;

HRESULT
CertBrowsePFX(HINSTANCE hInstance, HWND hDlg)
{
    HRESULT   hr;
    WCHAR    *pwszFileNameIn = NULL;
    WCHAR    *pwszFileNameOut = NULL;
    HWND      hCtrl = GetDlgItem(hDlg, IDC_PFX_FILENAME);

    hr = myUIGetWindowText(hCtrl, &pwszFileNameIn);
    _JumpIfError(hr, error, "myUIGetWindowText");

    hr = myGetOpenFileName(
             hDlg,
             hInstance,
             IDS_IMPORT_PFX_TITLE,
             IDS_PFX_FILE_FILTER,
             0, // no def ext
             OFN_PATHMUSTEXIST | OFN_HIDEREADONLY,
             pwszFileNameIn,
             &pwszFileNameOut);
    _JumpIfError(hr, error, "myGetOpenFileName");

    if (NULL != pwszFileNameOut)
    {
        SetWindowText(hCtrl, pwszFileNameOut);
    }

    hr = S_OK;
error:
    if (NULL != pwszFileNameOut)
    {
        LocalFree(pwszFileNameOut);
    }
    if (NULL != pwszFileNameIn)
    {
        LocalFree(pwszFileNameIn);
    }
    return hr;
}

HRESULT
GetPFXInfo(
    HWND               hDlg,
    CERTPFXIMPORTINFO* pCertPfxImportInfo)
{
    HRESULT hr;
    GetWindowText(GetDlgItem(hDlg, IDC_PFX_FILENAME),
                  pCertPfxImportInfo->pwszFileName,
                  pCertPfxImportInfo->dwFileNameSize);
    if (0x0 == pCertPfxImportInfo->pwszFileName[0])
    {
        // file can't empty
        hr = E_INVALIDARG;
        CertWarningMessageBox(
            pCertPfxImportInfo->hInstance,
            pCertPfxImportInfo->fUnattended,
            hDlg,
            IDS_ERR_EMPTYPFXFILE,
            0,
            NULL);
        SetFocus(GetDlgItem(hDlg, IDC_PFX_FILENAME));
        goto error;
    }
    GetWindowText(GetDlgItem(hDlg, IDC_PFX_PASSWORD),
                  pCertPfxImportInfo->pwszPassword,
                  pCertPfxImportInfo->dwPasswordSize);
    hr = S_OK;
error:
    return hr;
}

INT_PTR CALLBACK
CertPFXFilePasswordProc(
    HWND hDlg, 
    UINT iMsg, 
    WPARAM wParam, 
    LPARAM lParam) 
{
    HRESULT hr;
    BOOL  ret = FALSE;
    int   id = IDCANCEL;
    static CERTPFXIMPORTINFO *pCertPfxImportInfo = NULL;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            pCertPfxImportInfo = (CERTPFXIMPORTINFO*)lParam;
            ret = TRUE;
        break;
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_PFX_FILENAME:
                break;
                case IDC_PFX_PASSWORD:
                break;
                case IDC_PFX_BROWSE:
                    CertBrowsePFX(pCertPfxImportInfo->hInstance, hDlg);
                    ret = TRUE;
                break;
                case IDOK:
                    hr = GetPFXInfo(hDlg, pCertPfxImportInfo);
                    if (S_OK != hr)
                    {
                        break;
                    }
                    id = IDOK;
                case IDCANCEL:
                    ret = EndDialog(hDlg, id);
                break;
            }
        break;
        default:
        ret = FALSE;
    }
    return ret;
}
 
int
CertGetPFXFileAndPassword(
    IN HWND       hwnd,
    IN HINSTANCE  hInstance,
    IN BOOL       fUnattended,
    IN OUT WCHAR *pwszFileName,
    IN DWORD      dwFileNameSize,
    IN OUT WCHAR *pwszPassword,
    IN DWORD      dwPasswordSize)
{
    CERTPFXIMPORTINFO    CertPfxImportInfo =
        {hInstance, fUnattended,
         pwszFileName, dwFileNameSize,
         pwszPassword, dwPasswordSize};

    return (int) DialogBoxParam(hInstance,
              MAKEINTRESOURCE(IDD_PFXIMPORT),
              hwnd,
              CertPFXFilePasswordProc,
              (LPARAM)&CertPfxImportInfo);
}

//--------------------------------------------------------------------
HRESULT
ImportPFXAndUpdateCSPInfo(
    IN const HWND    hDlg,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    int nDlgRet;
    BOOL bRetVal;
    DWORD dwVerificationFlags;
    BOOL bSelfSigned;
    CSP_HASH * pHash;
    WCHAR wszName[MAX_PATH];
    WCHAR wszPassword[MAX_PATH];
    CSP_INFO * pCSPInfo;
    DWORD dwCSPInfoSize;
    CASERVERSETUPINFO * pServer=pComp->CA.pServer;

    // variables that must be cleaned up
    CRYPT_KEY_PROV_INFO *pCertKeyProvInfo = NULL;
    CERT_CONTEXT const *pSavedLeafCert = NULL;

    wszName[0] = L'\0';

    // get file name & password
    if(pComp->fUnattended)
    {
        CSASSERT(NULL!=pServer->pwszPFXFile);

        if(MAX_PATH<=wcslen(pServer->pwszPFXFile)||
           NULL!=pServer->pwszPFXPassword && 
           MAX_PATH<=wcslen(pServer->pwszPFXPassword))
        {
            hr = ERROR_BAD_PATHNAME;
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_FILE_OR_PASSWORD_TOO_LONG,
                    0,
                    NULL);
            _JumpError(hr, error, "PFX file name or password is too long");
        }

        wcscpy(wszName, pServer->pwszPFXFile);
        wcscpy(wszPassword, 
            pServer->pwszPFXPassword?pServer->pwszPFXPassword:L"");

        if (NULL == pServer->pCSPInfoList)
        {
            hr = GetCSPInfoList(&pServer->pCSPInfoList);
            _JumpIfError(hr, error, "GetCSPInfoList");
        }
    }
    else{
        nDlgRet = CertGetPFXFileAndPassword(
                                    hDlg,
                                    pComp->hInstance,
                                    pComp->fUnattended,
                                    wszName,
                                    sizeof(wszName)/sizeof(WCHAR),
                                    wszPassword,
                                    sizeof(wszPassword)/sizeof(WCHAR));
        if (IDOK != nDlgRet)
        {
            // cancel
            hr=HRESULT_FROM_WIN32(ERROR_CANCELLED);
            _JumpError(hr, error, "CertGetPFXFileAndPassword canceled");
        }
    }

    // import pkcs12
    hr=myCertServerImportPFX(
               wszName,
               wszPassword,
               FALSE,
               NULL,
               NULL,
               &pSavedLeafCert);
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD)==hr)
        {

            // tell the user that their password was invalid
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_INVALID_PASSWORD,
                    0,
                    NULL);
            _JumpError(hr, error, "myCertServerImportPFX");

        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
        {

            if(pComp->fUnattended)
            {
                nDlgRet=IDYES;
            }
            else
            {
                // confirm from user that they want to overwrite
                // the existing key and cert
                nDlgRet=CertMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hDlg,
                            IDS_PFX_KEYANDCERTEXIST,
                            0,
                            MB_YESNO | MB_ICONWARNING | CMB_NOERRFROMSYS,
                            NULL);
            }
            if (IDYES==nDlgRet)
            {
                hr=myCertServerImportPFX(
                           wszName,
                           wszPassword,
                           TRUE,
                           NULL,
                           NULL, 
                           &pSavedLeafCert);
                _JumpIfError(hr, errorMsg, "myCertServerImportPFX");
            }
            else
            {
                // cancel
                hr=HRESULT_FROM_WIN32(ERROR_CANCELLED);
                _JumpError(hr, error, "myCertServerImportPFX canceled");
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
        {
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_PATH_INVALID,
                    0,
                    wszName);
            _JumpError(hr, error, "myCertServerImportPFX");
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_PFX_FILE_NOT_FOUND,
                    0,
                    wszName);
            _JumpError(hr, error, "myCertServerImportPFX");
        }
        else if (HRESULT_FROM_WIN32(CRYPT_E_SELF_SIGNED) == hr)
        {
            // this cert is not appropriate for this CA type (no CA certs found at all)
            CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_PFX_WRONG_SELFSIGN_TYPE,
                S_OK, // don't show an error number
                NULL);
            _JumpError(hr, error, "This cert is not appropriate for this CA type");
        }
        else
        {
            // import failed for some other reason
            _JumpError(hr, errorMsg, "myCertServerImportPFX");
        }
    }

    // PFX import was successful. The cert is in the machine's MY store.
    CSASSERT(NULL!=pSavedLeafCert);

    // The following things have been verified by myCertServerImportPFX
    //  * The cert has an AT_SIGNATURE key
    //  * The key in the store matches the one on the cer
    //  * The cert is not expired
    //
    // We still need to check:
    //  * self-signed or not
    //  * verify chain

    // Note: IT IS VERY IMPORTANT that pfx import maintains all the
    //   invariants about CSP, key container, hash, cert validity, etc.
    //   that the rest of the UI maintains.

    // get key prov info from cert
    bRetVal=myCertGetCertificateContextProperty(
        pSavedLeafCert,
        CERT_KEY_PROV_INFO_PROP_ID,
        CERTLIB_USE_LOCALALLOC,
        (void **)&pCertKeyProvInfo,
        &dwCSPInfoSize);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, errorMsg, "myCertGetCertificateContextProperty");
    }

    // find our description of the CSP
    pCSPInfo=findCSPInfoFromList(pServer->pCSPInfoList,
        pCertKeyProvInfo->pwszProvName,
        pCertKeyProvInfo->dwProvType);
    CSASSERT(NULL!=pCSPInfo);
    if (pCSPInfo == NULL) // we don't have this CSP enumerated in our UI
    {
        hr = CRYPT_E_NOT_FOUND;
        _JumpError(hr, errorMsg, "pCSPInfo NULL");
    }

    //
    // Looks like this key is good. Use it.
    //

    // Stop using the previous cert and key
    // delete previously created key container, if necessary.
    ClearKeyContainerName(pServer);

    // update the CSP
    //   note: CSP, key container, and hash must all be consistent!
    pServer->pCSPInfo=pCSPInfo;

    hr = DetermineDefaultHash(pServer);
    _JumpIfError(hr, error, "DetermineDefaultHash");
    
    // save the name of the key container
    hr=SetKeyContainerName(pServer, pCertKeyProvInfo->pwszContainerName);
    _JumpIfError(hr, error, "SetKeyContainerName");

    //  See if we can use the cert

    // verify to make sure no cert in chain is revoked, but don't kill yourself if offline
    hr=myVerifyCertContext(
        pSavedLeafCert,
        CA_VERIFY_FLAGS_IGNORE_OFFLINE,
        0,
        NULL,
        HCCE_LOCAL_MACHINE,
        NULL,
        NULL);
    _JumpIfError(hr, errorMsg, "myVerifyCertContext");

    // See if this cert appropriately is self-signed or not.
    // A root CA cert must be self-signed, while
    // a subordinate CA cert must not be self-signed.
    hr=IsCertSelfSignedForCAType(pServer, pSavedLeafCert, &bRetVal);
    _JumpIfError(hr, errorMsg, "IsCertSelfSignedForCAType");
    if (FALSE==bRetVal) {

        // this cert is not appropriate for this CA type
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PFX_WRONG_SELFSIGN_TYPE,
            S_OK, // don't show an error number
            NULL);

        hr=CRYPT_E_SELF_SIGNED;
        _JumpError(hr, error, "This cert is not appropriate for this CA type");
    }

    //
    // Looks like this cert is good. Use it.
    //

    // save the cert and update the hash algorithm
    hr=SetExistingCertToUse(pServer, pSavedLeafCert);
    _JumpIfError(hr, error, "SetExistingCertToUse");
    pSavedLeafCert=NULL;

    hr=S_OK;

errorMsg:
    if (FAILED(hr)) {
        // an error occurred while trying to import the PFX file
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_ERR_IMPORTPFX,
            hr,
            NULL);
    }

error:
    CSILOG(
        hr,
        IDS_LOG_IMPORTPFX,
        L'\0' == wszName[0]? NULL : wszName,
        NULL,
        NULL);
    if (NULL != pSavedLeafCert)
    {
        CertFreeCertificateContext(pSavedLeafCert);
    }
    if (NULL != pCertKeyProvInfo)
    {
        LocalFree(pCertKeyProvInfo);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\dssetup.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dssetup.h
//
//--------------------------------------------------------------------------

#ifndef __DSSETUP_H__
#define __DSSETUP_H__

//+------------------------------------------------------------------------
//
//  File:	dssetup.h
// 
//  Contents:	Header file for DS setup utility functions.
//
//  Functions:
//
//  History:	1/98	xtan	Created
//
//-------------------------------------------------------------------------

BOOL IsDSAvailable(VOID);
HRESULT CreateCertDSHierarchy(VOID);
HRESULT InitializeCertificateTemplates(VOID);
HRESULT AddCAMachineToCertPublishers(VOID);
HRESULT RemoveCAMachineFromCertPublishers(VOID);

HRESULT
RemoveCAInDS(
    IN WCHAR const *pwszSanitizedName);

BOOL
IsCAExistInDS(
    IN WCHAR const *pwszSanitizedName);

HRESULT CurrentUserCanInstallCA(bool& fCanInstall);

#endif // __SETUPUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\reg.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        reg.cpp
//
// Contents:    certsrv setup reg apis
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <assert.h>
#include <shlwapi.h>

#define __dwFILE__	__dwFILE_OCMSETUP_REG_CPP__

DWORD
mySHCopyKey(
    IN HKEY hkeySrc,
    IN LPCWSTR wszSrcSubKey,
    IN HKEY hkeyDest,
    IN DWORD fReserved)
{
    DWORD err;

    __try
    {
	err = SHCopyKey(hkeySrc, wszSrcSubKey, hkeyDest, fReserved);
	_LeaveIfError(err, "SHCopyKey");
    }
    __except(err = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(err);
}


DWORD
mySHDeleteKey(
    IN HKEY hkey,
    IN LPCWSTR pszSubKey)
{
    DWORD err;

    __try
    {
	err = SHDeleteKey(hkey, pszSubKey);
	_LeaveIfError(err, "SHDeleteKey");
    }
    __except(err = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(err);
}


LONG
myRegRenameKey(
  HKEY hKey,        // handle to an open key
  LPCTSTR lpSrcKey, // address of old name of subkey
  LPCTSTR lpDesKey, // address of new name of subkey
  PHKEY phkResult)   // address of buffer for opened handle of new subkey
{
	LONG lerr;
	HKEY hDesKey = NULL;

	if (NULL == lpSrcKey || NULL == lpDesKey)
	{
		lerr = ERROR_INVALID_PARAMETER;
		goto error;
	}
	
	// open destination key sure it doesn't exist
	lerr = RegOpenKeyEx(
					hKey,
					lpDesKey,
					0,
					KEY_ALL_ACCESS,
					&hDesKey);
	if (ERROR_SUCCESS == lerr)
	{
		// destination exists, stop
		lerr = ERROR_FILE_EXISTS;
		goto error;
	}
	else if (ERROR_FILE_NOT_FOUND != lerr)
	{
		goto error;
	}
	assert(NULL == hDesKey);

	lerr = RegCreateKeyEx(
				hKey,
				lpDesKey,
				0,
				NULL,
				REG_OPTION_NON_VOLATILE,
				KEY_ALL_ACCESS,
				NULL,
				&hDesKey,
				NULL);
	if (ERROR_SUCCESS != lerr)
	{
		goto error;
	}

    lerr = mySHCopyKey(hKey, lpSrcKey, hDesKey, 0);
    if (ERROR_SUCCESS != lerr)
    {
        goto error;
    }

    lerr = mySHDeleteKey(hKey, lpSrcKey);
    if (ERROR_SUCCESS != lerr)
    {
        goto error;
    }

	if (NULL != phkResult)
	{
		*phkResult = hDesKey;
		hDesKey = NULL;
	}

	// done
	lerr = ERROR_SUCCESS;
error:
	if (NULL != hDesKey)
	{
		RegCloseKey(hDesKey);
	}
	return lerr;
}


HRESULT
myRenameCertRegKey(
    IN WCHAR const *pwszSrcCAName,
    IN WCHAR const *pwszDesCAName)
{
    HRESULT  hr;
    WCHAR *pwszSrcPath = NULL;
    WCHAR *pwszDesPath = NULL;

    if (0 == lstrcmpi(pwszSrcCAName, pwszDesCAName))
    {
        // destination is the same as source, done
        goto done;
    }

    hr = myFormCertRegPath(pwszSrcCAName, NULL, NULL, TRUE, &pwszSrcPath);
    _JumpIfError(hr, error, "formCertRegPath");

    hr = myFormCertRegPath(pwszDesCAName, NULL, NULL, TRUE, &pwszDesPath);
    _JumpIfError(hr, error, "formCertRegPath");

    hr = myRegRenameKey(
                HKEY_LOCAL_MACHINE,
                pwszSrcPath,
                pwszDesPath,
                NULL);
    if ((HRESULT) ERROR_SUCCESS != hr)
    {
        hr = HRESULT_FROM_WIN32(hr);
        _JumpError(hr, error, "myRegMoveKey");
    }

done:
    hr = S_OK;
error:
    if (NULL != pwszSrcPath)
    {
        LocalFree(pwszSrcPath);
    }
    if (NULL != pwszDesPath)
    {
        LocalFree(pwszDesPath);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\regd.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        regd.h
//
// Contents:    Helper functions registering and unregistering a component.
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------
#ifndef __Regd_H__
#define __Regd_H__

// This function will register a component in the Registry.
HRESULT
RegisterDcomServer(
    const CLSID& clsid, 
    const WCHAR *szFriendlyName,
    const WCHAR *szVerIndProgID,
    const WCHAR *szProgID);

// This function will unregister a component
HRESULT
UnregisterDcomServer(
    const CLSID& clsid,
    const WCHAR *szVerIndProgID,
    const WCHAR *szProgID);

HRESULT
RegisterDcomApp(
    const CLSID& clsid);

VOID
UnregisterDcomApp(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\regd.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        regd.cpp
//
// Contents:    registry functions for DCOM services
//
// History:     July-97       xtan created
//
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop

#include <objbase.h>
#include <assert.h>

#include "regd.h"


#define __dwFILE__	__dwFILE_OCMSETUP_REGD_CPP__


// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39;

extern WCHAR g_wszServicePath[MAX_PATH];

BYTE g_pNoOneLaunchPermission[] = {
  0x01,0x00,0x04,0x80,0x34,0x00,0x00,0x00,
  0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x14,0x00,0x00,0x00,0x02,0x00,0x20,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x3c,0x00,0xb9,0x00,0x07,0x00,0x03,0x00,
  0x00,0x23,0x10,0x00,0x01,0x05,0x00,0x00,
  0x00,0x00,0x00,0x05,0x01,0x05,0x00,0x00,
  0x00,0x00,0x00,0x05,0x15,0x00,0x00,0x00,
  0xa0,0x5f,0x84,0x1f,0x5e,0x2e,0x6b,0x49,
  0xce,0x12,0x03,0x03,0xf4,0x01,0x00,0x00,
  0x01,0x05,0x00,0x00,0x00,0x00,0x00,0x05,
  0x15,0x00,0x00,0x00,0xa0,0x5f,0x84,0x1f,
  0x5e,0x2e,0x6b,0x49,0xce,0x12,0x03,0x03,
  0xf4,0x01,0x00,0x00};

BYTE g_pEveryOneAccessPermission[] = {
  0x01,0x00,0x04,0x80,0x34,0x00,0x00,0x00,
  0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x14,0x00,0x00,0x00,0x02,0x00,0x20,0x00,
  0x01,0x00,0x00,0x00,0x00,0x00,0x18,0x00,
  0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,
  0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x01,0x05,0x00,0x00,
  0x00,0x00,0x00,0x05,0x15,0x00,0x00,0x00,
  0xa0,0x65,0xcf,0x7e,0x78,0x4b,0x9b,0x5f,
  0xe7,0x7c,0x87,0x70,0x36,0xbb,0x00,0x00,
  0x01,0x05,0x00,0x00,0x00,0x00,0x00,0x05,
  0x15,0x00,0x00,0x00,0xa0,0x65,0xcf,0x7e,
  0x78,0x4b,0x9b,0x5f,0xe7,0x7c,0x87,0x70,
  0x36,0xbb,0x00,0x00 };


//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//

HRESULT
setKeyAndValue(
    const WCHAR *wszKey,
    const WCHAR *wszSubkey,
    const WCHAR *wszValueName,
    const WCHAR *wszValue)
{
    HKEY hKey = NULL;
    HRESULT hr;
    WCHAR wszKeyBuf[1024] = L"";

    // Copy keyname into buffer.
    wcscpy(wszKeyBuf, wszKey);

    // Add subkey name to buffer.
    if (wszSubkey != NULL)
    {
	wcscat(wszKeyBuf, L"\\");
	wcscat(wszKeyBuf, wszSubkey);
    }

    // Create and open key and subkey.
    hr = RegCreateKeyEx(
		    HKEY_CLASSES_ROOT,
		    wszKeyBuf,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    NULL);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // Set the Value.
    if (NULL != wszValue)
    {
	RegSetValueEx(
		    hKey,
		    wszValueName,
		    0,
		    REG_SZ,
		    (BYTE *) wszValue,
		    (wcslen(wszValue) + 1) * sizeof(WCHAR));
	_JumpIfError(hr, error, "RegSetValueEx");
    }

error:
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    return(hr);
}


HRESULT
setCertSrvPermission(
    const WCHAR *wszKey)
{
    HKEY hKey = NULL;
    HRESULT hr;

    // create and open key
    hr = RegCreateKeyEx(
		    HKEY_CLASSES_ROOT,
		    wszKey,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    NULL);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // set access permission
    hr = RegSetValueEx(
		    hKey,
		    L"AccessPermission",
		    0,
		    REG_BINARY,
		    g_pEveryOneAccessPermission,
		    sizeof(g_pEveryOneAccessPermission));
    _JumpIfError(hr, error, "RegSetValueEx");

    // set access permission
    hr = RegSetValueEx(
		    hKey,
		    L"LaunchPermission",
		    0,
		    REG_BINARY,
		    g_pNoOneLaunchPermission,
		    sizeof(g_pNoOneLaunchPermission));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    return(hr);
}

// Convert a CLSID to a char string.
VOID
CLSIDtochar(
    const CLSID& clsid,
    WCHAR *wszCLSID,
    int length)
{
    HRESULT hr;
    LPOLESTR wszTmpCLSID = NULL;

    assert(length >= CLSID_STRING_SIZE);

    // Get CLSID
    hr = StringFromCLSID(clsid, &wszTmpCLSID);
    assert(S_OK == hr);

    if (S_OK == hr)
        wcscpy(wszCLSID, wszTmpCLSID);
    else
        wszCLSID[0] = L'\0';

    // Free memory.
    CoTaskMemFree(wszTmpCLSID);
}


// Determine if a particular subkey exists.
//
BOOL
SubkeyExists(
    const WCHAR *wszPath,	// Path of key to check
    const WCHAR *wszSubkey)	// Key to check
{
    HRESULT hr;
    HKEY hKey;
    WCHAR wszKeyBuf[80] = L"";

    // Copy keyname into buffer.
    wcscpy(wszKeyBuf, wszPath);

    // Add subkey name to buffer.
    if (wszSubkey != NULL)
    {
	wcscat(wszKeyBuf, L"\\");
	wcscat(wszKeyBuf, wszSubkey);
    }

    // Determine if key exists by trying to open it.
    hr = RegOpenKeyEx(
		    HKEY_CLASSES_ROOT,
		    wszKeyBuf,
		    0,
		    KEY_ALL_ACCESS,
		    &hKey);

    if (S_OK == hr)
    {
	RegCloseKey(hKey);
    }
    return(S_OK == hr);
}


// Delete a key and all of its descendents.
//

HRESULT
recursiveDeleteKey(
    HKEY hKeyParent,           // Parent of key to delete
    const WCHAR *wszKeyChild)  // Key to delete
{
    HRESULT hr;
    FILETIME time;
    WCHAR wszBuffer[MAX_PATH];
    DWORD dwSize;

    HKEY hKeyChild = NULL;

    // Open the child.
    hr = RegOpenKeyEx(hKeyParent, wszKeyChild, 0, KEY_ALL_ACCESS, &hKeyChild);
    _JumpIfError2(hr, error, "RegOpenKeyEx", ERROR_FILE_NOT_FOUND);

    // Enumerate all of the decendents of this child.

    while (TRUE)
    {
	dwSize = sizeof(wszBuffer)/sizeof(wszBuffer[0]);
	hr = RegEnumKeyEx(
			hKeyChild,
			0,
			wszBuffer,
			&dwSize,
			NULL,
			NULL,
			NULL,
			&time);
	if (S_OK != hr)
	{
	    break;
	}

	// Delete the decendents of this child.
	hr = recursiveDeleteKey(hKeyChild, wszBuffer);
	_JumpIfError(hr, error, "recursiveDeleteKey");
    }

    // Delete this child.
    hr = RegDeleteKey(hKeyParent, wszKeyChild);
    _JumpIfError(hr, error, "RegDeleteKey");

error:
    if (NULL != hKeyChild)
    {
	// Close the child.
	RegCloseKey(hKeyChild);
    }
    return(myHError(hr));
}

///////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT
RegisterDcomServer(
    const CLSID& clsid,			// Class ID
    const WCHAR *wszFriendlyName,	// Friendly Name
    const WCHAR *wszVerIndProgID,	// Programmatic
    const WCHAR *wszProgID)      	// IDs
{
    HRESULT hr;

    // Convert the CLSID into a char.
    WCHAR wszCLSID[CLSID_STRING_SIZE];
    CLSIDtochar(clsid, wszCLSID, sizeof(wszCLSID)/sizeof(WCHAR));

    // Build the key CLSID\\{...}
    WCHAR wszKey[64];

    wcscpy(wszKey, L"AppID\\");
    wcscat(wszKey, wszCLSID);

    // Add App IDs
    hr = setKeyAndValue(wszKey, NULL, NULL, wszFriendlyName);
    _JumpIfError(hr, error, "setKeyAndValue");

    // run as interactive
    hr = setKeyAndValue(wszKey, NULL, L"LocalService", wszSERVICE_NAME);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setCertSrvPermission(wszKey);
    _JumpIfError(hr, error, "setCertSrvPermission");

    wcscpy(wszKey, L"CLSID\\");
    wcscat(wszKey, wszCLSID);

    // Add the CLSID to the registry.
    hr = setKeyAndValue(wszKey, NULL, NULL, wszFriendlyName);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add application ID
    hr = setKeyAndValue(wszKey, NULL, L"AppID", wszCLSID);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add the server filename subkey under the CLSID key.
    hr = setKeyAndValue(wszKey, L"LocalServer32", NULL, g_wszServicePath);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add the ProgID subkey under the CLSID key.
    hr = setKeyAndValue(wszKey, L"ProgID", NULL, wszProgID);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add the version-independent ProgID subkey under CLSID key.
    hr = setKeyAndValue(wszKey, L"VersionIndependentProgID", NULL, wszVerIndProgID);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
    hr = setKeyAndValue(wszVerIndProgID, NULL, NULL, wszFriendlyName);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszVerIndProgID, L"CLSID", NULL, wszCLSID);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszVerIndProgID, L"CurVer", NULL, wszProgID);
    _JumpIfError(hr, error, "setKeyAndValue");

    // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
    hr = setKeyAndValue(wszProgID, NULL, NULL, wszFriendlyName);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszProgID, L"CLSID", NULL, wszCLSID);
    _JumpIfError(hr, error, "setKeyAndValue");

error:
    return(hr);
}

//
// Remove the component from the registry.
//

HRESULT
UnregisterDcomServer(
    const CLSID& clsid,			// Class ID
    const WCHAR *wszVerIndProgID,	// Programmatic
    const WCHAR *wszProgID)		// IDs
{
    HRESULT hr;

    // Convert the CLSID into a char.
    WCHAR wszCLSID[CLSID_STRING_SIZE];
    CLSIDtochar(clsid, wszCLSID, sizeof(wszCLSID)/sizeof(WCHAR));

    // Build the key CLSID\\{...}
    WCHAR wszKey[80];
    wcscpy(wszKey, L"CLSID\\");
    wcscat(wszKey, wszCLSID);

    // Check for a another server for this component.
    if (SubkeyExists(wszKey, L"InprocServer32"))
    {
	// Delete only the path for this server.
	wcscat(wszKey, L"\\LocalServer32");
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
	assert(hr == S_OK);
    }
    else
    {
	// Delete all related keys.
	// Delete the CLSID Key - CLSID\{...}
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
	assert(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);

	// Delete the version-independent ProgID Key.
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszVerIndProgID);
	assert(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);

	// Delete the ProgID key.
	hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszProgID);
	assert(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
    }
    wcscpy(wszKey, L"AppID\\");
    wcscat(wszKey, wszCLSID);
    hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
    assert(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);

    return(hr);
}


HRESULT
RegisterDcomApp(const CLSID& clsid)
{
    HRESULT hr;

    // Convert the CLSID into a char.
    WCHAR wszCLSID[CLSID_STRING_SIZE];
    CLSIDtochar(clsid, wszCLSID, sizeof(wszCLSID)/sizeof(WCHAR));

    WCHAR wszKey[64];

    wcscpy(wszKey, L"AppID\\");
    wcscat(wszKey, wszCERTSRVEXENAME);

    // Add App IDs
    hr = setKeyAndValue(wszKey, NULL, NULL, NULL);
    _JumpIfError(hr, error, "setKeyAndValue");

    hr = setKeyAndValue(wszKey, NULL, L"AppId", wszCLSID);
    _JumpIfError(hr, error, "setKeyAndValue");

error:
    return(hr);
}


void
UnregisterDcomApp()
{
    HRESULT hr;
    WCHAR wszKey[MAX_PATH];

    wcscpy(wszKey, L"AppID\\");
    wcscat(wszKey, wszCERTSRVEXENAME);
    hr = recursiveDeleteKey(HKEY_CLASSES_ROOT, wszKey);
    assert(S_OK == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\res.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       res.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by csocm.rc
//

// Important, reserve 900-999 for certlib.rc, 200-299 for setupids.h

#define IDI_APP                         201
#define IDI_PRODUCT                     202
#define IDB_APP                         221
#define IDB_PRODUCT                     222
#define IDB_WELCOME                     223

// strings from Cert Server 1.0:
#define IDS_STARTMENU_CERTHIER_LINKNAME 320
#define IDS_STARTMENU_CERTREQ_LINKNAME  321
#define IDS_STARTMENU_CERTSERVER        322
#define IDS_STARTMENU_NEWCRL_LINKNAME   323

#define IDS_ADVANCE_INVALIDKEYLENGTH    330
#define IDS_ADVANCE_KEYLENGTHOUTOFRANGE 331
#define IDS_ADVANCE_NEGATIVEKEYLENGTH   332
#define IDS_ADVANCE_SUBTITLE            333
#define IDS_ADVANCE_TITLE               334
#define IDS_ASK_CREATE_DIRECTORY        335
#define IDS_CALENSTRERR                 336
#define IDS_CANULLSTRERR                337
#define IDS_CAREQUEST_SUBTITLE          338
#define IDS_CAREQUEST_TITLE             339
#define IDS_CATYPE_DES_ENTERPRISE_ROOTCA 340
#define IDS_CATYPE_DES_ENTERPRISE_SUBCA  341
#define IDS_CATYPE_DES_STANDALONE_ROOTCA 342
#define IDS_CATYPE_DES_STANDALONE_SUBCA  343
#define IDS_CATYPE_SUBTITLE             344
#define IDS_CATYPE_TITLE                345
#define IDS_CA_SERVICEDESCRIPTION       346
#define IDS_CA_SERVICEDISPLAYNAME       347
#define IDS_CERTCONFIG_FOLDERDESCR      348
#define IDS_CLIENT_NOCA                 349
#define IDS_CLIENT_NOCOMPUTER           350
#define IDS_CLIENT_SUBTITLE             351
#define IDS_CLIENT_TITLE                352
#define IDS_COMPUTERLENSTRERR           354
#define IDS_COMPUTERNULLSTRERR          355
#define IDS_CONFIG_PICKER_PROMPT        356
#define IDS_CONFIG_PICKER_TITLE         357
#define IDS_ERR_ADDSOURCETOREGISTRY     358
#define IDS_ERR_ANALYSIS_CA             359
#define IDS_ERR_BUILDCERT               360
#define IDS_ERR_BUILDCERTREQUEST        361
#define IDS_FINAL_ERROR_TEXT            362
#define IDS_ERR_CERTSRV_SETUP_FAIL      363
#define IDS_ERR_CREATECERTSRVFILE       364
#define IDS_ERR_CREATELINK              365
#define IDS_ERR_CREATESERVICE           366
#define IDS_ERR_DELETESERVICE           367
#define IDS_ERR_DLLFUNCTION_CALL        368
#define IDS_ERR_EMPTYCANAME             369
#define IDS_ERR_EMPTYPFXFILE            370
#define IDS_ERR_FATAL_GENKEY            371
#define IDS_ERR_IMPORTPFX               372
#define IDS_ERR_INVALIDHASH             373
#define IDS_ERR_LOADICERTCONFIG         374
#define IDS_ERR_NETUSERMODALSGET        375
//#define IDS_UNUSED            	376
#define IDS_ERR_NOT_ADM                 377
#define IDS_ERR_UNSUPPORTEDHASH         378
#define IDS_ERR_WRITECONFIGFILE         379
#define IDS_IDINFO_CAEXISTINDS          380
#define IDS_IDINFO_DESCRIPTIONLENSTRERR     381
#define IDS_IDINFO_COUNTRYLENSTRERR     382
#define IDS_IDINFO_DETERMINEDBYPCA      383
#define IDS_IDINFO_EMAILLENSTRERR       384
#define IDS_IDINFO_INVALID_COUNTRYCODE  385
#define IDS_IDINFO_INVALID_COUNTRYCODE_LEN 386
#define IDS_IDINFO_INVALID_VALIDITY     387
#define IDS_IDINFO_LOCALITYLENSTRERR    388
#define IDS_IDINFO_NAMELENSTRERR        389
#define IDS_IDINFO_NAMENULLSTRERR       390
#define IDS_IDINFO_ORGLENSTRERR         391
#define IDS_IDINFO_ORGUNITLENSTRERR     392
#define IDS_IDINFO_STATELENSTRERR       393
#define IDS_IDINFO_SUBTITLE             394
#define IDS_IDINFO_TITLE                395
#define IDS_IDINFO_VALIDITYNULLSTRERR   396
#define IDS_IMPORT_PFX_TITLE            397
#define IDS_INCOMPLETE_REQUEST          398
#define IDS_KEYGEN_GENERATING           399
#define IDS_KEYGEN_PROTECTING           400
#define IDS_KEYGEN_SUBTITLE             401
#define IDS_KEYGEN_TESTINGHASHANDKEY    402
#define IDS_KEYGEN_TITLE                403
#define IDS_KEY_INVALID                 404
#define IDS_PATH_TOO_LONG_CANAME        405
#define IDS_PFX_FILE_FILTER             406
#define IDS_PFX_FILE_NOT_FOUND          407
#define IDS_PFX_INVALID_PASSWORD        408
#define IDS_PFX_KEYANDCERTEXIST         409
#define IDS_PFX_PATH_INVALID            410
#define IDS_REQUESTFILELENSTRERR        411
#define IDS_REQUESTFILENULLSTRERR       412
#define IDS_STOP_W3SVC                  413
#define IDS_STORELOC_PARENTDIRMUSTEXIST 414
#define IDS_STORELOC_PATHTOOLONG        415
#define IDS_STORELOC_UNCMUSTEXIST       416
#define IDS_STORE_SUBTITLE              417
#define IDS_STORE_TITLE                 418
#define IDS_TODO_TITLE                  419
#define IDS_VALIDITY_DAY                420
#define IDS_VALIDITY_MONTH              421
#define IDS_VALIDITY_WEEK               422
#define IDS_VALIDITY_YEAR               423
#define IDS_WRN_DBFILEINUSE             425
#define IDS_WRN_OVERWRITEEXISTINGKEY    426
#define IDS_WRN_STORELOC_DB_FULLPATH    427
#define IDS_WRN_STORELOC_EXISTINGDB     428
#define IDS_WRN_STORELOC_LOG_FULLPATH   429
#define IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH 430
#define IDS_WRN_UNICODESTRINGENCODING   431

#define IDS_LOG_BEGIN                   433
#define IDS_LOG_END                     434
#define IDS_LOG_WAS_ENABLED             435
#define IDS_LOG_IS_ENABLED              436
#define IDS_LOG_INSTALL_STATE           437
#define IDS_LOG_CREATE_REQUEST          438
#define IDS_LOG_CREATE_CERTIFICATE      439
#define IDS_LOG_START_SERVICE           440
#define IDS_LOG_WEB_INCLUDE             441
#define IDS_LOG_INSTALL_CLIENT          442
#define IDS_LOG_INSTALL_SERVER          443
#define IDS_LOG_UPGRADE_TYPE            444
#define IDS_LOG_UPGRADE_CERT_STORE      445
#define IDS_LOG_UPGRADE_KEY_SECURITY    446
#define IDS_LOG_UPGRADE_SERVER          447
#define IDS_LOG_UPGRADE_CLIENT          448
#define IDS_LOG_SERVICE_STOPPED         449
#define IDS_LOG_SERVICE_STARTED         450
#define IDS_LOG_CREATE_CLIENT_REG       451
#define IDS_LOG_CREATE_SERVER_REG       452
#define IDS_LOG_UPGRADE_SERVER_REG      453
#define IDS_LOG_DLLS_UNREGISTERED       454
#define IDS_LOG_DLLS_REGISTERED         455
#define IDS_LOG_PROGRAM_GROUPS          456
#define IDS_LOG_CREATE_SERVICE          457
#define IDS_LOG_CANCEL_INSTALL          458
#define IDS_LOG_FUNCTION                459
#define IDS_LOG_UNATTENDED_ATTRIBUTE    460
#define IDS_LOG_CLIENT_UNATTENDED_ATTRIBUTES    461
#define IDS_LOG_SERVER_UNATTENDED_ATTRIBUTES    462
#define IDS_LOG_OPERATIONFLAGS          463
#define IDS_LOG_TODOLIST                464
#define IDS_LOG_POSTBASE                465
#define IDS_LOG_UNATTENDED              466
#define IDS_LOG_REGSTATE                467
#define IDS_LOG_SELECTIONSTATE          468
#define IDS_WELCOME_TITLE               469
#define IDS_FINAL_TITLE                 470
#define IDS_LOG_IMPORTPFX               471
#define IDS_ERR_CREATE_DIR              473
#define IDS_WRN_UNINSTALL_BOTH          474
#define IDS_WRN_UNINSTALL_CLIENT        475
#define IDS_PFX_WRONG_SELFSIGN_TYPE     476
#define IDS_CAREQUEST_REQUESTFILEPATH_MUSTEXIST     477
#define IDS_LOG_IGNORE_KEYLENGTH        478
#define IDS_CAREQUEST_REQUESTFILEPATH_DIREXISTS     479
#define IDS_PFX_FILE_OR_PASSWORD_TOO_LONG 480
#define IDS_ERR_UPGRADE_NOT_SUPPORTED   481
#define IDS_WRN_SERVER_ONLY             482
#define IDS_IDINFO_VALIDITYLENSTRERR    483
#define IDS_WRN_IDINFO_INVALIDDN        484

// HTML strings
#define IDS_HTML_CERTWEBDAT             510
#define IDS_HTML_NSREV                  511

#define IDS_IDINFO_DELETECERTIFICATES   512


#define IDC_CERTOUT_EXCHANGEEDIT        1000
#define IDC_CATYPE_DESCRIPTION_PROXY    1000
#define IDC_CERTOUT_SELFSIGNEDEDIT      1001
#define IDC_EXISTING_KEYS               1050
#define IDC_KEY_LIST                    1051

#define IDC_NOEDIT_COUNTRY              1100
#define IDC_NOEDIT_ORGANIZATION         1101
#define IDC_NOEDIT_ORGANIZATION_UNIT    1102
#define IDC_NOEDIT_CA_NAME              1103
#define IDC_NOEDIT_STATE                1104
#define IDC_NOEDIT_LOCALITY             1105
#define IDC_NOEDIT_CSP_NAME             1106
#define IDC_NOEDIT_HASH_ALGORITHM       1107
#define IDC_NOEDIT_CONTAINER_NAME       1108
#define IDC_NOEDIT_MACHINE_KEYSET       1109
#define IDC_NOEDIT_SHARED_FOLDER        1110
#define IDC_NOEDIT_SIGNATURE_CERT_NAME  1111
#define IDC_NOEDIT_EXCHANGE_CERT_NAME   1112
#define IDC_LIST_CAS                    1150
#define IDC_EXISTING_CA_NAME            1151
#define IDC_EXISTING_CSP_NAME           1152
#define IDC_EXISTING_HASH_ALGORITHM     1153
#define IDC_EXISTING_KEY_CONTAINER_NAME 1154
#define IDC_USE_EXISTING_CA             1155
#define IDC_USE_MODIFY_EXISTING_CA      1156

#define IDC_CHECK_USE_EXISTING_KEY      1200
#define IDC_LIST_EXISTING_KEY           1201

#define IDD_WIZIDINFOPAGE               1250
#define IDD_WIZKEYGENPAGE               1251
#define IDD_WIZADVANCEDPAGE             1252
#define IDD_WIZCATYPEPAGE               1254
#define IDD_WIZCAREQUESTPAGE            1257
#define IDD_WIZSTOREPAGE                1258
#define IDD_WIZCLIENTPAGE               1259
#define IDD_PFXIMPORT                   1260
#define IDD_WIZWELCOMEPAGE              1261
#define IDD_WIZFINALPAGE                1262

#define IDC_IDINFO_NAMEEDIT             1300
#define IDC_CERTSRV_BITMAP              1309
#define IDC_IDINFO_COMBO_VALIDITYSTRING 1310
#define IDC_IDINFO_EDIT_VALIDITYCOUNT   1311
#define IDC_IDINFO_EXPIRATION           1312
#define IDC_IDINFO_DETERMINEDBYPCA      1313
#define IDC_IDINFO_EXPIRATION_LABEL     1314
#define IDC_IDINFO_VPLABEL              1315

#define IDC_IDINFO_NAMEPREVIEW          1317
#define IDC_IDINFO_DNSUFFIXEDIT         1319


#define IDC_CATYPE_ENT_ROOT_CA          1350
#define IDC_CATYPE_ENT_SUB_CA           1351
#define IDC_CATYPE_STAND_ROOT_CA        1353
#define IDC_CATYPE_STAND_SUB_CA         1354
#define IDC_CATYPE_CA_DESCRIPTION       1355
#define IDC_CATYPE_CHECK_ADVANCE        1360
#define IDC_CATYPE_DESCRIPTION_ENTERPRISE 1366

#define IDC_ADVANCE_CSPLIST             1400
#define IDC_ADVANCE_HASHLIST            1401
#define IDC_ADVANCE_USEKEYCHECK         1402
#define IDC_ADVANCE_KEYLIST             1403
#define IDC_ADVANCE_KEY_LENGTH          1404
#define IDC_ADVANCE_IMPORT              1405
#define IDC_ADVANCE_USECERTCHECK        1406
#define IDC_ADVANCE_VIEWCERT            1407
#define IDC_ADVANCE_INTERACTIVECHECK    1408

#define IDC_CAREQUEST_SUBMITTOCA        1500
#define IDC_CAREQUEST_SAVETOFILE        1501
#define IDC_CAREQUEST_COMPUTERNAME      1502
#define IDC_CAREQUEST_CANAME            1503
#define IDC_CAREQUEST_CA_BROWSE         1504
#define IDC_CAREQUEST_FILE_BROWSE       1505
#define IDC_CAREQUEST_FILE              1506
#define IDC_CAREQUEST_CNLABEL           1507
#define IDC_CAREQUEST_PCALABEL          1508
#define IDC_CAREQUEST_FILELABEL         1509

#define IDC_COMPLETE_INFO               1550
#define IDC_FINAL_STATUS                1551

#define IDC_STORE_EDIT_SHAREDFOLDER     1600
#define IDC_STORE_EDIT_DB               1601
#define IDC_STORE_EDIT_LOG              1602
#define IDC_STORE_SHAREDBROWSE          1603
#define IDC_STORE_DBBROWSE              1604
#define IDC_STORE_LOGBROWSE             1605
#define IDC_STORE_KEEPDB                1607
#define IDC_STORE_USE_SHAREDFOLDER      1608

#define IDC_CLIENT_CANAME               1653
#define IDC_CLIENT_COMPUTERNAME         1654
#define IDC_CLIENT_BROWSECNFG           1655

#define IDC_PFX_FILENAME                1750
#define IDC_PFX_BROWSE                  1751
#define IDC_PFX_PASSWORD                1752

#define IDC_KEYGEN_PROGRESS_TEXT        1780
#define IDC_KEYGEN_PROGRESS             1781
#define IDS_LOG_CANAME                  1782
#define IDS_LOG_ORG                     1783
#define IDS_LOG_ORGUNIT                 1784
#define IDS_LOG_LOCALITY                1785
#define IDS_LOG_STATE                   1786
#define IDS_LOG_EMAIL                   1787
#define IDS_LOG_COUNTRY                 1788
#define IDS_LOG_DESCRIPTION             1789
#define IDS_LOG_SHAREDFOLDER            1790
#define IDS_LOG_DBDIR                   1791
#define IDS_LOG_DBLOGDIR                1792
#define IDS_LOG_COMPUTER                1793
#define IDS_LOG_REQUESTFILE             1794
#define IDS_LOG_VALIDITY                1795
#define IDS_LOG_CATYPE                  1796
#define IDS_LOG_KEYNAME                 1797
#define IDS_ERR_NONIA5DNSNAME           1798
#define IDS_WRN_DBSPECIALCHARACTERS     1799
#define IDS_WRN_NONAMECHANGE            1800
#define IDS_WRN_KEYNAMETOOLONG          1801
#define IDS_LOG_QUERYCHANGESELSTATE     1802
#define IDS_PATH_TOO_LONG_DIRECTORY     1803
#define IDS_LOG_BAD_CATYPE              1804
#define IDS_LOG_BAD_OR_MISSING_CANAME   1805
#define IDS_LOG_BAD_VALIDITY_PERIOD_STRING 1806
#define IDS_LOG_CA_MACHINE_REQUIRED     1807
#define IDS_LOG_CA_NAME_REQUIRED        1808
#define IDS_LOG_PING_PARENT_FAIL        1809
#define IDS_LOG_EMPTY_UNATTENDED_ATTRIBUTE 1810
#define IDS_LOG_PATH_CAFILE_BUILD_FAIL  1811
#define IDS_LOG_ENTERPRISE_NO_DS        1812
#define IDS_LOG_BAD_COUNTRY_LENGTH      1813
#define IDS_LOG_NO_CERT                 1814
#define IDS_LOG_REUSE_CERT_NO_REUSE_KEY 1815
#define IDS_LOG_REUSE_DB_WITHOUT_REUSE_CERT 1816
#define IDS_LOG_BAD_VALIDITY_PERIOD_COUNT 1817
#define IDS_LOG_REQUEST_FILE_TOO_LONG   1818
#define IDS_LOG_CANAME_TOO_LONG         1819
#define IDS_LOG_PATH_TOO_LONG_CANAME    1820
#define IDS_LOG_BAD_COUNTRY_CODE        1821
#define IDS_LOG_KEY_NOT_FOUND_IN_LIST   1822
#define IDS_LOG_DISABLE_WIZ_PAGE        1823
#define IDS_LOG_WIZ_PAGE_ERROR  	1824
#define IDS_LOG_UPGRADE_UNSUPPORTED    	1825
#define IDS_LOG_UPGRADE_WIN2000      	1826
#define IDS_LOG_UPGRADE_B2B     	1827

#define IDS_LARGEFONTSIZE       	1828
#define IDS_LARGEFONTNAME       	1829
#define IDC_TEXT_BIGBOLD        	1830
#define IDS_ILOG_SANITIZEDNAME		1831
#define IDS_ILOG_KEYCONTAINERNAME	1832

#define IDC_STATIC                      (-1)

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\setuput.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       setuput.h
//
//--------------------------------------------------------------------------

#ifndef __SETUPUT_H__
#define __SETUPUT_H__

//+------------------------------------------------------------------------
//
//  File:	setuput.h
// 
//  Contents:	Header file for setup utility functions.
//
//  Functions:
//
//  History:	04/20/97	JerryK	Created
//
//-------------------------------------------------------------------------

#define SERVERINSTALLTICKS	50
#define CA_DEFAULT_KEY_LENGTH_ROOT	2048
#define CA_DEFAULT_KEY_LENGTH_SUB	1024
#define wszCERTSRVEXENAME   L"certsrv.exe"

#define wszCERTSRVSECTION  L"certsrv"
#define wszSERVERSECTION  L"certsrv_server"
#define wszCLIENTSECTION  L"certsrv_client"

#define wszOLDDOCCOMPONENT  L"certsrv_doc"

#define wszREGKEYOCMSUBCOMPONENTS L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents"

#define wszREGKEYCERTSRVTODOLIST L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList\\CertSrv"

#define wszW3SVCNAME    L"W3Svc"

#define _JumpIfOutOfMemory(hr, label, pMem) \
    { \
        if (NULL == (pMem)) \
        { \
            (hr) = E_OUTOFMEMORY; \
            _JumpError((hr), label, "Out of Memory"); \
        } \
    }


#define IS_CLIENT_INSTALL	0x00000001
#define IS_CLIENT_REMOVE	0x00000002
#define IS_CLIENT_CHANGE	0x00000004
#define IS_CLIENT_UPGRADE	0x00000008
#define IS_CLIENT_ENABLED	0x00000010

#define IS_SERVER_INSTALL	0x00000100
#define IS_SERVER_REMOVE	0x00000200
#define IS_SERVER_CHANGE	0x00000400
#define IS_SERVER_UPGRADE	0x00000800
#define IS_SERVER_ENABLED	0x00001000

#define VP_MIN                  1
#define VP_MAX                  1000
#define VP_MAX_DAYS_WEEKS_MONTHS    9999

// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )


typedef enum {
    cscInvalid,
    cscTopLevel,
    cscServer,
    cscClient,
} CertSubComponent;


typedef struct _UNATTENDPARM
{
    WCHAR const  *pwszName;
    WCHAR	**ppwszValue;
} UNATTENDPARM;

typedef struct _SUBCOMP
{
    WCHAR const *pwszSubComponent;
    CertSubComponent cscSubComponent;
    DWORD InstallFlags;
    DWORD UninstallFlags;
    DWORD ChangeFlags;
    DWORD UpgradeFlags;
    DWORD EnabledFlags;
    DWORD SetupStatusFlags;
    BOOL  fDefaultInstallUnattend;
    BOOL  fInstallUnattend;
    UNATTENDPARM *aUnattendParm;
} SUBCOMP;

HRESULT InitCASetup(HWND, PER_COMPONENT_DATA *pComp);

DWORD
myDoPageRequest(
    IN PER_COMPONENT_DATA *pComp,
    IN WizardPagesType WhichOnes,
    IN OUT PSETUP_REQUEST_PAGES SetupPages);

VOID
FreeCAComponentInfo(PER_COMPONENT_DATA *pComp);

HRESULT
PrepareUnattendedAttributes(
    IN HWND         hwnd,
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp);

VOID
FreeCAGlobals(VOID);

HRESULT
HookUnattendedServerAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pServerComp);

HRESULT
HookUnattendedClientAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pClientComp);

SUBCOMP const *
LookupSubComponent(
    IN CertSubComponent SubComp);

HRESULT
EnableVRootsAndShares(
    IN BOOL fFileSharesOnly,
    IN BOOL fUpgrade,
    IN BOOL fServer,
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT
DisableVRootsAndShares(
    IN BOOL fFileSharesOnly);

HRESULT
InstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fServer);

HRESULT
PreUninstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fPreserveClient);

HRESULT
UninstallCore(
    IN HWND hwnd,
    OPTIONAL IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentCompleteBase,
    IN DWORD PerCentCompleteMax,
    IN BOOL fPreserveClient,
    IN BOOL fRemoveVD,
    IN BOOL fPreserveToDoList);

HRESULT
UpgradeServer(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp);

HRESULT
UpgradeClient(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp);

HRESULT CreateConfigFiles(WCHAR *pwszDirectoryPath,
    PER_COMPONENT_DATA *pComp, BOOL fRemove, HWND hwnd);

HRESULT myStringToAnsiFile(HANDLE hFile, LPCSTR psz, DWORD cch);
HRESULT myStringToAnsiFile(HANDLE hFile, LPCWSTR pwsz, DWORD cch);
HRESULT myStringToAnsiFile(HANDLE hFile, CHAR ch);

HRESULT
myGetEnvString(
    WCHAR **ppwszOut,
    WCHAR const *pwszVariable);

VOID
certocmBumpGasGauge(
    IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentComplete
    DBGPARM(IN WCHAR const *pwszSource));

HRESULT
UpdateSubComponentInstallStatus(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT StartCertsrvService(BOOL fSilent);

BOOL certocmIsEnabled(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmWasEnabled(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmInstalling(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmUninstalling(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
BOOL certocmPreserving(PER_COMPONENT_DATA *pComp, CertSubComponent SubComp);
HRESULT certocmRetrieveUnattendedText(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp);

SUBCOMP *
TranslateSubComponent(
    IN WCHAR const *pwszComponent,
    OPTIONAL IN WCHAR const *pwszSubComponent);

HRESULT
certocmReadInfString(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *pwszFile,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszName,
    IN OUT WCHAR **ppwszValue);

HRESULT
ImportPFXAndUpdateCSPInfo(
    IN const HWND    hDlg,
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT CreateProgramGroups(BOOL fClient,
                            PER_COMPONENT_DATA *pComp,
                            HWND hwnd);

HRESULT
LoadDefaultCAIDAttributes(
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT
LoadDefaultAdvanceAttributes(
    IN OUT CASERVERSETUPINFO* pServer);

HRESULT
BuildDBFileName(
    IN WCHAR const *pwszCAName,
    IN WCHAR const *pwszDBDirectory,
    OUT WCHAR **ppwszDBFile);

VOID
BuildPath(
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut,
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile);

HRESULT
GetDefaultDBDirectory(
    IN PER_COMPONENT_DATA *pComp,
    OUT WCHAR            **ppwszDir);

HRESULT
GetDefaultSharedFolder(
    OUT WCHAR **ppwszSharedFolder);

HRESULT 
StartAndStopService(
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND const   hwnd,
    IN WCHAR const *pwszServiceName,
    IN BOOL const   fStopService,
    IN BOOL const   fConfirm,
    IN int          iMsg,
    OUT BOOL       *pfServiceWasRunning);

HRESULT
FixCertsvcService(
    IN PER_COMPONENT_DATA *pComp);

HRESULT
DetermineServerCustomModule(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN BOOL  fPolicy);

HRESULT
DetermineServerUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT
DetermineClientUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp);


HRESULT CreateCertWebDatIncPage(IN PER_COMPONENT_DATA *pComp, IN BOOL bIsServer);


HRESULT
CancelCertsrvInstallation(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp);

HRESULT
BuildCACertFileName(
    IN HINSTANCE        hInstance,
    IN HWND             hwnd,
    IN BOOL             fUnattended,
    OPTIONAL IN WCHAR   *pwszSharedFolder,
    IN WCHAR           *pwszSanitizedName,
    OUT WCHAR         **ppwszCACertFile);

HRESULT
myRenameCertRegKey(
    IN WCHAR const *pwszSrcCAName,
    IN WCHAR const *pwszDesCAName);

bool IsValidPeriod(const CASERVERSETUPINFO *pServer);

HRESULT
CheckPostBaseInstallStatus(
    OUT BOOL *pfFinished);

// externals

extern BOOL   g_fShowErrMsg;
extern HINSTANCE g_hInstance;
extern BOOL g_fW3SvcRunning;
extern WCHAR *g_pwszArgvPath;
extern WCHAR *g_pwszNoService;
#if DBG_CERTSRV
extern WCHAR *g_pwszDumpStrings;
#endif

extern UNATTENDPARM aUnattendParmClient[];
extern UNATTENDPARM aUnattendParmServer[];

#endif // __SETUPUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\setuput.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       setuput.cpp
//
//  Contents:   Utility functions for OCM based setup.
//
//  History:    04/20/97        JerryK  Created
//
//-------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// ** C Runtime Includes
#include <sys/types.h>
#include <sys/stat.h>

// ** System Includes **
#include <lmaccess.h>
#include <lmapibuf.h>
#include "csdisp.h"
#include <shlobj.h>
#include <userenv.h>
#include <dsgetdc.h>
#include <sddl.h>
#include <winldap.h>
#include <autoenr.h>
#include <userenvp.h>   // CreateLinkFile API

// ** security includes **
#include <aclapi.h>


// ** Application Includes **
#include "initcert.h"
#include "cscsp.h"
#include "cspenum.h"
#include "csldap.h"

#include "wizpage.h"
#include "websetup.h"

#include "certsrvd.h"
#include "regd.h"
#include "usecert.h"
#include "certmsg.h"
#include "dssetup.h"
#include "progress.h"
#include <certca.h>
#include "csprop.h"
#include "setupids.h"

#define __dwFILE__	__dwFILE_OCMSETUP_SETUPUT_CPP__

EXTERN_C const IID IID_IGPEInformation;
EXTERN_C const CLSID CLSID_GPESnapIn;

#define CERT_HALF_SECOND  500          // # of milliseconds in half second
#define CERT_MAX_ATTEMPT   2 * 60 * 2   // # of half seconds in 2 minutes

#define wszREQUESTVERINDPROGID  L"CertSrv.Request"
#define wszREQUESTPROGID        L"CertSrv.Request.1"
#define wszADMINVERINDPROGID    L"CertSrv.Admin"
#define wszADMINPROGID          L"CertSrv.Admin.1"
#define wszREQUESTFRIENDLYNAME  L"CertSrv Request"
#define wszADMINFRIENDLYNAME    L"CertSrv Admin"

#define wszCERTSRV              L"CertSrv"

#define wszREGW3SCRIPTMAP L"System\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Script Map"



#define wszHTTPS         L"https://"
#define wszASPEXT        L".asp"
#define wszHTTP          L"http://"
#define wszDOTCERTEXT    L".cer"
#define wszNEWLINE       L"\n"
#define wszFILESC        L"file://\\\\"

#define SZ_REGSVR32 L"regsvr32.exe"
#define SZ_REGSVR32_CERTCLI L"/i:i /n /s certcli.dll"
#define SZ_VERB_OPEN L"open"


// hardcoded shares
#define wszCERTENROLLURLPATH    L"/CertEnroll/"


#define wszzREGSUBJECTTEMPLATEVALUE \
    wszPROPEMAIL L"\0" \
    wszPROPCOMMONNAME L"\0" \
    wszATTRORGUNIT4 L"\0" \
    wszPROPORGANIZATION L"\0" \
    wszPROPLOCALITY L"\0" \
    wszPROPSTATE L"\0" \
    wszPROPDOMAINCOMPONENT L"\0" \
    wszPROPCOUNTRY L"\0"


// Whistler SMIME extension (or any other CSP):
// SMIME Capabilities
//     [1]SMIME Capability
//          Object ID=1.2.840.113549.3.2       szOID_RSA_RC2CBC, 128 bit
//          Parameters=02 02 00 80
//     [2]SMIME Capability
//          Object ID=1.2.840.113549.3.4       szOID_RSA_RC4, 128 bit
//          Parameters=02 02 00 80
//     [3]SMIME Capability
//          Object ID=1.3.14.3.2.7             szOID_OIWSEC_desCBC
//     [4]SMIME Capability
//          Object ID=1.2.840.113549.3.7       szOID_RSA_DES_EDE3_CBC
//

#define wszzREGVALUEDEFAULTSMIME \
    TEXT(szOID_RSA_RC2CBC) L",128" L"\0" \
    TEXT(szOID_RSA_RC4) L",128" L"\0" \
    TEXT(szOID_OIWSEC_desCBC) L"\0" \
    TEXT(szOID_RSA_DES_EDE3_CBC) L"\0"


#ifdef CERTSRV_ENABLE_ALL_REGISTRY_DEFAULTS
# define wszREGSUBJECTALTNAMEVALUE L"EMail"
# define wszREGSUBJECTALTNAME2VALUE L"EMail"
#else
# define wszREGSUBJECTALTNAMEVALUE \
    L"DISABLED: Set to EMail to set SubjectAltName extension to the email address"

# define wszREGSUBJECTALTNAME2VALUE \
    L"DISABLED: Set to EMail to set SubjectAltName2 extension to the email address"

#endif

#define szNULL_SESSION_REG_LOCATION "System\\CurrentControlSet\\Services\\LanmanServer\\Parameters"
#define szNULL_SESSION_VALUE "NullSessionPipes"

#define wszDEFAULTSHAREDFOLDER  L"\\CAConfig"


// globals
WCHAR *g_pwszArgvPath = NULL;          // for installing from local directory
WCHAR *g_pwszNoService = NULL;         // skip CreateService
WCHAR *g_pwszSanitizedChar = NULL;     // take first char for sanitizing test
#if DBG_CERTSRV
WCHAR *g_pwszDumpStrings = NULL;       // dump resource strings
#endif

BOOL            g_fW3SvcRunning = FALSE;
WCHAR           g_wszServicePath[MAX_PATH];



// Version-independent ProgID
// ProgID


WCHAR const g_wszCertAdmDotDll[]      = L"certadm.dll";
WCHAR const g_wszCertCliDotDll[]      = L"certcli.dll";
WCHAR const g_wszcertEncDotDll[]      = L"certenc.dll";
WCHAR const g_wszCertXDSDotDll[]      = L"certxds.dll";
WCHAR const g_wszCertIfDotDll[]       = L"certif.dll";
WCHAR const g_wszCertPDefDotDll[]     = L"certpdef.dll";
WCHAR const g_wszCertMMCDotDll[]      = L"certmmc.dll";
WCHAR const g_wszCertSrvDotMsc[]      = L"certsrv.msc";

WCHAR const g_wszSCrdEnrlDotDll[]     = L"scrdenrl.dll";

WCHAR const g_wszCertReqDotExe[]      = L"certreq.exe";
WCHAR const g_wszCertUtilDotExe[]     = L"certutil.exe";

WCHAR const g_wszCertDBDotDll[]       = L"certdb.dll";
WCHAR const g_wszCertViewDotDll[]     = L"certview.dll";

WCHAR const g_wszCSBullDotGif[]    = L"csbull.gif";
WCHAR const g_wszCSBackDotGif[]    = L"csback.gif";
WCHAR const g_wszCSLogoDotGif[]    = L"cslogo.gif";

CHAR const * const aszRegisterServer[] = {
    "DllRegisterServer",
    "DllUnregisterServer",
};

typedef struct _REGISTERDLL
{
    WCHAR const *pwszDllName;
    DWORD        Flags;
} REGISTERDLL;

#define RD_SERVER       0x00000001  // Register on server
#define RD_CLIENT       0x00000002  // Register on client
#define RD_UNREGISTER   0x00000004  // Unegister on client & server
#define RD_WHISTLER     0x00000008  // Register must succeed on Whistler only
#define RD_SKIPUNREGPOLICY 0x00000010  // not unreg custom policy during upgrade
#define RD_SKIPUNREGEXIT   0x00000020  // not unreg custom exit during upgrade
#define RD_SKIPUNREGMMC    0x00000040  // bug# 38876

REGISTERDLL const g_aRegisterDll[] = {
  { g_wszCertAdmDotDll,  RD_SERVER | RD_CLIENT },
  { g_wszCertCliDotDll,  RD_SERVER | RD_CLIENT },
  { g_wszcertEncDotDll,  RD_SERVER | RD_CLIENT | RD_UNREGISTER },
  { g_wszCertXDSDotDll,  RD_SERVER |             RD_UNREGISTER | RD_SKIPUNREGEXIT},
  { g_wszCertIfDotDll,                           RD_UNREGISTER },
  { g_wszCertPDefDotDll, RD_SERVER |             RD_UNREGISTER | RD_SKIPUNREGPOLICY },
  { g_wszCertMMCDotDll,  RD_SERVER |             RD_UNREGISTER | RD_SKIPUNREGMMC },
  { g_wszSCrdEnrlDotDll, RD_SERVER | RD_CLIENT | RD_UNREGISTER | RD_WHISTLER },
  { g_wszCertDBDotDll,   RD_SERVER |             RD_UNREGISTER },
  { g_wszCertViewDotDll,                         RD_UNREGISTER },
  { NULL,                     0 }
};


typedef struct _PROGRAMENTRY
{
    UINT        uiLinkName;
    UINT        uiGroupName;
    UINT        uiDescription;
    DWORD       csidl;          // special folder index
    WCHAR const *pwszExeName;
    WCHAR const *pwszClientArgs;
    WCHAR const *pwszServerArgs;
    DWORD        Flags;
} PROGRAMENTRY;

#define PE_SERVER               0x00000001  // Install on server
#define PE_CLIENT               0x00000002  // Install on client
#define PE_DELETEONLY           0x00000004  // Always delete

PROGRAMENTRY const g_aProgramEntry[] = {
    {
        IDS_STARTMENU_NEWCRL_LINKNAME,          // uiLinkName
        IDS_STARTMENU_CERTSERVER,               // uiGroupName
        0,                                      // uiDescription
        CSIDL_COMMON_PROGRAMS,                  // "All Users\Start Menu\Programs"
        g_wszCertUtilDotExe,                    // pwszExeName
        NULL,                                   // pwszClientArgs
        L"-crl -",                              // pwszServerArgs
        PE_DELETEONLY | PE_SERVER,              // Flags
    },
    {
        IDS_STARTMENU_CERTHIER_LINKNAME,        // uiLinkName
        IDS_STARTMENU_CERTSERVER,               // uiGroupName
        0,                                      // uiDescription
        CSIDL_COMMON_PROGRAMS,                  // "All Users\Start Menu\Programs"
        L"certhier.exe",                        // pwszExeName
        NULL,                                   // pwszClientArgs
        NULL,                                   // pwszServerArgs
        PE_DELETEONLY | PE_SERVER,              // Flags
    },
    {
        IDS_STARTMENU_CERTREQ_LINKNAME,          // uiLinkName
        IDS_STARTMENU_CERTSERVER,               // uiGroupName
        0,                                      // uiDescription
        CSIDL_COMMON_PROGRAMS,                  // "All Users\Start Menu\Programs"
        g_wszCertReqDotExe,                     // pwszExeName
        NULL,                                   // pwszClientArgs
        NULL,                                   // pwszServerArgs
        PE_DELETEONLY | PE_CLIENT | PE_SERVER,  // Flags
    },
};
#define CPROGRAMENTRY   ARRAYSIZE(g_aProgramEntry)

static char rgcCERT_NULL_SESSION[] = {0x43, 0x45, 0x52, 0x54, 0x00, 0x00};

// ** Prototypes **

HRESULT
UpgradeServerRegEntries(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp);

HRESULT
CreateServerRegEntries(
    IN HWND hwnd,
    IN BOOL fUpgrade,
    IN PER_COMPONENT_DATA *pComp);

HRESULT
CreateWebClientRegEntries(
    BOOL                fUpgrade,
    PER_COMPONENT_DATA *pComp);

HRESULT
UpgradeWebClientRegEntries(
    PER_COMPONENT_DATA *pComp);

HRESULT
GetServerNames(
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT WCHAR **ppwszServerName,
    OUT WCHAR **ppwszServerNameOld);

HRESULT
UpdateDomainAndUserName(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp);

HRESULT
RegisterAndUnRegisterDLLs(
    IN DWORD Flags,
    IN PER_COMPONENT_DATA *pComp,
    IN HWND hwnd);


HRESULT RenameMiscTargets(HWND hwnd, PER_COMPONENT_DATA *pComp, BOOL fServer);
HRESULT DeleteProgramGroups(IN BOOL fAll, IN PER_COMPONENT_DATA *pComp);

HRESULT CreateCertificateService(PER_COMPONENT_DATA *pComp, HWND hwnd);

HRESULT DeleteCertificates(const WCHAR *, BOOL fRoot);

HRESULT TriggerAutoenrollment();

//endproto


#ifdef DBG_OCM_TRACE
VOID
CaptureStackBackTrace(
    EXCEPTION_POINTERS *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    ZeroMemory(aeip, cFrames * sizeof(aeip[0]));

#if i386 == 1
    ULONG ieip, *pebp;
    ULONG *pebpMax = (ULONG *) MAXLONG; // 2 * 1024 * 1024 * 1024; // 2 gig - 1
    ULONG *pebpMin = (ULONG *) (64 * 1024);     // 64k

    if (pep == NULL)
    {
        ieip = 0;
        cSkip++;                    // always skip current frame
        pebp = ((ULONG *) &pep) - 2;
    }
    else
    {
        ieip = 1;
        CSASSERT(cSkip == 0);
        aeip[0] = pep->ContextRecord->Eip;
        pebp = (ULONG *) pep->ContextRecord->Ebp;
    }
    if (pebp >= pebpMin && pebp < pebpMax)
    {
        __try
        {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                if (ieip >= cSkip)
                {
                    aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                ULONG *pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 || pebpNext >= pebpMax - 1)
                {
                    break;
                }
                pebp = pebpNext;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ;
        }
    }
#endif // i386 == 1
}
#endif // DBG_OCM_TRACE


VOID
DumpBackTrace(char const *pszName)
{
#ifdef DBG_OCM_TRACE
    ULONG aeip[10];

    DBGPRINT((MAXDWORD, "%hs: BackTrace:\n", pszName));
    CaptureStackBackTrace(NULL, 1, ARRAYSIZE(aeip), aeip);

    for (int i = 0; i < ARRAYSIZE(aeip); i++)
    {
        if (NULL == aeip[i])
        {
            break;
        }
        DBGPRINT((MAXDWORD, "ln %x;", aeip[i]));
    }
    DBGPRINT((MAXDWORD, "\n"));
#endif // DBG_OCM_TRACE
}

__inline VOID
AppendBackSlash(
    IN OUT WCHAR *pwszOut)
{
    DWORD cwc = wcslen(pwszOut);

    if (0 == cwc || L'\\' != pwszOut[cwc - 1])
    {
        pwszOut[cwc++] = L'\\';
        pwszOut[cwc] = L'\0';
    }
}


__inline VOID
StripBackSlash(
    IN OUT WCHAR *pwszOut)
{
    DWORD cwc = wcslen(pwszOut);

    if (0 < cwc && L'\\' == pwszOut[cwc - 1])
    {
        pwszOut[cwc] = L'\0';
    }
}

VOID
BuildPath(
    OUT WCHAR *pwszOut,
    IN DWORD cwcOut,
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile)
{
    wcscpy(pwszOut, pwszDir);
    AppendBackSlash(pwszOut);
    wcscat(pwszOut, pwszFile);
    StripBackSlash(pwszOut);

    CSASSERT(wcslen(pwszOut) < cwcOut);

    DBGPRINT((DBG_SS_CERTOCMI, "BuildPath(%ws, %ws) -> %ws\n", pwszDir, pwszFile, pwszOut));
}


VOID
FreeCARequestInfo(CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pwszRequestFile)
    {
        LocalFree(pServer->pwszRequestFile);
    }
    if (NULL != pServer->pwszParentCAMachine)
    {
        LocalFree(pServer->pwszParentCAMachine);
    }
    if (NULL != pServer->pwszParentCAName)
    {
        LocalFree(pServer->pwszParentCAName);
    }
}


VOID
FreeCAStoreInfo(CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pwszSharedFolder)
    {
        LocalFree(pServer->pwszSharedFolder);
    }
    if (NULL != pServer->pwszDBDirectory)
    {
        LocalFree(pServer->pwszDBDirectory);
    }
    if (NULL != pServer->pwszLogDirectory)
    {
        LocalFree(pServer->pwszLogDirectory);
    }
}


VOID
FreeCAServerAdvanceInfo(CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pCSPInfoList)
    {
        FreeCSPInfoList(pServer->pCSPInfoList);
    }
    if (NULL != pServer->pKeyList)
    {
        csiFreeKeyList(pServer->pKeyList);
    }
    if (NULL != pServer->pDefaultCSPInfo)
    {
        freeCSPInfo(pServer->pDefaultCSPInfo);
    }
    if (NULL != pServer->pwszDesanitizedKeyContainerName)
    {
        LocalFree(pServer->pwszDesanitizedKeyContainerName);
    }
    if (NULL != pServer->pccExistingCert)
    {
        ClearExistingCertToUse(pServer);
    }
    if (NULL != pServer->pccUpgradeCert)
    {
        CertFreeCertificateContext(pServer->pccUpgradeCert);
    }
    if (NULL != pServer->pwszValidityPeriodCount)
    {
        LocalFree(pServer->pwszValidityPeriodCount);
    }
    if (NULL != pServer->pszAlgId)
    {
        LocalFree(pServer->pszAlgId);
    }
    if (NULL != pServer->hMyStore)
    {
        CertCloseStore(pServer->hMyStore, 0);
    }

    // don't free following because they are just pointers
    // pServer->pCSPInfo
    // pServer->pHashInfo
}


VOID
FreeCAServerIdInfo(
    CASERVERSETUPINFO *pServer)
{
    if (NULL != pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
        pServer->pwszCACommonName = NULL;
    }
}


VOID
FreeCAServerInfo(CASERVERSETUPINFO *pServer)
{
    FreeCAServerIdInfo(pServer);

    FreeCAServerAdvanceInfo(pServer);

    FreeCAStoreInfo(pServer);

    FreeCARequestInfo(pServer);

    if (NULL != pServer->pwszSanitizedName)
    {
        LocalFree(pServer->pwszSanitizedName);
    }

    if (NULL != pServer->pwszDNSuffix)
    {
        LocalFree(pServer->pwszDNSuffix);
    }

    if (NULL != pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN);
    }

    if (NULL != pServer->pwszKeyContainerName)
    {
        LocalFree(pServer->pwszKeyContainerName);
    }

    if (NULL != pServer->pwszCACertFile)
    {
        LocalFree(pServer->pwszCACertFile);
    }

    if (NULL != pServer->pwszUseExistingCert)
    {
        LocalFree(pServer->pwszUseExistingCert);
    }

    if (NULL != pServer->pwszPreserveDB)
    {
        LocalFree(pServer->pwszPreserveDB);
    }


    if (NULL != pServer->pwszCustomPolicy)
    {
        LocalFree(pServer->pwszCustomPolicy);
    }

    if (NULL != pServer->pwszzCustomExit)
    {
        LocalFree(pServer->pwszzCustomExit);
    }
}


VOID
FreeCAClientInfo(CAWEBCLIENTSETUPINFO *pClient)
{
    if (NULL != pClient)
    {
        if (NULL != pClient->pwszWebCAMachine)
        {
            LocalFree(pClient->pwszWebCAMachine);
        }
        if (NULL != pClient->pwszWebCAName)
        {
            LocalFree(pClient->pwszWebCAName);
        }
        if (NULL != pClient->pwszSanitizedWebCAName)
        {
            LocalFree(pClient->pwszSanitizedWebCAName);
        }
        if (NULL != pClient->pwszSharedFolder)
        {
            LocalFree(pClient->pwszSharedFolder);
        }
    }
}


VOID
FreeCAInfo(CASETUPINFO *pCA)
{
    if (NULL != pCA->pServer)
    {
        FreeCAServerInfo(pCA->pServer);
        LocalFree(pCA->pServer);
        pCA->pServer = NULL;
    }
    if (NULL != pCA->pClient)
    {
        FreeCAClientInfo(pCA->pClient);
        LocalFree(pCA->pClient);
        pCA->pClient = NULL;
    }
}


VOID
FreeCAComponentInfo(PER_COMPONENT_DATA *pComp)
{
    if (NULL != pComp->pwszCustomMessage)
    {
	LocalFree(pComp->pwszCustomMessage);
    }
    if (NULL != pComp->pwszComponent)
    {
        LocalFree(pComp->pwszComponent);
    }
    if (NULL != pComp->pwszUnattendedFile)
    {
        LocalFree(pComp->pwszUnattendedFile);
    }
    if (NULL != pComp->pwszServerName)
    {
        LocalFree(pComp->pwszServerName);
    }
    if (NULL != pComp->pwszServerNameOld)
    {
        LocalFree(pComp->pwszServerNameOld);
    }
    if (NULL != pComp->pwszSystem32)
    {
        LocalFree(pComp->pwszSystem32);
    }
    FreeCAInfo(&(pComp->CA));
}


VOID
FreeCAGlobals(VOID)
{
    if (NULL != g_pwszArgvPath)
    {
        LocalFree(g_pwszArgvPath);
    }
    if (NULL != g_pwszNoService)
    {
        LocalFree(g_pwszNoService);
    }
    if (NULL != g_pwszSanitizedChar)
    {
        LocalFree(g_pwszSanitizedChar);
    }
#if DBG_CERTSRV
    if (NULL != g_pwszDumpStrings)
    {
        LocalFree(g_pwszDumpStrings);
    }
#endif
}


VOID
SaveCustomMessage(
    IN OUT PER_COMPONENT_DATA *pComp,
    OPTIONAL IN WCHAR const *pwszCustomMessage)
{
    HRESULT hr;

    if (NULL != pwszCustomMessage)
    {
	if (NULL != pComp->pwszCustomMessage)
	{
	    LocalFree(pComp->pwszCustomMessage);
	    pComp->pwszCustomMessage = NULL;
	}
	hr = myDupString(pwszCustomMessage, &pComp->pwszCustomMessage);
	_JumpIfError(hr, error, "myDupString");
    }
error:
    ;
}



HRESULT
LoadDefaultCAIDAttributes(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    DWORD   i;


    // free existing Id info before load default
    FreeCAServerIdInfo(pServer);

    // load default from resource
    if (NULL != g_pwszSanitizedChar)
    {
        if (NULL != pServer->pwszCACommonName)
        {
            LocalFree(pServer->pwszCACommonName);
        }
        // replace with the env var
        pServer->pwszCACommonName = (WCHAR*)LocalAlloc(LMEM_FIXED,
                    (wcslen(g_pwszSanitizedChar) + 1) * sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pServer->pwszCACommonName);
        wcscpy(pServer->pwszCACommonName, g_pwszSanitizedChar);
    }


    // default validity
    pServer->enumValidityPeriod = dwVALIDITYPERIODENUMDEFAULT;
    pServer->dwValidityPeriodCount = dwVALIDITYPERIODCOUNTDEFAULT_ROOT;
    GetSystemTimeAsFileTime(&pServer->NotBefore);
    pServer->NotAfter = pServer->NotBefore;
    myMakeExprDateTime(
		&pServer->NotAfter,
		pServer->dwValidityPeriodCount,
		pServer->enumValidityPeriod);

    hr = S_OK;
error:
    return(hr);
}


HRESULT
GetDefaultDBDirectory(
    IN PER_COMPONENT_DATA *pComp,
    OUT WCHAR            **ppwszDir)
{
    HRESULT hr;
    DWORD cwc;

    *ppwszDir = NULL;
    cwc = wcslen(pComp->pwszSystem32) +
        wcslen(wszLOGPATH) +
        1;

    *ppwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *ppwszDir);

    // default
    wcscpy(*ppwszDir, pComp->pwszSystem32);
    wcscat(*ppwszDir, wszLOGPATH);

    CSASSERT(cwc == (DWORD) (wcslen(*ppwszDir) + 1));
    hr = S_OK;

error:
    return(hr);
}


HRESULT
LoadDefaultDBDirAttributes(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;

    if (NULL != pServer->pwszDBDirectory)
    {
        LocalFree(pServer->pwszDBDirectory);
        pServer->pwszDBDirectory = NULL;
    }
    hr = GetDefaultDBDirectory(pComp, &pServer->pwszDBDirectory);
    _JumpIfError(hr, error, "GetDefaultDBDirectory");

    // default log dir is the same as db
    if (NULL != pServer->pwszLogDirectory)
    {
        LocalFree(pServer->pwszLogDirectory);
    }
    pServer->pwszLogDirectory = (WCHAR *) LocalAlloc(
                LMEM_FIXED,
                (wcslen(pServer->pwszDBDirectory) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pServer->pwszLogDirectory);

    wcscpy(pServer->pwszLogDirectory, pServer->pwszDBDirectory);

    pServer->fPreserveDB = FALSE;

    hr = S_OK;
error:
    return(hr);
}


HRESULT
LoadDefaultAdvanceAttributes(
    IN OUT CASERVERSETUPINFO* pServer)
{
    HRESULT  hr;

    // load default csp, ms base csp
    pServer->fAdvance = FALSE;
    if (NULL == pServer->pDefaultCSPInfo)
    {
        pServer->pDefaultCSPInfo = newCSPInfo(PROV_RSA_FULL, wszBASECSP);
	if (NULL == pServer->pDefaultCSPInfo && !IsWhistler())
	{
	    pServer->pDefaultCSPInfo = newCSPInfo(PROV_RSA_FULL, MS_DEF_PROV_W);
	}
        _JumpIfOutOfMemory(hr, error, pServer->pDefaultCSPInfo);
    }

    // determine default hash, sha1
    pServer->pDefaultHashInfo = pServer->pDefaultCSPInfo->pHashList;
    while (NULL != pServer->pDefaultHashInfo)
    {
        if (pServer->pDefaultHashInfo->idAlg == CALG_SHA1)
        {
            //got default
            break;
        }
        pServer->pDefaultHashInfo = pServer->pDefaultHashInfo->next;
    }

    // If we have not just created a default key, reset the key container name.
    if (pServer->pCSPInfo != pServer->pDefaultCSPInfo || 
        (pServer->dwKeyLength != CA_DEFAULT_KEY_LENGTH_ROOT &&
         pServer->dwKeyLength != CA_DEFAULT_KEY_LENGTH_SUB) ||
        !pServer->fDeletableNewKey) {

        ClearKeyContainerName(pServer);
    }

    // ok, point to defaults
    pServer->pCSPInfo = pServer->pDefaultCSPInfo;
    pServer->pHashInfo = pServer->pDefaultHashInfo;

    // some other related defaults
    pServer->dwKeyLength = IsRootCA(pServer->CAType)?
        CA_DEFAULT_KEY_LENGTH_ROOT:
        CA_DEFAULT_KEY_LENGTH_SUB;
    pServer->dwKeyLenMin = 0;
    pServer->dwKeyLenMax = 0;

    // update hash oid
    if (NULL != pServer->pszAlgId)
    {
        // free old
        LocalFree(pServer->pszAlgId);
    }

    hr = myGetSigningOID(
		     NULL,	// hProv
		     pServer->pCSPInfo->pwszProvName,
		     pServer->pCSPInfo->dwProvType,
		     pServer->pHashInfo->idAlg,
		     &(pServer->pszAlgId));
    _JumpIfError(hr, error, "myGetSigningOID");

error:
    return(hr);
}


HRESULT
LoadDefaultCAClientAttributes(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    if (NULL != pClient)
    {
        // free existing client setup info
        FreeCAClientInfo(pClient);
        LocalFree(pClient);
        pComp->CA.pClient = NULL;
    }
    pComp->CA.pClient = (CAWEBCLIENTSETUPINFO *) LocalAlloc(
                                                LMEM_FIXED | LMEM_ZEROINIT,
                                                sizeof(CAWEBCLIENTSETUPINFO));
    _JumpIfOutOfMemory(hr, error, pComp->CA.pClient);

    pComp->CA.pClient->WebCAType = ENUM_UNKNOWN_CA;

    hr = S_OK;

error:
    return(hr);
}


HRESULT
GetDefaultSharedFolder(
    OUT WCHAR **ppwszSharedFolder)
{
    HRESULT  hr = S_OK;
    WCHAR   *pwszSysDrive = NULL;

    *ppwszSharedFolder = NULL;

    hr = myGetEnvString(&pwszSysDrive, L"SystemDrive");
    if (S_OK == hr)
    {
        *ppwszSharedFolder = (WCHAR *) LocalAlloc(
            LMEM_FIXED,
            (wcslen(pwszSysDrive) + wcslen(wszDEFAULTSHAREDFOLDER) + 1) *
             sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, *ppwszSharedFolder);

        wcscpy(*ppwszSharedFolder, pwszSysDrive);
        wcscat(*ppwszSharedFolder, wszDEFAULTSHAREDFOLDER);
    }

error:
    if (NULL != pwszSysDrive)
    {
        LocalFree(pwszSysDrive);
    }
    return hr;
}


HRESULT
LoadDefaultCAServerAttributes(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    BOOL       fDSCA = FALSE;
    WCHAR     *pwszSysDrive = NULL;
    bool fIsDomainMember;
    bool fUserCanInstallCA;

    if (NULL != pComp->CA.pServer)
    {
        // free existing server setup info
        FreeCAServerInfo(pComp->CA.pServer);
        LocalFree(pComp->CA.pServer);
    }
    // allocate server info buffer
    pComp->CA.pServer = (CASERVERSETUPINFO *) LocalAlloc(
                            LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof(CASERVERSETUPINFO));
    _JumpIfOutOfMemory(hr, error, pComp->CA.pServer);

    hr = LoadDefaultCAIDAttributes(pComp);
    _JumpIfError(hr, error, "LoadDefaultCAIDAttributes");

    hr = LoadDefaultAdvanceAttributes(pComp->CA.pServer);
    _JumpIfError(hr, error, "LoadDefaultAdvanceAttributes");

    hr = LoadDefaultDBDirAttributes(pComp);
    _JumpIfError(hr, error, "LoadDefaultDBDirAttributes");

    // decide default using DS
    // xtan, the following call should be replaced with HasDSWritePermission()
    //       remove DisableEnterpriseCAs()

    pComp->CA.pServer->fUseDS = FALSE;

    
    hr = LocalMachineIsDomainMember(&fIsDomainMember);
    _JumpIfError(hr, error, "LocalMachineIsDomainMember");

    if (fIsDomainMember)
    {
        if(IsDSAvailable())
        {

            hr = CurrentUserCanInstallCA(fUserCanInstallCA);
            _JumpIfError(hr, error, "CurrentUserCanInstallCA");
            
            if(fUserCanInstallCA)
            {
                pComp->CA.pServer->fUseDS = TRUE;
                fDSCA = csiIsAnyDSCAAvailable();
            }
        }
    }

    // alway free and null old shared folder
    if (NULL != pComp->CA.pServer->pwszSharedFolder)
    {
        LocalFree(pComp->CA.pServer->pwszSharedFolder);
        pComp->CA.pServer->pwszSharedFolder = NULL;
    }

    // decide default CA type and default shared folder
    pComp->CA.pServer->CAType = ENUM_STANDALONE_ROOTCA;
    if (pComp->CA.pServer->fUseDS)
    {
        if (fDSCA)
        {
            pComp->CA.pServer->CAType = ENUM_ENTERPRISE_SUBCA;
        }
        else
        {
            pComp->CA.pServer->CAType = ENUM_ENTERPRISE_ROOTCA;
        }
    }

    if (pComp->fUnattended || !pComp->CA.pServer->fUseDS)
    {
        BOOL fChangeToDefault = FALSE;

        // try reg load first
        hr = myGetCertRegStrValue(
                     NULL,
                     NULL,
                     NULL,
                     wszREGDIRECTORY,
                     &pComp->CA.pServer->pwszSharedFolder);
        if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGDIRECTORY);
        }
        if (S_OK == hr)
        {
            if (L'\0' == *pComp->CA.pServer->pwszSharedFolder)
            {
                // this mast be empty string
                fChangeToDefault = TRUE;
            }
            else
            {
                //got something, make sure unc path exist
                DWORD dwPathFlag;
                if (!myIsFullPath(pComp->CA.pServer->pwszSharedFolder,
                                  &dwPathFlag))
                {
                    // somehow register an invalid path, don't use it
                    fChangeToDefault = TRUE;
                }
                else
                {
                    if (UNC_PATH == dwPathFlag &&
                        DE_DIREXISTS != DirExists(pComp->CA.pServer->pwszSharedFolder))
                    {
                        // this unc path doesn't exist any more
                        // not making any sense to use it
                        fChangeToDefault = TRUE;
                        pComp->CA.pServer->fUNCPathNotFound = TRUE;
                    }
                }
            }
        }
        else
        {
            //must be not found
            fChangeToDefault = TRUE;
        }

        if (fChangeToDefault)
        {
            //free 1st
            if (NULL != pComp->CA.pServer->pwszSharedFolder)
            {
                LocalFree(pComp->CA.pServer->pwszSharedFolder);
            }
            // load default
            hr = GetDefaultSharedFolder(&pComp->CA.pServer->pwszSharedFolder);
            _JumpIfError(hr, error, "GetDefaultSharedFolder");
        }
    }

    pComp->CA.pServer->fSaveRequestAsFile = FALSE;
    pComp->CA.pServer->pwszRequestFile = NULL;
    pComp->CA.pServer->pwszParentCAMachine = NULL;
    pComp->CA.pServer->pwszParentCAName = NULL;
    hr = S_OK;

error:
    return hr;
}

HRESULT
InitCASetup(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT       hr;
    UINT ui;
    bool fIsAdmin = false;

    hr = GetServerNames(
		    hwnd,
		    pComp->hInstance,
		    pComp->fUnattended,
		    &pComp->pwszServerName,
		    &pComp->pwszServerNameOld);
    _JumpIfError(hr, error, "GetServerNames");

    DBGPRINT((
	DBG_SS_CERTOCMI,
	"InitCASetup:GetServerNames:%ws,%ws\n",
	pComp->pwszServerName,
	pComp->pwszServerNameOld));

    DumpBackTrace("InitCASetup");

    hr = IsCurrentUserBuiltinAdmin(&fIsAdmin);
    _JumpIfError(hr, error, "IsCurrentUserBuiltinAdmin");

    if (!fIsAdmin)
    {
        hr = E_ACCESSDENIED;
        CertErrorMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hwnd,
            IDS_ERR_NOT_ADM,
            0,
            NULL);
        _JumpError(hr, error, "IsCurrentUserBuiltinAdmin");
    }

    // load some of environment variables
    hr = myGetEnvString(&g_pwszArgvPath, L"CertSrv_BinDir");
    hr = myGetEnvString(&g_pwszNoService, L"CertSrv_NoService");
    hr = myGetEnvString(&g_pwszSanitizedChar, L"CertSrv_Sanitize");
#if DBG_CERTSRV
    myGetEnvString(&g_pwszDumpStrings, L"CertSrv_DumpStrings");
#endif


    // figure out where the system root directory is (build path to x:\\winnt\system32\)
    ui = GetSystemDirectory(NULL, 0);   // returns chars neccessary to hold path (incl null)
    if (ui == 0)
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSystemDirectory");
    }
    pComp->pwszSystem32 = (LPWSTR)LocalAlloc(LMEM_FIXED, (ui+1)*sizeof(WCHAR));
    if (NULL == pComp->pwszSystem32)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    if (0 == GetSystemDirectory(pComp->pwszSystem32, ui))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSystemDirectory");
    }
    wcscat(pComp->pwszSystem32, L"\\");

    // load default atrributes anyway
    hr = LoadDefaultCAServerAttributes(hwnd, pComp);
    _JumpIfError(hr, error, "LoadDefaultCAServerAttributes");

    hr = LoadDefaultCAClientAttributes(hwnd, pComp);
    _JumpIfError(hr, error, "LoadDefaultCAClientAttributes");

    if (pComp->fUnattended)
    {
        // hook unattended data
        hr = HookUnattendedServerAttributes(pComp,
                 LookupSubComponent(cscServer));
        _JumpIfError(hr, error, "HookUnattendedServerAttributes");

        hr = HookUnattendedClientAttributes(pComp,
                 LookupSubComponent(cscClient));
        _JumpIfError(hr, error, "HookUnattendedClientAttributes");
    }


    hr = S_OK;
error:
    return(hr);
}


HRESULT
CreateInitialCertificateRequest(
    IN HCRYPTPROV hProv,
    IN CASERVERSETUPINFO *pServer,
    IN PER_COMPONENT_DATA *pComp,
    IN HWND hwnd,
    OUT BYTE **ppbEncode,
    OUT DWORD *pcbEncode)
{
    HRESULT hr;
    BYTE *pbSubjectEncoded = NULL;
    DWORD cbSubjectEncoded;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    LPCWSTR pszErrorPtr;

    hr = AddCNAndEncode(
        pServer->pwszCACommonName,
        pServer->pwszDNSuffix,
        &pbSubjectEncoded,
        &cbSubjectEncoded);
    _JumpIfError(hr, error, "AddCNAndEncodeCertStrToName");

    hr = myInfOpenFile(NULL, &hInf, &ErrorLine);
    _PrintIfError2(
	    hr,
	    "myInfOpenFile",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = csiBuildRequest(
		hInf,
		NULL,
		pbSubjectEncoded,
		cbSubjectEncoded,
		pServer->pszAlgId,
		TRUE,			// fNewKey
		CANAMEIDTOICERT(pServer->dwCertNameId),
		CANAMEIDTOIKEY(pServer->dwCertNameId),
		hProv,
		hwnd,
                pComp->hInstance,
                pComp->fUnattended,
		ppbEncode,
		pcbEncode);
    _JumpIfError(hr, error, "csiBuildRequest");

error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    if (NULL != pbSubjectEncoded)
    {
        myFree(pbSubjectEncoded, CERTLIB_USE_LOCALALLOC);
    }
    CSILOG(hr, IDS_LOG_CREATE_REQUEST, NULL, NULL, NULL);
    return(hr);
}


HRESULT
BuildCAHierarchy(
    HCRYPTPROV hProv,
    PER_COMPONENT_DATA *pComp,
    CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    HWND hwnd)
{
    HRESULT    hr;
    BYTE      *pbRequest = NULL;
    DWORD      cbRequest;
    CASERVERSETUPINFO    *pServer = pComp->CA.pServer;
    BSTR       bStrChain = NULL;

    if (!pServer->fSaveRequestAsFile)
    {
        // online case
        if (NULL == pServer->pwszParentCAMachine ||
            NULL == pServer->pwszParentCAName)
        {
            hr = E_POINTER;
            _JumpError(hr, error, "Empty machine name or parent ca name");
        }
    }

    // create request 1st

    hr = CreateInitialCertificateRequest(
				hProv,
				pServer,
				pComp,
				hwnd,
				&pbRequest,
				&cbRequest);
    if (S_OK != hr)
    {
        pComp->iErrMsg = IDS_ERR_BUILDCERTREQUEST;
        _JumpError(hr, error, "CreateInitialCertificateRequest");
    }

    // save it to a file always
    hr = EncodeToFileW(
		pServer->pwszRequestFile,
		pbRequest,
		cbRequest,
		DECF_FORCEOVERWRITE | CRYPT_STRING_BASE64REQUESTHEADER);
    _JumpIfError(hr, error, "EncodeToFileW");

    // register request file name always

    hr = mySetCARegFileNameTemplate(
			    wszREGREQUESTFILENAME,
			    pComp->pwszServerName,
			    pServer->pwszSanitizedName,
			    pServer->pwszRequestFile);
    _JumpIfErrorStr(hr, error, "mySetCARegFileNameTemplate", wszREGREQUESTFILENAME);

    if (pServer->fSaveRequestAsFile)
    {
        // mark it as request file
        hr = SetSetupStatus(
                        pServer->pwszSanitizedName,
                        SETUP_SUSPEND_FLAG | SETUP_REQUEST_FLAG,
                        TRUE);
        _JumpIfError(hr, error, "SetSetupStatus");

        // done if save as request file
        goto done;
    }

    hr = csiSubmitCARequest(
		 pComp->hInstance,
		 pComp->fUnattended,
		 hwnd,
		 FALSE,		// fRenew
		 FALSE,		// fRetrievePending
		 pServer->pwszSanitizedName,
		 pServer->pwszParentCAMachine,
		 pServer->pwszParentCAName,
		 pbRequest,
		 cbRequest,
		 &bStrChain);
    // in any case, you can finish setup from mmc

    _JumpIfError(hr, done, "csiSubmitCARequest");

    hr = csiFinishInstallationFromPKCS7(
				pComp->hInstance,
				pComp->fUnattended,
				hwnd,
				pServer->pwszSanitizedName,
				pServer->pwszCACommonName,
				pKeyProvInfo,
				pServer->CAType,
				CANAMEIDTOICERT(pServer->dwCertNameId),
				CANAMEIDTOIKEY(pServer->dwCertNameId),
				pServer->fUseDS,
				FALSE,		// fRenew
				pComp->pwszServerName,
				(BYTE *) bStrChain,
				SysStringByteLen(bStrChain),
				pServer->pwszCACertFile);
    _JumpIfError(hr, error, "csiFinishInstallationFromPKCS7");

done:
    hr = S_OK;

error:
    if (NULL != pbRequest)
    {
        myFree(pbRequest, CERTLIB_USE_LOCALALLOC);
    }
    if (NULL != bStrChain)
    {
        SysFreeString(bStrChain);
    }
    return(hr);
}


// Find the newest CA cert that:
//  - matches the passed Subject DN,
//  - matches the passed cert index,
//  - expires prior the next newer cert (compare to pNotAfter)
//  - expires latest of all that match the above
//  - has KeyProvInfo
//  - key and cert can be used together to sign

HRESULT
SetCARegOldCertHashByIndex(
    IN WCHAR const *pwszSanitizedName,
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszDN,
    IN DWORD iCert,
    IN OUT FILETIME *pNotAfter)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    CERT_CONTEXT const *pCertNewest = NULL;
    WCHAR *pwszDNT = NULL;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;
    ALG_ID idAlg;
    BOOL fMachineKeyset;
    DWORD dwNameId;
    DWORD cbKey;
    CRYPT_KEY_PROV_INFO *pKey = NULL;

    hr = myGetCertSrvCSP(
		FALSE,		// fEncryptionCSP
                pwszSanitizedName,
                &dwProvType,
                &pwszProvName,
                &idAlg,
                &fMachineKeyset,
		NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    while (TRUE)
    {
	if (NULL != pKey)
	{
	    LocalFree(pKey);
	    pKey = NULL;
	}
	if (NULL != pwszDNT)
	{
	    LocalFree(pwszDNT);
	    pwszDNT = NULL;
	}
	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}

	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pCert->pCertInfo->Subject,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszDNT);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myCertNameToStr");
	    continue;
	}
	if (0 != lstrcmp(pwszDN, pwszDNT))
	{
	    DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: %ws\n", pwszDNT));
	    continue;
	}
	hr = myGetNameId(pCert, &dwNameId);
	if (S_OK != hr ||
	    MAXDWORD == dwNameId ||
	    CANAMEIDTOICERT(dwNameId) != iCert)
	{
	    DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: NameId=%x\n", dwNameId));
	    continue;
	}
	DBGPRINT((DBG_SS_CERTOCM, "NameId=%x\n", dwNameId));

	if (0 < CompareFileTime(&pCert->pCertInfo->NotAfter, pNotAfter))
	{
	    DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: too new\n"));
	    continue;
	}

	if (!myCertGetCertificateContextProperty(
					pCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &pKey,
					&cbKey))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CertGetCertificateContextProperty");
	    continue;
	}
        hr = myValidateHashForSigning(
				pKey->pwszContainerName,
				pwszProvName,
				dwProvType,
				fMachineKeyset,
				&pCert->pCertInfo->SubjectPublicKeyInfo,
				idAlg);
        if (S_OK != hr)
	{
	    _PrintError(hr, "myValidateHashForSigning");
	    continue;
	}

	if (NULL != pCertNewest)
	{
            if (0 > CompareFileTime(
			&pCert->pCertInfo->NotAfter,
			&pCertNewest->pCertInfo->NotAfter))
	    {
		DBGPRINT((DBG_SS_CERTOCM, "Skipping cert: not newest\n"));
		continue;
	    }
	    CertFreeCertificateContext(pCertNewest);
	    pCertNewest = NULL;
	}
	pCertNewest = CertDuplicateCertificateContext(pCert);
	if (NULL == pCertNewest)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertDuplicateCertificate");
	}
    }
    if (NULL == pCertNewest)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "CertEnumCertificatesInStore");
    }

    // mark as unarchived:

    CertSetCertificateContextProperty(
				pCertNewest,
				CERT_ARCHIVED_PROP_ID,
				0,
				NULL);

    hr = mySetCARegHash(pwszSanitizedName, CSRH_CASIGCERT, iCert, pCertNewest);
    _JumpIfError(hr, error, "mySetCARegHash");

    *pNotAfter = pCertNewest->pCertInfo->NotAfter;

error:
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (NULL != pwszDNT)
    {
	LocalFree(pwszDNT);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pCertNewest)
    {
        CertFreeCertificateContext(pCertNewest);
    }
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
SetCARegOldCertHashes(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD cCertOld,
    IN CERT_CONTEXT const *pccCA)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD i;
    WCHAR *pwszDN = NULL;
    FILETIME NotAfter;

    if (0 != cCertOld)
    {
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pccCA->pCertInfo->Subject,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszDN);
	_JumpIfError(hr, error, "myCertNameToStr");

	// open my store

	hMyStore = CertOpenStore(
		        CERT_STORE_PROV_SYSTEM_W,
		        X509_ASN_ENCODING,
		        NULL,                        // hProv
			CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_ENUM_ARCHIVED_FLAG,
		        wszMY_CERTSTORE);
	if (NULL == hMyStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}

	NotAfter = pccCA->pCertInfo->NotAfter;

	for (i = cCertOld; i > 0; i--)
	{
	    hr = SetCARegOldCertHashByIndex(
				pwszSanitizedName,
				hMyStore,
				pwszDN,
				i - 1,
				&NotAfter);
	    _PrintIfError(hr, "SetCARegOldCertHashByIndex");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszDN)
    {
        LocalFree(pwszDN);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, 0);
    }
    return(hr);
}


HRESULT
CreateCertificates(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN HWND hwnd)
{
    HRESULT hr;
    HCRYPTPROV hCryptProv = NULL;
    HCERTSTORE hStore = NULL;
    CRYPT_KEY_PROV_INFO keyProvInfo;
    WCHAR wszEnrollPath[MAX_PATH];
    CERT_CONTEXT const *pccCA = NULL;
    BYTE *pbEncoded = NULL;
    WCHAR *pwszEnrollPath = NULL;
    WCHAR *pwszDir = NULL;
    WCHAR *pwszFolderPath = NULL;
    DWORD dwSize;

    wszEnrollPath[0] = L'\0';
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    ZeroMemory(&keyProvInfo, sizeof(keyProvInfo));

    if (NULL == pServer->pwszKeyContainerName && pComp->fUnattended)
    {
        // create a new key if unattended

        hr = csiGenerateCAKeys(
                        pServer->pwszSanitizedName,
                        pServer->pCSPInfo->pwszProvName,
                        pServer->pCSPInfo->dwProvType,
                        pServer->pCSPInfo->fMachineKeyset,
                        pServer->dwKeyLength,
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        &pComp->CA.pServer->fKeyGenFailed);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                           pComp->hInstance,
                           pComp->fUnattended,
                           hwnd,
                           IDS_ERR_FATAL_GENKEY,
                           hr,
                           pServer->pwszSanitizedName);
            _JumpIfError(hr, error, "csiGenerateCAKeys");
        }

        // now set this as the existing key
        hr = SetKeyContainerName(pServer, pServer->pwszSanitizedName);
        _JumpIfError(hr, error, "SetKeyContainerName");
    }

    hr = csiFillKeyProvInfo(
                    pServer->pwszKeyContainerName,
                    pServer->pCSPInfo->pwszProvName,
                    pServer->pCSPInfo->dwProvType,
                    pServer->pCSPInfo->fMachineKeyset,
                    &keyProvInfo);
    _JumpIfError(hr, error, "csiFillKeyProvInfo");

    // get csp handle
    if (!myCertSrvCryptAcquireContext(
                            &hCryptProv,
                            pServer->pwszKeyContainerName,
                            pServer->pCSPInfo->pwszProvName,
                            pServer->pCSPInfo->dwProvType,
                            pComp->fUnattended? CRYPT_SILENT : 0, // query
                            pServer->pCSPInfo->fMachineKeyset))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }
    if (hCryptProv == NULL)
    {
        hr = E_HANDLE;
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    // open certificate store
    if (NULL == pServer->hMyStore)
    {
        pServer->hMyStore = CertOpenStore(
                                CERT_STORE_PROV_SYSTEM_W,
                                X509_ASN_ENCODING,
                                NULL,           // hProv
                                CERT_SYSTEM_STORE_LOCAL_MACHINE |
                                    CERT_STORE_ENUM_ARCHIVED_FLAG,
                                wszMY_CERTSTORE);
        if (NULL == pServer->hMyStore)
        {
            // no store exists, done
            hr = myHLastError();
            _JumpIfError(hr, error, "CertOpenStore");
        }
    }

    if (NULL != pServer->pccExistingCert)
    {
        // reuse cert, mark unarchived
        CertSetCertificateContextProperty(
                                pServer->pccExistingCert,
                                CERT_ARCHIVED_PROP_ID,
                                0,
                                NULL);
    }

    if (IsSubordinateCA(pServer->CAType) && NULL == pServer->pccExistingCert)
    {
        hr = BuildCAHierarchy(hCryptProv, pComp, &keyProvInfo, hwnd);
        _JumpIfError(hr, error, "BuildCAHierarchy");
    }
    else
    {
        WCHAR const *pwszCertName;
	DWORD cwc;

        BuildPath(
            wszEnrollPath,
            ARRAYSIZE(wszEnrollPath),
            pComp->pwszSystem32,
            wszCERTENROLLSHAREPATH);

	hr = csiBuildFileName(
		    wszEnrollPath,
		    pServer->pwszSanitizedName,
		    L".crt",
		    CANAMEIDTOICERT(pServer->dwCertNameId),
		    &pwszEnrollPath, 
		    pComp->hInstance,
		    pComp->fUnattended,
		    NULL);
	_JumpIfError(hr, error, "csiBuildFileName");

        CSASSERT(NULL != pServer->pwszCACertFile);
        pwszCertName = wcsrchr(pServer->pwszCACertFile, L'\\');
        CSASSERT(NULL != pwszCertName);

        cwc = SAFE_SUBTRACT_POINTERS(pwszCertName, pServer->pwszCACertFile);
	pwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED,  (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszDir)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pwszDir, pServer->pwszCACertFile, cwc * sizeof(WCHAR));
	pwszDir[cwc] = L'\0';

	hr = csiBuildFileName(
		    pwszDir,
		    pServer->pwszSanitizedName,
		    L".crt",
		    CANAMEIDTOICERT(pServer->dwCertNameId),
		    &pwszFolderPath, 
		    pComp->hInstance,
		    pComp->fUnattended,
		    NULL);
	_JumpIfError(hr, error, "csiBuildFileName");

        // create and save a selfsigned root cert

        hr = csiBuildAndWriteCert(
            hCryptProv,
            pServer,
	    pwszFolderPath, 
            pwszEnrollPath,
            pServer->pccExistingCert, // if NULL, we will build a new cert
            &pccCA,
            wszCERTTYPE_CA,
            pComp->hInstance,
            pComp->fUnattended,
            hwnd);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                IDS_ERR_BUILDCERT,
                hr,
                NULL);
            _JumpError(hr, error, "csiBuildAndWriteCert");
        }

	hr = SetCARegOldCertHashes(
		    pServer->pwszSanitizedName,
		    CANAMEIDTOICERT(pServer->dwCertNameId),
		    pccCA);
        _JumpIfError(hr, error, "SetCARegOldCertHashes");

        hr = mySetCARegHash(
                        pServer->pwszSanitizedName,
			CSRH_CASIGCERT,
			CANAMEIDTOICERT(pServer->dwCertNameId),
                        pccCA);
        _JumpIfError(hr, error, "mySetCARegHash");

	hr = csiSaveCertAndKeys(pccCA, NULL, &keyProvInfo, pServer->CAType);
	_JumpIfError(hr, error, "csiSaveCertAndKeys");

        if (pServer->fUseDS)
        {
            hr = csiSetupCAInDS(
                        hwnd,
                        pComp->pwszServerName,
                        pServer->pwszSanitizedName,
			pServer->pwszCACommonName,
                        NULL,
                        pServer->CAType,
			CANAMEIDTOICERT(pServer->dwCertNameId),
			CANAMEIDTOIKEY(pServer->dwCertNameId),
			FALSE,		// fRenew
                        pccCA);
            _PrintIfError(hr, "csiSetupCAInDS");
     
            if (hr == S_OK)
                 pServer->fSavedCAInDS = TRUE;
        }
    }
    hr = S_OK;

error:
    csiFreeKeyProvInfo(&keyProvInfo);
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    if (NULL != pwszDir)
    {
        LocalFree(pwszDir);
    }
    if (NULL != pwszFolderPath)
    {
        LocalFree(pwszFolderPath);
    }
    if (NULL != pwszEnrollPath)
    {
        LocalFree(pwszEnrollPath);
    }
    if (NULL != pccCA)
    {
        CertFreeCertificateContext(pccCA);
    }
    if (NULL != hCryptProv)
    {
        CryptReleaseContext(hCryptProv, 0);
    }
    CSILOG(hr, IDS_LOG_CREATE_CERTIFICATE, NULL, NULL, NULL);
    return(hr);
}


HRESULT
StartCertsrvService(BOOL fSilent)
{
    HRESULT hr;
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSCCertsvc = NULL;
    SERVICE_STATUS status;
    DWORD dwAttempt;
    BOOL fSawPending;
    WCHAR const *apwszSilentArg[1] = {L"-s"};

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }
    hSCCertsvc = OpenService(
        hSCManager,
        wszSERVICE_NAME,
        SERVICE_ALL_ACCESS);
    if (NULL == hSCCertsvc)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "OpenService", wszSERVICE_NAME);
    }

    // START the service
    if (!StartService(hSCCertsvc,
                      fSilent ? 1 : 0,
                      fSilent ? apwszSilentArg : NULL))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "StartService", wszSERVICE_NAME);
    }

    // get out after it is really started

    fSawPending = FALSE;
    for (dwAttempt = 0; dwAttempt < CERT_MAX_ATTEMPT; dwAttempt++)
    {
        DBGCODE(status.dwCurrentState = -1);
        if (!QueryServiceStatus(hSCCertsvc, &status))
        {
            // query failed, ignore error
            hr = S_OK;

            _JumpErrorStr(
                        myHLastError(),     // Display ignored error
                        error,
                        "QueryServiceStatus",
                        wszSERVICE_NAME);
        }
        if (SERVICE_START_PENDING != status.dwCurrentState &&
                        SERVICE_STOPPED != status.dwCurrentState)
        {
            // it was started already
            break;
        }
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Starting %ws service: current state=%d\n",
                wszSERVICE_NAME,
                status.dwCurrentState));
        if (fSawPending && SERVICE_STOPPED == status.dwCurrentState)
        {
            hr = HRESULT_FROM_WIN32(ERROR_SERVICE_NEVER_STARTED);
            _JumpErrorStr(
                    hr,
                    error,
                    "Service won't start",
                    wszSERVICE_NAME);
        }
        if (SERVICE_START_PENDING == status.dwCurrentState)
        {
            fSawPending = TRUE;
        }
        Sleep(CERT_HALF_SECOND);
    }
    if (dwAttempt >= CERT_MAX_ATTEMPT)
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Timeout starting %ws service: current state=%d\n",
                wszSERVICE_NAME,
                status.dwCurrentState));
    }
    else
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Started %ws service\n",
                wszSERVICE_NAME));
    }
    hr = S_OK;

error:
    if (NULL != hSCCertsvc)
    {
        CloseServiceHandle(hSCCertsvc);
    }
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    CSILOG(hr, IDS_LOG_START_SERVICE, NULL, NULL, NULL);
    return(hr);
}


HRESULT
EnforceCertFileExtensions(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    WCHAR *pwszTmp = NULL;
    WCHAR *pwszSuffix;
    BOOL fAppendExtension = TRUE;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (NULL == pServer->pwszCACertFile)
    {
        // no ca cert file
        goto done;
    }

    // make enough to hold extra extension crt
    pwszTmp = (WCHAR *) LocalAlloc(
                    LMEM_FIXED,
                    (wcslen(pServer->pwszCACertFile) + 5) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszTmp);

    wcscpy(pwszTmp, pServer->pwszCACertFile);

    // check to make sure our self-signed file has the right extension
    // Is there an extension?

    pwszSuffix = wcsrchr(pwszTmp, L'.');

    if (NULL != pwszSuffix)
    {
        // Is the stuff after the '.' already a 'crt' extension?

        if (0 == lstrcmpi(pwszSuffix, L".crt"))
        {
            fAppendExtension = FALSE;
        }
        else if (pwszSuffix[1] == L'\0')  // Is '.' last character?
        {
            while (pwszSuffix >= pwszTmp && *pwszSuffix == L'.')
            {
                *pwszSuffix-- = L'\0';
            }
        }
    }
    if (fAppendExtension)
    {
        // Apply the extension
        wcscat(pwszTmp, L".crt");
        // free old one
        LocalFree(pServer->pwszCACertFile);
        pServer->pwszCACertFile = pwszTmp;
        pwszTmp = NULL;
    }

done:
    hr = S_OK;

error:
    if (NULL != pwszTmp)
    {
        LocalFree(pwszTmp);
    }
    return(hr);
}

HRESULT
PrepareEDBDirectory(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp,
    WCHAR const *pwszDir)
{
    HRESULT hr;

    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    DWORD dwAttr = GetFileAttributes(pwszDir);
    if(MAXDWORD==dwAttr)
    {
        // file not found or other error
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpError(hr, error, "CreateDirectory");
        }
        hr = S_OK;

        if (!CreateDirectory(pwszDir, NULL))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateDirectory");
        }
    }

    if(!(dwAttr&FILE_ATTRIBUTE_DIRECTORY))
    {
        // file already exists but it's not a directory
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        _JumpError(hr, error, "CreateDirectory");
    }

    if (!pServer->fPreserveDB)
    {
        hr = myDeleteDBFilesInDir(pwszDir);
        _JumpIfError(hr, error, "myDeleteDBFilesInDir");
    }


    hr = S_OK;

error:
    if(S_OK != hr)
    {
        CertErrorMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hwnd,
            0,
            hr,
            L""); // only message is the system error message
    }

    return(hr);
}


//--------------------------------------------------------------------
// Create the web configuration files
HRESULT 
CreateCertWebIncPages(
    IN HWND hwnd, 
    IN PER_COMPONENT_DATA *pComp, 
    IN BOOL bIsServer,
    IN BOOL fUpgrade)
{
    HRESULT hr;
    
    CSASSERT(NULL != pComp);

    // create the web configuration file
    hr = CreateCertWebDatIncPage(pComp, bIsServer);
    _JumpIfError(hr, error, "CreateCertWebDatIncPage");

error:
    CSILOG(hr, IDS_LOG_WEB_INCLUDE, NULL, NULL, NULL);
    return hr;
}


//--------------------------------------------------------------------

HRESULT
EnableVRootsAndShares(
    IN BOOL fFileSharesOnly,
    IN BOOL fUpgrade,
    IN BOOL fServer,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    DWORD Flags = VFF_CREATEFILESHARES |
                    VFF_SETREGFLAGFIRST |
                    VFF_SETRUNONCEIFERROR |
                    VFF_CLEARREGFLAGIFOK;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    CSASSERT(!fServer || NULL != pServer);
    CSASSERT(fServer || NULL != pComp->CA.pClient);

    if (!fFileSharesOnly)
    {
        Flags |= VFF_CREATEVROOTS;
    }

    // if NT GUI mode (base setup) VRoot creation will fail during setup
    // because IIS is not yet operational.  Make a mark in the registry
    // to try this on NEXT service startup or via runonce.

    hr = myModifyVirtualRootsAndFileShares(
            Flags, 
            fServer? pServer->CAType : pComp->CA.pClient->WebCAType,
            FALSE,             // synchronous -- blocking call
            VFCSEC_TIMEOUT, 
            NULL, 
            NULL);
    _JumpIfError(hr, error, "myModifyVirtualRootsAndFileShares");

    if (!fUpgrade)
    {
        pServer->fCreatedShare = TRUE;
        if (!fFileSharesOnly)
        {
            pComp->fCreatedVRoot = TRUE;
        }
    }

error:
    return(hr);
}


HRESULT
DisableVRootsAndShares(
    IN BOOL fVRoot,
    IN BOOL fFileShares)
{
    HRESULT hr;
    DWORD Flags = 0;

    if (fVRoot)
    {
        Flags |= VFF_DELETEVROOTS;
    }
    if (fFileShares)
    {
        Flags |= VFF_DELETEFILESHARES;
    }
    if (0 == Flags)
    {
        goto done;
    }
    hr = myModifyVirtualRootsAndFileShares(
             Flags, 
             ENUM_UNKNOWN_CA,
             FALSE, // synchronous -- blocking call
             VFCSEC_TIMEOUT, 
             NULL, 
             NULL);
    _JumpIfError(hr, error, "myModifyVirtualRootsAndFileShares");

done:
    hr = S_OK;
error:
    return(hr);
}


HRESULT
InstallClient(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp)
{
    BOOL fCoInit = FALSE;
    HRESULT hr;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;
    certocmBumpGasGauge(pComp, 10 DBGPARM(L"InstallClient"));

    hr = CreateWebClientRegEntries(FALSE, pComp);
    _JumpIfError(hr, error, "CreateWebClientRegEntries");
    certocmBumpGasGauge(pComp, 30 DBGPARM(L"InstallClient"));

    hr = RegisterAndUnRegisterDLLs(RD_CLIENT, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");
    certocmBumpGasGauge(pComp, 50 DBGPARM(L"InstallClient"));

    DeleteProgramGroups(FALSE, pComp);

    hr = CreateProgramGroups(TRUE, pComp, hwnd);
    _JumpIfError(hr, error, "CreateProgramGroups");
    certocmBumpGasGauge(pComp, 70 DBGPARM(L"InstallClient"));

    hr = CreateCertWebIncPages(hwnd, pComp, FALSE /*IsServer*/, FALSE);
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, FALSE);
    _JumpIfError(hr, error, "RenameMiscTargets");
    certocmBumpGasGauge(pComp, 80 DBGPARM(L"InstallClient"));

    hr = EnableVRootsAndShares(FALSE, FALSE, FALSE, pComp);
    _JumpIfError(hr, error, "EnableVRootsAndShares");
    certocmBumpGasGauge(pComp, 100 DBGPARM(L"InstallClient"));

error:
    if (fCoInit)
    {
        CoUninitialize();
    }
    CSILOG(hr, IDS_LOG_INSTALL_CLIENT, NULL, NULL, NULL);
    return(hr);
}


HRESULT
RemoveWebClientRegEntries(VOID)
{
    HRESULT hr;

    hr = myDeleteCertRegValue(NULL, NULL, NULL, wszREGWEBCLIENTCAMACHINE);
    _PrintIfError(hr, "myDeleteCertRegValue");

    hr = myDeleteCertRegValue(NULL, NULL, NULL, wszREGWEBCLIENTCANAME);
    _PrintIfError(hr, "myDeleteCertRegValue");

    hr = myDeleteCertRegValue(NULL, NULL, NULL, wszREGWEBCLIENTCATYPE);
    _PrintIfError(hr, "myDeleteCertRegValue");

    hr = S_OK;
//error:
    return hr;
}


HRESULT
InstallServer(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp)
{
    BOOL fCoInit = FALSE;
    WCHAR  *pwszDBFile = NULL;
    DWORD   dwSetupStatus;
    HRESULT hr = pComp->hrContinue;
    int     ret;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR  *pwszConfig = NULL;
    BOOL    fSetDSSecurity;

    _JumpIfError(hr, error, "can't continue");

    hr = UpdateDomainAndUserName(hwnd, pComp);
    _JumpIfError(hr, error, "UpdateDomainAndUserName");

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = EnforceCertFileExtensions(pComp);
    _JumpIfError(hr, error, "EnforceCertFileExtensions");

    hr = PrepareEDBDirectory(hwnd, pComp, pServer->pwszDBDirectory);
    _JumpIfError(hr, error, "PrepareEDBDirectory");

    hr = PrepareEDBDirectory(hwnd, pComp, pServer->pwszLogDirectory);
    _JumpIfError(hr, error, "PrepareEDBDirectory");

    certocmBumpGasGauge(pComp, 10 DBGPARM(L"InstallServer"));

    // alway uninstall before install
    PreUninstallCore(hwnd, pComp, FALSE);
    UninstallCore(hwnd, pComp, 10, 30, FALSE, FALSE, FALSE);

    hr = CreateServerRegEntries(hwnd, FALSE, pComp);
    _JumpIfError(hr, error, "CreateServerRegEntries");

    if ((IS_SERVER_INSTALL & pComp->dwInstallStatus) &&
        (IS_CLIENT_UPGRADE & pComp->dwInstallStatus))
    {
        // case of install server only and keep web client
        // remove parent ca config info of the old web client
        hr = RemoveWebClientRegEntries();
        _PrintIfError(hr, "RemoveWebClientRegEntries");
    }

    certocmBumpGasGauge(pComp, 35 DBGPARM(L"InstallServer"));

    hr = RegisterAndUnRegisterDLLs(RD_SERVER, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

    certocmBumpGasGauge(pComp, 40 DBGPARM(L"InstallServer"));

    hr = CreateCertificateService(pComp, hwnd);
    _JumpIfError(hr, error, "CreateCertificateService");

    certocmBumpGasGauge(pComp, 45 DBGPARM(L"InstallServer"));

    hr = CreateCertificates(pComp, hwnd);
    _JumpIfError(hr, error, "CreateCertificates");

    certocmBumpGasGauge(pComp, 50 DBGPARM(L"InstallServer"));

    hr = CreateProgramGroups(FALSE, pComp, hwnd);
    _JumpIfError(hr, error, "CreateProgramGroups");

    certocmBumpGasGauge(pComp, 60 DBGPARM(L"InstallServer"));

    hr = CreateCertWebIncPages(hwnd, pComp, TRUE /*IsServer*/, FALSE);
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, TRUE);
    _JumpIfError(hr, error, "RenameMiscTargets");
    certocmBumpGasGauge(pComp, 70 DBGPARM(L"InstallServer"));

    hr = RegisterDcomServer(
                        CLSID_CCertRequestD,
                        wszREQUESTFRIENDLYNAME,
                        wszREQUESTVERINDPROGID,
                        wszREQUESTPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");
    hr = RegisterDcomServer(
                        CLSID_CCertAdminD,
                        wszADMINFRIENDLYNAME,
                        wszADMINVERINDPROGID,
                        wszADMINPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");
    certocmBumpGasGauge(pComp, 80 DBGPARM(L"InstallServer"));

    hr = RegisterDcomApp(CLSID_CCertRequestD);
    _JumpIfError(hr, error, "RegisterDcomApp");
    certocmBumpGasGauge(pComp, 90 DBGPARM(L"InstallServer"));

    if (pServer->fUseDS)
    {
        hr = AddCAMachineToCertPublishers();
        _JumpIfError(hr, error, "AddCAMachineToCertPublishers");

        hr = InitializeCertificateTemplates();
        _JumpIfError(hr, error, "InitializeCertificateTemplates");
    }
    certocmBumpGasGauge(pComp, 95 DBGPARM(L"InstallServer"));


    // Set the security locally.
    // A SubCA sets security when it receives its certificate from
    // its parent. ALL OTHER CA installs (Root & reuse of existing certs)
    // need to have security set now.

    // On a SubCA the DS object security will have been set
    // by a previous call in initlib if we already got our cert, or it will
    // be set later when we install our cert.
    // However, root certs install doesn't run completefrompkcs7(), so 
    // ds security on ent roots is never set. We must set it here.

    // TODO: set security properly at DS object creation time!
    fSetDSSecurity = (IsRootCA(pServer->CAType) || pServer->pccExistingCert);

    hr = csiInitializeCertSrvSecurity(
			pServer->pwszSanitizedName, 
			pServer->fUseDS,
			fSetDSSecurity? pServer->fUseDS : FALSE);	// clean SUBCA: happens during cert install, ROOT & reuse cert: apply now
    _JumpIfError(hr, error, "csiInitializeCertSrvSecurity");


    hr = GetSetupStatus(pServer->pwszSanitizedName, &dwSetupStatus);
    if (S_OK == hr)
    {
        if (IsSubordinateCA(pServer->CAType) &&
            (SETUP_SUSPEND_FLAG & dwSetupStatus) &&
            (SETUP_REQUEST_FLAG & dwSetupStatus))
        {
            // put out an info dlg
            CertInfoMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_INCOMPLETE_REQUEST,
                        pServer->pwszRequestFile);
        }
    }
    else
    {
        _PrintError(hr, "GetSetupStatus");
    }

    certocmBumpGasGauge(pComp, 100 DBGPARM(L"InstallServer"));

    hr = S_OK;
error:
    if (NULL != pwszConfig)
    {
        LocalFree(pwszConfig);
    }
    if (NULL != pwszDBFile)
    {
        LocalFree(pwszDBFile);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    CSILOG(hr, IDS_LOG_INSTALL_SERVER, NULL, NULL, NULL);
    return(hr);
}


HRESULT
CreateCertsrvDirectories(
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fUpgrade,
    IN BOOL fServer)
{
    HRESULT hr;
    WCHAR wszCertEnroll[MAX_PATH];
    wszCertEnroll[0] = L'\0';

    BuildPath(
            wszCertEnroll,
            ARRAYSIZE(wszCertEnroll),
            pComp->pwszSystem32,
            wszCERTENROLLSHAREPATH);
    if (0 == CreateDirectory(wszCertEnroll, NULL))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
        {
            _JumpErrorStr(hr, error, "CreateDirectory", wszCertEnroll);
        }
    }

    if (fServer && NULL != pComp->CA.pServer->pwszSharedFolder)
    {
	if (pComp->fUnattended && !fUpgrade)
	{
	    // make sure shared folder is created
	    if (!CreateDirectory(pComp->CA.pServer->pwszSharedFolder, NULL))
	    {
		hr = myHLastError();
		if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
		{
		    _JumpErrorStr(hr, error, "CreateDirectory",
			pComp->CA.pServer->pwszSharedFolder);
		}
	    }
	}

        if (!fUpgrade)
        {
            // set security on shared folder to 
            // FULL: Admins, LocalSystem, DomainAdmins
            // READ: Everyone
            // NOTE: in upgrade path, the system doesn't enable file share yet
            //       so skip the call
            hr = csiSetAdminOnlyFolderSecurity(
                      pComp->CA.pServer->pwszSharedFolder,
                      TRUE,     // apply Everyone:READ
                      pComp->CA.pServer->fUseDS);
            _JumpIfError(hr, error, "csiSetAdminOnlyFolderSecurity");
        }
    }

    hr = S_OK;

error:
    return hr;
}


// following remove unused file/directory/registry

#define wszOLDHELP          L"..\\help\\"
#define wszOLDCERTADM       L"\\certadm"
#define wszOLDCERTQUE       L"\\certque"

VOID
DeleteOldFilesAndDirectories(
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    WCHAR    wszPath[MAX_PATH];
    WCHAR   *pwszCertsrv;
    wszPath[0] = L'\0';

    // old help dir path
    wcscpy(wszPath, pComp->pwszSystem32);
    wcscat(wszPath, wszOLDHELP);
    wcscat(wszPath, wszCERTSRV);
    // remove old help files
    hr = myRemoveFilesAndDirectory(wszPath, TRUE);
    _PrintIfErrorStr(hr, "myRemoveFilesAndDirectory", wszPath);

    // point to system32\certsrv
    wcscpy(wszPath, pComp->pwszSystem32);
    wcscat(wszPath, wszCERTSRV);
    pwszCertsrv = &wszPath[wcslen(wszPath)];

    // old vroot dir path
    wcscpy(pwszCertsrv, wszOLDCERTADM);
    hr = myRemoveFilesAndDirectory(wszPath, TRUE);
    _PrintIfErrorStr(hr, "myRemoveFilesAndDirectory", wszPath);

    wcscpy(pwszCertsrv, wszOLDCERTQUE);
    hr = myRemoveFilesAndDirectory(wszPath, TRUE);
    _PrintIfErrorStr(hr, "myRemoveFilesAndDirectory", wszPath);

    // delete some obsolete registry keys and values

    // old doc sub-component
    hr = myDeleteCertRegValueEx(wszREGKEYOCMSUBCOMPONENTS,
                                NULL,
                                NULL,
                                wszOLDDOCCOMPONENT,
                                TRUE); //absolute path,
    _PrintIfErrorStr2(hr, "myDeleteCertRegValueEx", wszOLDDOCCOMPONENT, hr);

    // old CA cert serial number

    if (NULL != pComp->CA.pServer &&
	NULL != pComp->CA.pServer->pwszSanitizedName)
    {
	hr = myDeleteCertRegValue(
			    pComp->CA.pServer->pwszSanitizedName,
			    NULL,
			    NULL,
			    wszREGCASERIALNUMBER);
	_PrintIfErrorStr2(hr, "myDeleteCertRegValue", wszREGCASERIALNUMBER, hr);
    }
}


VOID
DeleteObsoleteResidue()
{
    HRESULT  hr;

    hr = myDeleteCertRegValueEx(wszREGKEYKEYSNOTTORESTORE,
                                NULL,
                                NULL,
                                wszREGRESTORECERTIFICATEAUTHORITY,
                                TRUE); //absolute path,
    _PrintIfErrorStr(hr, "myDeleteCertRegValueEx",
                     wszREGRESTORECERTIFICATEAUTHORITY);

    hr = myDeleteCertRegValueEx(wszREGKEYFILESNOTTOBACKUP,
                                NULL,
                                NULL,
                                wszREGRESTORECERTIFICATEAUTHORITY,
                                TRUE); //absolute path,
    _PrintIfErrorStr(hr, "myDeleteCertRegValueEx",
                     wszREGRESTORECERTIFICATEAUTHORITY);

}


HRESULT
InstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fServer)
{
    HRESULT hr = pComp->hrContinue;

    _JumpIfError(hr, error, "can't continue");

    hr = CreateCertsrvDirectories(pComp, FALSE, fServer);
    _JumpIfError(hr, error, "CreateCertsrvDirectories");

    // Trigger an autoenroll to download root certs (see bug# 341568)
    if(IsEnterpriseCA(pComp->CA.pServer->CAType))
    {
        hr = TriggerAutoenrollment();
        _JumpIfError(hr, error, "TriggerAutoenrollment");
    }

    if (fServer)
    {
        hr = InstallServer(hwnd, pComp);
        _JumpIfError(hr, error, "InstallServer");
    }
    else
    {
        hr = InstallClient(hwnd, pComp);
        _JumpIfError(hr, error, "InstallClient");
    }
    if (g_fW3SvcRunning)
    {
        hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hwnd,
                 wszW3SVCNAME,
                 FALSE,
                 FALSE,
                 0,    //doesn't matter since no confirm
                 &g_fW3SvcRunning);
        _PrintIfError(hr, "StartAndStopService");
    }

    DeleteOldFilesAndDirectories(pComp);

    hr = S_OK;

error:
    return(hr);
}


HRESULT
BuildMultiStringList(
    IN WCHAR const * const *apwsz,
    IN DWORD cpwsz,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    DWORD i;
    DWORD cwc;
    WCHAR *pwc;
    WCHAR *apwszEmpty[] = { L"", };

    if (0 == cpwsz)
    {
        cpwsz = ARRAYSIZE(apwszEmpty);
        apwsz = apwszEmpty;
    }
    cwc = 1;
    for (i = 0; i < cpwsz; i++)
    {
        cwc += wcslen(apwsz[i]) + 1;
    }
    *ppwszz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *ppwszz);

    pwc = *ppwszz;
    for (i = 0; i < cpwsz; i++)
    {
        wcscpy(pwc, apwsz[i]);
        pwc += wcslen(pwc) + 1;
    }
    *pwc = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwc, *ppwszz) + 1 == cwc);

    hr = S_OK;

error:
    return(hr);
}


HRESULT
helperGetDisableExtensionList(
    PER_COMPONENT_DATA *pComp,
    OUT WCHAR          **ppwszz)
{
    HRESULT hr;
    WCHAR *apwszExt[] = {
        L"",            // C compiler won't allow empty list
	//TEXT(szOID_ENROLL_CERTTYPE_EXTENSION), // 1.3.6.1.4.1.311.20.2
    };

    hr = BuildMultiStringList(apwszExt, ARRAYSIZE(apwszExt), ppwszz);
    _JumpIfError(hr, error, "BuildMultiStringList");

error:
    return(hr);
}


HRESULT
helperGetRequestExtensionList(
    PER_COMPONENT_DATA *pComp,
    OUT WCHAR          **ppwszz)
{
    HRESULT hr;
    WCHAR *apwszExt[] = {
	TEXT(szOID_RSA_SMIMECapabilities),	    // 1.2.840.113549.1.9.15
	TEXT(szOID_CROSS_CERT_DIST_POINTS),	    // 1.3.6.1.4.1.311.10.9.1
	TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),	    // 1.3.6.1.4.1.311.20.2
	TEXT(szOID_CERTSRV_CA_VERSION),		    // 1.3.6.1.4.1.311.21.1
	TEXT(szOID_CERTSRV_PREVIOUS_CERT_HASH),	    // 1.3.6.1.4.1.311.21.2
	TEXT(szOID_CERTIFICATE_TEMPLATE),	    // 1.3.6.1.4.1.311.21.7
	TEXT(szOID_APPLICATION_CERT_POLICIES),	    // 1.3.6.1.4.1.311.21.10
	TEXT(szOID_APPLICATION_POLICY_MAPPINGS),    // 1.3.6.1.4.1.311.21.11
	TEXT(szOID_APPLICATION_POLICY_CONSTRAINTS), // 1.3.6.1.4.1.311.21.12
        TEXT(szOID_KEY_USAGE),			    // 2.5.29.15
        TEXT(szOID_SUBJECT_ALT_NAME2),		    // 2.5.29.17
	TEXT(szOID_NAME_CONSTRAINTS),		    // 2.5.29.30
	TEXT(szOID_CERT_POLICIES),		    // 2.5.29.32
	TEXT(szOID_POLICY_MAPPINGS),		    // 2.5.29.33
	TEXT(szOID_POLICY_CONSTRAINTS),		    // 2.5.29.36
        TEXT(szOID_ENHANCED_KEY_USAGE),		    // 2.5.29.37
    };

    hr = BuildMultiStringList(apwszExt, ARRAYSIZE(apwszExt), ppwszz);
    _JumpIfError(hr, error, "BuildMultiStringList");

error:
    return(hr);
}

HRESULT
FindCACertByCommonNameAndSerialNumber(
    IN HCERTSTORE   hCAStore,
    IN WCHAR const *pwszCommonName,
    IN BYTE const  *pbSerialNumber,
    IN DWORD        cbSerialNumber,
    CERT_CONTEXT const **ppCACert)
{
    HRESULT  hr;
    CERT_RDN_ATTR  rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE,};
    CERT_RDN       rdn = { 1, &rdnAttr };
    CRYPT_INTEGER_BLOB SerialNumber;
    CERT_CONTEXT const *pCACert = NULL;

    CSASSERT(NULL != hCAStore &&
             NULL != pwszCommonName &&
             NULL != pbSerialNumber &&
             NULL != ppCACert);

    *ppCACert = NULL;

    rdnAttr.Value.pbData = (BYTE *) pwszCommonName;
    rdnAttr.Value.cbData = 0;
    pCACert = NULL;
    SerialNumber.pbData = const_cast<BYTE *>(pbSerialNumber);
    SerialNumber.cbData = cbSerialNumber;
    while (TRUE)
    {
        pCACert = CertFindCertificateInStore(
                                hCAStore,
                                X509_ASN_ENCODING,
                                CERT_UNICODE_IS_RDN_ATTRS_FLAG |
                                    CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG,
                                CERT_FIND_SUBJECT_ATTR,
                                &rdn,
                                pCACert);
        if (NULL == pCACert)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertFindCertificateInStore");
        }
        if (myAreSerialNumberBlobsSame(
                            &SerialNumber,
                            &pCACert->pCertInfo->SerialNumber))
        {
            break;      // found correct one
        }
    }

    *ppCACert = pCACert;
     pCACert = NULL;
    hr = S_OK;

error:
    if (NULL != pCACert)
    {
        CertFreeCertificateContext(pCACert);
    }
    return hr;
}


HRESULT
GetCARegSerialNumber(
    IN  WCHAR const *pwszSanitizedCAName,
    OUT BYTE       **ppbSerialNumber,
    OUT DWORD       *pcbSerialNumber)
{
    HRESULT hr;
    WCHAR  *pwszSerialNumber = NULL;
    BYTE   *pbSN = NULL;
    DWORD   cbSN;

    hr = myGetCertRegStrValue(
               pwszSanitizedCAName,
               NULL,
               NULL,
               wszREGCASERIALNUMBER,
               &pwszSerialNumber);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegStrValue",
		wszREGCASERIALNUMBER,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = WszToMultiByteInteger(FALSE, pwszSerialNumber, &cbSN, &pbSN);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    *ppbSerialNumber = pbSN;
    pbSN = NULL;
    *pcbSerialNumber = cbSN;

error:
    if (NULL != pwszSerialNumber)
    {
        LocalFree(pwszSerialNumber);
    }
    if (NULL != pbSN)
    {
        LocalFree(pbSN);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
LoadCurrentCACert(
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszSanitizedName,
    IN BOOL         fSignTest,
    OUT CERT_CONTEXT const **ppcc,
    OUT DWORD *pdwNameId)
{
    HRESULT hr;
    DWORD Count;
    HCERTSTORE hMyStore = NULL;
    BYTE *pbSerialNumber = NULL;
    DWORD cbSerialNumber;
    CRYPT_KEY_PROV_INFO *pKey = NULL;
    DWORD cbKey;
    DWORD dwType;
    CERT_CONTEXT const *pcc = NULL;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    ALG_ID idAlg;
    BOOL fMachineKeyset;

    *ppcc = NULL;
    
    // get prov name

    hr = myGetCertSrvCSP(
		FALSE,		// fEncryptionCSP
                pwszSanitizedName,
                &dwProvType,
                &pwszProvName,
                &idAlg,
                &fMachineKeyset,
		NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    // open my store

    hMyStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    X509_ASN_ENCODING,
                    NULL,                        // hProv
		    CERT_SYSTEM_STORE_LOCAL_MACHINE |
			CERT_STORE_ENUM_ARCHIVED_FLAG,
                   wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    hr = myGetCARegHashCount(pwszSanitizedName, CSRH_CASIGCERT, &Count);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    if (0 == Count)
    {
	*pdwNameId = 0;		// renewal wasn't implemented yet

	// find current CA cert by serial number -- the old fashioned way

	hr = GetCARegSerialNumber(
			    pwszSanitizedName,
			    &pbSerialNumber,
			    &cbSerialNumber);
	_JumpIfError(hr, error, "GetCARegSerialNumber");

	hr = FindCACertByCommonNameAndSerialNumber(
					hMyStore,
					pwszCommonName,
					pbSerialNumber,
					cbSerialNumber,
					&pcc);
	_JumpIfError(hr, error, "FindCACertByCommonNameAndSerialNumber");
    }
    else
    {
	hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedName,
			    CSRH_CASIGCERT,
			    Count - 1,
			    pdwNameId,
			    &pcc);
	_JumpIfError(hr, error, "myFindCACertByHashIndex");
    }

    // get the private key provider info

    if (!myCertGetCertificateContextProperty(
				    pcc,
				    CERT_KEY_PROV_INFO_PROP_ID,
				    CERTLIB_USE_LOCALALLOC,
				    (VOID **) &pKey,
				    &cbKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    if (fSignTest)
    {
        // signing testing
        hr = myValidateHashForSigning(
				pKey->pwszContainerName,
				pwszProvName,
				dwProvType,
				fMachineKeyset,
				&pcc->pCertInfo->SubjectPublicKeyInfo,
				idAlg);
        _JumpIfError(hr, error, "myValidateHashForSigning");
    }

    *ppcc = pcc;
    pcc = NULL;
    hr = S_OK;

error:
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbSerialNumber)
    {
        LocalFree(pbSerialNumber);
    }
    if (NULL != pKey)
    {
        LocalFree(pKey);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pcc)
    {
        CertFreeCertificateContext(pcc);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
ArchiveCACertificate(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    DWORD Count;
    DWORD i;
    CERT_CONTEXT const *pCert = NULL;
    DWORD dwNameId;
    CRYPT_DATA_BLOB Archived;

    // open my store

    hMyStore = CertOpenStore(
                   CERT_STORE_PROV_SYSTEM_W,
                   X509_ASN_ENCODING,
                   NULL,                        // hProv
                   CERT_SYSTEM_STORE_LOCAL_MACHINE,
                   wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    hr = myGetCARegHashCount(pwszSanitizedName, CSRH_CASIGCERT, &Count);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    for (i = 0; i < Count; i++)
    {
	hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedName,
			    CSRH_CASIGCERT,
			    i,
			    &dwNameId,
			    &pCert);
	_PrintIfError(hr, "myFindCACertByHashIndex");
	if (S_OK == hr)
	{
	    Archived.cbData = 0;
	    Archived.pbData = NULL;

	    // We force an archive on the old cert and close it.

	    CertSetCertificateContextProperty(
					    pCert,
					    CERT_ARCHIVED_PROP_ID,
					    0,
					    &Archived);
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// determine CA info, from build to build upgrade

HRESULT
DetermineCAInfoAndType(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    ENUM_CATYPES CATypeDummy;
    WCHAR *pwszCommonName = NULL;
    CERT_CONTEXT const *pCACert = NULL;
    DWORD dwNameId;

    // ca type
    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     NULL,
                     NULL,
                     wszREGCATYPE,
                     (DWORD *) &CATypeDummy);
    if (S_OK == hr)
    {
        pServer->CAType = CATypeDummy;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGCATYPE);
    }
    // else keep default CAType flag

    // get current ca common name

    hr = myGetCertRegStrValue(
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCOMMONNAME,
			&pwszCommonName);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCOMMONNAME);

    hr = LoadCurrentCACert(
		    pwszCommonName,
		    pServer->pwszSanitizedName,
		    FALSE,  // don't do signing test during upgrade
		    &pCACert,
		    &pServer->dwCertNameId);
    _JumpIfError(hr, error, "LoadCurrentCACert");

    // now ready to load DN info

    hr = DetermineExistingCAIdInfo(pServer, pCACert);
    _JumpIfError(hr, error, "DetermineExistingCAIdInfo");

    if (NULL != pServer->pccUpgradeCert)
    {
        CertFreeCertificateContext(pServer->pccUpgradeCert);
    }
    pServer->pccUpgradeCert = pCACert;
    pCACert = NULL;

error:
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    if (NULL != pCACert)
    {
        CertFreeCertificateContext(pCACert);
    }
    return(hr);
}


// the following will determine ca sanitized name and upgrade path
HRESULT
DetermineServerUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR   *pwszDummy = NULL;
    WCHAR   *pwszSanitizedCAName = NULL;
    LPWSTR pwszB2PolicyGuid = NULL;
    DWORD dwVersion;

    if (CS_UPGRADE_UNKNOWN != pComp->UpgradeFlag)
    {
        // already know upgrade type
        CSASSERT(pServer->pwszSanitizedName); // this is a side-effect of this fxn, better have been set already
        return S_OK;
    }
    
    // get active ca name
    hr = myGetCertRegStrValue(
        NULL,
        NULL,
        NULL,
        wszREGACTIVE,
        &pwszSanitizedCAName);
    if (hr != S_OK)
    {
        BOOL fFinishCYS;

        //for W2K after, it is possible to be in post mode
        hr = CheckPostBaseInstallStatus(&fFinishCYS);
        if (S_OK == hr && !fFinishCYS)
        {
            //this could be either w2k or whistler
            //treat as whistler since upgrade path won't execute
            pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;
            goto done;
        }

        // wszREGACTIVE used in Win2k product and after. If not found, this is way before our time
        
        // make sure by grabbing wszREGSP4DEFAULTCONFIGURATION
        LPWSTR pwszTmp = NULL;
        hr = myGetCertRegStrValue(
            NULL,
            NULL,
            NULL,
            wszREGSP4DEFAULTCONFIGURATION,
            &pwszTmp);
        if (pwszTmp)
            LocalFree(pwszTmp);
        
        // error! bail, we have no idea what we're seeing
        _JumpIfError(hr, error, "myGetCertRegStrValue wszREGSP4DEFAULTCONFIGURATION");
        
        // hr == S_OK: yep, looks like valid NT4 installation
        pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;	
        CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
        _JumpError(hr, error, "myGetCertRegStrValue");
    }
    
    // check wszREGVERSION to get current version
    hr = myGetCertRegDWValue(
        NULL,
        NULL,
        NULL,
        wszREGVERSION,
        &dwVersion);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)!= hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGVERSION);
    }
    // now either OK or FILE_NOT_FOUND
    
    if (S_OK == hr)
    {
        // pComp->UpgradeFlag = SOME_FUNCTION(dwVersion);		// CS_UPGRADE_WHISTLER already set as default; in future, key off of this
        pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;
        
        CSILOG(S_OK, IDS_LOG_UPGRADE_B2B, NULL, NULL, NULL);
    }
    else
    {
        // FILE_NOT_FOUND: now we know it's (NT5 Beta 2 <= X < Whistler)
        
        // is this Win2k, or NT5 Beta? Test for active policy module to have "ICertManageModule" entry
        // check nt5 beta 2 and get active policy name
        hr = myGetCertRegStrValue(
            pwszSanitizedCAName,
            wszREGKEYPOLICYMODULES,
            NULL,
            wszREGACTIVE,
            &pwszB2PolicyGuid);
        if (S_OK == hr)
        {
            hr = myGetCertRegStrValue(
                wszREGKEYPOLICYMODULES,
                pwszB2PolicyGuid,
                NULL,
                wszREGB2ICERTMANAGEMODULE,
                &pwszDummy);
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                // this doesn't exist on Win2k
                pComp->UpgradeFlag = CS_UPGRADE_WIN2000;
                CSILOG(S_OK, IDS_LOG_UPGRADE_WIN2000, NULL, NULL, NULL);
            }
            else
            {
                // this is definitely beta 2
                pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;
                CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // strange, maybe no active module. Assume OK, latest bits.
            pComp->UpgradeFlag = CS_UPGRADE_WIN2000;
            CSILOG(S_OK, IDS_LOG_UPGRADE_WIN2000, NULL, NULL, NULL);
        }
        else
        {
            // other failure, just bail
            _JumpErrorStr(hr, error, "myGetCertRegStrValue",
                wszREGKEYPOLICYMODULES);
        }
    }	// wszREGVERSION: FILE_NOT_FOUND
    
    // take sanitized name
    if (NULL != pServer->pwszSanitizedName)
    {
        // this will free the default name
        LocalFree(pServer->pwszSanitizedName);
    }
    pServer->pwszSanitizedName = pwszSanitizedCAName;
    pwszSanitizedCAName = NULL;
    
done:
    hr = S_OK;
    
error:

    if (NULL != pwszDummy)
    {
        LocalFree(pwszDummy);
    }
    if (NULL != pwszSanitizedCAName)
    {
        LocalFree(pwszSanitizedCAName);
    }

    CSILOG(hr, IDS_LOG_UPGRADE_TYPE, NULL, NULL, (DWORD const *) &pComp->UpgradeFlag);
    return hr;
}


// Description: load and determine necessary information for upgrade
//              upgrade won't continue if any error
HRESULT
LoadAndDetermineServerUpgradeInfo(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    WCHAR   *pwszRevocationType = NULL;
    DWORD    dwNetscapeType;
    BOOL     fDummy;
    ALG_ID   idAlgDummy;
    CSP_INFO CSPInfoDummy;
    ENUM_CATYPES CATypeDummy;
    WCHAR       *pwszCommonName = NULL;

    // initialize
    ZeroMemory(&CSPInfoDummy, sizeof(CSPInfoDummy));

    // load information for all upgrade scenarios

    // csp

    hr = myGetCertRegStrValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszREGPROVIDER,
                     &CSPInfoDummy.pwszProvName);
    if (S_OK == hr && NULL != CSPInfoDummy.pwszProvName)
    {
        if (NULL != pServer->pCSPInfo->pwszProvName)
        {
            // free default csp
            LocalFree(pServer->pCSPInfo->pwszProvName);
        }
        // use reg one as default for upgrade
        pServer->pCSPInfo->pwszProvName = CSPInfoDummy.pwszProvName;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGPROVIDER);
    }
    
    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszREGPROVIDERTYPE,
                     &CSPInfoDummy.dwProvType);
    if (S_OK == hr)
    { 
        pServer->pCSPInfo->dwProvType = CSPInfoDummy.dwProvType;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGPROVIDERTYPE);
    }

    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszMACHINEKEYSET,
                     (DWORD*)&CSPInfoDummy.fMachineKeyset);
    if (S_OK == hr)
    {
         pServer->pCSPInfo->fMachineKeyset = CSPInfoDummy.fMachineKeyset;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszMACHINEKEYSET);
    }

    hr = myGetCertRegDWValue(
                     pServer->pwszSanitizedName,
                     wszREGKEYCSP,
                     NULL,
                     wszHASHALGORITHM,
                     (DWORD*)&idAlgDummy);
    if (S_OK == hr)
    { 
        pServer->pHashInfo->idAlg = idAlgDummy;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpIfErrorStr(hr, error, "myGetCertRegDWValue", wszHASHALGORITHM);
    }

    if (NULL != pServer->pCSPInfoList)
    {
        // BUG, this will never happen because csp info list is not loaded yet
        // one more checking, make sure csp is installed
        if (NULL == findCSPInfoFromList(
                         pServer->pCSPInfoList,
                         pServer->pCSPInfo->pwszProvName,
                         pServer->pCSPInfo->dwProvType))
        {
            // if not, this is a broken ca
            hr = E_INVALIDARG;
            _JumpErrorStr(hr, error, "findCSPInfoFromList",
                pServer->pCSPInfo->pwszProvName);
        }
    }

    // UseDS flag
    hr = myGetCertRegDWValue(
                 pServer->pwszSanitizedName,
                 NULL,
                 NULL,
                 wszREGCAUSEDS,
                 (DWORD*)&fDummy);
    if (S_OK == hr)
    {
        // use from reg
        pServer->fUseDS = fDummy;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGCAUSEDS);
    }

    // CACommonName
    // this will be used for looking cert in store to determine ca DN info
    hr = myGetCertRegStrValue(
                pServer->pwszSanitizedName,
                NULL,
                NULL,
                wszREGCOMMONNAME,
                &pwszCommonName);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpError(hr, error, "myGetCertRegStrValue");
    }
    else if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
             (S_OK == hr && L'\0' == pwszCommonName[0]))
    {
        if (S_OK == hr && L'\0' == pwszCommonName[0])
        {
            // empty string, use snaitized name instead
            LocalFree(pwszCommonName);
        }
        // in case empty or not found, use sanitized
        pwszCommonName = (WCHAR*)LocalAlloc(LMEM_FIXED,
            (wcslen(pServer->pwszSanitizedName) + 1) * sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pwszCommonName);
        wcscpy(pwszCommonName, pServer->pwszSanitizedName);
    }
    if (NULL != pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
    }
    pServer->pwszCACommonName = pwszCommonName;
    pwszCommonName = NULL;


    // Collect CAType, DN info, dwCertNameId and upgrade ca cert
    hr = DetermineCAInfoAndType(pComp);
    _JumpIfError(hr, error, "DetermineCAInfoAndType");


    // load following values for later

    // check revocation type

    hr = myGetCertRegDWValue(
                    pServer->pwszSanitizedName,
                    wszREGKEYPOLICYMODULES,
                    wszCLASS_CERTPOLICY,
                    wszREGREVOCATIONTYPE,
                    &pServer->dwRevocationFlags);
    if(hr != S_OK)
    {
        pServer->dwRevocationFlags = pServer->fUseDS?
                                    REVEXT_DEFAULT_DS : REVEXT_DEFAULT_NODS;
    }

    // following for web page creation

    // load shared folder for ca cert file name creation
    if (NULL != pServer->pwszSharedFolder)
    {
        // shouldn't happen but in case
        LocalFree(pServer->pwszSharedFolder);
        pServer->pwszSharedFolder = NULL;
    }
    hr = myGetCertRegStrValue(
                    NULL,
                    NULL,
                    NULL,
                    wszREGDIRECTORY,
                    &pServer->pwszSharedFolder);
    if (S_OK == hr && L'\0' == pServer->pwszSharedFolder[0])
    {
        // in case of empty, set to null
        LocalFree(pServer->pwszSharedFolder);
        pServer->pwszSharedFolder = NULL;
    }
    else if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
        _JumpError(hr, error, "myGetCertRegStrValue");
    }
        
    // build ca cert file name for web install and ca cert saving
    if (NULL != pServer->pwszCACertFile)
    {
        // free old one
        LocalFree(pServer->pwszCACertFile);
    }
    hr = csiBuildCACertFileName(
			pComp->hInstance,
			NULL,  //hwnd, ok for upgrade
			pComp->fUnattended,
			pServer->pwszSharedFolder,
			pServer->pwszSanitizedName,
			L".crt",
			0,	// iCert
			&pServer->pwszCACertFile);
    _JumpIfError(hr, error, "BuildCACertFileName");

    hr = S_OK;

error:
    if (NULL != pwszRevocationType)
    {
        LocalFree(pwszRevocationType);
    }
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    return hr;
}


HRESULT
GetConfigInSharedFolderWithCert(
    WCHAR const *pwszSharedFolder,
    OUT WCHAR  **ppwszConfig)
{
    HRESULT  hr;
    ICertConfig * pICertConfig = NULL;
    BSTR bstrConfig = NULL;
    BOOL fCoInit = FALSE;
    WCHAR *pwszCAMachine;
    WCHAR *pwszCAName;
    WCHAR wszCertFileInSharedFolder[MAX_PATH];
    LONG i;
    LONG lCount;
    LONG Index;
    BOOL fLocal;

    CSASSERT(NULL != ppwszConfig);
    *ppwszConfig = NULL;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    hr = CoCreateInstance(
                    CLSID_CCertConfig,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_ICertConfig,
                    (VOID**) &pICertConfig);
    _JumpIfError(hr, error, "CoCreateInstance");

    // get local
    hr = pICertConfig->Reset(0, &lCount);
    _JumpIfError(hr, error, "ICertConfig->Reset");

    for (i = 0; i < lCount; ++i)
    {
        hr = pICertConfig->Next(&Index);
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "ICertConfig->Next");
        }
        if (-1 == Index)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            _JumpError(hr, error, "No CA cert file");
        }
        hr = pICertConfig->GetField(wszCONFIG_CONFIG, &bstrConfig);
        _JumpIfError(hr, error, "ICertConfig->GetField(Config)");

        pwszCAMachine = (WCHAR*)bstrConfig;
        pwszCAName = wcschr(pwszCAMachine, L'\\');
        if (NULL == pwszCAName)
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Invalid config string");
        }
        pwszCAName[0] = '\0'; // make pwszCAMachine
        ++pwszCAName;

        // form NT4 ca cert file path in shared folder
        wcscpy(wszCertFileInSharedFolder, pwszSharedFolder);
        wcscat(wszCertFileInSharedFolder, L"\\");
        wcscat(wszCertFileInSharedFolder, pwszCAMachine);
        wcscat(wszCertFileInSharedFolder, L"_");
        wcscat(wszCertFileInSharedFolder, pwszCAName);
        wcscat(wszCertFileInSharedFolder, L".crt");

	DBGPRINT((
	    DBG_SS_CERTOCM,
	    "wszCertFileInSharedFolder: %ws\n",
	    wszCertFileInSharedFolder));

        if (myDoesFileExist(wszCertFileInSharedFolder))
        {
            //done
            break;
        }
        SysFreeString(bstrConfig);
        bstrConfig = NULL;
    }
    if (i >= lCount)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        _JumpError(hr, error, "No CA cert file");
    }

    *ppwszConfig = (WCHAR*)LocalAlloc(LMEM_FIXED,
                        SysStringByteLen(bstrConfig) + sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *ppwszConfig);
    wcscpy(*ppwszConfig, bstrConfig);

    hr = S_OK;
error:
    if (NULL != pICertConfig)
    {
        pICertConfig->Release();
    }
    if (NULL != bstrConfig)
    {
        SysFreeString(bstrConfig);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return hr;
}


HRESULT
DetermineClientUpgradePath(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;
    WCHAR       *pwszCAName;
    DWORD       dwVersion;

    if (CS_UPGRADE_UNKNOWN != pComp->UpgradeFlag)
    {
        // already know upgrade type
        CSASSERT(pClient->pwszWebCAMachine); // this is a side-effect of this fxn, better have been set already
        CSASSERT(pClient->pwszWebCAName);    // this is a side-effect of this fxn, better have been set already
        return S_OK;
    }

    //get ca info from registry here
    if (NULL != pClient->pwszWebCAMachine)
    {
        // shouldn't happen, just in case
        LocalFree(pClient->pwszWebCAMachine);
        pClient->pwszWebCAMachine = NULL;
    }
    if (NULL != pClient->pwszWebCAName)
    {
        // shouldn't happen, just in case
        LocalFree(pClient->pwszWebCAName);
        pClient->pwszWebCAName = NULL;
    }

    // get ca machine
    hr = myGetCertRegStrValue(
        NULL, 
        NULL, 
        NULL, 
        wszREGWEBCLIENTCAMACHINE,
        &pClient->pwszWebCAMachine);
    if (S_OK != hr || L'\0' == pClient->pwszWebCAMachine[0])
    {
        BOOL fFinishCYS;

        //for W2K after, it is possible to be in post mode
        hr = CheckPostBaseInstallStatus(&fFinishCYS);
        if (S_OK == hr && !fFinishCYS)
        {
            //this could be either w2k or whistler
            //treat as whistler since upgrade path won't execute
            pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;
            goto done;
        }

        // incorrect reg state,
        // either not found entry or empty string: NT4
        pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;
        hr = S_OK;

        CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
        _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGWEBCLIENTCAMACHINE);
    }

    // get ca
    hr = myGetCertRegStrValue(
        NULL, 
        NULL, 
        NULL, 
        wszREGWEBCLIENTCANAME,
        &pClient->pwszWebCAName);
    if (S_OK != hr || L'\0' == pClient->pwszWebCAName[0])
	{
        // incorrect reg state,
        // either not found entry or empty string: NT4
        if (pClient->pwszWebCAMachine)
            LocalFree(pClient->pwszWebCAMachine);

        pComp->UpgradeFlag = CS_UPGRADE_UNSUPPORTED;
        hr = S_OK;

        CSILOG(S_OK, IDS_LOG_UPGRADE_UNSUPPORTED, NULL, NULL, NULL);
        _JumpErrorStr(hr, error, "myGetCertRegStrValue", wszREGWEBCLIENTCANAME);
    }

    // Now either W2k or Whistler

    // check wszREGVERSION to get current version on Whistler++
    hr = myGetCertRegDWValue(
             NULL,
             NULL,
             NULL,
             wszREGVERSION,
             &dwVersion);
    if (S_OK != hr && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)!= hr)
    {
        _JumpErrorStr(hr, error, "myGetCertRegDWValue", wszREGVERSION);
    }
    // now either OK or FILE_NOT_FOUND

    if (S_OK == hr)
    {
	    // pComp->UpgradeFlag = SOME_FUNCTION(dwVersion);		// CS_UPGRADE_WHISTLER already set as default; in future, key off of this
        pComp->UpgradeFlag = CS_UPGRADE_WHISTLER;

	    CSILOG(S_OK, IDS_LOG_UPGRADE_B2B, NULL, NULL, NULL);
    }
    else
    {
		pComp->UpgradeFlag = CS_UPGRADE_WIN2000;

        CSILOG(S_OK, IDS_LOG_UPGRADE_WIN2000, NULL, NULL, NULL);
    }

done:
    hr = S_OK;

error:
    CSILOG(hr, IDS_LOG_UPGRADE_TYPE, NULL, NULL, (DWORD const *) &pComp->UpgradeFlag);
    return hr;
}



HRESULT
LoadAndDetermineClientUpgradeInfo(
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;
    WCHAR       *pwszCAName;
    DWORD       dwVersion;

    //get ca info from registry here
    if (NULL != pClient->pwszSanitizedWebCAName)
    {
        // shouldn't happen, just in case
        LocalFree(pClient->pwszSanitizedWebCAName);
        pClient->pwszSanitizedWebCAName = NULL;
    }

    hr = DetermineClientUpgradePath(pComp);
    _JumpIfError(hr, error, "DetermineClientUpgradePath");


	// get ca
	hr = myGetCertRegDWValue(
			 NULL,
			 NULL,
			 NULL,
			 wszREGWEBCLIENTCATYPE,
			 (DWORD *) &pClient->WebCAType);
	_PrintIfErrorStr(hr, "myGetCertRegDWValue", wszREGWEBCLIENTCATYPE);


    hr = mySanitizeName(pClient->pwszWebCAName,
                        &pClient->pwszSanitizedWebCAName);
    _JumpIfError(hr, error, "mySanitizeName");

    hr = S_OK;

error:
    CSILOG(hr, IDS_LOG_UPGRADE_TYPE, NULL, NULL, (DWORD const *) &pComp->UpgradeFlag);
    return hr;
}



// apply ACL to key container for all upgrade scenarios

HRESULT
UpgradeKeyContainerSecurity(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    HCRYPTPROV hProv = NULL;
    WCHAR *pwszProvName = NULL;
    DWORD dwProvType;
    ALG_ID idAlg;
    BOOL fMachineKeyset;

    // get prov name

    hr = myGetCertSrvCSP(
		FALSE,		// fEncryptionCSP
                pComp->CA.pServer->pwszSanitizedName,
                &dwProvType,
                &pwszProvName,
                &idAlg,
                &fMachineKeyset,
		NULL);		// pdwKeySize
    _JumpIfError(hr, error, "myGetCertSrvCSP");

    if (!myCertSrvCryptAcquireContext(&hProv,
                                    pComp->CA.pServer->pwszSanitizedName,
                                    pwszProvName,
                                    dwProvType,
                                    CRYPT_SILENT,  // get key, upgrade, no UI
                                    fMachineKeyset))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    // set acl on it

    hr = csiSetKeyContainerSecurity(hProv);
    _JumpIfError(hr, error, "csiSetKeyContainerSecurity");

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    CSILOG(hr, IDS_LOG_UPGRADE_KEY_SECURITY, NULL, NULL, NULL);
    return hr;
}

    
HRESULT InstallNewTemplates(HWND hwnd)
{
    HRESULT hr = S_OK;
    SHELLEXECUTEINFO shi;

    ZeroMemory(&shi, sizeof(shi));
    shi.cbSize = sizeof(shi);
    shi.hwnd = hwnd;
    shi.lpVerb = SZ_VERB_OPEN;
    shi.lpFile = SZ_REGSVR32;
    shi.lpParameters = SZ_REGSVR32_CERTCLI;
    shi.fMask = SEE_MASK_FLAG_NO_UI |
                SEE_MASK_NOCLOSEPROCESS;

    if(!ShellExecuteEx(&shi))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ShellExecuteEx");
    }

    if(WAIT_FAILED == WaitForSingleObject(shi.hProcess, INFINITE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WaitForSingleObject");
    }

error:
    if(shi.hProcess)
    {
        CloseHandle(shi.hProcess);
    }
    return hr;
}


HRESULT
UpgradeServer(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    hr = RegisterAndUnRegisterDLLs(RD_SERVER|RD_SKIPUNREGMMC, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

    hr = LoadAndDetermineServerUpgradeInfo(pComp);
    _JumpIfError(hr, error, "LoadAndDetermineServerUpgradeInfo");

    // create enroll dir
    hr = CreateCertsrvDirectories(pComp, TRUE, TRUE);
    _JumpIfError(hr, error, "CreateCertsrvDirectories");

    hr = EnableVRootsAndShares(FALSE, TRUE, TRUE, pComp);
    _PrintIfError(hr, "EnableVRootsAndShares(share only)");

    hr = UpgradeServerRegEntries(hwnd, pComp);
    _JumpIfError(hr, error, "UpgradeServerRegEntries");

    hr = CreateCertWebIncPages(hwnd, pComp, TRUE /*IsServer*/, TRUE);
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, TRUE);
    _JumpIfError(hr, error, "RenameMiscTargets");

    hr = UpgradeKeyContainerSecurity(hwnd, pComp);
    // ignore new acl failure
    _PrintIfError(hr, "UpgradeKeyContainerSecurity");

    // always register dcom
    hr = RegisterDcomServer(
                        CLSID_CCertRequestD,
                        wszREQUESTFRIENDLYNAME,
                        wszREQUESTVERINDPROGID,
                        wszREQUESTPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");

    hr = RegisterDcomServer(
                        CLSID_CCertAdminD,
                        wszADMINFRIENDLYNAME,
                        wszADMINVERINDPROGID,
                        wszADMINPROGID);
    _JumpIfError(hr, error, "RegisterDcomServer");

    hr = RegisterDcomApp(CLSID_CCertRequestD);
    _JumpIfError(hr, error, "RegisterDcomApp");

    // fix for 155772	Certsrv: After upgrading a 2195 Enterprise Root CA 
    //                  to 2254.01VBL03 the CA will no longer issue Certs
    hr = InstallNewTemplates(hwnd);
    _JumpIfError(hr, error, "InstallNewTemplates");

    // always fix certsvc in upgrade
    hr = FixCertsvcService(pComp);
    _PrintIfError(hr, "FixCertsvcService");

    // delete any old program groups
    DeleteProgramGroups(TRUE, pComp);

    hr = CreateProgramGroups(FALSE, pComp, hwnd);
    _PrintIfError(hr, "CreateProgramGroups");

    // delete old stuff
    DeleteOldFilesAndDirectories(pComp);

    DBGPRINT((DBG_SS_CERTOCM, "UpgradeServer: setting SETUP_SERVER_UPGRADED_FLAG\n"));

    hr = SetSetupStatus(NULL, SETUP_SERVER_UPGRADED_FLAG, TRUE);
    _JumpIfError(hr, error, "SetSetupStatus");

    hr = csiUpgradeCertSrvSecurity(
            pServer->pwszSanitizedName,
            IsEnterpriseCA(pServer->CAType)?true:false,
            pServer->fUseDS?true:false,
            pComp->UpgradeFlag);
    if (hr == HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE))
    { 
        _PrintError(hr, "csiUpgradeCertSrvSecurity marked for later fixup; error ignored");
        hr = S_OK;
    }
    _JumpIfError(hr, error, "csiUpgradeCertSrvSecurity");

    hr = S_OK;
error:
    CSILOG(hr, IDS_LOG_UPGRADE_SERVER, NULL, NULL, NULL);
    return hr;
}


HRESULT
UpgradeClient(
    IN HWND                hwnd,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    if ((IS_CLIENT_UPGRADE & pComp->dwInstallStatus) &&
        (IS_SERVER_UPGRADE & pComp->dwInstallStatus))
    {
        // upgrade server will also hit here so skip it
        goto done;
    }

    // unset client
    hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, FALSE);
    _JumpIfError(hr, error, "SetSetupStatus");

    hr = RegisterAndUnRegisterDLLs(RD_CLIENT|RD_SKIPUNREGMMC, pComp, hwnd);
    _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

    hr = LoadAndDetermineClientUpgradeInfo(pComp);
    _JumpIfError(hr, error, "LoadAndDetermineClientUpgradeInfo");

    hr = UpgradeWebClientRegEntries(pComp);
    _JumpIfError(hr, error, "UpgradeWebClientRegEntries");

    hr = CreateCertWebIncPages(hwnd, pComp, FALSE /*IsServer*/, TRUE);
    _JumpIfError(hr, error, "CreateCertWebIncPages");

    hr = RenameMiscTargets(hwnd, pComp, FALSE);
    _JumpIfError(hr, error, "RenameMiscTargets");

    // delete any old program groups
    DeleteProgramGroups(FALSE, pComp);

    hr = CreateProgramGroups(TRUE, pComp, hwnd);
    _PrintIfError(hr, "CreateProgramGroups");

    hr = SetSetupStatus(NULL, SETUP_CLIENT_FLAG, TRUE);
    _JumpIfError(hr, error, "SetSetupStatus");

    DeleteOldFilesAndDirectories(pComp);

done:
    hr = S_OK;
error:
    CSILOG(hr, IDS_LOG_UPGRADE_CLIENT, NULL, NULL, NULL);
    return hr;
}


HRESULT
GetServerNames(
    IN HWND hwnd,
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    OUT WCHAR **ppwszServerName,
    OUT WCHAR **ppwszServerNameOld)
{
    HRESULT hr;

    // Retrieve computer name strings.

    hr = myGetComputerNames(ppwszServerName, ppwszServerNameOld);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
           hInstance,
           fUnattended,
           hwnd,
           IDS_ERR_GETCOMPUTERNAME,
           hr,
           NULL);
        _JumpError(hr, error, "myGetComputerNames");
    }

error:
    return(hr);
}


HRESULT
UpdateDomainAndUserName(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;

    // free old server and installer info because we might get them in nt base

    if (NULL != pComp->pwszServerName)
    {
        LocalFree(pComp->pwszServerName);
        pComp->pwszServerName = NULL;
    }
    if (NULL != pComp->pwszServerNameOld)
    {
        LocalFree(pComp->pwszServerNameOld);
        pComp->pwszServerNameOld = NULL;
    }
    hr = GetServerNames(
		    hwnd,
		    pComp->hInstance,
		    pComp->fUnattended,
		    &pComp->pwszServerName,
		    &pComp->pwszServerNameOld);
    _JumpIfError(hr, error, "GetServerNames");

    DBGPRINT((DBG_SS_CERTOCM, "UpdateDomainAndUserName:%ws,%ws\n", pComp->pwszServerName, pComp->pwszServerNameOld));
    DumpBackTrace("UpdateDomainAndUserName");

error:
    return(hr);
}


HRESULT
StopCertService(
    IN HWND hwnd,
    IN SC_HANDLE hSC,
    IN WCHAR const *pwszServiceName)
{
    HRESULT hr;
    SERVICE_STATUS status;
    DWORD dwAttempt;

    if (!ControlService(hSC, SERVICE_CONTROL_STOP, &status))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) != hr)
        {
            _JumpErrorStr(hr, error, "ControlService(Stop)", pwszServiceName);
        }
    }

    // get out after it is really stopped

    for (dwAttempt = 0; dwAttempt < CERT_MAX_ATTEMPT; dwAttempt++)
    {
        DBGCODE(status.dwCurrentState = -1);
        if (!QueryServiceStatus(hSC, &status))
        {
            // query failed, ignore error
            hr = S_OK;

            _JumpErrorStr(
                    myHLastError(),             // Display ignored error
                    error,
                    "QueryServiceStatus",
                    pwszServiceName);
        }
        if (status.dwCurrentState != SERVICE_STOP_PENDING &&
            status.dwCurrentState != SERVICE_RUNNING)
        {
            // it was stopped already
            break;
        }
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Stopping %ws service: current state=%d\n",
                pwszServiceName,
                status.dwCurrentState));
        Sleep(CERT_HALF_SECOND);
    }
    if (dwAttempt >= CERT_MAX_ATTEMPT)
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Timeout stopping %ws service: current state=%d\n",
                pwszServiceName,
                status.dwCurrentState));
    }
    else
    {
        DBGPRINT((
                DBG_SS_CERTOCM,
                "Stopped %ws service\n",
                pwszServiceName));
    }
    hr = S_OK;

error:
    CSILOG(hr, IDS_LOG_SERVICE_STOPPED, pwszServiceName, NULL, NULL);
    return(hr);
}


HRESULT
GetServiceControl(
    WCHAR const   *pwszServiceName,
    OUT SC_HANDLE *phService)
{
    HRESULT hr;
    SC_HANDLE hSCManager = NULL;

    *phService = NULL;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }
    *phService = OpenService(hSCManager, pwszServiceName, SERVICE_ALL_ACCESS);
    if (NULL == *phService)
    {
        hr = myHLastError();
        _JumpErrorStr2(
                    hr,
                    error,
                    "OpenService",
                    pwszServiceName,
                    HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST));
    }

    hr = S_OK;
error:
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    return hr;
}


HRESULT
IsServiceRunning(
    IN SC_HANDLE const hSCService,
    OUT BOOL *pfRun)
{
    HRESULT hr;
    SERVICE_STATUS status;

    *pfRun = FALSE;
    if (!QueryServiceStatus(hSCService, &status))
    {
        hr = myHLastError();
        _JumpError(hr, error, "QueryServiceStatus");
    }
    if (SERVICE_STOPPED != status.dwCurrentState &&
        SERVICE_STOP_PENDING != status.dwCurrentState)
    {
        *pfRun = TRUE;
    }

    hr = S_OK;
error:
    return hr;
}


HRESULT
StartAndStopService(
    IN HINSTANCE    hInstance,
    IN BOOL         fUnattended,
    IN HWND const   hwnd,
    IN WCHAR const *pwszServiceName,
    IN BOOL const   fStopService,
    IN BOOL const   fConfirm,
    IN int          iMsg,
    OUT BOOL       *pfServiceWasRunning)
{
    HRESULT hr;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS status;

    *pfServiceWasRunning = FALSE;

    hr = GetServiceControl(pwszServiceName, &hService);
    if (S_OK != hr)
    {
        _PrintError2(
                hr,
                "GetServiceControl",
                HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST));
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr)
        {
            hr = S_OK;
        }
        goto error;
    }

    // to get status if the service is running
    hr = IsServiceRunning(hService, pfServiceWasRunning);
    _JumpIfError(hr, error, "IsServiceRunning");

    if (fStopService)
    {
        if (*pfServiceWasRunning)
        {
            // stop the service
            if (fConfirm)
            {
                // confirmation dialog
                int ret = CertMessageBox(
                            hInstance,
                            fUnattended,
                            hwnd,
                            iMsg,
                            0,
                            MB_YESNO |
				MB_ICONWARNING |
				CMB_NOERRFROMSYS,
                            NULL);
                if (IDYES != ret)
                {
                    hr = E_ABORT;
                    _JumpError(hr, error, "Cancel it");
                }
            }
            hr = StopCertService(hwnd, hService, pwszServiceName);
            _JumpIfErrorStr(hr, error, "StopCertService", pwszServiceName);
        }
    }
    else
    {
        // START the service
        if (!*pfServiceWasRunning)
        {
            if (!StartService(hService, 0, NULL))
            {
                hr = myHLastError();
                _JumpErrorStr(hr, error, "StartService", pwszServiceName);
            }
        }
    }
    hr = S_OK;

error:
    if (NULL != hService)
    {
        CloseServiceHandle(hService);
    }
    CSILOG(
	    hr,
	    fStopService? IDS_LOG_SERVICE_STOPPED : IDS_LOG_SERVICE_STARTED,
	    pwszServiceName,
	    NULL,
	    NULL);
    return hr;
}

// fix existing certsvc service to add/use new service description
HRESULT
FixCertsvcService(PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    SC_HANDLE hService = NULL;
    QUERY_SERVICE_CONFIG *pServiceConfig = NULL;
    WCHAR     *pwszServiceDesc = NULL;
    WCHAR const *pwszDisplayName;
    SERVICE_DESCRIPTION sd;
    DWORD      dwSize;

    hr = GetServiceControl(wszSERVICE_NAME, &hService);
    _JumpIfError(hr, error, "GetServiceControl");

    // get size
    if (!QueryServiceConfig(hService,
                            NULL,
                            0,
                            &dwSize))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
        {
            _JumpError(hr, fix_desc, "QueryServiceConfig");
        }
    }
    else
    {
        // impossible???
        hr = E_INVALIDARG;
        _JumpError(hr, fix_desc, "QueryServiceConfig");
    }

    CSASSERT(0 < dwSize);

    // allocate config buffer
    pServiceConfig = (QUERY_SERVICE_CONFIG*)LocalAlloc(
                      LMEM_FIXED | LMEM_ZEROINIT,
                      dwSize);
    _JumpIfOutOfMemory(hr, error, pServiceConfig);

    // get config
    if (!QueryServiceConfig(hService,
                           pServiceConfig,
                           dwSize,
                           &dwSize))
    {
        hr = myHLastError();
        _JumpError(hr, fix_desc, "QueryServiceConfig");
    }

    // use new display name
    pwszDisplayName = myLoadResourceString(IDS_CA_SERVICEDISPLAYNAME);
    if (NULL == pwszDisplayName)
    {
        hr = myHLastError();
        _JumpError(hr, error, "myLoadResourceString");
    }

    if (!ChangeServiceConfig(hService,
                             pServiceConfig->dwServiceType, //dwServiceType
                             SERVICE_NO_CHANGE,    //dwStartType
                             SERVICE_NO_CHANGE,    //dwErrorControl
                             NULL,                 //lpBinaryPathName
                             NULL,                 //lpLoadOrderGroup
                             NULL,                 //lpdwTagId
                             NULL,                 //lpDependences
                             NULL,                 //lpServiceStartName
                             NULL,                 //lpPassword
                             pwszDisplayName))
    {
        hr = myHLastError();
        _JumpIfError(hr, fix_desc, "ChangeServiceConfig");
    }

fix_desc:
    // add description
    hr = myLoadRCString(pComp->hInstance, IDS_CA_SERVICEDESCRIPTION, &pwszServiceDesc);
    _JumpIfError(hr, error, "myLoadRCString");
    sd.lpDescription = pwszServiceDesc;

    if (!ChangeServiceConfig2(hService,
                                SERVICE_CONFIG_DESCRIPTION,
                                (VOID*)&sd))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ChangeServiceConfig2");
    }

    hr = S_OK;
error:
    if (NULL != hService)
    {
        CloseServiceHandle(hService);
    }
    if (NULL != pwszServiceDesc)
    {
        LocalFree(pwszServiceDesc);
    }
    if (NULL != pServiceConfig)
    {
        LocalFree(pServiceConfig);
    }
    return hr;
}

HRESULT
PreUninstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN BOOL fPreserveClient)
{
    BOOL fDummy;
    HRESULT hr;
    DWORD   dwFlags = RD_UNREGISTER;

    hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hwnd,
                 wszSERVICE_NAME,
                 TRUE,  // stop the service
                 FALSE, // no confirm
                 0,    //doesn't matter since no confirm
                 &fDummy);
    _PrintIfError(hr, "StartAndStopService");

    hr = RegisterAndUnRegisterDLLs(dwFlags, pComp, hwnd);
    _PrintIfError(hr, "RegisterAndUnRegisterDLLs");

    hr = S_OK;

    return(hr);
}



VOID
DeleteServiceAndGroups(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hwnd)
{
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSC = NULL;
    HRESULT hr;

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }

    hSC = OpenService(hSCManager, wszSERVICE_NAME, SERVICE_ALL_ACCESS);
    if (NULL != hSC)
    {
        if (!DeleteService(hSC))
        {
            hr = myHLastError();
            CertErrorMessageBox(
                hInstance,
                fUnattended,
                hwnd,
                IDS_ERR_DELETESERVICE,
                hr,
                wszSERVICE_NAME);
            _PrintError(hr, "DeleteService");
        }
        CloseServiceHandle(hSC);
    }

error:
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
}

HRESULT SetCertSrvInstallVersion()
{
    HRESULT hr;

    hr = mySetCertRegDWValueEx(
			FALSE,
			NULL,
			NULL,
			NULL,
			wszREGVERSION,
			(CSVER_MAJOR << 16) | CSVER_MINOR);
    _PrintIfErrorStr(hr, "mySetCertRegDWValueEx", wszREGVERSION);

    return hr;
}

HRESULT
CreateWebClientRegEntries(
    BOOL                fUpgrade,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    hr = mySetCertRegStrValueEx(fUpgrade, NULL, NULL, NULL,
             wszREGWEBCLIENTCAMACHINE, pClient->pwszWebCAMachine);
    _JumpIfError(hr, error, "mySetCertRegStrValueEx");

    hr = mySetCertRegStrValueEx(fUpgrade, NULL, NULL, NULL,
             wszREGWEBCLIENTCANAME, pClient->pwszWebCAName);
    _JumpIfError(hr, error, "mySetCertRegStrValueEx");

    hr = mySetCertRegDWValueEx(fUpgrade, NULL, NULL, NULL,
             wszREGWEBCLIENTCATYPE, pClient->WebCAType);
    _JumpIfError(hr, error, "mySetCertRegDWValueEx");

    hr = SetCertSrvInstallVersion();
    _JumpIfError(hr, error, "SetCertSrvInstallVersion");
     

    if (NULL != pClient->pwszSharedFolder)
    {
        hr = mySetCertRegStrValueEx(fUpgrade, NULL, NULL, NULL,
                 wszREGDIRECTORY, pClient->pwszSharedFolder);
        _JumpIfError(hr, error, "mySetCertRegStrValue");
    }

    hr = S_OK;
error:
    CSILOG(hr, IDS_LOG_CREATE_CLIENT_REG, NULL, NULL, NULL);
    return hr;
}


HRESULT
UpgradeWebClientRegEntries(
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;

    hr = CreateWebClientRegEntries(TRUE, pComp);
    _JumpIfError(hr, error, "CreateWebClientRegEntries");


//    hr = S_OK;
error:
    return hr;
}


HRESULT
UninstallCore(
    IN HWND hwnd,
    IN PER_COMPONENT_DATA *pComp,
    IN DWORD PerCentCompleteBase,
    IN DWORD PerCentCompleteMax,
    IN BOOL fPreserveClient,
    IN BOOL fRemoveVD,
    IN BOOL fPreserveToDoList)
{
    BOOL fCoInit = FALSE;
    HRESULT hr;
    WCHAR    *pwszSharedFolder = NULL;
    WCHAR    *pwszSanitizedCAName = NULL;
    ENUM_CATYPES  caType = ENUM_UNKNOWN_CA;
    BOOL     fUseDS = FALSE;
    WCHAR    *pwszDBDirectory = NULL;
    WCHAR    *pwszLogDirectory = NULL;
    WCHAR    *pwszSysDirectory = NULL;
    WCHAR    *pwszTmpDirectory = NULL;
    DWORD DBSessionCount = 0;
    DWORD PerCentCompleteDelta;

    PerCentCompleteDelta = (PerCentCompleteMax - PerCentCompleteBase) / 10;
#define _UNINSTALLPERCENT(tenths) \
            (PerCentCompleteBase + (tenths) * PerCentCompleteDelta)

    // get current active CA info
    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGACTIVE, &pwszSanitizedCAName);
    _PrintIfError(hr, "UninstallCore(no active CA)");
    if (S_OK == hr)
    {
        hr = ArchiveCACertificate(pwszSanitizedCAName);
        _PrintIfError2(hr, "ArchiveCACertificate", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

        hr = myGetCertRegDWValue(pwszSanitizedCAName, NULL, NULL, wszREGCATYPE, (DWORD*)&caType);
        _PrintIfError(hr, "no reg ca type");
        hr = myGetCertRegDWValue(pwszSanitizedCAName, NULL, NULL, wszREGCAUSEDS, (DWORD*)&fUseDS);
        _PrintIfError(hr, "no reg use ds");

        hr = DeleteCertificates(pwszSanitizedCAName, IsRootCA(caType));
        if(S_OK != hr)
        {
            CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_IDINFO_DELETECERTIFICATES,
                        0,
                        NULL);
        }

    }
    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDIRECTORY, &pwszSharedFolder);
    _PrintIfError(hr, "no shared folder");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBDIRECTORY, &pwszDBDirectory);
    _PrintIfError(hr, "no db directory");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBLOGDIRECTORY, &pwszLogDirectory);
    _PrintIfError(hr, "no log directory");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBSYSDIRECTORY, &pwszSysDirectory);
    _PrintIfError(hr, "no sys directory");

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBTEMPDIRECTORY, &pwszTmpDirectory);
    _PrintIfError(hr, "no tmp directory");

    hr = myGetCertRegDWValue(NULL, NULL, NULL, wszREGDBSESSIONCOUNT, &DBSessionCount);
    _PrintIfError(hr, "no session count");

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    DeleteServiceAndGroups(pComp->hInstance, pComp->fUnattended, hwnd);
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(1) DBGPARM(L"UninstallCore"));

    if (!fPreserveToDoList)
    {
        // if we're uninstalling, always clear post-base ToDo list
        RegDeleteKey(HKEY_LOCAL_MACHINE, wszREGKEYCERTSRVTODOLIST);
    }

    if (fPreserveClient)
    {
        hr = RegisterAndUnRegisterDLLs(RD_CLIENT, pComp, hwnd);
        _JumpIfError(hr, error, "RegisterAndUnRegisterDLLs");

	hr = CreateCertWebIncPages(hwnd, pComp, FALSE /*IsServer*/, FALSE);
	_JumpIfError(hr, error, "CreateCertWebIncPages");
    }
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(2) DBGPARM(L"UninstallCore"));

    DeleteProgramGroups(TRUE, pComp);

    if (fPreserveClient)
    {
        hr = CreateProgramGroups(TRUE, pComp, hwnd);
        _JumpIfError(hr, error, "CreateProgramGroups");
    }
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(3) DBGPARM(L"UninstallCore"));

    UnregisterDcomServer(
                    CLSID_CCertRequestD,
                    wszREQUESTVERINDPROGID,
                    wszREQUESTPROGID);
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(4) DBGPARM(L"UninstallCore"));

    UnregisterDcomServer(
                    CLSID_CCertAdminD,
                    wszADMINVERINDPROGID,
                    wszADMINPROGID);
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(5) DBGPARM(L"UninstallCore"));

    UnregisterDcomApp();
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(6) DBGPARM(L"UninstallCore"));

    if (fRemoveVD && !fPreserveClient)
    {
        DisableVRootsAndShares(TRUE, TRUE);
        myDeleteFilePattern(pComp->pwszSystem32, wszCERTSRV, TRUE);
    }

    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(7) DBGPARM(L"UninstallCore"));

    if (NULL != pwszSharedFolder)
    {
        // this must be restore before CreateConfigFiles()
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDIRECTORY, pwszSharedFolder);
        _PrintIfError(hr, "mySetCertRegStrValue");

        //remove entry
        hr = CreateConfigFiles(pwszSharedFolder, pComp, TRUE, hwnd);
        _PrintIfError2(hr, "CreateConfigFiles(Remove old entry)", hr);
    }
    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(8) DBGPARM(L"UninstallCore"));

    // restore db path
    if (NULL != pwszDBDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBDIRECTORY, pwszDBDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (NULL != pwszLogDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBLOGDIRECTORY, pwszLogDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (NULL != pwszSysDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBSYSDIRECTORY, pwszSysDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (NULL != pwszTmpDirectory)
    {
        hr = mySetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBTEMPDIRECTORY, pwszTmpDirectory);
        _PrintIfError(hr, "mySetCertRegStrValue");
    }
    if (0 != DBSessionCount)
    {
        hr = mySetCertRegDWValue(NULL, NULL, NULL,
                 wszREGDBSESSIONCOUNT, DBSessionCount);
        _PrintIfError(hr, "mySetCertRegDWValueEx");
    }

    if (fPreserveClient)
    {
        // this means uninstall server component and keep web client
        hr = CreateWebClientRegEntries(FALSE, pComp);
        _JumpIfError(hr, error, "CreateWebClientRegEntries");
    }

    DeleteObsoleteResidue();
    DeleteOldFilesAndDirectories(pComp);

    certocmBumpGasGauge(pComp, _UNINSTALLPERCENT(9) DBGPARM(L"UninstallCore"));

    if (fUseDS)
    {
        hr = RemoveCAInDS(pwszSanitizedCAName);
        _PrintIfError2(hr, "RemoveCAInDS", hr);
    }
    certocmBumpGasGauge(pComp, PerCentCompleteMax DBGPARM(L"UninstallCore"));

    hr = S_OK;

error:
    if (NULL != pwszSanitizedCAName)
    {
        LocalFree(pwszSanitizedCAName);
    }
    if (NULL != pwszSharedFolder)
    {
        LocalFree(pwszSharedFolder);
    }
    if (NULL != pwszDBDirectory)
    {
        LocalFree(pwszDBDirectory);
    }
    if (NULL != pwszLogDirectory)
    {
        LocalFree(pwszLogDirectory);
    }
    if (NULL != pwszSysDirectory)
    {
        LocalFree(pwszSysDirectory);
    }
    if (NULL != pwszTmpDirectory)
    {
        LocalFree(pwszTmpDirectory);
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(hr);
}


HRESULT
AddCAToRPCNullSessions()
{
    HRESULT hr;
    HKEY hRegKey = NULL;
    char *pszOriginal = NULL;
    char *psz;
    DWORD cb;
    DWORD cbTmp;
    DWORD cbSum;
    DWORD dwType;

    hr = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                szNULL_SESSION_REG_LOCATION,
                0,              // dwOptions
                KEY_READ | KEY_WRITE,
                &hRegKey);
    _JumpIfError(hr, error, "RegOpenKeyExA");

    // Need to get the size of the value first

    hr = RegQueryValueExA(hRegKey, szNULL_SESSION_VALUE, 0, &dwType, NULL, &cb);
    _JumpIfError(hr, error, "RegQueryValueExA");

    if (REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "RegQueryValueExA: Type");
    }

    cb += sizeof(rgcCERT_NULL_SESSION) - 1;
    pszOriginal = (char *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);

    if (NULL == pszOriginal)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // get the multi string of RPC null session pipes
    hr = RegQueryValueExA(
                        hRegKey,
                        szNULL_SESSION_VALUE,
                        0,
                        &dwType,
                        (BYTE *) pszOriginal,
                        &cb);
    _JumpIfError(hr, error, "RegQueryValueExA");

    psz = pszOriginal;

    // look for CERT in the list

    cbSum = 0;
    while (TRUE)
    {
        if (0 == strcmp(rgcCERT_NULL_SESSION, psz))
        {
            break;
        }
        cbTmp = strlen(psz) + 1;
        psz += cbTmp;
        cbSum += cbTmp;
        if (cb < cbSum + 1)
        {
            break;
        }

        if ('\0' == psz[0])
        {
            // add the CA pipe to the multi string

            CopyMemory(psz, rgcCERT_NULL_SESSION, sizeof(rgcCERT_NULL_SESSION));

            // set the new multi string in the reg value
            hr = RegSetValueExA(
                            hRegKey,
                            szNULL_SESSION_VALUE,
                            0,
                            REG_MULTI_SZ,
                            (BYTE *) pszOriginal,
                            cbSum + sizeof(rgcCERT_NULL_SESSION));
            _JumpIfError(hr, error, "RegSetValueExA");

            break;
        }
    }
    hr = S_OK;

error:
    if (NULL != pszOriginal)
    {
        LocalFree(pszOriginal);
    }
    if (NULL != hRegKey)
    {
        RegCloseKey(hRegKey);
    }
    return(hr);
}


HRESULT
AddCARegKeyToRegConnectExemptions()
{
    // add ourselves to list of people that take ACLs seriously
    // and should be allowed to reveal our key to outsiders.

    HRESULT hr;
    LPWSTR pszExempt = NULL;
    HKEY hkeyWinReg = NULL, hkeyAllowedPaths = NULL;
    LPWSTR pszTmp;
    DWORD dwDisposition, dwType;
    DWORD cb=0, cbRegKeyCertSrvPath = (wcslen(wszREGKEYCERTSVCPATH)+1) *sizeof(WCHAR);

    // carefully query this -- if it doesn't exist, we don't have to apply workaround
    hr = RegOpenKeyEx(
       HKEY_LOCAL_MACHINE,
       L"SYSTEM\\CurrentControlSet\\Control\\SecurePipeServers\\Winreg",
       0,
       KEY_ALL_ACCESS,
       &hkeyWinReg);
    _JumpIfError(hr, Ret, "RegOpenKeyEx");
 
    // creation of this optional key is always ok if above key exists
    hr = RegCreateKeyEx(
        hkeyWinReg,
        L"AllowedPaths",
        NULL,
        NULL,
        0,
        KEY_ALL_ACCESS,
        NULL,
        &hkeyAllowedPaths,
        &dwDisposition);
    _JumpIfError(hr, Ret, "RegCreateKeyEx exempt regkey");

    hr = RegQueryValueEx(
      hkeyAllowedPaths,
      L"Machine",
      NULL, // reserved
      &dwType, // type
      NULL, // pb
      &cb);
    _PrintIfError(hr, "RegQueryValueEx exempt regkey 1");

    if ((hr == S_OK) && (dwType != REG_MULTI_SZ))
    {
       hr = HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH);
       _JumpError(hr, Ret, "RegQueryValueEx invalid type");
    }

    // always include at least a terminator
    if (cb < sizeof(WCHAR)) 
        cb = sizeof(WCHAR);

    pszExempt = (LPWSTR)LocalAlloc(LMEM_FIXED, cb + cbRegKeyCertSrvPath );
    _JumpIfOutOfMemory(hr, Ret, pszExempt);
    
    // start with double null for safety
    pszExempt[0] = L'\0';
    pszExempt[1] = L'\0';

    hr = RegQueryValueEx(
      hkeyAllowedPaths,
      L"Machine",
      NULL, // reserved
      NULL, // type
      (PBYTE)pszExempt, // pb
      &cb);
    _PrintIfError(hr, "RegQueryValueEx exempt regkey 2");

    pszTmp = pszExempt;
    while(pszTmp[0] != L'\0')        // skip all existing strings
    {
        // if entry already exists, bail
        if (0 == lstrcmpi(wszREGKEYCERTSVCPATH, pszTmp))
        {
            hr = S_OK;
            goto Ret;
        }
        pszTmp += wcslen(pszTmp)+1;
    }
    wcscpy(&pszTmp[0], wszREGKEYCERTSVCPATH);
    pszTmp[wcslen(wszREGKEYCERTSVCPATH)+1] = L'\0'; // double NULL

    hr = RegSetValueEx(
        hkeyAllowedPaths,
        L"Machine",
        NULL,
        REG_MULTI_SZ,
        (PBYTE)pszExempt,
        cb + cbRegKeyCertSrvPath);
    _JumpIfError(hr, Ret, "RegSetValueEx exempt regkey");
 

Ret:
    if (hkeyAllowedPaths)
        RegCloseKey(hkeyAllowedPaths);

    if (hkeyWinReg)
        RegCloseKey(hkeyWinReg);

    if (pszExempt)
        LocalFree(pszExempt);
    
    return hr;
}

HRESULT
helperGetFilesNotToRestore(
    PER_COMPONENT_DATA *pComp,
    OUT WCHAR          **ppwszz)
{
    HRESULT hr;
    WCHAR *pwsz;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    DWORD cwc;
    WCHAR const wszDBDIRPATTERN[] = L"\\*.edb";
    WCHAR const wszDBLOGDIRPATTERN[] = L"\\*";

    *ppwszz = NULL;

    cwc = wcslen(pServer->pwszDBDirectory) +
            WSZARRAYSIZE(wszDBDIRPATTERN) +
            1 +
            wcslen(pServer->pwszLogDirectory) +
            WSZARRAYSIZE(wszDBLOGDIRPATTERN) +
            1 +
            1;

    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwsz);

    *ppwszz = pwsz;

    wcscpy(pwsz, pServer->pwszDBDirectory);
    wcscat(pwsz, wszDBDIRPATTERN);
    pwsz += wcslen(pwsz) + 1;

    wcscpy(pwsz, pServer->pwszLogDirectory);
    wcscat(pwsz, wszDBLOGDIRPATTERN);
    pwsz += wcslen(pwsz) + 1;

    *pwsz = L'\0';

    CSASSERT(cwc == (DWORD) (pwsz - *ppwszz + 1));
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CreateServerRegEntries(
    HWND hwnd,
    BOOL fUpgrade,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    HKEY hKeyBase = NULL;

    WCHAR *pwszCLSIDCertGetConfig = NULL;
    WCHAR *pwszCLSIDCertRequest = NULL;
    WCHAR *pwszCRLPeriod = NULL;
    WCHAR *pwszCRLDeltaPeriod = NULL;

    WCHAR *pwszzCRLPublicationValue = NULL;
    WCHAR *pwszzCACertPublicationValue = NULL;
    WCHAR *pwszzRequestExtensionList = NULL;
    WCHAR *pwszzDisableExtensionList = NULL;
    WCHAR *pwszzFilesNotToRestore = NULL;

    WCHAR *pwszProvNameReg = NULL;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;
    DWORD dwUpgradeFlags = fUpgrade ? CSREG_UPGRADE : 0x0;
    DWORD dwAppendFlags = 0x0; // default

    DWORD dwCRLPeriodCount, dwCRLDeltaPeriodCount;

    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;

    // no error checking?
    hr = AddCAToRPCNullSessions();
    _PrintIfError(hr, "AddCAToRPCNullSessions");
    
    hr = AddCARegKeyToRegConnectExemptions();
    _PrintIfError(hr, "AddCARegKeyToRegConnectExemptions");

    // create the CA key, so we can set security on it.
    hr = myCreateCertRegKey(pServer->pwszSanitizedName, NULL, NULL);
    _JumpIfError(hr, error, "myCreateCertRegKey");


    // configuration level

    // active ca
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGACTIVE,
			pServer->pwszSanitizedName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGACTIVE);

    if (NULL != pServer->pwszSharedFolder)
    {
        // shared folder
        hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDIRECTORY,
			pServer->pwszSharedFolder);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDIRECTORY);
    }

    // db dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBDIRECTORY,
			pServer->pwszDBDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBDIRECTORY);

    // log dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBLOGDIRECTORY,
			pServer->pwszLogDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBLOGDIRECTORY);

    // db tmp dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBTEMPDIRECTORY,
			pServer->pwszLogDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBTEMPDIRECTORY);

    // db sys dir
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBSYSDIRECTORY,
			pServer->pwszLogDirectory);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDBSYSDIRECTORY);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			NULL,
			NULL,
			NULL,
			wszREGDBSESSIONCOUNT,
			DBSESSIONCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGDBSESSIONCOUNT);

    hr = SetCertSrvInstallVersion();
    _JumpIfError(hr, error, "SetCertSrvInstallVersion");

    if (!fUpgrade)
    {
        // preserve db
        hr = SetSetupStatus(NULL, SETUP_CREATEDB_FLAG, !pServer->fPreserveDB);
        _JumpIfError(hr, error, "SetSetupStatus");
    }

    // ca level

    if (!fUpgrade && pServer->fUseDS)
    {
	hr = myLdapOpen(&pld, &strDomainDN, &strConfigDN);
	_JumpIfError(hr, error, "myLdapOpen");

	// Config DN

	hr = mySetCertRegStrValueEx(
			FALSE,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGDSCONFIGDN,
			strConfigDN);
	_JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDSCONFIGDN);

	// Domain DN

	hr = mySetCertRegStrValueEx(
			FALSE,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGDSDOMAINDN,
			strDomainDN);
	_JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGDSDOMAINDN);
    }

    // ca type

    CSASSERT(IsEnterpriseCA(pServer->CAType) || IsStandaloneCA(pServer->CAType));
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCATYPE,
			pServer->CAType);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCATYPE);

    // use DS flag
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAUSEDS,
			pServer->fUseDS);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCAUSEDS);

    // teletex flag
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGFORCETELETEX,
			ENUM_TELETEX_AUTO | ENUM_TELETEX_UTF8);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGFORCETELETEX);


    hr = mySetCertRegMultiStrValueEx(
		       dwUpgradeFlags,
		       pServer->pwszSanitizedName, 
		       NULL, 
		       NULL,
		       wszSECUREDATTRIBUTES, 
		       wszzDEFAULTSIGNEDATTRIBUTES);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszSECUREDATTRIBUTES,);

    // common name
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCOMMONNAME,
			pServer->pwszCACommonName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCOMMONNAME);

    // enable reg
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGENABLED,
			TRUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGENABLED);

    // policy flag
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGPOLICYFLAGS,
			0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGPOLICYFLAGS);

    // enroll compatible flag, always turn it off
    // BUG, consider use mySetCertRegDWValueEx with fUpgrade
    //      after W2K to support CertEnrollCompatible upgrade

    hr = mySetCertRegDWValue(
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCERTENROLLCOMPATIBLE,
                        FALSE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValue", wszREGCERTENROLLCOMPATIBLE);

    // Cert Server CRL Edit Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCRLEDITFLAGS,
                        EDITF_ENABLEAKIKEYID);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLEDITFLAGS);


    // Cert Server CRL Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCRLFLAGS,
			CRLF_DELETE_EXPIRED_CRLS);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLFLAGS);

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGENFORCEX500NAMELENGTHS,
                        TRUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGENFORCEX500NAMELENGTHS);

    // subject template
    hr = mySetCertRegMultiStrValueEx(
			0,		// dwUpgradeFlags: always overwrite!
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGSUBJECTTEMPLATE,
			wszzREGSUBJECTTEMPLATEVALUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGSUBJECTTEMPLATE);

    // (hard code) clock skew minutes
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCLOCKSKEWMINUTES,
			CCLOCKSKEWMINUTESDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCLOCKSKEWMINUTES);

    // (hard code) log level
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGLOGLEVEL,
			CERTLOG_WARNING);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGLOGLEVEL);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGHIGHSERIAL,
			0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGLOGLEVEL);

    // register server name
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCASERVERNAME,
			pComp->pwszServerName);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCASERVERNAME);

    // default validity period string and count for issued certs
    // use years for string

    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGVALIDITYPERIODSTRING,
			wszVALIDITYPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGVALIDITYPERIODSTRING);

    // validity period count
    // use 1 year for standalone and 2 years for enterprise

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGVALIDITYPERIODCOUNT,
			IsEnterpriseCA(pServer->CAType)?
			    dwVALIDITYPERIODCOUNTDEFAULT_ENTERPRISE :
			    dwVALIDITYPERIODCOUNTDEFAULT_STANDALONE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGVALIDITYPERIODCOUNT);

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
			    wszREGCAXCHGCERTHASH,
                            NULL);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGCAXCHGCERTHASH);

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
			    wszREGKRACERTHASH,
                            NULL);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGKRACERTHASH);

    hr = mySetCertRegDWValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
                            wszREGKRACERTCOUNT,
                            0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGKRACERTCOUNT);

    hr = mySetCertRegDWValueEx(
                            dwUpgradeFlags,
                            pServer->pwszSanitizedName,
                            NULL,
                            NULL,
                            wszREGKRAFLAGS,
                            0);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGKRAFLAGS);

    // CRL Publication URLs:

    hr = csiGetCRLPublicationURLTemplates(
			pServer->fUseDS,
			pComp->pwszSystem32,
			&pwszzCRLPublicationValue);
    _JumpIfError(hr, error, "csiGetCRLPublicationURLTemplates");

    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags | CSREG_MERGE,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
			wszREGCRLPUBLICATIONURLS,
			pwszzCRLPublicationValue);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGCRLPUBLICATIONURLS);


    // if this API returns non-null strings, it's got good data
    hr = csiGetCRLPublicationParams(
                        TRUE,
                        &pwszCRLPeriod,
                        &dwCRLPeriodCount);
    _PrintIfError(hr, "csiGetCRLPublicationParams");

    // crl period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLPERIODSTRING,
			(pwszCRLPeriod == NULL) ? wszCRLPERIODSTRINGDEFAULT : pwszCRLPeriod);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLPERIODSTRING);

    // crl period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLPERIODCOUNT,
			(pwszCRLPeriod == NULL) ? dwCRLPERIODCOUNTDEFAULT : dwCRLPeriodCount);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLPERIODCOUNT);

    // crl overlap period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLOVERLAPPERIODSTRING,
			wszCRLOVERLAPPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLOVERLAPPERIODSTRING);

    // crl overlap period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLOVERLAPPERIODCOUNT,
			dwCRLOVERLAPPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLOVERLAPPERIODCOUNT);

    // if this API returns non-null strings, it's got good data
    hr = csiGetCRLPublicationParams(
                        FALSE,	// delta
                        &pwszCRLDeltaPeriod,
                        &dwCRLDeltaPeriodCount);
    _PrintIfError(hr, "csiGetCRLPublicationParams");

    // delta crl period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAPERIODSTRING,
			(pwszCRLDeltaPeriod == NULL) ? wszCRLDELTAPERIODSTRINGDEFAULT : pwszCRLDeltaPeriod);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAPERIODSTRING);

    // delta crl period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAPERIODCOUNT,
			(pwszCRLDeltaPeriod == NULL) ? dwCRLPERIODCOUNTDEFAULT : dwCRLDeltaPeriodCount);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAPERIODCOUNT);

    // delta crl overlap period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAOVERLAPPERIODSTRING,
			wszCRLDELTAOVERLAPPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAOVERLAPPERIODSTRING);

    // delta crl overlap period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCRLDELTAOVERLAPPERIODCOUNT,
			dwCRLDELTAOVERLAPPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAOVERLAPPERIODCOUNT);

    // CA xchg cert validity period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGVALIDITYPERIODSTRING,
			wszCAXCHGVALIDITYPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAOVERLAPPERIODSTRING);

    // CA xchg cert validity period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGVALIDITYPERIODCOUNT,
			dwCAXCHGVALIDITYPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAOVERLAPPERIODCOUNT);

    // CA xchg cert overlap period string
    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGOVERLAPPERIODSTRING,
			wszCAXCHGOVERLAPPERIODSTRINGDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCRLDELTAOVERLAPPERIODSTRING);

    // CA xchg cert overlap period count
    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCAXCHGOVERLAPPERIODCOUNT,
			dwCAXCHGOVERLAPPERIODCOUNTDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGCRLDELTAOVERLAPPERIODCOUNT);

    hr = mySetCertRegDWValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			NULL,
			NULL,
			wszREGMAXINCOMINGMESSAGESIZE,
			MAXINCOMINGMESSAGESIZEDEFAULT);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx", wszREGMAXINCOMINGMESSAGESIZE);

    if (NULL != pServer->pwszSharedFolder)
    {
        // register CA file name for certhier and renewal

	hr = mySetCARegFileNameTemplate(
			wszREGCACERTFILENAME,
			pComp->pwszServerName,
			pServer->pwszSanitizedName,
			pServer->pwszCACertFile);
	_JumpIfError(hr, error, "SetRegCertFileName");
    }

    // policy

    // create default policy entry explicitly to get correct acl if upgrade
    hr = myCreateCertRegKeyEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			wszREGKEYPOLICYMODULES,
			wszCLASS_CERTPOLICY);
    _JumpIfErrorStr(hr, error, "myCreateCertRegKeyEx", wszCLASS_CERTPOLICY);

    // if customized policy, create a new entry with correct acl
    if (fUpgrade &&
        NULL != pServer->pwszCustomPolicy &&
        0 != wcscmp(wszCLASS_CERTPOLICY, pServer->pwszCustomPolicy) )
    {
        hr = myCreateCertRegKeyEx(
			    TRUE, // upgrade
			    pServer->pwszSanitizedName,
			    wszREGKEYPOLICYMODULES,
			    pServer->pwszCustomPolicy);
        _JumpIfError(hr, error, "myCreateCertRegKey");
    }

    // set default policy
    hr = mySetCertRegStrValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        NULL,
                        wszREGACTIVE,
                        (fUpgrade && (NULL != pServer->pwszCustomPolicy)) ?
                                     pServer->pwszCustomPolicy :
                                     wszCLASS_CERTPOLICY);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGACTIVE);


    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGREVOCATIONTYPE,
                        pServer->dwRevocationFlags | pServer->dwUpgradeRevFlags);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGREVOCATIONTYPE);

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGCAPATHLENGTH,
                        CAPATHLENGTH_INFINITE);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGCAPATHLENGTH);

    // revocation url

    hr = mySetCertRegStrValueEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			wszREGKEYPOLICYMODULES,
			wszCLASS_CERTPOLICY,
			wszREGREVOCATIONURL,
			g_wszASPRevocationURLTemplate);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGREVOCATIONURL);

    // Exit module publish flags
    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYEXITMODULES,
                        wszCLASS_CERTEXIT,
                        wszREGCERTPUBLISHFLAGS,
                        pServer->fUseDS ?
                            EXITPUB_DEFAULT_ENTERPRISE :
                            EXITPUB_DEFAULT_STANDALONE);
    _JumpIfErrorStr(
                hr,
                error,
                "mySetCertRegStrValueEx",
                wszREGCERTPUBLISHFLAGS);

    // Enable Request Extensions:

    hr = helperGetRequestExtensionList(pComp, &pwszzRequestExtensionList);
    _JumpIfError(hr, error, "helperGetRequestExtensionList");

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags | CSREG_MERGE,
                            pServer->pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            wszREGENABLEREQUESTEXTENSIONLIST,
                            pwszzRequestExtensionList);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGENABLEREQUESTEXTENSIONLIST);

    hr = helperGetDisableExtensionList(pComp, &pwszzDisableExtensionList);
    _JumpIfError(hr, error, "helperGetDisableExtensionList");

    // Disables Template Extensions:

    hr = mySetCertRegMultiStrValueEx(
                            dwUpgradeFlags | CSREG_MERGE,
                            pServer->pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            wszREGDISABLEEXTENSIONLIST,
                            pwszzDisableExtensionList);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGDISABLEEXTENSIONLIST);

    // Subject Alt Name Extension

    hr = mySetCertRegStrValueEx(
                              fUpgrade,
                              pServer->pwszSanitizedName,
                              wszREGKEYPOLICYMODULES,
                              wszCLASS_CERTPOLICY,
                              wszREGSUBJECTALTNAME,
                              wszREGSUBJECTALTNAMEVALUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGSUBJECTALTNAME);

    // Subject Alt Name 2 Extension

    hr = mySetCertRegStrValueEx(
                              fUpgrade,
                              pServer->pwszSanitizedName,
                              wszREGKEYPOLICYMODULES,
                              wszCLASS_CERTPOLICY,
                              wszREGSUBJECTALTNAME2,
                              wszREGSUBJECTALTNAME2VALUE);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGSUBJECTALTNAME2);

    // Request Disposition

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGREQUESTDISPOSITION,
                        IsEnterpriseCA(pServer->CAType)?
                            REQDISP_DEFAULT_ENTERPRISE :
                            REQDISP_DEFAULT_STANDALONE);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValueEx",
            wszREGREQUESTDISPOSITION);

    // Edit Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGEDITFLAGS,
                        IsEnterpriseCA(pServer->CAType)?
                            (EDITF_DEFAULT_ENTERPRISE | pServer->dwUpgradeEditFlags) :
                            (EDITF_DEFAULT_STANDALONE | pServer->dwUpgradeEditFlags));
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx", wszREGEDITFLAGS);

    // Issuer Cert URL Flags

    hr = mySetCertRegDWValueEx(
                        fUpgrade,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        wszREGISSUERCERTURLFLAGS,
                        pServer->fUseDS?
                            ISSCERT_DEFAULT_DS : ISSCERT_DEFAULT_NODS);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValueEx",
            wszREGISSUERCERTURLFLAGS);

    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags,
                        pServer->pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
			wszREGDEFAULTSMIME,
			wszzREGVALUEDEFAULTSMIME);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGDEFAULTSMIME);
    hr = csiGetCACertPublicationURLTemplates(
			pServer->fUseDS,
			pComp->pwszSystem32,
			&pwszzCACertPublicationValue);
    _JumpIfError(hr, error, "csiGetCACertPublicationURLTemplates");

    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags | CSREG_MERGE,
                        pServer->pwszSanitizedName,
                        NULL,
                        NULL,
			wszREGCACERTPUBLICATIONURLS,
			pwszzCACertPublicationValue);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGCRLPUBLICATIONURLS);

    // exit

    // create default exit entry to get correct acl if upgrade
    hr = myCreateCertRegKeyEx(
			fUpgrade,
			pServer->pwszSanitizedName,
			wszREGKEYEXITMODULES,
			wszCLASS_CERTEXIT);
    _JumpIfErrorStr(hr, error, "myCreateCertRegKeyEx", wszCLASS_CERTPOLICY);

    // if customized exit, create a new entry with correct acl
    if (fUpgrade &&
        NULL != pServer->pwszzCustomExit &&
        0 != wcscmp(wszCLASS_CERTEXIT, pServer->pwszzCustomExit) )
    {
        // create a new entry for custom exit
        hr = myCreateCertRegKeyEx(
			TRUE,  // upgrade
			pServer->pwszSanitizedName,
			wszREGKEYEXITMODULES,
			pServer->pwszzCustomExit);
        _JumpIfError(hr, error, "myCreateCertRegKey");
    }

    // set default exit
    hr = mySetCertRegMultiStrValueEx(
                        dwUpgradeFlags,
                        pServer->pwszSanitizedName,
                        wszREGKEYEXITMODULES,
                        NULL,
                        wszREGACTIVE,
                        (fUpgrade && (NULL != pServer->pwszzCustomExit)) ?
                                     pServer->pwszzCustomExit :
                                     wszCLASS_CERTEXIT L"\0");
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValueEx", wszREGACTIVE);


    // set some absolute keys and values

    hr = mySetAbsRegMultiStrValue(
                        wszREGKEYKEYSNOTTORESTORE,
                        wszREGRESTORECERTIFICATEAUTHORITY,
                        wszzREGVALUERESTORECERTIFICATEAUTHORITY);
    _JumpIfError(hr, error, "mySetAbsRegMultiStrValue");

    hr = helperGetFilesNotToRestore(pComp, &pwszzFilesNotToRestore);
    _JumpIfError(hr, error, "helperGetFilesNotToRestore");

    hr = mySetAbsRegMultiStrValue(
                        wszREGKEYFILESNOTTOBACKUP,
                        wszREGRESTORECERTIFICATEAUTHORITY,
                        pwszzFilesNotToRestore);
    _JumpIfError(hr, error, "mySetAbsRegMultiStrValue");


    // ICertGetConfig
    hr = StringFromCLSID(CLSID_CCertGetConfig, &pwszCLSIDCertGetConfig);
    _JumpIfError(hr, error, "StringFromCLSID(CCertGetConfig)");

    hr = mySetAbsRegStrValue(
                        wszREGKEYKEYRING,
                        wszREGCERTGETCONFIG,
                        pwszCLSIDCertGetConfig);
    _JumpIfError(hr, error, "mySetAbsRegStrValue");

    // ICertCertRequest
    hr = StringFromCLSID(CLSID_CCertRequest, &pwszCLSIDCertRequest);
    _JumpIfError(hr, error, "StringFromCLSID(CCertRequest)");

    hr = mySetAbsRegStrValue(
                        wszREGKEYKEYRING,
                        wszREGCERTREQUEST,
                        pwszCLSIDCertRequest);
    _JumpIfError(hr, error, "mySetAbsRegStrValue");

    if (NULL != pServer->pCSPInfo &&
        NULL != pServer->pHashInfo)
    {
        WCHAR const *pwszProvName = pServer->pCSPInfo->pwszProvName;
	DWORD dwProvType;
	ALG_ID idAlg;
	BOOL fMachineKeyset;
	DWORD dwKeySize;

	if (0 == lstrcmpi(pwszProvName, MS_DEF_PROV_W))
	{
	    pwszProvName = MS_STRONG_PROV_W;
	}
	
	hr = SetCertSrvCSP(
			FALSE,			// fEncryptionCSP
			pServer->pwszSanitizedName,
                        pServer->pCSPInfo->dwProvType,
			pwszProvName,
                        pServer->pHashInfo->idAlg,
                        pServer->pCSPInfo->fMachineKeyset,
			0);			// dwKeySize
        _JumpIfError(hr, error, "SetCertSrvCSP");

	hr = myGetCertSrvCSP(
			TRUE,			// fEncryptionCSP
			pServer->pwszSanitizedName,
			&dwProvType,
			&pwszProvNameReg,
			&idAlg,
			&fMachineKeyset,
			&dwKeySize);		// pdwKeySize
	if (S_OK != hr)
	{
	    _PrintError(hr, "myGetCertSrvCSP");
	    dwProvType = pServer->pCSPInfo->dwProvType;
	    idAlg = CALG_3DES;
	    fMachineKeyset = pServer->pCSPInfo->fMachineKeyset;
	    dwKeySize = 1024;
	}
	else if (NULL != pwszProvNameReg && L'\0' != *pwszProvNameReg)
	{
	    pwszProvName = pwszProvNameReg;
	    if (0 == lstrcmpi(pwszProvName, MS_DEF_PROV_W))
	    {
		pwszProvName = MS_STRONG_PROV_W;
	    }
	}
        hr = SetCertSrvCSP(
			TRUE,			// fEncryptionCSP
			pServer->pwszSanitizedName,
                        dwProvType,
			pwszProvName,
                        idAlg,
                        fMachineKeyset,
			dwKeySize);		// dwKeySize
        _JumpIfError(hr, error, "SetCertSrvCSP");
    }
    hr = S_OK;

error:
    if (NULL != pwszProvNameReg)
    {
	LocalFree(pwszProvNameReg);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    if (NULL != pwszCLSIDCertGetConfig)
    {
        CoTaskMemFree(pwszCLSIDCertGetConfig);
    }

    if (NULL != pwszCRLPeriod)
    {
        LocalFree(pwszCRLPeriod);
    }
    if (NULL != pwszCRLDeltaPeriod)
    {
        LocalFree(pwszCRLDeltaPeriod);
    }
    if (NULL != pwszCLSIDCertRequest)
    {
        CoTaskMemFree(pwszCLSIDCertRequest);
    }
    if (NULL != pwszzCRLPublicationValue)
    {
        LocalFree(pwszzCRLPublicationValue);
    }
    if (NULL != pwszzCACertPublicationValue)
    {
	LocalFree(pwszzCACertPublicationValue);
    }
    if (NULL != pwszzRequestExtensionList)
    {
        LocalFree(pwszzRequestExtensionList);
    }
    if (NULL != pwszzDisableExtensionList)
    {
        LocalFree(pwszzDisableExtensionList);
    }
    if (NULL != pwszzFilesNotToRestore)
    {
        LocalFree(pwszzFilesNotToRestore);
    }
    if (NULL != hKeyBase)
    {
        RegCloseKey(hKeyBase);
    }
    CSILOG(hr, IDS_LOG_CREATE_SERVER_REG, NULL, NULL, NULL);
    return(hr);
}


HRESULT
UpgradeRevocationURLReplaceParam(
	IN BOOL fPolicy,
    IN BOOL fMultiString,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszValueName)
{
    HRESULT hr;
    WCHAR *pwszzValue = NULL;
    WCHAR *pwsz;
    BOOL fModified = FALSE;

    CSASSERT(
        WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX) ==
        WSZARRAYSIZE(wszFCSAPARM_CRLFILENAMESUFFIX));

    // getMultiStr will read REG_SZs as well and double-terminate
    hr = myGetCertRegMultiStrValue(
                            pwszSanitizedName,
                            fPolicy ? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES,
                            fPolicy ? wszCLASS_CERTPOLICY : wszCLASS_CERTEXIT,
                            pwszValueName,
                            &pwszzValue);
    _JumpIfErrorStr2(hr, error, "myGetCertRegMultiStrValue", pwszValueName, hr);

    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        WCHAR *pwszT = pwsz;
        
	// Replace wszFCSAPARM_CERTFILENAMESUFFIX with
	// wszFCSAPARM_CRLFILENAMESUFFIX.  Beta 3's registry values incorrectly
	// used a Cert Suffix instead of CRL Suffix.

        while (TRUE)
        {
            DWORD i;
            
            pwszT = wcschr(pwszT, wszFCSAPARM_CERTFILENAMESUFFIX[0]);
            if (NULL == pwszT)
            {
                break;
            }
            for (i = 1; ; i++)
            {
                if (i == WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX))
                {
                    CopyMemory(
                            pwszT,
                            wszFCSAPARM_CRLFILENAMESUFFIX,
                            i * sizeof(WCHAR));
                    pwszT += i;
                    fModified = TRUE;
                    break;
                }
                if (pwszT[i] != wszFCSAPARM_CERTFILENAMESUFFIX[i])
                {
                    pwszT++;
                    break;
                }
            }
        }
    }
    if (fModified)
    {
        if (fMultiString)
        {
            // set as REG_MULTI_SZ
            hr = mySetCertRegMultiStrValue(
                                    pwszSanitizedName,
                                    fPolicy ? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES,
                                    fPolicy ? wszCLASS_CERTPOLICY : wszCLASS_CERTEXIT,
                                    pwszValueName,
                                    pwszzValue);
            _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszValueName);
        }
        else
        {
            // set as REG_SZ
            hr = mySetCertRegStrValue(
                                    pwszSanitizedName,
                                    fPolicy ? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES,
                                    fPolicy ? wszCLASS_CERTPOLICY : wszCLASS_CERTEXIT,
                                    pwszValueName,
                                    pwszzValue);
            _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszValueName);
        }
    }

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
UpgradeRevocationURLRemoveParam(
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszValueName)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    WCHAR *pwsz;
    BOOL fModified = FALSE;
    WCHAR *pwszT;

    hr = myGetCertRegStrValue(
                        pwszSanitizedName,
                        wszREGKEYPOLICYMODULES,
                        wszCLASS_CERTPOLICY,
                        pwszValueName,
                        &pwszValue);
    _JumpIfErrorStr2(hr, error, "myGetCertRegStrValue", pwszValueName, hr);

    pwszT = pwszValue;
        
    // Remove wszFCSAPARM_CERTFILENAMESUFFIX from the Netscape Revocaton URL
    // It should never have been written out in Beta 3's registry value.

    while (TRUE)
    {
        DWORD i;
        
        pwszT = wcschr(pwszT, wszFCSAPARM_CERTFILENAMESUFFIX[0]);
        if (NULL == pwszT)
        {
            break;
        }
        for (i = 1; ; i++)
        {
            if (i == WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX))
            {
                MoveMemory(
                        pwszT,
                        &pwszT[i],
                        (wcslen(&pwszT[i]) + 1) * sizeof(WCHAR));
                pwszT += i;
                fModified = TRUE;
                break;
            }
            if (pwszT[i] != wszFCSAPARM_CERTFILENAMESUFFIX[i])
            {
                pwszT++;
                break;
            }
        }
    }

    if (fModified)
    {
        hr = mySetCertRegStrValue(
                                pwszSanitizedName,
                                wszREGKEYPOLICYMODULES,
                                wszCLASS_CERTPOLICY,
                                pwszValueName,
                                pwszValue);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszValueName);
    }

error:
    if (NULL != pwszValue)
    {
        LocalFree(pwszValue);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


WCHAR const *apwszB3ExitEntriesToFix[] =
{
    wszREGLDAPREVOCATIONDNTEMPLATE_OLD,
    NULL
};

HRESULT
UpgradeCRLPath(
    WCHAR const *pwszSanitizedName)
{
    HRESULT  hr;
    WCHAR *pwszzCRLPath = NULL;
    WCHAR *pwszzFixedCRLPath = NULL;
    WCHAR *pwsz;
    BOOL   fRenewReady = TRUE;
    DWORD  dwSize = 0;

    // get current crl path
    hr = myGetCertRegMultiStrValue(
                        pwszSanitizedName,
                        NULL,
                        NULL,
                        wszREGCRLPATH_OLD,
                        &pwszzCRLPath);
    _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGCRLPATH_OLD);

    // to see if it is in renew ready format
    for (pwsz = pwszzCRLPath; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        dwSize += wcslen(pwsz) + 1;
        if (NULL == wcsstr(pwsz, wszFCSAPARM_CRLFILENAMESUFFIX))
        {
            // found one without suffix
            fRenewReady = FALSE;
            // add suffix len
            dwSize += WSZARRAYSIZE(wszFCSAPARM_CRLFILENAMESUFFIX);
        }
    }

    if (!fRenewReady)
    {
        ++dwSize; // multi string
        // at least one of crl path missed suffix
        pwszzFixedCRLPath = (WCHAR*)LocalAlloc(LMEM_FIXED,
                                               dwSize * sizeof(WCHAR));
        _JumpIfOutOfMemory(hr, error, pwszzFixedCRLPath);
        WCHAR *pwszPt = pwszzFixedCRLPath;
        for (pwsz = pwszzCRLPath; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
        {
            // copy over whole path 1st
            wcscpy(pwszPt, pwsz);

            if (NULL == wcsstr(pwszPt, wszFCSAPARM_CRLFILENAMESUFFIX))
            {
                // miss suffix, find file portion
                WCHAR *pwszFile = wcsrchr(pwszPt, L'\\');
                if (NULL == pwszFile)
                {
                    // may be relative path, point to begin
                    pwszFile = pwszPt;
                }
                // find crl extension portion
                WCHAR *pwszCRLExt = wcsrchr(pwszFile, L'.');
                if (NULL != pwszCRLExt)
                {
                    // insert suffix
                    wcscpy(pwszCRLExt, wszFCSAPARM_CRLFILENAMESUFFIX);
                    // add extension portion from original buffer
                    wcscat(pwszCRLExt,
                           pwsz + SAFE_SUBTRACT_POINTERS(pwszCRLExt, pwszPt));
                }
                else
                {
                    // no crl file extension, append suffix at end
                    wcscat(pwszPt, wszFCSAPARM_CRLFILENAMESUFFIX);
                }
            }
            // update pointer
            pwszPt += wcslen(pwszPt) + 1;
        }
        // mutil string
        *pwszPt = L'\0';
        CSASSERT(dwSize == SAFE_SUBTRACT_POINTERS(pwszPt, pwszzFixedCRLPath) + 1);

        // reset crl path with the fixed crl path
        hr = mySetCertRegMultiStrValue(
                            pwszSanitizedName,
                            NULL,
                            NULL,
                            wszREGCRLPATH_OLD,
                            pwszzFixedCRLPath);
        _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", wszREGCRLPATH_OLD);
    }

    hr = S_OK;
error:
    if (NULL != pwszzCRLPath)
    {
        LocalFree(pwszzCRLPath);
    }
    if (NULL != pwszzFixedCRLPath)
    {
        LocalFree(pwszzFixedCRLPath);
    }
    return hr;
}

typedef struct _URLPREFIXSTRUCT
{
    WCHAR const *pwszURLPrefix;
    DWORD        dwURLFlags;
} URLPREFIXSTRUCT;

//array of cdp url type and its default usage which is prefix of url
URLPREFIXSTRUCT aCDPURLPrefixList[] =
{
    {L"file:", CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP},

    {L"http:", CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP},

    {L"ldap:", CSURL_SERVERPUBLISH | CSURL_ADDTOCERTCDP | CSURL_ADDTOFRESHESTCRL | CSURL_ADDTOCRLCDP},

    {NULL, 0}
};

//array of aia url type and its default usage which is prefix of url
URLPREFIXSTRUCT aAIAURLPrefixList[] =
{
    {L"file:", CSURL_ADDTOCERTCDP},

    {L"http:", CSURL_ADDTOCERTCDP},

    {L"ldap:", CSURL_ADDTOCERTCDP | CSURL_SERVERPUBLISH},

    {NULL, 0}
};

#define wszURLPREFIXFORMAT   L"%d:"

//pass an old url, determine what is prefix in a format of "XX:"
HRESULT
DetermineURLPrefixFlags(
    IN BOOL         fDisabled,
	IN BOOL         fCDP,
    IN WCHAR const *pwszURL,
    IN WCHAR       *pwszPrefixFlags)
{
    HRESULT hr;
    URLPREFIXSTRUCT *pURLPrefix;
    DWORD dwPathFlags;
    WCHAR *pwszT;
    WCHAR *pwszLower = NULL;

    //default to disable
    wsprintf(pwszPrefixFlags, wszURLPREFIXFORMAT, 0);

    if (fDisabled)
    {
        //easy
        goto done;
    }

    if (myIsFullPath(pwszURL, &dwPathFlags))
    {
        //local path, easy
        wsprintf(pwszPrefixFlags, wszURLPREFIXFORMAT, CSURL_SERVERPUBLISH);
        goto done;
    }

    //make lower case url string
    pwszLower = (WCHAR*)LocalAlloc(LMEM_FIXED,
                            (wcslen(pwszURL) + 1) * sizeof(WCHAR));
    if (NULL == pwszLower)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszLower, pwszURL);
    CharLower(pwszLower);

    //loop through to find out url type
    for (pURLPrefix = fCDP ? aCDPURLPrefixList : aAIAURLPrefixList;
         NULL != pURLPrefix->pwszURLPrefix; ++pURLPrefix)
    {
        pwszT = wcsstr(pwszLower, pURLPrefix->pwszURLPrefix);
        if (0 == wcsncmp(pwszLower, pURLPrefix->pwszURLPrefix,
                         wcslen(pURLPrefix->pwszURLPrefix)))
        {
            //prefix appears at the begining
            wsprintf(pwszPrefixFlags, wszURLPREFIXFORMAT, pURLPrefix->dwURLFlags);
            goto done;
        }
    }

    //nothing matches, keep 0 flag
done:
    hr = S_OK;
error:
    if (NULL != pwszLower)
    {
        LocalFree(pwszLower);
    }
    return hr;
}

//move old cdp or aia url from policy to a new location under ca
HRESULT
UpgradeMoveURLsLocation(
	IN BOOL fCDP,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszValueName)
{
    HRESULT hr;
    WCHAR *pwszzValue = NULL;
    WCHAR *pwszzURLs = NULL;
    BOOL   fDisabled;
    DWORD  cURLs = 0;  //count of url from multi_sz
    DWORD  dwLen = 0;
    DWORD  dwSize = 0; //total size of chars in multi_sz url exluding '-'
    WCHAR *pwsz;
    WCHAR *pwszT;
    WCHAR *pwszNoMinus;
    WCHAR  wszPrefixFlags[9]; //should be enough

    // get urls in the old location
    hr = myGetCertRegMultiStrValue(
                            pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            pwszValueName,
                            &pwszzValue);
    _JumpIfErrorStr2(hr, error, "myGetCertRegMultiStrValue", pwszValueName, hr);

    // fix "-" prefix for disable and count size
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += dwLen + 1)
    {
        //current url length
        dwLen = wcslen(pwsz);
        //update size
        dwSize += dwLen;
        ++cURLs;

        pwszNoMinus = pwsz;
        while (L'-' == *pwszNoMinus)
        {
            //exclude prefix '-'s
            --dwSize;
            ++pwszNoMinus;
        }
    }

    //allocate buffer in "XX:URL" format
    pwszzURLs = (WCHAR*)LocalAlloc(LMEM_FIXED,
        (dwSize + cURLs * sizeof(wszPrefixFlags) + 1) * sizeof(WCHAR));
    if (NULL == pwszzURLs)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    pwszT = pwszzURLs;
    //form string in new url format
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        fDisabled = FALSE;
        pwszNoMinus = pwsz;
        while (L'-' == *pwszNoMinus)
        {
            //exclude prefix '-'s
            ++pwszNoMinus;
            fDisabled = TRUE;
        }
        hr = DetermineURLPrefixFlags(fDisabled, fCDP, pwszNoMinus, wszPrefixFlags);
        _JumpIfErrorStr(hr, error, "DetermineURLPrefixFlags", pwszNoMinus);

        //format "xx:url"
        wcscpy(pwszT, wszPrefixFlags);
        wcscat(pwszT, pwszNoMinus);
        //ready for next url
        pwszT += wcslen(pwszT) + 1;
    }
    //zz
    *pwszT = L'\0';

    pwszT = fCDP ? wszREGCRLPUBLICATIONURLS : wszREGCACERTPUBLICATIONURLS,
    //move or merge to ca
    hr = mySetCertRegMultiStrValueEx(
                CSREG_UPGRADE | CSREG_MERGE,
                pwszSanitizedName,
                NULL,
                NULL,
                pwszT,
                pwszzURLs);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszT);

    //remove url under policy
    hr = myDeleteCertRegValue(
                            pwszSanitizedName,
                            wszREGKEYPOLICYMODULES,
                            wszCLASS_CERTPOLICY,
                            pwszValueName);
    _PrintIfErrorStr(hr, "myGetCertRegMultiStrValue", pwszValueName);

    hr = S_OK;
error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    if (NULL != pwszzURLs)
    {
        LocalFree(pwszzURLs);
    }
    return(hr);
}

WCHAR const *apwszPolicyCDPEntriesToFix[] =
{
    wszREGLDAPREVOCATIONCRLURL_OLD, //"LDAPRevocationCRLURL"
    wszREGREVOCATIONCRLURL_OLD,     //"RevocationCRLURL"
    wszREGFTPREVOCATIONCRLURL_OLD,  //"FTPRevocationCRLURL"
    wszREGFILEREVOCATIONCRLURL_OLD, //"FileRevocationCRLURL"
    NULL
};

HRESULT
myPrintIfError(
    IN HRESULT               hrNew,
    IN HRESULT               hrOld,
    IN CHAR const           *psz,
    IN OPTIONAL WCHAR const *pwsz)
{
    if (S_OK != hrNew)
    {
        if (NULL != pwsz)
        {
            _PrintErrorStr(hrNew, psz, pwsz);
        }
        else
        {
            _PrintError(hrNew, psz);
        }
        if (S_OK == hrOld)
        {
            //save only oldest err
            hrOld = hrNew;
        }
    }
    return hrOld;
}

HRESULT
UpgradePolicyCDPURLs(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    WCHAR const **ppwsz;

    for (ppwsz = apwszPolicyCDPEntriesToFix; NULL != *ppwsz; ppwsz++)
    {
        // all entries are multi-valued
        hr2 = UpgradeRevocationURLReplaceParam(
                     TRUE, TRUE, pwszSanitizedName, *ppwsz);
        hr = myPrintIfError(hr2, hr, "UpgradeRevocationURLReplaceParam", *ppwsz);

        hr2 = UpgradeMoveURLsLocation(TRUE, pwszSanitizedName, *ppwsz);
        hr = myPrintIfError(hr2, hr, "UpgradeMoveURLsLocation", *ppwsz);
    }

    hr2 = UpgradeRevocationURLRemoveParam(pwszSanitizedName, wszREGREVOCATIONURL);
    hr = myPrintIfError(hr2, hr, "UpgradeRevocationURLRemoveParam", wszREGREVOCATIONURL);
    hr2 = UpgradeCRLPath(pwszSanitizedName);
    hr = myPrintIfError(hr2, hr, "UpgradeCRLPath", NULL);

    return(hr);
}

WCHAR const *apwszPolicyAIAEntriesToFix[] =
{
    wszREGLDAPISSUERCERTURL_OLD, //"LDAPIssuerCertURL"
    wszREGISSUERCERTURL_OLD,     //"IssuerCertURL"
    wszREGFTPISSUERCERTURL_OLD,  //"FTPIssuerCertURL"
    wszREGFILEISSUERCERTURL_OLD, //"FileIssuerCertURL"
    NULL
};

HRESULT
UpgradePolicyAIAURLs(
    IN WCHAR const *pwszSanitizedName)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    WCHAR const **ppwsz;

    for (ppwsz = apwszPolicyAIAEntriesToFix; NULL != *ppwsz; ppwsz++)
    {
        // all entries are multi-valued
        hr2 = UpgradeMoveURLsLocation(FALSE, pwszSanitizedName, *ppwsz);
        hr = myPrintIfError(hr2, hr, "UpgradeMoveURLsLocation", *ppwsz);
    }
    return(hr);
}

HRESULT
UpgradeExitRevocationURLs(
    IN WCHAR const *pwszSanitizedName)
{
    WCHAR const **ppwsz;

    for (ppwsz = apwszB3ExitEntriesToFix; NULL != *ppwsz; ppwsz++)
    {
        // all entries are single-valued
        UpgradeRevocationURLReplaceParam(FALSE, FALSE, pwszSanitizedName, *ppwsz);
    }
    return(S_OK);
}


// following code to determine if current policy/exit modules are custom
// if find any custom module and assign it to
// pServer->pwszCustomPolicy/Exit
// otherwise pServer->pwszCustomPolicy/Exit = NULL means default as active

#define wszCERTSRV10POLICYPROGID  L"CertificateAuthority.Policy"
#define wszCERTSRV10EXITPROGID    L"CertificateAuthority.Exit"
#define wszCLSID                  L"ClsID\\"
#define wszINPROCSERVER32         L"\\InprocServer32"

HRESULT
DetermineServerCustomModule(
    PER_COMPONENT_DATA *pComp,
    IN BOOL  fPolicy)
{
    HRESULT  hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;

    // init
    if (fPolicy)
    {
        if (NULL != pServer->pwszCustomPolicy)
        {
            LocalFree(pServer->pwszCustomPolicy);
            pServer->pwszCustomPolicy = NULL;
        }
    }
    else
    {
        if (NULL != pServer->pwszzCustomExit)
        {
            LocalFree(pServer->pwszzCustomExit);
            pServer->pwszzCustomExit = NULL;
        }
    }

    // build to build
    // to pass what is the current active policy
    if (fPolicy)
    {
        // policy module
        hr = myGetCertRegStrValue(
                    pServer->pwszSanitizedName,
                    wszREGKEYPOLICYMODULES,
                    NULL,
                    wszREGACTIVE,
                    &pServer->pwszCustomPolicy);
        _JumpIfError(hr, done, "myGetCertRegStrValue");
    }
    else
    {
        // exit module
        hr = myGetCertRegMultiStrValue(
                    pServer->pwszSanitizedName,
                    wszREGKEYEXITMODULES,
                    NULL,
                    wszREGACTIVE,
                    &pServer->pwszzCustomExit);
        _JumpIfError(hr, done, "myGetCertRegStrValue");
    }


done:
    hr = S_OK;

//error:

    return hr;
}

HRESULT
UpgradeServerRegEntries(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;
    WCHAR   *pwszCRLPeriodString = NULL;
    BOOL     fUseNewCRLPublish = FALSE;
    DWORD    dwCRLPeriodCount;
    DWORD    Count;

    BOOL  fUpgradeW2K = CS_UPGRADE_WIN2000 == pComp->UpgradeFlag;

    CSASSERT(
        NULL != pServer->pwszSanitizedName &&
        NULL != pServer->pccUpgradeCert);

    // Description:
    // - if upgrade and get this point, all necessary data structure
    //   should be loaded and created in LoadAndDetermineServerUpgradeInfo()
    // - in this module, check all different upgrade cases,
    //   upgrade (move) reg entries
    // - remove old unused reg entries if upgrade
    //   Note: each of above steps applys from config level down to ca then
    //         to policy, etc.
    // - lastly call CreateServerRegEntries with upgrade flag

    // CONFIGURATION LEVEL


    // CA LEVEL
    hr = myGetCARegHashCount(
			pServer->pwszSanitizedName,
			CSRH_CASIGCERT,
			&Count);
    _JumpIfError(hr, error, "myGetCARegHashCount");

    if (0 == Count)
    {
	    hr = mySetCARegHash(
			    pServer->pwszSanitizedName,
			    CSRH_CASIGCERT,
			    0,	// iCert
			    pServer->pccUpgradeCert);
	    _JumpIfError(hr, error, "mySetCARegHash");
    }


    // POLICY LEVEL

    {
        //could fix two things, 1) W2K from B3 needs fixing token plus 2) or
        //                      2) W2K needs fix CDP location

        hr = UpgradePolicyCDPURLs(pServer->pwszSanitizedName);
        _PrintIfError(hr, "UpgradePolicyCDPURLs");

        hr = UpgradePolicyAIAURLs(pServer->pwszSanitizedName);
        _PrintIfError(hr, "UpgradePolicyAIAURLs");

        hr = UpgradeExitRevocationURLs(pServer->pwszSanitizedName);
        _PrintIfError(hr, "UpgradeExitRevocationURLs");

        //UNDONE, we need move url for cdp and aia under policy to ca level
    }


    // EXIT LEVEL

    // DELETE OLD AND UNUSED ENTRIES
        
    hr = CreateServerRegEntries(hwnd, TRUE, pComp);
    _JumpIfError(hr, error, "CreateServerRegEntries");

//    hr = S_OK;
error:
    if (NULL != pwszCRLPeriodString)
    {
        LocalFree(pwszCRLPeriodString);
    }
    CSILOG(hr, IDS_LOG_UPGRADE_SERVER_REG, NULL, NULL, NULL);
    return(hr);
}


HRESULT
RegisterAndUnRegisterDLLs(
    IN DWORD Flags,
    IN PER_COMPONENT_DATA *pComp,
    IN HWND hwnd)
{
    HRESULT hr;
    HMODULE hMod = NULL;
    typedef HRESULT (STDAPICALLTYPE FNDLLREGISTERSERVER)(VOID);
    FNDLLREGISTERSERVER *pfnRegister;
    CHAR const *pszFuncName;
    REGISTERDLL const *prd;
    WCHAR wszString[MAX_PATH];
    UINT errmode = 0;
    BOOL fCoInit = FALSE;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    errmode = SetErrorMode(SEM_FAILCRITICALERRORS);
    pszFuncName = 0 == (RD_UNREGISTER & Flags)?
                        aszRegisterServer[0] : aszRegisterServer[1];

    for (prd = g_aRegisterDll; NULL != prd->pwszDllName; prd++)
    {
        if ((Flags & RD_UNREGISTER) &&
            ((Flags & RD_SKIPUNREGPOLICY) && (prd->Flags & RD_SKIPUNREGPOLICY) ||
             (Flags & RD_SKIPUNREGEXIT) && (prd->Flags & RD_SKIPUNREGEXIT) ||
             (Flags & RD_SKIPUNREGMMC) && (prd->Flags & RD_SKIPUNREGMMC)))
        {
            // case of upgrade path & this dll doesn't want to unreg
            continue;
        }

        if (Flags & prd->Flags)
        {
            if (NULL != g_pwszArgvPath)
            {
                wcscpy(wszString, g_pwszArgvPath);
                if (L'\0' != wszString[0] &&
                    L'\\' != wszString[wcslen(wszString) - 1])
                {
                    wcscat(wszString, L"\\");
                }
            }
            else
            {
                wcscpy(wszString, pComp->pwszSystem32);
            }
            wcscat(wszString, prd->pwszDllName);

            hMod = LoadLibrary(wszString);
            if (NULL == hMod)
            {
                hr = myHLastError();
                if (0 == (RD_UNREGISTER & Flags) &&
                    (!(RD_WHISTLER & prd->Flags) || IsWhistler()))
                {
		    SaveCustomMessage(pComp, wszString);
                    CertErrorMessageBox(
                                    pComp->hInstance,
                                    pComp->fUnattended,
                                    hwnd,
                                    IDS_ERR_DLLFUNCTION_CALL,
                                    hr,
                                    wszString);
                    _JumpErrorStr(hr, error, "DllRegisterServer", wszString);

		    CSILOG(hr, IDS_LOG_DLLS_REGISTERED, wszString, NULL, NULL);
                    _JumpErrorStr(hr, error, "LoadLibrary", wszString);
                }
                hr = S_OK;
                continue;
            }

            pfnRegister = (FNDLLREGISTERSERVER *) GetProcAddress(
                                                            hMod,
                                                            pszFuncName);
            if (NULL == pfnRegister)
            {
                hr = myHLastError();
                _JumpErrorStr(hr, error, "GetProcAddress", wszString);
            }

            __try
            {
                hr = (*pfnRegister)();
            }
            __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
            {
            }

            FreeLibrary(hMod);
            hMod = NULL;

            if (S_OK != hr)
            {
		CSILOG(
		    hr,
		    (RD_UNREGISTER & Flags)?
			IDS_LOG_DLLS_UNREGISTERED : IDS_LOG_DLLS_REGISTERED,
		    wszString,
		    NULL,
		    NULL);
                if (0 == (RD_UNREGISTER & Flags))
                {
                    CertErrorMessageBox(
                                    pComp->hInstance,
                                    pComp->fUnattended,
                                    hwnd,
                                    IDS_ERR_DLLFUNCTION_CALL,
                                    hr,
                                    wszString);
                    _JumpErrorStr(hr, error, "DllRegisterServer", wszString);
                }
                else
                {
                    _PrintErrorStr(hr, "DllUnregisterServer", wszString);
                }
            }
        }
    }
    hr = S_OK;

error:
    if (NULL != hMod)
    {
        FreeLibrary(hMod);
    }
    SetErrorMode(errmode);
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (S_OK == hr)
    {
	CSILOG(
	    hr,
	    (RD_UNREGISTER & Flags)?
		IDS_LOG_DLLS_UNREGISTERED : IDS_LOG_DLLS_REGISTERED,
	    NULL,
	    NULL,
	    NULL);
    }
    return(hr);
}


HRESULT
CreateProgramGroups(
    BOOL fClient,
    PER_COMPONENT_DATA *pComp,
    HWND hwnd)
{
    HRESULT hr;
    PROGRAMENTRY const *ppe;
    WCHAR const *pwszLinkName = NULL;
    DWORD Flags = fClient? PE_CLIENT : PE_SERVER;

    DBGPRINT((
        DBG_SS_CERTOCMI,
        "CreateProgramGroups: %ws\n",
        fClient? L"Client" : L"Server"));

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        if ((Flags & ppe->Flags) && 0 == (PE_DELETEONLY & ppe->Flags))
        {
            WCHAR const *pwszGroupName;
            WCHAR const *pwszDescription;
            WCHAR awc[MAX_PATH];
            WCHAR const *pwszArgs;

            wcscpy(awc, pComp->pwszSystem32);
            wcscat(awc, ppe->pwszExeName);
            pwszArgs = fClient? ppe->pwszClientArgs : ppe->pwszServerArgs;
            if (NULL != pwszArgs)
            {
                wcscat(awc, L" ");
                wcscat(awc, pwszArgs);
            }

            pwszLinkName = myLoadResourceString(ppe->uiLinkName);
            if (NULL == pwszLinkName)
            {
                hr = myHLastError();
                _JumpError(hr, error, "myLoadResourceString");
            }

            pwszGroupName = NULL;
            if (0 != ppe->uiGroupName)
            {
                pwszGroupName = myLoadResourceString(ppe->uiGroupName);
                if (NULL == pwszGroupName)
                {
                    hr = myHLastError();
                    _JumpError(hr, error, "myLoadResourceString");
                }
            }

            pwszDescription = NULL;
            if (0 != ppe->uiDescription)
            {
                pwszDescription = myLoadResourceString(ppe->uiDescription);
                if (NULL == pwszDescription)
                {
                    hr = myHLastError();
                    _JumpError(hr, error, "myLoadResourceString");
                }
            }

	    if (!CreateLinkFile(
			ppe->csidl,         // CSIDL_*
			pwszGroupName,      // IN LPCSTR lpSubDirectory
			pwszLinkName,       // IN LPCSTR lpFileName
			awc,                // IN LPCSTR lpCommandLine
			NULL,               // IN LPCSTR lpIconPath
			0,                  // IN INT    iIconIndex
			NULL,               // IN LPCSTR lpWorkingDirectory
			0,                  // IN WORD   wHotKey
			SW_SHOWNORMAL,      // IN INT    iShowCmd
			pwszDescription))           // IN LPCSTR lpDescription
	    {
		hr = myHLastError();
		_PrintErrorStr(hr, "CreateLinkFile", awc);
		_JumpErrorStr(hr, error, "CreateLinkFile", pwszLinkName);
            }
        }
    }

    hr = S_OK;
error:
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_ERR_CREATELINK,
                        hr,
                        pwszLinkName);
        pComp->fShownErr = TRUE;
    }
    CSILOG(hr, IDS_LOG_PROGRAM_GROUPS, NULL, NULL, NULL);
    return(hr);
}


HRESULT
MakeRevocationPage(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp,
    IN WCHAR const *pwszFile)
{
    DWORD hr;
    WCHAR *pwszASP = NULL;
    WCHAR *pwszConfig = NULL;
    HANDLE hFile = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

#define wszASP1 \
    L"<%\r\n" \
    L"Response.ContentType = \"application/x-netscape-revocation\"\r\n" \
    L"serialnumber = Request.QueryString\r\n" \
    L"set Admin = Server.CreateObject(\"CertificateAuthority.Admin\")\r\n" \
    L"\r\n" \
    L"stat = Admin.IsValidCertificate(\""

#define wszASP2 \
    L"\", serialnumber)\r\n" \
    L"\r\n" \
    L"if stat = 3 then Response.Write(\"0\") else Response.Write(\"1\") end if\r\n" \
    L"%>\r\n"

    hr = myFormConfigString(pComp->pwszServerName,
                            pServer->pwszSanitizedName,
                            &pwszConfig);
    _JumpIfError(hr, error, "myFormConfigString");

    pwszASP = (WCHAR *) LocalAlloc(
                            LMEM_FIXED,
                            (WSZARRAYSIZE(wszASP1) +
                             wcslen(pwszConfig) +
                             WSZARRAYSIZE(wszASP2) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszASP);

    wcscpy(pwszASP, wszASP1);
    wcscat(pwszASP, pwszConfig);
    wcscat(pwszASP, wszASP2);

    hFile = CreateFile(
                    pwszFile,           // lpFileName
                    GENERIC_WRITE,      // dwDesiredAccess
                    0,                  // dwShareMode
                    NULL,               // lpSecurityAttributes
                    CREATE_ALWAYS,      // dwCreationDisposition
                    0,                  // dwFlagsAndAttributes
                    0);                 // hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
       hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
       _JumpError(hr, error, "CreateFile");
    }
    hr = myStringToAnsiFile(hFile, pwszASP, -1);

error:
    if (hFile)
        CloseHandle(hFile);

    if (NULL != pwszASP)
    {
        LocalFree(pwszASP);
    }
    if (NULL != pwszConfig)
    {
        LocalFree(pwszConfig);
    }
    return(hr);
}


VOID
setupDeleteFile(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile)
{
    HRESULT hr;
    WCHAR *pwszFilePath = NULL;

    hr = myBuildPathAndExt(pwszDir, pwszFile, NULL, &pwszFilePath);
    _JumpIfError(hr, error, "myBuildPathAndExt");
    
    if (!DeleteFile(pwszFilePath))
    {
        hr = myHLastError();
        _PrintErrorStr2(hr, "DeleteFile", pwszFilePath, hr);
    }

error:
    if (NULL != pwszFilePath)
    {
       LocalFree(pwszFilePath);
    }
}


//+------------------------------------------------------------------------
//  Function:   RenameMiscTargets(. . . .)
//
//  Synopsis:   Handles various renaming jobs from the names that things
//              are given at installation time to the names that they need
//              in their new homes to run properly.
//
//  Arguments:  None
//
//  Returns:    DWORD error code.
//
//  History:    3/21/97 JerryK  Created
//-------------------------------------------------------------------------

HRESULT
RenameMiscTargets(
    HWND hwnd,
    PER_COMPONENT_DATA *pComp,
    BOOL fServer)
{
    HRESULT hr = S_OK;
    WCHAR wszAspPath[MAX_PATH]; wszAspPath[0] = L'\0';
    WCHAR wszCertSrv[MAX_PATH]; wszCertSrv[0] = L'\0';
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (fServer)
    {
        // Create nsrev_<CA Name>.asp
        BuildPath(
                wszCertSrv,
                ARRAYSIZE(wszCertSrv),
                pComp->pwszSystem32,
		wszCERTENROLLSHAREPATH);
        BuildPath(
                wszAspPath,
                ARRAYSIZE(wszAspPath),
                wszCertSrv,
                L"nsrev_");
        wcscat(wszAspPath, pServer->pwszSanitizedName);
        wcscat(wszAspPath, TEXT(".asp"));
        CSASSERT(wcslen(wszAspPath) < ARRAYSIZE(wszAspPath));

        hr = MakeRevocationPage(hwnd, pComp, wszAspPath);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hwnd,
                            IDS_ERR_CREATEFILE,
                            hr,
                            wszAspPath);
            _JumpError(hr, error, "MakeRevocationPage");
        }

    }

error:
    return(hr);
}



HRESULT
CreateCertificateService(
    PER_COMPONENT_DATA *pComp,
    HWND hwnd)
{
    HRESULT hr;
    WCHAR const *pwszDisplayName;
    SERVICE_DESCRIPTION sd;
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSC = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (NULL != pServer->pwszSharedFolder)
    {
        // add entry
        hr = CreateConfigFiles(pServer->pwszSharedFolder, pComp, FALSE, hwnd);
        if (S_OK != hr)
        {
            CertErrorMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hwnd,
                IDS_ERR_CREATECERTSRVFILE,
                hr,
                pServer->pwszSharedFolder);
            _JumpError(hr, error, "CreateConfigFiles");
        }
    }


    if (NULL != g_pwszArgvPath)
    {
        wcscpy(g_wszServicePath, g_pwszArgvPath);
        if (L'\0' != g_wszServicePath[0] &&
            L'\\' != g_wszServicePath[wcslen(g_wszServicePath) - 1])
        {
            wcscat(g_wszServicePath, L"\\");
        }
    }
    else
    {
        wcscpy(g_wszServicePath, pComp->pwszSystem32);
    }
    wcscat(g_wszServicePath, wszCERTSRVEXENAME);

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCManager)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenSCManager");
    }

    if (NULL == g_pwszNoService)
    {
        pwszDisplayName = myLoadResourceString(IDS_CA_SERVICEDISPLAYNAME);
        if (NULL == pwszDisplayName)
        {
            hr = myHLastError();
            _JumpError(hr, error, "myLoadResourceString");
        }

        sd.lpDescription = const_cast<WCHAR *>(myLoadResourceString(
                                                IDS_CA_SERVICEDESCRIPTION));
        if (NULL == sd.lpDescription)
        {
            hr = myHLastError();
            _JumpError(hr, error, "myLoadResourceString");
        }

        hSC = CreateService(
                        hSCManager,                     // hSCManager
                        wszSERVICE_NAME,                // lpServiceName
                        pwszDisplayName,                // lpDisplayName
                        SERVICE_ALL_ACCESS,             // dwDesiredAccess
                        SERVICE_WIN32_OWN_PROCESS|      // dwServiceType
                        (pServer->fInteractiveService?
                        SERVICE_INTERACTIVE_PROCESS:0),
                        SERVICE_AUTO_START,             // dwStartType
                        SERVICE_ERROR_NORMAL,           // dwErrorControl
                        g_wszServicePath,               // lpBinaryPathName
                        NULL,                           // lpLoadOrderGroup
                        NULL,                           // lplpdwTagId
                        NULL,                           // lpDependencies
                        NULL,                           // lpServiceStartName
                        NULL);                          // lpPassword
        if (NULL == hSC)
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_DUPLICATE_SERVICE_NAME) != hr &&
                HRESULT_FROM_WIN32(ERROR_SERVICE_EXISTS) != hr)
            {
                CertErrorMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hwnd,
                        IDS_ERR_CREATESERVICE,
                        hr,
                        wszSERVICE_NAME);
                _JumpError(hr, error, "CreateService");
            }
        }
        if (!ChangeServiceConfig2(
                            hSC,                        // hService
                            SERVICE_CONFIG_DESCRIPTION, // dwInfoLevel
                            (VOID *) &sd))              // lpInfo
        {
            // This error is not critical.

            hr = myHLastError();
            _PrintError(hr, "ChangeServiceConfig2");
        }
    }

    // add event log message DLL (ok, it's really an EXE) as a message source

    hr = myAddLogSourceToRegistry(g_wszServicePath, wszSERVICE_NAME);
    if (S_OK != hr)
    {
        CertErrorMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hwnd,
                    IDS_ERR_ADDSOURCETOREGISTRY,
                    hr,
                    NULL);
        _JumpError(hr, error, "AddLogSourceToRegistry");
    }

error:
    if (NULL != hSC)
    {
        CloseServiceHandle(hSC);
    }
    if (NULL != hSCManager)
    {
        CloseServiceHandle(hSCManager);
    }
    CSILOG(hr, IDS_LOG_CREATE_SERVICE, NULL, NULL, NULL);
    return(hr);
}


HRESULT
DeleteProgramGroups(
    IN BOOL fAll,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    PROGRAMENTRY const *ppe;
    WCHAR const *pwszLinkName;
    WCHAR const *pwszGroupName;

    for (ppe = g_aProgramEntry; ppe < &g_aProgramEntry[CPROGRAMENTRY]; ppe++)
    {
        if (fAll || (PE_DELETEONLY & ppe->Flags))
        {
            pwszLinkName = myLoadResourceString(ppe->uiLinkName);
            if (NULL == pwszLinkName)
            {
                hr = myHLastError();
                _PrintError(hr, "myLoadResourceString");
                continue;
            }

            pwszGroupName = NULL;
            if (0 != ppe->uiGroupName)
            {
                pwszGroupName = myLoadResourceString(ppe->uiGroupName);
                if (NULL == pwszGroupName)
                {
                    hr = myHLastError();
                    _PrintError(hr, "myLoadResourceString");
                    continue;
                }
            }
	    if (!DeleteLinkFile(
		    ppe->csidl,             // CSIDL_*
		    pwszGroupName,          // IN LPCSTR lpSubDirectory
		    pwszLinkName,           // IN LPCSTR lpFileName
		    FALSE))                 // IN BOOL fDeleteSubDirectory
	    {
		hr = myHLastError();
		_PrintError3(
			hr,
			"DeleteLinkFile",
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
			HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));
            }
        }
    }
    pwszGroupName = myLoadResourceString(IDS_STARTMENU_CERTSERVER);
    if (NULL == pwszGroupName)
    {
        hr = myHLastError();
        _PrintError(hr, "myLoadResourceString");
    }
    else if (!DeleteGroup(pwszGroupName, TRUE))
    {
	hr = myHLastError();
	_PrintError(hr, "DeleteGroup");
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
CancelCertsrvInstallation(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp)
{
    static BOOL s_fCancelled = FALSE;
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    if (s_fCancelled)
    {
        goto done;
    }

    if (IS_SERVER_INSTALL & pComp->dwInstallStatus)
    {
        // uninstall will remove reg entries and others
        PreUninstallCore(hwnd, pComp, FALSE);

        // Note, GUI mode, we allow re-try post setup in case of cancel or failure
        //       but unattended mode, only allow once
        UninstallCore(hwnd, pComp, 0, 0, FALSE, FALSE, !pComp->fUnattended);

        if (pComp->fUnattended)
        {
            hr = SetSetupStatus(
                NULL,
                SETUP_CLIENT_FLAG | SETUP_SERVER_FLAG,
                FALSE);
        }
    }

    if (NULL != pServer)
    {
        if (NULL == pServer->pccExistingCert)
        {
            if (pServer->fSavedCAInDS)
            {
                // remove ca entry from ds
                hr = RemoveCAInDS(pServer->pwszSanitizedName);
                if (S_OK == hr)
                {
                    pServer->fSavedCAInDS = FALSE;
                }
                else
                {
                    _PrintError(hr, "RemoveCAInDS");
                }
            }
        }

        // delete the new key container, if necessary.
        ClearKeyContainerName(pServer);

        DisableVRootsAndShares(pComp->fCreatedVRoot, pServer->fCreatedShare);
    }

    DBGPRINT((DBG_SS_CERTOCM, "Certsrv setup is cancelled.\n"));

    s_fCancelled = TRUE; // only once
done:
    hr = S_OK;
//error:
    CSILOG(hr, IDS_LOG_CANCEL_INSTALL, NULL, NULL, NULL);
    return hr;
}

// Returns true if the specified period is valid. For year it 
// should be in the VP_MIN,VP_MAX range. For days/weeks/months,
// we define a separate upper limit to be consistent with the
// attended setup which restricts the edit box to 4 digits.
bool IsValidPeriod(const CASERVERSETUPINFO *pServer)
{
    return VP_MIN <= pServer->dwValidityPeriodCount &&
       !(ENUM_PERIOD_YEARS == pServer->enumValidityPeriod &&
       VP_MAX < pServer->dwValidityPeriodCount) &&
       !(ENUM_PERIOD_YEARS != pServer->enumValidityPeriod &&
       VP_MAX_DAYS_WEEKS_MONTHS < pServer->dwValidityPeriodCount);
}

HRESULT DeleteCertificates(const WCHAR* pwszSanitizedCAName, BOOL fRoot)
{
    HRESULT hr = S_OK, hr2 = S_OK;
    DWORD cCACerts, cCACert, dwNameId;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCACert = NULL, *pDupCert;

    hr = myGetCARegHashCount(pwszSanitizedCAName, CSRH_CASIGCERT, &cCACerts);
    _JumpIfError(hr, error, "myGetCARegHashCount CSRH_CASIGCERT");

    hStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,
                        X509_ASN_ENCODING,
                        NULL,           // hProv
                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                        fRoot?wszROOT_CERTSTORE:wszCA_CERTSTORE);
    
    for(cCACert=0; cCACert<cCACerts; cCACert++)
    {
        hr2 = myFindCACertByHashIndex(
                            hStore,
                            pwszSanitizedCAName,
                            CSRH_CASIGCERT,
                            cCACert,
                            &dwNameId,
                            &pCACert);
        if(S_OK!=hr2)
        {
            hr = hr2;
            _PrintIfError(hr2, "myFindCACertByHashIndex");
            continue;
        }

        if(!CertDeleteCertificateFromStore(pCACert))
        {
            _PrintError(hr, "CertDeleteCertificateFromStore");
            CertFreeCertificateContext(pCACert);
        }
        pCACert = NULL;
    }

error:

    CSASSERT(!pCACert);

    if (NULL != hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }
    return hr;
}


HRESULT TriggerAutoenrollment() 
{
    HRESULT hr = S_OK;

    // must be cleaned up
    CAutoHANDLE hEvent;

    hEvent=OpenEvent(
        EVENT_MODIFY_STATE, 
        false, 
        L"Global\\" MACHINE_AUTOENROLLMENT_TRIGGER_EVENT);

    if (!hEvent) 
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenEvent");
    }

    if (!SetEvent(hEvent)) 
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenEvent");
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_STARTMENU_CERTHIER_LINKNAME),
    RESSTR(IDS_STARTMENU_CERTREQ_LINKNAME),
    RESSTR(IDS_STARTMENU_CERTSERVER),
    RESSTR(IDS_STARTMENU_NEWCRL_LINKNAME),
    RESSTR(IDS_ADVANCE_INVALIDKEYLENGTH),
    RESSTR(IDS_ADVANCE_KEYLENGTHOUTOFRANGE),
    RESSTR(IDS_ADVANCE_NEGATIVEKEYLENGTH),
    RESSTR(IDS_ADVANCE_SUBTITLE),
    RESSTR(IDS_ADVANCE_TITLE),
    RESSTR(IDS_ASK_CREATE_DIRECTORY),
    RESSTR(IDS_CALENSTRERR),
    RESSTR(IDS_CANULLSTRERR),
    RESSTR(IDS_CAREQUEST_SUBTITLE),
    RESSTR(IDS_CAREQUEST_TITLE),
    RESSTR(IDS_CATYPE_DES_ENTERPRISE_ROOTCA),
    RESSTR(IDS_CATYPE_DES_ENTERPRISE_SUBCA),
    RESSTR(IDS_CATYPE_DES_STANDALONE_ROOTCA),
    RESSTR(IDS_CATYPE_DES_STANDALONE_SUBCA),
    RESSTR(IDS_CATYPE_SUBTITLE),
    RESSTR(IDS_CATYPE_TITLE),
    RESSTR(IDS_CA_SERVICEDESCRIPTION),
    RESSTR(IDS_CA_SERVICEDISPLAYNAME),
    RESSTR(IDS_CERTCONFIG_FOLDERDESCR),
    RESSTR(IDS_CLIENT_NOCA),
    RESSTR(IDS_CLIENT_NOCOMPUTER),
    RESSTR(IDS_CLIENT_SUBTITLE),
    RESSTR(IDS_CLIENT_TITLE),
    RESSTR(IDS_COMPUTERLENSTRERR),
    RESSTR(IDS_COMPUTERNULLSTRERR),
    RESSTR(IDS_CONFIG_PICKER_PROMPT),
    RESSTR(IDS_CONFIG_PICKER_TITLE),
    RESSTR(IDS_ERR_ADDSOURCETOREGISTRY),
    RESSTR(IDS_ERR_ANALYSIS_CA),
    RESSTR(IDS_ERR_BUILDCERT),
    RESSTR(IDS_ERR_BUILDCERTREQUEST),
    RESSTR(IDS_FINAL_ERROR_TEXT),
    RESSTR(IDS_ERR_CERTSRV_SETUP_FAIL),
    RESSTR(IDS_ERR_CREATECERTSRVFILE),
    RESSTR(IDS_ERR_CREATELINK),
    RESSTR(IDS_ERR_CREATESERVICE),
    RESSTR(IDS_ERR_DELETESERVICE),
    RESSTR(IDS_ERR_DLLFUNCTION_CALL),
    RESSTR(IDS_ERR_EMPTYCANAME),
    RESSTR(IDS_ERR_EMPTYPFXFILE),
    RESSTR(IDS_ERR_FATAL_GENKEY),
    RESSTR(IDS_ERR_IMPORTPFX),
    RESSTR(IDS_ERR_INVALIDHASH),
    RESSTR(IDS_ERR_LOADICERTCONFIG),
    RESSTR(IDS_ERR_NETUSERMODALSGET),
    RESSTR(IDS_ERR_NOT_ADM),
    RESSTR(IDS_ERR_UNSUPPORTEDHASH),
    RESSTR(IDS_ERR_WRITECONFIGFILE),
    RESSTR(IDS_IDINFO_CAEXISTINDS),
    RESSTR(IDS_IDINFO_DESCRIPTIONLENSTRERR),
    RESSTR(IDS_IDINFO_COUNTRYLENSTRERR),
    RESSTR(IDS_IDINFO_DETERMINEDBYPCA),
    RESSTR(IDS_IDINFO_EMAILLENSTRERR),
    RESSTR(IDS_IDINFO_INVALID_COUNTRYCODE),
    RESSTR(IDS_IDINFO_INVALID_COUNTRYCODE_LEN),
    RESSTR(IDS_IDINFO_INVALID_VALIDITY),
    RESSTR(IDS_IDINFO_LOCALITYLENSTRERR),
    RESSTR(IDS_IDINFO_NAMELENSTRERR),
    RESSTR(IDS_IDINFO_NAMENULLSTRERR),
    RESSTR(IDS_IDINFO_ORGLENSTRERR),
    RESSTR(IDS_IDINFO_ORGUNITLENSTRERR),
    RESSTR(IDS_IDINFO_STATELENSTRERR),
    RESSTR(IDS_IDINFO_SUBTITLE),
    RESSTR(IDS_IDINFO_TITLE),
    RESSTR(IDS_IDINFO_VALIDITYNULLSTRERR),
    RESSTR(IDS_IMPORT_PFX_TITLE),
    RESSTR(IDS_INCOMPLETE_REQUEST),
    RESSTR(IDS_KEYGEN_GENERATING),
    RESSTR(IDS_KEYGEN_PROTECTING),
    RESSTR(IDS_KEYGEN_SUBTITLE),
    RESSTR(IDS_KEYGEN_TESTINGHASHANDKEY),
    RESSTR(IDS_KEYGEN_TITLE),
    RESSTR(IDS_KEY_INVALID),
    RESSTR(IDS_PATH_TOO_LONG_CANAME),
    RESSTR(IDS_PFX_FILE_FILTER),
    RESSTR(IDS_PFX_FILE_NOT_FOUND),
    RESSTR(IDS_PFX_INVALID_PASSWORD),
    RESSTR(IDS_PFX_KEYANDCERTEXIST),
    RESSTR(IDS_PFX_PATH_INVALID),
    RESSTR(IDS_REQUESTFILELENSTRERR),
    RESSTR(IDS_REQUESTFILENULLSTRERR),
    RESSTR(IDS_STOP_W3SVC),
    RESSTR(IDS_STORELOC_PARENTDIRMUSTEXIST),
    RESSTR(IDS_STORELOC_PATHTOOLONG),
    RESSTR(IDS_STORELOC_UNCMUSTEXIST),
    RESSTR(IDS_STORE_SUBTITLE),
    RESSTR(IDS_STORE_TITLE),
    RESSTR(IDS_TODO_TITLE),
    RESSTR(IDS_VALIDITY_DAY),
    RESSTR(IDS_VALIDITY_MONTH),
    RESSTR(IDS_VALIDITY_WEEK),
    RESSTR(IDS_VALIDITY_YEAR),
    RESSTR(IDS_WRN_DBFILEINUSE),
    RESSTR(IDS_WRN_OVERWRITEEXISTINGKEY),
    RESSTR(IDS_WRN_STORELOC_DB_FULLPATH),
    RESSTR(IDS_WRN_STORELOC_EXISTINGDB),
    RESSTR(IDS_WRN_STORELOC_LOG_FULLPATH),
    RESSTR(IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH),
    RESSTR(IDS_WRN_UNICODESTRINGENCODING),
    RESSTR(IDS_LOG_BEGIN),
    RESSTR(IDS_LOG_END),
    RESSTR(IDS_LOG_WAS_ENABLED),
    RESSTR(IDS_LOG_IS_ENABLED),
    RESSTR(IDS_LOG_INSTALL_STATE),
    RESSTR(IDS_LOG_CREATE_REQUEST),
    RESSTR(IDS_LOG_CREATE_CERTIFICATE),
    RESSTR(IDS_LOG_START_SERVICE),
    RESSTR(IDS_LOG_WEB_INCLUDE),
    RESSTR(IDS_LOG_INSTALL_CLIENT),
    RESSTR(IDS_LOG_INSTALL_SERVER),
    RESSTR(IDS_LOG_UPGRADE_TYPE),
    RESSTR(IDS_LOG_UPGRADE_CERT_STORE),
    RESSTR(IDS_LOG_UPGRADE_KEY_SECURITY),
    RESSTR(IDS_LOG_UPGRADE_SERVER),
    RESSTR(IDS_LOG_UPGRADE_CLIENT),
    RESSTR(IDS_LOG_SERVICE_STOPPED),
    RESSTR(IDS_LOG_SERVICE_STARTED),
    RESSTR(IDS_LOG_CREATE_CLIENT_REG),
    RESSTR(IDS_LOG_CREATE_SERVER_REG),
    RESSTR(IDS_LOG_UPGRADE_SERVER_REG),
    RESSTR(IDS_LOG_DLLS_UNREGISTERED),
    RESSTR(IDS_LOG_DLLS_REGISTERED),
    RESSTR(IDS_LOG_PROGRAM_GROUPS),
    RESSTR(IDS_LOG_CREATE_SERVICE),
    RESSTR(IDS_LOG_CANCEL_INSTALL),
    RESSTR(IDS_LOG_FUNCTION),
    RESSTR(IDS_LOG_UNATTENDED_ATTRIBUTE),
    RESSTR(IDS_LOG_CLIENT_UNATTENDED_ATTRIBUTES),
    RESSTR(IDS_LOG_SERVER_UNATTENDED_ATTRIBUTES),
    RESSTR(IDS_LOG_OPERATIONFLAGS),
    RESSTR(IDS_LOG_TODOLIST),
    RESSTR(IDS_LOG_POSTBASE),
    RESSTR(IDS_LOG_UNATTENDED),
    RESSTR(IDS_LOG_REGSTATE),
    RESSTR(IDS_LOG_SELECTIONSTATE),
    RESSTR(IDS_WELCOME_TITLE),
    RESSTR(IDS_FINAL_TITLE),
    RESSTR(IDS_LOG_IMPORTPFX),
    RESSTR(IDS_ERR_CREATE_DIR),
    RESSTR(IDS_WRN_UNINSTALL_BOTH),
    RESSTR(IDS_WRN_UNINSTALL_CLIENT),
    RESSTR(IDS_PFX_WRONG_SELFSIGN_TYPE),
    RESSTR(IDS_CAREQUEST_REQUESTFILEPATH_MUSTEXIST),
    RESSTR(IDS_LOG_IGNORE_KEYLENGTH),
    RESSTR(IDS_CAREQUEST_REQUESTFILEPATH_DIREXISTS),
    RESSTR(IDS_PFX_FILE_OR_PASSWORD_TOO_LONG),
    RESSTR(IDS_ERR_UPGRADE_NOT_SUPPORTED),
    RESSTR(IDS_WRN_SERVER_ONLY),
    RESSTR(IDS_IDINFO_VALIDITYLENSTRERR),
    RESSTR(IDS_WRN_IDINFO_INVALIDDN),
    RESSTR(IDS_HTML_CERTWEBDAT),
    RESSTR(IDS_HTML_NSREV),
    RESSTR(IDS_IDINFO_DELETECERTIFICATES),
    RESSTR(IDS_LOG_CANAME),
    RESSTR(IDS_LOG_ORG),
    RESSTR(IDS_LOG_ORGUNIT),
    RESSTR(IDS_LOG_LOCALITY),
    RESSTR(IDS_LOG_STATE),
    RESSTR(IDS_LOG_EMAIL),
    RESSTR(IDS_LOG_COUNTRY),
    RESSTR(IDS_LOG_DESCRIPTION),
    RESSTR(IDS_LOG_SHAREDFOLDER),
    RESSTR(IDS_LOG_DBDIR),
    RESSTR(IDS_LOG_DBLOGDIR),
    RESSTR(IDS_LOG_COMPUTER),
    RESSTR(IDS_LOG_REQUESTFILE),
    RESSTR(IDS_LOG_VALIDITY),
    RESSTR(IDS_LOG_CATYPE),
    RESSTR(IDS_LOG_KEYNAME),
    RESSTR(IDS_ERR_NONIA5DNSNAME),
    RESSTR(IDS_WRN_DBSPECIALCHARACTERS),
    RESSTR(IDS_WRN_NONAMECHANGE),
    RESSTR(IDS_WRN_KEYNAMETOOLONG),
    RESSTR(IDS_LOG_QUERYCHANGESELSTATE),
    RESSTR(IDS_PATH_TOO_LONG_DIRECTORY),
    RESSTR(IDS_LOG_BAD_CATYPE),
    RESSTR(IDS_LOG_BAD_OR_MISSING_CANAME),
    RESSTR(IDS_LOG_BAD_VALIDITY_PERIOD_STRING),
    RESSTR(IDS_LOG_CA_MACHINE_REQUIRED),
    RESSTR(IDS_LOG_CA_NAME_REQUIRED),
    RESSTR(IDS_LOG_PING_PARENT_FAIL),
    RESSTR(IDS_LOG_EMPTY_UNATTENDED_ATTRIBUTE),
    RESSTR(IDS_LOG_PATH_CAFILE_BUILD_FAIL),
    RESSTR(IDS_LOG_ENTERPRISE_NO_DS),
    RESSTR(IDS_LOG_BAD_COUNTRY_LENGTH),
    RESSTR(IDS_LOG_NO_CERT),
    RESSTR(IDS_LOG_REUSE_CERT_NO_REUSE_KEY),
    RESSTR(IDS_LOG_REUSE_DB_WITHOUT_REUSE_CERT),
    RESSTR(IDS_LOG_BAD_VALIDITY_PERIOD_COUNT),
    RESSTR(IDS_LOG_REQUEST_FILE_TOO_LONG),
    RESSTR(IDS_LOG_CANAME_TOO_LONG),
    RESSTR(IDS_LOG_PATH_TOO_LONG_CANAME),
    RESSTR(IDS_LOG_BAD_COUNTRY_CODE),
    RESSTR(IDS_LOG_KEY_NOT_FOUND_IN_LIST),
    RESSTR(IDS_LOG_DISABLE_WIZ_PAGE),
    RESSTR(IDS_LOG_WIZ_PAGE_ERROR),
    RESSTR(IDS_LOG_UPGRADE_UNSUPPORTED),
    RESSTR(IDS_LOG_UPGRADE_WIN2000),
    RESSTR(IDS_LOG_UPGRADE_B2B),
    RESSTR(IDS_LARGEFONTSIZE),
    RESSTR(IDS_LARGEFONTNAME),
    RESSTR(IDS_ILOG_SANITIZEDNAME),
    RESSTR(IDS_ILOG_KEYCONTAINERNAME),
    RESSTR(IDS_CAHIER_CERTFILE_FILTER),
    RESSTR(IDS_CAHIER_INSTALL_TITLE),
    RESSTR(IDS_ILOG_MISSING_PROVIDER),
    RESSTR(IDS_ERR_INCOMPLETECHAIN),
    RESSTR(IDS_ERR_INVALIDCHAIN),
    RESSTR(IDS_ERR_RETRIEVE_PENDING),
    RESSTR(IDS_ILOG_GETCANAME),
    RESSTR(IDS_ILOG_SELECTCA),
    RESSTR(IDS_ILOG_SAVECERTANDKEYS),
    RESSTR(IDS_ILOG_RETRIEVECERT),
    RESSTR(IDS_ILOG_FINISHSUSPENDEDSETUP),
    RESSTR(IDS_ERR_NOTCACERT),
    RESSTR(IDS_ILOG_SETUPCOMPLETE),
    RESSTR(IDS_ILOG_RETRIEVEPENDING),
    RESSTR(IDS_ILOG_KEYINDEX),
    RESSTR(IDS_ILOG_LOADOLDCERT),
    RESSTR(IDS_ILOG_CLONECERT),
    RESSTR(IDS_ILOG_BUILDREQUEST),
    RESSTR(IDS_ILOG_RENEWOLDKEY),
    RESSTR(IDS_ILOG_INSTALLCERT),
    RESSTR(IDS_ILOG_RENEWNEWKEY),
    RESSTR(IDS_ILOG_BUILDCERT),
    RESSTR(IDS_ILOG_SAVECHAINANDKEYS),
    RESSTR(IDS_REQUEST_HELPTEXT),
    RESSTR(IDS_ILOG_CREATECDP),
    RESSTR(IDS_ILOG_CREATENTAUTHTRUST),
    RESSTR(IDS_ILOG_CREATEROOTTRUST),
    RESSTR(IDS_ILOG_PUBLISHCA),
    RESSTR(IDS_ILOG_SUBMITREQUEST),
    RESSTR(IDS_ERR_BADCSP),
    RESSTR(IDS_ERR_BAD_CA_CERT_7F),
    RESSTR(IDS_ERR_RENEWEDCERTCAVERSION),
    RESSTR(IDS_ERR_UNTRUSTEDROOT),
    RESSTR(IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE),
    RESSTR(IDS_ERR_CERTCREATECERTIFICATECONTEXT),
    RESSTR(IDS_ILOG_SETSECURITY),
    RESSTR(IDS_ERR_CREATEFILE),
    RESSTR(IDS_ERR_DELETEKEY),
    RESSTR(IDS_ERR_ENCODEKEYATTR),
    RESSTR(IDS_ERR_ENCODETOBESIGNED),
    RESSTR(IDS_ERR_ENV_NOT_SET),
    RESSTR(IDS_ERR_FULL_TOKEN),
    RESSTR(IDS_ERR_GENKEYFAIL),
    RESSTR(IDS_ERR_GETCOMPUTERNAME),
    RESSTR(IDS_ERR_KEYSECURITY),
    RESSTR(IDS_ERR_MYDECODENAME),
    RESSTR(IDS_ERR_NOT_ENTERPRISE_USER),
    RESSTR(IDS_ERR_NOT_MATCH_NAME),
    RESSTR(IDS_ILOG_GENERATEKEYS),
    RESSTR(IDS_ERR_REPEATWIZPREFIX),
    RESSTR(IDS_ERR_REQUEST_DENIED),
    RESSTR(IDS_ERR_REQUEST_ERROR),
    RESSTR(IDS_ERR_REQUEST_INCOMPLETE),
    RESSTR(IDS_ERR_REQUEST_OUTOFBAND),
    RESSTR(IDS_ERR_REQUEST_PENDING),
    RESSTR(IDS_ERR_REQUEST_REVOKED),
    RESSTR(IDS_ERR_SETKEYPROVIDER),
    RESSTR(IDS_ERR_SUBMIT_REQUEST),
    RESSTR(IDS_ERR_SUBMIT_REQUEST_FAIL),
    RESSTR(IDS_CAHIER_INSTALL_MISIINGCERT_TITLE),
    RESSTR(IDS_ERR_WRITEDERTOFILE),
    RESSTR(IDS_ERR_WRITEFILE),
    RESSTR(IDS_ILOG_SETKEYSECURITY),
    RESSTR(IDS_MSG_PARENTCA_CONFIG),
    RESSTR(IDS_MSG_REQUEST_ID),
    RESSTR(IDS_MSG_TITLE),
    RESSTR(IDS_ILOG_SETADMINONLYFOLDERSECURITY),
    RESSTR(IDS_ERR_NO_KEY_ACCESS),
    RESSTR(IDS_CA_PICKER_TITLE),
    RESSTR(IDS_CA_PICKER_PROMPT),
    RESSTR(IDS_CERTTYPE_USER),
    RESSTR(IDS_CERTTYPE_USER_AS),
    RESSTR(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
    RESSTR(IDS_CERTTYPE_EFS),
    RESSTR(IDS_CERTTYPE_ADMIN),
    RESSTR(IDS_CERTTYPE_EFS_RECOVERY),
    RESSTR(IDS_CERTTYPE_CODE_SIGNING),
    RESSTR(IDS_CERTTYPE_CTL_SIGNING),
    RESSTR(IDS_CERTTYPE_MACHINE),
    RESSTR(IDS_CERTTYPE_DC),
    RESSTR(IDS_CERTTYPE_WEBSERVER),
    RESSTR(IDS_CERTTYPE_KDC),
    RESSTR(IDS_CERTTYPE_ROOT_CA),
    RESSTR(IDS_CERTTYPE_SUBORDINATE_CA),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT),
    RESSTR(IDS_CERTTYPE_SMARTCARD_USER),
    RESSTR(IDS_CERTTYPE_USER_SIGNATURE),
    RESSTR(IDS_ILOG_BAD_NUMERICFIELD),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_COUNT),
    RESSTR(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING),
    RESSTR(IDS_CERTTYPE_ROUTER_OFFLINE),
    RESSTR(IDS_REQUEST_FILE_DEFEXT),
    RESSTR(IDS_REQUEST_OPEN_TITLE),
    RESSTR(IDS_REQUEST_FILE_FILTER),
    RESSTR(IDS_WRN_COMPUTERNAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_EMPTY),
    RESSTR(IDS_WRN_CANAME_NOT_MATCH),
    RESSTR(IDS_WRN_PINGCA_FAIL),
    RESSTR(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER),
    RESSTR(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
    RESSTR(IDS_WRN_CALIST_EMPTY),
    RESSTR(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
    RESSTR(IDS_REQUEST_SAVE_TITLE),
    RESSTR(IDS_CERTTYPE_CEP_ENCRYPTION),
    RESSTR(IDS_ILOG_CAPOLICY_BUILD),
    RESSTR(IDS_ILOG_CAPOLICY_ELEMENT),
    RESSTR(IDS_ILOG_CAPOLICY_EXTENSION),
    RESSTR(IDS_ILOG_CAPOLICY_NOKEY),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN),
    RESSTR(IDS_ILOG_CAPOLICY_OPEN_FAILED),
    RESSTR(IDS_ILOG_BEGIN),
    RESSTR(IDS_ILOG_END),
    RESSTR(IDS_ACTRL_CAADMIN),
    RESSTR(IDS_ACTRL_OFFICER),
    RESSTR(IDS_ACTRL_AUDITOR),
    RESSTR(IDS_ACTRL_OPERATOR),
    RESSTR(IDS_ACTRL_CAREAD),
    RESSTR(IDS_ACTRL_ENROLL),
    RESSTR(IDS_ILOG_CAPOLICY_CLOSE),
    RESSTR(IDS_ILOG_MESSAGEBOX),
    RESSTR(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
    RESSTR(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
    RESSTR(IDS_CERTTYPE_CA_EXCHANGE),
    RESSTR(IDS_EMPTY_FRIENDLY_NAME),
    RESSTR(IDS_CERTTYPE_CROSS_CA),
    RESSTR(IDS_CERTTYPE_DC_AUTH),
    RESSTR(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
    RESSTR(IDS_WARN_ENTERPRISE_REQUIREMENTS),
    RESSTR(IDS_WRN_OLD_CA),
    RESSTR(IDS_KRA_DESCRIPTION),
    RESSTR(IDS_EMAIL_REPLICATION_DESCRIPTION),
    RESSTR(IDS_CROSS_CA_DESCRIPTION),
    RESSTR(IDS_CA_DESCRIPTION),
    RESSTR(IDS_MACHINE_DESCRIPTION),
    RESSTR(IDS_END_USER_DESCRIPTION),
    RESSTR(IDS_UNKNOWN_DESCRIPTION),
    RESSTR(IDS_STORENAME_DS_KRA),
    RESSTR(IDS_STORENAME_DS_AIA),
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\websetup.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       websetup.h
//
//--------------------------------------------------------------------------

#ifndef __WEBSETUP_H__
#define __WEBSETUP_H__

//+------------------------------------------------------------------------
//
//  File:	websetup.h
// 
//  Contents:	Header file for CertInit's web setup functions.
//
//  History:	3/19/97	JerryK	Created
//
//-------------------------------------------------------------------------




// Function Prototypes
void StartAndStopW3SVC();

HRESULT 
StartAndStopW3Svc(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND const hwnd,
    IN BOOL const fStopService,
    IN BOOL const fConfirm,
    OUT BOOL     *pfServiceWasRunning);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\usecert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       usecert.cpp
//
//  Contents:   cert store and file operations
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <wincrypt.h>

#include "initcert.h"
#include "cscsp.h"
#include "cspenum.h"
#include "wizpage.h"
#include "usecert.h"

#define __dwFILE__      __dwFILE_OCMSETUP_USECERT_CPP__

typedef struct _EXISTING_CA_IDINFO {
    LPSTR       pszObjId;
    WCHAR     **ppwszIdInfo;
} EXISTING_CA_IDINFO;


/*
EXISTING_CA_IDINFO   g_ExistingCAIdInfo[] = {
            {szOID_COMMON_NAME,              NULL},
            {szOID_ORGANIZATION_NAME,        NULL},
            {szOID_ORGANIZATIONAL_UNIT_NAME, NULL},
            {szOID_LOCALITY_NAME,            NULL},
            {szOID_STATE_OR_PROVINCE_NAME,   NULL},
            {szOID_RSA_emailAddr,            NULL},
            {szOID_COUNTRY_NAME,             NULL},
            {NULL, NULL},
                     };
*/

HRESULT
myMakeExprValidity(
    IN FILETIME const *pft,
    OUT LONG *plDayCount)
{
    HRESULT hr;
    FILETIME ft;
    LONGLONG llDelta;

    *plDayCount = 0;

    // get current time

    GetSystemTimeAsFileTime(&ft);

    llDelta = mySubtractFileTimes(pft, &ft);
    llDelta /= 1000 * 1000 * 10;
    llDelta += 12 * 60 * 60; // half day more to avoid truncation
    llDelta /= 24 * 60 * 60;

    *plDayCount = (LONG) llDelta;
    if (0 > *plDayCount)
    {
        *plDayCount = 0;
    }
    hr = S_OK;

//error:
    return hr;
}

//--------------------------------------------------------------------
// returns true if the CA type is root and the cert is self-signed,
// or the CA type is subordinate and the cert is no self-signed
HRESULT
IsCertSelfSignedForCAType(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCert,
    OUT BOOL * pbOK)
{
    CSASSERT(NULL!=pccCert);
    CSASSERT(NULL!=pServer);
    CSASSERT(NULL!=pbOK);

    HRESULT hr;
    DWORD dwVerificationFlags;
    BOOL bRetVal;

    // See if this cert is self-signed or not.
    // First, we flag what we want to check: "Use the public 
    //   key in the issuer's certificate to verify the signature on 
    //   the subject certificate." 
    // We use the same certificate as issuer and subject
    dwVerificationFlags=CERT_STORE_SIGNATURE_FLAG;
    // perform the checks
    bRetVal=CertVerifySubjectCertificateContext(
        pccCert,
        pccCert, // issuer same as subject
        &dwVerificationFlags);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "CertVerifySubjectCertificateContext");
    }
    // Every check that passed had its flag zeroed. See if our check passed
    if (CERT_STORE_SIGNATURE_FLAG&dwVerificationFlags){
        // This cert is not self-signed.
        if (IsRootCA(pServer->CAType)) {
            // A root CA cert must be self-signed.
            *pbOK=FALSE;
        } else {
            // A subordinate CA cert must not be self-signed.
            *pbOK=TRUE;
        }
    } else {
        // This cert is self-signed.
        if (IsSubordinateCA(pServer->CAType)) {
            // A subordinate CA cert must not be self-signed.
            *pbOK=FALSE;
        } else {
            // A root CA cert must be self-signed.
            *pbOK=TRUE;
        }
    }

    hr=S_OK;

error:
    return hr;
}

//--------------------------------------------------------------------
// find a certificate's hash algorithm in a CSP's list of hash algorithms
HRESULT
FindHashAlgorithm(
    IN CERT_CONTEXT const * pccCert,
    IN CSP_INFO * pCSPInfo,
    OUT CSP_HASH ** ppHash)
{
    CSASSERT(NULL!=pccCert);
    CSASSERT(NULL!=pCSPInfo);
    CSASSERT(NULL!=ppHash);

    HRESULT hr;
    unsigned int nIndex;
    CSP_HASH * phTravel;
    const CRYPT_OID_INFO * pOIDInfo;

    // Initialize out param
    *ppHash=NULL;

    // get the AlgID from the hash algorithm OID
    // (returned pointer must not be freed)
    pOIDInfo=CryptFindOIDInfo(
        CRYPT_OID_INFO_OID_KEY,
        pccCert->pCertInfo->SignatureAlgorithm.pszObjId,
        CRYPT_SIGN_ALG_OID_GROUP_ID
        );
    if (NULL==pOIDInfo) {
        // function is not doc'd to set GetLastError()
        hr=CRYPT_E_NOT_FOUND;
        _JumpError(hr, error, "Signature algorithm not found");
    }

    // find the hash algorithm in the list of hash algorithms the CSP supports
    for (phTravel=pCSPInfo->pHashList; NULL!=phTravel; phTravel=phTravel->next) {
        if (pOIDInfo->Algid==phTravel->idAlg) {
            *ppHash=phTravel;
            break;
        }
    }
    if (NULL==phTravel) {
        hr=CRYPT_E_NOT_FOUND;
        _JumpError(hr, error, "CSP does not support hash algorithm");
    }

    hr=S_OK;

error:
    return hr;
}

/*

HRESULT
HookExistingIdInfoData(
    CASERVERSETUPINFO    *pServer)
{
    HRESULT  hr;
    int      i = 0;

    while (NULL != g_ExistingCAIdInfo[i].pszObjId)
    {
        if (0 == strcmp(szOID_COMMON_NAME,
                        g_ExistingCAIdInfo[i].pszObjId))
        {
            g_ExistingCAIdInfo[i].ppwszIdInfo = &pServer->pwszCACommonName;
        }
        else if (0 == strcmp(szOID_ORGANIZATION_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_ORGANIZATIONAL_UNIT_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_LOCALITY_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_STATE_OR_PROVINCE_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_COUNTRY_NAME,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else if (0 == strcmp(szOID_RSA_emailAddr,
                             g_ExistingCAIdInfo[i].pszObjId))
        {
           // dead
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "unsupported name");
        }

        ++i;
    }

    hr = S_OK;
error:
    return hr;
}
*/

HRESULT
DetermineExistingCAIdInfo(
IN OUT CASERVERSETUPINFO       *pServer,
OPTIONAL IN CERT_CONTEXT const *pUpgradeCert)
{
    CERT_NAME_INFO    *pCertNameInfo = NULL;
    DWORD              cbCertNameInfo;
    WCHAR const       *pwszNameProp;
    WCHAR             *pwszExisting;
    int                i;
    HRESULT            hr = E_FAIL;
    SYSTEMTIME         sysTime;
    FILETIME           fileTime;
    CERT_CONTEXT const *pCert = pServer->pccExistingCert;

    CSASSERT(NULL!=pServer->pccExistingCert ||
             NULL != pUpgradeCert);

    if (NULL == pUpgradeCert)
    {
        myMakeExprValidity(
            &pServer->pccExistingCert->pCertInfo->NotAfter,
            &pServer->lExistingValidity);

        pServer->NotBefore = pServer->pccExistingCert->pCertInfo->NotBefore;
        pServer->NotAfter  = pServer->pccExistingCert->pCertInfo->NotAfter;
    }
   
    if (NULL != pUpgradeCert)
    {
        pCert = pUpgradeCert;
    }

    if (!myDecodeName(X509_ASN_ENCODING,
              X509_UNICODE_NAME,
              pCert->pCertInfo->Subject.pbData,
              pCert->pCertInfo->Subject.cbData,
              CERTLIB_USE_LOCALALLOC,
              &pCertNameInfo,
              &cbCertNameInfo))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myDecodeName");
    }

/*
    // fill a data structure for existing key id info
    hr = HookExistingIdInfoData(pServer);
    _JumpIfError(hr, error, "HookExistingIdInfoData");

    // load names from cert to the the data structure
    i = 0;

    while (NULL != g_ExistingCAIdInfo[i].pszObjId)
    {
        if (S_OK == myGetCertNameProperty(
                                 pCertNameInfo,
                                 g_ExistingCAIdInfo[i].pszObjId,
                                 &pwszNameProp))
        {
            pwszExisting = (WCHAR*)LocalAlloc(LPTR,
                (wcslen(pwszNameProp) + 1) * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pwszExisting);

            // get name
            wcscpy(pwszExisting, pwszNameProp);

            // make sure free old
            if (NULL != *(g_ExistingCAIdInfo[i].ppwszIdInfo))
            {
                LocalFree(*(g_ExistingCAIdInfo[i].ppwszIdInfo));
            }
            *(g_ExistingCAIdInfo[i].ppwszIdInfo) = pwszExisting;
        }
        ++i;
    }
*/
    hr = myGetCertNameProperty(  pCertNameInfo,
                                 szOID_COMMON_NAME,
                                 &pwszNameProp);
    if (hr == S_OK)
    {
        // Common name exists, copy it out
        hr = myDupString(pwszNameProp, &(pServer->pwszCACommonName));
        _JumpIfError(hr, error, "myDupString");
    }

    // now get everything else
    hr = myCertNameToStr(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                &pCert->pCertInfo->Subject,
                CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG | CERT_NAME_STR_REVERSE_FLAG, 
                &pServer->pwszFullCADN);
    _JumpIfError(hr, error, "myCertNameToStr");

    // No need for a DN suffix, the full DN is already in the cert
    
    hr = myDupString(L"", &(pServer->pwszDNSuffix));
    _JumpIfError(hr, error, "myDupString");
 
    hr = S_OK;

error:
    if (NULL != pCertNameInfo)
    {
        LocalFree(pCertNameInfo);
    }
    return hr;
}

//--------------------------------------------------------------------
// find a cert that matches the currently selected CSP and key container name
// returns CRYPT_E_NOT_FOUND if no certificate. Caller MUST free the returned
// context.
// Note: IT IS VERY IMPORTANT that pfx import maintains all the
//   invariants about CSP, key container, hash, cert validity, etc.
//   that the rest of the UI (including this function) maintains.
HRESULT
FindCertificateByKey(
    IN CASERVERSETUPINFO * pServer,
    OUT CERT_CONTEXT const ** ppccCertificateCtx)
{
    CSASSERT(NULL!=pServer);
    CSASSERT(NULL!=ppccCertificateCtx);

    HRESULT hr;
    DWORD dwPublicKeySize;
    BOOL bRetVal;
    DWORD dwVerificationFlags;
    BOOL bSelfSigned;
    CSP_HASH * pHash;
    CERT_CONTEXT const *pccFound = NULL;

    // variables that must be cleaned up
    HCRYPTPROV hProv=NULL;
    CERT_PUBLIC_KEY_INFO * pcpkiKeyInfo=NULL;
    CERT_CONTEXT const * pccCurrentCert=NULL;

    // initialize out param
    *ppccCertificateCtx=NULL;

    // open certificate store if it is not already open
    if (NULL==pServer->hMyStore) {
        pServer->hMyStore=CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            X509_ASN_ENCODING,
            NULL,           // hProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_ENUM_ARCHIVED_FLAG,
            wszMY_CERTSTORE);
        if (NULL==pServer->hMyStore) {
            hr=myHLastError();
            _JumpError(hr, error, "CertOpenStore");
        }
    }

    //
    // Get public key blob from key container
    //   Note: This may fail if key is not 
    //   AT_SIGNATURE, but we will never actually use the key in 
    //   this case anyway so it's ok to not find any certs
    //

    DBGPRINT((
        DBG_SS_CERTOCM,
        "FindCertificateByKey: key=%ws\n",
        pServer->pwszKeyContainerName));

    // first, open the key container
    bRetVal=myCertSrvCryptAcquireContext(
        &hProv,
        pServer->pwszKeyContainerName,
        pServer->pCSPInfo->pwszProvName,
        pServer->pCSPInfo->dwProvType,
        CRYPT_SILENT,   // we should never have to ask anything to get this info
        pServer->pCSPInfo->fMachineKeyset);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    // get the size of the blob
    bRetVal=CryptExportPublicKeyInfo(
        hProv,
        AT_SIGNATURE,
        X509_ASN_ENCODING,
        NULL, //determine size
        &dwPublicKeySize);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo (get data size)");
    }

    // allocate the blob
    pcpkiKeyInfo=(CERT_PUBLIC_KEY_INFO *)LocalAlloc(LMEM_FIXED, dwPublicKeySize);
    _JumpIfOutOfMemory(hr, error, pcpkiKeyInfo);

    // get the public key info blob
    bRetVal=CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            pcpkiKeyInfo,
            &dwPublicKeySize);
    if (FALSE==bRetVal) {
        hr=myHLastError();
        _JumpError(hr, error, "CryptExportPublicKeyInfo (get data)");
    }

    //
    // Find a certificate that has a matching key, has not expired,
    //   and is self-signed or not self-signed depending upon 
    //   the CA type we are trying to install
    //

    while (true) {
        // find the next cert that has this public key
        //   Note: the function will free the previously 
        //   used context when we pass it back
        pccCurrentCert=CertFindCertificateInStore(
            pServer->hMyStore,
            X509_ASN_ENCODING,
            0, // flags
            CERT_FIND_PUBLIC_KEY,
            pcpkiKeyInfo,
            pccCurrentCert);

        // exit the loop when we can find no more matching certs

        if (NULL == pccCurrentCert)
        {
            hr = myHLastError();
            if (NULL != pccFound)
            {
                break;
            }
            _JumpError(hr, error, "CertFindCertificateInStore");
        }

        // check to make sure that the cert has not expired
        // first, we flag what we want to check

        dwVerificationFlags = CERT_STORE_TIME_VALIDITY_FLAG;

        // perform the checks

        bRetVal=CertVerifySubjectCertificateContext(
            pccCurrentCert,
            NULL, // issuer; not needed
            &dwVerificationFlags);
        if (FALSE==bRetVal) {
            _PrintError(myHLastError(), "CertVerifySubjectCertificateContext");
            // this should not fail, but maybe we got a bad cert. Keep looking.
            continue;
        }
        // Every check that passed had its flag zeroed. See if our check passed
        if (CERT_STORE_TIME_VALIDITY_FLAG&dwVerificationFlags){
            // This cert is expired and we can't use it. Keep looking.
            continue;
        }

        // verify to make sure no cert in chain is revoked, but don't kill
	// yourself if can't connect
	// allow untrusted cert if installing a root

        hr = myVerifyCertContext(
		pccCurrentCert,
		CA_VERIFY_FLAGS_IGNORE_OFFLINE |
		    (IsRootCA(pServer->CAType)?
			CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT : 0),
		0,
		NULL,
		HCCE_LOCAL_MACHINE,
		NULL,
		NULL);
        if (S_OK != hr)
        {
            // At least one cert is revoked in chain
            _PrintError(hr, "myVerifyCertContext");
            continue;
        }

        // See if this cert appropriately is self-signed or not.
        // A root CA cert must be self-signed, while
        // a subordinate CA cert must not be self-signed.
        hr=IsCertSelfSignedForCAType(pServer, pccCurrentCert, &bRetVal);
        if (FAILED(hr)) {
            // this should not fail, but maybe we got a bad cert. Keep looking.
            _PrintError(hr, "IsCertSelfSignedForCAType");
            continue;
        }
        if (FALSE==bRetVal) {
            // this cert is not appropriate for this CA type
            _PrintError(S_FALSE, "bad CA Type");
            continue;
        }

        // If we got here, the cert we have is a good one.
        // If we already found a good cert and this one expires later,
        // toss the old one and save this one.

        if (NULL != pccFound)
        {
            if (0 > CompareFileTime(
                         &pccCurrentCert->pCertInfo->NotAfter,
                         &pccFound->pCertInfo->NotAfter))
            {
                continue;               // old one is newer -- keep it
            }
            CertFreeCertificateContext(pccFound);
            pccFound = NULL;
        }
        pccFound = CertDuplicateCertificateContext(pccCurrentCert);
        if (NULL == pccFound)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CertDuplicateCertificateContext");
        }

    } // <- End certificate finding loop

    CSASSERT(NULL != pccFound);
    *ppccCertificateCtx = pccFound;
    pccFound = NULL;
    hr = S_OK;

error:
    if (NULL!=hProv) {
        CryptReleaseContext(hProv, 0);
    }
    if (NULL!=pcpkiKeyInfo) {
        LocalFree(pcpkiKeyInfo);
    }
    if (NULL != pccFound)
    {
        CertFreeCertificateContext(pccFound);
    }
    if (NULL!=pccCurrentCert) {
        CertFreeCertificateContext(pccCurrentCert);
    }
    if (S_OK!=hr && CRYPT_E_NOT_FOUND!=hr) {
        _PrintError(hr, "Ignoring error in FindCertificateByKey, returning CRYPT_E_NOT_FOUND")
        hr=CRYPT_E_NOT_FOUND;
    }

    return hr;
}

//--------------------------------------------------------------------
// Set which existing certificate we want to use
HRESULT
SetExistingCertToUse(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCertCtx)
{
    CSASSERT(NULL!=pServer);
    CSASSERT(NULL!=pccCertCtx);

    HRESULT hr;
    CSP_HASH * pHash;

    // to use an existing cert, we must use an existing key
    CSASSERT(NULL!=pServer->pwszKeyContainerName);

    // find the hash algorithm that matches this cert, and use it if possible
    // otherwise, stick with what we are currently using.
    hr=FindHashAlgorithm(pccCertCtx, pServer->pCSPInfo, &pHash);
    if (S_OK==hr) {
        pServer->pHashInfo = pHash;
    }

    hr = myGetNameId(pccCertCtx, &pServer->dwCertNameId);
    _PrintIfError(hr, "myGetNameId");

    if (MAXDWORD == pServer->dwCertNameId)
    {
        pServer->dwCertNameId = 0;
    }

    ClearExistingCertToUse(pServer);
    pServer->pccExistingCert=pccCertCtx;


    // We could assume that everything will work, but it doesn't take long to check
    //pServer->fValidatedHashAndKey=TRUE;

    hr=S_OK;

//error:
    return hr;
}

//--------------------------------------------------------------------
// stop using an existing certificate
void
ClearExistingCertToUse(
    IN CASERVERSETUPINFO * pServer)
{
    CSASSERT(NULL!=pServer);

    if (NULL!=pServer->pccExistingCert) {
        CertFreeCertificateContext(pServer->pccExistingCert);
        pServer->pccExistingCert=NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\usecert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       usecert.h
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:	usecert.h
// 
//  Contents:	Header file for certificate store and file operations
//
//  History:	10/97	xtan	Created
//
//-------------------------------------------------------------------------


#ifndef __USECERT_H__
#define __USECERT_H__

HRESULT
DetermineExistingCAIdInfo(
    IN OUT CASERVERSETUPINFO       *pServer,
    OPTIONAL IN CERT_CONTEXT const *pUpgradeCert);

HRESULT
FindCertificateByKey(
    IN CASERVERSETUPINFO * pServer,
    OUT CERT_CONTEXT const ** ppccCertificateCtx);

HRESULT
SetExistingCertToUse(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCertCtx);

void
ClearExistingCertToUse(
    IN CASERVERSETUPINFO * pServer);

HRESULT
FindHashAlgorithm(
    IN CERT_CONTEXT const * pccCert,
    IN CSP_INFO * pCSPInfo,
    OUT CSP_HASH ** ppHash);

HRESULT
IsCertSelfSignedForCAType(
    IN CASERVERSETUPINFO * pServer,
    IN CERT_CONTEXT const * pccCert,
    OUT BOOL * pbOK);

#endif // #ifndef __USECERT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\unattend.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       unattend.cpp
//
//  Contents:   handling unattended attributes
//
//  History:    8/97      XTan
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// includes
#include <assert.h>

#include "cscsp.h"
#include "certmsg.h"
#include "usecert.h"
#include "dssetup.h"
#include "wizpage.h"

//defines

#define __dwFILE__      __dwFILE_OCMSETUP_UNATTEND_CPP__

#define wszCOMPONENTS              L"Components"

#define wszAttrCAMACHINE           L"camachine" //L"CAMachine"
#define wszAttrCANAME              L"caname" //L"CAName"
#define wszAttrPARENTCAMACHINE     L"parentcamachine" //L"ParentCAMachine"
#define wszAttrPARENTCANAME        L"parentcaname" //L"ParentCAName"

#define wszAttrCATYPE              L"catype" //L"CAType"
#define wszAttrNAME                L"name" //L"Name"
#define wszAttrCADISTINGUISHEDNAME L"cadistinguishedname" //L"CADistinguishedName"
#define wszAttrORGANIZATION        L"organization" //L"Organization" // dead
#define wszAttrORGANIZATIONUNIT    L"organizationalunit" //L"OrganizationalUnit" // dead
#define wszAttrLOCALITY            L"locality" //L"Locality" // dead
#define wszAttrSTATE               L"state" //L"State" // dead
#define wszAttrCOUNTRY             L"country" //L"Country" // dead
#define wszAttrDESCRIPTION         L"description" //L"Description" // dead
#define wszAttrEMAIL               L"email" //L"Email" // dead
#define wszAttrVALIDITYPERIODSTRING L"validityperiod" //L"ValidityPeriod"
#define wszAttrVALIDITYPERIODCOUNT L"validityperiodunits" //L"ValidityPeriodUnits"
#define wszAttrSHAREDFOLDER        L"sharedfolder" //L"SharedFolder"
#define wszAttrREQUESTFILE         L"requestfile" //L"RequestFile"
#define wszAttrCSPPROVIDER         L"cspprovider" //L"CSPProvider"
#define wszAttrHASHALGORITHM       L"hashalgorithm" //L"HashAlgorithm"
#define wszAttrKEYLENGTH           L"keylength" //L"KeyLength"
#define wszAttrEXISTINGKEY         L"existingkey" //L"ExistingKey"
#define wszAttrUSEEXISTINGCERT     L"useexistingcert" //L"UseExistingCert"
#define wszAttrPRESERVEDB          L"preservedb" //L"PreserveDB"
#define wszAttrDBDIR               L"dbdir" //L"DBDir"
#define wszAttrLOGDIR              L"logdir" //L"LogDir"
#define wszAttrINTERACTIVESERVICE  L"interactive" //L"Interactive"

#define wszValueENTERPRISEROOT           L"enterpriseroot"
#define wszValueENTERPRISESUBORDINATE    L"enterprisesubordinate"
#define wszValueSTANDALONEROOT           L"standaloneroot"
#define wszValueSTANDALONESUBORDINATE    L"standalonesubordinate"
#define wszValueYES                      L"yes"
#define wszValueNO                       L"no"
#define wszValueSHA1                     L"sha1"
#define wszValueMD2                      L"md2"
#define wszValueMD4                      L"md4"
#define wszValueMD5                      L"md5"

//typedefs

// globals

UNATTENDPARM aUnattendParmClient[] =
{
    { wszAttrCAMACHINE,    NULL/*pClient->pwszWebCAMachine*/ },
    { wszAttrCANAME,       NULL/*pClient->pwszWebCAName*/ },
// add more code in HookUnattendedClientAttributes if you add
    { NULL,                NULL/*end*/ },
};


UNATTENDPARM aUnattendParmServer[] =
{
    { wszAttrCATYPE,             NULL/*pServer->pwszCAType*/ },
    { wszAttrNAME,               NULL/*pServer->pwszCACommonName*/ },
    { wszAttrCADISTINGUISHEDNAME,NULL/*pServer->pwszCADistinguishedName*/ },

/*  dead params
    { wszAttrORGANIZATION,       NULL },
    { wszAttrORGANIZATIONUNIT,   NULL },
    { wszAttrLOCALITY,           NULL },
    { wszAttrSTATE,              NULL },
    { wszAttrCOUNTRY,            NULL },
    { wszAttrDESCRIPTION,        NULL },
    { wszAttrEMAIL,              NULL },*/

    { wszAttrVALIDITYPERIODCOUNT,  NULL/*pServer->pwszValidityPeriodCount*/ },
    { wszAttrVALIDITYPERIODSTRING, NULL/*pServer->pwszValidityPeriodString*/ },
    { wszAttrSHAREDFOLDER,       NULL/*pServer->pwszSharedFolder*/ },
    { wszAttrREQUESTFILE,        NULL/*pServer->pwszRequestFile*/ },
    { wszAttrCSPPROVIDER,        NULL/*pServer->pwszProvName*/ },
    { wszAttrHASHALGORITHM,      NULL/*pServer->pwszHashAlgorithm*/ },
    { wszAttrKEYLENGTH,          NULL/*pServer->pwszKeyLength*/ },
    { wszAttrEXISTINGKEY,        NULL/*pServer->pwszKeyContainerName*/ },
    { wszAttrUSEEXISTINGCERT,    NULL/*pServer->pwszUseExistingCert*/ },
    { wszAttrPRESERVEDB,         NULL/*pServer->pwszPreserveDB*/ },
    { wszAttrPARENTCAMACHINE,    NULL/*pServer->pwszParentCAMachine*/ },
    { wszAttrPARENTCANAME,       NULL/*pServer->pwszParentCAName*/ },
    { wszAttrDBDIR,              NULL/*pServer->pwszDBDirectory*/ },
    { wszAttrLOGDIR,             NULL/*pServer->pwszLogDirectory*/ },
    { wszAttrINTERACTIVESERVICE, NULL/*pServer->pwszInteractiveService*/ },
// add more code in HookUnattendedServerAttributes if you add
    { NULL,                      NULL/*end*/ },
};


HRESULT
HookUnattendedClientAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pClientComp)
{
    HRESULT  hr;
    DWORD    i;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    for (i = 0; NULL != pClientComp->aUnattendParm[i].pwszName; ++i)
    {
        if (0 == lstrcmpi( wszAttrCAMACHINE,
                         pClientComp->aUnattendParm[i].pwszName) )
        {
            pClientComp->aUnattendParm[i].ppwszValue =
                &pClient->pwszWebCAMachine;
        }
        else if (0 == lstrcmpi( wszAttrCANAME,
                              pClientComp->aUnattendParm[i].pwszName) )
        {
            pClientComp->aUnattendParm[i].ppwszValue =
                &pClient->pwszWebCAName;
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error, incorrect attr.");
        }
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
HookUnattendedServerAttributes(
    IN OUT PER_COMPONENT_DATA *pComp,
    IN OUT const SUBCOMP      *pServerComp)
{
    HRESULT  hr;
    DWORD    i;
    CASERVERSETUPINFO *pServer = (pComp->CA).pServer;

    for (i = 0; NULL != pServerComp->aUnattendParm[i].pwszName; ++i)
    {
        if (0 == lstrcmpi( wszAttrCATYPE,
                         pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszCAType;
        }
        else if (0 == lstrcmpi( wszAttrNAME,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszCACommonName;
        }
        else if (0 == lstrcmpi( wszAttrCADISTINGUISHEDNAME,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszFullCADN;
        }
        else if (0 == lstrcmpi( wszAttrORGANIZATION,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            // dead
        }
        else if (0 == lstrcmpi( wszAttrORGANIZATIONUNIT,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            // dead
        }
        else if (0 == lstrcmpi( wszAttrLOCALITY,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            // dead
        }
        else if (0 == lstrcmpi( wszAttrSTATE,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            // dead
        }
        else if (0 == lstrcmpi( wszAttrCOUNTRY,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            // dead
        }
        else if (0 == lstrcmpi( wszAttrDESCRIPTION,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            // dead
        }
        else if (0 == lstrcmpi( wszAttrEMAIL,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            // dead
        }
        else if (0 == lstrcmpi( wszAttrVALIDITYPERIODCOUNT,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszValidityPeriodCount;
        }
        else if (0 == lstrcmpi( wszAttrVALIDITYPERIODSTRING,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszValidityPeriodString;
        }
        else if (0 == lstrcmpi( wszAttrSHAREDFOLDER,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszSharedFolder;
        }
        else if (0 == lstrcmpi( wszAttrREQUESTFILE,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszRequestFile;
        }
        else if (0 == lstrcmpi( wszAttrCSPPROVIDER,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pCSPInfo->pwszProvName;
        }
        else if (0 == lstrcmpi( wszAttrHASHALGORITHM,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszHashAlgorithm;
        }
        else if (0 == lstrcmpi( wszAttrKEYLENGTH,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszKeyLength;
        }
        else if (0 == lstrcmpi( wszAttrEXISTINGKEY,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszKeyContainerName;
        }
        else if (0 == lstrcmpi( wszAttrUSEEXISTINGCERT,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszUseExistingCert;
        }
        else if (0 == lstrcmpi( wszAttrPRESERVEDB,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszPreserveDB;
        }
        else if (0 == lstrcmpi( wszAttrPARENTCAMACHINE,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszParentCAMachine;
        }
        else if (0 == lstrcmpi( wszAttrPARENTCANAME,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszParentCAName;
        }
        else if (0 == lstrcmpi( wszAttrDBDIR,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszDBDirectory;
        }
        else if (0 == lstrcmpi( wszAttrLOGDIR,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszLogDirectory;
        }
        else if (0 == lstrcmpi( wszAttrINTERACTIVESERVICE,
                              pServerComp->aUnattendParm[i].pwszName) )
        {
            pServerComp->aUnattendParm[i].ppwszValue =
                &pServer->pwszInteractiveService;
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error, incorrect attr.");
        }
    }

    hr = S_OK;
error:
    return hr;
}


HRESULT
certocmRetrieveUnattendedText(
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    SUBCOMP *psc;
    WCHAR *pwsz = NULL;
    WCHAR   *pwszLoad;
    HANDLE hUnattendedFile = (*pComp->HelperRoutines.GetInfHandle)(
                                INFINDEX_UNATTENDED,
                                pComp->HelperRoutines.OcManagerContext);

    psc = TranslateSubComponent(pwszComponent, pwszSubComponent);
    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error, unsupported component");
    }

    psc->fInstallUnattend = FALSE;

    hr = certocmReadInfString(
                        hUnattendedFile,
                        pComp->pwszUnattendedFile,
                        wszCOMPONENTS,
                        pwszSubComponent,
                        &pwsz);
    CSILOG(hr, IDS_LOG_UNATTENDED_ATTRIBUTE, pwszSubComponent, pwsz, NULL);
    _JumpIfError(hr, error, "certocmReadInfString");

    if (0 == lstrcmpi(pwsz, L"DEFAULT"))
    {
        psc->fInstallUnattend = psc->fDefaultInstallUnattend;
    }
    else
    {
        psc->fInstallUnattend = 0 == lstrcmpi(pwsz, L"ON");
    }

    if (psc->fInstallUnattend)
    {
        DWORD i;

        for (i = 0; NULL != psc->aUnattendParm[i].pwszName; i++)
        {
            pwszLoad = NULL;
            hr = certocmReadInfString(
                                hUnattendedFile,
                                pComp->pwszUnattendedFile,
                                psc->pwszSubComponent,
                                psc->aUnattendParm[i].pwszName,
                                &pwszLoad);
            if (S_OK != hr || NULL == pwszLoad)
            {
                // allow missing attributes
                _PrintErrorStr(
                        hr,
                        "Ignoring certocmReadInfString",
                        psc->aUnattendParm[i].pwszName);
                continue;
            }

            if (0x0 == pwszLoad[0])
            {
                // if a attribute is given as empty, put it in log
                CSILOG(
                    hr,
                    IDS_LOG_EMPTY_UNATTENDED_ATTRIBUTE,
                    psc->aUnattendParm[i].pwszName,
                    NULL,
                    NULL);

                // continue to take default
                LocalFree(pwszLoad);
                continue;
            }

            if (NULL != psc->aUnattendParm[i].ppwszValue &&
                NULL != *(psc->aUnattendParm[i].ppwszValue) )
            {
                // free old or default attributes
                LocalFree(*(psc->aUnattendParm[i].ppwszValue));
            }
            // get new
            *(psc->aUnattendParm[i].ppwszValue) = pwszLoad;

            CSILOG(
                S_OK,
                IDS_LOG_UNATTENDED_ATTRIBUTE,
                psc->aUnattendParm[i].pwszName,
                pwszLoad,
                NULL);
        }
    }

    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;
}

HRESULT BuildDistinguishedName(
    LPCWSTR pcwszCN,
    LPWSTR *ppwszDN)
{
    HRESULT hr = S_OK;
    LPWSTR pwszDN = NULL;
    LPWSTR pwszMachineDN = NULL;
    LPCWSTR pcwszCNEqual = L"CN=";
    DWORD dwLen = 0;

    CSASSERT(pcwszCN);
    CSASSERT(ppwszDN);

    myGetComputerObjectName(NameFullyQualifiedDN, &pwszMachineDN);
    //ignore failure

    dwLen = wcslen(pcwszCNEqual)+wcslen(pcwszCN)+1;
    if(pwszMachineDN)
    {
        dwLen += wcslen(pwszMachineDN)+1; // add 1 for comma
    }
    dwLen *= sizeof(WCHAR);

    pwszDN = (LPWSTR)LocalAlloc(LMEM_FIXED, dwLen);
    _JumpIfAllocFailed(pwszDN, error);

    wcscpy(pwszDN, pcwszCNEqual);
    wcscat(pwszDN, pcwszCN);
    
    if (pwszMachineDN)
    {
        _wcsupr(pwszMachineDN);

        WCHAR *pwszFirstDCComponent = wcsstr(pwszMachineDN, L"DC=");
        if (pwszFirstDCComponent != NULL)
        {
           wcscat(pwszDN, L",");
           wcscat(pwszDN, pwszFirstDCComponent);
        }
    }

    *ppwszDN = pwszDN;

error:

    LOCAL_FREE(pwszMachineDN);
    return hr;
}

HRESULT
PrepareServerUnattendedAttributes(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp,
    SUBCOMP            *psc)
{
    HRESULT            hr;
    CASERVERSETUPINFO *pServer = (pComp->CA).pServer;
    BOOL fUpdateAlg = FALSE;
    BOOL fCoInit = FALSE;
    BOOL fNotContinue = FALSE;
    BOOL fValidDigitString;

    WCHAR *pwszConfig = NULL;

    // determine CA type
    if (NULL != pServer->pwszCAType)
    {
        // case insensitive
        if (0 == lstrcmpi(wszValueENTERPRISEROOT, pServer->pwszCAType))
        {
            pServer->CAType = ENUM_ENTERPRISE_ROOTCA;
        }
        else if (0 == lstrcmpi(wszValueENTERPRISESUBORDINATE, pServer->pwszCAType))
        {
            pServer->CAType = ENUM_ENTERPRISE_SUBCA;
        }
        else if (0 == lstrcmpi(wszValueSTANDALONEROOT, pServer->pwszCAType))
        {
            pServer->CAType = ENUM_STANDALONE_ROOTCA;
        }
        else if (0 == lstrcmpi(wszValueSTANDALONESUBORDINATE, pServer->pwszCAType))
        {
            pServer->CAType = ENUM_STANDALONE_SUBCA;
        }
        else
        {
            // unknown ca type in unattended file
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_BAD_CATYPE, pServer->pwszCAType, NULL, NULL);
            _JumpError(hr, error, "unknown ca type in unattended file");
        }
    }

    // determine if ca type and DS combination is legal
    if (IsEnterpriseCA(pServer->CAType))
    {
        // enterprise cas require DS
        if (!pServer->fUseDS)
        {
            // no ds, let it failure
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_ENTERPRISE_NO_DS, NULL, NULL, NULL);
            _JumpError(hr, error, "No DS is available for enterprise CA. Either select standalone or install DS first");
        }
    }

    // build full CA DN 

    if(EmptyString(pServer->pwszCACommonName))
    {
        hr = E_INVALIDARG;
        CSILOG(hr, IDS_LOG_CA_NAME_REQUIRED, NULL, NULL, NULL);
        _JumpError(hr, error, "CA name not specified");
    }

    if(!EmptyString(pServer->pwszFullCADN))
    {
        LPWSTR pwszTempFullName;
        hr = BuildFullDN(
            pServer->pwszCACommonName,
            pServer->pwszFullCADN,
            &pwszTempFullName);
        _JumpIfError(hr, error, "BuildFullDN");

        LocalFree(pServer->pwszFullCADN);
        pServer->pwszFullCADN = pwszTempFullName;
    }
    else
    {
        hr = BuildDistinguishedName(
            pServer->pwszCACommonName,
            &pServer->pwszFullCADN);
        _JumpIfError(hr, error, "BuildDistinguishedName");
    }

    // determine advance attributes
    hr = csiGetProviderTypeFromProviderName(
                    pServer->pCSPInfo->pwszProvName,
                    &pServer->pCSPInfo->dwProvType);
    _JumpIfError(hr, error, "csiGetProviderTypeFromProviderName");

    if (NULL != pServer->pwszHashAlgorithm)
    {
        // case insensitive
        if (0 == lstrcmpi(wszValueSHA1, pServer->pwszHashAlgorithm) )
        {
            pServer->pHashInfo->idAlg = CALG_SHA1;
        }
        else if (0 == lstrcmpi(wszValueMD2, pServer->pwszHashAlgorithm) )
        {
            pServer->pHashInfo->idAlg = CALG_MD2;
        }
        else if (0 == lstrcmpi(wszValueMD4, pServer->pwszHashAlgorithm) )
        {
            pServer->pHashInfo->idAlg = CALG_MD4;
        }
        else if (0 == lstrcmpi(wszValueMD5, pServer->pwszHashAlgorithm) )
        {
            pServer->pHashInfo->idAlg = CALG_MD5;
        }
        else
        {
            // undone, support oid ???

            // otherwise convert to calg id
            pServer->pHashInfo->idAlg = myWtoI(
					    pServer->pwszHashAlgorithm,
					    &fValidDigitString);
        }
    }
    // update algorithm oid anyway (for any changes from csp name, type, hash)
    if (NULL != pServer->pszAlgId)
    {
        // free old
        LocalFree(pServer->pszAlgId);
    }
    hr = myGetSigningOID(
		     NULL,	// hProv
		     pServer->pCSPInfo->pwszProvName,
		     pServer->pCSPInfo->dwProvType,
		     pServer->pHashInfo->idAlg,
		     &pServer->pszAlgId);
    _JumpIfError(hr, error, "myGetSigningOID");

    if (NULL != pServer->pwszKeyLength)
    {
        pServer->dwKeyLength = myWtoI(
				    pServer->pwszKeyLength,
				    &fValidDigitString);
    }

    // Import from PFX file?
    if(NULL != pServer->pwszPFXFile)
    {
        hr = ImportPFXAndUpdateCSPInfo(
                hwnd,
                pComp);
        _JumpIfError(hr, error, "ImportPFXAndUpdateCSPInfo");
    }

    if (NULL != pServer->pwszKeyContainerName)
    {
        if (NULL != pServer->pwszKeyLength)
        {
            CSILOG(hr, IDS_LOG_IGNORE_KEYLENGTH, NULL, NULL, NULL);
            _PrintError(0, "Defined key length is ignored because of reusing key");
        }
        // to revert key container name to common name
        if (NULL != pServer->pwszCACommonName)
        {
            LocalFree(pServer->pwszCACommonName);
            pServer->pwszCACommonName = NULL;
        }
        hr = myRevertSanitizeName(pServer->pwszKeyContainerName,
                 &pServer->pwszCACommonName);
        _JumpIfError(hr, error, "myRevertSanitizeName");
    }

    // set preserveDB flag
    pServer->fPreserveDB = FALSE;
    if (NULL != pServer->pwszPreserveDB)
    {
        // case insensitive
        if (0 == lstrcmpi(wszValueYES, pServer->pwszPreserveDB))
        {
            pServer->fPreserveDB = TRUE;
        }
    }

    // set fInteractiveService flag
    pServer->fInteractiveService = FALSE;
    if (NULL != pServer->pwszInteractiveService)
    {
        // case insensitive
        if (0 == lstrcmpi(wszValueYES, pServer->pwszInteractiveService))
        {
            pServer->fInteractiveService = TRUE;
        }
    }

    // ca idinfo attributes

    // Reuse cert?
    if (NULL!=pServer->pwszUseExistingCert &&
        0==lstrcmpi(wszValueYES, pServer->pwszUseExistingCert))
    {
        //
        // User wants to reuse an existing cert
        //

        // must have a key container name to reuse a cert
        if (NULL==pServer->pwszKeyContainerName) {
            hr=E_INVALIDARG;
            CSILOG(hr, IDS_LOG_REUSE_CERT_NO_REUSE_KEY, NULL, NULL, NULL);
            _JumpError(hr, error, "cannot reuse ca cert without reuse key");
        }

        // see if a matching certificate exists
        CERT_CONTEXT const * pccExistingCert;
        hr = FindCertificateByKey(pServer, &pccExistingCert);
        if (S_OK != hr)
        {
            CSILOG(hr, IDS_LOG_NO_CERT, NULL, NULL, NULL);
            _JumpError(hr, error, "FindCertificateByKey");
        }

        // use the matching cert
        hr = SetExistingCertToUse(pServer, pccExistingCert);
        _JumpIfError(hr, error, "SetExistingCertToUse");

    } else {
        //
        // User does not want to reuse an existing cert
        //   Get the information that we would have pulled from the cert
        //

        // must reuse an existing cert to preserve the DB
        if (pServer->fPreserveDB){
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_REUSE_DB_WITHOUT_REUSE_CERT, NULL, NULL, NULL);
            _JumpError(hr, error, "cannot preserve DB if don't reuse both key and ca cert");
        }

        // determine extended idinfo attributes

        // validity period
        DWORD       dwValidityPeriodCount;
        ENUM_PERIOD enumValidityPeriod = ENUM_PERIOD_INVALID;
        BOOL        fSwap;
        if (NULL != pServer->pwszValidityPeriodCount ||
            NULL != pServer->pwszValidityPeriodString)
        {
            hr = myInfGetValidityPeriod(
                                 NULL,		// hInf
				 pServer->pwszValidityPeriodCount,
                                 pServer->pwszValidityPeriodString,
                                 &dwValidityPeriodCount,
                                 &enumValidityPeriod,
                                 &fSwap);
            _JumpIfError(hr, error, "myGetValidityPeriod");

            if (ENUM_PERIOD_INVALID != enumValidityPeriod)
            {
                pServer->enumValidityPeriod = enumValidityPeriod;
            }
            if (0 != dwValidityPeriodCount)
            {
                pServer->dwValidityPeriodCount = dwValidityPeriodCount;
            }
        }

	    if (!IsValidPeriod(pServer))
        {
                hr = E_INVALIDARG;
                CSILOG(
                    hr,
                    IDS_LOG_BAD_VALIDITY_PERIOD_COUNT,
                    pServer->pwszValidityPeriodCount,
                    NULL,
                    &pServer->dwValidityPeriodCount);
                _JumpError(hr, error, "validity period count");
        }

        pServer->NotAfter = pServer->NotBefore;
        myMakeExprDateTime(
			&pServer->NotAfter,
			pServer->dwValidityPeriodCount,
			pServer->enumValidityPeriod);

        //if swap, swap pointer before validation
        if (fSwap)
        {
            WCHAR *pwszTemp = pServer->pwszValidityPeriodCount;
            pServer->pwszValidityPeriodCount = pServer->pwszValidityPeriodString;
            pServer->pwszValidityPeriodString = pwszTemp;
        }

        //the following WizardPageValidation requires
        //pServer->pwszValidityPeriodCount so load from count before validation
        if (NULL == pServer->pwszValidityPeriodCount)
        {
            WCHAR wszCount[10]; //should be enough
            wsprintf(wszCount, L"%d", pServer->dwValidityPeriodCount);
            pServer->pwszValidityPeriodCount = (WCHAR*)LocalAlloc(LMEM_FIXED,
                        (wcslen(wszCount) + 1) * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pServer->pwszValidityPeriodCount);
            wcscpy(pServer->pwszValidityPeriodCount, wszCount);
        }

        // hook with g_aIdPageString
        hr = HookIdInfoPageStrings(
                 NULL,  // hDlg
                 g_aIdPageString,
                 pServer);
        _JumpIfError(hr, error, "HookIdInfoPageStrings");

        hr = WizardPageValidation(
                 pComp->hInstance,
                 pComp->fUnattended,
                 NULL,
                 g_aIdPageString);
        _JumpIfError(hr, error, "WizardPageValidation");

        // make sure no invalid rdn characters
        if (IsAnyInvalidRDN(NULL, pComp))
        {
            hr = E_INVALIDARG;
            CSILOG(
                hr,
                IDS_LOG_BAD_OR_MISSING_CANAME,
                pServer->pwszCACommonName,
                NULL,
                NULL);
            _JumpError(hr, error, "Invalid RDN characters");
        }

    } // <- End if reuse/not-reuse cert

    // determine CA name
    if (NULL != pServer->pwszSanitizedName)
    {
        // free old
        LocalFree(pServer->pwszSanitizedName);
        pServer->pwszSanitizedName = NULL;
    }
    // derive ca name from common name
    hr = mySanitizeName(
             pServer->pwszCACommonName,
             &(pServer->pwszSanitizedName) );
    _JumpIfError(hr, error, "mySanitizeName");

    if (MAX_PATH <= wcslen(pServer->pwszSanitizedName) + cwcSUFFIXMAX)
    {
        hr = CO_E_PATHTOOLONG;
        CSILOG(
            hr,
            IDS_LOG_CANAME_TOO_LONG,
            pServer->pwszSanitizedName,
            NULL,
            NULL);
        _JumpErrorStr(hr, error, "CA Name", pServer->pwszSanitizedName);
    }

    // store attributes
    hr = StorePageValidation(NULL, pComp, &fNotContinue);
    _JumpIfError(hr, error, "StorePageValidation");

    if (fNotContinue)
    {
        hr = S_FALSE;
        _JumpError(hr, error, "StorePageValidation failed");
    }

    // ca cert file name
    if (NULL != pServer->pwszCACertFile)
    {
        // free old one
        LocalFree(pServer->pwszCACertFile);
    }
    hr = csiBuildCACertFileName(
                 pComp->hInstance,
                 hwnd,
                 pComp->fUnattended,
                 pServer->pwszSharedFolder,
                 pServer->pwszSanitizedName,
                 L".crt",
                 0, // CANAMEIDTOICERT(pServer->dwCertNameId),
                 &pServer->pwszCACertFile);
    if (S_OK != hr)
    {
        CSILOG(
            hr,
            IDS_LOG_PATH_CAFILE_BUILD_FAIL,
            pServer->pwszSharedFolder, //likely by invalid shared folder path
            NULL,
            NULL);
        _JumpError(hr, error, "csiBuildFileName");
    }

    // validate path length
    if (MAX_PATH <= wcslen(pServer->pwszCACertFile) + cwcSUFFIXMAX)
    {
            hr = CO_E_PATHTOOLONG;
            CSILOG(
                hr,
                IDS_LOG_PATH_TOO_LONG_CANAME,
                pServer->pwszCACertFile,
                NULL,
                NULL);
            _JumpErrorStr(hr, error, "csiBuildFileName", pServer->pwszCACertFile);
    }

    // request attributes
    // if subordinate ca, determine online or request file
    if (IsSubordinateCA(pServer->CAType))
    {
        // default
        pServer->fSaveRequestAsFile = TRUE;
        if (NULL != pServer->pwszParentCAMachine)
        {
            // online case
            pServer->fSaveRequestAsFile = FALSE;

            hr = CoInitialize(NULL);
            if (S_OK != hr && S_FALSE != hr)
            {
                _JumpError(hr, error, "CoInitialize");
            }
            fCoInit = TRUE;

            if (NULL != pServer->pwszParentCAName)
            {
                // answer file provides both machine and ca names
                hr = myFormConfigString(
                             pServer->pwszParentCAMachine,
                             pServer->pwszParentCAName,
                             &pwszConfig);
                _JumpIfError(hr, error, "myFormConfigString");

                // answer file has complete config string, try to ping it
                hr = myPingCertSrv(pwszConfig, NULL, NULL, NULL, NULL, NULL, NULL);
                if (S_OK != hr)
                {
                    // can't finish without pingable ca
                    CSILOG(
                            hr,
                            IDS_LOG_PING_PARENT_FAIL,
                            pwszConfig,
                            NULL,
                            NULL);
                    _JumpErrorStr(hr, error, "myPingCertSrv", pwszConfig);
                }
            }
            else
            {
                WCHAR *pwszzCAList = NULL;
                // answer file only has machine name, try to get ca name
                hr = myPingCertSrv(
                             pServer->pwszParentCAMachine,
                             NULL,
                             &pwszzCAList,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
                if (S_OK != hr)
                {
                    // can't finish without pingable ca
                    CSILOG(
                            hr,
                            IDS_LOG_PING_PARENT_FAIL,
                            pServer->pwszParentCAMachine,
                            NULL,
                            NULL);
                    _JumpErrorStr(hr, error, "myPingCertSrv",
                                  pServer->pwszParentCAMachine);
                }
                // pick the first one as the choice
                pServer->pwszParentCAName = pwszzCAList;
            }
        }

        if (NULL == pServer->pwszRequestFile)
        {
            // in any case, construct request file name if not defined
            hr = BuildRequestFileName(
                         pServer->pwszCACertFile,
                         &pServer->pwszRequestFile);
            _JumpIfError(hr, error, "BuildRequestFileName");
            // make sure in limit
            if (MAX_PATH <= wcslen(pServer->pwszRequestFile) + cwcSUFFIXMAX)
            {
                hr = CO_E_PATHTOOLONG;
                            CSILOG(
                            hr,
                            IDS_LOG_REQUEST_FILE_TOO_LONG,
                            pServer->pwszRequestFile,
                            NULL,
                            NULL);
                _JumpErrorStr(hr, error, "Request File", pServer->pwszRequestFile);
            }
        }
    }

    // other attributes

    if(pServer->fUseDS)
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_DS;
    }
    else
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_NODS;
    }

    hr = S_OK;
error:
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (NULL!=pwszConfig) {
        LocalFree(pwszConfig);
    }

    CSILOG(hr, IDS_LOG_SERVER_UNATTENDED_ATTRIBUTES, NULL, NULL, NULL);
    return hr;
}


HRESULT
PrepareClientUnattendedAttributes(
    PER_COMPONENT_DATA *pComp,
    SUBCOMP            *psc)
{
    HRESULT hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    WCHAR *pwszConfig = NULL;
    CAINFO *pCAInfo = NULL;
    BOOL fCoInit = FALSE;
    WCHAR * pwszDnsName = NULL;

    if ((IS_CLIENT_INSTALL & pComp->dwInstallStatus) &&
        !(IS_SERVER_INSTALL & pComp->dwInstallStatus))
    {
        // no extra setting and converting
        if (NULL == pClient->pwszWebCAMachine)
        {
            hr = E_INVALIDARG;
            CSILOG(hr, IDS_LOG_CA_MACHINE_REQUIRED, NULL, NULL, NULL);
            _JumpError(hr, error, "ca machine name is required");
        }

        hr = CoInitialize(NULL);
        if (S_OK != hr && S_FALSE != hr)
        {
            _JumpError(hr, error, "CoInitialize");
        }
        fCoInit = TRUE;

        if (NULL == pClient->pwszWebCAName)
        {
                WCHAR *pwszzCAList = NULL;
                // answer file only has machine name, try to get ca name
                hr = myPingCertSrv(
                             pClient->pwszWebCAMachine,
                             NULL,
                             &pwszzCAList,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
                if (S_OK != hr)
                {
                    // can't finish without pingable ca
                    CSILOG(
                            hr,
                            IDS_LOG_PING_PARENT_FAIL,
                            pClient->pwszWebCAMachine,
                            NULL,
                            NULL);
                    _JumpErrorStr(hr, error, "myPingCertSrv",
                                  pClient->pwszWebCAMachine);
                }
                // pick the first one as the choice
                pClient->pwszWebCAName = pwszzCAList;
        }

        hr = mySanitizeName(pClient->pwszWebCAName, &pClient->pwszSanitizedWebCAName);
        _JumpIfError(hr, error, "mySanitizeName");

        // build the config string so we can ping the parent CA
        hr = myFormConfigString(
                     pClient->pwszWebCAMachine,
                     pClient->pwszWebCAName,
                     &pwszConfig);
        _JumpIfError(hr, error, "myFormConfigString");

        // ping the CA to retrieve the CA type and DNS name.
        hr = myPingCertSrv(pwszConfig, NULL, NULL, NULL, &pCAInfo, NULL, &pwszDnsName);
        if (S_OK != hr)
        {
            // can't finish without pingable ca
            CSILOG(
                    hr,
                    IDS_LOG_PING_PARENT_FAIL,
                    pwszConfig,
                    NULL,
                    NULL);
            _JumpErrorStr(hr, error, "myPingCertSrv", pwszConfig);
        }
        pClient->WebCAType = pCAInfo->CAType;

        // use the FQDN if available
        if (NULL!=pwszDnsName) {
            LocalFree(pClient->pwszWebCAMachine);
            pClient->pwszWebCAMachine=pwszDnsName;
        }
    }

    hr = S_OK;
error:
    if (NULL!=pwszConfig)
    {
        LocalFree(pwszConfig);
    }

    if (NULL != pCAInfo)
    {
        LocalFree(pCAInfo);
    }

    if (fCoInit)
    {
        CoUninitialize();
    }

    CSILOG(hr, IDS_LOG_CLIENT_UNATTENDED_ATTRIBUTES, NULL, NULL, NULL);
    return hr;
}


HRESULT
PrepareUnattendedAttributes(
    IN HWND         hwnd,
    IN WCHAR const *pwszComponent,
    IN WCHAR const *pwszSubComponent,
    IN PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    SUBCOMP *psc = TranslateSubComponent(pwszComponent, pwszSubComponent);

    if (NULL == psc)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal error, unsupported component");
    }

    switch (psc->cscSubComponent)
    {
        case cscServer:
            hr = PrepareServerUnattendedAttributes(hwnd, pComp, psc);
            _JumpIfError(hr, error, "PrepareServerUnattendedAttributes");
        break;
        case cscClient:
            hr = PrepareClientUnattendedAttributes(pComp, psc);
            _JumpIfError(hr, error, "PrepareClientUnattendedAttributes");
        break;
        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Internal error, unsupported component");
    }

    hr = S_OK;
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\wizpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       wizpage.h
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:       wizpage.h
// 
//  Contents:   Header file for OCM wizard support functions.
//
//  History:    04/17/97        JerryK  Created
//
//-------------------------------------------------------------------------


#ifndef __WIZPAGE_H__
#define __WIZPAGE_H__

typedef struct tagWizPageResEntry
{
    int         idResource;
    DLGPROC     fnDlgProc;
    int         idTitle;
    int         idSubTitle;
} WIZPAGERESENTRY, *PWIZPAGERESENTRY;

typedef struct _PAGESTRINGS
{
    int     idControl;
    int     idLog;
    int     idMsgBoxNullString;
    DWORD   idMsgBoxLenString;
    int     cchMax;     // max num of characters allowed
    WCHAR **ppwszString;
} PAGESTRINGS;

int FileExists(LPTSTR pszTestFileName);
int DirExists(LPTSTR pszTestFileName);

#define DE_DIREXISTS            1               // Return codes for
#define DE_NAMEINUSE            2               // DirExists

#define STRBUF_SIZE             2048

#define UB_DESCRIPTION          1024      // This is not an X.500 limit
#define UB_VALIDITY             4
#define UB_VALIDITY_ANY         1024     // no limit actually

extern PAGESTRINGS g_aIdPageString[];

BOOL BrowseForDirectory(
                HWND hwndParent,
                LPCTSTR pszInitialDir,
                LPTSTR pszBuf,
                int cchBuf,
                LPCTSTR pszDialogTitle,
                BOOL bRemoveTrailingBackslash);

DWORD
SeekFileNameIndex(WCHAR const *pwszFullPath);

BOOL
IsAnyInvalidRDN(
    OPTIONAL HWND       hDlg,
    PER_COMPONENT_DATA *pComp);

HRESULT
SetKeyContainerName(
        CASERVERSETUPINFO *pServer,
        const WCHAR * pwszKeyContainerName);

HRESULT
DetermineDefaultHash(CASERVERSETUPINFO *pServer);

void
ClearKeyContainerName(CASERVERSETUPINFO *pServer);

HRESULT
BuildRequestFileName(
    IN WCHAR const *pwszCACertFile,
    OUT WCHAR     **ppwszRequestFile);

HRESULT
HookIdInfoPageStrings(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer);

HRESULT
WizardPageValidation(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hDlg,
    IN PAGESTRINGS *pPageStrings);

HRESULT
StorePageValidation(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    BOOL              *pfDontNext);

HRESULT 
ExtractCommonName(
    LPCWSTR pcwszDN, 
    LPWSTR* ppwszCN);

INT_PTR
WizIdInfoPageDlgProc(
    HWND hDlg, 
    UINT iMsg, 
    WPARAM wParam, 
    LPARAM lParam);

HRESULT
WizPageSetTextLimits(
    HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings);

BOOL
IsEverythingMatched(CASERVERSETUPINFO *pServer);

HRESULT BuildFullDN(
    OPTIONAL LPCWSTR pcwszCAName,
    OPTIONAL LPCWSTR pcwszDNSuffix,
    LPWSTR* pwszFullDN);

HRESULT InitNameFields(CASERVERSETUPINFO *pServer);

#endif // #ifndef __WIZPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\ocmsetup\wizpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       wizpage.cpp
//
//  Contents:   Wizard page construction and presentation functions to be used
//              by the OCM driver code.
//
//  History:    04/16/97    JerryK    Fixed/Changed/Unmangled
//                0/8/97      XTan    major structure change
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// ** System Includes **
#include <prsht.h>
#include <commdlg.h>
#include <sddl.h>

// ** Application Includes **
#include "cryptui.h"
#include "csdisp.h"
#include "csprop.h"
#include "cspenum.h"
#include "usecert.h"
#include "wizpage.h"

#include "cscsp.h"
#include "clibres.h"
#include "certmsg.h"
#include "websetup.h"
#include "dssetup.h"
#include "setupids.h"
#include "tfc.h"

//defines

#define __dwFILE__      __dwFILE_OCMSETUP_WIZPAGE_CPP__

#define dwWIZDISABLE    -2
#define dwWIZBACK       -1
#define dwWIZACTIVE     0
#define dwWIZNEXT       1

#define C_CSPHASNOKEYMINMAX  -1
#define MAX_KEYLENGTHEDIT     128
#define MAX_KEYLENGTHDIGIT    5

#define wszOLDCASTOREPREFIX L"CA_"

#define _ReturnIfWizError(hr) \
    { \
        if (S_OK != (hr)) \
        { \
            CSILOG((hr), IDS_LOG_WIZ_PAGE_ERROR, NULL, NULL, NULL); \
            _PrintError(hr, "CertSrv Wizard error"); \
            return TRUE; \
        } \
    }

#define _GetCompDataOrReturnIfError(pComp, hDlg) \
           (PER_COMPONENT_DATA*)GetWindowLongPtr((hDlg), DWLP_USER); \
           if (NULL == (pComp) || S_OK != (pComp)->hrContinue) \
           { \
                return TRUE; \
           }

#define _GetCompDataOrReturn(pComp, hDlg) \
           (PER_COMPONENT_DATA*)GetWindowLongPtr((hDlg), DWLP_USER); \
           if (NULL == (pComp)) \
           { \
                return TRUE; \
           }

#define _DisableWizDisplayIfError(pComp, hDlg) \
    if (S_OK != (pComp)->hrContinue) \
    { \
        CSILOG((pComp)->hrContinue, IDS_LOG_DISABLE_WIZ_PAGE, NULL, NULL, NULL); \
        SetWindowLongPtr((hDlg), DWLP_MSGRESULT, -1); \
    }

//--------------------------------------------------------------------
struct FAKEPROGRESSINFO {
    HANDLE hStopEvent;
    CRITICAL_SECTION csTimeSync;
    BOOL fCSInit;
    DWORD dwSecsRemaining;
    HWND hwndProgBar;
};

struct KEYGENPROGRESSINFO {
    HWND hDlg;                      // wizard page window
    PER_COMPONENT_DATA * pComp;     // setup data
};


KEYGENPROGRESSINFO  g_KeyGenInfo = {
    NULL,    //hDlg
    NULL,    //pComp
    };
BOOL g_fAllowUnicodeStrEncoding = FALSE;

// ** Prototypes/Forward Declarations **
LRESULT CALLBACK
IdInfoNameEditFilterHook(HWND, UINT, WPARAM, LPARAM);

__inline VOID
SetEditFocusAndSelect(
    IN HWND  hwnd,
    IN DWORD indexStart,
    IN DWORD indexEnd)
{
    SetFocus(hwnd);
    SendMessage(hwnd, EM_SETSEL, indexStart, indexEnd);
}


// fix for 160324 - NT4->Whistler upgrade: 
// cannot reinstall CA w/ same cert as instructions tell us to do
//
// Upgrade NT4->Whistler is not supported but old CA key and cert can be reused
// But NT4 used to install CA certs in a separate store (CA_MACHINENAME) so we
// need to move the cert to root store so it can be validated.
HRESULT CopyNT4CACertToRootStore(CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    WCHAR          wszOldCAStore[MAX_PATH];
    HCERTSTORE     hOldStore = NULL;
    HCERTSTORE     hRootStore = NULL;
    CERT_RDN_ATTR  rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE,};
    CERT_RDN       rdn = { 1, &rdnAttr };
    DWORD          cCA = 0;
    CERT_CONTEXT const *pCACert;
    CERT_CONTEXT const *pCACertKeep = NULL; // needn't free
    DWORD          dwFlags;
    ENUM_CATYPES CATypeDummy;
    CERT_CONTEXT const **ppCACertKeep = NULL;
    CRYPT_KEY_PROV_INFO  keyProvInfo;
    DWORD                IndexCA;
    DWORD               *pIndex = NULL;
    DWORD i = 0;

    ZeroMemory(&keyProvInfo, sizeof(keyProvInfo));

    // form old ca store name
    // !!! NT4 uses different sanitize, how do we build it correctly?
    wcscpy(wszOldCAStore, wszOLDCASTOREPREFIX);
    wcscat(wszOldCAStore, pServer->pwszSanitizedName);

    // open old CA store
    hOldStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            X509_ASN_ENCODING,
            NULL,           // hProv
            CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_READONLY_FLAG |
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            wszOldCAStore);
    if (NULL == hOldStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // find CA cert, old ca common name always same as ca name
    rdnAttr.Value.pbData = (BYTE *) pServer->pwszCACommonName;
    rdnAttr.Value.cbData = 0;
    pCACert = NULL;
    do
    {
        pCACert = CertFindCertificateInStore(
                                hOldStore,
                                X509_ASN_ENCODING,
                                CERT_UNICODE_IS_RDN_ATTRS_FLAG |
                                    CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG,
                                CERT_FIND_SUBJECT_ATTR,
                                &rdn,
                                pCACert);
        if (NULL != pCACert)
        {
            // find one
            if (NULL == ppCACertKeep)
            {
                ppCACertKeep = (CERT_CONTEXT const **)LocalAlloc(LMEM_FIXED,
                                  (cCA + 1) * sizeof(CERT_CONTEXT const *));
                _JumpIfOutOfMemory(hr, error, ppCACertKeep);
            }
            else
            {
                CERT_CONTEXT const ** ppTemp;
                ppTemp = (CERT_CONTEXT const **)LocalReAlloc(
                                  ppCACertKeep,
                                  (cCA + 1) * sizeof(CERT_CONTEXT const *),
                                  LMEM_MOVEABLE);
                _JumpIfOutOfMemory(hr, error, ppTemp);
                ppCACertKeep = ppTemp;
               
            }
            // keep current
            ppCACertKeep[cCA] = CertDuplicateCertificateContext(pCACert);
            if (NULL == ppCACertKeep[cCA])
            {
                hr = myHLastError();
                _JumpError(hr, error, "CertDuplicateCertificate");
            }
            ++cCA;
        }
    } while (NULL != pCACert);

    if (1 > cCA)
    {
        // no ca cert
        hr = E_INVALIDARG;
        _JumpError(hr, error, "no ca cert");
    }

    // assume 1st one
    pCACertKeep = ppCACertKeep[0];

    if (1 < cCA)
    {
        DWORD  cCA2 = cCA;
        BOOL   fMatch;

        // have multi ca certs with the same cn
        // because sp4 doesn't reg ca serial # so need to decide which one
        // once the correct one is found, reg its serial #

        // build an index
        pIndex = (DWORD*)LocalAlloc(LMEM_FIXED, cCA * sizeof(DWORD));
        _JumpIfOutOfMemory(hr, error, pIndex);
        i = 0;
        for (pIndex[i] = i; i < cCA; ++i);

        // try to compare with public key

        // in case ca cert doesn't have kpi which is the case for v10
        // so try base rsa
        hr = csiFillKeyProvInfo(
                    pServer->pwszSanitizedName,
                    pServer->pCSPInfo->pwszProvName,
                    pServer->pCSPInfo->dwProvType,
                    TRUE,                       // always machine keyset
                    &keyProvInfo);
        if (S_OK == hr)
        {

            cCA2 = 0;
            for (i = 0; i < cCA; ++i)
            {
                hr = myVerifyPublicKey(
				ppCACertKeep[i],
				FALSE,
				&keyProvInfo,
				NULL,
				&fMatch);
                if (S_OK != hr)
                {
                    continue;
                }
                if (fMatch)
                {
                    // found one match with current public key from container
                    pIndex[cCA2] = i;
                    ++cCA2;
                }
            }
        }

        // compare all ca certs and pick one has most recent NotAfter
        pCACertKeep = ppCACertKeep[pIndex[0]];
        for (i = 1; i < cCA2; ++i)
        {
            if (0 < CompareFileTime(
                         &ppCACertKeep[pIndex[i]]->pCertInfo->NotAfter,
                         &pCACertKeep->pCertInfo->NotAfter))
            {
                // update
                pCACertKeep = ppCACertKeep[pIndex[i]];
            }
        }
    }

    // if get here, must find ca cert
    CSASSERT(NULL != pCACertKeep);

    // add cert to root store
    hRootStore = CertOpenStore(
                        CERT_STORE_PROV_SYSTEM_W,
                        X509_ASN_ENCODING,
                        NULL,           // hProv
                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                        wszROOT_CERTSTORE);
    if (NULL == hRootStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    if(!CertAddCertificateContextToStore(
            hRootStore,
            pCACertKeep,
            CERT_STORE_ADD_NEW,
            NULL))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddCertificateContextToStore");
    }
  
error:
    csiFreeKeyProvInfo(&keyProvInfo);
    for (i = 0; i < cCA; ++i)
    {
        CertFreeCertificateContext(ppCACertKeep[i]);
    }
    if (NULL != hOldStore)
    {
        CertCloseStore(hOldStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hRootStore)
    {
        CertCloseStore(hRootStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return hr;
}


//--------------------------------------------------------------------
// Clear the key container name to indicate that we must generate a new key.
void
ClearKeyContainerName(CASERVERSETUPINFO *pServer)
{
    if (NULL!=pServer->pwszKeyContainerName) {
        // Delete the key container if this is a new one
        if (pServer->fDeletableNewKey) {

            // Delete the key container. Ignore any errors.
            HCRYPTPROV hProv=NULL;
            myCertSrvCryptAcquireContext(
                    &hProv,
                    pServer->pwszKeyContainerName,
                    pServer->pCSPInfo->pwszProvName,
                    pServer->pCSPInfo->dwProvType,
                    CRYPT_DELETEKEYSET,
                    pServer->pCSPInfo->fMachineKeyset);
            if (NULL!=hProv) {
                CryptReleaseContext(hProv, 0);
            }
            pServer->fDeletableNewKey=FALSE;
        }

        // Clear the key container name, to indicate that we must generate a new key.
        LocalFree(pServer->pwszKeyContainerName);
        LocalFree(pServer->pwszDesanitizedKeyContainerName);
        pServer->pwszKeyContainerName=NULL;
        pServer->pwszDesanitizedKeyContainerName=NULL;

        // if we were using an existing cert, we are not anymore
        ClearExistingCertToUse(pServer);

    } else {

        // if there was no key, there couldn't be a existing cert.
        CSASSERT(NULL==pServer->pccExistingCert);

        // key container name is already clear
    }
}

//--------------------------------------------------------------------
// Set both the real key container name and the display key container name
HRESULT
SetKeyContainerName(
    CASERVERSETUPINFO *pServer,
    const WCHAR * pwszKeyContainerName)
{
    HRESULT hr;

    // get rid of any previous names
    ClearKeyContainerName(pServer);

    // set the real key container name
    pServer->pwszKeyContainerName = (WCHAR *) LocalAlloc(
			LMEM_FIXED,
			sizeof(WCHAR) * (wcslen(pwszKeyContainerName) + 1));
    _JumpIfOutOfMemory(hr, error, pServer->pwszKeyContainerName);

    wcscpy(pServer->pwszKeyContainerName, pwszKeyContainerName);

    // set the display key container name
    hr = myRevertSanitizeName(
			pServer->pwszKeyContainerName,
			&pServer->pwszDesanitizedKeyContainerName);
    _JumpIfError(hr, error, "myRevertSanitizeName");

    // Must validate the key again when the selected key changes
    pServer->fValidatedHashAndKey = FALSE;

    CSILOG(
	hr,
	IDS_ILOG_KEYCONTAINERNAME,
	pServer->pwszKeyContainerName,
	pServer->pwszDesanitizedKeyContainerName,
	NULL);

error:
    return hr;
}

HRESULT
UpdateDomainAndUserName(
    IN HWND hwnd,
    IN OUT PER_COMPONENT_DATA *pComp);





BOOL
CertConfirmCancel(
    HWND                hwnd,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;

    CSASSERT(NULL != pComp);

    if (!(*pComp->HelperRoutines.ConfirmCancelRoutine)(hwnd))
    {
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        return TRUE;
    }
    hr = CancelCertsrvInstallation(hwnd, pComp);
    _PrintIfError(hr, "CancelCertsrvInstallation");

    return FALSE;
}

HRESULT
StartWizardPageEditControls(
    IN HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings)
{
    HRESULT hr;

    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        SendMessage(
            GetDlgItem(hDlg, pPageStrings->idControl),
            WM_SETTEXT,
            0,
            (LPARAM) *pPageStrings->ppwszString);
    }

    hr = S_OK;
//error:
    return hr;
}


HRESULT
FinishWizardPageEditControls(
    IN HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings)
{
    HRESULT hr;
    
    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        WCHAR *pwszString = NULL;

        hr = myUIGetWindowText(
                        GetDlgItem(hDlg, pPageStrings->idControl),
                        &pwszString);
        _JumpIfError(hr, error, "myUIGetWindowText");

        if (NULL != *pPageStrings->ppwszString)
        {
            // free old one
            LocalFree(*pPageStrings->ppwszString);
            *pPageStrings->ppwszString = NULL;
        }
        *pPageStrings->ppwszString = pwszString;
        CSILOG(S_OK, pPageStrings->idLog, pwszString, NULL, NULL);
    }

    hr = S_OK;
error:
    return hr;
}


//+------------------------------------------------------------------------
//  Function:   WizPageSetTextLimits
//
//  Synopsis:   Sets text input limits for the text controls of a dlg page.
//-------------------------------------------------------------------------

HRESULT
WizPageSetTextLimits(
    HWND hDlg,
    IN OUT PAGESTRINGS *pPageStrings)
{
    HRESULT hr;

    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        SendDlgItemMessage(
                hDlg,
                pPageStrings->idControl,
                EM_SETLIMITTEXT,
                (WPARAM) pPageStrings->cchMax,
                (LPARAM) 0);
    }

    hr = S_OK;
//error:
    return hr;
}


// check optional or mac length in edit field
// if any invalid, focus on the edit field, select all
HRESULT
ValidateTextField(
    HINSTANCE hInstance,
    BOOL fUnattended,
    HWND hDlg,
    LPTSTR pszTestString,
    DWORD nUBValue,
    int nMsgBoxNullStringErrID,
    int nMsgBoxLenStringErrID,
    int nControlID)
{
    HRESULT  hr = E_INVALIDARG;
    HWND hwndCtrl = NULL;
    BOOL fIsEmpty;

    fIsEmpty = (NULL == pszTestString) || (L'\0' == pszTestString[0]);

    if (fIsEmpty)
    {
        if (0 != nMsgBoxNullStringErrID) // non optional
        {
            // edit field can't be empty

            CertWarningMessageBox(
                        hInstance,
                        fUnattended,
                        hDlg,
                        nMsgBoxNullStringErrID,
                        0,
                        NULL);
            if (!fUnattended)
            {
                hwndCtrl = GetDlgItem(hDlg, nControlID);  // Get offending ctrl
            }
            goto error;
        }
        goto done;
    }

    // the following may not be necessary because edit field set to max limit
    if (wcslen(pszTestString) > nUBValue)        // Make sure it's not too long
    {
        CertWarningMessageBox(
                hInstance,
                fUnattended,
                hDlg,
                nMsgBoxLenStringErrID,
                0,
                NULL);
        if (!fUnattended)
        {
            hwndCtrl = GetDlgItem(hDlg, nControlID);
        }
        goto error;
    }

done:
    hr = S_OK;
error:
    if (!fUnattended && NULL != hwndCtrl)
    {
        SetEditFocusAndSelect(hwndCtrl, 0, -1);
    }
    return hr;
}

HRESULT
WizardPageValidation(
    IN HINSTANCE hInstance,
    IN BOOL fUnattended,
    IN HWND hDlg,
    IN PAGESTRINGS *pPageStrings)
{
    HRESULT  hr;

    for ( ; NULL != pPageStrings->ppwszString; pPageStrings++)
    {
        hr = ValidateTextField(
                        hInstance,
                        fUnattended,
                        hDlg,
                        *pPageStrings->ppwszString,
                        pPageStrings->cchMax,
                        pPageStrings->idMsgBoxNullString,
                        pPageStrings->idMsgBoxLenString,
                        pPageStrings->idControl);
        _JumpIfError(hr, error, "invalid edit field");
    }

    hr = S_OK;
error:
    return hr;
}





#define KEYGEN_GENERATE_KEY     60 // estimated seconds to gen key
#define KEYGEN_PROTECT_KEY      60 // estimated seconds to acl key
#define KEYGEN_TEST_HASH        2 // estimated seconds to acl key


//--------------------------------------------------------------------
// Fake progress by incrementing a progress bar every second

DWORD WINAPI
KeyGenFakeProgressThread(
    LPVOID lpParameter)
{
    FAKEPROGRESSINFO * pFakeProgressInfo=(FAKEPROGRESSINFO *)lpParameter;

    // Wait for the stop signal for 1 second.
    while (WAIT_TIMEOUT==WaitForSingleObject(pFakeProgressInfo->hStopEvent, 1000)) {

        // See if we can send another tick to the progress bar
        if(pFakeProgressInfo->fCSInit)
        {
            EnterCriticalSection(&pFakeProgressInfo->csTimeSync);
            if (pFakeProgressInfo->dwSecsRemaining>0) {

                // move one step (one second)
                SendMessage(pFakeProgressInfo->hwndProgBar, PBM_DELTAPOS, 1, 0);
                pFakeProgressInfo->dwSecsRemaining--;
            }
            LeaveCriticalSection(&pFakeProgressInfo->csTimeSync);
        }
    }

    // We were signaled, so stop.
    return 0; // return value ignored
}


//--------------------------------------------------------------------
// Generate a new key and test the hash algorithm

DWORD WINAPI
GenerateKeyThread(
    LPVOID lpParameter)
{
    HRESULT hr = S_OK;
    WCHAR * pwszMsg;
    FAKEPROGRESSINFO fpi;
    KEYGENPROGRESSINFO * pKeyGenInfo=(KEYGENPROGRESSINFO *)lpParameter;
    PER_COMPONENT_DATA * pComp=pKeyGenInfo->pComp;
    CASERVERSETUPINFO * pServer=pComp->CA.pServer;
    HWND hwndProgBar=GetDlgItem(pKeyGenInfo->hDlg, IDC_KEYGEN_PROGRESS);
    HWND hwndText=GetDlgItem(pKeyGenInfo->hDlg, IDC_KEYGEN_PROGRESS_TEXT);
    int iErrMsg=0; // error msg id
    const WCHAR * pwszErrMsgData = L"";

    // variables that must be cleaned up

    fpi.hStopEvent=NULL;
    HANDLE hFakeProgressThread=NULL;
    HCRYPTPROV hProv=NULL;
    fpi.fCSInit = FALSE;
    __try
    {
        InitializeCriticalSection(&fpi.csTimeSync);
        fpi.fCSInit = TRUE;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    // STEP 0:
    // initialize the fake-progress thread

    // set up the structure for the fake-progress thread
    fpi.hStopEvent=CreateEvent(
        NULL,   // security
        FALSE,  // manual reset? 
        FALSE,  // signaled?
        NULL);  // name
    if (NULL==fpi.hStopEvent) {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }
    fpi.hwndProgBar=hwndProgBar;
    fpi.dwSecsRemaining=0; // Initially, the thread has no work to do.

    // start the fake-progress thread
    DWORD dwThreadID; // ignored
    hFakeProgressThread=CreateThread(
        NULL,                       // security
        0,                          // stack
        KeyGenFakeProgressThread,
        (void *)&fpi,
        0,                          // flags
        &dwThreadID);
    if (NULL==hFakeProgressThread) {
        hr = myHLastError();
        _JumpError(hr, error, "CreateThread");
    }

    if (NULL==pServer->pwszKeyContainerName) {
        // STEP 1:
        // Generate a key

        // set the status
        hr = myLoadRCString(pComp->hInstance, IDS_KEYGEN_GENERATING, &pwszMsg);
        _JumpIfError(hr, error, "myLoadRCString");

        SetWindowText(hwndText, pwszMsg);
        LocalFree(pwszMsg);
        SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)0, 0);

        if(fpi.fCSInit)
        {
            EnterCriticalSection(&fpi.csTimeSync);
            fpi.dwSecsRemaining = KEYGEN_GENERATE_KEY;
            LeaveCriticalSection(&fpi.csTimeSync);
        }

        // generate key
        hr = csiGenerateKeysOnly(
                        pServer->pwszSanitizedName,
                        pServer->pCSPInfo->pwszProvName,
                        pServer->pCSPInfo->dwProvType,
                        pServer->pCSPInfo->fMachineKeyset,
                        pServer->dwKeyLength,
                        pComp->fUnattended,
                        &hProv,
                        &iErrMsg);
        if (S_OK != hr)
        {
            pwszErrMsgData=pServer->pwszSanitizedName;
            pServer->fKeyGenFailed = TRUE;
            _JumpError(hr, error, "csiGenerateKeysOnly");
        }
        pServer->fKeyGenFailed = FALSE;

        // now set this as the existing key
        SetKeyContainerName(pServer, pServer->pwszSanitizedName);
        pServer->fDeletableNewKey=TRUE;

        // STEP 2:
        // Set the ACLs

        // set the status
        hr = myLoadRCString(pComp->hInstance, IDS_KEYGEN_PROTECTING, &pwszMsg);
        _JumpIfError(hr, error, "myLoadRCString");

        SetWindowText(hwndText, pwszMsg);
        LocalFree(pwszMsg);
        if(fpi.fCSInit)
        {
            EnterCriticalSection(&fpi.csTimeSync);
            SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)KEYGEN_GENERATE_KEY, 0);
            fpi.dwSecsRemaining=KEYGEN_PROTECT_KEY;
            LeaveCriticalSection(&fpi.csTimeSync);
        }

        // set the ACLs
        hr = csiSetKeyContainerSecurity(hProv);
        if (S_OK!=hr) {
            iErrMsg=IDS_ERR_KEYSECURITY;
            pwszErrMsgData=pServer->pwszKeyContainerName;
            _JumpError(hr, error, "csiSetKeyContainerSecurity");
        }

    } // <- end if (NULL==pServer->pwszKeyContainerName)

    if (FALSE==pServer->fValidatedHashAndKey) {

        // STEP 3:
        // Test the hash algorithm and key set

        // set the status
        hr = myLoadRCString(pComp->hInstance, IDS_KEYGEN_TESTINGHASHANDKEY, &pwszMsg);
        _JumpIfError(hr, error, "myLoadRCString");
        SetWindowText(hwndText, pwszMsg);
        LocalFree(pwszMsg);
        if(fpi.fCSInit)
        {
            EnterCriticalSection(&fpi.csTimeSync);
            SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)KEYGEN_GENERATE_KEY+KEYGEN_PROTECT_KEY, 0);
            fpi.dwSecsRemaining=KEYGEN_TEST_HASH;
            LeaveCriticalSection(&fpi.csTimeSync);
        }

        // test the hash and keyset
        hr = myValidateHashForSigning(
                            pServer->pwszKeyContainerName,
                            pServer->pCSPInfo->pwszProvName,
                            pServer->pCSPInfo->dwProvType,
                            pServer->pCSPInfo->fMachineKeyset,
                            NULL,
                            pServer->pHashInfo->idAlg);
        if (S_OK!=hr) {
            if (NTE_BAD_KEY_STATE==hr ||   //all the errors with KEY in them
                NTE_NO_KEY==hr ||
                NTE_BAD_PUBLIC_KEY==hr ||
                NTE_BAD_KEYSET==hr ||
                NTE_KEYSET_NOT_DEF==hr ||  
                NTE_KEYSET_ENTRY_BAD==hr ||
                NTE_BAD_KEYSET_PARAM==hr) {
                // Bad keyset (eg, not AT_SIGNATURE) - force user to pick another
                iErrMsg=IDS_KEY_INVALID;
                pwszErrMsgData=pServer->pwszKeyContainerName;
            } else {
                // Bad hash algorithm - force user to pick another
                iErrMsg=IDS_ERR_INVALIDHASH;
                pwszErrMsgData=pServer->pHashInfo->pwszName;
            }
           _JumpError(hr, error, "myValidateHashForSigning");
        }
        
        // mark this hash as validated
        pServer->fValidatedHashAndKey=TRUE;
    }

    // STEP 3:
    // Go to the next page

    // set the status, so the user sees the bar go all the way.
    if(fpi.fCSInit)
    {
        EnterCriticalSection(&fpi.csTimeSync);
        SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)KEYGEN_GENERATE_KEY+KEYGEN_PROTECT_KEY+KEYGEN_TEST_HASH, 0);
        fpi.dwSecsRemaining=0;
        LeaveCriticalSection(&fpi.csTimeSync);
    }

error:

    // clean up after the false-progress thread
    if (NULL!=hFakeProgressThread) {
        CSASSERT(NULL!=fpi.hStopEvent);
        // tell the progress thread to stop
        if (FALSE==SetEvent(fpi.hStopEvent)) {
            _PrintError(myHLastError(), "SetEvent");
        } else {
            // wait for it to stop
            WaitForSingleObject(hFakeProgressThread, INFINITE);
        }
        CloseHandle(hFakeProgressThread);
    }
    
    if(fpi.fCSInit)
    {
        DeleteCriticalSection(&fpi.csTimeSync);
    }
    
    if (NULL!=fpi.hStopEvent) {
        CloseHandle(fpi.hStopEvent);
    }

    if (NULL!=hProv) {
        CryptReleaseContext(hProv, 0);
    }

    // show an error message if we need to
    if (0!=iErrMsg) {
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            pKeyGenInfo->hDlg,
            iErrMsg,
            hr,
            pwszErrMsgData);
    }

    pServer->LastWiz=ENUM_WIZ_KEYGEN;
    if (S_OK==hr) {
        // go to next page 
        PropSheet_PressButton(GetParent(pKeyGenInfo->hDlg), PSBTN_NEXT);
    } else {
        // go back
        PropSheet_PressButton(GetParent(pKeyGenInfo->hDlg), PSBTN_BACK);
    }

    return 0; // return value ignored
}


//--------------------------------------------------------------------
// Start the KeyGen wizard page

HRESULT
HandleKeyGenWizActive(
    HWND    hDlg,
    PER_COMPONENT_DATA *pComp,
    KEYGENPROGRESSINFO *pKeyGenInfo)
{
    HRESULT hr = S_OK;

    // Suppress this wizard page if
    // we are going backwards, or
    // we've already seen an error, or
    // we are not installing the server,
    // or the key exists and the hash has been checked.

    if (ENUM_WIZ_STORE == pComp->CA.pServer->LastWiz ||
        !(IS_SERVER_INSTALL & pComp->dwInstallStatus) ||
        (NULL != pComp->CA.pServer->pwszKeyContainerName &&
         pComp->CA.pServer->fValidatedHashAndKey)) {

        // skip/disable page
        CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
    }
    else
    {
        // set progress bar parameters: range, step, and position
        // set them now so the user will never see a full bar if this is the second visit.

        HWND hwndProgBar=GetDlgItem(hDlg, IDC_KEYGEN_PROGRESS);
        SendMessage(hwndProgBar, PBM_SETRANGE, 0,
            MAKELPARAM(0, KEYGEN_GENERATE_KEY+KEYGEN_PROTECT_KEY+KEYGEN_TEST_HASH));
        SendMessage(hwndProgBar, PBM_SETSTEP, (WPARAM)1, 0);
        SendMessage(hwndProgBar, PBM_SETPOS, (WPARAM)0, 0);

         // init info for keygen thread
        pKeyGenInfo->hDlg=hDlg;
        pKeyGenInfo->pComp=pComp;

        // start the key gen thread
        DWORD dwThreadID; // ignored
        HANDLE hKeyGenThread=CreateThread(
            NULL,                   // security
            0,                      // stack
            GenerateKeyThread,
            (void *)pKeyGenInfo,
            0,                      // flags
            &dwThreadID);
        if (NULL==hKeyGenThread) {
            hr = myHLastError();
            _JumpError(hr, error, "CreateThread");
        }
        CloseHandle(hKeyGenThread);
    }

error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizKeyGenPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for keygen wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizKeyGenPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND     hwndCtrl;
    PER_COMPONENT_DATA *pComp = NULL;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;
        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), 0);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue=HandleKeyGenWizActive(hDlg, pComp, &g_KeyGenInfo);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZBACK);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_KEYGEN_TITLE, dwWIZNEXT);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;

    }
    return TRUE;
}


HRESULT
ValidateESERestrictions(
    IN WCHAR const *pwszDirectory)
{
    HRESULT hr;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileA = INVALID_HANDLE_VALUE;
    WCHAR *pwszPath = NULL;
    char *pszPath = NULL;
    WCHAR *pwsz;
    char *psz;
    DWORD cwcbs;
    DWORD cchbs;
    
    hr = myBuildPathAndExt(pwszDirectory, L"certocm.tmp", NULL, &pwszPath);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    if (!ConvertWszToSz(&pszPath, pwszPath, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "ConvertWszToSz")
    }

    pwsz = pwszPath;
    cwcbs = 0;
    while (TRUE)
    {
        pwsz = wcschr(pwsz, L'\\');
        if (NULL == pwsz)
        {
            break;
        }
        pwsz++;
        cwcbs++;
    }

    psz = pszPath;
    cchbs = 0;
    while (TRUE)
    {
        psz = strchr(psz, '\\');
        if (NULL == psz)
        {
            break;
        }
        psz++;
        cchbs++;
    }
    if (cchbs != cwcbs)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "backslash count")
    }

    hFile = CreateFile(
                    pwszPath,
                    GENERIC_WRITE,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,               // security
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);              // template
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CreateFile", pwszPath);
    }

    hFileA = CreateFileA(
                    pszPath,
                    GENERIC_READ,
                    FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,               // security
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);              // template
    if (INVALID_HANDLE_VALUE == hFileA)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, pszPath, L"CreateFileA");
    }
    CSASSERT(S_OK == hr);

error:
    if (INVALID_HANDLE_VALUE != hFileA)
    {
        CloseHandle(hFileA);            // close before below delete
    }
    if (NULL != pszPath)
    {
        LocalFree(pszPath);
    }
    if (NULL != pwszPath)
    {
        if (INVALID_HANDLE_VALUE != hFile)
        {
            CloseHandle(hFile);         // close before delete
            DeleteFile(pwszPath);
        }
        LocalFree(pwszPath);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
//  Function:   check if a database edit field
//--------------------------------------------------------------------------
BOOL
ValidateAndCreateDirField(
    HINSTANCE hInstance,
    BOOL    fUnattended,
    HWND    hDlg,
    WCHAR   *pwszDirectory,
    BOOL    fDefaultDir,
    int     iMsgNotFullPath,
    BOOL    *pfExist, 
    BOOL    *pfIsUNC)
{
    BOOL fRet = FALSE;
    DWORD dwPathFlag = 0;
    HRESULT hr;

    *pfExist = TRUE;

    // check edit field
    if (!myIsFullPath(pwszDirectory, &dwPathFlag))
    {
        CertWarningMessageBox(
                    hInstance,
                    fUnattended,
                    hDlg,
                    iMsgNotFullPath,
                    0,
                    pwszDirectory);
        goto error;
    }

    // set the UNC check
    *pfIsUNC = (dwPathFlag == UNC_PATH);

    if (MAX_PATH - 1 < wcslen(pwszDirectory))
    {
        WCHAR  wszMsg[256 + MAX_PATH];
        WCHAR *pwszFormat = NULL;

        hr = myLoadRCString(hInstance,
                    IDS_STORELOC_PATHTOOLONG,
                    &pwszFormat);
        _JumpIfError(hr, error, "myLoadRCString");

        swprintf(wszMsg, pwszFormat, pwszDirectory, MAX_PATH-1);
        CertWarningMessageBox(
                    hInstance,
                    fUnattended,
                    hDlg,
                    0,
                    0,
                    wszMsg);
        LocalFree(pwszFormat);
        goto error;
    }

    if (DE_DIREXISTS != DirExists(pwszDirectory))
    {
        if (*pfIsUNC)
        {
            CertWarningMessageBox(
                        hInstance,
                        fUnattended,
                        hDlg,
                        IDS_STORELOC_UNCMUSTEXIST,
                        0,
                        pwszDirectory);
            goto error;
        }
        else
        {
            if (!fDefaultDir)
            {
                // confirm and create outside
                *pfExist = FALSE;
                goto done;
            }

            // try to create default dir
            hr = myCreateNestedDirectories(pwszDirectory);
            _JumpIfError(hr, error, "myCreateNestedDirectories");
        }
    }

done:
    fRet = TRUE;

error:
    return fRet;
}

//+---------------------------------------------------------------------------
//  Description:    set MS Base CSP as default csp otherwise 1st one
//----------------------------------------------------------------------------
HRESULT
DetermineDefaultCSP(CASERVERSETUPINFO *pServer)
{
    HRESULT   hr;
    CSP_INFO *pCSPInfo = NULL;

    // select 1st if no MSBase
    pServer->pCSPInfo = pServer->pCSPInfoList;

    if (NULL == pServer->pDefaultCSPInfo)
    {
        goto done;
    }
    
    // check all csps
    pCSPInfo = pServer->pCSPInfoList;
    while (NULL != pCSPInfo)
    {
        if (NULL != pCSPInfo->pwszProvName)
        {
            if (0 == wcscmp(pCSPInfo->pwszProvName,
                         pServer->pDefaultCSPInfo->pwszProvName) &&
                pCSPInfo->dwProvType == pServer->pDefaultCSPInfo->dwProvType)
            {
                // change to default
                pServer->pCSPInfo = pCSPInfo;
                break;
            }
        }
        pCSPInfo = pCSPInfo->next;
    }

done:
    hr = S_OK;
//error:
    return hr;
}

//+---------------------------------------------------------------------------
//  Description:    set SHA as default hash alg. otherwise 1st one
//----------------------------------------------------------------------------
HRESULT
DetermineDefaultHash(CASERVERSETUPINFO *pServer)
{
    CSP_HASH *pHashInfo = NULL;
    HRESULT   hr;

    if ((NULL == pServer) || (NULL == pServer->pCSPInfo))
        return E_POINTER;

    // select 1st if no default match
    pServer->pHashInfo = pServer->pCSPInfo->pHashList;

    // search list
    pHashInfo = pServer->pCSPInfo->pHashList;
    while (NULL != pHashInfo)
    {
        if (pHashInfo->idAlg == pServer->pDefaultHashInfo->idAlg)
        {
            //change to default
            pServer->pHashInfo = pHashInfo;
            break;
        }
        pHashInfo = pHashInfo->next;
    }

    // Must validate the hash again when the selected hash changes
    pServer->fValidatedHashAndKey = FALSE;

    hr = S_OK;
//error:
    return hr;
}

HRESULT
UpdateCADescription(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    int      ids;
    WCHAR   *pwszDesc = NULL;
    HRESULT  hr;

    switch (pComp->CA.pServer->CAType)
    {
        case ENUM_STANDALONE_ROOTCA:
            ids = IDS_CATYPE_DES_STANDALONE_ROOTCA;
        break;
        case ENUM_STANDALONE_SUBCA:
            ids = IDS_CATYPE_DES_STANDALONE_SUBCA;
        break;
        case ENUM_ENTERPRISE_ROOTCA:
            ids = IDS_CATYPE_DES_ENTERPRISE_ROOTCA;
        break;
        case ENUM_ENTERPRISE_SUBCA:
            ids = IDS_CATYPE_DES_ENTERPRISE_SUBCA;
        break;
    }
    // load description from resource
    hr = myLoadRCString(pComp->hInstance, ids, &pwszDesc);
    _JumpIfError(hr, error, "myLoadRCString");
    // change text
    SetWindowText(GetDlgItem(hDlg, IDC_CATYPE_CA_DESCRIPTION), pwszDesc);

    hr = S_OK;
error:
    if (NULL != pwszDesc)
    {
        LocalFree(pwszDesc);
    }
    return hr;
}

HRESULT
InitCATypeWizControls(
    HWND    hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    int        idc;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_ENT_ROOT_CA), pServer->fUseDS);
    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_ENT_SUB_CA), pServer->fUseDS);
    ShowWindow(GetDlgItem(hDlg, IDC_CATYPE_DESCRIPTION_ENTERPRISE),
        !pServer->fUseDS);
    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_STAND_ROOT_CA), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_CATYPE_STAND_SUB_CA), TRUE);
    if (pServer->fUseDS)
    {
        if (ENUM_ENTERPRISE_SUBCA == pServer->CAType)
        {
            idc = IDC_CATYPE_ENT_SUB_CA;
        }
        else
        {
            idc = IDC_CATYPE_ENT_ROOT_CA;
        }
    }
    else
    {
        idc = IDC_CATYPE_STAND_ROOT_CA;
    }
    SendMessage(GetDlgItem(hDlg, idc), BM_CLICK, (WPARAM)0, (LPARAM)0);

    hr= UpdateCADescription(hDlg, pComp);
    _JumpIfError(hr, error, "UpdateCADescription");

    hr = S_OK;
error:
    return hr;
}

BOOL
IsRadioControlChecked(HWND hwnd)
{
    BOOL checked = FALSE;
    if (BST_CHECKED == SendMessage(hwnd, BM_GETCHECK, (WPARAM)0, (LPARAM)0))
    {
        checked = TRUE;
    }
    return checked;
}

HRESULT
HandleAdvanceChange(HWND hDlg, CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;

    if (!pServer->fAdvance)
    {
        // if not advance, clear all advance flags
        pServer->fPreserveDB = FALSE;
        ClearExistingCertToUse(pServer);
    }

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleCATypeChange(
    IN HWND hDlg, 
    IN PER_COMPONENT_DATA *pComp,
    IN ENUM_CATYPES eNewType)
{
    HRESULT  hr;
    BOOL bCertOK;
    CASERVERSETUPINFO * pServer=pComp->CA.pServer;

    pServer->CAType = eNewType;

    pServer->dwKeyLength = IsRootCA(pServer->CAType)?
        CA_DEFAULT_KEY_LENGTH_ROOT:
        CA_DEFAULT_KEY_LENGTH_SUB;

    hr=UpdateCADescription(hDlg, pComp);
    _JumpIfError(hr, error, "UpdateCADescription");

    // make sure that if we are using an existing cert, we didn't make it invalid.
    if (NULL!=pServer->pccExistingCert) {
        hr=IsCertSelfSignedForCAType(pServer, pServer->pccExistingCert, &bCertOK);
        _JumpIfError(hr, error, "UpdateCADescription");
        if (FALSE==bCertOK) {
            // can't use this cert with this CA type.
            ClearExistingCertToUse(pServer);
        }
    }

    hr = S_OK;

error:
    return hr;
}

HRESULT
HandleCATypeWizActive(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;

    // first of all, get install status
    hr = UpdateSubComponentInstallStatus(wszCERTSRVSECTION, wszSERVERSECTION, pComp);
    _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");
    hr = UpdateSubComponentInstallStatus(wszCERTSRVSECTION, wszCLIENTSECTION, pComp);
    _JumpIfError(hr, error, "UpdateSubComponentInstallStatus");

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server.

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }
done:
    hr = S_OK;
error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizCATypePageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for CA Type wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizCATypePageDlgProc(
    HWND hDlg,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitCATypeWizControls(hDlg, pComp);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CATYPE_STAND_ROOT_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_STANDALONE_ROOTCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_STAND_SUB_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_STANDALONE_SUBCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_ENT_ROOT_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_ENTERPRISE_ROOTCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_ENT_SUB_CA:
            if (IsRadioControlChecked((HWND)lParam))
            {
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCATypeChange(hDlg,
                                        pComp, ENUM_ENTERPRISE_SUBCA);
                _ReturnIfWizError(pComp->hrContinue);
            }
            break;

        case IDC_CATYPE_CHECK_ADVANCE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fAdvance = !pComp->CA.pServer->fAdvance;
            pComp->hrContinue = HandleAdvanceChange(hDlg, pComp->CA.pServer);
            _ReturnIfWizError(pComp->hrContinue);
            break;
        }
        break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code)
            {
            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;
            case PSN_QUERYCANCEL:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                return CertConfirmCancel(hDlg, pComp);
                break;

            case PSN_SETACTIVE:
                CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZACTIVE);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
                pComp = _GetCompDataOrReturn(pComp, hDlg);
                _DisableWizDisplayIfError(pComp, hDlg);
                _ReturnIfWizError(pComp->hrContinue);
                pComp->hrContinue = HandleCATypeWizActive(hDlg, pComp);
                _ReturnIfWizError(pComp->hrContinue);
                break;

            case PSN_WIZBACK:
                CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZBACK);
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->CA.pServer->LastWiz = ENUM_WIZ_CATYPE;
                break;

            case PSN_WIZNEXT:
                CSILOGDWORD(IDS_CATYPE_TITLE, dwWIZNEXT);
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->CA.pServer->LastWiz = ENUM_WIZ_CATYPE;
                CSILOGDWORD(IDS_LOG_CATYPE, pComp->CA.pServer->CAType);
                pComp->hrContinue = InitNameFields(pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;

            default:
                return FALSE;
            }
            break;

    default:
        return FALSE;
    }
    return TRUE;
}


//+---------------------------------------------------------------------------
//  Description:    display existing keys from list
//----------------------------------------------------------------------------

HRESULT
ShowExistingKey(
    IN HWND      hDlg,
    KEY_LIST    *pKeyList)
{
    HRESULT   hr;
    KEY_LIST *pKey = pKeyList;
    HWND hKeyList = GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    LRESULT nItem;
    LRESULT lr;
    WCHAR   *pwszDeSanitize = NULL;

    while (NULL != pKey)
    {
        if (NULL != pKey->pwszName)
        {
            if (NULL != pwszDeSanitize)
            {
                LocalFree(pwszDeSanitize);
                pwszDeSanitize = NULL;
            }
            hr = myRevertSanitizeName(pKey->pwszName, &pwszDeSanitize);
            _JumpIfError(hr, error, "myRevertSanitizeName");

            nItem = (INT)SendMessage(
                hKeyList,
                LB_ADDSTRING,
                (WPARAM) 0,
                (LPARAM) pwszDeSanitize);
            if (LB_ERR == nItem)
            {
                hr = myHLastError();
                _JumpError(hr, error, "SendMessage");
            }
            lr = (INT)SendMessage(
                hKeyList,
                LB_SETITEMDATA,
                (WPARAM) nItem,
                (LPARAM) pKey->pwszName);
            if (LB_ERR == lr)
            {
                hr = myHLastError();
                _JumpError(hr, error, "SendMessage");
            }
        }
        pKey = pKey->next;
    }
    if (NULL != pKeyList)
    {
        // choose the 1st one as default
        lr = (INT)SendMessage(hKeyList, LB_SETCURSEL, (WPARAM) 0, (LPARAM) 0);
        if (LB_ERR == lr)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SendMessage");
        }
    }

    hr = S_OK;
error:
    if (NULL != pwszDeSanitize)
    {
        LocalFree(pwszDeSanitize);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//  Description:    hilight an item by matched data
//----------------------------------------------------------------------------
HRESULT
HilightItemInList(HWND hDlg, int id, VOID const *pData, BOOL fString)
{
    HWND     hListCtrl = GetDlgItem(hDlg, id);
    LRESULT  iItem;
    LRESULT  count;
    VOID    *pItemData;
    HRESULT  hr = NTE_NOT_FOUND;

    // find item
    if (fString)
    {
        iItem = (INT)SendMessage(
                hListCtrl,
                LB_FINDSTRING,
                (WPARAM) 0,
                (LPARAM) pData);
        if (LB_ERR == iItem)
        {
            _JumpError(hr, error, "SendMessage");
        }
        hr = S_OK;
    }
    else
    {
        count = (INT)SendMessage(hListCtrl, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);
        for (iItem = 0; iItem < count; ++iItem)
        {
            pItemData = (VOID*)SendMessage(hListCtrl, LB_GETITEMDATA,
                                   (WPARAM)iItem, (LPARAM)0);
            if (pItemData == pData)
            {
                hr = S_OK;
                break;
            }
        }
    }
    if (S_OK != hr)
    {
        _JumpError(hr, error, "not found");
    }

    // hilight it
    SendMessage(hListCtrl, LB_SETCURSEL, (WPARAM)iItem, (LPARAM)0);

    hr = S_OK;
error:
    return hr;
}

HRESULT
ShowAllCSP(
    HWND        hDlg,
    CSP_INFO   *pCSPInfo)
{
    HWND     hCSPList = GetDlgItem(hDlg, IDC_ADVANCE_CSPLIST);
    LRESULT  nItem;

    // list all of csps
    while (pCSPInfo)
    {
        if (pCSPInfo->pwszProvName)
        {
            nItem = (INT)SendMessage(hCSPList, LB_ADDSTRING, 
                (WPARAM)0, (LPARAM)pCSPInfo->pwszProvName);
            SendMessage(hCSPList, LB_SETITEMDATA, 
                (WPARAM)nItem, (LPARAM)pCSPInfo);
        }
        pCSPInfo = pCSPInfo->next;
    }

    return S_OK;
}

HRESULT
ShowAllHash(
    HWND      hDlg,
    CSP_HASH *pHashInfo)
{
    HWND     hHashList = GetDlgItem(hDlg, IDC_ADVANCE_HASHLIST);
    LRESULT  nItem;

    // remove hash of previous csp from list
    while (SendMessage(hHashList, LB_GETCOUNT, 
                     (WPARAM)0, (LPARAM)0))
    {
        SendMessage(hHashList, LB_DELETESTRING, 
                             (WPARAM)0, (LPARAM)0);
    }

    // list all hash
    while (NULL != pHashInfo)
    {
        if (NULL != pHashInfo->pwszName)
        {
            nItem = (INT)SendMessage(hHashList, LB_ADDSTRING,
                (WPARAM)0, (LPARAM)pHashInfo->pwszName);
            SendMessage(hHashList, LB_SETITEMDATA,
                (WPARAM)nItem, (LPARAM)pHashInfo);
        }
        pHashInfo = pHashInfo->next;
    }

    return S_OK;
}

//--------------------------------------------------------------------
HRESULT
UpdateUseCertCheckbox(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    BOOL bUsingExistingCert;

    if (NULL==pServer->pccExistingCert) {
        bUsingExistingCert=FALSE;
    } else {
        bUsingExistingCert=TRUE;
    }

    // check "use cert" control
    SendMessage(GetDlgItem(hDlg, IDC_ADVANCE_USECERTCHECK),
                BM_SETCHECK,
                (WPARAM)(bUsingExistingCert?BST_CHECKED:BST_UNCHECKED),
                (LPARAM)0);

    // enable the "View Cert" button if necessary
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_VIEWCERT), bUsingExistingCert);

    // we will match the hash alg used by the cert, if possible
    hr=HilightItemInList(hDlg, IDC_ADVANCE_HASHLIST,
             pServer->pHashInfo, FALSE);
    _JumpIfError(hr, error, "HilightItemInList");

    hr=S_OK;

error:
    return hr;
}


HRESULT
FindCertificateByKeyWithWaitCursor(
    IN CASERVERSETUPINFO *pServer,
    OUT CERT_CONTEXT const **ppccCert)
{
    HRESULT hr;
    HCURSOR hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr = FindCertificateByKey(pServer, ppccCert);
    SetCursor(hPrevCur);
    _JumpIfError(hr, error, "FindCertificateByKey");

error:
    return(hr);
}


//--------------------------------------------------------------------
// handle the "Use existing Cert" checkbox
HRESULT
HandleUseCertCheckboxChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    CERT_CONTEXT const * pccCert;

    if(pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN);
        pServer->pwszFullCADN = NULL;
    }

    // is the checkbox checked or unchecked?
    if (BST_CHECKED==IsDlgButtonChecked(hDlg, IDC_ADVANCE_USECERTCHECK)) {

        // checkbox was just checked, so we previously were not using an existing cert
        CSASSERT(NULL==pServer->pccExistingCert);

        // Find the existing cert for this key
        hr = FindCertificateByKeyWithWaitCursor(pServer, &pccCert);
        _JumpIfError(hr, error, "FindCertificateByKeyWithWaitCursor");

        // use it
        hr=SetExistingCertToUse(pServer, pccCert);
        _JumpIfError(hr, error, "SetExistingCertToUse");

    } else {

        // checkbox was just unchecked, so we previously were using an existing cert.
        CSASSERT(NULL!=pServer->pccExistingCert);

        // stop using the cert
        ClearExistingCertToUse(pServer);
    }

    hr = UpdateUseCertCheckbox(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateUseCertCheckbox");

error:
    return hr;
}


//----------------------------------------------------------------------------
// Hilight the current key - don't use HilightItemInList because we
// must use string-compare on the data portion, and HilightItemInList does not
// support this.
HRESULT
HilightKeyInList(HWND hDlg, CASERVERSETUPINFO * pServer)
{
    HWND hListCtrl=GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    LRESULT nIndex;
    LRESULT nTotNames;
    WCHAR * pwszKeyContainerName;
    HRESULT  hr = NTE_NOT_FOUND;

    nTotNames=(INT)SendMessage(hListCtrl, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);
    for (nIndex=0; nIndex<nTotNames; nIndex++) {
        pwszKeyContainerName=(WCHAR *)SendMessage(hListCtrl, LB_GETITEMDATA, (WPARAM)nIndex, (LPARAM)0);
        if (0==wcscmp(pwszKeyContainerName, pServer->pwszKeyContainerName)) {
            SendMessage(hListCtrl, LB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
            hr = S_OK;
            break;
        }
    }

    if (S_OK != hr)
    {
        // can lead to dead wiz pages
        CSILOG(
                hr,
                IDS_LOG_KEY_NOT_FOUND_IN_LIST,
                pServer->pwszKeyContainerName,
                NULL,
                NULL);
        _PrintErrorStr(hr, "not found", pServer->pwszKeyContainerName);
    }

    hr = S_OK;
//error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT
UpdateKeySelection(
    HWND            hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr;
    BOOL bAvailableExistingCert = FALSE;
    CERT_CONTEXT const * pccCert;

    // if we have an existing key, make sure it is the one hilighted
    // in the list and check for coresponding certs.
    if (NULL!=pServer->pwszKeyContainerName) {

        // hilight key
        hr = HilightKeyInList(hDlg, pServer);
        _JumpIfError(hr, error, "HilightKeyInList");

        if (NULL!=pServer->pccExistingCert) {
            // we are using an existing cert, so it better exist!
            bAvailableExistingCert = TRUE;
        } else {
            // see if there is an existing cert for this key
            hr = FindCertificateByKeyWithWaitCursor(pServer, &pccCert);
            if (S_OK==hr) {
                CertFreeCertificateContext(pccCert);
                bAvailableExistingCert = TRUE;
            } else {
                // only other return is 'not found'
                CSASSERT(CRYPT_E_NOT_FOUND==hr);
            }
        }

    } else {
        // no key selected, can't have an existing cert
    }

    // enable/disable reuse cert...
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_USECERTCHECK), bAvailableExistingCert);

    hr = UpdateUseCertCheckbox(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateUseCertCheckbox");

error:
    return hr;
}


//--------------------------------------------------------------------
HRESULT
UpdateUseKeyCheckbox(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    BOOL bReuseKey;

    if (NULL==pServer->pwszKeyContainerName) {
        // we are creating a new key
        bReuseKey=FALSE;
    } else {
        // we are using an existing key
        bReuseKey=TRUE;
    }

    // check/uncheck the checkbox depending upon whether we are reusing a key
    SendDlgItemMessage(hDlg,
        IDC_ADVANCE_USEKEYCHECK,
        BM_SETCHECK,
        (WPARAM)(bReuseKey?BST_CHECKED:BST_UNCHECKED),
        (LPARAM)0);

    // enable the key list if we are reusing a key
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST), bReuseKey);

    // disable the key length box if we are reusing a key
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH), !bReuseKey);

    hr = UpdateKeySelection(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateKeySelection");

error:
    return hr;
}

//+---------------------------------------------------------------------------
//  Description:    update hash alg. list if csp selection changes
//----------------------------------------------------------------------------
HRESULT
UpdateHashList(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT  hr;

    // load new hash list
    hr = ShowAllHash(hDlg, pServer->pCSPInfo->pHashList);
    _JumpIfError(hr, error, "ShowAllHash");

    hr = HilightItemInList(hDlg, IDC_ADVANCE_HASHLIST,
             pServer->pHashInfo, FALSE);
    _JumpIfError(hr, error, "HilightItemInList");

    hr = S_OK;
error:
    return hr;
}

//+---------------------------------------------------------------------------
//  Description:    update key list if csp selection changes
//----------------------------------------------------------------------------
HRESULT
UpdateKeyList(
    HWND           hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    HWND hKeyList;
    CSP_HASH *pHashInfo = NULL;
    int nItem;
    HCURSOR hPrevCur;

    // remove keys of previous csp from list

    hKeyList = GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    while (SendMessage(hKeyList, LB_GETCOUNT, (WPARAM) 0, (LPARAM) 0))
    {
        SendMessage(hKeyList, LB_DELETESTRING, (WPARAM) 0, (LPARAM) 0);
    }

    // update key list with new CSP

    if (NULL != pServer->pKeyList)
    {
        csiFreeKeyList(pServer->pKeyList);
    }

    hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    hr = csiGetKeyList(
                pServer->pCSPInfo->dwProvType,
                pServer->pCSPInfo->pwszProvName,
                pServer->pCSPInfo->fMachineKeyset,
                FALSE,                  // fSilent
                &pServer->pKeyList);
    SetCursor(hPrevCur);
    if (S_OK != hr)
    {
        _PrintError(hr, "csiGetKeyList");
        // don't fail setup if only no key update
        //goto done;
    }

    // show keys
    if (NULL != pServer->pKeyList)
    {
        hr = ShowExistingKey(hDlg, pServer->pKeyList);
        _JumpIfError(hr, error, "ShowExistingKey");
    }

    if (NULL == pServer->pKeyList) {
        // no existing key for the csp, so disable "use existing key" checkbox
        EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_USEKEYCHECK), FALSE);
        CSASSERT(NULL==pServer->pwszKeyContainerName);
    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_USEKEYCHECK), TRUE);
    }

    hr = UpdateUseKeyCheckbox(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateUseKeyCheckbox");

//done:
    hr = S_OK;
error:
    return(hr);
}


DWORD g_adwKeyLengths[] =
{
    512,
    1024,
    2048,
    4096,
};

DWORD g_adwKeyLengthsSmall[] =
{
    128,
    256,
    512,
    1024,
};

HRESULT
AddPredefinedKeyLength
(
    HWND   hwnd,
    DWORD  dwKeyLength)
{
    HRESULT    hr;
    WCHAR  wszKeyLength[MAX_KEYLENGTHDIGIT + 1];
    WCHAR  const *pwszKeyLength;
    LRESULT nIndex;

    CSASSERT(0 != dwKeyLength);
    wsprintf(wszKeyLength, L"%u", dwKeyLength);
    pwszKeyLength = wszKeyLength;

    nIndex = (INT)SendMessage(hwnd, CB_ADDSTRING, (WPARAM)0, (LPARAM)pwszKeyLength);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_ADDSTRING)");
    }
    SendMessage(hwnd, CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)dwKeyLength);

    hr = S_OK;
error:
    return hr;
}

HRESULT
ShowAllKeyLength(
    HWND            hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr;
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);
    WCHAR  wszKeyLength[MAX_KEYLENGTHDIGIT + 1];
    DWORD *pdw;
    DWORD *pdwEnd;

    // remove existing key length list
    while (SendMessage(hwndCtrl, CB_GETCOUNT, (WPARAM) 0, (LPARAM) 0))
    {
        SendMessage(hwndCtrl, CB_DELETESTRING, (WPARAM) 0, (LPARAM) 0);
    }

    CSASSERT(0 != pServer->dwKeyLength);

    if(pServer->dwKeyLength > pServer->dwKeyLenMax)
    {
        pServer->dwKeyLength=pServer->dwKeyLenMax;
    }

    wsprintf(wszKeyLength, L"%u", pServer->dwKeyLength);
    SetWindowText(hwndCtrl, wszKeyLength);

    pdw = g_adwKeyLengths;
    pdwEnd = &g_adwKeyLengths[ARRAYSIZE(g_adwKeyLengths)];

    if (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMin &&
        C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMax &&
        g_adwKeyLengthsSmall[ARRAYSIZE(g_adwKeyLengthsSmall) - 1] >=
        pServer->dwKeyLenMax)
    {
        pdw = g_adwKeyLengthsSmall;
        pdwEnd = &g_adwKeyLengthsSmall[ARRAYSIZE(g_adwKeyLengthsSmall)];
    }

    // show new key length list
    for ( ; pdw < pdwEnd; pdw++)
    {
        if (0 == *pdw ||
            ((C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMin &&
              *pdw >= pServer->dwKeyLenMin) && 
             (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMax &&
              *pdw <= pServer->dwKeyLenMax)) )
        {
            hr = AddPredefinedKeyLength(hwndCtrl, *pdw);
            _JumpIfError(hr, error, "AddPredefinedKeyLength");
        }
    }
    hr = S_OK;

error:
    return hr;
}


HRESULT
UpdateKeyLengthMinMax(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT     hr;
    HCRYPTPROV  hProv = NULL;
    CSP_INFO   *pCSPInfo = pServer->pCSPInfo;
    PROV_ENUMALGS_EX paramData;
    DWORD       cbData;
    DWORD       dwFlags;

    // default that csp doesn't support PP_ENUMALGS_EX
    pServer->dwKeyLenMin = C_CSPHASNOKEYMINMAX;
    pServer->dwKeyLenMax = C_CSPHASNOKEYMINMAX;

    // determine the min and max key length for selected csp
    if (!myCertSrvCryptAcquireContext(
                &hProv,
                NULL,
                pCSPInfo->pwszProvName,
                pCSPInfo->dwProvType,
                CRYPT_VERIFYCONTEXT,
                FALSE))
    {
        hr = myHLastError();
        if (NULL != hProv)
        {
            hProv = NULL;
            _PrintError(hr, "CSP returns a non-null handle");
        }
        _JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pCSPInfo->pwszProvName);
    }

    dwFlags = CRYPT_FIRST;
    while (TRUE)
    {
        cbData = sizeof(paramData);
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS_EX,
                (BYTE *) &paramData,
                &cbData,
                dwFlags))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
            {
                // out of for loop
                break;
            }
            _JumpError(hr, error, "CryptGetProvParam");
        }
        if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(paramData.aiAlgid))
        {
            pServer->dwKeyLenMin = paramData.dwMinLen;
            pServer->dwKeyLenMax = paramData.dwMaxLen;
            break;
        }
	dwFlags = 0;
    }

error:
    hr = ShowAllKeyLength(hDlg, pServer);
    _PrintIfError(hr, "ShowAllKeyLength");

    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return(S_OK);
}


HRESULT
InitializeKeyLengthControl(HWND hDlg)
{
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);

    // set digit length

    SendMessage(
            hwndCtrl,
            CB_LIMITTEXT,
            (WPARAM) MAX_KEYLENGTHDIGIT,
            (LPARAM) 0);

    return S_OK;
}



//--------------------------------------------------------------------
HRESULT
HandleKeySelectionChange(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer,
    BOOL                fUpdate)
{
    HRESULT  hr;
    HWND     hKeyList = GetDlgItem(hDlg, IDC_ADVANCE_KEYLIST);
    WCHAR * pwszKeyContainerName;
    CERT_CONTEXT const * pccCert;

    LRESULT nItem = (INT)SendMessage(
                         hKeyList,
                         LB_GETCURSEL,
                         (WPARAM) 0,
                         (LPARAM) 0);
   CSASSERT(LB_ERR!=nItem);

    pwszKeyContainerName = (WCHAR *) SendMessage(
        hKeyList, 
        LB_GETITEMDATA,
        (WPARAM) nItem,
        (LPARAM) 0);
    CSASSERT(NULL!=pwszKeyContainerName);

    // Only change is this is a different selection
    if (NULL==pServer->pwszKeyContainerName ||
        0!=wcscmp(pwszKeyContainerName, pServer->pwszKeyContainerName)) {

        // Set the container name to match what the user picked.
        BOOL fKeyListChange=pServer->fDeletableNewKey;
        hr = SetKeyContainerName(pServer, pwszKeyContainerName);
        _JumpIfError(hr, error, "SetKeyContainerName");

        // see if there is an existing cert for this key
        hr = FindCertificateByKeyWithWaitCursor(pServer, &pccCert);
        if (S_OK==hr) {
            // Yes there is. By default, use it.
            hr=SetExistingCertToUse(pServer, pccCert);
            _JumpIfError(hr, error, "SetExistingCertToUse");
        } else {
            // only other return is 'not found'
            CSASSERT(CRYPT_E_NOT_FOUND==hr);
        }

        // check to see if our caller wants us to update.
        // our caller may want to do the update himself.
        if (fUpdate) {
            // perform the minimum necessary update
            if (fKeyListChange) {
                hr = UpdateKeyList(hDlg, pServer);
                _JumpIfError(hr, error, "UpdateKeyList");
            } else {
                hr = UpdateKeySelection(hDlg, pServer);
                _JumpIfError(hr, error, "UpdateKeySelection");
            }
        }
    }

    hr=S_OK;

error:
    return hr;
}

//--------------------------------------------------------------------
// handle the "Use existing Key" checkbox
HRESULT
HandleUseKeyCheckboxChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    static bool fNT4CertCopiedAlready = false;

    if(pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN);
        pServer->pwszFullCADN = NULL;
    }

    if(pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
        pServer->pwszCACommonName = NULL;
    }

    if(pServer->pwszDNSuffix)
    {
        LocalFree(pServer->pwszDNSuffix);
        pServer->pwszDNSuffix = NULL;
    }

    // is the checkbox checked or unchecked?
    if (BST_CHECKED==IsDlgButtonChecked(hDlg, IDC_ADVANCE_USEKEYCHECK)) {

        // checkbox was just checked, so we previously did not have a chosen key.
        CSASSERT(NULL==pServer->pwszKeyContainerName);

        hr = HandleKeySelectionChange(hDlg, pServer, FALSE); // don't update, because we need to update too.
        _JumpIfError(hr, error, "HandleKeySelectionChange");

        hr = UpdateUseKeyCheckbox(hDlg, pServer);
        _JumpIfError(hr, error, "UpdateUseKeyCheckbox");

    } else {

        // checkbox was just unchecked, so we previously had a chosen key..
        CSASSERT(NULL!=pServer->pwszKeyContainerName);

        BOOL fKeyListChange=pServer->fDeletableNewKey;
        ClearKeyContainerName(pServer);

        // perform the minimum necessary update
        if (fKeyListChange) {
            hr = UpdateKeyList(hDlg, pServer);
            _JumpIfError(hr, error, "UpdateKeyList");
        } else {
            hr = UpdateUseKeyCheckbox(hDlg, pServer);
            _JumpIfError(hr, error, "UpdateUseKeyCheckbox");
        }
        
        hr = InitNameFields(pServer);
        _JumpIfError(hr, error, "InitNameFields");
    }


error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT
UpdateCSPSelection(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr;
    bool fInteractiveOff;

    if (NULL == pServer->pCSPInfo)
    {
       hr = E_POINTER;
       _JumpError(hr, error, "NULL pCSPInfo");
    }

    // hilight current CSP
    hr = HilightItemInList(hDlg,
                    IDC_ADVANCE_CSPLIST,
                    pServer->pCSPInfo->pwszProvName,
                    TRUE);
    _JumpIfError(hr, error, "HilightItemInList");

    hr = UpdateHashList(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateHashList");

    hr = UpdateKeyLengthMinMax(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateKeyLengthMinMax");

    hr = UpdateKeyList(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateKeyList");

    // Update "interact with desktop" flag. For default CSP
    // we turn it off, otherwise turn it on.
    CSASSERT(pServer->pCSPInfo &&
        pServer->pDefaultCSPInfo&&
        pServer->pCSPInfo->pwszProvName &&
        pServer->pDefaultCSPInfo->pwszProvName);
    
    fInteractiveOff =
        (0 == wcscmp(pServer->pCSPInfo->pwszProvName,
                     pServer->pDefaultCSPInfo->pwszProvName) &&
        (pServer->pCSPInfo->dwProvType == pServer->pDefaultCSPInfo->dwProvType));

    SendMessage(
            GetDlgItem(hDlg, IDC_ADVANCE_INTERACTIVECHECK),
            BM_SETCHECK,
            (WPARAM)(fInteractiveOff?BST_UNCHECKED:BST_CHECKED),
            (LPARAM)0);

    hr = S_OK;
error:
    return hr;
}

//--------------------------------------------------------------------
HRESULT
HandleCSPSelectionChange(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT hr = S_OK;
    HWND     hCSPList;
    LRESULT  nItem;
    CSP_INFO * pCSPInfo;

    // get current csp
    hCSPList = GetDlgItem(hDlg, IDC_ADVANCE_CSPLIST);
    nItem = (INT)SendMessage(hCSPList, LB_GETCURSEL, 
                          (WPARAM)0, (LPARAM)0);
    pCSPInfo = (CSP_INFO *)SendMessage(hCSPList, 
           LB_GETITEMDATA, (WPARAM)nItem, (LPARAM)0);

    // only change if this is a different selection
    if (pCSPInfo->dwProvType!=pServer->pCSPInfo->dwProvType ||
        0!=wcscmp(pCSPInfo->pwszProvName, pServer->pCSPInfo->pwszProvName)) {

        // Must create a new key if the CSP changes
        ClearKeyContainerName(pServer);

        pServer->pCSPInfo=pCSPInfo;

        hr = DetermineDefaultHash(pServer);
        _JumpIfError(hr, error, "DetermineDefaultHash");

        hr = UpdateCSPSelection(hDlg, pServer);
        _JumpIfError(hr, error, "UpdateCSPSelection");
    }

error:
    return hr;
}

// Update cascade:
//
// UpdateCSPSelection
// |-UpdateHashList
// |-UpdateKeyLengthMinMax
// \-UpdateKeyList
//   \-UpdateUseKeyCheckbox
//     \-UpdateKeySelection
//       \-UpdateUseCertCheckbox

HRESULT
InitAdvanceWizPageControls(
    HWND                hDlg,
    CASERVERSETUPINFO  *pServer)
{
    HRESULT  hr;

    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCE_INTERACTIVECHECK), TRUE);

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleHashSelectionChange(
    HWND           hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;
    HWND hHashList = GetDlgItem(hDlg, IDC_ADVANCE_HASHLIST);
 
    LRESULT nItem = (INT)SendMessage(
                        hHashList,
                        LB_GETCURSEL, 
                        (WPARAM) 0,
                        (LPARAM) 0);

    pServer->pHashInfo = (CSP_HASH*)SendMessage(
        hHashList,
        LB_GETITEMDATA,
        (WPARAM) nItem,
        (LPARAM) 0);

    // Must validate the hash again when the selected hash changes
    pServer->fValidatedHashAndKey = FALSE;

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleKeyLengthSelectionChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);

    LRESULT nItem = (INT)SendMessage(hwndCtrl, CB_GETCURSEL,
                                (WPARAM)0, (LPARAM)0);
    pServer->dwKeyLength = (DWORD)SendMessage(hwndCtrl,
                                      CB_GETITEMDATA,
                                      (WPARAM)nItem, (LPARAM)0);

    // If key length chenges, we must not have created a key yet.
    CSASSERT(NULL==pServer->pwszKeyContainerName);

    hr = S_OK;
//error:
    return hr;
}

// remove any non-numeric chars except default string
HRESULT
HandleKeyLengthEditChange(
    HWND               hwndComboBox)
{
    HRESULT  hr;
    WCHAR    wszKeyLength[MAX_KEYLENGTHEDIT];
    int      index = 0; // index for new #
    int      posi = 0;  // current position

    wszKeyLength[0] = L'\0'; // PREFIX says initialize 
    GetWindowText(hwndComboBox, wszKeyLength, ARRAYSIZE(wszKeyLength));

    // remove non-numeric chars
    while (L'\0' != wszKeyLength[posi])
    {
        if (iswdigit(wszKeyLength[posi]))
        {
            // take digit
            wszKeyLength[index] = wszKeyLength[posi];
            ++index;
        }
        ++posi;
    }
    if (index != posi)
    {
        // null terminator
        wszKeyLength[index] = L'\0';
        // update
        SetWindowText(hwndComboBox, wszKeyLength);
        // point to end
        SendMessage(hwndComboBox, CB_SETEDITSEL, (WPARAM)0,
                MAKELPARAM((index), (index)) );
    }

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleImportPFXButton(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    hr = ImportPFXAndUpdateCSPInfo(hDlg, pComp);
    _PrintIfError(hr, "ImportPFXAndUpdateCSPInfo");

    // ignore error and force update anyway.
    hr = UpdateCSPSelection(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateCSPSelection");

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleAdvanceWizNext(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    WCHAR    wszKeyLength[MAX_KEYLENGTHEDIT];
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    HWND hwndCtrl = GetDlgItem(hDlg, IDC_ADVANCE_KEY_LENGTH);
    BOOL     fDontNext = FALSE;
    WCHAR    wszKeyRange[2*MAX_KEYLENGTHDIGIT + 4]; //"(xxxx,xxxx)" format
    WCHAR   *pwszKeyRange = NULL; //don't free just a pointer
    int    dwKeyLength;
    int      idMsg;
    BOOL fValidDigitString;

    if (NULL == pServer->pwszKeyContainerName)
    {
        GetWindowText(hwndCtrl, wszKeyLength, ARRAYSIZE(wszKeyLength));

        dwKeyLength = myWtoI(wszKeyLength, &fValidDigitString);
        if (0 > dwKeyLength)
        {
            idMsg = IDS_ADVANCE_NEGATIVEKEYLENGTH;
            fDontNext = TRUE;
        }
        else if (!fValidDigitString)
        {
            idMsg = IDS_ADVANCE_INVALIDKEYLENGTH;
            fDontNext = TRUE;
        }
        else if ( (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMin &&
                   (DWORD)dwKeyLength < pServer->dwKeyLenMin) ||
                  (C_CSPHASNOKEYMINMAX != pServer->dwKeyLenMax &&
                   (DWORD)dwKeyLength > pServer->dwKeyLenMax) )
        {
            swprintf(wszKeyRange, L"(%ld, %ld)",
                     pServer->dwKeyLenMin, pServer->dwKeyLenMax);
            pwszKeyRange = wszKeyRange;
            idMsg = IDS_ADVANCE_KEYLENGTHOUTOFRANGE;
            fDontNext = TRUE;
        }
        if (fDontNext)
        {
            CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        idMsg,
                        0,
                        pwszKeyRange);
            SetEditFocusAndSelect(hwndCtrl, 0, -1);
            goto done;
        }
        // take the length
        pServer->dwKeyLength = dwKeyLength;
    }
    else
    {
        // use existing key

        if (NULL==pServer->pccExistingCert)
        {
            // If reusing a key but not a cert, make the common name match the key name
            if (NULL != pServer->pwszCACommonName)
            {
                // free old
                LocalFree(pServer->pwszCACommonName);
                pServer->pwszCACommonName = NULL;
            }
            pServer->pwszCACommonName = (WCHAR*) LocalAlloc(LPTR,
                (wcslen(pServer->pwszDesanitizedKeyContainerName) + 1) * sizeof(WCHAR));
            _JumpIfOutOfMemory(hr, error, pServer->pwszCACommonName);
            wcscpy(pServer->pwszCACommonName, pServer->pwszDesanitizedKeyContainerName);

            hr = InitNameFields(pServer);
            _JumpIfError(hr, error, "InitNameFields");

        } else {

            // If reusing a cert, make all the ID fields match the cert
            // use idinfo from signing cert
            hr = DetermineExistingCAIdInfo(pServer, NULL);
            if (S_OK != hr)
            {
                CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_ERR_ANALYSIS_CA,
                    hr,
                    NULL);
                _PrintError(hr, "DetermineExistingCAIdInfo");
                fDontNext = TRUE;
                goto done;
            }
        }
    }

    // get "interactive service" check box state
    pServer->fInteractiveService = 
        (BST_CHECKED == 
         SendMessage(GetDlgItem(hDlg, IDC_ADVANCE_INTERACTIVECHECK), 
         BM_GETCHECK, (WPARAM)0, (LPARAM)0))?
        TRUE:FALSE;

    // update hash oid
    if (NULL != pServer->pszAlgId)
    {
        // free old
        LocalFree(pServer->pszAlgId);
    }
    hr = myGetSigningOID(
		     NULL,	// hProv
		     pServer->pCSPInfo->pwszProvName,
		     pServer->pCSPInfo->dwProvType,
		     pServer->pHashInfo->idAlg,
		     &(pServer->pszAlgId));
    if (S_OK != hr)
    {
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_ERR_UNSUPPORTEDHASH,
            hr,
            NULL);
        fDontNext = TRUE;
        goto done;
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    else
    {
        pServer->LastWiz = ENUM_WIZ_ADVANCE;
    }
    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleAdvanceWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // Suppress this wizard page if
    // we've already seen an error, or
    // the advanced option was not selected, or
    // we are not installing the server.

    if (!pServer->fAdvance ||
        !(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    if (NULL == pServer->pCSPInfoList)
    {
        // construct CSP info list
        HCURSOR hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        hr = GetCSPInfoList(&pServer->pCSPInfoList);
        SetCursor(hPrevCur);
        _JumpIfError(hr, error, "GetCSPInfoList");

        // show all csps
        hr = ShowAllCSP(hDlg, pServer->pCSPInfoList);
        _JumpIfError(hr, error, "ShowAllCSP");

        // determine default csp
        hr = DetermineDefaultCSP(pServer);
        _JumpIfError(hr, error, "DetermineDefaultCSP");

        hr = DetermineDefaultHash(pServer);
        _JumpIfError(hr, error, "DetermineDefaultHash");

        hr = InitializeKeyLengthControl(hDlg);
        _JumpIfError(hr, error, "InitializeKeyLengthControl");
    }

    hr = UpdateCSPSelection(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateCSPSelection");

done:
    hr = S_OK;

error:
    return hr;
}

HRESULT
HandleViewCertButton(
    HWND                hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CRYPTUI_VIEWCERTIFICATE_STRUCTW viewCert;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    CSASSERT(NULL!=pServer->pwszKeyContainerName &&
             NULL!=pServer->pccExistingCert);

    ZeroMemory(&viewCert, sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCTW));
    viewCert.hwndParent = hDlg;
    viewCert.dwSize = sizeof(viewCert);
    viewCert.pCertContext = CertDuplicateCertificateContext(pServer->pccExistingCert);
    if (NULL == viewCert.pCertContext)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertDuplicateCertificateContext");
    }
//    viewCert.rghStores = &pServer->hMyStore;
//    viewCert.cStores = 1;
    viewCert.dwFlags = CRYPTUI_DONT_OPEN_STORES;

    if (!CryptUIDlgViewCertificateW(&viewCert, NULL))
    {
        hr = myHLastError();
        _PrintError(hr, "CryptUIDlgViewCertificate");
    }

    hr = S_OK;
error:
    if (NULL != viewCert.pCertContext)
    {
        CertFreeCertificateContext(viewCert.pCertContext);
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   WizAdvancedPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for advanced configuration OCM wizard.
//
//  Arguments:  [hDlg]
//              [iMsg]
//              [wParam]
//              [lParam]    ... the usual.
//
//  Returns:    BOOL dlg proc result.
//
//-------------------------------------------------------------------------
INT_PTR
WizAdvancedPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    switch (iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (LONG)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitAdvanceWizPageControls(hDlg, pComp->CA.pServer);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_ADVANCE_CSPLIST:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleCSPSelectionChange(hDlg,
                                         pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;

            default:
                break;
            }
            break;

        case IDC_ADVANCE_HASHLIST:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleHashSelectionChange(hDlg,
                                         pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;

        case IDC_ADVANCE_KEYLIST:
            switch (HIWORD(wParam))
            {
            case LBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleKeySelectionChange(hDlg,
                                        pComp->CA.pServer, TRUE);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;

        case IDC_ADVANCE_USEKEYCHECK:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleUseKeyCheckboxChange(hDlg,
                                        pComp->CA.pServer);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_ADVANCE_USECERTCHECK:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleUseCertCheckboxChange(hDlg,
                                        pComp->CA.pServer);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_ADVANCE_KEY_LENGTH:
            switch (HIWORD(wParam))
            {
            case CBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleKeyLengthSelectionChange(hDlg,
                                        pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            case CBN_EDITCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleKeyLengthEditChange(
                        (HWND)lParam);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;

        case IDC_ADVANCE_IMPORT:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleImportPFXButton(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_ADVANCE_VIEWCERT:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleViewCertButton(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR*) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleAdvanceWizActive(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZBACK);
            break;

        case PSN_WIZNEXT:
            DWORD fReuseCert;

            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            fReuseCert = NULL != pComp->CA.pServer->pccExistingCert;
            CSILOG(
                S_OK,
                IDS_LOG_KEYNAME,
                pComp->CA.pServer->pwszKeyContainerName,
		pComp->CA.pServer->pwszDesanitizedKeyContainerName,
                &fReuseCert);
            CSILOGDWORD(IDS_ADVANCE_TITLE, dwWIZNEXT);
            pComp->hrContinue = HandleAdvanceWizNext(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


HRESULT
EnableSharedFolderControls(HWND hDlg, BOOL fUseSharedFolder)
{
    EnableWindow(GetDlgItem(hDlg, IDC_STORE_EDIT_SHAREDFOLDER), fUseSharedFolder);
    EnableWindow(GetDlgItem(hDlg, IDC_STORE_SHAREDBROWSE), fUseSharedFolder);
    if (fUseSharedFolder)
    {
        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_STORE_EDIT_SHAREDFOLDER), 0, -1);
    }
    return S_OK;
}


HRESULT
StorePageValidation(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    BOOL              *pfDontNext)
{
    HRESULT hr;
    UINT    uiFocus = 0;
    WCHAR   *pwszDefaultDBDir = NULL;
    WCHAR   *pwszDefaultSF = NULL;

    LPWSTR  pwszPrompt = NULL;
    LPWSTR  pwszComputerName = NULL;

    BOOL    fExistSF = TRUE;
    BOOL    fExistDB = TRUE;
    BOOL    fExistLog = TRUE;
    BOOL    fDefaultDir;
    BOOL    fIsUNC, fIsSharedFolderUNC;
    WCHAR   wszNotExistingDir[3 * MAX_PATH];
    BOOL    fUseSharedFolder;
    
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    
    *pfDontNext = FALSE;

    // get shared folder check state
    if (pComp->fUnattended)
    {
        CSASSERT(NULL != pServer->pwszSharedFolder);
        fUseSharedFolder = TRUE;  // unattended always use shared folder
    }
    else
    {
        fUseSharedFolder = (BST_CHECKED == SendMessage(
                        GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER),
                        BM_GETCHECK, 0, 0));
    }

    if (NULL != pServer->pwszSharedFolder)
    {
        fDefaultDir = TRUE;
        hr = GetDefaultSharedFolder(&pwszDefaultSF);
        _JumpIfError(hr, error, "GetDefaultSharedFolder");
        
        // make sure case insensitive
        if (0 != lstrcmpiW(pwszDefaultSF, pServer->pwszSharedFolder))
        {
            fDefaultDir = FALSE;
        }
        if (!ValidateAndCreateDirField(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg, 
            pServer->pwszSharedFolder,
            fDefaultDir,
            IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH,
            &fExistSF,
            &fIsSharedFolderUNC))
        {
            uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
            *pfDontNext = TRUE;
            goto done;
        }
    }
    else if (fUseSharedFolder)
    {
        // the case to enforce shared folder but edit field is empty
        CertWarningMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH,
                    0,
                    L"");
        uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
        *pfDontNext = TRUE;
        goto done;
    }
    
    fDefaultDir = TRUE;
    hr = GetDefaultDBDirectory(pComp, &pwszDefaultDBDir);
    _JumpIfError(hr, error, "GetDefaultDBDirectory");
    
    // make sure case insensitive
    if (0 != lstrcmpiW(pwszDefaultDBDir, pServer->pwszDBDirectory))
    {
        fDefaultDir = FALSE;
    }
    if (!ValidateAndCreateDirField(
        pComp->hInstance,
        pComp->fUnattended,
        hDlg, 
        pServer->pwszDBDirectory,
        fDefaultDir,
        IDS_WRN_STORELOC_DB_FULLPATH,
        &fExistDB,
        &fIsUNC))
    {
        uiFocus = IDC_STORE_EDIT_DB;
        *pfDontNext = TRUE;
        goto done;
    }
    
    fDefaultDir = TRUE;
    
    // remember default log dir is the same as db
    if (0 != lstrcmpiW(pwszDefaultDBDir, pServer->pwszLogDirectory))
    {
        fDefaultDir = FALSE;
    }
    if (!ValidateAndCreateDirField(
        pComp->hInstance,
        pComp->fUnattended,
        hDlg, 
        pServer->pwszLogDirectory,
        fDefaultDir,
        IDS_WRN_STORELOC_LOG_FULLPATH,
        &fExistLog,
        &fIsUNC))
    {
        uiFocus = IDC_STORE_EDIT_LOG;
        *pfDontNext = TRUE;
        goto done;
    }
    
    wszNotExistingDir[0] = '\0'; // empty string
    if (!fExistSF)
    {
        wcscat(wszNotExistingDir, pServer->pwszSharedFolder);
    }
    if (!fExistDB)
    {
        if ('\0' != wszNotExistingDir[0])
        {
            wcscat(wszNotExistingDir, L"\n");
        }
        wcscat(wszNotExistingDir, pServer->pwszDBDirectory);
    }
    if (!fExistLog)
    {
        if ('\0' != wszNotExistingDir[0])
        {
            wcscat(wszNotExistingDir, L"\n");
        }
        wcscat(wszNotExistingDir, pServer->pwszLogDirectory);
    }
    if ('\0' != wszNotExistingDir[0])
    {
        // skip confirm in unattended mode
        if (!pComp->fUnattended)
        {
            // confirm all here
            if (IDYES != CertMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hDlg,
                            IDS_ASK_CREATE_DIRECTORY,
                            0,
                            MB_YESNO |
                            MB_ICONWARNING |
                            CMB_NOERRFROMSYS,
                            wszNotExistingDir) )
            {
                if (!fExistSF)
                {
                    uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
                }
                else if (!fExistDB)
                {
                    uiFocus = IDC_STORE_EDIT_DB;
                }
                else if (!fExistLog)
                {
                    uiFocus = IDC_STORE_EDIT_LOG;
                }
                *pfDontNext = TRUE;
                goto done;
            }
        }
        if (!fExistSF)
        {
            hr = myCreateNestedDirectories(pServer->pwszSharedFolder);
            if (S_OK != hr)
            {
                CertWarningMessageBox(pComp->hInstance,
                               pComp->fUnattended,
                               hDlg,
                               IDS_ERR_CREATE_DIR,
                               hr,
                               pServer->pwszSharedFolder);
                uiFocus = IDC_STORE_EDIT_SHAREDFOLDER;
                *pfDontNext = TRUE;
                goto done;
            }
        }
        if (!fExistDB)
        {
            hr = myCreateNestedDirectories(pServer->pwszDBDirectory);
            if (S_OK != hr)
            {
                CertWarningMessageBox(pComp->hInstance,
                               pComp->fUnattended,
                               hDlg,
                               IDS_ERR_CREATE_DIR,
                               hr,
                               pServer->pwszDBDirectory);
                uiFocus = IDC_STORE_EDIT_DB;
                *pfDontNext = TRUE;
                goto done;
            }
        }
        if (!fExistLog)
        {
            hr = myCreateNestedDirectories(pServer->pwszLogDirectory);
            if (S_OK != hr)
            {
                CertWarningMessageBox(pComp->hInstance,
                               pComp->fUnattended,
                               hDlg,
                               IDS_ERR_CREATE_DIR,
                               hr,
                               pServer->pwszLogDirectory);
                uiFocus = IDC_STORE_EDIT_LOG;
                *pfDontNext = TRUE;
                goto done;
            }
        }
    }
    hr = ValidateESERestrictions(pServer->pwszDBDirectory);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_WRN_DBSPECIALCHARACTERS,
                        hr,
                        pServer->pwszDBDirectory);
        uiFocus = IDC_STORE_EDIT_DB;
        *pfDontNext = TRUE;
        goto done;
    }

    hr = ValidateESERestrictions(pServer->pwszLogDirectory);
    if (S_OK != hr)
    {
        CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_WRN_DBSPECIALCHARACTERS,
                        hr,
                        pServer->pwszLogDirectory);
        uiFocus = IDC_STORE_EDIT_LOG;
        *pfDontNext = TRUE;
        goto done;
    }

    CSASSERT(!*pfDontNext);

    // directory creation done; now analyze for UNC, sharepath
    if (NULL != pServer->pwszSharedFolder)
    {
        // if not UNC, prompt to change to UNC
        if (!fIsSharedFolderUNC)
        {
#define UNCPATH_TEMPLATE     L"\\\\%ws\\" wszCERTCONFIGSHARENAME
                
            hr = myAddShare(
                wszCERTCONFIGSHARENAME, 
                myLoadResourceString(IDS_CERTCONFIG_FOLDERDESCR), 
                pServer->pwszSharedFolder, 
                TRUE, // overwrite
                NULL);
            _JumpIfError(hr, done, "myAddShare");
            
            // get the local machine name
            WCHAR wszUNCPath[MAX_PATH + ARRAYSIZE(UNCPATH_TEMPLATE)];   // "machine" + UNCPATH_TEMPLATE
            
            hr = myGetMachineDnsName(&pwszComputerName);
            _JumpIfError(hr, done, "myGetMachineDnsName");
            
            // create UNC path
            swprintf(wszUNCPath, UNCPATH_TEMPLATE, pwszComputerName);
            
            // only convert to UNC if this thing is shared
            LocalFree(pServer->pwszSharedFolder);
            pServer->pwszSharedFolder = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                         WSZ_BYTECOUNT(wszUNCPath));
            _JumpIfOutOfMemory(hr, error, pServer->pwszSharedFolder);
            wcscpy(pServer->pwszSharedFolder, wszUNCPath);
        }  // else, user typed in an already-shared UNC path
    }

    
done:
    hr = S_OK;
error:
    if (NULL != pwszDefaultDBDir)
        LocalFree(pwszDefaultDBDir);

    if (NULL != pwszDefaultSF)
        LocalFree(pwszDefaultSF);

    if (NULL != pwszPrompt)
        LocalFree(pwszPrompt);

    if (NULL != pwszComputerName)
        LocalFree(pwszComputerName);

    if (!pComp->fUnattended && uiFocus != 0 && *pfDontNext)
    {
        SetEditFocusAndSelect(GetDlgItem(hDlg, uiFocus), 0, -1);
    }
    return hr;
}


HRESULT
StoreDBShareValidation(
    IN HWND               hDlg,
    IN PER_COMPONENT_DATA *pComp,
    IN WCHAR const        *pwszDir,
    IN BOOL                fDB,  //db dir vs. log dir
    OUT BOOL              *pfDontNext)
{
    HRESULT hr;
    WCHAR *pwszDefaultLogDir = NULL;
    BOOL fDefaultLogPath;
    WCHAR *pwszFileInUse = NULL;
    BOOL fFilesExist;

    static BOOL s_fOverwriteDB = FALSE;
    static BOOL s_fOverwriteLog = FALSE;
    BOOL *pfOverwrite = fDB ? &s_fOverwriteDB : &s_fOverwriteLog;

    // init
    *pfDontNext = FALSE;

    // get default log path which is the same as db

    hr = GetDefaultDBDirectory(pComp, &pwszDefaultLogDir);
    _JumpIfError(hr, error, "GetDefaultDBDirectory");

    fDefaultLogPath = (0 == lstrcmpi(pwszDir, pwszDefaultLogDir));

    hr = myDoDBFilesExistInDir(pwszDir, &fFilesExist, &pwszFileInUse);
    _JumpIfError(hr, error, "myDoDBFilesExistInDir");

    if (NULL != pwszFileInUse)
    {
        CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_WRN_DBFILEINUSE,
                0,
                pwszFileInUse);
        *pfDontNext = TRUE;
        goto done;
    }

    if (!pComp->CA.pServer->fPreserveDB &&
        fFilesExist &&
        !*pfOverwrite &&
        !fDefaultLogPath)
    {
        // log file exists in non-default dir

        if (IDYES != CertMessageBox(
                            pComp->hInstance,
                            pComp->fUnattended,
                            hDlg,
                            IDS_WRN_STORELOC_EXISTINGDB,
                            0,
                            MB_YESNO |
                                MB_DEFBUTTON2 |
                                MB_ICONWARNING |
                                CMB_NOERRFROMSYS,
                            pwszDir))
        {
            *pfDontNext = TRUE;
            goto done;
        }

        // warn only once

        *pfOverwrite = TRUE;
    }

done:
    if (*pfDontNext)
    {
        // set focus
        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_STORE_EDIT_LOG), 0, -1);
    }
    hr = S_OK;

error:
    if (NULL != pwszFileInUse)
    {
        LocalFree(pwszFileInUse);
    }
    if (NULL != pwszDefaultLogDir)
    {
        LocalFree(pwszDefaultLogDir);
    }
    return hr;
}


HRESULT
FinishDirectoryBrowse(
    HWND    hDlg,
    int     idEdit)
{
    HRESULT  hr = S_FALSE;
    WCHAR dirInitName[MAX_PATH];
    WCHAR dirName[MAX_PATH];

    GetWindowText(GetDlgItem(hDlg, idEdit), dirInitName, MAX_PATH);
    if (BrowseForDirectory(
        GetParent(hDlg),
        dirInitName,
        dirName,
        MAX_PATH,
        NULL,
        TRUE))
    {
        SetDlgItemText(hDlg, idEdit, dirName);
        hr = S_OK;
    }
    return hr;
}

HRESULT
HookStorePageStrings(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT    hr;

    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_STORE_EDIT_SHAREDFOLDER:
                pPageString->ppwszString = &(pServer->pwszSharedFolder);
            break;
            case IDC_STORE_EDIT_DB:
                pPageString->ppwszString = &(pServer->pwszDBDirectory);
            break;
            case IDC_STORE_EDIT_LOG:
                pPageString->ppwszString = &(pServer->pwszLogDirectory);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

HRESULT
InitStoreWizControls(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT  hr;

    // now make page strings complete
    hr = HookStorePageStrings(hDlg, pPageString, pServer);
    _JumpIfError(hr, error, "HookStorePageStrings");

    SendDlgItemMessage(hDlg,
        IDC_STORE_USE_SHAREDFOLDER,
        BM_SETCHECK,
        (WPARAM)((NULL != pServer->pwszSharedFolder) ?
                 BST_CHECKED : BST_UNCHECKED),
        (LPARAM)0);

    if (!pServer->fUseDS && (NULL != pServer->pwszSharedFolder))
    {
        // no DS, disable shared folder check to force it
        EnableWindow(GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER), FALSE);
    }

    hr = StartWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandlePreservingDB(
    HWND                hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    HWND hwndSF = GetDlgItem(hDlg, IDC_STORE_EDIT_SHAREDFOLDER);
    HWND hwndDB = GetDlgItem(hDlg, IDC_STORE_EDIT_DB);
    HWND hwndLog = GetDlgItem(hDlg, IDC_STORE_EDIT_LOG);
    BOOL    fEnable = TRUE;
    BOOL    fEnableSharedFolder = TRUE;
    WCHAR    *pwszExistingSharedFolder = NULL;
    WCHAR    *pwszExistingDBDirectory = NULL;
    WCHAR    *pwszExistingLogDirectory = NULL;


    if (pServer->fPreserveDB)
    {
        if (!pServer->fUNCPathNotFound)
        {
            // get shared folder path
            hr = myGetCertRegStrValue(NULL, NULL, NULL,
                     wszREGDIRECTORY, &pwszExistingSharedFolder);
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                // optional value
                hr = S_OK;
                pwszExistingSharedFolder = NULL;
            }
            _JumpIfError(hr, error, "myGetCertRegStrValue");
            fEnableSharedFolder = FALSE;
        }
        else
        {
            pwszExistingSharedFolder = pServer->pwszSharedFolder;
        }

        // get existing db path
        hr = myGetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBDIRECTORY, &pwszExistingDBDirectory);
        _JumpIfError(hr, error, "myGetCertRegStrValue");

        hr = myGetCertRegStrValue(NULL, NULL, NULL,
                 wszREGDBLOGDIRECTORY, &pwszExistingLogDirectory);
        _JumpIfError(hr, error, "myGetCertRegStrValue");

        // fill edit fields
        SetWindowText(hwndSF, pwszExistingSharedFolder);
        SetWindowText(hwndDB, pwszExistingDBDirectory);
        SetWindowText(hwndLog, pwszExistingLogDirectory);

        // disable them
        fEnable = FALSE;
    }
    EnableWindow(hwndSF, fEnableSharedFolder);
    EnableWindow(hwndDB, fEnable);
    EnableWindow(hwndLog, fEnable);

    hr = S_OK;
error:
    if (NULL != pwszExistingSharedFolder &&
        pwszExistingSharedFolder != pServer->pwszSharedFolder)
    {
        LocalFree(pwszExistingSharedFolder);
    }
    if (NULL != pwszExistingDBDirectory)
    {
        LocalFree(pwszExistingDBDirectory);
    }
    if (NULL != pwszExistingLogDirectory)
    {
        LocalFree(pwszExistingLogDirectory);
    }
    return hr;
}

HRESULT
HandleStoreWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    PAGESTRINGS       *pPageString)
{
    HRESULT hr;
    HWND    hwndDB;
    BOOL fEnableKeepDB = FALSE;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server.

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_STORE_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    CSASSERT(NULL != pServer->pwszKeyContainerName);

    hwndDB = GetDlgItem(hDlg, IDC_STORE_KEEPDB);

    if (NULL != pServer->pccExistingCert)
    {
        // determine existing db status

        hr = myDoDBFilesExist(
                        pServer->pwszSanitizedName,
                        &fEnableKeepDB,
                        NULL);
        _JumpIfError(hr, error, "myDoDBFilesExist");
    }
    else
    {
        // can't use db
        pServer->fPreserveDB = FALSE;
        SendMessage(hwndDB, BM_SETCHECK, (WPARAM)BST_UNCHECKED, (LPARAM)0);
        HandlePreservingDB(hDlg, pComp);
    }
    // enable/disable the control
    EnableSharedFolderControls(hDlg, NULL != pServer->pwszSharedFolder);
    EnableWindow(hwndDB, fEnableKeepDB);

done:
    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleStoreWizNextOrBack(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    PER_COMPONENT_DATA *pComp,
    int                 iWizBN)
{
    HRESULT hr;
    HWND    hwndCtrl = NULL;
    WCHAR  *pwszFile = NULL;
    WCHAR const *pwszCertName;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    BOOL     fDontNext = FALSE;
    BOOL     fGoBack = FALSE;
    BOOL     fUseSharedFolder;
    HCURSOR hPrevCur;

    hr = FinishWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    // make sure at least one way to publish ca
    CSASSERT(NULL != pServer->pwszSharedFolder || pComp->CA.pServer->fUseDS);

    // get shared folder check state
    fUseSharedFolder = (BST_CHECKED == SendMessage(
                        GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER),
                        BM_GETCHECK, 0, 0));

    if (!fUseSharedFolder && NULL != pServer->pwszSharedFolder)
    {
        //don't collect shared folder from edit control
        LocalFree(pServer->pwszSharedFolder);
        pServer->pwszSharedFolder = NULL;
    }

    hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    hr = StorePageValidation(hDlg, pComp, &fDontNext);
    SetCursor(hPrevCur);
    _JumpIfError(hr, error, "StorePageValidation");

    if (fDontNext)
    {
        goto done;
    }

    // validate existing db sharing here

    hr = StoreDBShareValidation(
                        hDlg,
                        pComp,
                        pComp->CA.pServer->pwszDBDirectory,
                        TRUE,  //db dir
                        &fDontNext);
    _JumpIfError(hr, error, "StoreDBShareValidation");

    if (fDontNext)
    {
        goto done;
    }

    if (0 != lstrcmpi(
                pComp->CA.pServer->pwszDBDirectory,
                pComp->CA.pServer->pwszLogDirectory))
    {
        hr = StoreDBShareValidation(
                            hDlg,
                            pComp,
                            pComp->CA.pServer->pwszLogDirectory,
                            FALSE, //log dir
                            &fDontNext);
        _JumpIfError(hr, error, "StoreDBShareValidation");

        if (fDontNext)
        {
            goto done;
        }
    }

    hr = myBuildPathAndExt(
                    pComp->CA.pServer->pwszDBDirectory,
                    pServer->pwszSanitizedName,
                    wszDBFILENAMEEXT,
                    &pwszFile);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    // make sure path fits

    if (MAX_PATH <= wcslen(pwszFile))
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_CANAME,
            S_OK,
            pwszFile);
        // make it go back
        fGoBack = TRUE;
        fDontNext = TRUE;
        goto done;
    }
    LocalFree(pwszFile);
    pwszFile = NULL;

    hr = myBuildPathAndExt(
                    pComp->CA.pServer->pwszLogDirectory,
                    TEXT(szDBBASENAMEPARM) L"00000",
                    wszLOGFILENAMEEXT,
                    &pwszFile);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    // make sure path fits

    if (MAX_PATH <= wcslen(pwszFile))
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_DIRECTORY,
            S_OK,
            pwszFile);

        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_STORE_EDIT_LOG), 0, -1);
        fDontNext = TRUE;
        goto done;
    }
    LocalFree(pwszFile);
    pwszFile = NULL;

    hr = csiBuildCACertFileName(
                        pComp->hInstance,
                        hDlg,
                        pComp->fUnattended,
                        pServer->pwszSharedFolder,
                        pServer->pwszSanitizedName,
                        L".crt",
                        0, // CANAMEIDTOICERT(pServer->dwCertNameId),
                        &pwszFile);
    _JumpIfError(hr, error, "csiBuildCACertFileName");

    // make sure path fit
    if (MAX_PATH <= wcslen(pwszFile) + cwcSUFFIXMAX)
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_CANAME,
            S_OK,
            pwszFile);
        // make it go back
        fGoBack = TRUE;
        fDontNext = TRUE;
        goto done;
    }
    if (NULL != pServer->pwszCACertFile)
    {
        // free old one
        LocalFree(pServer->pwszCACertFile);
    }
    pServer->pwszCACertFile = pwszFile;
    pwszFile = NULL;

    if (IsRootCA(pServer->CAType))
    {
        hPrevCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hDlg, 
                 wszW3SVCNAME,
                 TRUE,
                 TRUE, // confirmation
                 IDS_STOP_W3SVC,
                 &g_fW3SvcRunning);
        SetCursor(hPrevCur);
        if (S_OK != hr)
        {
            if (E_ABORT == hr)
            {
                fDontNext = TRUE;
                goto done;
            }
            _JumpError(hr, error, "StartAndStopService");
        }
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
        if (fGoBack)
        {
            PropSheet_PressButton(GetParent(hDlg), PSBTN_BACK);
            pServer->LastWiz = ENUM_WIZ_STORE;
        }
    }
    else
    {
        // continue to next
        pServer->LastWiz = ENUM_WIZ_STORE;
    }
    hr = S_OK;

error:
    if (NULL != pwszFile)
    {
        LocalFree(pwszFile);
    }
    return hr;
}

HRESULT
HandleUseSharedFolder(
    IN HWND    hDlg,
    IN OUT PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    // get shared folder check state
    BOOL fUseSharedFolder = (BST_CHECKED == SendMessage(
                             GetDlgItem(hDlg, IDC_STORE_USE_SHAREDFOLDER),
                             BM_GETCHECK, 0, 0));

    if (!fUseSharedFolder && !pComp->CA.pServer->fUseDS)
    {
        // must check at least one, force unchange
        fUseSharedFolder = TRUE;
        SendDlgItemMessage(hDlg, IDC_STORE_USE_SHAREDFOLDER,
            BM_SETCHECK, (WPARAM)BST_CHECKED, (LPARAM)0);
    }
    hr = EnableSharedFolderControls(hDlg, fUseSharedFolder);
//    _JumpIfError(hr, error, "EnableSharedFolderControls");
    _PrintIfError(hr, "EnableSharedFolderControls");

//    hr = S_OK;
//error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizStorePageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for storage location
//-------------------------------------------------------------------------

INT_PTR
WizStorePageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    // keep scope of following array inside
    static PAGESTRINGS saStoreString[] =
    {
        {
            IDC_STORE_EDIT_SHAREDFOLDER,
            IDS_LOG_SHAREDFOLDER,
            0,
            0,
            MAX_PATH,
            NULL,
        },
        {
            IDC_STORE_EDIT_DB,
            IDS_LOG_DBDIR,
            0,
            0,
            MAX_PATH,
            NULL,
        },
        {
            IDC_STORE_EDIT_LOG,
            IDS_LOG_DBLOGDIR,
            0,
            0,
            MAX_PATH,
            NULL,
        },
// you need to add code in HookStoreStrings if adding more...
        {
            0,
            0,
            0,
            0,
            0,
            NULL,
        }
    };

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (LONG)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitStoreWizControls(hDlg, saStoreString, pComp->CA.pServer);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_STORE_USE_SHAREDFOLDER:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleUseSharedFolder(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_STORE_KEEPDB:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fPreserveDB = !pComp->CA.pServer->fPreserveDB;
            pComp->hrContinue = HandlePreservingDB(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_STORE_SHAREDBROWSE:
            FinishDirectoryBrowse(hDlg, IDC_STORE_EDIT_SHAREDFOLDER);
            break;

        case IDC_STORE_DBBROWSE:
            FinishDirectoryBrowse(hDlg, IDC_STORE_EDIT_DB);
            break;

        case IDC_STORE_LOGBROWSE:
            FinishDirectoryBrowse(hDlg, IDC_STORE_EDIT_LOG);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_STORE_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleStoreWizActive(hDlg, pComp,
                saStoreString);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_STORE_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleStoreWizNextOrBack(hDlg,
                saStoreString, pComp, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_STORE_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleStoreWizNextOrBack(hDlg,
                saStoreString, pComp, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

HRESULT
EnableCARequestControls(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // Online req
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_CANAME),
        !pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_COMPUTERNAME),
        !pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_CA_BROWSE),
        !pServer->fSaveRequestAsFile && pServer->fCAsExist);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_CNLABEL),
        !pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_PCALABEL),
        !pServer->fSaveRequestAsFile);

    // File req
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_FILE),
        pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_FILE_BROWSE),
        pServer->fSaveRequestAsFile);
    EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_FILELABEL),
        pServer->fSaveRequestAsFile);

    if (pServer->fSaveRequestAsFile)
    {
        SetFocus(GetDlgItem(hDlg, IDC_CAREQUEST_FILE));
    }
    else
    {
        SetFocus(GetDlgItem(hDlg, IDC_CAREQUEST_CANAME));
    }


    hr = S_OK;
//error:
    return hr;
}

HRESULT
BuildRequestFileName(
    IN WCHAR const *pwszCACertFile,
    OUT WCHAR     **ppwszRequestFile)
{
#define wszREQEXT  L".req"

    HRESULT hr;
    WCHAR const *pwszStart;
    WCHAR const *pwszEnd;
    WCHAR *pwszRequestFile = NULL;

    CSASSERT(NULL != pwszCACertFile);

    // derive request file name
    pwszStart = pwszCACertFile;
    pwszEnd = wcsrchr(pwszStart, L'.');
    if (pwszEnd == NULL)
    {
        // set to end of entire string -- no '.' found
        pwszEnd = &pwszStart[wcslen(pwszStart)];
    }

    pwszRequestFile = (WCHAR*)LocalAlloc(LMEM_FIXED,
        (SAFE_SUBTRACT_POINTERS(pwszEnd, pwszStart) + 
         wcslen(wszREQEXT) + 1) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, pwszRequestFile);

    CopyMemory(pwszRequestFile, pwszStart,
            SAFE_SUBTRACT_POINTERS(pwszEnd, pwszStart) * sizeof(WCHAR));
    wcscpy(pwszRequestFile + SAFE_SUBTRACT_POINTERS(pwszEnd, pwszStart), wszREQEXT);

    // return
    *ppwszRequestFile = pwszRequestFile;
    pwszRequestFile = NULL;

    hr = S_OK;
error:
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    return hr;
}

HRESULT
StartCARequestPage(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{

    HRESULT hr;

    if (NULL == pServer->pwszRequestFile)
    {
    hr = BuildRequestFileName(
             pServer->pwszCACertFile,
             &pServer->pwszRequestFile);
    _JumpIfError(hr, error, "BuildRequestFileName");
    }

    hr = StartWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

    hr = S_OK;
error:
    return hr;
}


HRESULT
GetRequestFileName(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    WCHAR     *pwszFileIn = NULL;
    WCHAR     *pwszFileOut = NULL;
    HWND       hCtrl = GetDlgItem(hDlg, IDC_CAREQUEST_FILE);

    hr = myUIGetWindowText(hCtrl, &pwszFileIn);
    _JumpIfError(hr, error, "myUIGetWindowText");

    hr = myGetSaveFileName(
             hDlg,
             pComp->hInstance,
             IDS_REQUEST_SAVE_TITLE,
             IDS_REQUEST_FILE_FILTER,
             IDS_REQUEST_FILE_DEFEXT,
             OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT,
             pwszFileIn,
             &pwszFileOut);
    _JumpIfError(hr, error, "myGetSaveFileName");

    if (NULL != pwszFileOut)
    {
        SetWindowText(hCtrl, pwszFileOut);
    }

    hr = S_OK;
error:
    if (NULL != pwszFileOut)
    {
        LocalFree(pwszFileOut);
    }
    if (NULL != pwszFileIn)
    {
        LocalFree(pwszFileIn);
    }
    return hr;
}

HRESULT
HookCARequestPageStrings(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_CAREQUEST_CANAME:
                pPageString->ppwszString = &(pServer->pwszParentCAName);
            break;
            case IDC_CAREQUEST_COMPUTERNAME:
                pPageString->ppwszString = &(pServer->pwszParentCAMachine);
            break;
            case IDC_CAREQUEST_FILE:
                pPageString->ppwszString = &(pServer->pwszRequestFile);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

CERTSRVUICASELECTION g_CARequestUICASelection =
                         {NULL, NULL, NULL, NULL, NULL, ENUM_UNKNOWN_CA, false};

HRESULT
InitCARequestWizControls(
    HWND               hDlg,
    PAGESTRINGS       *pSubmitPageString,
    PAGESTRINGS       *pFilePageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT  hr;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    HWND     hwndCtrl;

    // now make page strings complete
    hr = HookCARequestPageStrings(hDlg, pSubmitPageString, pServer);
    _JumpIfError(hr, error, "HookCARequestPageStrings");

    hr = HookCARequestPageStrings(hDlg, pFilePageString, pServer);
    _JumpIfError(hr, error, "HookCARequestPageStrings");

    if (!(SETUPOP_STANDALONE & pComp->Flags))
    {
        // nt base setup
        // disable online submit
        EnableWindow(GetDlgItem(hDlg, IDC_CAREQUEST_SUBMITTOCA), FALSE);
        SendMessage(GetDlgItem(hDlg, IDC_CAREQUEST_SUBMITTOCA),
            BM_SETCHECK,
            (WPARAM) BST_UNCHECKED,
            (LPARAM) 0);
        // only save as file
        pServer->fSaveRequestAsFile = TRUE;
        SendMessage(GetDlgItem(hDlg, IDC_CAREQUEST_SAVETOFILE),
            BM_SETCHECK,
            (WPARAM) BST_CHECKED,
            (LPARAM) 0);
    }
    else
    {
        // set online submit as default
        pServer->fSaveRequestAsFile = FALSE;
        SendMessage(GetDlgItem(hDlg, IDC_CAREQUEST_SUBMITTOCA),
            BM_CLICK,
            (WPARAM) 0,
            (LPARAM) 0);

        hr = myInitUICASelectionControls(
				&g_CARequestUICASelection,
				pComp->hInstance,
				hDlg,
				GetDlgItem(hDlg, IDC_CAREQUEST_CA_BROWSE),
				GetDlgItem(hDlg, IDC_CAREQUEST_COMPUTERNAME),
				GetDlgItem(hDlg, IDC_CAREQUEST_CANAME),
				csiIsAnyDSCAAvailable(),
				&pServer->fCAsExist);
        _JumpIfError(hr, error, "myInitUICASelectionControls");

    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleCARequestWizActive(
    HWND                hDlg,
    PAGESTRINGS        *pPageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT                   hr;
    DWORD                     dwCACount;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;
    CASERVERSETUPINFO        *pServer = pComp->CA.pServer;
    BOOL                      fMatchAll = IsEverythingMatched(pServer);

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server, or
    // we are not installing a subordinate, or
    // the advanced page already selected a matching key and cert

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) ||
        IsRootCA(pServer->CAType) ||
        fMatchAll)
    {
        // disable page
        CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    EnableCARequestControls(hDlg, pComp);

    hr = StartCARequestPage(hDlg, pPageString, pServer);
    _JumpIfError(hr, error, "StartCARequestPage");

done:
    hr = S_OK;
error:
    if (NULL != pCAContext)
    {
        CryptUIDlgFreeCAContext(pCAContext);
    }
    return hr;
}

HRESULT
ConvertEditControlFullFilePath(
    HWND                hEdtCtrl)
{
    HRESULT  hr;
    WCHAR    *pwszPath = NULL;
    WCHAR    wszFullPath[MAX_PATH];
    WCHAR    *pwszNotUsed;
    DWORD    dwSize = 0;

    hr = myUIGetWindowText(hEdtCtrl, &pwszPath);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL == pwszPath)
    {
        // empty path, done
        goto done;
    }

    dwSize = GetFullPathName(pwszPath,
                     ARRAYSIZE(wszFullPath),
                     wszFullPath,
                     &pwszNotUsed);
    CSASSERT(ARRAYSIZE(wszFullPath) > dwSize);

    if (0 == dwSize)
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetFullPathName");
    }

    // get full path, set it back to edit control
    SetWindowText(hEdtCtrl, wszFullPath);

done:
    hr = S_OK;
error:
    if (NULL != pwszPath)
    {
        LocalFree(pwszPath);
    }
    return hr;
}

HRESULT
HandleCARequestWizNextOrBack(
    HWND                hDlg,
    PAGESTRINGS        *pPageString,
    PER_COMPONENT_DATA  *pComp,
    int                 iWizBN)
{
    HRESULT  hr;
    CASERVERSETUPINFO  *pServer = pComp->CA.pServer;
    BOOL     fDontNext = FALSE;
    BOOL     fValid;

    if (pServer->fSaveRequestAsFile)
    {
        // convert request file to full path
        hr = ConvertEditControlFullFilePath(
                 GetDlgItem(hDlg, IDC_CAREQUEST_FILE));
        _JumpIfError(hr, error, "ConvertEditControlFullFilePath");

        CSASSERT(pServer->pwszSanitizedName);
        CSASSERT(pServer->pwszKeyContainerName);
        
        hr = mySetCertRegStrValue(
            pServer->pwszSanitizedName,
            NULL,
            NULL,
            wszREGREQUESTKEYCONTAINER,
            pServer->pwszKeyContainerName);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", wszREGREQUESTKEYCONTAINER);
    }

    hr = FinishWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    if (!pServer->fSaveRequestAsFile && NULL==pServer->pccExistingCert)
    {
        // online case
        hr = myUICASelectionValidation(&g_CARequestUICASelection, &fValid);
        _JumpIfError(hr, error, "myUICASelectionValidation");
        if (!fValid)
        {
            fDontNext = TRUE;
            goto done;
        }
    }

    hr = WizardPageValidation(pComp->hInstance, pComp->fUnattended,
             hDlg, pPageString);
    if (S_OK != hr)
    {
        fDontNext = TRUE;
        goto done;
    }

    if (pServer->fSaveRequestAsFile)
    {
        // validate dir path existance of the request file
        WCHAR *pwszLastSlash = wcsrchr(pServer->pwszRequestFile, L'\\');
        CSASSERT(NULL != pwszLastSlash);
        if (NULL != pwszLastSlash)
        {
            // make request file path into a dir path
            pwszLastSlash[0] = L'\0';
            if (DE_DIREXISTS != DirExists(pServer->pwszRequestFile) ||
                L'\0' == pwszLastSlash[1])
            {
                // bring request file path back
                pwszLastSlash[0] = L'\\';
                CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_CAREQUEST_REQUESTFILEPATH_MUSTEXIST,
                        0,
                        pServer->pwszRequestFile);
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_CAREQUEST_FILE), 0, -1);
                fDontNext = TRUE;
                goto done;
            }    
            // bring request file path back
            pwszLastSlash[0] = L'\\';
        }

        // Fail if a directory with the same name already exists
        if(DE_DIREXISTS == DirExists(pServer->pwszRequestFile))
        {
                CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_CAREQUEST_REQUESTFILEPATH_DIREXISTS,
                        0,
                        pServer->pwszRequestFile);
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_CAREQUEST_FILE), 0, -1);
                fDontNext = TRUE;
                goto done;
        }

    }

    hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hDlg, 
                 wszW3SVCNAME,
                 TRUE,
                 TRUE,
                 IDS_STOP_W3SVC,
                 &g_fW3SvcRunning);
    if (S_OK != hr)
    {
        if (E_ABORT == hr)
        {
            fDontNext = TRUE;
            goto done;
        }
        _JumpError(hr, error, "StartAndStopService");
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    else
    {
        pServer->LastWiz = ENUM_WIZ_REQUEST;
    }
    hr = S_OK;
error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizCARequestPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for CA Request wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizCARequestPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PAGESTRINGS       *pPageString;
    PER_COMPONENT_DATA *pComp = NULL;

    static BOOL  s_fComputerChange = FALSE;

    // keep the following in local scope
    static PAGESTRINGS saCARequestSubmit[] =
    {
        {
            IDC_CAREQUEST_COMPUTERNAME,
            IDS_LOG_COMPUTER,
            IDS_COMPUTERNULLSTRERR,
            IDS_COMPUTERLENSTRERR,
            MAX_PATH,
            NULL,
        },
        {
            IDC_CAREQUEST_CANAME,
            IDS_LOG_CANAME,
            IDS_CANULLSTRERR,
            IDS_CALENSTRERR,
            cchCOMMONNAMEMAX,
            NULL,
        },
// add more code in HookCARequestPageStrings if you add
        {
            0,
            0,
            0,
            0,
            0,
            NULL
        }
    };

    static PAGESTRINGS saCARequestFile[] =
    {
        {
            IDC_CAREQUEST_FILE,
            IDS_LOG_REQUESTFILE,
            IDS_REQUESTFILENULLSTRERR,
            IDS_REQUESTFILELENSTRERR,
            MAX_PATH,
            NULL,
        },
// add more code in HookCARequestPageStrings if you add
        {
            0,
            0,
            0,
            0,
            0,
            NULL,
        }
    };

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitCARequestWizControls(hDlg,
                                 saCARequestSubmit,
                                 saCARequestFile,
                                 pComp);
        _ReturnIfWizError(pComp->hrContinue);
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CAREQUEST_SAVETOFILE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fSaveRequestAsFile = TRUE;
            pComp->hrContinue = EnableCARequestControls(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_SUBMITTOCA:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->CA.pServer->fSaveRequestAsFile = FALSE;
            pComp->hrContinue = EnableCARequestControls(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_CA_BROWSE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = myUICAHandleCABrowseButton(
                      &g_CARequestUICASelection,
                      csiIsAnyDSCAAvailable(),
                      IDS_CA_PICKER_TITLE,
                      IDS_CA_PICKER_PROMPT,
                      NULL);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_FILE_BROWSE:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = GetRequestFileName(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_CANAME:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = myUICAHandleCAListDropdown(
                                    (int)HIWORD(wParam), // notification
                                    &g_CARequestUICASelection,
                                    &s_fComputerChange);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CAREQUEST_COMPUTERNAME:
            switch ((int)HIWORD(wParam))
            {
                case EN_CHANGE: // edit changed
                    s_fComputerChange = TRUE;
                    break;
            }
            break;

        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZACTIVE);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleCARequestWizActive(hDlg,
                saCARequestFile, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pPageString = saCARequestSubmit;
            if (pComp->CA.pServer->fSaveRequestAsFile)
            {
                pPageString = saCARequestFile;
            }
            pComp->hrContinue = HandleCARequestWizNextOrBack(hDlg,
                pPageString, pComp, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_CAREQUEST_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pPageString = saCARequestSubmit;
            if (pComp->CA.pServer->fSaveRequestAsFile)
            {
                pPageString = saCARequestFile;
            }
            pComp->hrContinue = HandleCARequestWizNextOrBack(hDlg,
                pPageString, pComp, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;

    }
    return TRUE;
}

HRESULT
HookClientPageStrings(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CAWEBCLIENTSETUPINFO *pClient)
{
    HRESULT    hr;

    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_CLIENT_COMPUTERNAME:
                pPageString->ppwszString = &(pClient->pwszWebCAMachine);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

CERTSRVUICASELECTION g_WebClientUICASelection =
                         {NULL, NULL, NULL, NULL, NULL, ENUM_UNKNOWN_CA, true};

HRESULT
InitClientWizControls(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr;
    BOOL fCAsExist;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    hr = HookClientPageStrings(hDlg, pPageString, pClient);
    _JumpIfError(hr, error, "HookClientPageStrings");

    hr = WizPageSetTextLimits(hDlg, pPageString);
    _JumpIfError(hr, error, "WizPageSetTextLimits");

    pClient->fUseDS = FALSE;
    if (IsDSAvailable())
    {
        pClient->fUseDS = csiIsAnyDSCAAvailable();
    }

    hr = myInitUICASelectionControls(
			    &g_WebClientUICASelection,
			    pComp->hInstance,
			    hDlg,
			    GetDlgItem(hDlg, IDC_CLIENT_BROWSECNFG),
			    GetDlgItem(hDlg, IDC_CLIENT_COMPUTERNAME),
			    GetDlgItem(hDlg, IDC_CLIENT_CANAME),
			    pClient->fUseDS,
			    &fCAsExist);
    _JumpIfError(hr, error, "myInitUICASelectionControls");

    hr = S_OK;
error:
    return hr;
}

HRESULT
GetCAConfigInfo(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT   hr = S_OK;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;

    // free old shared folder always
    if (NULL != pClient->pwszSharedFolder)
    {
        // free old
        LocalFree(pClient->pwszSharedFolder);
        pClient->pwszSharedFolder = NULL;
    }

    hr = myUICAHandleCABrowseButton(
             &g_WebClientUICASelection,
             pClient->fUseDS,
             IDS_CONFIG_PICKER_TITLE,
             IDS_CONFIG_PICKER_PROMPT,
             &pClient->pwszSharedFolder);
    _JumpIfError(hr, error, "myUICAHandleCABrowseButton");

error:
    return hr;
}

HRESULT
HandleClientWizNextOrBack(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    PER_COMPONENT_DATA *pComp,
    int                iWizBN)
{
    HWND     hwndCtrl;
    HRESULT  hr;
    CAWEBCLIENTSETUPINFO *pClient = pComp->CA.pClient;
    BOOL     fDontNext = FALSE;
    WCHAR   *pwszCAName = NULL;
    WCHAR   *pwszSanitizedCAName;
    int      nItem;
    int      len;
    BOOL     fValid;
    BOOL     fCoInit = FALSE;
//    CAINFO  *pCAInfo = NULL;
    HCURSOR hPrevCur;

    hr = FinishWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    hr = myUICASelectionValidation(&g_WebClientUICASelection, &fValid);
    _JumpIfError(hr, error, "myUICASelectionValidation");
    if (!fValid)
    {
        fDontNext = TRUE;
        goto done;
    }

    // at this point, g_WebClientUICASelection.CAType is guaranteed to be filled in     
    hr = WizardPageValidation(pComp->hInstance, pComp->fUnattended,
             hDlg, pPageString);
    if (S_OK != hr)
    {
        fDontNext = TRUE;
        goto done;
    }

    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_CLIENT_CANAME), &pwszCAName);
    _JumpIfError(hr, error, "myUIGetWindowText");
    CSASSERT(NULL != pwszCAName);


    if (NULL != pClient->pwszWebCAName)
    {
        // free old one
        LocalFree(pClient->pwszWebCAName);
    }
    pClient->pwszWebCAName = pwszCAName;
    pwszCAName = NULL;
    hr = mySanitizeName(pClient->pwszWebCAName, &pwszSanitizedCAName);
    _JumpIfError(hr, error, "mySanitizeName");
    if (NULL != pClient->pwszSanitizedWebCAName)
    {
        // free old one
        LocalFree(pClient->pwszSanitizedWebCAName);
    }
    pClient->pwszSanitizedWebCAName = pwszSanitizedCAName;
//    pClient->WebCAType = pCAInfo->CAType;
    pClient->WebCAType = g_WebClientUICASelection.CAType;

    hr = StartAndStopService(pComp->hInstance,
                 pComp->fUnattended,
                 hDlg, 
                 wszW3SVCNAME,
                 TRUE,
                 TRUE,
                 IDS_STOP_W3SVC,
                 &g_fW3SvcRunning);
    if (S_OK != hr)
    {
        if (E_ABORT == hr)
        {
            fDontNext = TRUE;
            goto done;
        }
        _JumpError(hr, error, "StartAndStopService");
    }

done:
    hr = S_OK;
error:
    if (fCoInit)
    {
        CoUninitialize();
    }
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    if (NULL != pwszCAName)
    {
        LocalFree(pwszCAName);
    }
//    if (NULL != pCAInfo)
    {
//        LocalFree(pCAInfo);
    }
    return hr;
}

HRESULT
HandleClientWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    PAGESTRINGS       *pPageString)
{
    HRESULT hr;

    // Suppress this wizard page if
    // we've already seen an error, or
    // the server is or will be installed, or
    // the client isn't or won't be installed, or
    // ther will be no change in client and server install states.

    if ((IS_SERVER_ENABLED & pComp->dwInstallStatus) ||
        !(IS_CLIENT_ENABLED & pComp->dwInstallStatus) ||
        !((IS_CLIENT_CHANGE | IS_SERVER_CHANGE) & pComp->dwInstallStatus))
    {
        // disable page
        CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }

    // load id info
    hr = StartWizardPageEditControls(hDlg, pPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

done:
    hr = S_OK;
error:
    return hr;
}

//+------------------------------------------------------------------------
//  Function:   WizClientPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure for CA Client wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizClientPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    static BOOL  s_fComputerChange = FALSE;

    static PAGESTRINGS saClientPageString[] =
    {
        {
            IDC_CLIENT_COMPUTERNAME,
            IDS_LOG_COMPUTER,
            IDS_CLIENT_NOCOMPUTER,
            IDS_COMPUTERLENSTRERR,
            MAX_PATH,
            NULL,
        },
// you need to add code in HookClientPageStrings if adding more...
        {
            0,
            0,
            0,
            0,
            0,
            NULL
        }
    };

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (LONG)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitClientWizControls(hDlg,
            saClientPageString, pComp);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CLIENT_BROWSECNFG:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = GetCAConfigInfo(hDlg, pComp);
            _ReturnIfWizError(pComp->hrContinue);
            break;
        case IDC_CLIENT_CANAME:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = myUICAHandleCAListDropdown(
                                    (int)HIWORD(wParam),
                                    &g_WebClientUICASelection,
                                    &s_fComputerChange);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case IDC_CLIENT_COMPUTERNAME:
            switch ((int)HIWORD(wParam))
            {
                case EN_CHANGE: // edit change
                    s_fComputerChange = TRUE;
                    break;
            }
            break;

        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {

        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleClientWizActive(hDlg, pComp, saClientPageString);
             _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            // enable back     
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
            pComp->hrContinue = HandleClientWizNextOrBack(hDlg,
                saClientPageString, pComp, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_CLIENT_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleClientWizNextOrBack(hDlg,
                saClientPageString, pComp, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;

    }
    return TRUE;
}

static CFont s_cBigBoldFont;
static BOOL s_fBigBoldFont;

BOOL ocmWiz97SetupFonts(HWND hwnd)
{
    BOOL        bReturn = FALSE;
    //
    // Create the fonts we need based on the dialog font
    //
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof (ncm);
    SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    LOGFONT BigBoldLogFont  = ncm.lfMessageFont;

    //
    // Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;

    WCHAR       largeFontSizeString[24];
    INT         largeFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if ( !::LoadString (g_hInstance, IDS_LARGEFONTNAME,
                        BigBoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
                CSASSERT (0);
        lstrcpy (BigBoldLogFont.lfFaceName, L"MS Shell Dlg");
    }

    if ( ::LoadStringW (g_hInstance, IDS_LARGEFONTSIZE,
                        largeFontSizeString, ARRAYSIZE(largeFontSizeString)) ) 
    {
        largeFontSize = wcstoul (largeFontSizeString, NULL, 10);
    } 
    else 
    {
        CSASSERT (0);
        largeFontSize = 12;
    }

    HDC hdc = GetDC(hwnd);

    if (hdc)
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * largeFontSize / 72);
        BOOL    bBigBold = s_cBigBoldFont.CreateFontIndirect (&BigBoldLogFont);

        ReleaseDC(hwnd, hdc);

        if ( bBigBold )
             bReturn = TRUE;
    }

    return bReturn;
}

HFONT ocmWiz97GetBigBoldFont(HWND hwnd)
{
   if (FALSE == s_fBigBoldFont)
   {
       if (!ocmWiz97SetupFonts(hwnd))
           return NULL;

       s_fBigBoldFont = TRUE;
   }

   return s_cBigBoldFont;
}

//+------------------------------------------------------------------------
//  Function:   WizWelcomePageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure welcome wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizWelcomePageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;
    HFONT hf;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (LONG)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;

        // set wizard 97 fonts
        hf = ocmWiz97GetBigBoldFont(hDlg);
        if (NULL != hf)
            SendMessage(GetDlgItem(hDlg, IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)hf, MAKELPARAM(TRUE, 0));

        _ReturnIfWizError(pComp->hrContinue);

        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            case PSN_SETACTIVE:
                // disable back button
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                pComp = _GetCompDataOrReturn(pComp, hDlg);
                _DisableWizDisplayIfError(pComp, hDlg);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//+------------------------------------------------------------------------
//  Function:   WizFinalPageDlgProc(. . . .)
//
//  Synopsis:   Dialog procedure final wiz-page
//-------------------------------------------------------------------------

INT_PTR
WizFinalPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;
    HFONT hf;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (LONG)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)((PROPSHEETPAGE*)lParam)->lParam;

        hf = ocmWiz97GetBigBoldFont(hDlg);
        if (NULL != hf)
            SendMessage(GetDlgItem(hDlg,IDC_TEXT_BIGBOLD), WM_SETFONT, (WPARAM)hf, MAKELPARAM(TRUE, 0));

        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
            case PSN_SETACTIVE:
                // enable finish button
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);
                pComp = _GetCompDataOrReturn(pComp, hDlg);
                // always display final wiz page
                if (S_OK != pComp->hrContinue)
                {
                    WCHAR *pwszFail = NULL;
                    HRESULT hr2 = myLoadRCString(
                                pComp->hInstance,
                                IDS_FINAL_ERROR_TEXT,
                                &pwszFail);
                    if (S_OK == hr2)
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_FINAL_STATUS),
                                      pwszFail);
                        LocalFree(pwszFail);
                    }
                    else
                    {
                        // well, use hard code string
                        SetWindowText(GetDlgItem(hDlg, IDC_FINAL_STATUS),
                                      L"Certificate Services Installation failed");
                        _PrintError(hr2, "myLoadRCString");
                    }
                }
                _ReturnIfWizError(pComp->hrContinue);
                break;
            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// Map table for dialog template resource IDs and dialog proc pointers
WIZPAGERESENTRY aWizPageResources[] = 
{
    IDD_WIZCATYPEPAGE,       WizCATypePageDlgProc,
        IDS_CATYPE_TITLE,       IDS_CATYPE_SUBTITLE,
    IDD_WIZADVANCEDPAGE,     WizAdvancedPageDlgProc,
        IDS_ADVANCE_TITLE,      IDS_ADVANCE_SUBTITLE,
    IDD_WIZIDINFOPAGE,       WizIdInfoPageDlgProc,
        IDS_IDINFO_TITLE,       IDS_IDINFO_SUBTITLE,
    IDD_WIZKEYGENPAGE,       WizKeyGenPageDlgProc,
        IDS_KEYGEN_TITLE,       IDS_KEYGEN_SUBTITLE,
    IDD_WIZSTOREPAGE,        WizStorePageDlgProc,
        IDS_STORE_TITLE,        IDS_STORE_SUBTITLE,
    IDD_WIZCAREQUESTPAGE,    WizCARequestPageDlgProc,
        IDS_CAREQUEST_TITLE,    IDS_CAREQUEST_SUBTITLE,
    IDD_WIZCLIENTPAGE,       WizClientPageDlgProc,
        IDS_CLIENT_TITLE,    IDS_CLIENT_SUBTITLE,
};
#define NUM_SERVERWIZPAGES  sizeof(aWizPageResources)/sizeof(WIZPAGERESENTRY)


HRESULT
CreateCertsrvWizPage(
    IN PER_COMPONENT_DATA      *pComp,
    IN int                      idTitle,
    IN int                      idSubTitle,
    IN int                      idDlgResource,
    IN DLGPROC                  fnDlgProc,
    IN BOOL                     fWelcomeFinal,
    OUT HPROPSHEETPAGE         *phPage)
{
    HRESULT  hr;
    PROPSHEETPAGE   Page;
    WCHAR          *pwszTitle = NULL;
    WCHAR          *pwszSubTitle = NULL;

    // init
    ZeroMemory(&Page, sizeof(PROPSHEETPAGE));

    // construct page info
    // Set titles
    Page.dwFlags = PSP_DEFAULT;

    if (fWelcomeFinal)
        Page.dwFlags |= PSP_HIDEHEADER;

    if (-1 != idTitle)
    {
        hr = myLoadRCString(pComp->hInstance,
                            idTitle,
                            &pwszTitle);
        _JumpIfError(hr, error, "Internal Error");
        Page.pszHeaderTitle = pwszTitle;
        Page.dwFlags |= PSP_USEHEADERTITLE;
    }
    if (-1 != idSubTitle)
    {
        hr = myLoadRCString(pComp->hInstance,
                            idSubTitle,
                            &pwszSubTitle);
        _JumpIfError(hr, error, "Internal Error");
        Page.pszHeaderSubTitle = pwszSubTitle;
        Page.dwFlags |= PSP_USEHEADERSUBTITLE;
    }

    // Set the basic property sheet data
    Page.dwSize = sizeof(PROPSHEETPAGE); // + sizeof(MYWIZPAGE);

    // Set up module and resource dependent data
    Page.hInstance = pComp->hInstance;
    Page.pszTemplate = MAKEINTRESOURCE(idDlgResource);
    Page.pfnDlgProc = fnDlgProc;
    Page.pfnCallback = NULL;
    Page.pcRefParent = NULL;
    Page.pszIcon = NULL;
    Page.pszTitle = NULL;
    Page.lParam = (LPARAM)pComp;  // pass this to wizpage handlers

    // Create the page
    *phPage = CreatePropertySheetPage(&Page);
    _JumpIfOutOfMemory(hr, error, *phPage);

    hr = S_OK;
error:
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszSubTitle)
    {
        LocalFree(pwszSubTitle);
    }
    return hr;
}


//+------------------------------------------------------------------------
//
//  Function:   DoPageRequest(. . . .)
//
//  Synopsis:   Handler for the OC_REQUEST_PAGES notification.
//
//  Effects:    Ponies up the pages for the OCM driven wizard to display.
//
//  Arguments:  [ComponentId]   ID String for the component.
//              [WhichOnes]     Type specifier for requested pages.
//              [SetupPages]    Structure to receive page handles.
//
//  Returns:    DWORD count of pages returned or -1 (MAXDWORD) in case of
//              failure; in this case SetLastError() will provide extended
//              error information.
//
//  History:    04/16/97    JerryK    Unmangled
//                08/97       XTan    major structure change
//
//-------------------------------------------------------------------------
DWORD
DoPageRequest(
    IN PER_COMPONENT_DATA      *pComp,
    IN WIZPAGERESENTRY         *pWizPageResources,
    IN DWORD                    dwWizPageNum,
    IN WizardPagesType          WhichOnes,
    IN OUT PSETUP_REQUEST_PAGES SetupPages)
{
    DWORD               dwPageNum = MAXDWORD;
    HRESULT             hr;
    DWORD               i;

    if (pComp->fUnattended)
    {
        // don't create wiz page if unattended
        return 0;
    }

    // handle welcome page
    if (pComp->fPostBase && WizPagesWelcome == WhichOnes)
    {
        if (1 > SetupPages->MaxPages)
        {
            // ask ocm allocate enough pages
            return 1; // only welcome, 1 page
        }
        hr = CreateCertsrvWizPage(
                     pComp,
                     IDS_WELCOME_TITLE,    // title,
                     -1,                   // no sub-title
                     IDD_WIZWELCOMEPAGE,
                     WizWelcomePageDlgProc,
                     TRUE,
                     &SetupPages->Pages[0]);
        _JumpIfError(hr, error, "CreateCertsrvWizPage");
        return 1; // create 1 page
    }

    // handle final page
    if (pComp->fPostBase && WizPagesFinal == WhichOnes)
    {
        if (1 > SetupPages->MaxPages)
        {
            // ask ocm allocate enough pages
            return 1; // only final, 1 page
        }
        hr = CreateCertsrvWizPage(
                     pComp,
                     IDS_FINAL_TITLE,      // title,
                     -1,                   // no sub-title
                     IDD_WIZFINALPAGE,
                     WizFinalPageDlgProc,
                     TRUE,
                     &SetupPages->Pages[0]);
        _JumpIfError(hr, error, "CreateCertsrvWizPage");
        return 1; // create 1 page
    }

    // from now on, we should only handle post net wiz pages

    if (WizPagesPostnet != WhichOnes)
    {
        // ignore all others except postnet pages
        return 0;
    }

    if (dwWizPageNum > SetupPages->MaxPages)
    {
        // OCM didn't allocate enough for pages, return # and ask more
        return dwWizPageNum;
    }

    // Create the property sheet pages for the wizard
    for (i = 0; i < dwWizPageNum; i++)
    {
        hr = CreateCertsrvWizPage(
                     pComp,
                     pWizPageResources[i].idTitle,      // title,
                     pWizPageResources[i].idSubTitle,   // sub-title
                     pWizPageResources[i].idResource,
                     pWizPageResources[i].fnDlgProc,
                     FALSE,
                     &SetupPages->Pages[i]);
        _JumpIfError(hr, error, "CreateCertsrvWizPage");
    }

    dwPageNum = dwWizPageNum;

error:
    return dwPageNum;
}

DWORD
myDoPageRequest(
    IN PER_COMPONENT_DATA *pComp,
    IN WizardPagesType WhichOnes,
    IN OUT PSETUP_REQUEST_PAGES SetupPages)
{
    pComp->CA.pServer->LastWiz = ENUM_WIZ_UNKNOWN;

    return DoPageRequest(pComp,
               aWizPageResources,
               NUM_SERVERWIZPAGES,
               WhichOnes,
               SetupPages);
}

//+-------------------------------------------------------------------------
//
//  Function:   DirExists()
//
//  Synopsis:   Determines whether or not a directory already exists.
//
//  Arguments:  [pszTestFileName]   -- Name of directory to test for.
//
//  Returns:    FALSE           --  Directory doesn't exist
//              DE_DIREXISTS    --  Directory exists
//              DE_NAMEINUSE    --  Name in use by non-directory entity
//
//  History:    10/23/96    JerryK  Created
//
//--------------------------------------------------------------------------
int
DirExists(LPTSTR pszTestFileName)
{
    DWORD dwFileAttrs;
    int nRetVal;

    // Get file attributes
    dwFileAttrs = GetFileAttributes(pszTestFileName);

    if (0xFFFFFFFF == dwFileAttrs)  // Error code from GetFileAttributes
    {
        nRetVal = FALSE;            // Couldn't open file
    }
    else if (dwFileAttrs & FILE_ATTRIBUTE_DIRECTORY)
    {
        nRetVal = DE_DIREXISTS;     // Directory already exists
    }
    else
    {
        nRetVal = DE_NAMEINUSE;     // Name in use by non-directory entity
    }

    return nRetVal;
}

BOOL
IsEverythingMatched(CASERVERSETUPINFO *pServer)
{
    return pServer->fAdvance &&
           (NULL!=pServer->pwszKeyContainerName) &&
           NULL!=pServer->pccExistingCert;
}


//====================================================================
//
// CA info code
//
//
//====================================================================

WNDPROC g_pfnValidityWndProcs;
WNDPROC g_pfnIdInfoWndProcs;


HRESULT
GetValidityEditCount(
    HWND   hDlg,
    DWORD *pdwPeriodCount)
{
    HRESULT    hr;
    WCHAR     *pwszPeriodCount = NULL;
    BOOL fValidDigitString;

    // init to 0
    *pdwPeriodCount = 0;

    hr = myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT),
                            &pwszPeriodCount);
    _JumpIfError(hr, error, "myUIGetWindowText");

    if (NULL != pwszPeriodCount)
    {
        *pdwPeriodCount = myWtoI(pwszPeriodCount, &fValidDigitString);
    }
    hr = S_OK;

error:
    if (NULL != pwszPeriodCount)
    {
        LocalFree(pwszPeriodCount);
    }
    return hr;
}


HRESULT
UpdateExpirationDate(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT    hr;
    WCHAR      *pwszExpiration = NULL;

    hr = GetValidityEditCount(hDlg, &pServer->dwValidityPeriodCount);
    _JumpIfError(hr, error, "GetValidityEditCount");

    if (0 < pServer->dwValidityPeriodCount)
    {
        if(!pServer->pccExistingCert)
        {
            GetSystemTimeAsFileTime(&pServer->NotBefore);        
            pServer->NotAfter = pServer->NotBefore;
            myMakeExprDateTime(
		        &pServer->NotAfter,
		        pServer->dwValidityPeriodCount,
		        pServer->enumValidityPeriod);
        }

        hr = myGMTFileTimeToWszLocalTime(
				&pServer->NotAfter,
				FALSE,
				&pwszExpiration);
        _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");

        if (!SetWindowText(GetDlgItem(hDlg, IDC_IDINFO_EXPIRATION),
                 pwszExpiration))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetWindowText");
        }
    }

    hr = S_OK;
error:
    if (NULL != pwszExpiration)
    {
        LocalFree(pwszExpiration);
    }
    return hr;
}

HRESULT
AddValidityString(
    IN HINSTANCE  hInstance,
    const HWND    hList,
    const int     ids,
    ENUM_PERIOD   enumValidityPeriod)
{
    HRESULT    hr;
    WCHAR      *pwsz = NULL;
    LRESULT    nIndex;

    hr = myLoadRCString(hInstance, ids, &pwsz);
    _JumpIfError(hr, error, "myLoadRCString");

    // add string
    nIndex = (INT)SendMessage(hList, CB_ADDSTRING, (WPARAM)0, (LPARAM)pwsz);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_ADDSTRING)");
    }
    // set data
    nIndex = (INT)SendMessage(hList, CB_SETITEMDATA, (WPARAM)nIndex, (LPARAM)enumValidityPeriod);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_ADDSTRING)");
    }

    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;
}

HRESULT
SelectValidityString(
    PER_COMPONENT_DATA *pComp,
    HWND                hList,
    ENUM_PERIOD  enumValidityPeriod)
{
    HRESULT    hr;
    WCHAR     *pwsz = NULL;
    LRESULT    nIndex;
    LRESULT    lr;
    int        id;

    switch (enumValidityPeriod)
    {
        case ENUM_PERIOD_YEARS:
            id = IDS_VALIDITY_YEAR;
	    break;

        case ENUM_PERIOD_MONTHS:
            id = IDS_VALIDITY_MONTH;
	    break;

        case ENUM_PERIOD_WEEKS:
            id = IDS_VALIDITY_WEEK;
	    break;

        case ENUM_PERIOD_DAYS:
            id = IDS_VALIDITY_DAY;
	    break;

        default:
            hr = E_INVALIDARG;
            _JumpError(hr, error, "Invalid validity period enum");
        break;
    }

    hr = myLoadRCString(pComp->hInstance, id, &pwsz);
    _JumpIfError(hr, error, "myLoadRCString");

    nIndex = (INT)SendMessage(hList, CB_FINDSTRING, (WPARAM)0, (LPARAM)pwsz);
    if (CB_ERR == nIndex)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_FINDSTRING)");
    }

    lr = (INT)SendMessage(hList, CB_SETCURSEL, (WPARAM)nIndex, (LPARAM)0);
    if (CB_ERR == lr)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_FINDSTRING)");
    }

    lr = (INT)SendMessage(hList, CB_GETITEMDATA, (WPARAM)nIndex, (LPARAM)0);
    if (CB_ERR == lr)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "SendMessage(CB_FINDSTRING)");
    }

    pComp->CA.pServer->enumValidityPeriod = (ENUM_PERIOD)lr;

    hr = S_OK;
error:
    if (pwsz)
       LocalFree(pwsz);

    return hr;
}

HRESULT
DetermineKeyExistence(
    CSP_INFO *pCSPInfo,
    WCHAR    *pwszKeyName)
{
    HRESULT      hr;
    HCRYPTPROV   hProv = NULL;

    if (!myCertSrvCryptAcquireContext(
                &hProv,
                pwszKeyName,
                pCSPInfo->pwszProvName,
                pCSPInfo->dwProvType,
                CRYPT_SILENT,
                TRUE))
    {
        hr = myHLastError();
        goto error;
    }
    hr = S_OK;
error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;
}

LRESULT CALLBACK
ValidityEditFilterHook(
    HWND hwnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int ret;
    BOOL  fUpdate = FALSE;
    LRESULT  lr;
    CASERVERSETUPINFO *pServer = (CASERVERSETUPINFO*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(iMsg)
    {
        case WM_CHAR:
            fUpdate = TRUE;
            if (!iswdigit((TCHAR) wParam))
            {
                if (VK_BACK != (int)wParam)
                {
                    // ignore the key
                    MessageBeep(0xFFFFFFFF);
                    return 0;
                }
            }
            break;
        case WM_KEYDOWN:
            if (VK_DELETE == (int)wParam)
            {
                // validity is changed
                fUpdate = TRUE;
            }
            break;
    }
    lr = CallWindowProc(
            g_pfnValidityWndProcs,
            hwnd,
            iMsg,
            wParam,
            lParam);
    if (fUpdate)
    {
        UpdateExpirationDate(GetParent(hwnd), pServer);
    }
    return lr;
}

HRESULT MakeNullStringEmpty(LPWSTR *ppwszStr)
{
    if(!*ppwszStr)
        return myDupString(L"", ppwszStr);
    return S_OK;
}

HRESULT
HideAndShowMachineDNControls(
    HWND hDlg,
    CASERVERSETUPINFO   *pServer)
{
    HRESULT    hr;
    LPCWSTR pcwszDNSuffix;


    hr = MakeNullStringEmpty(&pServer->pwszFullCADN);
    _JumpIfError(hr, error, "MakeNullStringEmpty");
    hr = MakeNullStringEmpty(&pServer->pwszCACommonName);
    _JumpIfError(hr, error, "MakeNullStringEmpty");
    hr = MakeNullStringEmpty(&pServer->pwszDNSuffix);
    _JumpIfError(hr, error, "MakeNullStringEmpty");

    SetDlgItemText(hDlg, IDC_IDINFO_NAMEEDIT,       pServer->pwszCACommonName);
    SetDlgItemText(hDlg, IDC_IDINFO_DNSUFFIXEDIT,   pServer->pwszDNSuffix);
    SetDlgItemText(hDlg, IDC_IDINFO_NAMEPREVIEW,    pServer->pwszFullCADN);

    // name preview is never editable
//    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_NAMEPREVIEW),  FALSE);
    SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEPREVIEW,  EM_SETREADONLY, TRUE, 0);    

    // if we're in reuse cert mode, we can't edit the DNs
    if (NULL != pServer->pccExistingCert)
    {
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),     FALSE);
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT), FALSE);
        

        SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEEDIT,     EM_SETREADONLY, TRUE, 0);
        SendDlgItemMessage(hDlg, IDC_IDINFO_DNSUFFIXEDIT, EM_SETREADONLY, TRUE, 0);
    }
    else
    {
        // set the defaults again
        // and re-enable everything else
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), TRUE);
//        EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT), TRUE);

        SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEEDIT, EM_SETREADONLY, FALSE, 0);
        SendDlgItemMessage(hDlg, IDC_IDINFO_DNSUFFIXEDIT, EM_SETREADONLY, FALSE, 0);
    //    SendDlgItemMessage(hDlg, IDC_IDINFO_NAMEPREVIEW,  EM_SETREADONLY, FALSE, 0);    
    }

    hr = S_OK;
error:

    return hr;
}

HRESULT InitNameFields(CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    CAutoLPWSTR pwsz;
    const WCHAR *pwszFirstDCComponent = L"";
    
    if(pServer->pccExistingCert)
    {
    }
    else
    {
        if(!pServer->pwszCACommonName)
        {
            // avoid null name
            hr = myDupString(L"", &pServer->pwszCACommonName);
            _JumpIfError(hr, error, "myDupString");
        }
    
        hr = myGetComputerObjectName(NameFullyQualifiedDN, &pwsz);
        _PrintIfError(hr, "myGetComputerObjectName");

        if (S_OK == hr && pwsz != NULL)
        {
            pwszFirstDCComponent = wcsstr(pwsz, L"DC=");
        }

        if(pServer->pwszDNSuffix)
        {
            LocalFree(pServer->pwszDNSuffix);
            pServer->pwszDNSuffix = NULL;
        }

        if(!pwszFirstDCComponent)
        {
            pwszFirstDCComponent = L"";
        }

        hr = myDupString(pwszFirstDCComponent, &pServer->pwszDNSuffix);
	    _JumpIfError(hr, error, "myDupString");

        if(pServer->pwszFullCADN)
        {
            LocalFree(pServer->pwszFullCADN);
            pServer->pwszFullCADN = NULL;
        }
    
        hr = BuildFullDN(
            pServer->pwszCACommonName,
            pwszFirstDCComponent,
            &pServer->pwszFullCADN);
        _JumpIfError(hr, error, "BuildFullDN");
    }

error:
    return hr;
}


// Builds full DN "CN=CAName,DistinguishedName" where CAName and DistinguishedName
// could be empty or NULL;
HRESULT BuildFullDN(
    OPTIONAL LPCWSTR pcwszCAName,
    OPTIONAL LPCWSTR pcwszDNSuffix,
    LPWSTR* ppwszFullDN)
{
    HRESULT hr = S_OK;
    DWORD cBytes = 4; // 4 chars for leading "CN=" plus null terminator

    CSASSERT(ppwszFullDN);

    if(!EmptyString(pcwszCAName))
        cBytes += wcslen(pcwszCAName);

    if(!EmptyString(pcwszDNSuffix))
        cBytes += wcslen(pcwszDNSuffix)+1; // comma

    cBytes *= sizeof(WCHAR);

    *ppwszFullDN = (LPWSTR) LocalAlloc(LMEM_FIXED, cBytes);
    _JumpIfAllocFailed(*ppwszFullDN, error);

    wcscpy(*ppwszFullDN, L"CN=");

    if(!EmptyString(pcwszCAName))
    {
        wcscat(*ppwszFullDN, pcwszCAName);
    }
    
    if(!EmptyString(pcwszDNSuffix))
    {
        wcscat(*ppwszFullDN, L",");
        wcscat(*ppwszFullDN, pcwszDNSuffix);
    }

error:
    return hr;
}

HRESULT
EnableValidityControls(HWND hDlg, BOOL fEnabled)
{
    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), fEnabled);
    return S_OK;
}

HRESULT
HideAndShowValidityControls(
    HWND         hDlg,
    ENUM_CATYPES CAType)
{
    // default to root ca
    int    showValidity = SW_SHOW;
    int    showHelp = SW_HIDE;
    BOOL   fEnableLabel = TRUE;

    if (IsSubordinateCA(CAType))
    {
        showValidity = SW_HIDE;
        showHelp = SW_SHOW;
        fEnableLabel = FALSE;
    }

    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_DETERMINEDBYPCA), showHelp);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), showValidity);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING), showValidity);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_EXPIRATION_LABEL), showValidity);
    ShowWindow(GetDlgItem(hDlg, IDC_IDINFO_EXPIRATION), showValidity);
    EnableWindow(GetDlgItem(hDlg, IDC_IDINFO_VPLABEL), fEnableLabel);

   return S_OK;
}

HRESULT
InitValidityControls(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT    hr;
    HWND       hwndCtrl = GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING);
    ENUM_PERIOD   enumValidityPeriod = ENUM_PERIOD_YEARS;
    WCHAR      *pwsz = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // load validity help text
    hr = myLoadRCString(pComp->hInstance, IDS_IDINFO_DETERMINEDBYPCA, &pwsz);
    _JumpIfError(hr, error, "LoadString");

    if (!SetWindowText(GetDlgItem(hDlg, IDC_IDINFO_DETERMINEDBYPCA), pwsz))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetWindowText");
    }

    // load validity period strings

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_YEAR,
             ENUM_PERIOD_YEARS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_MONTH,
             ENUM_PERIOD_MONTHS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_WEEK,
             ENUM_PERIOD_WEEKS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = AddValidityString(pComp->hInstance, hwndCtrl, IDS_VALIDITY_DAY,
             ENUM_PERIOD_DAYS);
    _JumpIfError(hr, error, "AddValidityString");

    hr = S_OK;
error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return hr;
}


HRESULT
EnableMatchedCertIdInfoEditFields(HWND hDlg, BOOL fEnable)
{
    HRESULT hr;

    EnableValidityControls(hDlg, fEnable);
    
    hr = S_OK;
//error:
    return hr;
}

HRESULT 
WizIdInfoPageSetHooks(HWND hDlg, PER_COMPONENT_DATA *pComp)
{
    HRESULT     hr;

    CSASSERT (NULL != pComp);

    // CA Name filter proc
    g_pfnIdInfoWndProcs = 
        (WNDPROC) SetWindowLongPtr(
                    GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),
                    GWLP_WNDPROC,
                    (LPARAM)IdInfoNameEditFilterHook);
    if (0 == g_pfnIdInfoWndProcs)
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetWindowLongPtr");
    }

    SetLastError(0);
    if (0 == SetWindowLongPtr(
                    GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),
                    GWLP_USERDATA,
                    (LPARAM)pComp->CA.pServer))
    {
        hr = myHLastError(); // might return S_OK
        _JumpIfError(hr, error, "SetWindowLongPtr USERDATA");
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
HandleValidityStringChange(
    HWND               hDlg,
    CASERVERSETUPINFO *pServer)
{
    HRESULT hr;
    LRESULT nItem;
    LRESULT lr;
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING);

    if (NULL == hwndCtrl)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal Error");
    }

    nItem = (INT)SendMessage(hwndCtrl, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
    if (CB_ERR == nItem)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal Error");
    }

    lr = (INT)SendMessage(hwndCtrl, CB_GETITEMDATA, (WPARAM)nItem, (LPARAM)0);
    if (CB_ERR == nItem)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Internal Error");
    }

    pServer->enumValidityPeriod = (ENUM_PERIOD)lr;

    hr = UpdateExpirationDate(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateExpirationDate");

    hr = S_OK;

error:

    return hr;
}
HRESULT
HookIdInfoPageStrings(
    HWND               hDlg,
    PAGESTRINGS       *pPageString,
    CASERVERSETUPINFO *pServer)
{
    HRESULT    hr;

    for ( ; 0 != pPageString->idControl; pPageString++)
    {
        switch (pPageString->idControl)
        {
            case IDC_IDINFO_NAMEEDIT:
                pPageString->ppwszString = &(pServer->pwszCACommonName);
            break;
            case IDC_IDINFO_EDIT_VALIDITYCOUNT:
                pPageString->ppwszString = &(pServer->pwszValidityPeriodCount);
            break;
            default:
                hr = E_INVALIDARG;
                _JumpError(hr, error, "Internal error");
            break;
        }
    }
    hr = S_OK;
error:
    return hr;
}

HRESULT
InitIdInfoWizControls(
    HWND                hDlg,
    PAGESTRINGS        *pIdPageString,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT        hr;
    HWND           hwndCtrl;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;

    // now make page strings complete
    hr = HookIdInfoPageStrings(hDlg, pIdPageString, pServer);
    _JumpIfError(hr, error, "HookIdInfoPageStrings");

    hr = WizPageSetTextLimits(hDlg, pIdPageString);
    _JumpIfError(hr, error, "WizPageSetTextLimits");

    hr = WizIdInfoPageSetHooks(hDlg, pComp);
    _JumpIfError(hr, error, "WizIdInfoPageSetHooks");

    hr = InitValidityControls(hDlg, pComp);
    _JumpIfError(hr, error, "InitValidityControls");

    if (!IsSubordinateCA(pServer->CAType))
    {
        hwndCtrl = GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT);
        g_pfnValidityWndProcs = (WNDPROC)SetWindowLongPtr(hwndCtrl,
            GWLP_WNDPROC, (LPARAM)ValidityEditFilterHook);
        if (NULL == g_pfnValidityWndProcs)
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetWindowLongPtr");
        }
        // pass data
        SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (ULONG_PTR)pServer);
    }

    hr = S_OK;
error:
    return hr;
}

HRESULT
UpdateValidityMaxDigits(
    BOOL         fMatchAll,
    PAGESTRINGS *pIdPageString)
{
    HRESULT hr;

    for (; 0 != pIdPageString; pIdPageString++)
    {
        if (IDC_IDINFO_EDIT_VALIDITYCOUNT == pIdPageString->idControl)
        {
            pIdPageString->cchMax = fMatchAll? UB_VALIDITY_ANY : UB_VALIDITY;
            break;
        }
    }

    hr = S_OK;
//error:
    return hr;
}

HRESULT
HandleIdInfoWizActive(
    HWND               hDlg,
    PER_COMPONENT_DATA *pComp,
    PAGESTRINGS       *pIdPageString)
{
    HRESULT              hr;
    WCHAR                wszValidity[20];
    CASERVERSETUPINFO   *pServer = pComp->CA.pServer;
    ENUM_PERIOD   enumValidityPeriod = pServer->enumValidityPeriod;
    BOOL                 fMatchAll;

    // Suppress this wizard page if
    // we've already seen an error, or
    // we are not installing the server.

    if (!(IS_SERVER_INSTALL & pComp->dwInstallStatus) )
    {
        // disable page
        CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZDISABLE);
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
        goto done;
    }
 
    if (ENUM_WIZ_STORE == pServer->LastWiz)
    {
        // if back from ca request, reset
        g_fAllowUnicodeStrEncoding = FALSE;
    }

    if (pServer->fAdvance &&
        ENUM_WIZ_KEYGEN == pServer->LastWiz &&
        (pServer->fKeyGenFailed || pServer->fValidatedHashAndKey) )
    {
        // key gen failed and go back
        PropSheet_PressButton(GetParent(hDlg), PSBTN_BACK);
    }

    if (!pServer->fAdvance && ENUM_WIZ_CATYPE == pServer->LastWiz)
    {
        hr = LoadDefaultAdvanceAttributes(pServer);
        _JumpIfError(hr, error, "LoadDefaultAdvanceAttributes");
    }

    hr = HideAndShowValidityControls(hDlg, pServer->CAType);
    _JumpIfError(hr, error, "HideAndShowValidityControls");
 
    hr = HideAndShowMachineDNControls(hDlg, pServer);
    _JumpIfError(hr, error, "HideAndShowMachineDNControls");
 
    // load id info
    hr = StartWizardPageEditControls(hDlg, pIdPageString);
    _JumpIfError(hr, error, "StartWizardPageEditControls");

    hr = EnableMatchedCertIdInfoEditFields(hDlg, TRUE);
    _JumpIfError(hr, error, "EnableMatchedCertIdInfoEditFields");

    // default
    wsprintf(wszValidity, L"%u", pServer->dwValidityPeriodCount);

    fMatchAll = IsEverythingMatched(pServer);

    if (fMatchAll)
    {
        enumValidityPeriod = ENUM_PERIOD_DAYS;
        wsprintf(wszValidity, L"%u", pServer->lExistingValidity);
        hr = EnableMatchedCertIdInfoEditFields(hDlg, FALSE);
        _JumpIfError(hr, error, "EnableMatchedCertIdInfoEditFields");
    }

    // update validity period string

    hr = SelectValidityString(
			pComp, 
			GetDlgItem(hDlg, IDC_IDINFO_COMBO_VALIDITYSTRING),
			enumValidityPeriod);
    _JumpIfError(hr, error, "SelectValidityString");
    // update validity
    SetWindowText(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), wszValidity);
    
    hr = UpdateExpirationDate(hDlg, pServer);
    _JumpIfError(hr, error, "UpdateExpirationDate");

    // update validity digits max for validation
    hr = UpdateValidityMaxDigits(fMatchAll, pIdPageString);
    _JumpIfError(hr, error, "UpdateValidityMaxDigits");

    EnableValidityControls(hDlg, !IsSubordinateCA(pServer->CAType) && !fMatchAll);

done:
    hr = S_OK;
error:
    return hr;
}


// check server RDN info, warning any invalid or
// or confirm from users once if any unicode string encoding
BOOL
IsAnyInvalidRDN(
    OPTIONAL HWND       hDlg,
    PER_COMPONENT_DATA *pComp)
{
    HRESULT hr = S_OK;
    BOOL  fInvalidRDN = TRUE;
    BYTE  *pbEncodedName = NULL;
    DWORD  cbEncodedName;
    CERT_NAME_INFO *pbDecodedNameInfo = NULL;
    DWORD           cbDecodedNameInfo;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD   *pIndexRDN = NULL;
    DWORD   *pIndexAttr = NULL;
    DWORD   dwUnicodeCount;
    WCHAR   *pwszAllStrings = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    DWORD indexRDN;
    DWORD indexAttr;
    DWORD indexValue;
    int   idControl;

    LPCWSTR pszErrorPtr = NULL;

    // don't bother calling with CERT_NAME_STR_REVERSE_FLAG, we're just throwing this encoding away
    hr = myCertStrToName(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            pServer->pwszDNSuffix,
            CERT_X500_NAME_STR | CERT_NAME_STR_COMMA_FLAG, 
            NULL,
            &pbEncodedName,
            &cbEncodedName,
            &pszErrorPtr);

    if(S_OK != hr)
    {
            CertWarningMessageBox(
                        pComp->hInstance,
                        pComp->fUnattended,
                        hDlg,
                        IDS_WRN_IDINFO_INVALIDDN,
                        0,
                        NULL);

            int nStartIndex = 0;
            int nEndIndex = wcslen(pServer->pwszDNSuffix);

            if(pszErrorPtr)
            {
                nStartIndex = SAFE_SUBTRACT_POINTERS(pszErrorPtr,pServer->pwszDNSuffix);

                const WCHAR *pwszNextComma = wcsstr(pszErrorPtr, L",");
                if(pwszNextComma)
                {
                    nEndIndex = SAFE_SUBTRACT_POINTERS(pwszNextComma,pServer->pwszDNSuffix+1);
                }
            }

            SetEditFocusAndSelect(
                GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT),
                nStartIndex, 
                nEndIndex);
    }
    _JumpIfError(hr, error, "myCertStrToName");

    // call CryptDecodeObject to get pbDecodedNameInfo

    // if hit here, check if any unicode string encoding
    if (!g_fAllowUnicodeStrEncoding && !pComp->fUnattended)
    {

        // decode to nameinfo
        if (!myDecodeName(
                X509_ASN_ENCODING,
                X509_UNICODE_NAME,
                pbEncodedName,
                cbEncodedName,
                CERTLIB_USE_LOCALALLOC,
                &pbDecodedNameInfo,
                &cbDecodedNameInfo))
        {
            hr = myHLastError();
            _JumpError(hr, error, "myDecodeName");
        }

        // calculate attributes total in RDN
        dwUnicodeCount = 0;
        for (indexRDN = 0; indexRDN < pbDecodedNameInfo->cRDN; ++indexRDN)
        {
            dwUnicodeCount += pbDecodedNameInfo->rgRDN[indexRDN].cRDNAttr;
        }

        // allocate & init index
        // sure allocate max for possible all unicode strings
        pIndexRDN = (DWORD*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                             dwUnicodeCount * sizeof(DWORD));
        _JumpIfOutOfMemory(hr, error, pIndexRDN);
        pIndexAttr = (DWORD*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                             dwUnicodeCount * sizeof(DWORD));
        _JumpIfOutOfMemory(hr, error, pIndexAttr);

        dwUnicodeCount = 0; // reset count
        for (indexRDN = 0; indexRDN < pbDecodedNameInfo->cRDN; ++indexRDN)
        {
	    DWORD cRDNAttr = pbDecodedNameInfo->rgRDN[indexRDN].cRDNAttr;
	    CERT_RDN_ATTR *rgRDNAttr = pbDecodedNameInfo->rgRDN[indexRDN].rgRDNAttr;

            // for each RDN
            for (indexAttr = 0; indexAttr < cRDNAttr; indexAttr++)
            {
                // for each attr, check unicode string

		switch (rgRDNAttr[indexAttr].dwValueType)
		{
		    case CERT_RDN_UTF8_STRING:
		    case CERT_RDN_UNICODE_STRING:
			// there is a unicode or UTF8 string, save index

			pIndexRDN[dwUnicodeCount] = indexRDN;
			pIndexAttr[dwUnicodeCount] = indexAttr;

			// set count

			++dwUnicodeCount;
			break;
                }
            }
        }
        if (0 == dwUnicodeCount)
        {
            // no unicode string encoding
            goto done;
        }

        // calculate size of all unicode strings for display
        DWORD dwLen = 0;
        for (indexAttr = 0; indexAttr < dwUnicodeCount; ++indexAttr)
        {
          dwLen += (wcslen((WCHAR*)pbDecodedNameInfo->rgRDN[pIndexRDN[indexAttr]].rgRDNAttr[pIndexAttr[indexAttr]].Value.pbData) + 3 ) * sizeof(WCHAR);
        }
        pwszAllStrings = (WCHAR*)LocalAlloc(LMEM_FIXED, dwLen);
        _JumpIfOutOfMemory(hr, error, pwszAllStrings);

        // form all strings for display
        for (indexAttr = 0; indexAttr < dwUnicodeCount; ++indexAttr)
        {
            if (0 == indexAttr)
            {
                wcscpy(pwszAllStrings, (WCHAR*)
                       pbDecodedNameInfo->rgRDN[pIndexRDN[indexAttr]].rgRDNAttr[pIndexAttr[indexAttr]].Value.pbData);
            }
            else
            {
                wcscat(pwszAllStrings, (WCHAR*)
                       pbDecodedNameInfo->rgRDN[pIndexRDN[indexAttr]].rgRDNAttr[pIndexAttr[indexAttr]].Value.pbData);
            }
            if (dwUnicodeCount - 1 > indexAttr)
            {
                // add comma + new line
                wcscat(pwszAllStrings, L",\n");
            }
        }

        // ok, ready to put out a warning
        if (IDYES == CertMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_WRN_UNICODESTRINGENCODING,
                    0,
                    MB_YESNO |
                    MB_ICONWARNING |
                    CMB_NOERRFROMSYS,
                    NULL)) //pwszAllStrings))
        {
            // warning only once
            g_fAllowUnicodeStrEncoding = TRUE;
            goto done;
        }

        goto error;
    }

done:

    fInvalidRDN = FALSE;
error:
    if (NULL != pIndexRDN)
    {
        LocalFree(pIndexRDN);
    }
    if (NULL != pIndexAttr)
    {
        LocalFree(pIndexAttr);
    }
    if (NULL != pwszAllStrings)
    {
        LocalFree(pwszAllStrings);
    }
    if (NULL != pbEncodedName)
    {
        LocalFree(pbEncodedName);
    }
    if (NULL != pbDecodedNameInfo)
    {
        LocalFree(pbDecodedNameInfo);
    }
    if (NULL != pNameInfo)
    {
        csiFreeCertNameInfo(pNameInfo);
    }
    return fInvalidRDN;
}
    
/*HRESULT ExtractCommonName(LPCWSTR pcwszDN, LPWSTR* ppwszCN)
{
    HRESULT hr = S_OK;
    WCHAR* pszComma;
    LPWSTR pwszDNUpperCase = NULL;
    const WCHAR* pszCN = pcwszDN;

    if(0!=_wcsnicmp(pcwszDN, L"CN=", wcslen(L"CN=")))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, 
            "distinguished name doesn't start with the common name");
    }

    pszCN += wcslen(L"CN=");

    while(iswspace(*pszCN))
        pszCN++;

    pszComma = wcsstr(pszCN, L",");
    DWORD iChars;
    if (pszComma == NULL)
    {
       // ONLY CN= string, no additional names
       iChars = wcslen(pszCN);
    }
    else
    {
       iChars = SAFE_SUBTRACT_POINTERS(pszComma, pszCN);
    }

    if(0==iChars)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, 
            "invalid syntax, common name should follow CN=");
    }

    *ppwszCN = (LPWSTR)LocalAlloc(LMEM_FIXED, (iChars+1)*sizeof(WCHAR));
    _JumpIfAllocFailed(*ppwszCN, error);

    CopyMemory(*ppwszCN, pszCN, iChars*sizeof(WCHAR));
    (*ppwszCN)[iChars] = L'\0';

error:

    LOCAL_FREE(pwszDNUpperCase);
    return hr;
}*/

HRESULT
HandleIdInfoWizNextOrBack(
    HWND hDlg,
    PER_COMPONENT_DATA *pComp,
    PAGESTRINGS       *pIdPageString,
    int                iWizBN)
{
    HRESULT  hr;
    WCHAR   *pwszSanitizedName = NULL;
    CASERVERSETUPINFO *pServer = pComp->CA.pServer;
    BOOL     fDontNext = FALSE;
    WCHAR    wszCountryCode[cchCOUNTRYNAMEMAX+1];
    HWND     hwnd;
    DWORD    size;
    DWORD    i;
    BOOL fValidDigitString;
    WCHAR * pwszFullPath = NULL;
    WCHAR * pwszDir = NULL;
    DWORD cDirLen;

    hr = FinishWizardPageEditControls(hDlg, pIdPageString);
    _JumpIfError(hr, error, "FinishWizardPageEditControls");

    if (PSN_WIZBACK == iWizBN)
    {
        goto done;
    }

    hr = WizardPageValidation(pComp->hInstance, pComp->fUnattended,
             hDlg, pIdPageString);
    if (S_OK != hr)
    {
        _PrintError(hr, "WizardPageValidation");
        fDontNext = TRUE;
        goto done;
    }

    // snag the full DN specified
    if (NULL != pServer->pwszCACommonName)
    {
        LocalFree(pServer->pwszCACommonName);
	pServer->pwszCACommonName = NULL;
    }
    if (NULL != pServer->pwszFullCADN)
    {
        LocalFree(pServer->pwszFullCADN); 
        pServer->pwszFullCADN = NULL;
    }
    if (NULL != pServer->pwszDNSuffix)
    {
        LocalFree(pServer->pwszDNSuffix);
        pServer->pwszDNSuffix = NULL;
    }

    myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), &pServer->pwszCACommonName);
    myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_NAMEPREVIEW), &pServer->pwszFullCADN);
    myUIGetWindowText(GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT), &pServer->pwszDNSuffix);

    // if generate a new cert
    if (NULL == pServer->pccExistingCert &&
        IsAnyInvalidRDN(hDlg, pComp))
    {
        fDontNext = TRUE;
        goto done;
    }

    // if we are not using an existing cert, verify the chosen validity
    // period of the new cert.
    if (NULL==pServer->pccExistingCert)
    {
        // convert validity count string to a number

        pServer->dwValidityPeriodCount = myWtoI(
					    pServer->pwszValidityPeriodCount,
					    &fValidDigitString);
	if (!fValidDigitString ||
        !IsValidPeriod(pServer))
        {
            // validity out of range, put out a warning dlg
            CertWarningMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_IDINFO_INVALID_VALIDITY,
                0,
                NULL);
            SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_EDIT_VALIDITYCOUNT), 0, -1);
            _PrintError(E_INVALIDARG, "invalid validity");
            fDontNext = TRUE;
            goto done;
        }
    }

    // get sanitized name
    hr = mySanitizeName(pServer->pwszCACommonName, &pwszSanitizedName);
    _JumpIfError(hr, error, "mySanitizeName");

    CSILOG(
	hr,
	IDS_ILOG_SANITIZEDNAME,
	pwszSanitizedName,
	NULL,
	NULL);

    if (MAX_PATH <= wcslen(pwszSanitizedName) + cwcSUFFIXMAX)
    {
        CertMessageBox(
                pComp->hInstance,
                pComp->fUnattended,
                hDlg,
                IDS_WRN_KEYNAMETOOLONG,
                S_OK,
                MB_ICONWARNING | CMB_NOERRFROMSYS,
                pwszSanitizedName);
        SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, -1);
        fDontNext = TRUE;
        goto done;
    }

    // if we are making a new key, see if a key by that name already exists.
    // if it does, see if the user wants to overwrite it.

    if (NULL == pServer->pwszKeyContainerName)
    {
        if (S_OK == DetermineKeyExistence(pServer->pCSPInfo, pwszSanitizedName))
        {
            // warn user if key exist
            if (IDYES != CertMessageBox(
                    pComp->hInstance,
                    pComp->fUnattended,
                    hDlg,
                    IDS_WRN_OVERWRITEEXISTINGKEY,
                    S_OK,
                    MB_YESNO |
                        MB_ICONWARNING |
                        MB_DEFBUTTON2 |
                        CMB_NOERRFROMSYS,
                    pServer->pwszCACommonName))
            {
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, -1);
                fDontNext = TRUE;
                goto done;
            }
        }
    }

    if (NULL != pServer->pwszSanitizedName)
    {
        // free old
        LocalFree(pServer->pwszSanitizedName);
    }
    pServer->pwszSanitizedName = pwszSanitizedName;
    pwszSanitizedName = NULL;

    if (pServer->fUseDS)
    {
        if (IsCAExistInDS(pServer->pwszSanitizedName))
        {
            int ret = CertMessageBox(
                          pComp->hInstance,
                          pComp->fUnattended,
                          hDlg,
                          IDS_IDINFO_CAEXISTINDS,
                          0,
                          MB_YESNO |
                          MB_ICONWARNING |
                          CMB_NOERRFROMSYS,
                          NULL);
            if (IDYES != ret)
            {
                // not overwrite
                SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, -1);
                fDontNext = TRUE;
                goto done;
            }
            else
            {
                hr =  RemoveCAInDS(pServer->pwszSanitizedName);
                if(hr != S_OK)
                {
                    _PrintError(hr, "RemoveCAInDS");
                    SetEditFocusAndSelect(GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT), 0, -1);
                    fDontNext = TRUE;
                    goto done;
                }
            }
        }
    }

    hr = UpdateDomainAndUserName(hDlg, pComp);
    _JumpIfError(hr, error, "UpdateDomainAndUserName");


    if(pServer->fUseDS)
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_DS;
    }
    else
    {
        pServer->dwRevocationFlags = REVEXT_DEFAULT_NODS;
    }

    // validate cert file path lenght
    cDirLen = wcslen(pComp->pwszSystem32)+
        wcslen(wszCERTENROLLSHAREPATH) + 1;

    pwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED, cDirLen * sizeof(WCHAR));
    if (NULL == pwszDir)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszDir, pComp->pwszSystem32); // has trailing "\\"
    wcscat(pwszDir, wszCERTENROLLSHAREPATH);

    hr = csiBuildFileName(
                pwszDir,
                pServer->pwszSanitizedName,
                L".crt",
                0,
                &pwszFullPath,
                pComp->hInstance,
                pComp->fUnattended,
                hDlg);
    _JumpIfError(hr, error, "csiBuildFileName");
    
    if (MAX_PATH <= wcslen(pwszFullPath) + cwcSUFFIXMAX)
    {
        // pop up warning
        CertWarningMessageBox(
            pComp->hInstance,
            pComp->fUnattended,
            hDlg,
            IDS_PATH_TOO_LONG_CANAME,
            S_OK,
            pwszFullPath);
        fDontNext = TRUE;
        goto done;
    }

done:
    if (fDontNext)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // forbid
    }
    else
    {
        pServer->LastWiz = ENUM_WIZ_IDINFO;
    }
    hr = S_OK;
error:
    if (NULL != pwszSanitizedName)
    {
        LocalFree(pwszSanitizedName);
    }
    if(NULL != pwszFullPath)
    {
        LocalFree(pwszFullPath);
    }
    if(NULL != pwszDir)
    {
        LocalFree(pwszDir);
    }

    return hr;
}


PAGESTRINGS g_aIdPageString[] =
    {
        {
            IDC_IDINFO_NAMEEDIT,
            IDS_LOG_CANAME,
            IDS_IDINFO_NAMENULLSTRERR,
            IDS_IDINFO_NAMELENSTRERR,
            cchCOMMONNAMEMAX,
            NULL,
        },
        {
            IDC_IDINFO_EDIT_VALIDITYCOUNT,
            IDS_LOG_VALIDITY,
            IDS_IDINFO_VALIDITYNULLSTRERR,
            IDS_IDINFO_VALIDITYLENSTRERR,
            UB_VALIDITY,
            NULL,
        },
// you need to add code in HookIdInfoPageStrings if adding more...
        {
            0,
            0,
            0,
            0,
            0,
            NULL,
        }
    };

LRESULT CALLBACK
IdInfoNameEditFilterHook(
    HWND hwnd,
    UINT iMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    WCHAR rgchUpper[] = {'\0', '\0'};

    switch(iMsg)
    {
    case WM_CHAR:
        if ((WCHAR)wParam == L',')
        {
                MessageBeep(0xFFFFFFFF);
                return 0;
                break;
        }
        break;

    default:
        break;
    }

    return CallWindowProc(g_pfnIdInfoWndProcs,
               hwnd,
               iMsg,
               wParam,
               lParam);

    return 0;
}


//-------------------------------------------------------------------------
//  WizIdInfoPageDlgProc
//-------------------------------------------------------------------------
INT_PTR
WizIdInfoPageDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    PER_COMPONENT_DATA *pComp = NULL;

    switch(iMsg)
    {
    case WM_INITDIALOG:
        // point to component data
        SetWindowLongPtr(hDlg, DWLP_USER,
            (ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam);
        pComp = (PER_COMPONENT_DATA*)(ULONG_PTR)((PROPSHEETPAGE*)lParam)->lParam;
        _ReturnIfWizError(pComp->hrContinue);
        pComp->hrContinue = InitIdInfoWizControls(hDlg,
                                 g_aIdPageString,
                                 pComp);
        _ReturnIfWizError(pComp->hrContinue);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_IDINFO_NAMEEDIT:
        case IDC_IDINFO_DNSUFFIXEDIT:
            if (HIWORD(wParam) == EN_CHANGE)
            {
                CAutoLPWSTR pwszCAName, pwszDNSuffix, pwszFullDN;
                CASERVERSETUPINFO* pServer;
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pServer = pComp->CA.pServer;
                // if using existing certs ignore the notification
                // to avoid building the full DN
                if(pServer->pccExistingCert)
                {
                    break;
                }
            
                pComp->hrContinue = myUIGetWindowText(
                    GetDlgItem(hDlg, IDC_IDINFO_NAMEEDIT),
                    &pwszCAName);
                _ReturnIfWizError(pComp->hrContinue);

                pComp->hrContinue = myUIGetWindowText(
                    GetDlgItem(hDlg, IDC_IDINFO_DNSUFFIXEDIT),
                    &pwszDNSuffix);
                _ReturnIfWizError(pComp->hrContinue);

                pComp->hrContinue = BuildFullDN(
                    pwszCAName,
                    pwszDNSuffix,
                    &pwszFullDN);
                _ReturnIfWizError(pComp->hrContinue);

                SetDlgItemText(
                    hDlg, 
                    IDC_IDINFO_NAMEPREVIEW,
                    pwszFullDN);
            }
           
            break;

        case IDC_IDINFO_EDIT_VALIDITYCOUNT:
            break;
        case IDC_IDINFO_COMBO_VALIDITYSTRING:
            switch (HIWORD(wParam))
            {
            case CBN_SELCHANGE:
                pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
                pComp->hrContinue = HandleValidityStringChange(
						hDlg,
						pComp->CA.pServer);
                _ReturnIfWizError(pComp->hrContinue);
                break;
            }
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code)
        {
        case PSN_KILLACTIVE:
            break;

        case PSN_RESET:
            break;

        case PSN_QUERYCANCEL:
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            return CertConfirmCancel(hDlg, pComp);
            break;

        case PSN_SETACTIVE:
            CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZACTIVE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
            pComp = _GetCompDataOrReturn(pComp, hDlg);
            _DisableWizDisplayIfError(pComp, hDlg);
            _ReturnIfWizError(pComp->hrContinue);
            pComp->hrContinue = HandleIdInfoWizActive(hDlg,
                                     pComp,
                                     g_aIdPageString);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZBACK:
            CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZBACK);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleIdInfoWizNextOrBack(
                                    hDlg, pComp, g_aIdPageString, PSN_WIZBACK);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        case PSN_WIZNEXT:
            CSILOGDWORD(IDS_IDINFO_TITLE, dwWIZNEXT);
            pComp = _GetCompDataOrReturnIfError(pComp, hDlg);
            pComp->hrContinue = HandleIdInfoWizNextOrBack(
                                    hDlg, pComp, g_aIdPageString, PSN_WIZNEXT);
            _ReturnIfWizError(pComp->hrContinue);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"default"

#include <windows.h>

#include <setupapi.h>
#include "ocmanage.h"

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>
#include <certpdef.h>

#include "causages.h"
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\module.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       module.h
//
//--------------------------------------------------------------------------

#include "resource.h"       // main symbols

class CCertManagePolicyModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModule, &CLSID_CCertManagePolicyModule>
{
public:
    CCertManagePolicyModule() {m_hWnd = NULL;}
    ~CCertManagePolicyModule() {}

BEGIN_COM_MAP(CCertManagePolicyModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManagePolicyModule,
    wszCLASS_CERTMANAGEPOLICYMODULE TEXT(".1"),
    wszCLASS_CERTMANAGEPOLICYMODULE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:

    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);

        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

    HWND m_hWnd;

private:
    HRESULT GetAdmin(ICertAdmin2 **ppAdmin);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include "module.h"
#include "policy.h"
#include "cslistvw.h"
#include "tfc.h"

// help ids
#include "csmmchlp.h"

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

extern HINSTANCE g_hInstance;

STDMETHODIMP
CCertManagePolicyModule::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }

    if (0 == wcscmp(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_MODULE_NAME;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
        uiStr = IDS_MODULE_DESCR;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        uiStr = IDS_MODULE_COPYRIGHT;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_FILEVER))
        uiStr = IDS_MODULE_FILEVER;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        uiStr = IDS_MODULE_PRODUCTVER;
    else
        return S_FALSE;  

    // load string from resource
    WCHAR szStr[MAX_PATH];
    szStr[0] = L'\0';
    LoadString(g_hInstance, uiStr, szStr, ARRAYLEN(szStr));

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;
    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller


    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManagePolicyModule::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvalProperty)
{
    HRESULT hr;

     if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _PrintError(hr, "NULL in parm");
        return hr;
    }

    if (NULL == pvalProperty)
    {
        hr = E_POINTER;
        _PrintError(hr, "NULL parm");
        return hr;
    }

     if (0 == wcscmp(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvalProperty->vt != VT_BSTR)
              return E_INVALIDARG;

         if (SysStringByteLen(pvalProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;
         
         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvalProperty->bstrVal;
         return S_OK;
     }
     
     return S_FALSE;
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam);

struct POLICY_CONFIGSTRUCT
{
    POLICY_CONFIGSTRUCT() :
        pstrConfig(NULL),
        CAType(ENUM_UNKNOWN_CA),
        pCertAdmin(NULL),
        Flags(),
        dwPageModified(0) {}
    ~POLICY_CONFIGSTRUCT()
    { 
        if(pCertAdmin)
        {
            pCertAdmin->Release();
            pCertAdmin = NULL;
        }
    }
    const BSTR*  pstrConfig;
    ENUM_CATYPES CAType;
    ICertAdmin2  *pCertAdmin;
    LONG         Flags;
    
    DWORD        dwPageModified;
};

typedef POLICY_CONFIGSTRUCT *PPOLICY_CONFIGSTRUCT;
        
// dwPageModified
#define PAGE1 (0x1)
#define PAGE2 (0x2)


void MessageBoxWarnReboot(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle));
    LoadString(g_hInstance, IDS_WARNING_REBOOT, szText, ARRAYLEN(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

void MessageBoxNoSave(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYLEN(szTitle));
    LoadString(g_hInstance, IDS_WARNING_NOSAVE, szText, ARRAYLEN(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

STDMETHODIMP
CCertManagePolicyModule::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags)
{
    HRESULT hr;
    ICertServerPolicy *pServer = NULL;
    POLICY_CONFIGSTRUCT sConfig;

    BOOL fLocal;
    LPWSTR szMachine = NULL;
    HKEY hkeyHKLM = NULL;
    DWORD dwDisposition;

    hr = myIsConfigLocal(strConfig, &szMachine, &fLocal);
    _JumpIfError(hr, Ret, "myIsConfigLocal");

    // use callbacks for info
    hr = polGetServerCallbackInterface(&pServer, 0);    // no context : 0
    _JumpIfError(hr, Ret, "polGetServerCallbackInterface");

    // we need to find out who we're running under
    hr = polGetCertificateLongProperty(
			    pServer,
			    wszPROPCATYPE,
			    (LONG *) &sConfig.CAType);
    _JumpIfErrorStr(hr, Ret, "polGetCertificateLongProperty", wszPROPCATYPE);

    hr = GetAdmin(&sConfig.pCertAdmin);
    _JumpIfError(hr, Ret, "GetAdmin");

    sConfig.pstrConfig = &strConfig;
    sConfig.Flags = dwFlags;

    PROPSHEETPAGE page[1];
    ZeroMemory(&page[0], sizeof(PROPSHEETPAGE));
    page[0].dwSize = sizeof(PROPSHEETPAGE);
    page[0].dwFlags = PSP_DEFAULT;
    page[0].hInstance = g_hInstance;
    page[0].lParam = (LPARAM)&sConfig;
    page[0].pszTemplate = MAKEINTRESOURCE(IDD_POLICYPG1);
    page[0].pfnDlgProc = WizPage1DlgProc;

    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.pszCaption = MAKEINTRESOURCE(IDS_MODULE_NAME);
    sSheet.nPages = ARRAYLEN(page);
    sSheet.ppsp = page;

    
    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

Ret:
    if (szMachine)
        LocalFree(szMachine);

    if (pServer)
        pServer->Release();

    return hr;
}



void mySetModified(HWND hwndPage, POLICY_CONFIGSTRUCT* psConfig)
{
    if (psConfig->dwPageModified != 0)
    {
        PropSheet_Changed( ::GetParent(hwndPage), hwndPage); 
    }
    else
    {
        PropSheet_UnChanged( ::GetParent(hwndPage), hwndPage); 
    }
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,  
  UINT uMsg,     
  WPARAM wParam,
  LPARAM lParam)
{
    POLICY_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (POLICY_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwRequestDisposition, dwType;
            DWORD cbRequestDisposition = sizeof(dwRequestDisposition);

            CString strSubkey = wszREGKEYPOLICYMODULES 
                                L"\\" 
                                wszMICROSOFTCERTMODULE_PREFIX 
                                wszCERTPOLICYMODULE_POSTFIX;
            VARIANT var;
            VariantInit(&var);
            hr = psConfig->pCertAdmin->GetConfigEntry(
                    *psConfig->pstrConfig,
                    strSubkey.GetBuffer(),
                    wszREGREQUESTDISPOSITION,
                    &var);
            if(S_OK!=hr)
                break;

            dwRequestDisposition = V_I4(&var);

            // if disposition includes Issue
            if ((dwRequestDisposition & REQDISP_MASK) == REQDISP_ISSUE)
            {
                // if pending bit set
                if (dwRequestDisposition & REQDISP_PENDINGFIRST)
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), BM_SETCHECK, TRUE, BST_CHECKED);
                else
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_SETCHECK, TRUE, BST_CHECKED);
            }

            // disallow "Pend first" if Enterprise (bug #259346)
            // Post-win2000: re-enable and fix tools
/*
            if ((psConfig->CAType == ENUM_ENTERPRISE_ROOTCA) ||
                (psConfig->CAType == ENUM_ENTERPRISE_SUBCA))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_TEXT_PENDFIRST), FALSE);
            }
*/
            psConfig->dwPageModified &= ~PAGE1; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (psConfig->dwPageModified & PAGE1)
                {
                    DWORD dwCheckState, dwRequestDisposition;
                    dwCheckState = (DWORD)SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_GETCHECK, 0, 0);

                    if (dwCheckState == BST_CHECKED)
                        dwRequestDisposition = REQDISP_ISSUE;
                    else
                        dwRequestDisposition = REQDISP_ISSUE | REQDISP_PENDINGFIRST;

                    CString strSubkey = wszREGKEYPOLICYMODULES 
                                        L"\\" 
                                        wszMICROSOFTCERTMODULE_PREFIX 
                                        wszCERTPOLICYMODULE_POSTFIX;
                    VARIANT var;
                    VariantInit(&var);
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = dwRequestDisposition;

                    hr = psConfig->pCertAdmin->SetConfigEntry(
                            *psConfig->pstrConfig,
                            strSubkey.GetBuffer(),
                            wszREGREQUESTDISPOSITION,
                            &var);
                    if(S_OK!=hr)
                    {
                        MessageBoxNoSave(hwndDlg);
                        psConfig->dwPageModified &= ~PAGE1;
                    }
                    else
                    {
                        MessageBoxWarnReboot(NULL);
                    }
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE1;
                mySetModified(hwndDlg, psConfig);
            }
            break;
        default:
            break;
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_RADIO_ISSUE:
        case IDC_RADIO_PENDFIRST:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (BN_CLICKED == HIWORD(wParam))
                {
                    psConfig->dwPageModified |= PAGE1;
                    mySetModified(hwndDlg, psConfig);
                }
            }
            break;

        default:
            break;
        }
    default:
        break;
    }

    return fReturn;
}

HRESULT CCertManagePolicyModule::GetAdmin(ICertAdmin2 **ppAdmin)
{
    HRESULT hr = S_OK, hr1;
    BOOL fCoInit = FALSE;

    hr1 = CoInitialize(NULL);
    if ((S_OK == hr1) || (S_FALSE == hr1))
        fCoInit = TRUE;

    // create interface, pass back
    hr = CoCreateInstance(
			CLSID_CCertAdmin,
			NULL,		// pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertAdmin2,
			(void **) ppAdmin);
    _PrintIfError(hr, "CoCreateInstance");

    if (fCoInit)
        CoUninitialize();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\policy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//--------------------------------------------------------------------------

// policy.h: Declaration of CCertPolicyEnterprise


#include "resource.h"
#include "causages.h"

#include <certca.h>
#include <userenv.h>
#include <dsgetdc.h>
#include <winldap.h>

/////////////////////////////////////////////////////////////////////////////
// certpol


extern HANDLE g_hEventLog;
extern HINSTANCE g_hInstance;

#define MAX_INSERTION_ARRAY_SIZE 100
#define  B3_VERSION_NUMBER 2031

#define CONFIGURE_EVENT_FORMAT TEXT("CA Configuration %ls")


#define DS_ATTR_COMMON_NAME		L"cn"
//#define DS_ATTR_DISTINGUISHED_NAME	L"distinguishedName"
#define DS_ATTR_DNS_NAME		L"dNSHostName"
#define DS_ATTR_EMAIL_ADDR		L"mail"
#define DS_ATTR_OBJECT_GUID		L"objectGUID"
#define DS_ATTR_UPN			L"userPrincipalName"


typedef struct _KUMASK {
    DWORD dwMask;
    LPWSTR wszAlg;
} KUMASK;

class CTemplatePolicy;

HRESULT
polGetProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN DWORD PropType,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarOut);

HRESULT
polCAGetCertTypeProperty(
    IN HCERTTYPE hCertType,
    IN WCHAR const *pwszPropName,
    WCHAR ***papwszValues);

HRESULT
polCAGetCertTypeStringProperty(
    IN HCERTTYPE hCertType,
    IN WCHAR const *pwszPropName,
    OUT WCHAR **ppwszValue);

// begin_sdksample

class CRequestInstance;

#ifndef __BSTRC__DEFINED__
#define __BSTRC__DEFINED__
typedef OLECHAR const *BSTRC;
#endif

HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context);

HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut);

DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR **ppwsz);

// 
// Class CCertPolicyEnterprise
// 
// Actual policy module for a CA Policy
//
//

class CCertPolicyEnterprise: 
    public CComDualImpl<ICertPolicy2, &IID_ICertPolicy2, &LIBID_CERTPOLICYLib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertPolicyEnterprise, &CLSID_CCertPolicy>
{
public:
    CCertPolicyEnterprise()
    {
        HRESULT hr;
	
	m_strDescription = NULL;

        // RevocationExtension variables:

	m_dwRevocationFlags = 0;
	m_wszASPRevocationURL = NULL;

        m_dwDispositionFlags = 0;
        m_dwEditFlags = 0;

	// CertTypeExtension variables:

	m_astrSubjectAltNameProp[0] = NULL;
	m_astrSubjectAltNameProp[1] = NULL;
	m_astrSubjectAltNameObjectId[0] = NULL;
	m_astrSubjectAltNameObjectId[1] = NULL;

	m_cEnableRequestExtensions = 0;
	m_apstrEnableRequestExtensions = NULL;

	m_cDisableExtensions = 0;
	m_apstrDisableExtensions = NULL;

	// CA Name
        m_strRegStorageLoc = NULL;

	m_strCAName = NULL;
        m_strCASanitizedName = NULL;
        m_strCASanitizedDSName = NULL;
        m_strMachineDNSName = NULL;

	m_fPolicyCriticalSection = FALSE;

        // CA and cert type info

        m_CAType = ENUM_UNKNOWN_CA;

        m_pCert = NULL;
        m_iCRL = 0;

	// end_sdksample
	//+--------------------------------------

	m_pbSMIME = NULL;
        m_fUseDS = FALSE;
        m_pld = NULL;
	m_hCertTypeQuery = NULL;
        m_strDomainDN = NULL;
        m_strConfigDN = NULL;
        m_cTemplatePolicies = 0;
        m_apTemplatePolicies = NULL;
	m_fConfigLoaded = FALSE;
	m_ConfigLoadedCount = 0;
	m_dwCATemplListSequenceNum = 0;

	//+--------------------------------------
	// begin_sdksample
    }
    ~CCertPolicyEnterprise();

BEGIN_COM_MAP(CCertPolicyEnterprise)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertPolicy)
    COM_INTERFACE_ENTRY(ICertPolicy2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertPolicyEnterprise) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertPolicyEnterprise,
    wszCLASS_CERTPOLICY TEXT(".1"),
    wszCLASS_CERTPOLICY,
    IDS_CERTPOLICY_DESC,
    THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICertPolicy
public:
    STDMETHOD(Initialize)( 
		/* [in] */ BSTR const strConfig);

    STDMETHOD(VerifyRequest)( 
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Context,
		/* [in] */ LONG bNewRequest,
		/* [in] */ LONG Flags,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetDescription)( 
		/* [out, retval] */ BSTR __RPC_FAR *pstrDescription);

    STDMETHOD(ShutDown)();

// ICertPolicy2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

public:
    HRESULT AddBasicConstraintsCommon(
		IN ICertServerPolicy *pServer,
		IN CERT_EXTENSION const *pExtension,
		IN BOOL fCA,
		IN BOOL fEnableExtension);

    BSTRC GetPolicyDescription() { return(m_strDescription); }

// end_sdksample

    HRESULT FindTemplate(
		OPTIONAL IN WCHAR const *pwszTemplateName,
		OPTIONAL IN WCHAR const *pwszTemplateObjId,
		OUT CTemplatePolicy **ppTemplate);

    DWORD GetLogLevel() { return(m_dwLogLevel); }
    DWORD GetEditFlags() { return(m_dwEditFlags); }
    BYTE const *GetSMIME(OUT DWORD *pcbSMIME)
    {
	*pcbSMIME = m_cbSMIME;
	return(m_pbSMIME);
    }
// begin_sdksample

private:
    HRESULT _LogLoadTemplateError(
                IN ICertServerPolicy *pServer,
                HRESULT hr, 
                LPCWSTR pcwszTemplate);

    HRESULT _LoadTemplates(
		IN ICertServerPolicy *pServer,
		OPTIONAL OUT HCAINFO *phCAInfo);

    VOID _ReleaseTemplates();

    HRESULT _AddTemplateToCA(
		IN HCAINFO hCAInfo,
		IN WCHAR const *pwszTemplateName,
		OUT BOOL *pfAdded);

    CERT_CONTEXT const *_GetIssuer(
		IN ICertServerPolicy *pServer);

    HRESULT _EnumerateExtensions(
		IN ICertServerPolicy *pServer,
		IN LONG bNewRequest,
		IN BOOL fFirstPass);

#if DBG_CERTSRV
    VOID _DumpStringArray(
		IN char const *pszType,
		IN DWORD count,
		IN BSTR const *apstr);
#else
    #define _DumpStringArray(pszType, count, apstr)
#endif

    VOID _FreeStringArray(
		IN OUT DWORD *pcString,
		IN OUT LPWSTR **papstr);

    VOID _Cleanup();


    HRESULT _SetSystemStringProp(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszName,
		OPTIONAL IN WCHAR const *pwszValue);

    HRESULT _AddStringArray(
		IN WCHAR const *pwszzValue,
		IN BOOL fURL,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papstrRegValues);

    HRESULT _ReadRegistryString(
		IN HKEY hkey,
		IN BOOL fURL,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszSuffix,
		OUT LPWSTR *pwszRegValue);

    HRESULT _ReadRegistryStringArray(
		IN HKEY hkey,
		IN BOOL fURL,
		IN DWORD dwFlags,
		IN DWORD cRegNames,
		IN DWORD *aFlags,
		IN WCHAR const * const *apwszRegNames,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papstrRegValues);

    VOID _InitRevocationExtension(
		IN HKEY hkey);

    VOID _InitSubjectAltNameExtension(
		IN HKEY hkey,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszObjectId,
		IN DWORD iAltName);

    VOID _InitRequestExtensionList(
		IN HKEY hkey);

    VOID _InitDisableExtensionList(
		IN HKEY hkey);

// end_sdksample
    VOID _InitDefaultSMIMEExtension(
		IN HKEY hkey);
// begin_sdksample

    HRESULT _AddRevocationExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddOldCertTypeExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddTemplateNameExtension(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _AddSubjectAltNameExtension(
		IN ICertServerPolicy *pServer,
		IN DWORD iAltName);

    HRESULT _PatchExchangeSubjectAltName(
		IN ICertServerPolicy *pServer,
		OPTIONAL IN BSTRC strTemplateName);

    HRESULT _AddAuthorityKeyId(
		IN ICertServerPolicy *pServer);

    HRESULT _AddDefaultKeyUsageExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddEnhancedKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddDefaultBasicConstraintsExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _SetValidityPeriod(
		IN ICertServerPolicy *pServer);

// end_sdksample

    HRESULT _LoadDSConfig(
		IN ICertServerPolicy *pServer,
		IN BOOL fRediscover);

    VOID _UnloadDSConfig();

    HRESULT _UpdateTemplates(
		IN ICertServerPolicy *pServer,
		IN BOOL fForceLoad);

    HRESULT _ApplyTemplate(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest,
		OUT DWORD *pdwEnrollmentFlags);

// begin_sdksample

private:
    // RevocationExtension variables:

    PCCERT_CONTEXT m_pCert;

    BSTR  m_strDescription;

    DWORD m_dwRevocationFlags;
    LPWSTR m_wszASPRevocationURL;

    DWORD m_dwDispositionFlags;
    DWORD m_dwEditFlags;
    DWORD m_CAPathLength;

    DWORD m_cEnableRequestExtensions;
    LPWSTR *m_apstrEnableRequestExtensions;

    DWORD m_cDisableExtensions;
    LPWSTR *m_apstrDisableExtensions;

    // SubjectAltNameExtension variables:

    BSTR m_astrSubjectAltNameProp[2];
    BSTR m_astrSubjectAltNameObjectId[2];

    // CertTypeExtension variables:

    BSTR m_strRegStorageLoc;
    BSTR m_strCAName;

    BSTR m_strCASanitizedName;
    BSTR m_strCASanitizedDSName;

    BSTR m_strMachineDNSName;

    CRITICAL_SECTION m_PolicyCriticalSection;
    BOOL m_fPolicyCriticalSection;
    
    // CA and cert type info

    ENUM_CATYPES m_CAType;

    DWORD m_iCert;
    DWORD m_iCRL;

    // end_sdksample
    //+--------------------------------------

    BOOL              m_fUseDS;
    DWORD             m_dwLogLevel;
    LDAP             *m_pld;
    HCERTTYPEQUERY    m_hCertTypeQuery;
    DWORD             m_TemplateSequence;
    BSTR              m_strDomainDN;
    BSTR  	      m_strConfigDN;

    DWORD             m_cTemplatePolicies;
    CTemplatePolicy **m_apTemplatePolicies;
    BOOL              m_fConfigLoaded;
    DWORD 	      m_ConfigLoadedCount;
    DWORD             m_dwCATemplListSequenceNum;
    BYTE *m_pbSMIME;
    DWORD m_cbSMIME;

    //+--------------------------------------
    // begin_sdksample
};

// end_sdksample

// 
// Class CTemplatePolicy
// 
// Sub Policy information for a CA policy
// 
//

typedef struct _POLICIES {
    DWORD cObjId;
    WCHAR **prgObjId;
} POLICIES;
 
class CTemplatePolicy
{
public:
    CTemplatePolicy();
    ~CTemplatePolicy();

    HRESULT Initialize(
		IN HCERTTYPE hCertType,
		IN ICertServerPolicy *pServer,
		IN CCertPolicyEnterprise *pPolicy);

    HRESULT Apply(
		IN ICertServerPolicy *pServer, 
		IN CRequestInstance *pRequest);

    HRESULT GetFlags(
		IN DWORD dwOption,
		OUT DWORD *pdwFlags);

    BOOL IsRequestedTemplate(
		OPTIONAL IN WCHAR const *pwszTemplateName,
		OPTIONAL IN WCHAR const *pwszTemplateObjId);

    WCHAR const *GetTemplateName() { return(m_pwszTemplateName); }
    WCHAR const *GetTemplateObjId() { return(m_pwszTemplateObjId); }

private:
    VOID _Cleanup();

    HRESULT _LogLoadResult(
		IN CCertPolicyEnterprise *pPolicy,
		IN ICertServerPolicy *pServer,
		IN HRESULT hrLoad);

    HRESULT _InitBasicConstraintsExtension(
		IN HKEY hkey);

    HRESULT _AddBasicConstraintsExtension(
                IN CRequestInstance *pRequest,
		IN ICertServerPolicy *pServer);

    HRESULT _InitKeyUsageExtension(
		IN HKEY hkey);

    HRESULT _AddKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddTemplateExtensionArray(
		IN ICertServerPolicy *pServer);

    HRESULT _AddTemplateExtension(
		IN ICertServerPolicy *pServer,
		IN CERT_EXTENSION const *pExt);

    HRESULT _AddSubjectName(
		IN ICertServerPolicy *pServer,
                IN CRequestInstance *pRequest);

    HRESULT _AddDSDistinguishedName(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _AddAltSubjectName(
                IN ICertServerPolicy *pServer,
                IN CRequestInstance *pRequest);

    HRESULT _ApplyExpirationTime(
                IN ICertServerPolicy *pServer);

    HRESULT _EnforceKeySizePolicy(
                IN ICertServerPolicy *pServer);

    HRESULT _EnforceKeyArchivalPolicy(
                IN ICertServerPolicy *pServer);

    HRESULT _EnforceSymmetricAlgorithms(
		IN ICertServerPolicy *pServer,
                IN CRequestInstance *pRequest);

    HRESULT _EnforceMinimumTemplateVersion(
		IN CRequestInstance *pRequest);

    HRESULT _EnforceEnrollOnBehalfOfAllowed(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _EnforceReenrollment(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _EnforceSignaturePolicy(
                IN ICertServerPolicy *pServer);

    HRESULT _LoadPolicies(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszPropNameCertType,
		IN WCHAR const *pwszPropNameRequest,
		OUT DWORD *pcObjId,
		OUT WCHAR ***papwszObjId,
		OUT DWORD *pcPolicies,
		OUT POLICIES **pprgPolicies);

    VOID _FreePolicies(
		IN WCHAR **apwszObjId,
		IN POLICIES *prgPolicies);

private:
    WCHAR                 *m_pwszTemplateName;
    WCHAR                 *m_pwszTemplateObjId;
    DWORD                  m_dwTemplateMajorVersion;
    DWORD                  m_dwTemplateMinorVersion;
    DWORD                  m_dwSchemaVersion;
    HCERTTYPE              m_hCertType;
    CERT_EXTENSIONS       *m_pExtensions;
    DWORD                  m_dwEnrollmentFlags;
    DWORD                  m_dwSubjectNameFlags;
    DWORD                  m_dwPrivateKeyFlags;
    DWORD                  m_dwGeneralFlags;
    DWORD                  m_dwMinKeyLength;
    CCertPolicyEnterprise *m_pPolicy;
};


// begin_sdksample
// 
// Class CRequestInstance
// 
// Instance data for a certificate that is being created.
//

class CRequestInstance
{
    friend class CTemplatePolicy;	// no_sdksample

public:
    CRequestInstance()
    {
        m_strTemplateName = NULL;
	m_strTemplateObjId = NULL;
	m_pPolicy = NULL;

	// end_sdksample
	//+--------------------------------------

        m_hToken = NULL;
        m_SearchResult = NULL;
        m_PrincipalAttributes = NULL;

        m_strUserDN = NULL;
        m_pwszUPN = NULL;

        // The default version for clients is W2K beta3 (2031)

        m_RequestOsVersion.dwOSVersionInfoSize = sizeof(m_RequestOsVersion);
        m_RequestOsVersion.dwMajorVersion = 5;
        m_RequestOsVersion.dwMinorVersion = 0;
        m_RequestOsVersion.dwBuildNumber = B3_VERSION_NUMBER;
        m_RequestOsVersion.dwPlatformId = VER_PLATFORM_WIN32_NT;
        m_RequestOsVersion.szCSDVersion[0] = 0;
        m_RequestOsVersion.wServicePackMajor = 0;
        m_RequestOsVersion.wServicePackMinor = 0;
        m_RequestOsVersion.wSuiteMask = 0;
        m_RequestOsVersion.wProductType = 0;
        m_RequestOsVersion.wReserved = 0;
	m_fClientVersionSpecified = FALSE;
        m_fIsXenrollRequest = FALSE;
        m_fNewRequest = TRUE;

	//+--------------------------------------
	// begin_sdksample
    }

    ~CRequestInstance();

    HRESULT Initialize(
		IN CCertPolicyEnterprise *pPolicy,
		IN BOOL fEnterpriseCA,	// no_sdksample
		IN BOOL bNewRequest,	// no_sdksample
		IN ICertServerPolicy *pServer);

    HRESULT SetTemplateName(
		IN ICertServerPolicy *pServer,
		IN OPTIONAL WCHAR const *pwszTemplateName,
		IN OPTIONAL WCHAR const *pwszTemplateObjId);

    BSTRC GetTemplateName() { return(m_strTemplateName); }
    BSTRC GetTemplateObjId() { return(m_strTemplateObjId); }

    // end_sdksample

    VOID GetTemplateVersion(
		OUT DWORD *pdwTemplateMajorVersion,
		OUT DWORD *pdwTemplateMinorVersion);

    // begin_sdksample

    BOOL IsCARequest() { return(m_fCA); }

    CCertPolicyEnterprise *GetPolicy() { return(m_pPolicy); }

    BOOL IsNewRequest() { return m_fNewRequest; }

private:

    HRESULT _SetFlagsProperty(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszPropName,
		IN DWORD dwFlags);

    BOOL _TemplateNamesMatch(
		IN WCHAR const *pwszTemplateName1,
		IN WCHAR const *pwszTemplateName2,
		OUT BOOL *pfTemplateMissing);

    // end_sdksample
    //+--------------------------------------

    HRESULT _InitToken(
		IN ICertServerPolicy *pServer);

    HRESULT _InitClientOSVersionInfo(
		IN ICertServerPolicy *pServer);

    HANDLE _GetToken() { return(m_hToken); }

    BOOL _IsUser() { return(m_fUser); }

    BOOL _IsXenrollRequest() { return(m_fIsXenrollRequest); }

    BOOL _ClientVersionSpecified() { return(m_fClientVersionSpecified); }


    // Return TRUE if the requesting client is running NT and the OS version is
    // older than the passed version.

    BOOL _IsNTClientOlder(
		IN DWORD dwMajor,
		IN DWORD dwMinor,
		IN DWORD dwBuild,
		IN DWORD dwPlatform)
    {
	return(
	    dwPlatform == m_RequestOsVersion.dwPlatformId &&
	    (dwMajor > m_RequestOsVersion.dwMajorVersion ||
	     (dwMajor == m_RequestOsVersion.dwMajorVersion &&
	      (dwMinor > m_RequestOsVersion.dwMinorVersion ||
	       (dwMinor == m_RequestOsVersion.dwMinorVersion &&
		dwBuild > m_RequestOsVersion.dwBuildNumber)))));
    }

    HRESULT _GetValueString(
		IN WCHAR const *pwszName,
		OUT BSTRC *pstrValue);

    HRESULT _GetValues(
		IN WCHAR const *pwszName,
		OUT WCHAR ***pppwszValues);

    HRESULT _FreeValues(
		IN WCHAR **ppwszValues);

    HRESULT _GetObjectGUID(
		OUT BSTR *pstrGuid);

    HRESULT _LoadPrincipalObject(
		IN ICertServerPolicy *pServer,
		IN CTemplatePolicy *pTemplate);

    VOID _Cleanup();		// add_sdksample

    HRESULT _GetDSObject();

private:			// add_sdksample
    HANDLE          m_hToken;
    BOOL            m_fUser;		    // This is a user 
    BOOL            m_fEnterpriseCA;

    LDAPMessage    *m_SearchResult;
    LDAPMessage    *m_PrincipalAttributes;  // Collected attribs for this cert 
    BSTR            m_strUserDN;	    // Path to principal object
    WCHAR          *m_pwszUPN;		    // Principal Name

    OSVERSIONINFOEX m_RequestOsVersion;	    // Version info for the request
    BOOL            m_fIsXenrollRequest;    // not a netscape keygen request
    BOOL            m_fClientVersionSpecified;

    //+--------------------------------------
    // begin_sdksample
    CCertPolicyEnterprise *m_pPolicy;
    BSTR                   m_strTemplateName;	// certificate type requested
    BSTR                   m_strTemplateObjId;	// certificate type requested
    DWORD                  m_dwTemplateMajorVersion;
    DWORD                  m_dwTemplateMinorVersion;
    BOOL                   m_fCA;
    BOOL                   m_fNewRequest;   // set if this is a new request, 
                                            // not a resubmitted one
};
// end_sdksample
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\certpdef.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certpdef.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "resource.h"
#include "policy.h"
#include "module.h"

#define __dwFILE__	__dwFILE_POLICY_DEFAULT_CERTPDEF_CPP__

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertPolicy, CCertPolicyEnterprise)
    OBJECT_ENTRY(CLSID_CCertManagePolicyModule, CCertManagePolicyModule)
END_OBJECT_MAP()

#define EVENT_SOURCE_LOCATION L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"
#define EVENT_SOURCE_NAME L"CertEnterprisePolicy"

HANDLE g_hEventLog = NULL;
HINSTANCE g_hInstance = NULL;


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
        g_hEventLog = RegisterEventSource(NULL, EVENT_SOURCE_NAME);
		g_hInstance = hInstance;
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:

        if(g_hEventLog)
        {
            DeregisterEventSource(g_hEventLog);
            g_hEventLog = NULL;
        }
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    HKEY hk = NULL;
    DWORD disp;
    DWORD err;
    DWORD dwData;
    LPWSTR wszModuleLocation = L"%SystemRoot%\\System32\\certpdef.dll"; 

    // wrap delayloaded func with try/except
    __try
    {
        // registers object, typelib and all interfaces in typelib
        // Register the event logging
         err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             EVENT_SOURCE_LOCATION EVENT_SOURCE_NAME,
                             NULL,
                             TEXT(""),
                             REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                             NULL,
                             &hk,
                             &disp);
         if(err != ERROR_SUCCESS)
             goto end;

         err = RegSetValueEx(hk,             // subkey handle 
                L"EventMessageFile",       // value name 
                0,                        // must be zero 
                REG_EXPAND_SZ,            // value type 
                (LPBYTE)wszModuleLocation,           // pointer to value data 
                sizeof(WCHAR)*(wcslen(wszModuleLocation) + 1));
            

        dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
            EVENTLOG_INFORMATION_TYPE; 
     
        err = RegSetValueEx(hk,      // subkey handle 
                L"TypesSupported",  // value name 
                0,                 // must be zero 
                REG_DWORD,         // value type 
                (LPBYTE) &dwData,  // pointer to value data 
                sizeof(DWORD));           
    }
    __except(err = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(err, "Exception");
    }

end:
    if (hk)
        RegCloseKey(hk);

    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    // wrap delayloaded func with try/except
    HRESULT err;
    __try
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE, EVENT_SOURCE_LOCATION EVENT_SOURCE_NAME);
    }
    __except(err = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(err, "Exception");
    }

    _Module.UnregisterServer();
    return(S_OK);
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(size_t cb)
{
    return(LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb));
}


void __RPC_USER
MIDL_user_free(void __RPC_FAR *pb)
{
    LocalFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        policy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <winldap.h>
#include <security.h>

#include "cspelog.h"
#include "pollog.h"

#include "csprop.h"
#include "csldap.h"
#include "csdisp.h"
#include "policy.h"
#include "cainfop.h"


#define __dwFILE__	__dwFILE_POLICY_DEFAULT_POLICY_CPP__


#define LOCAL_SYSTEM_SD L"O:SYG:DAD:(A;;0x00000001;;;SY)(A;;0x00000001;;;PS)"


// begin_sdksample

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

// end_sdksample

HRESULT CreateCertDSHierarchy(VOID);
VOID reqCleanup(VOID);


HRESULT
polCAGetCertTypeProperty(
    IN HCERTTYPE hCertType,
    IN WCHAR const *pwszPropName,
    WCHAR ***papwszValues)
{
    HRESULT hr;
    
    *papwszValues = NULL;
    hr = CAGetCertTypeProperty(hCertType, pwszPropName, papwszValues);
    _PrintIfErrorStr2(
	    hr,
	    "Policy:CAGetCertTypeProperty",
	    pwszPropName,
	    HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
    if (S_OK != hr)
    {
	*papwszValues = NULL;
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    goto error;
	}
	hr = S_OK;
    }

error:
    return(hr);
}


HRESULT
polCAGetCertTypeStringProperty(
    IN HCERTTYPE hCertType,
    IN WCHAR const *pwszPropName,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    WCHAR **apwszValues = NULL;
    
    *ppwszValue = NULL;
    hr = CAGetCertTypeProperty(hCertType, pwszPropName, &apwszValues);
    if (S_OK != hr)
    {
	apwszValues = NULL;
	_JumpErrorStr(hr, error, "CAGetCertTypeProperty", pwszPropName);
    }
    if (NULL == apwszValues || NULL == apwszValues[0])
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpErrorStr(hr, error, "CAGetCertTypeProperty", pwszPropName);
    }
    hr = myDupString(apwszValues[0], ppwszValue);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != apwszValues)
    {
        CAFreeCertTypeProperty(hCertType, apwszValues);
    }
    return(hr);
}


// begin_sdksample

// worker
HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Policy:polGetServerCallbackInterface");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerPolicy,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerPolicy,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Policy:CoCreateInstance");

    if (NULL == *ppServer)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Policy:CoCreateInstance");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Policy:SetContext");
    }

error:
    return hr;
}


HRESULT
polGetProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN DWORD PropType,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    VariantInit(pvarOut);
    strName = SysAllocString(pwszPropertyName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    if (fRequest)
    {
	hr = pServer->GetRequestProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetRequestProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = pServer->GetCertificateProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetCertificateProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polGetStringProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    hr = polGetProperty(pServer, fRequest, PROPTYPE_STRING, pwszPropertyName, &var);
    _JumpIfError2(
	    hr,
	    error,
	    "Policy:polGetProperty",
	    CERTSRV_E_PROPERTY_EMPTY);

    if (VT_BSTR != var.vt || NULL == var.bstrVal || L'\0' == var.bstrVal)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *pstrOut = var.bstrVal;
    var.vt = VT_EMPTY;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetLongProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    hr = polGetProperty(pServer, fRequest, PROPTYPE_LONG, pwszPropertyName, &var);
    _JumpIfError2(hr, error, "Policy:polGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    if (VT_I4 != var.vt)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *plOut = var.lVal;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, TRUE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, FALSE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, TRUE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, FALSE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszAttributeName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetRequestAttribute(strName, pstrOut);
    _JumpIfErrorStr(hr, error, "Policy:GetRequestAttribute", pwszAttributeName);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::~CCertPolicyEnterprise -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertPolicyEnterprise::~CCertPolicyEnterprise()
{
    _Cleanup();

    if(m_fPolicyCriticalSection)
    {
        DeleteCriticalSection(&m_PolicyCriticalSection);
    }
}


VOID
CCertPolicyEnterprise::_FreeStringArray(
    IN OUT DWORD *pcString,
    IN OUT LPWSTR **papstr)
{
    BSTR *apstr = *papstr;
    DWORD i;

    if (NULL != apstr)
    {
        for (i = *pcString; i-- > 0; )
        {
            if (NULL != apstr[i])
            {
                DBGPRINT((DBG_SS_CERTPOLI, "_FreeStringArray[%u]: '%ws'\n", i, apstr[i]));
                LocalFree(apstr[i]);
            }
        }
        LocalFree(apstr);
        *papstr = NULL;
    }
    *pcString = 0;
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_UnloadDSConfig -- release LDAP related resources
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_UnloadDSConfig()
{
    HRESULT hr;
    
    _ReleaseTemplates();
    if (NULL != m_hCertTypeQuery)
    {
	hr = CACertTypeUnregisterQuery(m_hCertTypeQuery);
	_PrintIfError(hr, "Policy:CACertTypeUnregisterQuery");
        m_hCertTypeQuery = NULL;
    }
    if (NULL != m_pld)
    {
        ldap_unbind(m_pld);
        m_pld = NULL;
    }
    if (NULL != m_strDomainDN)
    {
        SysFreeString(m_strDomainDN);
        m_strDomainDN = NULL;
    }
    if (NULL != m_strConfigDN)
    {
        SysFreeString(m_strConfigDN);
        m_strConfigDN = NULL;
    }
    m_fConfigLoaded = FALSE;
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_LoadDSConfig -- acquire LDAP related resources
//
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_LoadDSConfig(
    IN ICertServerPolicy *pServer,
    IN BOOL fRediscover)
{
    HRESULT hr;
    DWORD dwLogId = 0;

    _UnloadDSConfig();

    if (m_fUseDS)
    {
	hr = myDoesDSExist(TRUE);
	if (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN))
	{
	    dwLogId = MSG_NO_DOMAIN;
	    _JumpError(hr, error, "Policy:myDoesDSExist");
	}

	hr = myRobustLdapBindEx(
                        FALSE,			// fGC
                        fRediscover,
                        LDAP_VERSION3,		// uVersion
			NULL,			// pwszDomainName
                        &m_pld,			// ppld
                        NULL);			// ppwszForestDNSName
	_JumpIfError(hr, error, "Policy:myRobustLdapBindEx");

	// Renewal domain and config containers (%5, %6)

	hr = myGetAuthoritativeDomainDn(m_pld, &m_strDomainDN, &m_strConfigDN);
	_JumpIfError(hr, error, "Policy:myGetAuthoritativeDomainDn");

	if (IsEnterpriseCA(m_CAType))
	{
	    hr = CACertTypeRegisterQuery(0, m_pld, &m_hCertTypeQuery);
	    _JumpIfError(hr, error, "Policy:CACertTypeRegisterQuery");

	    hr = _UpdateTemplates(pServer, TRUE);
	    _JumpIfError(hr, error, "Policy:_UpdateTemplates");
	}
	if (0 < m_ConfigLoadedCount++)
	{
	    hr = LogPolicyEvent(
			g_hInstance,
			MSG_DS_RECONNECTED,
			pServer,
			wszPROPEVENTLOGWARNING,
			NULL);
	    _PrintIfError(hr, "Policy:LogPolicyEvent");
	}
    }
    else
    {
	m_strDomainDN = SysAllocString(L"");
	m_strConfigDN = SysAllocString(L"");
	if (NULL == m_strDomainDN || NULL == m_strConfigDN)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
    }
    m_fConfigLoaded = TRUE;
    hr = S_OK;

error:
    if (0 != dwLogId)
    {
	CSASSERT(m_strDescription);
	::LogModuleStatus(g_hInstance, dwLogId, TRUE, m_strDescription, NULL);
    }
    if (S_OK != hr)
    {
	_UnloadDSConfig();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_Cleanup -- free memory associated with this instance
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_Cleanup()
{
    DWORD i;

    if (m_strDescription)
    {
        SysFreeString(m_strDescription);
        m_strDescription = NULL;
    }

    // RevocationExtension variables:

    if (NULL != m_wszASPRevocationURL)
    {
        LocalFree(m_wszASPRevocationURL);
    	m_wszASPRevocationURL = NULL;
    }

    // SubjectAltNameExtension variables:

    for (i = 0; i < 2; i++)
    {
	if (NULL != m_astrSubjectAltNameProp[i])
	{
	    SysFreeString(m_astrSubjectAltNameProp[i]);
	    m_astrSubjectAltNameProp[i] = NULL;
	}
	if (NULL != m_astrSubjectAltNameObjectId[i])
	{
	    SysFreeString(m_astrSubjectAltNameObjectId[i]);
	    m_astrSubjectAltNameObjectId[i] = NULL;
	}
    }

    _FreeStringArray(&m_cEnableRequestExtensions, &m_apstrEnableRequestExtensions);
    _FreeStringArray(&m_cDisableExtensions, &m_apstrDisableExtensions);

    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
        m_strCAName = NULL;
    }
    if (NULL != m_strCASanitizedName)
    {
        SysFreeString(m_strCASanitizedName);
        m_strCASanitizedName = NULL;
    }
    if (NULL != m_strCASanitizedDSName)
    {
        SysFreeString(m_strCASanitizedDSName);
        m_strCASanitizedDSName = NULL;
    }
    if (NULL != m_strRegStorageLoc)
    {
        SysFreeString(m_strRegStorageLoc);
        m_strRegStorageLoc = NULL;
    }
    if (NULL != m_pCert)
    {
        CertFreeCertificateContext(m_pCert);
        m_pCert = NULL;
    }
    if (m_strMachineDNSName)
    {
        SysFreeString(m_strMachineDNSName);
        m_strMachineDNSName=NULL;
    }

    // end_sdksample

    if (NULL != m_pbSMIME)
    {
	LocalFree(m_pbSMIME);
	m_pbSMIME = NULL;
    }
    _UnloadDSConfig();

    // begin_sdksample
}


HRESULT
CCertPolicyEnterprise::_ReadRegistryString(
    IN HKEY hkey,
    IN BOOL fURL,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszSuffix,
    OUT LPWSTR *ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    *ppwszOut = NULL;
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    NULL,
		    &cbValue);
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:RegQueryValueEx",
		pwszRegName,
		ERROR_FILE_NOT_FOUND);

    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpErrorStr(hr, error, "Policy:RegQueryValueEx TYPE", pwszRegName);
    }
    if (NULL != pwszSuffix)
    {
	cbValue += wcslen(pwszSuffix) * sizeof(WCHAR);
    }
    pwszRegValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
    if (NULL == pwszRegValue)
    {
        hr = E_OUTOFMEMORY;
        _JumpErrorStr(hr, error, "Policy:LocalAlloc", pwszRegName);
    }
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) pwszRegValue,
		    &cbValue);
    _JumpIfErrorStr(hr, error, "Policy:RegQueryValueEx", pwszRegName);

    // Handle malformed registry values cleanly:

    pwszRegValue[cbValue / sizeof(WCHAR)] = L'\0';
    if (NULL != pwszSuffix)
    {
	wcscat(pwszRegValue, pwszSuffix);
    }

    hr = myFormatCertsrvStringArray(
			fURL,			// fURL
			m_strMachineDNSName, 	// pwszServerName_p1_2
			m_strCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			m_strDomainDN,		// pwszDomainDN_p5
			m_strConfigDN, 	// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9
			TRUE,			// fDSAttrib_p10_11
			1,       		// cStrings
			(LPCWSTR *) &pwszRegValue, // apwszStringsIn
			ppwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "Policy:myFormatCertsrvStringArray");

error:
    if (NULL != pwszRegValue)
    {
        LocalFree(pwszRegValue);
    }
    return(myHError(hr));	// Reg routines return Win32 error codes
}


#if DBG_CERTSRV

VOID
CCertPolicyEnterprise::_DumpStringArray(
    IN char const *pszType,
    IN DWORD count,
    IN BSTR const *apstr)
{
    DWORD i;
    WCHAR const *pwszName;

    for (i = 0; i < count; i++)
    {
	pwszName = L"";
	if (iswdigit(apstr[i][0]))
	{
	    pwszName = myGetOIDName(apstr[i]);	// Static: do not free!
	}
	DBGPRINT((
		DBG_SS_CERTPOLI,
		"%hs[%u]: %ws%hs%ws\n",
		pszType,
		i,
		apstr[i],
		L'\0' != *pwszName? " -- " : "",
		pwszName));
    }
}
#endif // DBG_CERTSRV


HRESULT
CCertPolicyEnterprise::_SetSystemStringProp(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const *pwszValue)
{
    HRESULT hr;
    BSTR strName = NULL;
    VARIANT varValue;

    varValue.vt = VT_NULL;
    varValue.bstrVal = NULL;

    if (!myConvertWszToBstr(&strName, pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    if (NULL != pwszValue)
    {
        if (!myConvertWszToBstr(&varValue.bstrVal, pwszValue, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertWszToBstr");
	}
	varValue.vt = VT_BSTR;
    }
    
    hr = pServer->SetCertificateProperty(strName, PROPTYPE_STRING, &varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_AddStringArray(
    IN WCHAR const *pwszzValue,
    IN BOOL fURL,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr;
    DWORD cString = 0;
    WCHAR const *pwsz;
    LPCWSTR *awszFormatStrings = NULL;
    LPWSTR *awszOutputStrings = NULL;

    // Count the number of strings we're adding
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        cString++;
    }
    if (0 == cString)		// no strings
    {
	hr = S_OK;
        goto error;
    }
    awszFormatStrings = (LPCWSTR *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cString * sizeof(LPWSTR));
    if (NULL == awszFormatStrings)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:LocalAlloc");
    }

    cString = 0;
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        // Skip strings that start with a an unescaped minus sign.
        // Strings with an escaped minus sign (2 minus signs) are not skipped.

        if (L'-' == *pwsz)
        {
	    pwsz++;
	    if (L'-' != *pwsz)
	    {
                continue;
	    }
        }
        awszFormatStrings[cString++] = pwsz;
    }

    // if no strings to add, don't modify
    if (cString > 0)
    {
        awszOutputStrings = (LPWSTR *) LocalAlloc(
			        LMEM_FIXED | LMEM_ZEROINIT,
			        (cString + *pcStrings) * sizeof(LPWSTR));
        if (NULL == awszOutputStrings)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "Policy:LocalAlloc");
        }

        if (0 != *pcStrings)
        {
            CSASSERT(NULL != *papstrRegValues);
            CopyMemory(
		awszOutputStrings,
		*papstrRegValues,
		*pcStrings * sizeof(LPWSTR));
        }

        hr = myFormatCertsrvStringArray(
		fURL,				// fURL
		m_strMachineDNSName,		// pwszServerName_p1_2
		m_strCASanitizedName,		// pwszSanitizedName_p3_7
		m_iCert,			// iCert_p4
		m_strDomainDN,			// pwszDomainDN_p5
		m_strConfigDN,			// pwszConfigDN_p6
		m_iCRL,				// iCRL_p8
		FALSE,				// fDeltaCRL_p9
		TRUE,				// fDSAttrib_p10_11
		cString,			// cStrings
		awszFormatStrings,		// apwszStringsIn
		awszOutputStrings + (*pcStrings)); // apwszStringsOut
	_JumpIfError(hr, error, "Policy:myFormatCertsrvStringArray");

        *pcStrings = (*pcStrings) + cString;
        if (*papstrRegValues)
        {
            LocalFree(*papstrRegValues);
        }
        *papstrRegValues = awszOutputStrings;
        awszOutputStrings = NULL;
    }
    hr = S_OK;

error:
    if (NULL != awszOutputStrings)
    {
        LocalFree(awszOutputStrings);
    }
    if (NULL != awszFormatStrings)
    {
        LocalFree(awszFormatStrings);
    }
    return(hr);	
}


HRESULT
CCertPolicyEnterprise::_ReadRegistryStringArray(
    IN HKEY hkey,
    IN BOOL fURL,
    IN DWORD dwFlags,
    IN DWORD cRegNames,
    IN DWORD *aFlags,
    IN WCHAR const * const *apwszRegNames,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    for (i = 0; i < cRegNames; i++)
    {
        if (0 == (dwFlags & aFlags[i]))
        {
	    continue;
        }
        if (NULL != pwszzValue)
        {
	    LocalFree(pwszzValue);
	    pwszzValue = NULL;
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        NULL,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr2(
			hr,
			"Policy:RegQueryValueEx",
			apwszRegNames[i],
			ERROR_FILE_NOT_FOUND);
	    continue;
        }
        if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx TYPE", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly by adding two WCHAR L'\0's
	// allocate space for 3 WCHARs to allow for unaligned (odd) cbValue;

        pwszzValue = (WCHAR *) LocalAlloc(
				        LMEM_FIXED,
				        cbValue + 3 * sizeof(WCHAR));
        if (NULL == pwszzValue)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpErrorStr(hr, error, "Policy:LocalAlloc", apwszRegNames[i]);
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        (BYTE *) pwszzValue,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly:

        pwszzValue[cbValue / sizeof(WCHAR)] = L'\0';
        pwszzValue[cbValue / sizeof(WCHAR) + 1] = L'\0';

        hr = _AddStringArray(
			pwszzValue,
			fURL,
			pcStrings,
			papstrRegValues);
        _JumpIfErrorStr(hr, error, "_AddStringArray", apwszRegNames[i]);
    }
    hr = S_OK;

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitRevocationExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitRevocationExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;

    cb = sizeof(m_dwRevocationFlags);
    hr = RegQueryValueEx(
                hkey,
                wszREGREVOCATIONTYPE,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwRevocationFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwRevocationFlags) != cb)
    {
        goto error;
    }
    DBGPRINT((DBG_SS_CERTPOL, "Revocation Flags = %x\n", m_dwRevocationFlags));

    // clean up from previous call

    if (NULL != m_wszASPRevocationURL)
    {
	LocalFree(m_wszASPRevocationURL);
	m_wszASPRevocationURL = NULL;
    }

    if (REVEXT_ASPENABLE & m_dwRevocationFlags)
    {
        hr = _ReadRegistryString(
			    hkey,
			    TRUE,			// fURL
			    wszREGREVOCATIONURL,	// pwszRegName
			    L"?",			// pwszSuffix
			    &m_wszASPRevocationURL);	// pstrRegValue
        _JumpIfErrorStr(hr, error, "_ReadRegistryString", wszREGREVOCATIONURL);
        _DumpStringArray("ASP", 1, &m_wszASPRevocationURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitRequestExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitRequestExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
	EDITF_REQUESTEXTENSIONLIST,
    };
    WCHAR *apwszRegNames[] = {
	wszREGENABLEREQUESTEXTENSIONLIST,
    };

    CSASSERT(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));

    // clean up from previous call

    if (NULL != m_apstrEnableRequestExtensions)
    {
        _FreeStringArray(
		    &m_cEnableRequestExtensions,
		    &m_apstrEnableRequestExtensions);
    }


    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cEnableRequestExtensions,
			&m_apstrEnableRequestExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"Request",
		m_cEnableRequestExtensions,
		m_apstrEnableRequestExtensions);

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitDisableExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitDisableExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
	EDITF_DISABLEEXTENSIONLIST,
    };
    WCHAR *apwszRegNames[] = {
	wszREGDISABLEEXTENSIONLIST,
    };

    CSASSERT(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));

    // clean up from previous call

    if (NULL != m_apstrDisableExtensions)
    {
        _FreeStringArray(&m_cDisableExtensions, &m_apstrDisableExtensions);
    }


    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cDisableExtensions,
			&m_apstrDisableExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"Disable",
		m_cDisableExtensions,
		m_apstrDisableExtensions);

error:
    ;
}


// end_sdksample

//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitDefaultSMIMEExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitDefaultSMIMEExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    CRYPT_SMIME_CAPABILITIES SMIME = { 0, NULL };
    CRYPT_SMIME_CAPABILITY *pSMIME;
    DWORD cSMIME;
    DWORD i;
    LPWSTR *apstrSMIME = NULL;
    DWORD adwFlags[] = {
	EDITF_ENABLEDEFAULTSMIME,
    };
    WCHAR *apwszRegNames[] = {
	wszREGDEFAULTSMIME,
    };

    CSASSERT(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));

    // clean up from previous call

    if (NULL != m_pbSMIME)
    {
	LocalFree(m_pbSMIME);
	m_pbSMIME = NULL;
    }

    cSMIME = 0;
    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&cSMIME,
			&apstrSMIME);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray("SMIME", cSMIME, apstrSMIME);

    if (0 != cSMIME)
    {
	SMIME.rgCapability = (CRYPT_SMIME_CAPABILITY *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cSMIME * sizeof(SMIME.rgCapability[0]));
	if (NULL == SMIME.rgCapability)
	{
	    _JumpError(E_OUTOFMEMORY, error, "Policy:LocalAlloc");
	}
	SMIME.cCapability = cSMIME;

	for (i = 0; i < cSMIME; i++)
	{
	    WCHAR *pwszKeyLength = wcschr(apstrSMIME[i], L',');

	    pSMIME = &SMIME.rgCapability[i];
	    if (NULL != pwszKeyLength)
	    {
		DWORD dwKeyLength;

		*pwszKeyLength++ = L'\0';
		dwKeyLength = _wtoi(pwszKeyLength);
		if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_INTEGER,
			    &dwKeyLength,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pSMIME->Parameters.pbData,
			    &pSMIME->Parameters.cbData))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "Policy:myEncodeObject");
		}
	    }
	    if (!myConvertWszToSz(&pSMIME->pszObjId, apstrSMIME[i], -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }
	}
	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    PKCS_SMIME_CAPABILITIES,
		    &SMIME,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &m_pbSMIME,
		    &m_cbSMIME))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myEncodeObject");
	}
    }

error:
    if (NULL != apstrSMIME)
    {
	_FreeStringArray(&cSMIME, &apstrSMIME);
    }
    if (NULL != SMIME.rgCapability)
    {
	for (i = 0; i < SMIME.cCapability; i++)
	{
	    pSMIME = &SMIME.rgCapability[i];

	    if (NULL != pSMIME->Parameters.pbData)
	    {
		LocalFree(pSMIME->Parameters.pbData);
	    }
	    if (NULL != pSMIME->pszObjId)
	    {
		LocalFree(pSMIME->pszObjId);
	    }
	}
	LocalFree(SMIME.rgCapability);
    }
}
// begin_sdksample


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitSubjectAltNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitSubjectAltNameExtension(
    IN HKEY hkey,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszObjectId,
    IN DWORD iAltName)
{
    DWORD err;
    DWORD dwType;
    DWORD cbbuf;
    WCHAR awcbuf[MAX_PATH];

    cbbuf = sizeof(awcbuf) - 2 * sizeof(WCHAR);
    err = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,         // lpdwReserved
		    &dwType,
		    (BYTE *) awcbuf,
		    &cbbuf);
    if (ERROR_SUCCESS != err ||
        REG_SZ != dwType ||
        sizeof(awcbuf) - 2 * sizeof(WCHAR) <= cbbuf)
    {
        goto error;
    }
    if (0 == lstrcmpi(awcbuf, wszATTREMAIL1) ||
	0 == lstrcmpi(awcbuf, wszATTREMAIL2))
    {
        if (!myConvertWszToBstr(
			&m_astrSubjectAltNameObjectId[iAltName],
			pwszObjectId,
			-1))
	{
	    _JumpError(E_OUTOFMEMORY, error, "Policy:myConvertWszToBstr");
	}

        if (!myConvertWszToBstr(
			&m_astrSubjectAltNameProp[iAltName],
			wszPROPSUBJECTEMAIL,
			-1))
	{
	    _JumpError(E_OUTOFMEMORY, error, "Policy:myConvertWszToBstr");
	}
    }
    DBGPRINT((
	DBG_SS_CERTPOLI,
	"Policy: %ws(RDN=%ws): %ws\n",
	pwszRegName,
	awcbuf,
	m_astrSubjectAltNameProp[iAltName]));

error:
    ;
}



//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::Initialize(
    /* [in] */ BSTR const strConfig)
{
    HRESULT hr;
    HKEY hkey = NULL;
    DWORD dwType;
    DWORD dwSize;
    ICertServerPolicy *pServer = NULL;
    BOOL fCritSecEntered = FALSE;
    BOOL fUpgraded;
    BSTR bstrDescription = NULL;

    CERT_RDN_ATTR rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE, };
    CERT_RDN rdn = { 1, &rdnAttr };

    rdnAttr.Value.pbData = NULL;

    DBGPRINT((DBG_SS_CERTPOL, "Policy:Initialize:\n"));

    if (!m_fPolicyCriticalSection)
    {
	__try
	{
	    InitializeCriticalSection(&m_PolicyCriticalSection);
	    m_fPolicyCriticalSection = TRUE;
	    hr = S_OK;
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
        _JumpIfError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&m_PolicyCriticalSection);
    fCritSecEntered = TRUE;

    __try
    {
	_Cleanup();

	m_strCAName = SysAllocString(strConfig);

	// force loading the description from resources

	hr = GetDescription(&bstrDescription);
	_LeaveIfError(hr, "CCertPolicyEnterprise::GetDescription");

	// get server callbacks

	hr = polGetServerCallbackInterface(&pServer, 0);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");

	// get storage location
	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPMODULEREGLOC,
				    &m_strRegStorageLoc);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPMODULEREGLOC);


	// get CA type

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCATYPE,
				    (LONG *) &m_CAType);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCATYPE);

	// end_sdksample

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPUSEDS,
				    (LONG *) &m_fUseDS);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszREGCAUSEDS);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPLOGLEVEL,
				    (LONG *) &m_dwLogLevel);
	if (S_OK != hr)
	{
	    m_dwLogLevel = CERTLOG_WARNING;
	    _PrintErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPLOGLEVEL);
	}

	// begin_sdksample

	// get sanitized name

	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDCANAME,
				    &m_strCASanitizedName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDCANAME);

	// get sanitized name

	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDSHORTNAME,
				    &m_strCASanitizedDSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDSHORTNAME);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPSERVERUPGRADED,
				    (LONG *) &fUpgraded);
	if (S_OK != hr)
	{
	    fUpgraded = FALSE;
	    _PrintErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPSERVERUPGRADED);
	}

	hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		m_strRegStorageLoc,
		0,              // dwReserved
		fUpgraded?
		    KEY_ALL_ACCESS :
		    (KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE),
		&hkey);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:Initialize:RegOpenKeyEx",
		    m_strRegStorageLoc);

	// Ignore error codes.

	dwSize = sizeof(m_dwDispositionFlags);
	hr = RegQueryValueEx(
			hkey,
			wszREGREQUESTDISPOSITION,
			0,
			&dwType,
			(BYTE *) &m_dwDispositionFlags,
			&dwSize);
	if (S_OK != hr)
	{
	    m_dwDispositionFlags = 0;
	}
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    "Disposition Flags = %x\n",
	    m_dwDispositionFlags));

	dwSize = sizeof(m_dwEditFlags);
	hr = RegQueryValueEx(
			hkey,
			wszREGEDITFLAGS,
			0,
			&dwType,
			(BYTE *) &m_dwEditFlags,
			&dwSize);
	if (S_OK != hr)
	{
	    m_dwEditFlags = 0;
	}
	if (fUpgraded)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"Initialize: setting EDITF_SERVERUPGRADED\n"));

	    m_dwEditFlags |= EDITF_SERVERUPGRADED;
	    dwSize = sizeof(m_dwEditFlags);
	    hr = RegSetValueEx(
			    hkey,
			    wszREGEDITFLAGS,
			    0,
			    REG_DWORD,
			    (BYTE *) &m_dwEditFlags,
			    dwSize);
	    _PrintIfError(hr, "Policy:RegSetValueEx");
	}
	DBGPRINT((DBG_SS_CERTPOL, "Edit Flags = %x\n", m_dwEditFlags));

	dwSize = sizeof(m_CAPathLength);
	hr = RegQueryValueEx(
			hkey,
			wszREGCAPATHLENGTH,
			0,
			&dwType,
			(BYTE *) &m_CAPathLength,
			&dwSize);
	if (S_OK != hr)
	{
	    m_CAPathLength = CAPATHLENGTH_INFINITE;
	}
	DBGPRINT((DBG_SS_CERTPOL, "CAPathLength = %x\n", m_CAPathLength));


	// Initialize the insertion string array.
	// Machine DNS name (%1)

	hr = polGetCertificateStringProperty(
			    pServer,
			    wszPROPMACHINEDNSNAME,
			    &m_strMachineDNSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPMACHINEDNSNAME);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCERTCOUNT,
				    (LONG *) &m_iCert);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCERTCOUNT);
	m_iCert--;

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCRLINDEX,
				    (LONG *) &m_iCRL);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCRLINDEX);

	hr = polGetCertificateLongProperty(
                                pServer,
                                wszPROPTEMPLATECHANGESEQUENCENUMBER,
                                (LONG *) &m_dwCATemplListSequenceNum);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPTEMPLATECHANGESEQUENCENUMBER);
	
	_InitRevocationExtension(hkey);
	_InitRequestExtensionList(hkey);
	_InitDisableExtensionList(hkey);

	if (IsStandaloneCA(m_CAType))	// no_sdksample
	{
	    _InitSubjectAltNameExtension(
				hkey,
				wszREGSUBJECTALTNAME,
				TEXT(szOID_SUBJECT_ALT_NAME),
				0);
	    _InitSubjectAltNameExtension(
				hkey,
				wszREGSUBJECTALTNAME2,
				TEXT(szOID_SUBJECT_ALT_NAME2),
				1);
	}

	// end_sdksample

	_InitDefaultSMIMEExtension(hkey);

	hr = _LoadDSConfig(pServer, FALSE);
	_PrintIfError(hr, "Policy:_LoadDSConfig");

	// if we fail the bind, don't sweat it, as we'll try again later,
	// at each request, and when GPO download happens.
	// begin_sdksample

	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != bstrDescription)
    {
        SysFreeString(bstrDescription);
    }
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    if (NULL != pServer)
    {
	pServer->Release();
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&m_PolicyCriticalSection);
    }
    return(myHError(hr));	// Reg routines return Win32 error codes
}


DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR **ppwsz)
{
    DWORD i;

    for (i = 0; i < count; i++)
    {
	if (0 == wcscmp(pwsz, ppwsz[i]))
	{
	    break;
	}
    }
    return(i < count? i : MAXDWORD);
}


HRESULT
CCertPolicyEnterprise::_EnumerateExtensions(
    IN ICertServerPolicy *pServer,
    IN LONG bNewRequest,
    IN BOOL fFirstPass)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varValue;
    BOOL fClose = FALSE;
    BOOL fEnable;
    BOOL fDisable;

    VariantInit(&varValue);

    hr = pServer->EnumerateExtensionsSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateExtensionsSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateExtensions(&strName);
        if (S_FALSE == hr)
        {
            hr = S_OK;
            break;
        }
        _JumpIfError(hr, error, "Policy:EnumerateExtensions");

        hr = pServer->GetCertificateExtension(
                                        strName,
                                        PROPTYPE_BINARY,
                                        &varValue);
        _JumpIfError(hr, error, "Policy:GetCertificateExtension");

        hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	fEnable = FALSE;
	fDisable = FALSE;

        if (fFirstPass)
        {
            if (bNewRequest && (EXTENSION_DISABLE_FLAG & ExtFlags))
            {
                switch (EXTENSION_ORIGIN_MASK & ExtFlags)
                {
                    case EXTENSION_ORIGIN_REQUEST:
                    case EXTENSION_ORIGIN_RENEWALCERT:
                    case EXTENSION_ORIGIN_PKCS7:
                    case EXTENSION_ORIGIN_CMC:
                    if ((EDITF_ENABLEREQUESTEXTENSIONS & m_dwEditFlags) ||
			MAXDWORD != polFindObjIdInList(
					    strName,
					    m_cEnableRequestExtensions,
					    m_apstrEnableRequestExtensions))
                    {
			fEnable = TRUE;
                    }
                    break;
                }
            }
        }
        else
        {
            if (0 == (EXTENSION_DISABLE_FLAG & ExtFlags) &&
		MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cDisableExtensions,
				    m_apstrDisableExtensions))
            {
                fDisable = TRUE;
            }
        }

        if (fDisable || fEnable)
        {
            if (fEnable)
            {
                ExtFlags &= ~EXTENSION_DISABLE_FLAG;
            }
            else
            {
                ExtFlags |= EXTENSION_DISABLE_FLAG;
            }
            hr = pServer->SetCertificateExtension(
			            strName,
			            PROPTYPE_BINARY,
			            ExtFlags,
			            &varValue);
            _JumpIfError(hr, error, "Policy:SetCertificateExtension");
        }

        if (fFirstPass || fDisable || fEnable)
        {
	    DBGPRINT((
		DBG_SS_CERTPOL,
                "Policy:EnumerateExtensions(%ws, Flags=%x, %x bytes)%hs\n",
                strName,
                ExtFlags,
                SysStringByteLen(varValue.bstrVal),
		fDisable? " DISABLING" : (fEnable? " ENABLING" : "")));
        }
        VariantClear(&varValue);
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateExtensionsClose();
        if (S_OK != hr2)
        {
            if (S_OK == hr)
            {
                hr = hr2;
            }
	    _PrintError(hr2, "Policy:EnumerateExtensionsClose");
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    VariantClear(&varValue);
    return(hr);
}


HRESULT
EnumerateAttributes(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    BOOL fClose = FALSE;
    BSTR strValue = NULL;

    hr = pServer->EnumerateAttributesSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateAttributesSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateAttributes(&strName);
	if (S_FALSE == hr)
	{
	    hr = S_OK;
	    break;
	}
	_JumpIfError(hr, error, "Policy:EnumerateAttributes");

        hr = pServer->GetRequestAttribute(strName, &strValue);
	_JumpIfError(hr, error, "Policy:GetRequestAttribute");

	DBGPRINT((
		DBG_SS_CERTPOL,
                "Policy:EnumerateAttributes(%ws = %ws)\n",
                strName,
                strValue));
        if (NULL != strValue)
        {
            SysFreeString(strValue);
            strValue = NULL;
        }
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateAttributesClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateAttributesClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }

    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
CheckRequestProperties(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    LONG lRequestId;

    hr = polGetRequestLongProperty(pServer, wszPROPREQUESTREQUESTID, &lRequestId);
    _JumpIfError(hr, error, "Policy:polGetRequestLongProperty");

    DBGPRINT((
	DBG_SS_CERTPOL,
	"Policy:CheckRequestProperties(%ws = %u)\n",
	wszPROPREQUESTREQUESTID,
	lRequestId));

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddRevocationExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddRevocationExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strASPExtension = NULL;
    VARIANT varExtension;
    DWORD i;

    if (NULL != m_wszASPRevocationURL)
    {
	strASPExtension = SysAllocString(m_wszASPRevocationURL);
	if (NULL == strASPExtension)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strASPExtension;
	hr = pServer->SetCertificateExtension(
				TEXT(szOID_NETSCAPE_REVOCATION_URL),
				PROPTYPE_STRING,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "Policy:SetCertificateExtension", L"ASP");
    }

error:
    if (NULL != strASPExtension)
    {
        SysFreeString(strASPExtension);
    }
    return(hr);
}


#define HIGHBIT(bitno)	(1 << (7 - (bitno)))	// bit counted from high end

#define SSLBIT_CLIENT	((BYTE) HIGHBIT(0))	// certified for client auth
#define SSLBIT_SERVER	((BYTE) HIGHBIT(1))	// certified for server auth
#define SSLBIT_SMIME	((BYTE) HIGHBIT(2))	// certified for S/MIME
#define SSLBIT_SIGN	((BYTE) HIGHBIT(3))	// certified for signing

#define SSLBIT_RESERVED	((BYTE) HIGHBIT(4))	// reserved for future use

#define SSLBIT_CASSL	((BYTE) HIGHBIT(5))	// CA for SSL auth certs
#define SSLBIT_CASMIME	((BYTE) HIGHBIT(6))	// CA for S/MIME certs
#define SSLBIT_CASIGN	((BYTE) HIGHBIT(7))	// CA for signing certs

#define NSCERTTYPE_CLIENT  ((BYTE) SSLBIT_CLIENT)
#define NSCERTTYPE_SERVER  ((BYTE) (SSLBIT_SERVER | SSLBIT_CLIENT))
#define NSCERTTYPE_SMIME   ((BYTE) SSLBIT_SMIME)
#define NSCERTTYPE_CA	   ((BYTE) (SSLBIT_CASSL | SSLBIT_CASMIME | SSLBIT_CASIGN))

//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddOldCertTypeExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddOldCertTypeExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr = S_OK;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    BSTR strCertType = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    DWORD cb;

    VariantInit(&varConstraints);

    if (EDITF_ADDOLDCERTTYPE & m_dwEditFlags)
    {
	BYTE CertType;

	if (!fCA)
	{
	    hr = pServer->GetCertificateExtension(
					TEXT(szOID_BASIC_CONSTRAINTS2),
					PROPTYPE_BINARY,
					&varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	hr = CoCreateInstance(
			CLSID_CCertEncodeBitString,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeBitString,
			(VOID **) &pBitString);
	_JumpIfError(hr, error, "Policy:CoCreateInstance");

	CertType = NSCERTTYPE_CLIENT;	// Default to client auth. cert
	if (fCA)
	{
	    CertType = NSCERTTYPE_CA;
	}
	else
	{
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
	    if (S_OK == hr)
	    {
		if (0 == lstrcmpi(strCertType, L"server"))
		{
		    CertType = NSCERTTYPE_SERVER;
		}
	    }
	}

        if (!myConvertWszToBstr(
		    &strBitString,
		    (WCHAR const *) &CertType,
		    sizeof(CertType)))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertWszToBstr");
	}

	hr = pBitString->Encode(
			    sizeof(CertType) * 8,
			    strBitString,
			    &strExtension);
	_JumpIfError(hr, error, "Policy:BitString:Encode");

        varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strExtension;
	hr = pServer->SetCertificateExtension(
				TEXT(szOID_NETSCAPE_CERT_TYPE),
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }

error:
    VariantClear(&varConstraints);
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddAuthorityKeyId
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddAuthorityKeyId(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo = NULL;
    DWORD cbInfo = 0;
    LONG ExtFlags = 0;

    // Optimization

    if ((EDITF_ENABLEAKIKEYID |
	 EDITF_ENABLEAKIISSUERNAME |
	 EDITF_ENABLEAKIISSUERSERIAL) ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL |
	  EDITF_ENABLEAKICRITICAL) & m_dwEditFlags))
    {
        goto error;
    }

    hr = pServer->GetCertificateExtension(
                                    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
                                    PROPTYPE_BINARY,
                                    &varExtension);
    _JumpIfError(hr, error, "Policy:GetCertificateExtension");

    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

    if (VT_BSTR != varExtension.vt)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Policy:GetCertificateExtension");
    }

    cbInfo = 0;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
                    X509_AUTHORITY_KEY_ID2,
                    (PBYTE)varExtension.bstrVal,
                    SysStringByteLen(varExtension.bstrVal),
		    CERTLIB_USE_LOCALALLOC,
                    (PVOID *)&pInfo,
                    &cbInfo))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "Policy:myDecodeObject");
    }

    // Make Any Modifications Here

    if (0 == (EDITF_ENABLEAKIKEYID & m_dwEditFlags))
    {
        pInfo->KeyId.cbData = 0;
        pInfo->KeyId.pbData = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERNAME & m_dwEditFlags))
    {
        pInfo->AuthorityCertIssuer.cAltEntry = 0;
        pInfo->AuthorityCertIssuer.rgAltEntry = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERSERIAL & m_dwEditFlags))
    {
        pInfo->AuthorityCertSerialNumber.cbData = 0;
        pInfo->AuthorityCertSerialNumber.pbData = NULL;
    }
    if (EDITF_ENABLEAKICRITICAL & m_dwEditFlags)
    {
	ExtFlags |= EXTENSION_CRITICAL_FLAG;
    }
    if (0 ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL) & m_dwEditFlags))
    {
	ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    VariantClear(&varExtension);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_KEY_ID2,
		    pInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }
    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtension(AuthorityKeyId2)");

error:
    if (NULL != pInfo)
    {
	LocalFree(pInfo);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddDefaultKeyUsageExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr;
    BSTR strName = NULL;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    VARIANT varKeyUsage;
    CRYPT_BIT_BLOB *pKeyUsage = NULL;
    DWORD cb;
    BYTE abKeyUsage[1];
    BYTE *pbKeyUsage;
    DWORD cbKeyUsage;

    VariantInit(&varConstraints);
    VariantInit(&varKeyUsage);

    if (EDITF_ADDOLDKEYUSAGE & m_dwEditFlags)
    {
	BOOL fModified = FALSE;

	if (!fCA)
	{
	    hr = pServer->GetCertificateExtension(
					TEXT(szOID_BASIC_CONSTRAINTS2),
					PROPTYPE_BINARY,
					&varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	ZeroMemory(abKeyUsage, sizeof(abKeyUsage));
	pbKeyUsage = abKeyUsage;
	cbKeyUsage = sizeof(abKeyUsage);

	hr = pServer->GetCertificateExtension(
				    TEXT(szOID_KEY_USAGE),
				    PROPTYPE_BINARY,
				    &varKeyUsage);
	if (S_OK == hr)
	{
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    (BYTE const *) varKeyUsage.bstrVal,
			    SysStringByteLen(varKeyUsage.bstrVal),
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pKeyUsage,
			    &cb))
	    {
		hr = GetLastError();
		_PrintError(hr, "Policy:myDecodeObject");
	    }
	    else if (0 != cb && NULL != pKeyUsage && 0 != pKeyUsage->cbData)
	    {
		pbKeyUsage = pKeyUsage->pbData;
		cbKeyUsage = pKeyUsage->cbData;
	    }
	}

	if ((CERT_KEY_ENCIPHERMENT_KEY_USAGE & pbKeyUsage[0]) &&
	    (CERT_KEY_AGREEMENT_KEY_USAGE & pbKeyUsage[0]))
	{
	    pbKeyUsage[0] &= ~CERT_KEY_AGREEMENT_KEY_USAGE;
	    pbKeyUsage[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE |
				CERT_NON_REPUDIATION_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fCA)
	{
	    pbKeyUsage[0] |= CERT_KEY_CERT_SIGN_KEY_USAGE |
				CERT_CRL_SIGN_KEY_USAGE |
				CERT_DIGITAL_SIGNATURE_KEY_USAGE |
				CERT_NON_REPUDIATION_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fModified)
	{
	    hr = CoCreateInstance(
			    CLSID_CCertEncodeBitString,
			    NULL,               // pUnkOuter
			    CLSCTX_INPROC_SERVER,
			    IID_ICertEncodeBitString,
			    (VOID **) &pBitString);
	    _JumpIfError(hr, error, "Policy:CoCreateInstance");

	    if (!myConvertWszToBstr(
			&strBitString,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }

	    hr = pBitString->Encode(cbKeyUsage * 8, strBitString, &strExtension);
	    _JumpIfError(hr, error, "Policy:Encode");

	    if (!myConvertWszToBstr(&strName, TEXT(szOID_KEY_USAGE), -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    varExtension.bstrVal = strExtension;
	    hr = pServer->SetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    0,
				    &varExtension);
	    _JumpIfError(hr, error, "Policy:SetCertificateExtension");
	}
    }
    hr = S_OK;

error:
    VariantClear(&varConstraints);
    VariantClear(&varKeyUsage);
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_AddEnhancedKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR strUsage = NULL;
    char *pszUsage = NULL;
    char *psz;
    char *pszNext;
    CERT_ENHKEY_USAGE ceu;
    CERT_POLICIES_INFO cpi;
    BYTE *pbKeyUsage = NULL;
    DWORD cbKeyUsage;
    BYTE *pbPolicies = NULL;
    DWORD cbPolicies;
    CERT_POLICY_INFO *pcpi = NULL;
    DWORD i;
    VARIANT varExtension;
    
    ZeroMemory(&ceu, sizeof(ceu));
    ZeroMemory(&cpi, sizeof(cpi));
    VariantInit(&varExtension);

    if (0 == (EDITF_ATTRIBUTEEKU & m_dwEditFlags))
    {
	hr = S_OK;
	goto error;
    }
    hr = polGetRequestAttribute(pServer, wszPROPCERTUSAGE, &strUsage);
    if (S_OK != hr)
    {
	hr = S_OK;
	goto error;
    }
    if (!myConvertWszToSz(&pszUsage, strUsage, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    for (psz = pszUsage; '\0' != *psz; psz = pszNext)
    {
	pszNext = &psz[strcspn(psz, ",")];
	if ('\0' != *pszNext)
	{
	    pszNext++;
	}
	ceu.cUsageIdentifier++;
    }
    if (0 == ceu.cUsageIdentifier)
    {
	hr = S_OK;
	goto error;
    }

    ceu.rgpszUsageIdentifier = (char **) LocalAlloc(
		LMEM_FIXED,
		ceu.cUsageIdentifier * sizeof(ceu.rgpszUsageIdentifier[0]));
    if (NULL == ceu.rgpszUsageIdentifier)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    // Destructively parse comma separated ObjIds into individual strings

    i = 0;
    for (psz = pszUsage; '\0' != *psz; psz = pszNext)
    {
	char *pszEnd;
	
	CSASSERT(i < ceu.cUsageIdentifier);
	pszNext = &psz[strcspn(psz, ",")];
	pszEnd = pszNext;
	if ('\0' != *pszNext)
	{
	    *pszNext++ = '\0';
	}
	while (' ' == *psz)
	{
	    psz++;
	}
	while (pszEnd > psz && ' ' == *--pszEnd)
	{
	    *pszEnd = '\0';
	}
	if ('\0' != *psz)
	{
	    hr = myVerifyObjIdA(psz);
	    _JumpIfError(hr, error, "Policy:myVerifyObjIdA");

	    ceu.rgpszUsageIdentifier[i++] = psz;
	}
    }
    ceu.cUsageIdentifier = i;
    if (0 == ceu.cUsageIdentifier)
    {
	hr = S_OK;
	goto error;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ENHANCED_KEY_USAGE,
		    &ceu,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbKeyUsage,
		    &cbKeyUsage))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    varExtension.bstrVal = NULL;
    if (!myConvertWszToBstr(
			&varExtension.bstrVal,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_ENHANCED_KEY_USAGE),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtensioo");

    cpi.cPolicyInfo = ceu.cUsageIdentifier;
    cpi.rgPolicyInfo = (CERT_POLICY_INFO *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cpi.cPolicyInfo * sizeof(cpi.rgPolicyInfo[0]));
    if (NULL == cpi.rgPolicyInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:LocalAlloc");
    }
    for (i = 0; i < cpi.cPolicyInfo; i++)
    {
	cpi.rgPolicyInfo[i].pszPolicyIdentifier = ceu.rgpszUsageIdentifier[i];
    }
    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_POLICIES,
		    &cpi,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbPolicies,
		    &cbPolicies))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    if (!myConvertWszToBstr(
			&varExtension.bstrVal,
			(WCHAR const *) pbPolicies,
			cbPolicies))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_APPLICATION_CERT_POLICIES),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtensioo");

error:
    if (NULL != pcpi)
    {
	LocalFree(pcpi);
    }
    VariantClear(&varExtension);
    if (NULL != ceu.rgpszUsageIdentifier)
    {
	LocalFree(ceu.rgpszUsageIdentifier);
    }
    if (NULL != pbPolicies)
    {
	LocalFree(pbPolicies);
    }
    if (NULL != pbKeyUsage)
    {
	LocalFree(pbKeyUsage);
    }
    if (NULL != pszUsage)
    {
	LocalFree(pszUsage);
    }
    if (NULL != strUsage)
    {
	SysFreeString(strUsage);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddDefaultBasicConstraintsExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL               fCA)
{
    HRESULT hr;
    VARIANT varExtension;
    LONG ExtFlags;
    CERT_EXTENSION Ext;
    CERT_EXTENSION *pExtension = NULL;
    BSTR strCertType = NULL;

    VariantInit(&varExtension);

    if (EDITF_BASICCONSTRAINTSCA & m_dwEditFlags)
    {
        hr = pServer->GetCertificateExtension(
				        TEXT(szOID_BASIC_CONSTRAINTS2),
				        PROPTYPE_BINARY,
				        &varExtension);
        if (S_OK == hr)
        {
	    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
	    DWORD cb;

	    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	    if (S_OK == hr)
	    {
                Ext.pszObjId = szOID_BASIC_CONSTRAINTS2;
                Ext.fCritical = FALSE;
                if (EXTENSION_CRITICAL_FLAG & ExtFlags)
                {
                    Ext.fCritical = TRUE;
                }
                Ext.Value.pbData = (BYTE *) varExtension.bstrVal;
                Ext.Value.cbData = SysStringByteLen(varExtension.bstrVal);
		pExtension = &Ext;

		cb = sizeof(Constraints);
		if (!fCA && CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        Ext.Value.pbData,
			        Ext.Value.cbData,
			        0,
			        &Constraints,
			        &cb))
		{
		    fCA = Constraints.fCA;
		}
	    }
	}
    }

    if (EDITF_ATTRIBUTECA & m_dwEditFlags)
    {
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == lstrcmpi(strCertType, L"ca"))
                {
                    fCA = TRUE;
                }
            }
        }
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == lstrcmpi(strCertType, wszCERTTYPE_SUBORDINATE_CA))
                {
                    fCA = TRUE;
                }
            }
	}
    }

    // For standalone, the extension is only enabled if it's a CA

    hr = AddBasicConstraintsCommon(pServer, pExtension, fCA, fCA);
    _JumpIfError(hr, error, "Policy:AddBasicConstraintsCommon");

error:
    VariantClear(&varExtension);
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    return(hr);
}


HRESULT
CCertPolicyEnterprise::AddBasicConstraintsCommon(
    IN ICertServerPolicy *pServer,
    IN CERT_EXTENSION const *pExtension,
    IN BOOL fCA,
    IN BOOL fEnableExtension)
{
    HRESULT hr;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    CERT_CONTEXT const *pIssuerCert;
    CERT_EXTENSION *pIssuerExtension;
    LONG ExtFlags = 0;
    BYTE *pbConstraints = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    CERT_BASIC_CONSTRAINTS2_INFO IssuerConstraints;
    ZeroMemory(&IssuerConstraints, sizeof(IssuerConstraints));

    DWORD cb;

    pIssuerCert = _GetIssuer(pServer);
    if (NULL == pIssuerCert)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "_GetIssuer");
    }

    if (NULL != pExtension)
    {
        cb = sizeof(Constraints);
        if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_BASIC_CONSTRAINTS2,
			pExtension->Value.pbData,
			pExtension->Value.cbData,
			0,
			&Constraints,
			&cb))
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:CryptDecodeObject");
        }

        // Cert templates use CAPATHLENGTH_INFINITE to indicate
        // fPathLenConstraint should be FALSE.

        if (CAPATHLENGTH_INFINITE == Constraints.dwPathLenConstraint)
        {

            // NOTE: This is ok as certcli already sets fPathLenConstraint to FALSE
            // for templates in this case.
	    Constraints.fPathLenConstraint = FALSE;

            // NOTE: This is ok as autoenrollment ignores dwPathLenConstraint
            // if fPathLenConstraint is FALSE;
	    Constraints.dwPathLenConstraint = 0;
        }
        if (pExtension->fCritical)
        {
	    ExtFlags = EXTENSION_CRITICAL_FLAG;
        }
    }
    else
    {
	Constraints.fCA = fCA;
	Constraints.fPathLenConstraint = FALSE;
	Constraints.dwPathLenConstraint = 0;
    }
    if (EDITF_BASICCONSTRAINTSCRITICAL & m_dwEditFlags)
    {
        ExtFlags = EXTENSION_CRITICAL_FLAG;
    }

    // Check basic constraints against the issuer's cert.

    pIssuerExtension = CertFindExtension(
				szOID_BASIC_CONSTRAINTS2,
				pIssuerCert->pCertInfo->cExtension,
				pIssuerCert->pCertInfo->rgExtension);
    if (NULL != pIssuerExtension)
    {
        cb = sizeof(IssuerConstraints);
        if (!CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        pIssuerExtension->Value.pbData,
			        pIssuerExtension->Value.cbData,
			        0,
			        &IssuerConstraints,
			        &cb))
        {
            hr = myHLastError();
            _JumpError(hr, error, "Policy:CryptDecodeObject");
        }
        if (!IssuerConstraints.fCA)
        {
            hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
            _JumpError(hr, error, "Policy:CA cert not a CA cert");
        }
    }

    if (Constraints.fCA)
    {
        if (IssuerConstraints.fPathLenConstraint)
        {
            if (0 == IssuerConstraints.dwPathLenConstraint)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:CA cert is a leaf CA cert");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint >
	            IssuerConstraints.dwPathLenConstraint - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint =
                IssuerConstraints.dwPathLenConstraint - 1;
            }
        }
        if (CAPATHLENGTH_INFINITE != m_CAPathLength)
        {
            if (0 == m_CAPathLength)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:Registry says not to issue CA certs");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint > m_CAPathLength - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint = m_CAPathLength - 1;
            }
        }
    }

    if (!fEnableExtension)
    {
        ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS2,
                    &Constraints,
		    0,
		    CERTLIB_USE_LOCALALLOC,
                    &pbConstraints,
                    &cb))
    {
        hr = myHLastError();
        _JumpError(hr, error, "Policy:myEncodeObject");
    }

    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbConstraints,
			cb))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_BASIC_CONSTRAINTS2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtensioo");

error:
    if (NULL != pbConstraints)
    {
        LocalFree(pbConstraints);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }

    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_SetValidityPeriod
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_SetValidityPeriod(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR strPeriodString = NULL;
    BSTR strPeriodCount = NULL;
    BSTR strNameNotBefore = NULL;
    BSTR strNameNotAfter = NULL;
    VARIANT varValue;
    LONG lDelta;
    ENUM_PERIOD enumValidityPeriod;
    BOOL fValidDigitString;

    VariantInit(&varValue);

    if (!(EDITF_ATTRIBUTEENDDATE & m_dwEditFlags))
    {
	hr = S_OK;
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODSTRING,
			&strPeriodString);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODSTRING,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODCOUNT,
			&strPeriodCount);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODCOUNT,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    // Swap Count and String BSTRs if backwards -- Windows 2000 had it wrong.

    lDelta = myWtoI(strPeriodCount, &fValidDigitString);
    if (!fValidDigitString)
    {
	BSTR str = strPeriodCount;

	strPeriodCount = strPeriodString;
	strPeriodString = str;

	lDelta = myWtoI(strPeriodCount, &fValidDigitString);
	if (!fValidDigitString)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Policy:myWtoI");
	}
    }

    hr = myTranslatePeriodUnits(strPeriodString, lDelta, &enumValidityPeriod, &lDelta);
    _JumpIfError(hr, error, "Policy:myTranslatePeriodUnits");

    strNameNotBefore = SysAllocString(wszPROPCERTIFICATENOTBEFOREDATE);
    if (NULL == strNameNotBefore)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strNameNotBefore,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    hr = myMakeExprDate(&varValue.date, lDelta, enumValidityPeriod);
    _JumpIfError(hr, error, "Policy:myMakeExprDate");

    strNameNotAfter = SysAllocString(wszPROPCERTIFICATENOTAFTERDATE);
    if (NULL == strNameNotAfter)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->SetCertificateProperty(
				strNameNotAfter,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != strPeriodString)
    {
	SysFreeString(strPeriodString);
    }
    if (NULL != strPeriodCount)
    {
	SysFreeString(strPeriodCount);
    }
    if (NULL != strNameNotBefore)
    {
        SysFreeString(strNameNotBefore);
    }
    if (NULL != strNameNotAfter)
    {
        SysFreeString(strNameNotAfter);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddSubjectAltNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddSubjectAltNameExtension(
    IN ICertServerPolicy *pServer,
    IN DWORD iAltName)
{
    HRESULT hr = S_OK;
    ICertEncodeAltName *pAltName = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strCertType = NULL;
    BSTR strName = NULL;
    VARIANT varValue;

    VariantInit(&varValue);
    if (NULL != m_astrSubjectAltNameProp[iAltName])
    {
	hr = CoCreateInstance(
			CLSID_CCertEncodeAltName,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeAltName,
			(VOID **) &pAltName);
	_JumpIfError(hr, error, "Policy:CoCreateInstance");

	hr = pServer->GetRequestProperty(
				    m_astrSubjectAltNameProp[iAltName],
				    PROPTYPE_STRING,
				    &varValue);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"Policy:GetRequestProperty(%ws):%hs %x\n",
		m_astrSubjectAltNameProp[iAltName],
		CERTSRV_E_PROPERTY_EMPTY == hr? " MISSING ATTRIBUTE" : "",
		hr));
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		hr = S_OK;
	    }
	    goto error;
	}
        if (VT_BSTR != varValue.vt)
	{
 	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}

        if (L'\0' == varValue.bstrVal[0])
	{
	    hr = S_OK;
	    goto error;
	}
        if (!myConvertWszToBstr(&strName, varValue.bstrVal, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertWszToBstr");
	}

	hr = pAltName->Reset(1);
	_JumpIfError(hr, error, "Policy:AltName:Reset");

	hr = pAltName->SetNameEntry(0, CERT_ALT_NAME_RFC822_NAME, strName);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");

	hr = pAltName->Encode(&strExtension);
	_JumpIfError(hr, error, "Policy:AltName:Encode");

        varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strExtension;
	hr = pServer->SetCertificateExtension(
				m_astrSubjectAltNameObjectId[iAltName],
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != pAltName)
    {
        pAltName->Release();
    }
    VariantClear(&varValue);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_PatchExchangeSubjectAltName
//
// If the request is for one of the Exchange templates, and if it contains an
// RFC822 entry and a Directory Name entry consisting solely of a single common
// name, strip out the common name entry.  The common name entry was used for
// display purposes by Outlook, but it interferes with name constraints
// enforcement.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_PatchExchangeSubjectAltName(
    IN ICertServerPolicy *pServer,
    OPTIONAL IN BSTRC strTemplateName)
{
    HRESULT hr;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varExtension;
    VARIANT varExtension2;
    CERT_ALT_NAME_INFO *pAltName = NULL;
    CERT_ALT_NAME_ENTRY *pRFC822Name;
    CERT_ALT_NAME_ENTRY *pDirectoryName;
    CERT_RDN const *prdn;
    CERT_ALT_NAME_INFO AltName;
    DWORD cbEncoded;
    BYTE *pbEncoded = NULL;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    BOOL fUpdate = FALSE;

    VariantInit(&varExtension);
    VariantInit(&varExtension2);

    if (NULL == strTemplateName ||
	(0 != lstrcmpi(strTemplateName, wszCERTTYPE_EXCHANGE_USER) &&
	 0 != lstrcmpi(strTemplateName, wszCERTTYPE_EXCHANGE_USER_SIGNATURE)))
    {
	goto skip;	// not an Exchange request.

    }

    strName = SysAllocString(TEXT(szOID_SUBJECT_ALT_NAME2));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    hr = pServer->GetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    &varExtension);
    _PrintIfError2(hr, "Policy:GetCertificateExtension", hr);
    if (S_OK != hr || VT_BSTR != varExtension.vt)
    {
	goto skip;	// skip if the extension doesn't exist.
    }

    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

    if (EXTENSION_DISABLE_FLAG & ExtFlags)
    {
	goto skip;	// skip if the extension is disabled.
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		(BYTE *) varExtension.bstrVal,
		SysStringByteLen(varExtension.bstrVal),
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pAltName,
		&cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }
    if (2 != pAltName->cAltEntry)
    {
	goto skip;	// skip if the extension isn't as expected
    }

    pRFC822Name = &pAltName->rgAltEntry[0];
    pDirectoryName = &pAltName->rgAltEntry[1];
    if (CERT_ALT_NAME_RFC822_NAME == pRFC822Name->dwAltNameChoice &&
	CERT_ALT_NAME_DIRECTORY_NAME == pDirectoryName->dwAltNameChoice)
    {
    }
    else
    if (CERT_ALT_NAME_DIRECTORY_NAME == pRFC822Name->dwAltNameChoice &&
	CERT_ALT_NAME_RFC822_NAME == pDirectoryName->dwAltNameChoice)
    {
	pDirectoryName = &pAltName->rgAltEntry[0];
	pRFC822Name = &pAltName->rgAltEntry[1];
    }
    else
    {
	goto skip;	// skip if the extension doesn't contain one of each
    }
    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pDirectoryName->DirectoryName.pbData,
		pDirectoryName->DirectoryName.cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }
    if (1 != pNameInfo->cRDN)
    {
	goto skip;	// skip if the entry doesn't contain one common name
    }
    prdn = &pNameInfo->rgRDN[0];
    if (1 != prdn->cRDNAttr ||
	0 != strcmp(prdn->rgRDNAttr[0].pszObjId, szOID_COMMON_NAME))
    {
	goto skip;	// skip if the entry doesn't contain one common name
    }

    // rewrite the extension with only the RFC822 entry.

    AltName.cAltEntry = 1;
    AltName.rgAltEntry = pRFC822Name;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    varExtension2.bstrVal = NULL;
    if (!myConvertWszToBstr(
			&varExtension2.bstrVal,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    varExtension2.vt = VT_BSTR;

    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    0,
			    &varExtension2);
    _JumpIfError(hr, error, "Policy:SetCertificateExtension");

skip:
    hr = S_OK;

error:
    VariantClear(&varExtension);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pAltName)
    {
	LocalFree(pAltName);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddTemplateNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddTemplateNameExtension(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    BSTRC strTemplateName;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varExtension;
    CERT_NAME_VALUE *pName = NULL;
    CERT_NAME_VALUE NameValue;
    DWORD cbEncoded;
    BYTE *pbEncoded = NULL;
    BOOL fUpdate = TRUE;

    VariantInit(&varExtension);

    strTemplateName = pRequest->GetTemplateName();
    if (NULL == strTemplateName)
    {
        hr = S_OK;
        goto error;
    }

    strName = SysAllocString(TEXT(szOID_ENROLL_CERTTYPE_EXTENSION));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    hr = pServer->GetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    &varExtension);
    _PrintIfError2(hr, "Policy:GetCertificateExtension", hr);
    if (S_OK == hr && VT_BSTR == varExtension.vt)
    {
	hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	if (0 == (EXTENSION_DISABLE_FLAG & ExtFlags))
	{
	    if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			(BYTE *) varExtension.bstrVal,
			SysStringByteLen(varExtension.bstrVal),
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pName,
			&cbEncoded))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Policy:myDecodeObject");
	    }

	    // case sensitive compare -- make sure it matches case of template

	    if (0 == lstrcmp(
			(WCHAR const *) pName->Value.pbData,
			strTemplateName))
	    {
		fUpdate = FALSE;
	    }
	}
    }
    if (fUpdate)
    {
	VariantClear(&varExtension);
	varExtension.bstrVal = NULL;

	NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
	NameValue.Value.pbData = (BYTE *) strTemplateName;
	NameValue.Value.cbData = 0;

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			&NameValue,
			0,
			CERTLIB_USE_LOCALALLOC,
			&pbEncoded,
			&cbEncoded))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myEncodeObject");
	}
	if (!myConvertWszToBstr(
			    &varExtension.bstrVal,
			    (WCHAR const *) pbEncoded,
			    cbEncoded))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertWszToBstr");
	}
	varExtension.vt = VT_BSTR;

	hr = pServer->SetCertificateExtension(
				strName,
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }
    hr = S_OK;

error:
    VariantClear(&varExtension);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}

// end_sdksample


HRESULT
CCertPolicyEnterprise::FindTemplate(
    OPTIONAL IN WCHAR const *pwszTemplateName,
    OPTIONAL IN WCHAR const *pwszTemplateObjId,
    OUT CTemplatePolicy **ppTemplate)
{
    HRESULT hr;
    DWORD i;

    hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
    *ppTemplate = NULL;
    for (i = 0; i < m_cTemplatePolicies; i++)
    {
        if (NULL == m_apTemplatePolicies[i])
        {
            continue;
        }
        if (m_apTemplatePolicies[i]->IsRequestedTemplate(
						pwszTemplateName,
						pwszTemplateObjId))
        {
	    *ppTemplate = m_apTemplatePolicies[i];
	    hr = S_OK;
	    break;
        }
    }
    _JumpIfErrorStr(hr, error, "FindTemplate", pwszTemplateName);

error:
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_ApplyTemplate(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest,
    OUT DWORD *pdwEnrollmentFlags)
{
    HRESULT hr;
    WCHAR const *pwszTemplateName;
    CTemplatePolicy *pTemplate;

    pwszTemplateName = pRequest->GetTemplateName();
    if (NULL == pwszTemplateName)
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "Policy:no CertType");
    }
    hr = FindTemplate(
		pwszTemplateName,
		pRequest->GetTemplateObjId(),
		&pTemplate);
    _JumpIfError(hr, error, "Policy:FindTemplate: Unsupported Cert Type");

    DBGPRINT((DBG_SS_CERTPOL, "Requested cert type: %ws\n", pwszTemplateName));

    hr = pTemplate->Apply(pServer, pRequest);
    _JumpIfError(hr, error, "Apply");

    hr = pTemplate->GetFlags(CERTTYPE_ENROLLMENT_FLAG, pdwEnrollmentFlags);
    _JumpIfError(hr, error, "GetFlags");

error:
    DBGPRINT((DBG_SS_CERTPOLI, "Policy:_ApplyTemplate: %x\n", hr));
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_AddTemplateToCA(
    IN HCAINFO hCAInfo,
    IN WCHAR const *pwszTemplateName,
    OUT BOOL *pfAdded)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    CTemplatePolicy *pTemplate;

    *pfAdded = FALSE;
    hr = FindTemplate(pwszTemplateName, NULL, &pTemplate);
    if (S_OK != hr)
    {
	hr = CAFindCertTypeByName(
			pwszTemplateName,
			m_pld,
			CT_FIND_LOCAL_SYSTEM |
			    CT_ENUM_MACHINE_TYPES |
			    CT_ENUM_USER_TYPES |
			    CT_FLAG_SCOPE_IS_LDAP_HANDLE |
			    CT_FLAG_NO_CACHE_LOOKUP,
			&hCertType);
	_JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pwszTemplateName);

	hr = CAAddCACertificateType(hCAInfo, hCertType);
	_JumpIfErrorStr(hr, error, "CAAddCACertificateType", pwszTemplateName);

	*pfAdded = TRUE;
    }
    CSASSERT(S_OK == hr);

error:
    DBGPRINT((
	DBG_SS_CERTPOL,
	"_AddTemplateToCA(%ws) --> %x\n",
	pwszTemplateName,
	hr));

    if (NULL != hCertType)
    {
        CACloseCertType(hCertType);
    }
    return(hr);
}


VOID
CCertPolicyEnterprise::_ReleaseTemplates()
{
    DWORD i;
    
    if (NULL != m_apTemplatePolicies)
    {
        for (i = 0; i < m_cTemplatePolicies; i++)
        {
            if (NULL != m_apTemplatePolicies[i])
            {
                delete m_apTemplatePolicies[i];
            }
        }
        LocalFree(m_apTemplatePolicies);
        m_apTemplatePolicies = NULL;
    }
    m_cTemplatePolicies = 0;
}


HRESULT 
CCertPolicyEnterprise::_LogLoadTemplateError(
    IN ICertServerPolicy *pServer,
    HRESULT hr, 
    LPCWSTR pcwszTemplate)
{
    LPCWSTR apwsz[2];
    LPCWSTR pwszError;

    _PrintErrorStr(hr, "LogLoadTemplateError", pcwszTemplate);
    
    pwszError = myGetErrorMessageText(hr, TRUE);
    apwsz[0] = pcwszTemplate;
    apwsz[1] = pwszError;

    HRESULT hr2 = LogPolicyEvent(
			g_hInstance,
			MSG_LOAD_TEMPLATE,
			pServer,
			wszPROPEVENTLOGWARNING,
			apwsz);
    _PrintIfError(hr2, "LogPolicyEvent");

    LOCAL_FREE(const_cast<LPWSTR>(pwszError));

    return hr2;
}


HRESULT
CCertPolicyEnterprise::_LoadTemplates(
    IN ICertServerPolicy *pServer,
    OPTIONAL OUT HCAINFO *phCAInfo)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    DWORD dwLogId = 0;
    WCHAR **ppwszTemplates = NULL;
    int iTempl, iTemplPol;
    HCAINFO hCAInfo = NULL;
    
    _ReleaseTemplates();

    hr = CAFindByName(
		m_strCASanitizedDSName,
		(WCHAR const *) m_pld,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FLAG_SCOPE_IS_LDAP_HANDLE,
		&hCAInfo);
    if (S_OK != hr)
    {
	dwLogId = MSG_NO_CA_OBJECT;
	_JumpError(hr, error, "Policy:CAFindByName");
    }

    hr = CAGetCAProperty(hCAInfo, CA_PROP_CERT_TYPES, &ppwszTemplates);
    if (S_OK != hr ||
        !ppwszTemplates ||
        !ppwszTemplates[0])
    {
        dwLogId = MSG_NO_CERT_TYPES;
        _JumpError(hr, error, "CAGetCAProperty");
    }

    // count # of templates in the CA's list
    for (m_cTemplatePolicies = 0; 
         ppwszTemplates[m_cTemplatePolicies];
         m_cTemplatePolicies++)
        NULL;

    m_apTemplatePolicies = (CTemplatePolicy **) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    sizeof(CTemplatePolicy *) * m_cTemplatePolicies);
    _JumpIfAllocFailed(m_apTemplatePolicies, error);

    for (iTempl = 0, iTemplPol = 0; ppwszTemplates[iTempl]; iTempl++)
    {
                
        hr = CAFindCertTypeByName(
			    ppwszTemplates[iTempl],
			    m_pld,
			    CT_FIND_LOCAL_SYSTEM |
				CT_ENUM_MACHINE_TYPES |
				CT_ENUM_USER_TYPES |
				CT_FLAG_SCOPE_IS_LDAP_HANDLE |
				(iTempl? 0 : CT_FLAG_NO_CACHE_LOOKUP),
			    &hCertType);
        if (S_OK != hr)
        {
            // failed to retrieve the template with this name, log an error and
	    // move to the next template name

            _LogLoadTemplateError(pServer, hr, ppwszTemplates[iTempl]);
            continue;
        }

        m_apTemplatePolicies[iTemplPol] = new CTemplatePolicy;
        _JumpIfAllocFailed(m_apTemplatePolicies[iTemplPol], error);

        hr = m_apTemplatePolicies[iTemplPol]->Initialize(hCertType, pServer, this);
        if (S_OK != hr)
        {
            _LogLoadTemplateError(pServer, hr, ppwszTemplates[iTempl]);
            
            delete m_apTemplatePolicies[iTemplPol];
            m_apTemplatePolicies[iTemplPol] = NULL;
            CACloseCertType(hCertType);

            continue;
        }

        iTemplPol++;
    }

    m_cTemplatePolicies = iTemplPol; // # of templates we retrieved successfully
    if (NULL != phCAInfo)
    {
        CAFreeCAProperty(hCAInfo, ppwszTemplates);
	ppwszTemplates = NULL;

	*phCAInfo = hCAInfo;
	hCAInfo = NULL;
    }

error:
    if (0 != dwLogId)
    {
        CSASSERT(m_strDescription);
        ::LogModuleStatus(g_hInstance, dwLogId, TRUE, m_strDescription, NULL);
    }
    if (NULL != ppwszTemplates)
    {
        CAFreeCAProperty(hCAInfo, ppwszTemplates);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    if (S_OK != hr)
    {
        LOCAL_FREE(m_apTemplatePolicies);
        m_apTemplatePolicies = NULL;
        m_cTemplatePolicies = 0;
    }
    return hr;
}


HRESULT
CCertPolicyEnterprise::_UpdateTemplates(
    IN ICertServerPolicy *pServer,
    IN BOOL fForceLoad)
{
    HRESULT hr;
    HKEY hkey = NULL;
    BOOL fUpdateTemplates;
    DWORD dwChangeSequence;
    HCAINFO hCAInfo = NULL;
    DWORD dwCATemplListSequenceNum;

    if (NULL == m_hCertTypeQuery)
    {
	hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        _JumpError(hr, error, "NULL m_hCertTypeQuery");
    }

    hr = CACertTypeQuery(m_hCertTypeQuery, &dwChangeSequence);
    _JumpIfError(hr, error, "CACertTypeQuery");

    hr = polGetCertificateLongProperty(
        pServer,
        wszPROPTEMPLATECHANGESEQUENCENUMBER,
        (LONG *) &dwCATemplListSequenceNum);
    _JumpIfErrorStr(hr, error, 
        "polGetCertificateLongProperty",
        wszPROPTEMPLATECHANGESEQUENCENUMBER);

    fUpdateTemplates = fForceLoad ||
			!m_fConfigLoaded ||
			dwChangeSequence != m_TemplateSequence ||
			dwCATemplListSequenceNum != m_dwCATemplListSequenceNum;
    DBGPRINT((
	DBG_SS_CERTPOL,
	"_UpdateTemplates(fForce=%u) Sequence=%u->%u, %u->%u: fUpdate=%u\n",
	fForceLoad,
	m_TemplateSequence,
	dwChangeSequence,
	m_dwCATemplListSequenceNum,
	dwCATemplListSequenceNum,
	fUpdateTemplates));

    while (fUpdateTemplates)
    {
	BOOL fTemplateAdded = FALSE;

	hr = _LoadTemplates(pServer, &hCAInfo);
	_JumpIfError(hr, error, "_LoadTemplates");

	m_TemplateSequence = dwChangeSequence;
	m_dwCATemplListSequenceNum = dwCATemplListSequenceNum;

	if (fForceLoad && (EDITF_SERVERUPGRADED & m_dwEditFlags))
	{
	    BOOL fUpgradeComplete = TRUE;
	    DWORD cb;

	    if (FIsAdvancedServer())
	    {
		CTemplatePolicy *pTemplate;

		hr = FindTemplate(wszCERTTYPE_DC, NULL, &pTemplate);
		if (S_OK == hr)
		{
		    BOOL fAdded;
		    
		    hr = _AddTemplateToCA(
				    hCAInfo,
				    wszCERTTYPE_DC_AUTH,
				    &fAdded);
		    if (S_OK == hr && fAdded)
		    {
			fTemplateAdded = TRUE;
		    }
		    if (S_OK != hr)
		    {
			fUpgradeComplete = FALSE;
		    }
		    hr = _AddTemplateToCA(
				    hCAInfo,
				    wszCERTTYPE_DS_EMAIL_REPLICATION,
				    &fAdded);
		    if (S_OK == hr && fAdded)
		    {
			fTemplateAdded = TRUE;
		    }
		    if (S_OK != hr)
		    {
			fUpgradeComplete = FALSE;
		    }
		    if (fTemplateAdded)
		    {
			hr = CAUpdateCA(hCAInfo);
			_JumpIfError(hr, error, "CAUpdateCA");
		    }
		}
	    }
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"_UpdateTemplates: %ws EDITF_SERVERUPGRADED\n",
		fUpgradeComplete? L"clearing" : L"keeping"));

	    if (fUpgradeComplete)
	    {
		m_dwEditFlags &= ~EDITF_SERVERUPGRADED;

		hr = RegOpenKeyEx(
			    HKEY_LOCAL_MACHINE,
			    m_strRegStorageLoc,
			    0,              // dwReserved
			    KEY_ALL_ACCESS,
			    &hkey);
		if (S_OK != hr)
		{
		    _PrintIfError(hr, "Policy:RegOpenKeyEx");
		}
		else
		{
		    cb = sizeof(m_dwEditFlags);
		    hr = RegSetValueEx(
				    hkey,
				    wszREGEDITFLAGS,
				    0,
				    REG_DWORD,
				    (BYTE *) &m_dwEditFlags,
				    cb);
		    _PrintIfError(hr, "Policy:RegSetValueEx");
		}
	    }
	}
	if (!fTemplateAdded)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::VerifyRequest
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

// begin_sdksample

STDMETHODIMP
CCertPolicyEnterprise::VerifyRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Context,
    /* [in] */ LONG bNewRequest,
    /* [in] */ LONG Flags,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr = E_FAIL;
    ICertServerPolicy *pServer = NULL;
    CRequestInstance Request;
    BOOL fCA = FALSE;
    BSTR strDisposition = NULL;
    BOOL fCritSecEntered = FALSE;
    DWORD dwEnrollmentFlags = 0;	// no_sdksample

    if (!m_fPolicyCriticalSection)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }

    __try
    {
	if (NULL == pDisposition)
	{
	    hr = E_POINTER;
	    _LeaveError(hr, "Policy:pDisposition");
	}
	*pDisposition = VR_INSTANT_BAD;

	hr = polGetServerCallbackInterface(&pServer, Context);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");


	// only need to check user access for original submitter:
	// resubmit can only be called by admins

	if (bNewRequest && (0 == (m_dwEditFlags & EDITF_IGNOREREQUESTERGROUP)))
	{
	    BOOL fRequesterAccess = FALSE;

	    // Is this user allowed to request certs?
	    hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPREQUESTERCAACCESS,
				    (LONG *) &fRequesterAccess);
	    _PrintIfErrorStr(
			hr,
			"Policy:polGetCertificateLongProperty",
			wszPROPREQUESTERCAACCESS);
	    if (hr != S_OK || !fRequesterAccess)
	    {
		hr = CERTSRV_E_ENROLL_DENIED;
		_JumpError(hr, deny, "Policy:fRequesterAccess");
	    }
	}

	// end_sdksample

	EnterCriticalSection(&m_PolicyCriticalSection);
	fCritSecEntered = TRUE;

	hr = S_OK;
	if (bNewRequest && IsEnterpriseCA(m_CAType))
	{
	    hr = _UpdateTemplates(pServer, FALSE);
	    _PrintIfError(hr, "Policy:_UpdateTemplates(will rebind)");
	}
	if (!m_fConfigLoaded || S_OK != hr)
	{
	    // Uninitialized or possible LDAP handle gone bad -- rebind
	    // _LoadDSConfig calls _UpdateTemplates

	    hr = _LoadDSConfig(pServer, TRUE);
	    _LeaveIfError(hr, "Policy:_LoadDSConfig");
	}
	// begin_sdksample

	hr = Request.Initialize(
			    this,
			    IsEnterpriseCA(m_CAType),	// no_sdksample
			    bNewRequest,		// no_sdksample
			    pServer);
	_LeaveIfError(hr, "Policy:VerifyRequest:Request.Initialize");

	LeaveCriticalSection(&m_PolicyCriticalSection);	// no_sdksample
	fCritSecEntered = FALSE;			// no_sdksample

	hr = _EnumerateExtensions(pServer, bNewRequest, TRUE);
	_LeaveIfError(hr, "_EnumerateExtensions");

	if (IsStandaloneCA(m_CAType))	// no_sdksample
	{
	    hr = _AddDefaultBasicConstraintsExtension(
						pServer,
						Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultBasicConstraintsExtension");

	    hr = _AddDefaultKeyUsageExtension(pServer, Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultKeyUsageExtension");

	    hr = _AddEnhancedKeyUsageExtension(pServer);
	    _LeaveIfError(hr, "_AddEnhancedKeyUsageExtension");

	    hr = _AddSubjectAltNameExtension(pServer, 0);
	    _LeaveIfError(hr, "_AddSubjectAltNameExtension");

	    hr = _AddSubjectAltNameExtension(pServer, 1);
	    _LeaveIfError(hr, "_AddSubjectAltNameExtension");
	}

	hr = _SetValidityPeriod(pServer);
	_LeaveIfError(hr, "_SetValidityPeriod");

	hr = _PatchExchangeSubjectAltName(pServer, Request.GetTemplateName());
	_LeaveIfError(hr, "_PatchExchangeSubjectAltName");

	hr = EnumerateAttributes(pServer);
	_LeaveIfError(hr, "Policy:EnumerateAttributes");

	hr = _AddRevocationExtension(pServer);
	_LeaveIfError(hr, "_AddRevocationExtension");

	hr = _AddOldCertTypeExtension(pServer, Request.IsCARequest());
	_LeaveIfError(hr, "_AddOldCertTypeExtension");

	hr = _AddAuthorityKeyId(pServer);
	_LeaveIfError(hr, "_AddAuthorityKeyId");

	// end_sdksample

	if (IsEnterpriseCA(m_CAType))
	{
	    EnterCriticalSection(&m_PolicyCriticalSection);
	    fCritSecEntered = TRUE;

	    hr = _ApplyTemplate(pServer, &Request, &dwEnrollmentFlags);
	    _JumpIfError(hr, deny, "_ApplyTemplate"); // pass hr as Disposition

	    LeaveCriticalSection(&m_PolicyCriticalSection);
	    fCritSecEntered = FALSE;
	}

	// begin_sdksample

	hr = _AddTemplateNameExtension(pServer, &Request);
	_LeaveIfError(hr, "_AddTemplateNameExtension");

	// pass hr as Disposition

	hr = CheckRequestProperties(pServer);
	_JumpIfError(hr, deny, "Policy:CheckRequestProperties");

	if (EDITF_DISABLEEXTENSIONLIST & m_dwEditFlags)
	{
	    hr = _EnumerateExtensions(pServer, bNewRequest, FALSE);
	    _LeaveIfError(hr, "_EnumerateExtensions");
	}

	if (bNewRequest &&
	    (
	     (CT_FLAG_PEND_ALL_REQUESTS & dwEnrollmentFlags) ||	// no_sdksample
	     (REQDISP_PENDINGFIRST & m_dwDispositionFlags)))
	{
	    *pDisposition = VR_PENDING;
	}
	else switch (REQDISP_MASK & m_dwDispositionFlags)
	{
	    default:
	    case REQDISP_PENDING:
		*pDisposition = VR_PENDING;
		break;

	    case REQDISP_ISSUE:
		*pDisposition = VR_INSTANT_OK;
		break;

	    case REQDISP_DENY:
		*pDisposition = VR_INSTANT_BAD;
		break;

	    case REQDISP_USEREQUESTATTRIBUTE:
		*pDisposition = VR_INSTANT_OK;
		hr = polGetRequestAttribute(
				    pServer,
				    wszPROPDISPOSITION,
				    &strDisposition);
		if (S_OK == hr)
		{
		    if (0 == lstrcmpi(wszPROPDISPOSITIONDENY, strDisposition))
		    {
			*pDisposition = VR_INSTANT_BAD;
		    }
		    if (0 == lstrcmpi(wszPROPDISPOSITIONPENDING, strDisposition))
		    {
			*pDisposition = VR_PENDING;
		    }
		}
		hr = S_OK;
		break;
	}
deny:
	if (FAILED(hr))
	{
	    *pDisposition = hr;	// pass failed HRESULT back as Disposition
	}
	else if (hr != S_OK)
	{
	    *pDisposition = VR_INSTANT_BAD;
	}
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != strDisposition)
    {
	SysFreeString(strDisposition);
    }
    if (NULL != pServer)
    {
        pServer->Release();
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&m_PolicyCriticalSection);
    }
    //_PrintIfError(hr, "Policy:VerifyRequest(hr)");
    //_PrintError(*pDisposition, "Policy:VerifyRequest(*pDisposition)");
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::GetDescription
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::GetDescription(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

    if(!m_strDescription)
    {
#ifdef IDS_MODULE_NAME						// no_sdksample
	LoadString(g_hInstance, IDS_MODULE_NAME, sz, ARRAYSIZE(sz));// no_sdksample
#else								// no_sdksample
	CSASSERT(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
	wcscpy(sz, wsz_SAMPLE_DESCRIPTION);
#endif								// no_sdksample

	m_strDescription = SysAllocString(sz);
	if (NULL == m_strDescription)
	{
	    hr = E_OUTOFMEMORY;
	    return hr;
	}
    }

    if (NULL != *pstrDescription)
    {
        SysFreeString(*pstrDescription);
    }

    *pstrDescription = SysAllocString(m_strDescription);
    if (NULL == *pstrDescription)
    {
        hr = E_OUTOFMEMORY;
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::ShutDown
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::ShutDown(VOID)
{
    // called once, as Server unloading policy dll
    _Cleanup();
    reqCleanup();	// no_sdksample
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
		    CLSID_CCertManagePolicyModule,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
		    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_GetIssuer
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

PCCERT_CONTEXT
CCertPolicyEnterprise::_GetIssuer(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    BSTR strName = NULL;

    VariantInit(&varValue);
    if (NULL != m_pCert)
    {
        hr = S_OK;
	goto error;
    }
    strName = SysAllocString(wszPROPRAWCACERTIFICATE);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(strName, PROPTYPE_BINARY, &varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    m_pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    (BYTE *) varValue.bstrVal,
				    SysStringByteLen(varValue.bstrVal));
    if (NULL == m_pCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:CertCreateCertificateContext");
    }

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(m_pCert);
}


STDMETHODIMP
CCertPolicyEnterprise::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
        &IID_ICertPolicy,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (IsEqualGUID(*arr[i], riid))
        {
            return(S_OK);
        }
    }
    return(S_FALSE);
}

// end_sdksample
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        request.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <winldap.h>
#include <security.h>

#include "cspelog.h"
#include "pollog.h"

#include "csprop.h"
#include "csldap.h"
#include "csdisp.h"
#include "policy.h"
#include "cainfop.h"


LDAP *g_pldGC = NULL;

HRESULT
myLdapGCBind(
    IN OUT LDAP **ppldGC)
{
    HRESULT hr;
    ULONG ldaperr;
    DWORD GetDSNameFlags;
    WCHAR *pwszDomainControllerName;
    BOOL fRediscover = FALSE;
    LDAP *pldGC = *ppldGC;

    // We want to talk to a GC, so grab the GC name.  Get the GC location.

    GetDSNameFlags = DS_RETURN_DNS_NAME | DS_GC_SERVER_REQUIRED;
    if (fRediscover)
    {
	GetDSNameFlags |= DS_FORCE_REDISCOVERY;
    }

    while (TRUE)
    {
        if (NULL != *ppldGC)
	{
            break;
	}

        // Clean up from previous loop execution

        if (NULL != pldGC)
        {
            ldap_unbind(pldGC);
            pldGC = NULL;
        }

        // Grab an LDAP handle for use during this instantiation

        pldGC = ldap_init(NULL, LDAP_GC_PORT);
        if (NULL == pldGC)
        {
	    hr = myHLdapLastError(NULL, NULL);
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:ldap_init", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:ldap_init");
        }

        ldaperr = ldap_set_option(
			    pldGC,
			    LDAP_OPT_GETDSNAME_FLAGS,
			    (VOID *) &GetDSNameFlags);
        if (LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pldGC, ldaperr, NULL);
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:ldap_set_option", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:ldap_set_option");
        }

        ldaperr = ldap_set_option(pldGC, LDAP_OPT_SIGN, LDAP_OPT_ON);
        if (LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pldGC, ldaperr, NULL);
            if (!fRediscover)
            {
                _PrintError2(hr, "Policy:ldap_set_option", hr);
                fRediscover = TRUE;
                continue;
            }
            _JumpError(hr, error, "Policy:ldap_set_option");
        }

        ldaperr = ldap_bind_s(pldGC, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        if (LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pldGC, ldaperr, NULL);
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:ldap_bind_s", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:ldap_bind_s");
        }

	hr = myLdapGetDSHostName(pldGC, &pwszDomainControllerName);
        if (S_OK != hr)
        {
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:myLdapGetDSHostName", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:myLdapGetDSHostName");
        }
	DBGPRINT((
	    DBG_SS_CERTPOLI,
	    "DC name = %ws\n",
	    pwszDomainControllerName));
        break;
    }
    hr = S_OK;

error:
    *ppldGC = pldGC;
    return(hr);
}


VOID
myLdapGCUnBind(
    IN OUT LDAP **ppldGC)
{
    if (NULL != *ppldGC)
    {
	 ldap_unbind(*ppldGC);
	 *ppldGC = NULL;
    }
}


// begin_sdksample

VOID
reqCleanup()
{
    myLdapGCUnBind(&g_pldGC);	// no_sdksample
}


CRequestInstance::~CRequestInstance()
{
    _Cleanup();
}


VOID
CRequestInstance::_Cleanup()
{
    if (NULL != m_strTemplateName)
    {
        SysFreeString(m_strTemplateName);
        m_strTemplateName = NULL;
    }
    if (NULL != m_strTemplateObjId)
    {
        SysFreeString(m_strTemplateObjId);
        m_strTemplateObjId = NULL;
    }
    // end_sdksample
    //+--------------------------------------
    if (NULL != m_hToken)
    {
        CloseHandle(m_hToken);
        m_hToken = NULL;
    }
    if (NULL != m_strUserDN)
    {
        SysFreeString(m_strUserDN);
        m_strUserDN = NULL;
    }
    if (NULL != m_pwszUPN)
    {
        LocalFree(m_pwszUPN);
        m_pwszUPN = NULL;
    }
    if (NULL != m_SearchResult)
    {
        ldap_msgfree(m_SearchResult);
        m_SearchResult = NULL;
    }
    //+--------------------------------------
    // begin_sdksample
}


static WCHAR const *s_apwszCATypes[] =
{
    wszCERTTYPE_SUBORDINATE_CA,
    wszCERTTYPE_CROSS_CA,
};

//+--------------------------------------------------------------------------
// CRequestInstance::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::Initialize(
    IN CCertPolicyEnterprise *pPolicy,
    IN BOOL fEnterpriseCA,		// no_sdksample
    IN BOOL bNewRequest,		// no_sdksample
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hrTemplate = S_OK;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    CERT_NAME_VALUE *pName = NULL;
    BSTR strTemplateObjId = NULL;	// from V2 template extension
    BSTR strTemplateName = NULL;	// from V1 template extension
    BSTR strTemplateRA = NULL;		// from request attributes
    WCHAR const *pwszTemplateName;
    WCHAR const *pwszTemplateObjId;
    VARIANT varValue;
    DWORD cbType;
    DWORD i;
    BOOL fConflict;
    BOOL f;
    BOOL fTemplateMissing;
    BOOL fRAObjId = FALSE;

    VariantInit(&varValue);

    m_pPolicy = pPolicy;
    m_fCA = FALSE;
    m_fNewRequest = bNewRequest;

    // end_sdksample
    //+--------------------------------------

    m_fUser = TRUE;
    m_fEnterpriseCA = fEnterpriseCA;

    if (m_fEnterpriseCA && bNewRequest)
    {
	hr = _InitToken(pServer);
	_JumpIfError(hr, error, "Policy:_InitToken");
    }

    hr = _InitClientOSVersionInfo(pServer);
    _JumpIfError(hr, error, "Policy:_InitClientOSVersionInfo");

    //+--------------------------------------
    // begin_sdksample

    // Retrieve the template ObjId from the V2 cert template info extension

    m_dwTemplateMajorVersion = 0;
    m_dwTemplateMinorVersion = 0;
    hr = pServer->GetCertificateExtension(
                                    TEXT(szOID_CERTIFICATE_TEMPLATE),
                                    PROPTYPE_BINARY,
                                    &varValue);
    _PrintIfErrorStr(
		hr,
		"Policy:GetCertificateExtension",
		TEXT(szOID_CERTIFICATE_TEMPLATE));
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERTIFICATE_TEMPLATE,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pTemplate,
		    &cbType))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "Policy:myDecodeObject");
        }
	if (!myConvertSzToBstr(&strTemplateObjId, pTemplate->pszObjId, -1))
	{
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertSzToBstr");
        }
	m_dwTemplateMajorVersion = pTemplate->dwMajorVersion;
	m_dwTemplateMinorVersion = pTemplate->dwMinorVersion;
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    pTemplate->fMinorVersion?
		"Extension Template Info: %ws V%u.%u\n" :
		"Extension Template Info: %ws V%u%\n",
	    strTemplateObjId,
	    m_dwTemplateMajorVersion,
	    m_dwTemplateMinorVersion));
    }
    VariantClear(&varValue);

    // Retrieve template Name from the V1 cert template name extension

    hr = pServer->GetCertificateExtension(
                                    TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
                                    PROPTYPE_BINARY,
                                    &varValue);
    _PrintIfErrorStr(
		hr,
		"Policy:GetCertificateExtension",
		TEXT(szOID_ENROLL_CERTTYPE_EXTENSION));
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pName,
		    &cbType))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "Policy:myDecodeObject");
        }
        strTemplateName = SysAllocStringByteLen(
					(char *) pName->Value.pbData,
					pName->Value.cbData);
        if (NULL == strTemplateName)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocStringByteLen");
        }
	DBGPRINT((DBG_SS_CERTPOL, "Extension Template: %ws\n", strTemplateName));
    }

    fConflict = FALSE;
    fTemplateMissing = FALSE;

    // Retrieve the template from the request attributes

    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strTemplateRA);
    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "Policy:polGetRequestAttribute", wszPROPCERTTEMPLATE);
	hr = S_OK;

	// end_sdksample
	if (m_fEnterpriseCA &&
	    NULL == strTemplateObjId &&
	    NULL == strTemplateName)
	{
	    hrTemplate = CERTSRV_E_NO_CERT_TYPE;
	    _PrintError(hrTemplate, "Policy:Request contains no template name");
	}
	// begin_sdksample

    }
    else
    {
	DBGPRINT((DBG_SS_CERTPOL, "Attribute Template: %ws\n", strTemplateRA));
	if (NULL != strTemplateObjId &&
	    !_TemplateNamesMatch(strTemplateObjId, strTemplateRA, &f))
	{
	    fConflict = TRUE;
	    if (f)
	    {
		fTemplateMissing = TRUE;
	    }
	}
	if (NULL != strTemplateName &&
	    !_TemplateNamesMatch(strTemplateName, strTemplateRA, &f))
	{
	    fConflict = TRUE;
	    if (f)
	    {
		fTemplateMissing = TRUE;
	    }
	}
	hr = myVerifyObjId(strTemplateRA);
	fRAObjId = S_OK == hr;
    }

    if (NULL != strTemplateObjId &&
	NULL != strTemplateName &&
	!_TemplateNamesMatch(strTemplateObjId, strTemplateName, &f))
    {
	fConflict = TRUE;
	if (f)
	{
	    fTemplateMissing = TRUE;
	}
    }

    if (fConflict)
    {
	hrTemplate = CERTSRV_E_TEMPLATE_CONFLICT;
	if (NULL != strTemplateObjId)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Extension Template ObjId",
			strTemplateObjId);
	}
	if (NULL != strTemplateName)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Extension Template Name",
			strTemplateName);
	}
	if (NULL != strTemplateRA)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Attribute Template",
			strTemplateRA);
	}
    }

    pwszTemplateName = strTemplateName;
    pwszTemplateObjId = strTemplateObjId;
    if (fRAObjId)
    {
	if (NULL == pwszTemplateObjId)
	{
	    pwszTemplateObjId = strTemplateRA;
	}
    }
    else
    {
	if (NULL == pwszTemplateName)
	{
	    pwszTemplateName = strTemplateRA;
	}
    }

    // end_sdksample

    if (m_fEnterpriseCA)
    {
	CTemplatePolicy *ptp;
	DWORD dwFlags;

	hr = m_pPolicy->FindTemplate(
			    pwszTemplateName,
			    pwszTemplateObjId,
			    &ptp);
	if (S_OK != hr)
	{
	    _PrintErrorStr(
		hr,
		"FindTemplate",
		NULL != pwszTemplateName? pwszTemplateName : pwszTemplateObjId);
	    if (S_OK == hrTemplate || fTemplateMissing)
	    {
		hrTemplate = hr;
	    }
	}
	else
	{
	    hr = ptp->GetFlags(CERTTYPE_GENERAL_FLAG, &dwFlags);
	    _JumpIfError(hr, error, "Policy:GetFlags");

	    if (CT_FLAG_IS_CA & dwFlags)
	    {
		m_fCA = TRUE;
	    }

	    hr = ptp->GetFlags(CERTTYPE_ENROLLMENT_FLAG, &dwFlags);
	    _JumpIfError(hr, error, "Policy:GetFlags");

	    hr = _SetFlagsProperty(
			    pServer,
			    wszPROPCERTIFICATEENROLLMENTFLAGS,
			    dwFlags);
	    _JumpIfError(hr, error, "Policy:_SetFlagsProperty");

	    hr = ptp->GetFlags(CERTTYPE_GENERAL_FLAG, &dwFlags);
	    _JumpIfError(hr, error, "Policy:GetFlags");

	    hr = _SetFlagsProperty(
			    pServer,
			    wszPROPCERTIFICATEGENERALFLAGS,
			    dwFlags);
	    _JumpIfError(hr, error, "Policy:_SetFlagsProperty");

	    if (CT_FLAG_MACHINE_TYPE & dwFlags)
	    {
		m_fUser = FALSE;
	    }
	    pwszTemplateName = ptp->GetTemplateName();
	    pwszTemplateObjId = ptp->GetTemplateObjId();
	}
    }
    else

    // begin_sdksample

    {
	if (NULL != pwszTemplateName)
	{
	    for (i = 0; i < ARRAYSIZE(s_apwszCATypes); i++)
	    {
		if (0 == lstrcmpi(s_apwszCATypes[i], pwszTemplateName))
		{
		    m_fCA = TRUE;
		    break;
		}
	    }
	}
    }
    hr = SetTemplateName(pServer, pwszTemplateName, pwszTemplateObjId);
    _JumpIfError(hr, error, "Policy:SetTemplateName");

error:
    if (S_OK != hrTemplate)
    {
	hr = hrTemplate;	// override secondary errors

	// end_sdksample
	WCHAR const *apwsz[4];
	DWORD cpwsz = 0;
	DWORD LogMsg;

	switch (hrTemplate)
	{
	    default:
	    case CERTSRV_E_NO_CERT_TYPE:
		LogMsg = MSG_MISSING_CERT_TYPE;
		apwsz[cpwsz++] = wszPROPCERTTEMPLATE;
		break;

	    case CERTSRV_E_TEMPLATE_CONFLICT:
		LogMsg = MSG_CONFLICTING_CERT_TYPE;
		break;

	    case CERTSRV_E_UNSUPPORTED_CERT_TYPE:
		LogMsg = MSG_UNSUPPORTED_CERT_TYPE;
		break;
	}
	if (0 == cpwsz)
	{
	    if (NULL != strTemplateName)
	    {
		apwsz[cpwsz++] = strTemplateName;
	    }
	    if (NULL != strTemplateObjId)
	    {
		apwsz[cpwsz++] = strTemplateObjId;
	    }
	    if (NULL != strTemplateRA)
	    {
		apwsz[cpwsz++] = strTemplateRA;
	    }
	}
	apwsz[cpwsz] = NULL;

	LogModuleStatus(
		    g_hInstance,
		    LogMsg,
		    TRUE,
		    m_pPolicy->GetPolicyDescription(),
		    apwsz);
	// begin_sdksample
    }
    VariantClear(&varValue);
    if (NULL != pName)
    {
        LocalFree(pName);
    }
    if (NULL != pTemplate)
    {
        LocalFree(pTemplate);
    }
    if (NULL != strTemplateObjId)
    {
        SysFreeString(strTemplateObjId);
    }
    if (NULL != strTemplateName)
    {
        SysFreeString(strTemplateName);
    }
    if (NULL != strTemplateRA)
    {
        SysFreeString(strTemplateRA);
    }
    return(hr);
}


BOOL
CRequestInstance::_TemplateNamesMatch(
    IN WCHAR const *pwszTemplateName1,
    IN WCHAR const *pwszTemplateName2,
    OUT BOOL *pfTemplateMissing)
{
    HRESULT hr1;
    HRESULT hr2;
    BOOL fMatch = TRUE;

    *pfTemplateMissing = FALSE;

    if (0 == lstrcmpi(pwszTemplateName1, pwszTemplateName2))
    {
	goto done;	// identical names
    }

    // end_sdksample
    if (m_fEnterpriseCA)
    {
	CTemplatePolicy *pTemplate1;
	CTemplatePolicy *pTemplate2;

	hr1 = m_pPolicy->FindTemplate(pwszTemplateName1, NULL, &pTemplate1);
	hr2 = m_pPolicy->FindTemplate(pwszTemplateName2, NULL, &pTemplate2);
	if (S_OK == hr1 && S_OK == hr2)
	{
	    if (pTemplate1 == pTemplate2)
	    {
		goto done;
	    }
	}
	else
	{
	    *pfTemplateMissing = TRUE;
	}
    }
    else
    // begin_sdksample
    {
	hr1 = myVerifyObjId(pwszTemplateName1);
	hr2 = myVerifyObjId(pwszTemplateName2);
	if ((S_OK == hr1) ^ (S_OK == hr2))
	{
	    goto done;
	}
    }
    fMatch = FALSE;

done:
    return(fMatch);
}


//+--------------------------------------------------------------------------
// CRequestInstance::SetTemplateName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::SetTemplateName(
    IN ICertServerPolicy *pServer,
    IN OPTIONAL WCHAR const *pwszTemplateName,
    IN OPTIONAL WCHAR const *pwszTemplateObjId)
{
    HRESULT hr;
    BSTR strProp = NULL;
    BSTR strTemplateName = NULL;

    if (NULL != pwszTemplateName)
    {
	m_strTemplateName = SysAllocString(pwszTemplateName);
	if (NULL == m_strTemplateName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateName;
    }

    if (NULL != pwszTemplateObjId)
    {
	m_strTemplateObjId = SysAllocString(pwszTemplateObjId);
	if (NULL == m_strTemplateObjId)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateObjId;
    }

    if (NULL != strTemplateName)
    {
	VARIANT var;

	strProp = SysAllocString(wszPROPCERTIFICATETEMPLATE);
	if (NULL == strProp)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	var.vt = VT_BSTR;
	var.bstrVal = strTemplateName;

	hr = pServer->SetCertificateProperty(strProp, PROPTYPE_STRING, &var);
	_JumpIfError(hr, error, "Policy:SetCertificateProperty");
    }
    hr = S_OK;

error:
    if (NULL != strProp)
    {
	SysFreeString(strProp);
    }
    return(hr);
}

// end_sdksample


HRESULT
CRequestInstance::_SetFlagsProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags)
{
    HRESULT hr;
    BSTR strPropName = NULL;
    VARIANT var;
    
    strPropName = SysAllocString(pwszPropName);
    if (NULL == strPropName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    var.vt = VT_I4;
    var.lVal = dwFlags;

    hr = pServer->SetCertificateProperty(strPropName, PROPTYPE_LONG, &var);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    if (NULL != strPropName)
    {
        SysFreeString(strPropName);
    }
    return(hr);
}


VOID
CRequestInstance::GetTemplateVersion(
    OUT DWORD *pdwTemplateMajorVersion,
    OUT DWORD *pdwTemplateMinorVersion)
{
    *pdwTemplateMajorVersion = m_dwTemplateMajorVersion;
    *pdwTemplateMinorVersion = m_dwTemplateMinorVersion;
}


//+--------------------------------------------------------------------------
// CRequestInstance::_InitToken
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::_InitToken(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;

    VariantInit(&varValue);

    hr = pServer->GetCertificateProperty(
				wszPROPREQUESTERTOKEN,
				PROPTYPE_BINARY,
				&varValue);
    if (S_OK == hr)
    {
        HANDLE hToken;

        // Got a token value

        if (sizeof(hToken) != SysStringByteLen(varValue.bstrVal))
        {
            hr = E_HANDLE;
            ::LogModuleStatus(
			g_hInstance,
			MSG_NO_REQUESTER_TOKEN,
			TRUE,
			m_pPolicy->GetPolicyDescription(),
			NULL);
	    _JumpError(hr, error, "Policy:Token Length");
        }

        hToken = *(HANDLE *) varValue.bstrVal;

        if (!DuplicateToken(hToken, SecurityIdentification, &m_hToken))
        {
            hr = myHLastError();
            ::LogModuleStatus(
			g_hInstance,
			MSG_NO_REQUESTER_TOKEN,
			TRUE,
			m_pPolicy->GetPolicyDescription(),
			NULL);
	    _JumpError(hr, error, "Policy:DuplicateToken");
        }
    }
    hr = S_OK;

error:
    VariantClear(&varValue);
    return(hr);
}


//+--------------------------------------------------------------------------
// CRequestInstance::_InitClientOSVersionInfo
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::_InitClientOSVersionInfo(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    DWORD dwFormat = 0;
    LONG l;
    BSTR strVersionInfo = NULL;
    BSTR strCSPProvider = NULL;

    VariantInit(&varValue);

    // In the following code, we also attempt to determine if the
    // request came from an xenroll.dll, so we know whether to put
    // the UPN in the subject name.  We put the UPN in the subject name
    // for old xenroll requests, as we know that autoenrollment on those
    // machines will need it to prevent enrollment loops.

    // Get the optional OS version information.  Ignore failure.

    hr = polGetRequestAttribute(pServer, wszPROPREQUESTOSVERSION, &strVersionInfo);
    if (S_OK == hr && NULL != strVersionInfo)
    {
        DWORD dwMajor, dwMinor, dwBuild, dwPlatform;

        if (4 == swscanf(
		    strVersionInfo,
		    L"%d.%d.%d.%d",
		    &dwMajor,
		    &dwMinor,
		    &dwBuild,
		    &dwPlatform))
        {
            m_RequestOsVersion.dwMajorVersion = dwMajor;
            m_RequestOsVersion.dwMinorVersion = dwMinor;
            m_RequestOsVersion.dwBuildNumber = dwBuild;
            m_RequestOsVersion.dwPlatformId = dwPlatform;
        }

        // We know this is an xenroll request,
        // as it has a OSVERSIONINFO property

        m_fIsXenrollRequest = TRUE;
	m_fClientVersionSpecified = TRUE;
    }
    hr = polGetRequestLongProperty(pServer, wszPROPREQUESTTYPE, &l);
    if (S_OK == hr)
    {
	dwFormat = CR_IN_FORMATMASK & l;
    }

    if (dwFormat == CR_IN_KEYGEN)
    {
        // KEYGEN requests only come from netscape, not xenroll,
        // so we know it's not an xenroll request.

        m_fIsXenrollRequest = FALSE;
    }
    else if (!m_fIsXenrollRequest)
    {
        hr = polGetRequestAttribute(
			    pServer,
			    wszPROPREQUESTCSPPROVIDER,
			    &strCSPProvider);
        if (S_OK == hr && NULL != strCSPProvider)
        {
            // xenroll includes a CSPPROVIDER attribute

            m_fIsXenrollRequest = TRUE;
        }
    }
    hr = S_OK;

//error:
    if (NULL != strVersionInfo)
    {
        SysFreeString(strVersionInfo);
    }
    if (NULL != strCSPProvider)
    {
        SysFreeString(strCSPProvider);
    }
    VariantClear(&varValue);
    return(hr);
}


//+--------------------------------------------------------------------------
// CRequestInstance::_LoadPrincipalObject
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::_LoadPrincipalObject(
    IN ICertServerPolicy *pServer,
    IN CTemplatePolicy *pTemplate)
{
    HRESULT hr;
    BSTR strProp = NULL;
    LPWSTR *awszUPN = NULL;
    BSTR strSamName = NULL;
    WCHAR *pwszUserName;
    DWORD dwFlags;
    VARIANT var;

    VariantInit(&var);

    // Get the name of the user or machine

    hr = polGetRequestStringProperty(
			pServer,
			wszPROPREQUESTERNAME,
			&strSamName);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		wszPROPREQUESTERNAME);

    if (L'\0' == *strSamName)
    {
	// can't have a zero length name
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "Policy:zero length name");
    }

    // See if there's a domain, as well

    pwszUserName = wcschr(strSamName, L'\\');
    if (NULL == pwszUserName)
    {
	WCHAR wszDN[MAX_PATH];
	DWORD cwc = ARRAYSIZE(wszDN);

        // No domain portion, so assume part of the current domain.

        if (GetUserNameEx(NameSamCompatible, wszDN, &cwc))
        {
            // Fix NULL termination bug

            if (0 < cwc)
            {
                wszDN[cwc - 1] = L'\0';
            }

            pwszUserName = wcschr(wszDN, L'\\');
            if (NULL != pwszUserName)
            {
                pwszUserName++;

                wcsncpy(pwszUserName, strSamName, ARRAYSIZE(wszDN) - (cwc - 1));
                SysFreeString(strSamName);
                strSamName = SysAllocString(wszDN);
                if (NULL == strSamName)
                {
                    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "Policy:SysAllocString");
                }
            }
        }
    }

    pwszUserName = wcschr(strSamName, L'\\');
    if (NULL == pwszUserName)
    {
        pwszUserName = strSamName;
    }
    else
    {
        pwszUserName++;
    }

    DBGPRINT((DBG_SS_CERTPOL, "pwszUserName = %ws\n", pwszUserName));
    DBGPRINT((DBG_SS_CERTPOL, "strSamName = %ws\n", strSamName));

    // If the user name ends in $, it's a hint that this is a machine account.

    if (pwszUserName[wcslen(pwszUserName) - 1] == L'$')
    {
        if (m_fUser)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"USER TEMPLATE w/ '$': %ws\n",
		pwszUserName));
	}
    }
    else
    {
        if (!m_fUser)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"MACHINE TEMPLATE w/o '$': %ws\n",
		pwszUserName));
	}
    }

    hr = polGetCertificateStringProperty(pServer, wszPROPUSERDN, &m_strUserDN);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetCertificateStringProperty",
		wszPROPUSERDN);

    hr = _GetDSObject();
    _JumpIfError(hr, error, "_GetDSObject");

    hr = pTemplate->GetFlags(CERTTYPE_GENERAL_FLAG, &dwFlags);
    _JumpIfError(hr, error, "Policy:GetFlags");

    if (!m_fUser ^ (0 != (CT_FLAG_MACHINE_TYPE & dwFlags)))
    {
	// if m_fUser state no longer agrees with the template machine flag,
	// toggle the flag and store the corrected value in the database.
	
	dwFlags ^= CT_FLAG_MACHINE_TYPE;
	hr = _SetFlagsProperty(
			pServer,
			wszPROPCERTIFICATEGENERALFLAGS,
			dwFlags);
	_JumpIfError(hr, error, "Policy:_SetFlagsProperty");
    }

    // Build the UPN value.
    // If a machine, the UPN must be the DNS name.

    hr = _GetValues(m_fUser? DS_ATTR_UPN : DS_ATTR_DNS_NAME, &awszUPN);
    if (S_OK == hr && NULL != awszUPN && NULL != awszUPN[0])
    {
	hr = myDupString(awszUPN[0], &m_pwszUPN);
	_JumpIfError(hr, error, "myDupString");
    }
    else
    {
	if (m_fUser)
	{
            WCHAR **awszExplodedDN;
	    WCHAR **ppwszCurrent;

            // Build a UPN from the username -- without the SAM domain.
            // Get a buffer that will be big enough.

	    hr = myDupString(m_strUserDN, &m_pwszUPN);
	    _JumpIfError(hr, error, "myDupString");

            wcscpy(m_pwszUPN, pwszUserName);
            awszExplodedDN = ldap_explode_dn(m_strUserDN, 0);
            if (NULL != awszExplodedDN)
            {
                wcscat(m_pwszUPN, L"@");
                for (ppwszCurrent = awszExplodedDN;
		     NULL != *ppwszCurrent;
		     ppwszCurrent++)
                {
		    WCHAR wszDC[4];

		    wcsncpy(wszDC, *ppwszCurrent, ARRAYSIZE(wszDC) - 1);
		    wszDC[ARRAYSIZE(wszDC) - 1] = L'\0';
		    if (0 == lstrcmpi(wszDC, L"DC="))
                    {
                        wcscat(
			    m_pwszUPN,
			    (*ppwszCurrent) + ARRAYSIZE(wszDC) - 1);
                        wcscat(m_pwszUPN, L".");
                    }
                }

                // remove the trailing '.' or "@" if there was no DC=

                m_pwszUPN[wcslen(m_pwszUPN) - 1] = L'\0';

                // We're done referencing awszExplodedDN, so free it.
                // ldap_value_free frees the ldap_explode_dn return value

                ldap_value_free(awszExplodedDN);
            }
        }
	else
        {
            LPCWSTR wszStrings[1];

            wszStrings[0] = m_strUserDN;

            ::LogModuleStatus(
			g_hInstance,
			MSG_NO_DNS_NAME,
			TRUE,
			m_pPolicy->GetPolicyDescription(),
			wszStrings);
            if (hr == S_OK)
            {
                hr = CERTSRV_E_SUBJECT_DNS_REQUIRED;
            }
	    _JumpErrorStr(hr, error, "No DNS Name", m_strUserDN);
        }
    }
    DBGPRINT((DBG_SS_CERTPOL, "m_pwszUPN = %ws\n", m_pwszUPN));

    strProp = SysAllocString(wszPROPCERTIFICATEUPN);
    if (NULL == strProp)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    var.bstrVal = NULL;
    if (!myConvertWszToBstr(&var.bstrVal, m_pwszUPN, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    var.vt = VT_BSTR;

    hr = pServer->SetCertificateProperty(strProp, PROPTYPE_STRING, &var);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    if (NULL != strSamName)
    {
        SysFreeString(strSamName);
    }
    if (NULL != awszUPN)
    {
        _FreeValues(awszUPN);
    }
    if (NULL != strProp)
    {
	SysFreeString(strProp);
    }
    VariantClear(&var);
    return(hr);
}


#define wszSEARCHUSER		L"(objectCategory=user)"
#define wszSEARCHCOMPUTER	L"(objectCategory=computer)"
#define wszSEARCHUSERCOMPUTER	L"(|" wszSEARCHUSER wszSEARCHCOMPUTER L")"
#define wszDSOBJECTCATEGORYATTRIBUTE       L"objectCategory"


WCHAR *s_apwszAttrs[] = {
    wszDSOBJECTCLASSATTRIBUTE,
    //wszDSOBJECTCATEGORYATTRIBUTE,
    DS_ATTR_COMMON_NAME,
    DS_ATTR_DNS_NAME,
    DS_ATTR_EMAIL_ADDR,
    DS_ATTR_OBJECT_GUID,
    DS_ATTR_UPN,
    NULL,
};


HRESULT
CRequestInstance::_GetDSObject()
{
    HRESULT hr;
    ULONG ldaperr;
    struct l_timeval timeout;
    WCHAR **ppwszValues = NULL;
    BOOL fRediscover = FALSE;
    BOOL fUser;

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    while (TRUE)
    {
	if (NULL != m_SearchResult)
	{
	    ldap_msgfree(m_SearchResult);
	    m_SearchResult = NULL;
	}

	hr = myLdapGCBind(&g_pldGC);
	_JumpIfError(hr, error, "myLdapGCBind");

	ldaperr = ldap_search_ext_s(
			    g_pldGC,
			    m_strUserDN,
			    LDAP_SCOPE_BASE,
			    wszSEARCHUSERCOMPUTER,
			    s_apwszAttrs,
			    0,
			    NULL,
			    NULL,
			    &timeout,
			    10000,
			    &m_SearchResult);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(g_pldGC, ldaperr, NULL);
	    if (!fRediscover)   // only do this once
	    {
		// get rid of GC we have, handle might be stale

		_PrintError2(hr, "Policy:ldap_search_ext_s", hr);
		myLdapGCUnBind(&g_pldGC);
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "Policy:ldap_search_ext_s");
	}
	break;
    }
    if (0 == ldap_count_entries(g_pldGC, m_SearchResult))
    {
	hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
	_JumpError(hr, error, "Policy:ldap_count_entries");
    }

    m_PrincipalAttributes = ldap_first_entry(g_pldGC, m_SearchResult);
    if (NULL == m_PrincipalAttributes)
    {
	hr = myHLdapLastError(g_pldGC, NULL);
        _JumpError(hr, error, "Policy:ldap_first_entry");
    }
#if DBG_CERTSRV
    {
	DWORD i;

	for (i = 0; NULL != s_apwszAttrs[i]; i++)
	{
	    if (0 == lstrcmpi(DS_ATTR_OBJECT_GUID, s_apwszAttrs[i]))
	    {
		BSTR strGuid = NULL;

		hr = _GetObjectGUID(&strGuid);
		if (S_OK == hr)
		{
		    WCHAR *pwsz;

		    hr = myCLSIDToWsz((CLSID const *) strGuid, &pwsz);
		    if (S_OK == hr)
		    {
			DBGPRINT((
			    DBG_SS_CERTPOL,
			    "%ws = %ws\n",
			    s_apwszAttrs[i],
			    pwsz));
			LocalFree(pwsz);
		    }
		    SysFreeString(strGuid);
		}
	    }
	    else
	    {
		hr = _GetValues(s_apwszAttrs[i], &ppwszValues);
		if (S_OK == hr)
		{
		    DWORD j;

		    for (j = 0; NULL != ppwszValues[j]; j++)
		    {
			DBGPRINT((
			    DBG_SS_CERTPOL,
			    "%ws[%u] = %ws\n",
			    s_apwszAttrs[i],
			    j,
			    ppwszValues[j]));
		    }
		    _FreeValues(ppwszValues);
		    ppwszValues = NULL;
		}
	    }
	    if (S_OK != hr)
	    {
		DBGPRINT((DBG_SS_CERTPOL, "%ws = NULL\n", s_apwszAttrs[i]));
	    }
	}
    }
#endif

    hr = _GetValues(wszDSOBJECTCLASSATTRIBUTE, &ppwszValues);
    _JumpIfErrorStr(hr, error, "Policy:_GetValues", wszDSOBJECTCLASSATTRIBUTE);

    fUser = TRUE;
    if (NULL != ppwszValues)
    {
	DWORD i;

	for (i = 0; NULL != ppwszValues[i]; i++)
	{
	    DBGPRINT((
		DBG_SS_CERTPOLI,
		"Class[%u] = %ws\n",
		i,
		ppwszValues[i]));
	    if (0 == lstrcmpi(L"computer", ppwszValues[i]))
	    {
		fUser = FALSE;
		break;
	    }
	}
    }

    if (fUser != m_fUser)
    {
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    fUser? "MACHINE -> USER: %ws\n" : "USER -> MACHINE: %ws\n",
	    m_strUserDN));
	m_fUser = fUser;
    }

    hr = S_OK;

error:
    if (NULL != ppwszValues)
    {
        _FreeValues(ppwszValues);
    }
    return(hr);
}


HRESULT
CRequestInstance::_GetValues(
    IN WCHAR const *pwszName,
    OUT WCHAR ***pppwszValues)
{
    HRESULT hr;
    WCHAR **ppwszValues = NULL;
    
    ppwszValues = ldap_get_values(
			    g_pldGC,
			    m_PrincipalAttributes,
			    const_cast<WCHAR *>(pwszName));
    if (NULL == ppwszValues || NULL == ppwszValues[0])
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
        _JumpErrorStr2(hr, error, "Policy:ldap_get_values", pwszName, hr);
    }
    *pppwszValues = ppwszValues;
    ppwszValues = NULL;
    hr = S_OK;

error:
    if (NULL != ppwszValues)
    {
	ldap_value_free(ppwszValues);
    }
    return(hr);
}


HRESULT
CRequestInstance::_GetObjectGUID(
    OUT BSTR *pstrGuid)
{
    struct berval **pGuidVal = NULL;
    HRESULT hr;

    *pstrGuid = NULL;
    pGuidVal = ldap_get_values_len(
			    g_pldGC,
			    m_PrincipalAttributes,
			    DS_ATTR_OBJECT_GUID);
    if (NULL == pGuidVal || NULL == pGuidVal[0])
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
        _JumpError2(hr, error, "Policy:ldap_get_values_len", hr);
    }
    *pstrGuid = SysAllocStringByteLen(pGuidVal[0]->bv_val, pGuidVal[0]->bv_len);
    if (NULL == *pstrGuid)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocStringByteLen");
    }
    hr = S_OK;

error:
    if (NULL != pGuidVal)
    {
	ldap_value_free_len(pGuidVal);
    }
    return(hr);
}


HRESULT
CRequestInstance::_FreeValues(
    IN WCHAR **ppwszValues)
{
    if (NULL != ppwszValues)
    {
        ldap_value_free(ppwszValues);
    }
    return(S_OK);
}


HRESULT
CRequestInstance::_GetValueString(
    IN WCHAR const *pwszName,
    OUT BSTRC *pstrValue)
{
    HRESULT hr;
    WCHAR **ppwszValues = NULL;
    BSTR strReturn;
    DWORD i;
    DWORD cwc;

    *pstrValue = NULL;

    hr = _GetValues(pwszName, &ppwszValues);
    _JumpIfErrorStr(hr, error, "Policy:_GetValues", pwszName);

    if (NULL == ppwszValues || NULL == ppwszValues[0])
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpErrorStr(hr, error, "Policy:ppwszValues", pwszName);
    }

    cwc = 0;
    for (i = 0; NULL != ppwszValues[i]; i++)
    {
	if (0 != i)
	{
	    cwc++;
	}
	cwc += wcslen(ppwszValues[i]);
    }

    strReturn = SysAllocStringLen(NULL, cwc);
    if (NULL == strReturn)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocStringLen");
    }

    strReturn[0] = L'\0';
    for (i = 0; NULL != ppwszValues[i]; i++)
    {
	if (0 != i)
	{
	    wcscat(strReturn, L",");
	}
	wcscat(strReturn, ppwszValues[i]);
    }
    CSASSERT(SysStringByteLen(strReturn) == cwc * sizeof(WCHAR));
    CSASSERT(wcslen(strReturn) == cwc);
    *pstrValue = strReturn;

error:
    if (NULL != ppwszValues)
    {
        _FreeValues(ppwszValues);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certpent.rc
//
#define IDS_CERTPOLICY_DESC             1
#define IDS_CERTMANAGEPOLICYMODULE_DESC 2
#define IDS_NO_CONFIGURABLE_DATA        3
#define IDC_RADIO1                      201
#define IDC_RADIO_ISSUE                 202
#define IDC_EDIT1                       203
#define IDC_ADD_CRL                     205
#define IDC_REMOVE_CRL                  206
#define IDC_ADD_AIA                     207
#define IDC_REMOVE_AIA                  208
#define IDC_TEXT_PENDFIRST              209
#define IDC_RADIO_PENDFIRST             211
#define IDC_RADIO2                      212
#define IDD_POLICYPG1                   609
#define IDD_POLICYPG2                   610
#define IDS_MODULE_NAME                 611
#define IDS_MODULE_DESCR                612
#define IDS_MODULE_COPYRIGHT            613
#define IDS_MODULE_FILEVER              614
#define IDS_MODULE_PRODUCTVER           615
#define IDS_WARNING_REBOOT              616
#define IDS_WARNING_NOSAVE              617
#define IDC_CRL_LIST                    737
#define IDC_AIA_LIST                    738
#define IDB_CHECKLIST                   739
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\default\template.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        template.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <winldap.h>
#include <security.h>

#include "cspelog.h"
#include "pollog.h"

#include "csprop.h"
#include "csldap.h"
#include "csdisp.h"
#include "csber.h"
#include "policy.h"
#include "cainfop.h"


// Versions of NT earlier than this build have an auto-enrollment loop problem
// with not having the basic constraints extension, so we must put one in certs
// for these builds.  This build marks when certcli started return no BC
// extension for templates that were not CA's.

#define VERSION_AUTOENROLLMENT_BC_AWARE   2036


// Versions of NT earlier than this build have an auto-enrollment loop problem
// with having the UPN anywhere but the CN.  Certs for these builds must have
// the UPN in the common name.

#define VERSION_AUTOENROLLMENT_UPN_AWARE   2090

#define VERSION_WIN2K_XENROLL_CLIENT	   (2195 + 1)


KUMASK g_aKUMasks[] =
{
  { ~CERT_KEY_AGREEMENT_KEY_USAGE,    TEXT(szOID_RSA_RSA) },
  { ~CERT_KEY_ENCIPHERMENT_KEY_USAGE, TEXT(szOID_OIWSEC_dsa) },
  { ~CERT_KEY_ENCIPHERMENT_KEY_USAGE, TEXT(szOID_X957_DSA) },
  { ~CERT_KEY_ENCIPHERMENT_KEY_USAGE, TEXT(szOID_ANSI_X942_DH) },
  { ~CERT_KEY_ENCIPHERMENT_KEY_USAGE, TEXT(szOID_RSA_DH) },
  { ~CERT_KEY_AGREEMENT_KEY_USAGE,    TEXT(szOID_OIWSEC_rsaXchg) },
  { ~CERT_KEY_ENCIPHERMENT_KEY_USAGE, TEXT(szOID_INFOSEC_mosaicKMandUpdSig) }
};


CTemplatePolicy::CTemplatePolicy()
{
    m_hCertType = NULL;
    m_pExtensions = NULL;
    m_pwszTemplateName = NULL;
    m_pwszTemplateObjId = NULL;
    m_dwEnrollmentFlags = 0;
    m_dwSubjectNameFlags = 0;
    m_dwPrivateKeyFlags = 0;
    m_dwGeneralFlags = 0;
    m_pPolicy = NULL;
}


CTemplatePolicy::~CTemplatePolicy()
{
    _Cleanup();
}


VOID
CTemplatePolicy::_Cleanup()
{
    if (NULL != m_hCertType)
    {
        if (NULL != m_pExtensions)
        {
            CAFreeCertTypeExtensions(m_hCertType, m_pExtensions);
	    m_pExtensions = NULL;
        }
        CACloseCertType(m_hCertType);
        m_hCertType = NULL;
    }
    if (NULL != m_pwszTemplateName)
    {
        LocalFree(m_pwszTemplateName);
        m_pwszTemplateName = NULL;
    }
    if (NULL != m_pwszTemplateObjId)
    {
        LocalFree(m_pwszTemplateObjId);
        m_pwszTemplateObjId = NULL;
    }
    m_pPolicy = NULL;
}


HRESULT
CTemplatePolicy::_LogLoadResult(
    IN CCertPolicyEnterprise *pPolicy,
    IN ICertServerPolicy *pServer,
    IN HRESULT hrLoad)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    WCHAR const *apwsz[2];
    DWORD level;
    DWORD MsgId;
    WCHAR const *pwszLogProp;

    if (S_OK != hrLoad)
    {
	pwszError = myGetErrorMessageText(hrLoad, TRUE);
	level = CERTLOG_WARNING;
	MsgId = MSG_LOAD_TEMPLATE;
	pwszLogProp = wszPROPEVENTLOGWARNING;
    }
    else
    {
	level = CERTLOG_VERBOSE;
	MsgId = MSG_LOAD_TEMPLATE_SUCCEEDED;
	pwszLogProp = wszPROPEVENTLOGVERBOSE;
    }
    if (level > pPolicy->GetLogLevel())
    {
	hr = S_OK;
	goto error;
    }
    apwsz[0] = m_pwszTemplateName;
    apwsz[1] = pwszError;

    hr = LogPolicyEvent(
		g_hInstance,
		MsgId,
		pServer,
		pwszLogProp,
		apwsz);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:LogPolicyEvent");

error:
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::Initialize
// Populate the CTemplatePolicy object from the registry
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::Initialize(
    IN HCERTTYPE hCertType,
    IN ICertServerPolicy *pServer,
    IN CCertPolicyEnterprise *pPolicy)
{
    HRESULT hr;
    CERT_EXTENSIONS *pExtensions = NULL;

    _Cleanup();

    hr = polCAGetCertTypeStringProperty(
				hCertType,
				CERTTYPE_PROP_DN,
				&m_pwszTemplateName);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:Initialize:polCAGetCertTypeStringProperty",
		CERTTYPE_PROP_DN);

    hr = CAGetCertTypePropertyEx(
			hCertType,
			CERTTYPE_PROP_SCHEMA_VERSION,
			&m_dwSchemaVersion);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		CERTTYPE_PROP_SCHEMA_VERSION);

    if (!FIsAdvancedServer() && CERTTYPE_SCHEMA_VERSION_2 <= m_dwSchemaVersion)
    {
	// V2 templates require Advanced Server

	hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "CTemplatePolicy:Initialize:m_dwSchemaVersion");
    }
    m_pPolicy = pPolicy;

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_ENROLLMENT_FLAG,
			&m_dwEnrollmentFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_SUBJECT_NAME_FLAG,
			&m_dwSubjectNameFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_PRIVATE_KEY_FLAG,
			&m_dwPrivateKeyFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_GENERAL_FLAG,
			&m_dwGeneralFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypeExtensions(hCertType, &pExtensions);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeExtensions");

    m_dwTemplateMinorVersion = 0;
    m_dwMinKeyLength = 0;
    if (CERTTYPE_SCHEMA_VERSION_2 <= m_dwSchemaVersion)
    {
	hr = polCAGetCertTypeStringProperty(
				    hCertType,
				    CERTTYPE_PROP_OID,
				    &m_pwszTemplateObjId);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "CTemplatePolicy:Initialize:polCAGetCertTypeStringProperty",
		    CERTTYPE_PROP_OID);

	hr = CAGetCertTypePropertyEx(
			    hCertType,
			    CERTTYPE_PROP_MINOR_REVISION,
			    &m_dwTemplateMinorVersion);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		    CERTTYPE_PROP_MINOR_REVISION);

	hr = CAGetCertTypePropertyEx(
			    hCertType,
			    CERTTYPE_PROP_MIN_KEY_SIZE,
			    &m_dwMinKeyLength);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		    CERTTYPE_PROP_MIN_KEY_SIZE);
    }
    hr = CAGetCertTypePropertyEx(
			hCertType,
			CERTTYPE_PROP_REVISION,
			&m_dwTemplateMajorVersion);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		CERTTYPE_PROP_REVISION);

    m_hCertType = hCertType;	// Transfer ownership only on success
    m_pExtensions = pExtensions;
    pExtensions = NULL;
    hr = S_OK;

error:
    if (NULL != pExtensions)
    {
	CAFreeCertTypeExtensions(hCertType, pExtensions);
    }
    DBGPRINT((
	DBG_SS_CERTPOL,
	"Policy:Template:Initialize(%ws, v%u.%u): V%u hr=%x\n",
	NULL != m_pwszTemplateName? m_pwszTemplateName : L"",
	m_dwTemplateMajorVersion,
	m_dwTemplateMinorVersion,
	m_dwSchemaVersion,
	hr));
    _LogLoadResult(pPolicy, pServer, hr);
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::Apply
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::Apply(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    HANDLE hToken;

    if(pRequest->IsNewRequest())
    {
        // on resubmitted requests we don't have the requester's token
        hToken = pRequest->_GetToken();

        CSASSERT(NULL != hToken);

	hr = CACertTypeAccessCheck(m_hCertType, hToken);
	if (E_ACCESSDENIED == hr)
	{
	    // map E_ACCESSDENIED to a more meaningful error

	    hr = CERTSRV_E_TEMPLATE_DENIED;
        }
        _JumpIfError(hr, error, "Policy:CACertTypeAccessCheck");
    }

    hr = _AddBasicConstraintsExtension(pRequest, pServer);
    _JumpIfError(hr, error, "Policy:_AddBasicConstraintsExtension");

    hr = _AddKeyUsageExtension(pServer);
    _JumpIfError(hr, error, "Policy:_AddKeyUsageExtension");

    hr = _AddTemplateExtensionArray(pServer);
    _JumpIfError(hr, error, "Policy:_AddTemplateExtensionArray");

    if (0 == (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & m_dwSubjectNameFlags))
    {
        hr = pRequest->_LoadPrincipalObject(pServer, this);
        _JumpIfError(hr, error, "_LoadPrincipalObject");

        hr = _AddSubjectName(pServer, pRequest);
	_JumpIfError(hr, error, "Policy:_AddSubjectName");
    }
    hr = _AddAltSubjectName(pServer, pRequest);
    _JumpIfError(hr, error, "Policy:_AddAltSubjectName");

    hr = _ApplyExpirationTime(pServer);
    _JumpIfError(hr, error, "Policy:_ApplyExpirationTime");

    hr = _EnforceKeySizePolicy(pServer);
    _JumpIfError(hr, error, "Policy:_EnforceKeySizePolicy");

    hr = _EnforceKeyArchivalPolicy(pServer);
    _JumpIfError(hr, error, "Policy:_EnforceKeyArchivalPolicy");

    hr = _EnforceSymmetricAlgorithms(pServer, pRequest);
    _JumpIfError(hr, error, "Policy:_EnforceSymmetricAlgorithms");

    hr = _EnforceMinimumTemplateVersion(pRequest);
    _JumpIfError(hr, error, "Policy:_EnforceMinimumTemplateVersion");

    hr = _EnforceEnrollOnBehalfOfAllowed(pServer, pRequest);
    _JumpIfError(hr, error, "Policy:_EnforceEnrollOnBehalfOfAllowed");

    hr = S_FALSE;
    if (CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & m_dwEnrollmentFlags)
    {
	hr = _EnforceReenrollment(pServer, pRequest);
	_PrintIfError(hr, "Policy:_EnforceReenrollment");
    }
    if (S_OK != hr)
    {
	hr = _EnforceSignaturePolicy(pServer);
	_JumpIfError(hr, error, "Policy:_EnforceSignaturePolicy");
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddBasicConstraintsExtension(
    IN CRequestInstance *pRequest,
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION BasicConstraintsExtension;

    BasicConstraintsExtension.Value.pbData = NULL;

    pExt = CertFindExtension(
			szOID_BASIC_CONSTRAINTS2,
			m_pExtensions->cExtension,
			m_pExtensions->rgExtension);
    if (NULL == pExt)
    {
        if (pRequest->_IsNTClientOlder(
				5,
				0,
				VERSION_AUTOENROLLMENT_BC_AWARE,
				VER_PLATFORM_WIN32_NT))
        {

            CERT_BASIC_CONSTRAINTS2_INFO OldBasicConstraints =
		{ FALSE, FALSE, 0};

            // Older autoenrollment clients don't know how to deal with
            // having no basic constraints extension, so they might loop.
            // For an old client, we must fabricate a basic constraints.

            if (!myEncodeObject(
			X509_ASN_ENCODING,
			szOID_BASIC_CONSTRAINTS2,
			&OldBasicConstraints,
			0,
			CERTLIB_USE_LOCALALLOC,
			&BasicConstraintsExtension.Value.pbData,
			&BasicConstraintsExtension.Value.cbData))
	    {
                hr = myHLastError();
                _JumpError(hr, error, "Policy:myEncodeObject");
            }
            BasicConstraintsExtension.fCritical = TRUE;
            BasicConstraintsExtension.pszObjId = szOID_BASIC_CONSTRAINTS2;
            pExt = &BasicConstraintsExtension;
        }
    }
    hr = m_pPolicy->AddBasicConstraintsCommon(
				    pServer,
				    pExt,
				    FALSE, // fCA only enabled for standalone
				    NULL != pExt);
    _JumpIfError(hr, error, "Policy:AddBasicConstraintsCommon");

error:
    if (NULL != BasicConstraintsExtension.Value.pbData)
    {
        LocalFree(BasicConstraintsExtension.Value.pbData);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strAlg = NULL;
    CERT_EXTENSION const *pExt;
    CRYPT_BIT_BLOB *pKeyUsage = NULL;
    BYTE *pbKeyUsage = NULL;
    DWORD cbKeyUsage;
    DWORD dwMask = 0xffffffff;
    DWORD i;

    VariantInit(&varExtension);

    hr = polGetCertificateStringProperty(
				pServer,
				wszPROPCERTIFICATEPUBLICKEYALGORITHM,
				&strAlg);
    _JumpIfError(hr, error, "Policy:polGetCertificateStringProperty");

    for (i = 0; i < ARRAYSIZE(g_aKUMasks); i++)
    {
        if (0 == wcscmp(strAlg, g_aKUMasks[i].wszAlg))
        {
            dwMask = g_aKUMasks[i].dwMask;
            break;
        }
    }

    pExt = CertFindExtension(
			szOID_KEY_USAGE,
			m_pExtensions->cExtension,
			m_pExtensions->rgExtension);
    if (NULL == pExt)
    {
        hr = S_OK;
        goto error;
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_KEY_USAGE,
		pExt->Value.pbData,
		pExt->Value.cbData,
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pKeyUsage,
		&cbKeyUsage))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }

    // Mask out any unneeded bits

    for (i = 0; i < pKeyUsage->cbData; i++)
    {
        pKeyUsage->pbData[i] &= ((BYTE *) &dwMask)[i];
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_KEY_USAGE,
		    pKeyUsage,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbKeyUsage,
		    &cbKeyUsage))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    strExtension = NULL;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_KEY_USAGE),
			    PROPTYPE_BINARY,
			    pExt->fCritical? EXTENSION_CRITICAL_FLAG : 0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtension");

error:
    VariantClear(&varExtension);
    if (NULL != strAlg)
    {
        SysFreeString(strAlg);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != pbKeyUsage)
    {
        LocalFree(pbKeyUsage);
    }
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddTemplateExtensionArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddTemplateExtensionArray(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < m_pExtensions->cExtension; i++)
    {
	CERT_EXTENSION const *pExt = &m_pExtensions->rgExtension[i];

	// Skip extensions that have special handling code.

	if (0 == strcmp(szOID_BASIC_CONSTRAINTS2, pExt->pszObjId) ||
	    0 == strcmp(szOID_KEY_USAGE, pExt->pszObjId))
	{
	    continue;
	}
	hr = _AddTemplateExtension(pServer, pExt);
	_JumpIfError(hr, error, "Policy:_AddTemplateExtension");
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddTemplateExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddTemplateExtension(
    IN ICertServerPolicy *pServer,
    IN CERT_EXTENSION const *pExt)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    BSTR strObjId = NULL;
    VARIANT varExtension;

    if (!myConvertSzToBstr(&strObjId, pExt->pszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertSzToBstr");
    }

    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pExt->Value.pbData,
			pExt->Value.cbData))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strObjId,
			    PROPTYPE_BINARY,
			    pExt->fCritical? EXTENSION_CRITICAL_FLAG : 0,
			    &varExtension);
    _JumpIfErrorStr(hr, error, "Policy:SetCertificateExtension", strObjId);

error:
    if (NULL != strObjId)
    {
        SysFreeString(strObjId);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddSubjectName
//
// Build the subject name and add it to the cert, if required
//
// The subject name consists of:
// machine:  the CN is set to the UPN (machineDNSName)
// old user: the CN is set to the UPN (Kerberos name)
// user:     the CN is set to the DS_ATTR_COMMON_NAME
//
// both:  E= indicates an e-mail name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddSubjectName(
    IN ICertServerPolicy *pServer,
    CRequestInstance *pRequest)
{
    HRESULT hr;
    BSTRC strCN = NULL;
    BSTRC strEMail = NULL;
    VARIANT varValue;

    // Clear out any existing subject name info

    varValue.vt = VT_NULL;
    hr = pServer->SetCertificateProperty(
				    wszPROPSUBJECTDOT,	// BUGBUG:BSTR
				    PROPTYPE_STRING,
				    &varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

    if (CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH & m_dwSubjectNameFlags)
    {
	hr = _AddDSDistinguishedName(pServer, pRequest);
	_JumpIfError(hr, error, "Policy:_AddDSDistinguishedName");
    }
    else
    if ((CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME |
	 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN) & m_dwSubjectNameFlags)
    {
	if (!pRequest->_IsUser() ||
	    (pRequest->_IsXenrollRequest() &&
	     pRequest->_IsNTClientOlder(
				5,
				0,
				VERSION_AUTOENROLLMENT_UPN_AWARE,
				VER_PLATFORM_WIN32_NT)))

	{
	    // The UPN will be either a user UPN or the machine DNS name

	    if (NULL == pRequest->m_pwszUPN)
	    {
		hr = E_POINTER;	// We should never get this
		_JumpError(hr, error, "Policy:NULL UPN");
	    }
	    strCN = SysAllocString(pRequest->m_pwszUPN);
	    if (NULL == strCN)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:SysAllocString");
	    }
	}
	else
	{
	    // We are talking to an advanced client which can deal with a UPN
	    // in a SubjectAltName extension.  Put the DS CN in the cert.

	    hr = pRequest->_GetValueString(DS_ATTR_COMMON_NAME, &strCN);
	    _JumpIfErrorStr(
			hr,
			error,
			"Policy:_GetValueString",
			DS_ATTR_COMMON_NAME);
	}
	CSASSERT(NULL != strCN);
	varValue.vt = VT_BSTR;
	varValue.bstrVal = const_cast<BSTR>(strCN);

	hr = pServer->SetCertificateProperty(
				    wszPROPSUBJECTCOMMONNAME,	// BUGBUG:BSTR
				    PROPTYPE_STRING,
				    &varValue);
	_JumpIfError(hr, error, "Policy:SetCertificateProperty");
    }

    if (CT_FLAG_SUBJECT_REQUIRE_EMAIL & m_dwSubjectNameFlags)
    {
        hr = pRequest->_GetValueString(DS_ATTR_EMAIL_ADDR, &strEMail);
        if (S_OK == hr)
        {
	    varValue.vt = VT_BSTR;
	    varValue.bstrVal = const_cast<BSTR>(strEMail);

	    hr = pServer->SetCertificateProperty(
				        wszPROPSUBJECTEMAIL,	// BUGBUG:BSTR
				        PROPTYPE_STRING,
				        &varValue);
	    _JumpIfError(hr, error, "Policy:SetCertificateProperty");
        }
        else
        {
            LPCWSTR wszStrings[1];

            wszStrings[0] = pRequest->m_strUserDN;
            ::LogModuleStatus(
			g_hInstance,
			MSG_NO_EMAIL_NAME,
			TRUE,
			pRequest->GetPolicy()->GetPolicyDescription(),
			wszStrings);
        }
    }
    hr = S_OK;

error:
    if (NULL != strCN)
    {
        SysFreeString(const_cast<BSTR>(strCN));
    }
    if (NULL != strEMail)
    {
        SysFreeString(const_cast<BSTR>(strEMail));
    }
    return(hr);
}


HRESULT
myCertStrToName(
    IN WCHAR const *pwszName,
    OUT CERT_NAME_BLOB *pName)
{
    HRESULT hr;
    WCHAR const *pwszError;

    pName->cbData = 0;
    pName->pbData = NULL;

    if (!CertStrToName(
		X509_ASN_ENCODING,
		pwszName,
		CERT_X500_NAME_STR,
		NULL,
		NULL,	// pName
		&pName->cbData,
		&pwszError))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:CertStrToName");
    }
    pName->pbData = (BYTE *) LocalAlloc(LMEM_FIXED, pName->cbData);
    if (NULL == pName->pbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    if (!CertStrToName(
		X509_ASN_ENCODING,
		pwszName,
		CERT_X500_NAME_STR,
		NULL,
		pName->pbData,
		&pName->cbData,
		&pwszError))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:CertStrToName");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CTemplatePolicy::_AddDSDistinguishedName(
    IN ICertServerPolicy *pServer,
    CRequestInstance *pRequest)
{
    HRESULT hr;
    CERT_NAME_BLOB Name = { 0, NULL };
    CERT_NAME_INFO *pNameInfo = NULL;
    WCHAR *pwszObjId = NULL;
    BSTR strRDN = NULL;
    BSTR strRDNName = NULL;
    BSTR strRDNValue = NULL;
    DWORD cb;
    CERT_RDN *prdn;
    CERT_RDN *prdnEnd;

    if (NULL == pRequest->m_strUserDN)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "Policy:m_strUserDN");
    }

    hr = myCertStrToName(pRequest->m_strUserDN, &Name);
    _JumpIfError(hr, error, "Policy:myCertStrToName");

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		Name.pbData,
		Name.cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    VARIANT varNew;

	    if (NULL == prdna->Value.pbData ||
		sizeof(WCHAR) > prdna->Value.cbData ||
		L'\0' == *(WCHAR *) prdna->Value.pbData)
	    {
		continue;
	    }
	    if (NULL != strRDNValue)
	    {
		SysFreeString(strRDNValue);
		strRDNValue = NULL;
	    }
	    if (NULL != strRDNName)
	    {
		SysFreeString(strRDNName);
		strRDNName = NULL;
	    }
	    if (NULL != pwszObjId)
	    {
		LocalFree(pwszObjId);
		pwszObjId = NULL;
	    }

	    if (!myConvertSzToWsz(&pwszObjId, prdna->pszObjId, MAXDWORD))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertSzToWsz");
	    }
	    strRDNName = SysAllocStringLen(
			NULL,
			WSZARRAYSIZE(wszPROPSUBJECTDOT) + wcslen(pwszObjId));
	    if (NULL == strRDNName)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:SysAllocStringLen");
	    }
	    wcscpy(strRDNName, wszPROPSUBJECTDOT);
	    wcscat(strRDNName, pwszObjId);
	    CSASSERT(SysStringByteLen(strRDNName) == wcslen(strRDNName) * sizeof(WCHAR));

	    hr = polGetCertificateStringProperty(pServer, strRDNName, &strRDN);
	    if (S_OK == hr)
	    {
		strRDNValue = SysAllocStringLen(
			    NULL,
			    wcslen((WCHAR *) prdna->Value.pbData) +
				WSZARRAYSIZE(wszNAMESEPARATORDEFAULT) +
				wcslen(strRDN));
		if (NULL == strRDNValue)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "Policy:SysAllocStringLen");
		}
		wcscpy(strRDNValue, (WCHAR *) prdna->Value.pbData);
		wcscat(strRDNValue, wszNAMESEPARATORDEFAULT);
		wcscat(strRDNValue, strRDN);
	    }
	    if (NULL == strRDNValue)
	    {
		strRDNValue = SysAllocString((WCHAR *) prdna->Value.pbData);
		if (NULL == strRDNValue)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "Policy:SysAllocStringLen");
		}
	    }
	    varNew.vt = VT_BSTR;
	    varNew.bstrVal = strRDNValue;
	    hr = pServer->SetCertificateProperty(
					strRDNName,
					PROPTYPE_STRING,
					&varNew);
	    _JumpIfError(hr, error, "Policy:SetCertificateProperty");
        }
    }

error:
    if (NULL != strRDN)
    {
	SysFreeString(strRDN);
    }
    if (NULL != strRDNValue)
    {
	SysFreeString(strRDNValue);
    }
    if (NULL != strRDNName)
    {
        SysFreeString(strRDNName);
    }
    if (NULL != pwszObjId)
    {
        LocalFree(pwszObjId);
    }
    if (NULL != Name.pbData)
    {
        LocalFree(Name.pbData);
    }
    if (NULL != pNameInfo)
    {
        LocalFree(pNameInfo);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddAltSubjectName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddAltSubjectName(
    IN ICertServerPolicy *pServer,
    CRequestInstance *pRequest)
{
    HRESULT hr = S_OK;
    DWORD cbExtension;
    VARIANT varExtension;
    DWORD iNameEntry;
    WCHAR **ppwszCurName;
    CERT_OTHER_NAME objectGuidOtherName;
    CERT_OTHER_NAME upnOtherName;

    WCHAR **apwszMailNames = NULL;
    WCHAR **apwszMachineNames = NULL;
    BYTE *pbExtension= NULL;
    BSTR strobjectGuid = NULL;
    CERT_ALT_NAME_INFO AltName;

    AltName.cAltEntry = 0;
    AltName.rgAltEntry = 0;
    objectGuidOtherName.Value.pbData = NULL;
    objectGuidOtherName.Value.cbData = 0;
    upnOtherName.Value.pbData = NULL;
    upnOtherName.Value.cbData = 0;

    VariantInit(&varExtension);

    // If this cert template doesn't set the alt-subject-name, then enable
    // whatever alt subject name that was in the request.

    if (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME & m_dwSubjectNameFlags)
    {
	LONG ExtFlags;

        hr = pServer->GetCertificateExtension(
                                        TEXT(szOID_SUBJECT_ALT_NAME2),
                                        PROPTYPE_BINARY,
                                        &varExtension);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED;
	}
	_JumpIfError(hr, error, "Policy:GetCertificateExtension");

	hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	if (EXTENSION_DISABLE_FLAG & ExtFlags)
	{
            ExtFlags &= ~EXTENSION_DISABLE_FLAG;
            hr = pServer->SetCertificateExtension(
			            TEXT(szOID_SUBJECT_ALT_NAME2),
			            PROPTYPE_BINARY,
			            ExtFlags,
			            &varExtension);
	    _JumpIfError(hr, error, "Policy:SetCertificateExtension");
        }
        CSASSERT(S_OK == hr);
        goto error;
    }

    // We do alt name entries for
    //   UPN/SPN
    //   rfc822 (mail name)
    //   DNSname
    //   DS location

    if ((CT_FLAG_SUBJECT_ALT_REQUIRE_UPN | CT_FLAG_SUBJECT_ALT_REQUIRE_SPN) &
	m_dwSubjectNameFlags)
    {
        // Add the UPN

        if (NULL == pRequest->m_pwszUPN)
        {
	    hr = CERTSRV_E_SUBJECT_UPN_REQUIRED;
	    _JumpError(hr, error, "Policy:_AddAltSubjectName");
        }
	AltName.cAltEntry++;
    }

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL & m_dwSubjectNameFlags)
    {
        hr = pRequest->_GetValues(DS_ATTR_EMAIL_ADDR, &apwszMailNames);
	if (S_OK != hr || NULL == apwszMailNames || NULL == apwszMailNames[0])
        {
            LPCWSTR wszStrings[1];

	    _PrintIfError(hr, "_GetValues(email)");
            wszStrings[0] = pRequest->m_strUserDN;
            ::LogModuleStatus(
			g_hInstance,
			MSG_NO_EMAIL_NAME,
			TRUE,
			pRequest->GetPolicy()->GetPolicyDescription(),
			wszStrings);
	}
	else
	{
	    ppwszCurName = apwszMailNames;
	    while (NULL != *ppwszCurName)
	    {
		AltName.cAltEntry++;
		ppwszCurName++;
	    }
	}
    }

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID & m_dwSubjectNameFlags)
    {
        hr = pRequest->_GetObjectGUID(&strobjectGuid);
	if (S_OK != hr || NULL == strobjectGuid)
        {
	    _PrintIfError(hr, "_GetObjectGUID");
	    hr = CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED;
	    _JumpError(hr, error, "Policy:_AddAltSubjectName");
	}
	AltName.cAltEntry++;
    }
    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DNS & m_dwSubjectNameFlags)
    {
        hr = pRequest->_GetValues(DS_ATTR_DNS_NAME, &apwszMachineNames);
	if (S_OK != hr || NULL == apwszMachineNames || NULL == apwszMachineNames[0])
        {
	    _PrintIfError(hr, "_GetValues(dns)");
	    hr = CERTSRV_E_SUBJECT_DNS_REQUIRED;
	    _JumpError(hr, error, "Policy:_AddAltSubjectName");
	}

	ppwszCurName = apwszMachineNames;
	while (NULL != *ppwszCurName)
	{
	    AltName.cAltEntry++;
	    ppwszCurName++;
        }
    }

    if (AltName.cAltEntry == 0)
    {
        hr = S_OK;
        goto error;
    }

    AltName.rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			    LMEM_FIXED,
                            sizeof(CERT_ALT_NAME_ENTRY) * AltName.cAltEntry);
    if (NULL == AltName.rgAltEntry)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    iNameEntry = 0;

    if ((CT_FLAG_SUBJECT_ALT_REQUIRE_UPN | CT_FLAG_SUBJECT_ALT_REQUIRE_SPN) &
	m_dwSubjectNameFlags)
    {
        // Add the UPN

	CERT_NAME_VALUE nameUpn;

	nameUpn.dwValueType = CERT_RDN_UTF8_STRING;
	nameUpn.Value.pbData = (BYTE *) pRequest->m_pwszUPN;
	nameUpn.Value.cbData = wcslen(pRequest->m_pwszUPN) * sizeof(WCHAR);

	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    &nameUpn,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &upnOtherName.Value.pbData,
		    &upnOtherName.Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myEncodeObject");
	}

	upnOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
	AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_OTHER_NAME;
	AltName.rgAltEntry[iNameEntry++].pOtherName = &upnOtherName;
    }

    // Now do strobjectGuid

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID & m_dwSubjectNameFlags)
    {
        CRYPT_DATA_BLOB blobGuid;

	CSASSERT(NULL != strobjectGuid);
        blobGuid.pbData = (BYTE *) strobjectGuid;
        blobGuid.cbData = SysStringByteLen(strobjectGuid);

        objectGuidOtherName.pszObjId = szOID_NTDS_REPLICATION;

        if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&blobGuid,
			0,
			CERTLIB_USE_LOCALALLOC,
			&objectGuidOtherName.Value.pbData,
			&objectGuidOtherName.Value.cbData))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "Policy:myEncodeObject");
        }
        AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_OTHER_NAME;
        AltName.rgAltEntry[iNameEntry++].pOtherName = &objectGuidOtherName;
    }

    // Now do rfc822

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL & m_dwSubjectNameFlags)
    {
	ppwszCurName = apwszMailNames;
	if (NULL != ppwszCurName)
	{
	    while (NULL != *ppwszCurName)
	    {
		AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_RFC822_NAME;
		AltName.rgAltEntry[iNameEntry++].pwszRfc822Name = *ppwszCurName;
		ppwszCurName++;
	    }
	}
    }

    // Now do DNS

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DNS & m_dwSubjectNameFlags)
    {
	ppwszCurName = apwszMachineNames;
	if (NULL != ppwszCurName)
	{
	    while (NULL != *ppwszCurName)
	    {
		AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_DNS_NAME;
		AltName.rgAltEntry[iNameEntry++].pwszRfc822Name = *ppwszCurName;
		ppwszCurName++;
	    }
	}
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbExtension,
		    &cbExtension))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = SysAllocStringByteLen(
					(char const *) pbExtension,
					cbExtension);
    if (NULL == varExtension.bstrVal)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocStringByteLen");
    }
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_SUBJECT_ALT_NAME2),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtension");

error:
    if (NULL != pbExtension)
    {
        LocalFree(pbExtension);
    }
    if (NULL != strobjectGuid)
    {
        SysFreeString(strobjectGuid);
    }
    if (NULL != AltName.rgAltEntry)
    {
        // clean each entry in array
        for (DWORD i = 0; i < AltName.cAltEntry; i++)
        {
            switch (AltName.rgAltEntry[i].dwAltNameChoice)
            {
                case CERT_ALT_NAME_DIRECTORY_NAME:
                {
                    if (NULL != AltName.rgAltEntry[i].DirectoryName.pbData)
                    {
                        LocalFree(AltName.rgAltEntry[i].DirectoryName.pbData);
                        AltName.rgAltEntry[i].DirectoryName.pbData = NULL;
                    }
                    break;
                }
                case CERT_ALT_NAME_OTHER_NAME:
                    // points to objectGuidOtherName or bstrUpn, which are
		    // freed separately
		    break;

                case CERT_ALT_NAME_RFC822_NAME:
                    // points to apwszMailNames, freed later
                    break;

                case CERT_ALT_NAME_DNS_NAME:
                    // points to apwszMachineNames, freed later
                    break;
            }
        }

        // free array
        LocalFree(AltName.rgAltEntry);
    }
    if (NULL != objectGuidOtherName.Value.pbData)
    {
        LocalFree(objectGuidOtherName.Value.pbData);
    }
    if (NULL != upnOtherName.Value.pbData)
    {
        LocalFree(upnOtherName.Value.pbData);
    }
    if (NULL != pRequest)
    {
        if (NULL != apwszMailNames)
        {
            pRequest->_FreeValues(apwszMailNames);
        }
        if (NULL != apwszMachineNames)
        {
            pRequest->_FreeValues(apwszMachineNames);
        }
    }
    VariantClear(&varExtension);
    return(hr);
}


#ifdef DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINTTIMEORPERIOD(pszDesc, pft) \
    policyDbgPrintTimeOrPeriod((pszDesc), (pft))

VOID
policyDbgPrintTimeOrPeriod(
    IN char const *pszDesc,
    IN FILETIME const *pft)
{
    HRESULT hr;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];

    if (0 <= (LONG) pft->dwHighDateTime)
    {
	hr = myGMTFileTimeToWszLocalTime(pft, TRUE, &pwszTime);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    }
    else
    {
	hr = myFileTimePeriodToWszTimePeriod(pft, TRUE, &pwszTime);
	_PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
    }
    if (S_OK != hr)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }
    DBGPRINT((DBG_SS_CERTPOL, "%hs: %ws\n", pszDesc, pwszTime));

//error:
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}
#else // DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINTTIMEORPERIOD(pszDesc, pft)
#endif // DBG_CERTSRV_DEBUG_PRINT


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_ApplyExpirationTime
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_ApplyExpirationTime(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    VARIANT varValue;
    BSTR strNameNotBefore = NULL;
    BSTR strNameNotAfter = NULL;
    SYSTEMTIME SystemTime;
    LARGE_INTEGER ftExpirationPeriod;
    LARGE_INTEGER ftNotAfter;
    LARGE_INTEGER ftNotAfterCalc;
    LARGE_INTEGER ftNotBefore;

    VariantInit(&varValue);

    strNameNotBefore = SysAllocString(wszPROPCERTIFICATENOTBEFOREDATE);
    if (NULL == strNameNotBefore)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strNameNotBefore,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    if (VT_DATE != varValue.vt)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Policy:varValue.vt");
    }

    if (!VariantTimeToSystemTime(varValue.date, &SystemTime))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:VariantTimeToSystemTime");
    }

    if (!SystemTimeToFileTime(&SystemTime, (LPFILETIME)&ftNotBefore))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:SystemTimeToFileTime");
    }

    strNameNotAfter = SysAllocString(wszPROPCERTIFICATENOTAFTERDATE);
    if (NULL == strNameNotAfter)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strNameNotAfter,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    if (VT_DATE != varValue.vt)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Policy:varValue.vt");
    }

    if (!VariantTimeToSystemTime(varValue.date, &SystemTime))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:VariantTimeToSystemTime");
    }

    if (!SystemTimeToFileTime(&SystemTime, (LPFILETIME)&ftNotAfter))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:SystemTimeToFileTime");
    }


    hr = CAGetCertTypeExpiration(m_hCertType, (LPFILETIME)&ftExpirationPeriod, NULL);
    _JumpIfError(hr, error, "Policy:CAGetCertTypeExpiration");

    if (0 > ftExpirationPeriod.QuadPart)
    {
        ftNotAfterCalc.QuadPart = ftNotBefore.QuadPart - ftExpirationPeriod.QuadPart;
    }
    else
    {
        ftNotAfterCalc = ftExpirationPeriod;
    }

    if (ftNotAfterCalc.QuadPart > ftNotAfter.QuadPart)
    {
        ftNotAfterCalc = ftNotAfter;
    }

    if (!FileTimeToSystemTime((FILETIME *) &ftNotAfterCalc, &SystemTime))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:FileTimeToSystemTime");
    }
    if (!SystemTimeToVariantTime(&SystemTime, &varValue.date))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:SystemTimeToVariantTime");
    }

    hr = pServer->SetCertificateProperty(
				wszPROPCERTIFICATENOTAFTERDATE,	// BUGBUG:BSTR
				PROPTYPE_DATE,
				&varValue);
    if (S_OK != hr)
    {
	DBGPRINTTIMEORPERIOD("  Old NotBefore", (FILETIME const *) &ftNotBefore);
	DBGPRINTTIMEORPERIOD("   Old NotAfter", (FILETIME const *) &ftNotAfter);
	DBGPRINTTIMEORPERIOD("Template Period", (FILETIME const *) &ftExpirationPeriod);
	DBGPRINTTIMEORPERIOD("   New NotAfter", (FILETIME const *) &ftNotAfterCalc);
    }
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    VariantClear(&varValue);
    if (NULL != strNameNotBefore)
    {
	SysFreeString(strNameNotBefore);
    }
    if (NULL != strNameNotAfter)
    {
	SysFreeString(strNameNotAfter);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceKeySizePolicy
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceKeySizePolicy(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;

    if (0 != m_dwMinKeyLength)
    {
	LONG KeyLength;

	hr = polGetCertificateLongProperty(
				pServer,
				wszPROPCERTIFICATEPUBLICKEYLENGTH,
				&KeyLength);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCERTIFICATEPUBLICKEYLENGTH);

	if (m_dwMinKeyLength > (DWORD) KeyLength)
	{
	    DBGPRINT((
		DBG_SS_ERROR,
		"Key Length %u, expected minimum %u\n",
		KeyLength,
		m_dwMinKeyLength));

	    hr = CERTSRV_E_KEY_LENGTH;
	    _JumpError(hr, error, "Key too small");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceKeyArchivalPolicy
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceKeyArchivalPolicy(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR str = NULL;

    hr = polGetRequestStringProperty(
			    pServer,
			    wszPROPREQUESTKEYRECOVERYHASHES,
			    &str);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfErrorStr(
		    hr,
		    error,
		    "Policy:polGetRequestStringProperty",
		    wszPROPREQUESTKEYRECOVERYHASHES);
    }
    if (CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL & m_dwPrivateKeyFlags)
    {
	if (S_OK != hr)
	{
	    hr = CERTSRV_E_ARCHIVED_KEY_REQUIRED;
	    _JumpError(hr, error, "missing archived key");
	}
    }
    else
    {
	if (S_OK == hr)
	{
	    hr = CERTSRV_E_ARCHIVED_KEY_UNEXPECTED;
	    _JumpError(hr, error, "unexpected archived key");
	}
    }
    hr = S_OK;

error:
    if (NULL != str)
    {
        SysFreeString(str);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceSymmetricAlgorithms
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceSymmetricAlgorithms(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    VARIANT varExtension;
    BOOL fSetNeeded = FALSE;
    BOOL fAddExtension = FALSE;
    LONG ExtFlags = 0;
    BSTR strCSPProvider = NULL;

    VariantInit(&varExtension);
    if (CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS & m_dwEnrollmentFlags)
    {
        hr = pServer->GetCertificateExtension(
				    TEXT(szOID_RSA_SMIMECapabilities),
				    PROPTYPE_BINARY,
				    &varExtension);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _JumpIfError(hr, error, "Policy:GetCertificateExtension");

	    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	    if (EXTENSION_DISABLE_FLAG & ExtFlags)
	    {
		ExtFlags &= ~EXTENSION_DISABLE_FLAG;
		fSetNeeded = TRUE;
	    }
	}
	else
	{
	    BYTE const *pbSMIME;
	    DWORD cbSMIME;
	    
	    pbSMIME = m_pPolicy->GetSMIME(&cbSMIME);
	    if (0 == (EDITF_ENABLEDEFAULTSMIME & m_pPolicy->GetEditFlags()) ||
		NULL == pbSMIME)
	    {
		hr = CERTSRV_E_SMIME_REQUIRED;
		_JumpError(hr, error, "Policy:GetCertificateExtension");
	    }

	    varExtension.bstrVal = NULL;
	    if (!myConvertWszToBstr(
				&varExtension.bstrVal,
				(WCHAR const *) pbSMIME,
				cbSMIME))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    fSetNeeded = TRUE;
	}
    }
    if (fSetNeeded)
    {
	hr = pServer->SetCertificateExtension(
				TEXT(szOID_RSA_SMIMECapabilities),
				PROPTYPE_BINARY,
				ExtFlags,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }
    hr = S_OK;

error:
    if (NULL != strCSPProvider)
    {
	SysFreeString(strCSPProvider);
    }
    VariantClear(&varExtension);
    return(hr);
}


// Fail the request if all of the following are true:
// 1: the request is for a V2 template
// 2: no signatures are required by the template
// 3: the RequesterName is not the same as the CallerName (enroll-on-behalf-of)


HRESULT
CTemplatePolicy::_EnforceEnrollOnBehalfOfAllowed(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    BSTR strRequester = NULL;
    BSTR strCaller = NULL;
    DWORD cSignatureRequired;

    if (CERTTYPE_SCHEMA_VERSION_2 > m_dwSchemaVersion)
    {
	hr = S_OK;
	goto error;	// skip V1 template
    }

    hr = CAGetCertTypePropertyEx(
			m_hCertType,
			CERTTYPE_PROP_RA_SIGNATURE,
			&cSignatureRequired);
    _PrintIfErrorStr2(
	    hr,
	    "_EnforceEnrollOnBehalfOfAllowed:CAGetCertTypePropertyEx",
	    CERTTYPE_PROP_RA_SIGNATURE,
	    HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
    if (S_OK == hr && 0 != cSignatureRequired)
    {
	hr = S_OK;
	goto error;	// skip when no signatures required
    }

    hr = polGetRequestStringProperty(
			    pServer,
			    wszPROPREQUESTERNAME,
			    &strRequester);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		wszPROPREQUESTERNAME);

    hr = polGetRequestStringProperty(
			    pServer,
			    wszPROPCALLERNAME,
			    &strCaller);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		wszPROPCALLERNAME);

    if (0 != lstrcmpi(strRequester, strCaller))
    {
	hr = CERTSRV_E_BAD_RENEWAL_SUBJECT;
	_JumpError(hr, error, "UPN doesn't match renewal UPN");
    }
    hr = S_OK;		// caller matches requester

error:
    if (NULL != strRequester)
    {
	SysFreeString(strRequester);
    }
    if (NULL != strCaller)
    {
	SysFreeString(strCaller);
    }
    return(hr);
}


HRESULT
CTemplatePolicy::_EnforceMinimumTemplateVersion(
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    DWORD dwRequestTemplateMinimumMajorVersion;
    DWORD dwRequestTemplateMinimumMinorVersion;

    pRequest->GetTemplateVersion(
			&dwRequestTemplateMinimumMajorVersion,
			&dwRequestTemplateMinimumMinorVersion);

    if (m_dwTemplateMajorVersion < dwRequestTemplateMinimumMajorVersion ||
	(m_dwTemplateMajorVersion == dwRequestTemplateMinimumMajorVersion &&
	 m_dwTemplateMinorVersion < dwRequestTemplateMinimumMinorVersion))
    {
	DBGPRINT((
	    DBG_SS_ERROR,
	    "Requested template version %u.%u, Loaded version %u.%u\n",
	    dwRequestTemplateMinimumMajorVersion,
	    dwRequestTemplateMinimumMinorVersion,
	    m_dwTemplateMajorVersion,
	    m_dwTemplateMinorVersion));
	hr = CERTSRV_E_BAD_TEMPLATE_VERSION;
	_JumpError(hr, error, "Policy:_EnforceMinimumTemplateVersion");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
polSplitPolicies(
    IN BSTR strPolicies,
    OUT DWORD *pcPolicies,
    OUT POLICIES **pprgPolicies)
{
    HRESULT hr;
    WCHAR const *pwszT;
    WCHAR *pwszOut;
    WCHAR *pwsz;
    DWORD cPolicies;
    POLICIES *prgPolicies;
    DWORD cObjId;
    WCHAR **prgObjId;
    BOOL fNew;

    *pprgPolicies = NULL;

    pwszT = strPolicies;
    cPolicies = 1;		// plus one per newline separator
    cObjId = 0;
    while (L'\0' != *pwszT)
    {
	int ichar = wcscspn(pwszT, L",\n");
        if (ichar == 0)    // neither of these, look for end-of-string
            ichar = wcslen(pwszT);
        pwszT += ichar;

	switch (*pwszT)
	{
	    case L'\n':
		cPolicies++;	// plus one per newline separator
                pwszT++;        // step over the newline
		break;

	    case L',':
		cObjId++;	// plus one per comma separator
		pwszT++;        // step over the comma
		break;

	    case L'\0':
	    default:
		CSASSERT(L'\0' == *pwszT);
		break;
	}
    }
    cObjId += cPolicies;	// plus one per signature

    prgPolicies = (POLICIES *) LocalAlloc(
				    LMEM_FIXED,
				    cPolicies * sizeof(prgPolicies[0]) +
				    cObjId * sizeof(WCHAR *) +
				    (wcslen(strPolicies) + 1) * sizeof(WCHAR));
    if (NULL == prgPolicies)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    *pprgPolicies = prgPolicies;
    *pcPolicies = cPolicies;

    prgObjId = (WCHAR **) &prgPolicies[cPolicies];
    pwszOut = (WCHAR *) &prgObjId[cObjId];
    wcscpy(pwszOut, strPolicies);

    fNew = TRUE;
    while (L'\0' != *pwszOut)
    {
	if (fNew)
	{
	    prgPolicies->cObjId = 0;
	    prgPolicies->prgObjId = prgObjId;
	}
	prgPolicies->cObjId++;
	*prgObjId = pwszOut;
        prgObjId++; // next array entry

	fNew = FALSE;

	int ichar = wcscspn(pwszOut , L",\n");
        if (ichar == 0)    // neither of these, look for end-of-string
            ichar = wcslen(pwszOut);
        pwszOut  += ichar;

	switch (*pwszOut)
	{
	    case L'\n':
		prgPolicies++;
		fNew = TRUE;
		// FALLTHROUGH

	    case L',':
		*pwszOut++ = L'\0';
		break;

	    case L'\0':
	    default:
		CSASSERT(L'\0' == *pwszOut);
		break;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CTemplatePolicy::_LoadPolicies(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropNameCertType,
    IN WCHAR const *pwszPropNameRequest,
    OUT DWORD *pcTemplatePolicies,
    OUT WCHAR ***papwszTemplatePolicies,	// from the cert template
    OUT DWORD *pcSignaturePolicies,
    OUT POLICIES **pprgSignaturePolicies)	// from the signing cert(s)
{
    HRESULT hr;
    BSTR strSignaturePolicies = NULL;
    DWORD cTemplatePolicies;
    WCHAR **apwsz;

    *pcTemplatePolicies = 0;
    *papwszTemplatePolicies = NULL;
    *pcSignaturePolicies = 0;
    *pprgSignaturePolicies = NULL;

    hr = polCAGetCertTypeProperty(
			    m_hCertType,
			    pwszPropNameCertType,
			    papwszTemplatePolicies);
    _PrintIfErrorStr(
	    hr,
	    "CTemplatePolicy:_LoadPolicies:polCAGetCertTypeProperty",
	    pwszPropNameCertType);
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:_LoadPolicies:polCAGetCertTypeProperty",
		pwszPropNameCertType);
    }

    cTemplatePolicies = 0;
    apwsz = *papwszTemplatePolicies;
    if (NULL != apwsz)
    {
	while (NULL != *apwsz++)
	{
	    cTemplatePolicies++;
	}
    }
    *pcTemplatePolicies = cTemplatePolicies;

    hr = polGetRequestStringProperty(
			    pServer,
			    pwszPropNameRequest,
			    &strSignaturePolicies);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = CERTSRV_E_SIGNATURE_POLICY_REQUIRED;
    }
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		pwszPropNameRequest);

    hr = polSplitPolicies(
		    strSignaturePolicies,
		    pcSignaturePolicies,
		    pprgSignaturePolicies);
    _JumpIfError(hr, error, "Policy:polSplitPolicies");

error:
    if (NULL != strSignaturePolicies)
    {
	SysFreeString(strSignaturePolicies);
    }
    return(hr);
}


VOID
CTemplatePolicy::_FreePolicies(
    IN WCHAR **apwszTemplatePolicies,
    IN POLICIES *prgPolicies)
{
    if (NULL != apwszTemplatePolicies)
    {
        CAFreeCertTypeProperty(m_hCertType, apwszTemplatePolicies);
    }
    if (NULL != prgPolicies)
    {
	LocalFree(prgPolicies);
    }
}


HRESULT
CTemplatePolicy::_EnforceReenrollment(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    VARIANT var;
    CERT_CONTEXT const *pOldCert = NULL;
    CERT_EXTENSION const *pExt;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    WCHAR *pwszObjId = NULL;
    CERT_ALT_NAME_INFO *pAltName = NULL;
    CERT_NAME_VALUE *pName = NULL;
    DWORD cb;
    DWORD i;

    VariantInit(&var);

    if (NULL == m_pwszTemplateObjId)
    {
	hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
	_JumpError(hr, error, "Policy:No template ObjId");
    }
    hr = polGetProperty(
		pServer,
		TRUE,		// fRequest
		PROPTYPE_BINARY,
		wszPROPREQUESTRAWOLDCERTIFICATE,
		&var);
    _JumpIfError(hr, error, "Policy:polGetProperty");

    if (VT_BSTR != var.vt || NULL == var.bstrVal)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    var.bstrVal;

    pOldCert = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				(BYTE *) var.bstrVal,
				SysStringByteLen(var.bstrVal));
    if (NULL == pOldCert)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pExt = CertFindExtension(
			szOID_CERTIFICATE_TEMPLATE,
			pOldCert->pCertInfo->cExtension,
			pOldCert->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpError(hr, error, "CertFindExtension(Template)");
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_CERTIFICATE_TEMPLATE,
		pExt->Value.pbData,
		pExt->Value.cbData,
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pTemplate,
		&cb))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }
    if (!myConvertSzToWsz(&pwszObjId, pTemplate->pszObjId, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertSzToWsz");
    }
    if (0 != lstrcmp(pwszObjId, m_pwszTemplateObjId))
    {
	hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
	_JumpError(hr, error, "Policy:different cert type");
    }

    if (NULL == pRequest->m_pwszUPN)
    {
	hr = E_POINTER;		// We should never get this
	_JumpError(hr, error, "Policy:NULL UPN");
    }
    pExt = CertFindExtension(
			szOID_SUBJECT_ALT_NAME2,
			pOldCert->pCertInfo->cExtension,
			pOldCert->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpError(hr, error, "CertFindExtension(SubjectAltName)");
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		pExt->Value.pbData,
		pExt->Value.cbData,
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pAltName,
		&cb))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }
    for (i = 0; i < pAltName->cAltEntry; i++)
    {
	CERT_ALT_NAME_ENTRY *pAltEntry = &pAltName->rgAltEntry[i];

	if (CERT_ALT_NAME_OTHER_NAME != pAltEntry->dwAltNameChoice)
	{
	    continue;
	}
	if (0 != strcmp(
		    pAltEntry->pOtherName->pszObjId,
		    szOID_NT_PRINCIPAL_NAME))
	{
	    continue;
	}
	if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    pAltEntry->pOtherName->Value.pbData,
		    pAltEntry->pOtherName->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pName,
		    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myDecodeObject");
	}
	if (CERT_RDN_UTF8_STRING != pName->dwValueType ||
	    0 != lstrcmpi(
		    pRequest->m_pwszUPN,
		    (WCHAR const *) pName->Value.pbData))
	{
	    hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	    _JumpError(hr, error, "UPN doesn't match renewal UPN");
	}
    }
    if (NULL == pName)
    {
	hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	_JumpError(hr, error, "missing renewal UPN");
    }
    hr = S_OK;

error:
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pAltName)
    {
	LocalFree(pAltName);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    if (NULL != pTemplate)
    {
	LocalFree(pTemplate);
    }
    if (NULL != pOldCert)
    {
	CertFreeCertificateContext(pOldCert);
    }
    VariantClear(&var);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceSignaturePolicy
//
// Fetch required lists of Issuance and Application ObjIds from the template.
// Fetch signing certificates' lists of Issuance and Application ObjIds from
// the cert server.
//
// Reject signatures that don't include all of the required Application ObjIds.
// Reject signatures that don't include at least one of the required Issuance
// ObjIds.
//
// The count of accepted signatures must be equal to or greater than the
// template-specified required signature count.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceSignaturePolicy(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    DWORD cSignatureRequired;
    DWORD cSignatureAccepted;
    DWORD cSignatureRejected;
    DWORD *prgdwRefCount = NULL;
    WCHAR **apwsz;
    DWORD i;

    DWORD cTemplateIssuance;
    WCHAR **apwszTemplateIssuance = NULL;
    DWORD cSignatureIssuance;
    POLICIES *prgSignatureIssuance = NULL;

    DWORD cTemplateApplication;
    WCHAR **apwszTemplateApplication = NULL;
    DWORD cSignatureApplication;
    POLICIES *prgSignatureApplication = NULL;

    hr = CAGetCertTypePropertyEx(
			m_hCertType,
			CERTTYPE_PROP_RA_SIGNATURE,
			&cSignatureRequired);
    _PrintIfErrorStr2(
	    hr,
	    "CTemplatePolicy:_EnforceSignaturePolicy:CAGetCertTypePropertyEx",
	    CERTTYPE_PROP_RA_SIGNATURE,
	    HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    goto error;
	}
	cSignatureRequired = 0;
    }
    if (0 == cSignatureRequired)
    {
	hr = S_OK;
	goto error;
    }
    hr = _LoadPolicies(
		pServer,
		CERTTYPE_PROP_RA_POLICY,
		wszPROPSIGNERPOLICIES,
		&cTemplateIssuance,	// from the cert template
		&apwszTemplateIssuance,
		&cSignatureIssuance,	// from the signing cert(s)
		&prgSignatureIssuance);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:_LoadPolicies",
		CERTTYPE_PROP_RA_POLICY);

    hr = _LoadPolicies(
		pServer,
		CERTTYPE_PROP_RA_APPLICATION_POLICY,
		wszPROPSIGNERAPPLICATIONPOLICIES,
		&cTemplateApplication,	// from the cert template
		&apwszTemplateApplication,
		&cSignatureApplication,	// from the signing cert(s)
		&prgSignatureApplication);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:_LoadPolicies",
		CERTTYPE_PROP_RA_APPLICATION_POLICY);

    if (0 == cTemplateIssuance && 0 == cTemplateApplication)
    {
	hr = CERTSRV_E_TEMPLATE_POLICY_REQUIRED;
	_JumpIfError(hr, error, "no template policies");
    }

    if (cSignatureIssuance != cSignatureApplication)
    {
	hr = NTE_BAD_SIGNATURE;		// must be an internal server problem
	_JumpError(hr, error, "Policy:bad request policies counts");
    }
    if (0 != cTemplateIssuance)
    {
	prgdwRefCount = (DWORD *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cTemplateIssuance * sizeof(DWORD));
	if (NULL == prgdwRefCount)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
    }

    // Loop through each signature's Application and Issuance Policy OIDs

    cSignatureAccepted = 0;
    cSignatureRejected = 0;
    for (i = 0; i < cSignatureIssuance; i++)
    {
	BOOL fReject = FALSE;
	WCHAR **prgObjId;
	DWORD cObjId;
	DWORD j;
	DWORD idx;

	// This signature must include ALL required Application Policy OIDs
	// If no Application Policy OIDs are required, all signatures are OK.

	prgObjId = prgSignatureApplication[i].prgObjId;
	cObjId = prgSignatureApplication[i].cObjId;
	for (j = 0; j < cTemplateApplication; j++)
	{
	    idx = polFindObjIdInList(
				apwszTemplateApplication[j],
				cObjId,
				prgObjId);
	    if (MAXDWORD == idx)
	    {
		fReject = TRUE;
		_PrintErrorStr(
			hr,
			"Policy:missing Application Policy",
			apwszTemplateApplication[i]);
	    }
	}
	if (!fReject)
	{
	    DWORD cFound = 0;

	    // For each Issuance Policy OID in this signature that also exists
	    // in the required Issuance Policy OIDs, increment the ref count to
	    // show the OID was referenced by an accepted signature.
	    // Reject the signature if it doesn't reference any required OID.

	    prgObjId = prgSignatureIssuance[i].prgObjId;
	    cObjId = prgSignatureIssuance[i].cObjId;
	    for (j = 0; j < cObjId; j++)
	    {
		idx = polFindObjIdInList(
				    prgObjId[j],
				    cTemplateIssuance,
				    apwszTemplateIssuance);
		if (MAXDWORD != idx)
		{
		    prgdwRefCount[idx]++;
		    cFound++;
		}
	    }

	    // If no Issuance Policy OIDs are required, all signatures are OK.

	    if (0 != cTemplateIssuance && 0 == cFound)
	    {
		fReject = TRUE;
	    }
	}
	if (fReject)
	{
	    cSignatureRejected++;
	}
	else
	{
	    cSignatureAccepted++;
	}
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    "Sig[%u]: %ws\n",
	    i,
	    fReject? L"Rejected" : L"Accepted"));
    }

    hr = S_OK;
    if (cSignatureAccepted < cSignatureRequired)
    {
	hr = CERTSRV_E_SIGNATURE_COUNT;
	if (0 != cSignatureRejected)
	{
	    hr = CERTSRV_E_SIGNATURE_REJECTED;
	}
	_PrintError(hr, "Policy:not enough signatures");
    }
    DBGPRINT((
	S_OK != hr? DBG_SS_CERTPOLI : DBG_SS_CERTPOL,
	"Signatures: %u needed, %u accepted\n",
	cSignatureRequired,
	cSignatureAccepted));
    for (i = 0; i < cTemplateIssuance; i++)
    {
	if (0 == prgdwRefCount[i])
	{
	    hr = CERTSRV_E_ISSUANCE_POLICY_REQUIRED;
	    _PrintErrorStr(
		    hr,
		    "Policy:missing Issuance Policy",
		    apwszTemplateIssuance[i]);
	}
    }
    _JumpIfError(hr, error, "Policy:missing Policy/Signature");

error:
    _FreePolicies(apwszTemplateIssuance, prgSignatureIssuance);
    _FreePolicies(apwszTemplateApplication, prgSignatureApplication);
    if (NULL != prgdwRefCount)
    {
        LocalFree(prgdwRefCount);
    }
    return(hr);
}


HRESULT
CTemplatePolicy::GetFlags(
    IN DWORD dwOption,
    OUT DWORD *pdwFlags)
{
    HRESULT hr;

    switch (dwOption)
    {
	case CERTTYPE_ENROLLMENT_FLAG:
	    *pdwFlags = m_dwEnrollmentFlags;
	    break;

	case CERTTYPE_SUBJECT_NAME_FLAG:
	    *pdwFlags = m_dwSubjectNameFlags;
	    break;

	case CERTTYPE_PRIVATE_KEY_FLAG:
	    *pdwFlags = m_dwPrivateKeyFlags;
	    break;

	case CERTTYPE_GENERAL_FLAG:
	    *pdwFlags = m_dwGeneralFlags;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:bad dwOption");

    }
    hr = S_OK;

error:
    return(hr);
}


// IsRequestedTemplate - determine if the request specifies this template

BOOL
CTemplatePolicy::IsRequestedTemplate(
    OPTIONAL IN WCHAR const *pwszTemplateName,
    OPTIONAL IN WCHAR const *pwszTemplateObjId)
{
    HRESULT hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;

    if (NULL != pwszTemplateName)
    {
	if ((NULL != m_pwszTemplateName &&
	     0 == lstrcmpi(m_pwszTemplateName, pwszTemplateName)) ||
	    (NULL != m_pwszTemplateObjId &&
	     0 == lstrcmp(m_pwszTemplateObjId, pwszTemplateName)))
	{
	    hr = S_OK;
	}
    }
    if (S_OK != hr && NULL != pwszTemplateObjId)
    {
	if ((NULL != m_pwszTemplateName &&
	     0 == lstrcmpi(m_pwszTemplateName, pwszTemplateObjId)) ||
	    (NULL != m_pwszTemplateObjId &&
	     0 == lstrcmp(m_pwszTemplateObjId, pwszTemplateObjId)))
	{
	    hr = S_OK;
	}
    }
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:wrong CertType",
		m_pwszTemplateName,
		hr);

error:
    return(S_OK == hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\cemmchlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       csmmchlp.h
//
//--------------------------------------------------------------------------

#define CERTMMC_HELPFILENAME L"Certmmc.hlp"

#define	IDH_CM_MODULE_LIST	70008125
#define	IDH_CRL_COMBO_UNITS	70008176
#define	IDH_CRL_DISABLE_PUBLISH	70008178
#define	IDH_CRL_EDIT_LASTUPDATE	70008177
#define	IDH_CRL_EDIT_NUMUNITS	70008175
#define	IDH_CRL_VIEW_CRL	70008179
#define	IDH_DQ_ADD_RESTRICTION	70008201
#define	IDH_DQ_DELETE_RESTRICTION	70008202
#define	IDH_DQ_QUERY_LIST	70008200
#define	IDH_DQ_RESET_BUTTON	70008203
#define	IDH_ED_COMBO_REASON	70008250
#define	IDH_NR_EDIT_NEWQUERY_FIELD	70008225
#define	IDH_NR_EDIT_NEWQUERY_OPERATION	70008226
#define	IDH_NR_EDIT_NEWQUERY_VALUE	70008227
#define	IDH_NR_DATEPICKER_NEWQUERY	70008228
#define IDH_NR_TIMEPICKER_NEWQUERY	70008229
#define	IDH_PP_BUTTON_DN	70008102
#define	IDH_PP_BUTTON_UP	70008101
#define	IDH_PP_CHECK1	70008075
#define	IDH_PP_EDIT_DATABASE_LOC	70008077
#define	IDH_PP_EDIT_LOG_LOC	70008078
#define	IDH_PP_EDIT_SHAREDFOLDER	70008076
#define	IDH_PP_LIST_AVAILABLE	70008100
#define	IDH_PP1_CANAME	70008000
#define	IDH_PP1_CSP_NAME	70008003
#define	IDH_PP1_DESCRIPTION	70008001
#define	IDH_PP1_HASHALG	70008004
#define	IDH_PP1_VIEW_CERT	70008002
#define	IDH_PP2_ACTIVE_MODULE	70008210
#define	IDH_PP2_CONFIGURE	70008209
#define	IDH_PP2_COPYRIGHT	70008028
#define	IDH_PP2_DESCRIPTION	70008026
#define	IDH_PP2_MODULENAME	70008025
#define	IDH_PP2_VERSION	70008027
#define	IDH_PP3_ACTIVE_MODULE	70008058
#define	IDH_PP3_ADDBUTTON1	70008051
#define	IDH_PP3_CONFIGURE	70008057
#define	IDH_PP3_COPYRIGHT	70008056
#define	IDH_PP3_DESCRIPTION	70008054
#define	IDH_PP3_EDIT1	70008050
#define	IDH_PP3_MODULENAME	70008053
#define	IDH_PP3_REMOVEBUTTON4	70008052
#define	IDH_PP3_VERSION	70008055
#define	IDH_RESTORE_DEFOK2	70008103
#define	IDH_ADDURL_EDITURL	70008400
#define	IDH_CRL_ADD	70008426
#define	IDH_CRL_LIST	70008425
#define	IDH_CRL_REMOVE	70008427
#define	IDH_EXIT_CHECK_FILE	70008451
#define	IDH_EXIT2_CHECK_DS	70008450
#define	IDH_DA_RADIO_PENDFIRST	70008500
#define	IDH_DA_RADIO_ISSUE	70008501
#define	IDH_POL2_ADD_AIA	70008529
#define	IDH_POL2_ADD_CRL	70008526
#define	IDH_POL2_AIA_LIST	70008528
#define	IDH_POL2_CRL_LIST	70008525
#define	IDH_POL2_REMOVE_AIA	70008530
#define	IDH_POL2_REMOVE_CRL	70008527
#define IDH_RADIO_REUSEKEY	70008541
#define IDH_RADIO_NEWKEY	70008542

#if defined (_CERTMMC_)

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE1[]=
{
	IDC_HASHALG,IDH_PP1_HASHALG,
	IDC_CANAME,IDH_PP1_CANAME,
	IDC_DESCRIPTION,IDH_PP1_DESCRIPTION,
	IDC_VIEW_CERT,IDH_PP1_VIEW_CERT,
	IDC_CSP_NAME,IDH_PP1_CSP_NAME,
	0, 0
};


const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE2[]=
{
	IDC_DESCRIPTION,IDH_PP2_DESCRIPTION,
	IDC_CONFIGURE,IDH_PP2_CONFIGURE,
	IDC_MODULENAME,IDH_PP2_MODULENAME,
	IDC_COPYRIGHT,IDH_PP2_COPYRIGHT,
	IDC_VERSION,IDH_PP2_VERSION,
	IDC_ACTIVE_MODULE,IDH_PP2_ACTIVE_MODULE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE3[]=
{
	IDC_ACTIVE_MODULE,IDH_PP3_ACTIVE_MODULE,
	IDC_EDIT1,IDH_PP3_EDIT1,
	IDC_BUTTON1,IDH_PP3_ADDBUTTON1,
	IDC_DESCRIPTION,IDH_PP3_DESCRIPTION,
	IDC_VERSION,IDH_PP3_VERSION,
	IDC_COPYRIGHT,IDH_PP3_COPYRIGHT,
	IDC_CONFIGURE,IDH_PP3_CONFIGURE,
	IDC_MODULENAME,IDH_PP3_MODULENAME,
	IDC_BUTTON4,IDH_PP3_REMOVEBUTTON4,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE5[]=
{
	IDC_CHECK1,IDH_PP_CHECK1,
	IDC_EDIT_SHAREDFOLDER,IDH_PP_EDIT_SHAREDFOLDER,
	IDC_EDIT_LOG_LOC,IDH_PP_EDIT_LOG_LOC,
	IDC_EDIT_DATABASE_LOC,IDH_PP_EDIT_DATABASE_LOC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CHOOSE_COLUMNS[]=
{
	IDC_LIST_AVAILABLE,IDH_PP_LIST_AVAILABLE,
	IDC_BUTTON_UP,IDH_PP_BUTTON_UP,
	IDC_BUTTON_DN,IDH_PP_BUTTON_DN,
	IDOK2,IDH_RESTORE_DEFOK2,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CHOOSE_MODULE[]=
{
	IDC_MODULE_LIST,IDH_CM_MODULE_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CRL_PROPPAGE[]=
{
	IDC_EDIT_NUMUNITS,IDH_CRL_EDIT_NUMUNITS,
	IDC_COMBO_UNITS,IDH_CRL_COMBO_UNITS,
	IDC_EDIT_LASTUPDATE,IDH_CRL_EDIT_LASTUPDATE,
	IDC_DISABLE_PUBLISH,IDH_CRL_DISABLE_PUBLISH,
	IDC_VIEW_CRL,IDH_CRL_VIEW_CRL,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DEFINE_QUERY[]=
{
	IDC_RESET_BUTTON,IDH_DQ_RESET_BUTTON,
	IDC_QUERY_LIST,IDH_DQ_QUERY_LIST,
	IDC_ADD_RESTRICTION,IDH_DQ_ADD_RESTRICTION,
	IDC_DELETE_RESTRICTION,IDH_DQ_DELETE_RESTRICTION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_NEW_RESTRICTION[]=
{
	IDC_EDIT_NEWQUERY_VALUE,IDH_NR_EDIT_NEWQUERY_VALUE,
	IDC_EDIT_NEWQUERY_FIELD,IDH_NR_EDIT_NEWQUERY_FIELD,
	IDC_EDIT_NEWQUERY_OPERATION,IDH_NR_EDIT_NEWQUERY_OPERATION,
	IDC_DATEPICKER_NEWQUERY, IDH_NR_DATEPICKER_NEWQUERY,
	IDC_TIMEPICKER_NEWQUERY, IDH_NR_TIMEPICKER_NEWQUERY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REVOCATION_DIALOG[]=
{
	IDC_COMBO_REASON,IDH_ED_COMBO_REASON,
	0, 0
};


const DWORD g_aHelpIDs_IDD_RENEW_REUSEKEYS[]=
{
	IDC_RADIO_REUSEKEY,IDH_RADIO_REUSEKEY,
	IDC_RADIO_NEWKEY,IDH_RADIO_NEWKEY,
	0,0
};

#endif // #if defined (_CERTMMC_)


#if defined (_CERTEXIT_)

//certexit.rc
const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG1[]=
{
	IDC_REMOVE_CRL, IDH_CRL_REMOVE,
	IDC_ADD_CRL, IDH_CRL_ADD,
	IDC_CRL_LIST, IDH_CRL_LIST,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG2[]=
{
	IDC_CHECK_FILE, IDH_EXIT_CHECK_FILE,
	IDC_CHECK_DS, IDH_EXIT2_CHECK_DS,
	0,0
};

#endif // #if defined (_CERTEXIT_)


#if defined (_CERTPDEF_)

//certpent.rc
const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	0,0
};

const DWORD g_aHelpIDs_IDD_POLICYPG1[]=
{
	IDC_RADIO_ISSUE,IDH_DA_RADIO_ISSUE,
	IDC_RADIO_PENDFIRST,IDH_DA_RADIO_PENDFIRST,
	0,0
};


const DWORD g_aHelpIDs_IDD_POLICYPG2[]=
{
	IDC_REMOVE_AIA,IDH_POL2_REMOVE_AIA,
	IDC_ADD_AIA,IDH_POL2_ADD_AIA,
	IDC_AIA_LIST,IDH_POL2_AIA_LIST,
	IDC_REMOVE_CRL,IDH_POL2_REMOVE_CRL,
	IDC_ADD_CRL,IDH_POL2_ADD_CRL,
	IDC_CRL_LIST,IDH_POL2_CRL_LIST,
	0,0
};

#endif // #if defined (_CERTPDEF_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\iisver.h ===
//
// Apps' rc files should look like this:
//
/**
#include "windows.h"
#include "ntverp.h"

#define VER_FILEDESCRIPTION_STR         "File Description"
#define VER_INTERNALNAME_STR            "Internal Name"
#define VER_ORIGINALFILENAME_STR        "Original Name"
#define VER_FILETYPE                    VFT_DLL

#include "iisver.h"
#include "common.ver"

**/
//
// Apps may also define, in the same place as the other defines, above:
// VER_FILESUBTYPE
// VER_IISPRODUCTNAME_STR
// VER_IISMAJORVERSION
// VER_IISMINORVERSION
// VER_IISPRODUCTVERSION_STR
// VER_IISPRODUCTVERSION
// VER_IISPRODUCTBUILD
//

#ifndef VER_FILEDESCRIPTION_STR
#define VER_FILEDESCRIPTION_STR     "IIS Executable"
#endif

#ifndef VER_INTERNALNAME_STR
#define VER_INTERNALNAME_STR        "IISFile.exe"
#endif

#ifndef VER_ORIGINALFILENAME_STR
#define VER_ORIGINALFILENAME_STR    VER_INTERNALNAME_STR
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifndef VER_IISPRODUCTNAME_STR
#define VER_IISPRODUCTNAME_STR      "Internet Information Services"
#endif

#define VER_PRODUCTNAME_STR         VER_IISPRODUCTNAME_STR

#ifndef VER_IISMAJORVERSION
#define VER_IISMAJORVERSION         5
#endif

#ifndef VER_IISMINORVERSION
#define VER_IISMINORVERSION         00
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifndef VER_IISPRODUCTVERSION_STR
#define VER_IISPRODUCTVERSION_STR      "5.00.0984"
#endif

#define VER_PRODUCTVERSION_STR      VER_IISPRODUCTVERSION_STR

//
// VER_PRODUCTBUILD is defined by ntverp.h as the nt build number
//

#ifndef VER_PRODUCTBUILD
#define VER_PRODUCTBUILD            0984
#endif

#ifndef VER_IISPRODUCTBUILD
#define VER_IISPRODUCTBUILD         VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifndef VER_IISPRODUCTVERSION
#define VER_IISPRODUCTVERSION          VER_IISMAJORVERSION,VER_IISMINORVERSION,VER_IISPRODUCTBUILD,1
#endif

#define VER_PRODUCTVERSION          VER_IISPRODUCTVERSION

#ifndef VER_FILEVERSION
#define VER_FILEVERSION             VER_PRODUCTVERSION
#endif

#ifndef VER_FILETYPE
#define VER_FILETYPE                VFT_DLL
#endif

#ifndef VER_FILESUBTYPE
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\kmsattr.h ===
/*
 * kmsattr.h
 *
 * constants shared between KMServer.exe and ExPolicy.dll
 *
 * Owner : Greg Kramer (gregkr)
 *
 * Copyright 1986-1997 Microsoft Corporation. All Rights Reserved.
 *
 */

#ifndef _KMSATTR_H_
#define _KMSATTR_H_

// syntax of Submit::Attributes is
//      name:value\n
// '-' and ' ' are stripped from name.
// leading and trailing whitespace stripped from name and from value.

const   WCHAR   k_wszSubjAltNameRFC822  [] = L"SubjAltNameRFC822";
const   WCHAR   k_wszSubjAltNameDisplay [] = L"SubjAltNameDisplay";
const   WCHAR   k_wszKeyUsage           [] = L"KeyUsage";
const   WCHAR   k_wszKMServerName       [] = L"KMServerName";

// count of attributes sent from KMServer to ExPolicy :
// SubjAltNameRFC822, SubjAltNameDisplay, KeyUsage, and KMServerName
const   ULONG   k_cAttrNames            = 4;

const   WCHAR   k_wchTerminateName      = L':';
const   WCHAR   k_wchTerminateValue     = L'\n';

const   WCHAR   k_wszUsageSealing       [] = L"1";
const   WCHAR   k_wszUsageSigning       [] = L"2";
const   ULONG   k_cchmaxUsage           = 1;    // cch of longest value

const   ULONG   k_cchNamesAndTerminaters =
    (sizeof(k_wszSubjAltNameRFC822)  / sizeof(WCHAR) ) - 1 +
    (sizeof(k_wszSubjAltNameDisplay) / sizeof(WCHAR) ) - 1 +
    (sizeof(k_wszKeyUsage)           / sizeof(WCHAR) ) - 1 +
    (sizeof(k_wszKMServerName)       / sizeof(WCHAR) ) - 1 +
    k_cAttrNames +  // name terminaters
    k_cAttrNames;   // value terminaters
    // don't include string terminaters

const   WCHAR   k_wszSubjectAltName     [] = L"SubjectAltName";
const   WCHAR   k_wszSubjectAltName2    [] = L"SubjectAltName2";
const   WCHAR   k_wszIssuerAltName      [] = L"IssuerAltName";

const   WCHAR   k_wszSpecialAttribute   [] = L"Special";

const   ULONG   k_cchSpecialAttribute   =
    (sizeof(k_wszSpecialAttribute)   / sizeof(WCHAR) ) - 1;

#endif // ! _KMSATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\exver.h ===
#include <ntverp.h>
#include "iisver.h"

//#define VER_IISMAJORVERSION	5

#ifdef VER_IISMINORVERSION
#undef VER_IISMINORVERSION
#endif
#define VER_IISMINORVERSION	5

#ifdef VER_IISPRODUCTBUILD
#undef VER_IISPRODUCTBUILD
#endif
#define VER_IISPRODUCTBUILD	2232

//
// Undo IIS's definitions and use our own
//
#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif
#define VER_PRODUCTNAME_STR			"Microsoft(R) Internet Services"

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#ifndef rmj
#define rmj VER_IISMAJORVERSION
#endif // !rmj 
#ifndef rmn
#define rmn VER_IISMINORVERSION
#endif // !rmn 
#define rmm VER_IISPRODUCTBUILD
#define rup 1
#define szVerName ""
#define szVerUser "_mpubld"


#ifdef MAC
#ifndef _rmacmaj
#define _rmacmaj 0x6
#endif
#ifndef _rmacmin
#define _rmacmin 0x
#endif
#ifndef _rmacint
#define _rmacint 0x
#endif
#ifndef _rmactype
#define _rmactype 
#endif
#ifndef _rmacstr
#define _rmacstr "6.0"
#endif
#endif //MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\expolicy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        expolicy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "policy.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertPolicyExchange, CCertPolicyExchange)
    OBJECT_ENTRY(CLSID_CCertManagePolicyModuleExchange, CCertManagePolicyModuleExchange)
END_OBJECT_MAP()

HINSTANCE g_hInstance = NULL;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    g_hInstance = hInstance;
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(size_t cb)
{
    return(LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb));
}


void __RPC_USER
MIDL_user_free(void __RPC_FAR *pb)
{
    LocalFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\listvw.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       listvw.cpp
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <commctrl.h>
#include <assert.h>

#include "celib.h"
#include "listvw.h"

extern HINSTANCE g_hInstance;

typedef struct _DISPLAYSTRING_EXPANSION
{
   LPCWSTR szContractedToken;
   LPCWSTR szExpansionString;
} DISPLAYSTRING_EXPANSION, *PDISPLAYSTRING_EXPANSION;

DISPLAYSTRING_EXPANSION displayStrings[] =
{
    { wszFCSAPARM_SERVERDNSNAME, L"%SERVER_DNS_NAME%"},
    { wszFCSAPARM_SERVERSHORTNAME, L"%SERVER_SHORT_NAME%"},
    { wszFCSAPARM_SANITIZEDCANAME, L"%CA_NAME%"},
    { wszFCSAPARM_CERTFILENAMESUFFIX, L"%CERT_SUFFIX%"},
    { wszFCSAPARM_DOMAINDN, L"%DOMAIN_NAME%"},
    { wszFCSAPARM_CONFIGDN, L"%CONFIG_NAME%"},
    { wszFCSAPARM_SANITIZEDCANAMEHASH, L"%CA_NAME_HASH%"},
    { wszFCSAPARM_CRLFILENAMESUFFIX, L"%CRL_SUFFIX%"},
};

DISPLAYSTRING_EXPANSION escapedStrings[] =
{
    { L"%9", L"%%"},
};




HRESULT ValidateTokens(
    IN OUT LPWSTR szURL,
    OUT DWORD* pchBadBegin,
    OUT DWORD* pchBadEnd)
{
    HRESULT hr = S_FALSE;
    int i;
    LPWSTR pszMatch;
    LPWSTR pszFound = szURL;

    WCHAR rgszToken[MAX_PATH];

    *pchBadBegin = -1;
    *pchBadEnd = -1;

    // look for escape token open marker
    while(NULL != (pszFound = wcschr(pszFound, L'%')))
    {
        pszMatch = wcschr(&pszFound[1], L'%'); // look for closing marker
        if (pszMatch == NULL)
            goto Ret;

        DWORD dwChars = SAFE_SUBTRACT_POINTERS(pszMatch, pszFound) +1;   // dwChars is chars including markers
        if (dwChars == 2)
            goto NextMatch;   // %% is valid escape sequence
        
        if (dwChars > MAX_PATH)
            goto Ret;   // invalid escape token!

        // isolate the token
        CopyMemory(rgszToken, pszFound, dwChars * sizeof(WCHAR));
        rgszToken[dwChars] = L'\0';

        for (i=0; i<ARRAYSIZE(displayStrings); i++)
        {
            if (0 == _wcsicmp(rgszToken, displayStrings[i].szExpansionString))
            {
                // copy from displayStrings -- these are guaranteed to be properly uppercased
                CopyMemory(pszFound, displayStrings[i].szExpansionString, dwChars * sizeof(WCHAR));
                goto NextMatch;
            }
        }
        
        // if we get here, we found no match
        goto Ret;

NextMatch:
        pszFound = ++pszMatch;
    }

    hr = S_OK;
Ret:
    
    if (hr != S_OK)
    {
        *pchBadBegin = SAFE_SUBTRACT_POINTERS(pszFound, szURL); // offset to first incorrect %

        if (pszMatch)
            *pchBadEnd = SAFE_SUBTRACT_POINTERS(pszMatch, szURL) + 1; // offset past final incorrect %
    }
    
    return hr;
}


HRESULT 
ExpandDisplayString(
     IN LPCWSTR szContractedString,
     OUT LPWSTR* ppszDisplayString)
{
    HRESULT hr;
    DWORD dwChars;
    int i, iescapedStrings;
    LPWSTR pszTempContracted = NULL;
    LPWSTR pszFound;

    // account for %% escaping in contracted string --
    // replace "%%" with %9, let FormatString expand to "%%"
    pszTempContracted = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szContractedString)+1)*sizeof(WCHAR));
    if (pszTempContracted == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }
    wcscpy(pszTempContracted, szContractedString);

    pszFound = wcsstr(pszTempContracted, L"%%");
    while(pszFound)
    {
        CopyMemory(pszFound, escapedStrings[0].szContractedToken, wcslen(escapedStrings[0].szContractedToken)*sizeof(WCHAR));
        pszFound = wcsstr(pszFound, L"%%");
    }


    LPCWSTR args[ARRAYSIZE(displayStrings)+ARRAYSIZE(escapedStrings)];
    for (i=0; i<ARRAYSIZE(displayStrings); i++)
    {
        args[i] = displayStrings[i].szExpansionString;
    }
    // and tell FormatString to expand %9 to %%
    for (iescapedStrings=0; iescapedStrings<ARRAYSIZE(escapedStrings); iescapedStrings++)
    {
        args[i+iescapedStrings] = escapedStrings[iescapedStrings].szExpansionString;
    }


    dwChars = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
        pszTempContracted,
        0, //msgid
        0, //langid
        (LPWSTR)ppszDisplayString,
        1,  // minimum chars to alloc
        (va_list *)args);

    if (dwChars == 0)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }

    hr = S_OK;
Ret:
    if (pszTempContracted)
        LocalFree(pszTempContracted);

    return hr;
}

HRESULT
ContractDisplayString(
     IN LPCWSTR szDisplayString,
     OUT LPWSTR* ppContractedString)
{
    HRESULT hr;
    int i;

    *ppContractedString = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szDisplayString)+1) * sizeof(WCHAR));
    if (*ppContractedString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    wcscpy(*ppContractedString, szDisplayString);

    for (i=0; i<ARRAYSIZE(displayStrings); i++)
    {
        DWORD chContractedToken, chExpansionString;

        LPWSTR pszFound = wcsstr(*ppContractedString, displayStrings[i].szExpansionString);
        while(pszFound)
        {
            // calc commonly used values
            chContractedToken = wcslen(displayStrings[i].szContractedToken);
            chExpansionString = wcslen(displayStrings[i].szExpansionString);

            // replace with token
            CopyMemory(pszFound, displayStrings[i].szContractedToken, chContractedToken*sizeof(WCHAR));

            // slide rest of string left
            MoveMemory(
                &pszFound[chContractedToken],         // destination
                &pszFound[chExpansionString],         // source
                (wcslen(&pszFound[chExpansionString])+1) *sizeof(WCHAR) );

            // step Found over insertion
            pszFound += chContractedToken;

            // find any other ocurrences after this one
            pszFound = wcsstr(pszFound, displayStrings[i].szExpansionString);
        }
    }

    hr = S_OK;
Ret:
    return hr;
}     

void AddStringToCheckList(
                    HWND            hWndListView,
                    LPCWSTR         szText, 
                    LPVOID          pvData,
                    BOOL            fCheck)
{
    LVITEMW                    lvI;
    ZeroMemory(&lvI, sizeof(lvI));
   
    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_PARAM;
    lvI.pszText = (LPWSTR)szText;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)pvData; 
    lvI.iItem = ListView_GetItemCount(hWndListView);
    lvI.cchTextMax = wcslen(szText);

    ListView_InsertItem(hWndListView, &lvI);
    ListView_SetCheckState(hWndListView, lvI.iItem, fCheck);

    ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
}

DWORD DetermineURLType(PCERTSVR_URL_PARSING prgURLParsing, int cURLParsingEntries, LPCWSTR szCandidateURL)
{
    int iURLTypeMatch;

    // determine URL type
    WCHAR rgsz[6];  // "http:\0" , etc
    lstrcpyn(rgsz, szCandidateURL, 6);
    WCHAR* pch = wcschr(rgsz, L':');    // find ':'
    if (NULL == pch)
        return -1;   // invalid item
    pch[1] = '\0';  // whack the elt after :
            
    // find the prefix in our list of known protocols
    for (iURLTypeMatch=0; iURLTypeMatch<cURLParsingEntries; iURLTypeMatch++)
    {
        if (0 == lstrcmpi(rgsz, prgURLParsing[iURLTypeMatch].szKnownPrefix))
            break;
    }
    if (iURLTypeMatch == cURLParsingEntries)     // no match
        return -1;
    
    return iURLTypeMatch;
}


HRESULT WriteChanges(HWND hListView, HKEY hkeyStorage, PCERTSVR_URL_PARSING prgURLParsing, DWORD cURLParsingEntries)
{
    HRESULT hr = S_OK;

    // empty item to dump to 
    LV_ITEM lvI;
    ZeroMemory(&lvI, sizeof(lvI));
    lvI.mask = LVIF_TEXT;
    WCHAR szText[MAX_PATH+1];
    lvI.pszText = szText;
    lvI.cchTextMax = MAX_PATH;
    
    LPWSTR pszContracted = NULL;

    int iURLArrayLen = cURLParsingEntries;
    int iURLTypeMatch;
    
    DWORD*  rgchszzEntries = NULL;
    LPWSTR* rgszzEntries = NULL;

    // entries will be sorted into one of the following
    rgchszzEntries = (DWORD*)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(DWORD) * cURLParsingEntries);
    if (NULL == rgchszzEntries)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    rgszzEntries = (LPWSTR*)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(LPWSTR) * cURLParsingEntries); 
    if (NULL == rgszzEntries)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }    
    
    // enumerate through all the items and add to the arrays
    for (lvI.iItem=0; ; lvI.iItem++)
    {
        BOOL fCheck = TRUE;
        LPWSTR pszTmp;
        
        // go until we hit end-of-list
        if (!ListView_GetItem(hListView, &lvI))
            break;
        
        // determine URL type
        iURLTypeMatch = DetermineURLType(prgURLParsing, iURLArrayLen, lvI.pszText);
        if (iURLTypeMatch == -1)    // no match
            continue;

        hr = ContractDisplayString(
             lvI.pszText,
             &pszContracted);

        // determine check state
        if (!ListView_GetCheckState(hListView, lvI.iItem))
        {
            // item not checked! add '-'
            fCheck = FALSE;
        }
        
        // alloc enough to hold existing, plus new [-]"string\0", plus \0 we'll tack on end of string
        DWORD dwAllocBytes = ((rgchszzEntries[iURLTypeMatch] + wcslen(pszContracted) + 2) * sizeof(WCHAR)) + (fCheck ? 0 : sizeof(WCHAR));

        if (NULL == rgszzEntries[iURLTypeMatch])
        {
            pszTmp  = (LPWSTR)LocalAlloc(LMEM_FIXED, dwAllocBytes);
        }
        else
        {
            pszTmp = (LPWSTR)LocalReAlloc(
                rgszzEntries[iURLTypeMatch], 
                dwAllocBytes, 
                LMEM_MOVEABLE);
        }
        if (NULL == pszTmp)
        {
            // leave ppszzEntries as valid as it already is, try to recover
            break;
        }
        
        rgszzEntries[iURLTypeMatch] = pszTmp;           // assign new mem to rgszz; meanwhile, pszTmp is shorthand
        DWORD chTmp = rgchszzEntries[iURLTypeMatch];  // temp assign
        
        if (!fCheck)
        {
            pszTmp[chTmp++] = L'-'; // item not checked
        }
        wcscpy(&pszTmp[chTmp], pszContracted);
        chTmp += wcslen(pszContracted)+1; // skip string\0
        pszTmp[chTmp] = L'\0';    // double NULL, don't count in rgchszzEntries
        
        // reassign chTmp to rgchszzEntries[iURLTypeMatch]
        rgchszzEntries[iURLTypeMatch] = chTmp;

        // clean up
        if (pszContracted)
            LocalFree(pszContracted);
        pszContracted = NULL;
        
        // next listbox entry!
    }

    // done, now commit all URL types to registry
    for (iURLTypeMatch=0; iURLTypeMatch<iURLArrayLen; iURLTypeMatch++)
    {
        hr = RegSetValueEx(
		    hkeyStorage,
		    prgURLParsing[iURLTypeMatch].szRegEntries,
		    0,
		    REG_MULTI_SZ,
		    (BYTE *) (NULL == rgszzEntries[iURLTypeMatch]?
			L"\0\0" : rgszzEntries[iURLTypeMatch]),
		    (NULL == rgszzEntries[iURLTypeMatch]?
			    2 : rgchszzEntries[iURLTypeMatch] + 1) *
			sizeof(WCHAR)); // now add 2nd '\0'
        
        // Zero
        if (rgszzEntries[iURLTypeMatch])
        {
            LocalFree(rgszzEntries[iURLTypeMatch]);
            rgszzEntries[iURLTypeMatch] = NULL;
            rgchszzEntries[iURLTypeMatch] = 0;
        }
        
        if (hr != ERROR_SUCCESS)
        {
            //ASSERT(!"RegSetValueEx error!");
            continue;
        }
    }

    hr = S_OK;
Ret:
    if (rgchszzEntries)
        LocalFree(rgchszzEntries);

    if (rgszzEntries)
        LocalFree(rgszzEntries);

    if (pszContracted)
        LocalFree(pszContracted);

    return hr;
}

HRESULT PopulateListView(
        HWND hListView, 
        HKEY hkeyStorage, 
        PCERTSVR_URL_PARSING prgURLParsing, 
        DWORD cURLParsingEntries,
        DWORD dwEnableFlags)
{
    HRESULT hr;
    LPWSTR pwszzMultiString = NULL, psz;
    for (DWORD i=0; i<cURLParsingEntries; i++)
    {
        DWORD cb=0, dwType;
        hr = RegQueryValueEx(
            hkeyStorage,
            prgURLParsing[i].szRegEntries,
            0,
            &dwType,
            NULL,
            &cb);
        if ((hr != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ) || (cb == 0))
            continue;
        pwszzMultiString = (LPWSTR)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pwszzMultiString)
            continue;
        hr = RegQueryValueEx(
            hkeyStorage,
            prgURLParsing[i].szRegEntries,
            0,
            &dwType,
            (PBYTE)pwszzMultiString,
            &cb);
        if ((HRESULT) ERROR_SUCCESS != hr)
        {
            if (pwszzMultiString)
                LocalFree(pwszzMultiString); 
            pwszzMultiString = NULL;

            continue;
        }

        // walk pwszzMultiString components
        for (psz = pwszzMultiString; (psz) && (psz[0] != '\0'); psz += wcslen(psz)+1)
        {
            BOOL fCheck = TRUE;
            LPWSTR szDisplayString;

            // if string starts with -, this is unchecked 
            if (psz[0] == L'-')
            {
                fCheck = FALSE;
                psz++;  // step past this char
            }

            // enable flags -- override
            if (prgURLParsing[i].dwEnableFlag != (dwEnableFlags & prgURLParsing[i].dwEnableFlag))
                fCheck = FALSE;

            hr = ExpandDisplayString(
                 psz,
                 &szDisplayString);
            if (hr != S_OK)
                continue;

            // add this sz
            AddStringToCheckList(
                    hListView,
                    szDisplayString, //psz, 
                    NULL,
                    fCheck);
            
            LocalFree(szDisplayString);
        }

        if (pwszzMultiString) 
        {
            LocalFree(pwszzMultiString); 
            pwszzMultiString = NULL;
        }
    }

    hr = S_OK;
//Ret:
    return hr;
}

BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;

    if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        WinHelp((HWND)pHelpInfo->hItemHandle, szHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    }
    return TRUE;
}

BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;
    assert(IsWindow(hWnd));
    WinHelp(hWnd, szHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\listvw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       listvw.h
//
//--------------------------------------------------------------------------

typedef struct _CERTSVR_URL_PARSING
{
    LPWSTR szKnownPrefix;
    LPWSTR szRegEntries;
    DWORD  dwEnableFlag;
} CERTSVR_URL_PARSING, *PCERTSVR_URL_PARSING;

typedef struct _ADDURL_DIALOGARGS
{
    CERTSVR_URL_PARSING* rgAllowedURLs;
    DWORD cAllowedURLs;
    LPWSTR* ppszNewURL;
} ADDURL_DIALOGARGS, *PADDURL_DIALOGARGS;

DWORD DetermineURLType(
                    PCERTSVR_URL_PARSING prgURLParsing, 
                    int cURLParsingEntries, 
                    LPCWSTR szCandidateURL);

void AddStringToCheckList(
                    HWND            hWndListView,
                    LPCWSTR         szText, 
                    LPVOID          pvData,
                    BOOL            fCheck);


HRESULT WriteChanges(
                    HWND hListView, 
                    HKEY hkeyStorage, 
                    PCERTSVR_URL_PARSING prgURLParsing, 
                    DWORD cURLParsingEntries);

HRESULT PopulateListView(
                    HWND hListView, 
                    HKEY hkeyStorage, 
                    PCERTSVR_URL_PARSING prgURLParsing, 
                    DWORD cURLParsingEntries,
                    DWORD dwEnableFlags);

HRESULT ValidateTokens(
                    IN OUT LPWSTR szURL,
                    OUT DWORD* pchBadBegin,
                    OUT DWORD* pchBadEnd);

// help is embedded in certmmc.hlp

BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\makefile.inc ===
!include ..\sample\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#define wszCLASS_CERTPOLICYEXCHANGEPREFIX TEXT("CertificateAuthority_MicrosoftExchange55") 

#define wszCLASS_CERTPOLICYEXCHANGE wszCLASS_CERTPOLICYEXCHANGEPREFIX  wszCERTPOLICYMODULE_POSTFIX

#define wszCLASS_CERTMANAGEEXCHANGE wszCLASS_CERTPOLICYEXCHANGEPREFIX wszCERTMANAGEPOLICY_POSTFIX

#define wsz_SAMPLE_NAME           L"ExPolicy.dll"
#define wsz_SAMPLE_DESCRIPTION    L"Exchange 5.5 Policy Module for Windows 2000"
#define wsz_SAMPLE_COPYRIGHT      L"(c)1999 Microsoft"
#define wsz_SAMPLE_FILEVER        L"v 1.0"
#define wsz_SAMPLE_PRODUCTVER     L"v 5.00"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\certweb\certsgcl.inc ===
﻿<%' CODEPAGE=65001 'UTF-8%>
<%' certsgcl.inc - (CERT)srv web - (S)cript: (G)et (C)sp (L)ist
  ' Copyright (C) Microsoft Corporation, 1998 - 1999 %>

<Script Language="JavaScript">
	//----------------------------------------------------------------
	// convert a (signed) number into a (unsigned) hex string
	function toHex(number) {
		var sRight=(number&0x0FFFFFFF).toString(16).toUpperCase();
		sRight="0000000".substring(0, 7-sRight.length)+sRight;
		return ((number>>28)&0x0000000F).toString(16).toUpperCase()+sRight;
	}
</Script>

<%If True=bIncludeXEnroll Then%>
<%If "IE"=sBrowser Then%>
<!-- IE SPECIFIC:  -->
<Span ID=spnXEnroll Style="display:none">
	<!-- XEnroll will be inserted here -->
</Span>

<!-- A DHTML alert box, for the transient message routines -->
<Table Border=0 CellSpacing=0 CellPadding=0 ID=tblWorkingMsg Style="display:none; position:absolute;">
<TR>
	<TD BgColor=#000040 Height=3 ColSpan=3></TD>
</TR> <TR>
	<TD BgColor=#000040 Width=3></TD>
	<TD BgColor=#008080><Font Color=#FFFFFF><B><BR>&nbsp;&nbsp;&nbsp;&nbsp;<Span ID=spnWorkingMsg></Span>&nbsp;&nbsp;&nbsp;&nbsp;<BR><BR></B></Font></TD>
	<TD BgColor=#000040 Width=3></TD>
</TR> <TR>
	<TD BgColor=#000040 Height=3 ColSpan=3></TD>
</TR>
</Table>
<%End If%>

<%If "Text"<>sBrowser Then%>
<Script Language="JavaScript">
	//----------------------------------------------------------------
	// Show the message in the status bar and in the middle of the screen (DHTML only)
	function ShowTransientMessage(sMessage) {
		window.status=sMessage;
		<%If "IE"=sBrowser Then%>
		spnWorkingMsg.innerText=sMessage;
		tblWorkingMsg.style.display='';
		tblWorkingMsg.style.pixelTop=
			(document.body.clientHeight/2)-(tblWorkingMsg.offsetHeight/2)+(document.body.scrollTop);
		tblWorkingMsg.style.pixelLeft=
			(document.body.clientWidth/2)-(tblWorkingMsg.offsetWidth/2)+(document.body.scrollLeft);
		<%End If%>
	}

	//----------------------------------------------------------------
	// hide the message box
	function HideTransientMessage() {
		window.status="";
		<%If "IE"=sBrowser Then%>
		tblWorkingMsg.style.display='none';
		<%End If%>
	}
</Script>
<%End If%>

<%If "IE"=sBrowser Then%>
<Script Language="JavaScript">

	//----------------------------------------------------------------
	// IE SPECIFIC:
	// Download the appropriate version of XEnroll if the local 
	// version is too old, and wait for the control to finish downloading.
	// sContinueCmd will be executed when the control is ready
	function loadXEnroll(sContinueCmd) {

		// clear the current control, if there is one
		spnXEnroll.innerHTML="";
		
		// determine the file name from the CPU type.
		var sCPU=navigator.cpuClass.toLowerCase();
		if ("x86"!=sCPU && "ia64"!=sCPU) {
			alert(eval(L_BadCPU_ErrorMessage));
			g_fnOnLoadFail();
			return;
		}

		// load the control
		var sControl="<Object \n"
			+ "  ClassID=\"clsid:43F8F289-7A20-11D0-8F06-00C04FC295E1\"\n"
			+ "  Codebase=\"/CertControl/xenrlinf.cab#Version=<%=sXEnrollVersion%>\"\n"
			+ "  ID=XEnroll\n"
			+ "></Object>";
		// alert("About to create:\n" + sControl);
		spnXEnroll.innerHTML=sControl;

		// begin polling to see if the control is loaded
		setTimeout("loadXEnrollPhase2(\""+sContinueCmd+"\")", 1);
	}
	function loadXEnrollPhase2(sContinueCmd) {
		// continued from above

		// is the control loaded?
		if (4!=XEnroll.readyState) { // 4=READYSTATE_COMPLETE
			// no, show a message and wait a while
			ShowTransientMessage(L_DownloadingControl_Message);
			setTimeout("loadXEnrollPhase2(\""+sContinueCmd+"\")", 500);
		} else {
			// yes, hide the message
			HideTransientMessage();

			// smoke test the control
			var nResult=ConfirmXEnrollLoaded();
			if (0!=nResult) {
				if (438==nResult) {
					alert(L_ControlLoadFailed_ErrorMessage);
				} else {
					var sErrorNumber="0x"+toHex(nResult);
					alert(eval(L_ControlLoadFailedEx_ErrorMessage));
				}
				g_fnOnLoadFail();
				return;
			}

			// Continue with what the caller wanted us to do
			execScript(sContinueCmd, "JavaScript");
		}
	}

	//----------------------------------------------------------------
	// IE SPECIFIC:
	// disable all the controls on this page so the user can't do anything
	function disableAllControls() {

		// some pages do not have any controls
		if (null==document.UIForm) {
			return;
		}

		// disable every control on the page
		var nCount=document.UIForm.elements.length;
		var nIndex;
		for (nIndex=0; nIndex<nCount; nIndex++) { //>
			document.UIForm.elements(nIndex).disabled=true;
		}
	}

	//----------------------------------------------------------------
	// If XEnroll fails to load, this function will be called.
	// By default, disable all controls.
	var g_fnOnLoadFail=disableAllControls;

</Script>
<Script Language="VBScript">
	'-----------------------------------------------------------------
	' Strings to be localized
	Const L_BadCPU_ErrorMessage="""Your CPU (""+sCPU+"") is not supported."""
	Const L_DownloadingControl_Message="Downloading ActiveX control..."
	Const L_ControlLoadFailed_ErrorMessage="The proper version of the ActiveX control failed to download and install. You may not have sufficient permissions. Please ask your system administrator for assistance."
	Const L_ControlLoadFailedEx_ErrorMessage="""An unexpected error (""+sErrorNumber+"") occurred while downloading and installing the proper version of the ActiveX control. Please ask your system administrator for assistance."""

	'-----------------------------------------------------------------
	' IE SPECIFIC:
	' Test to make sure XEnroll loaded properly by calling a method on it.
	' For best results, the method we call should only be available in the 
	' most recent version of the control, however any method will detect
	' failure to create the object.
	Function ConfirmXEnrollLoaded()
		On Error Resume Next
		Dim nTest
		nTest=XEnroll.HashAlgID
		ConfirmXEnrollLoaded=Err.Number
	End Function
</Script>
<%End If '"IE"=sBrowser%>
<%End If 'True=bIncludeXEnroll%>

<%If True=bIncludeGetCspList Then%>
<%If "IE"=sBrowser Then%>
<Script Language="VBScript">
	Option Explicit

	'-----------------------------------------------------------------
	' Strings to be localized
	Const L_NoCSPs_ErrorMessage="(No CSPs found!)"
	Const EnhancedCSPString="Microsoft Enhanced Cryptographic Provider"
	Const BaseCSPString="Microsoft Base Cryptographic Provider"

	'-----------------------------------------------------------------
	' IE SPECIFIC:
	' Get the list of CSPs from XEnroll
	' returns error number
	' assumes XEnroll is named 'XEnroll' and the list box is 'document.UIForm.lbCSP'
	Function GetCSPList()
		On Error Resume Next
		Dim nProvType, nOrigProvType, nTotCSPs, nDefaultCSP, nBaseCSP, bNoDssBase, bNoDssDh, sUserAgent
		Const nMaxProvType=25 ' should be >= the number of providers defined in wincrypt.h (~line 431)
		nTotCSPs=0
		nDefaultCSP=-1
		nBaseCSP=-1

		' Special case stuff for DSS CSPs
		' We know we are an IE browser to get here.
		sUserAgent=navigator.userAgent
		If CInt(Mid(sUserAgent, InStr(sUserAgent, "MSIE")+5, 1))<=4 Then
			' IE 4 or below
			bNoDssDh=True
			bNoDssBase=True
			If 0<>InStr(sUserAgent, "NT)") Then 'NT 4 does not include version num in string.
				' except on NT4, which can
				bNoDssDh=False
			End If
		Else
			' IE 5 or above
			bNoDssDh=False
			If 0<>InStr(sUserAgent, "95") Then
				' Win95 can't
				bNoDssBase=True
			ElseIf 0<>InStr(sUserAgent, "NT)") Then 'NT 4 does not include version num in string.
				' NT4 can't
				bNoDssBase=True
			Else
				' Win98 and Win2K can
				bNoDssBase=False
			End If
		End If

		' save the original provider type
		nOrigProvType=XEnroll.ProviderType
		If 0<>Err.Number Then
			' something wrong with XEnroll
			GetCSPList=Err.Number 
			Exit Function
		End If

		' enumerate through each of the provider types
		For nProvType=0 To nMaxProvType 
			Dim nCSPIndex
			nCSPIndex=0
			XEnroll.ProviderType=nProvType
			
			' enumerate through each of the providers for this type
			Do 
				Dim sProviderName

				'get the name
				sProviderName=XEnroll.enumProviders(nCSPIndex, 0)
				
				If &H80070103=Err.Number Then 
					' no more providers
					Err.Clear
					Exit Do
				ElseIf 0<>Err.Number Then
					' something wrong with XEnroll
					'  - ex, Win16 IE4 XEnroll doesn't support this call.
					GetCSPList=Err.Number 
					Exit Function
				End If
			
				If ("Microsoft Base DSS Cryptographic Provider"=sProviderName And True=bNoDssBase) _
					Or ("Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"=sProviderName And True=bNoDssDh) Then
					' skip this provider
				Else 
					' For each provider, add an element to the list box.
					Dim oOption
					Set oOption=document.createElement("Option")
					oOption.text=sProviderName
					oOption.Value=nProvType
					document.UIForm.lbCSP.add(oOption)
					If InStr(sProviderName, EnhancedCSPString) <> 0 Then
						oOption.selected=True
						nDefaultCSP=nTotCSPs
					End If
					If InStr(sProviderName, BaseCSPString) <> 0 Then
						'just remember the base csp index
						nBaseCSP=nTotCSPs
					End If
					nTotCSPs=nTotCSPs+1
				End If
				
				' get the next provider
				nCSPIndex=nCSPIndex+1
			Loop
		Next
		
		' if there are no CSPs, we're kinda stuck
		If 0=nTotCSPs Then
			Set oElement=document.createElement("Option")
			oElement.text=L_NoCSPs_ErrorMessage
			document.UIForm.lbCSP.Options.Add oElement
		End If

		' remove the 'loading' text
		document.UIForm.lbCSP.remove(0)

		' select the default provider
		If -1 = nDefaultCSP Then
			'no enhanced csp, how about base
			If -1 <> nBaseCSP Then
				'ok, take base csp
				nDefaultCSP=nBaseCSP
			End If
		End If
		If -1<>nDefaultCSP Then
			document.UIForm.lbCSP.selectedIndex=nDefaultCSP
		End If
		If -1 = nDefaultCSP Then
			If 0 < nCSPIndex Then
				'well, best bet is the 1st available one
				document.UIForm.lbCSP.selectedIndex=0
			End If
		End If

		' restore the original provider type
		XEnroll.ProviderType=nOrigProvType

		' set the return value and exit
		If 0<>Err.Number Then
			GetCSPList=Err.Number
		ElseIf 0=nTotCSPs Then
			' signal no elements with -1
			GetCSPList=-1
		Else
			GetCSPList=0
		End If

	End Function

	Function AddCSPToList(sCSP)
		On Error Resume Next
		Dim oOption
		Dim nProviderType

		nProviderType = XEnroll.getProviderType(sCSP)
		If 0=Err.Number Then
			'csp available on the machine
			Set oOption=document.createElement("Option")
			oOption.text=sCSP
			oOption.Value=nProviderType
			document.UIForm.lbCSP.add(oOption)
			If InStr(sCSP, EnhancedCSPString) <> 0 Then
				oOption.selected=True
			End If
		End If
	End Function

</Script>

<%End If '"IE"=sBrowser%>
<%End If 'True=bIncludeGetCspList%>

<%If "IE"=sBrowser Then%>
<%If True=bIncludeTemplateCode Then%>
<Script Language="JavaScript">
	var CTINFO_INDEX_OFFLINE     =0;
	var CTINFO_INDEX_REALNAME    =1;
	var CTINFO_INDEX_KEYSPEC     =2;
	var CTINFO_INDEX_KEYFLAG     =3;
	var CTINFO_INDEX_ENROLLFLAG  =4;
	var CTINFO_INDEX_PRIVATEKEYFLAG  =5;
	var CTINFO_INDEX_SUBJECTFLAG =6;
	var CTINFO_INDEX_RASIGNATURE =7;
	var CTINFO_INDEX_CSPLIST     =8;
	var CTINFO_INDEX_EXTOID      =9;
	var CTINFO_INDEX_EXTMAJ      =10;
	var CTINFO_INDEX_EXTFMIN     =11;
	var CTINFO_INDEX_EXTMIN      =12;

        function getTemplateStringInfo(nIndex, sInTemplate)
        {
		//extract sub string from template string in a format
		//of "substr1;substr2;substr3;substr4;..."
		//";" is the separator, index starts from 0
		var nTemplateIndex, sTemplate;
		if (null == sInTemplate)
		{
			nTemplateIndex=document.UIForm.lbCertTemplate.selectedIndex;
			sTemplate=document.UIForm.lbCertTemplate.options[nTemplateIndex].value;
		}
		else
		{
			sTemplate = sInTemplate;
		}
		var sTemp = sTemplate;
		var n, m, nEnd;
		var fFound = true;

		//find sub-string start location
		for (n = 0; n < nIndex; ++n)
		{
			m = sTemp.indexOf(";");
			if (-1 == m)
			{
				fFound = false;
				break;
			}
			sTemp = sTemp.substr(m+1);
		}

		if (fFound)
		{
			//sTemp starts from the substring, find end index
			nEnd = sTemp.indexOf(";");
			if (-1 != nEnd)
			{
				sTemp = sTemp.substring(0, nEnd);
			}
		}
		else
		{
			sTemp = "";
		}
		return sTemp;
	}


        function updateCSPListFromStrings(sCSPList)
        {
		var n, m, nCSP;
		var L_NoDesiredCSPInstalledMsg = "You need to install the following CSPs before the enrollment, ";
		var L_AndMsg = "and ";
		var sSupportedCSPs = "";

		//remove the current csp list
		var nCSP = document.UIForm.lbCSP.length;
		//note, strange reasons, can't nCSP-1
		for (n = 0; n < nCSP; ++n)
		{
			document.UIForm.lbCSP.remove(0);
		}

		//add to the list
		while (-1 != (m = sCSPList.indexOf("?")))
		{
			//get csp from the list
			sCSP = sCSPList.substring(0, m);
			AddCSPToList(sCSP);
			if ("" == sSupportedCSPs)
			{
				sSupportedCSPs = sCSP;
			}
			else
			{
				sSupportedCSPs = sSupportedCSPs + ", ";
			}
			//move to the next csp
			sCSPList = sCSPList.substring(m+1);
		}
		if ("" != sCSPList)
		{
			//add the last csp
			AddCSPToList(sCSPList);

			if ("" == sSupportedCSPs)
			{
				sSupportedCSPs = sCSPList + ".";
			}
			else
			{
				sSupportedCSPs = sSupportedCSPs + ", " + L_AndMsg + sCSPList + ".";
			}
		}
		if (0 == document.UIForm.lbCSP.length)
		{
			alert(L_NoDesiredCSPInstalledMsg + sSupportedCSPs);
		}
        }

</Script>
<%End If 'True=bIncludeTemplateCode Then%>
<%End If '"IE"=sBrowser%>

<%If "IE"=sBrowser Then
	If True=bIncludeCheckClientCode Then%>
<Script Language="JavaScript">
	//helper to decide downlevel browsers
	function isClientAbleToCreateCMC()
	{
		var sUserAgent = navigator.userAgent;
		var index;

		//check if W2K or newer
		index = sUserAgent.indexOf("Windows NT");
		if (-1 != index)
		{
			if (4 < parseInt(sUserAgent.substring(index+11, index+12)))
			{
				//either w2k or newer
				return true;
			}
		}
		if (-1 != sUserAgent.indexOf("Windows 98; Win 9x"))
		{
			//win ME
			return true;
		}
		return false;
	}

</Script>
<%	End If 'True=bIncludeTemplateCode Then
End If '"IE"=sBrowser%>

<%  ' ########## BEGIN SERVER SIDE EXECUTION ##########

	'-----------------------------------------------------------------
	' Strings To Be Localized
	Const L_Unexpected_ErrorMessage="Unexpected Error"
	Const L_NoTemplates_ErrorMessage="(No templates found!)"

	'-----------------------------------------------------------------
	' SCrdEnrl constants

	' flags for enumCAName, getCAName and setCAName
	Const SCARD_ENROLL_CA_REAL_NAME=0 'default
	Const SCARD_ENROLL_CA_MACHINE_NAME=1
	Const SCARD_ENROLL_CA_DISPLAY_NAME=2
	Const SCARD_ENROLL_CA_UNIQUE_NAME=3 'machineName\displayName

	' flags for getCertTemplateCount and enumCertTemplateName
	Const SCARD_ENROLL_USER_CERT_TEMPLATE=1
	Const SCARD_ENROLL_MACHINE_CERT_TEMPLATE=2
	Const SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE=&H08
	Const SCARD_ENROLL_OFFLINE_CERT_TEMPLATE=&H10
	Const SCARD_ENROLL_CROSS_CERT_TEMPLATE=&H20

	' flags for enumCertTemplateName, getCertTemplateName and setCertTemplateName
	Const SCARD_ENROLL_CERT_TEMPLATE_REAL_NAME=0 ' default
	Const SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME=4

	'-----------------------------------------------------------------
	' Get the list of Cert templates from SCrdEnr and write them to the web page
	' returns error number, or -1 if no templates
	Function WriteTemplateList()
		On Error Resume Next
		Dim nTest, bAnyElements, SCrdEnrl, bAnyElementsReturn

		'Stop 'debugging breakpoint
		bAnyElements=False

		' create the object
		Set SCrdEnrl=Server.CreateObject("SCrdEnr.SCrdEnr.1")
		' call an easy method to make sure everything is OK
		nTest=SCrdEnrl.CSPCount
		If 0<>Err.Number Then
			' something's wrong with SCrdEnrl
			WriteTemplateError Err.Number
			WriteTemplateList=Err.Number
			Exit Function
		End If

		' first, get the Enterprise (DS-backed) templates
		bAnyElementsReturn=EnumTemplates(SCrdEnrl, SCARD_ENROLL_USER_CERT_TEMPLATE Or SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE or SCARD_ENROLL_CROSS_CERT_TEMPLATE, "E")
		bAnyElements=bAnyElements Or bAnyElementsReturn

		' Second, get the Offline (non-Enterprise, non-DS-backed) templates
		bAnyElementsReturn=EnumTemplates(SCrdEnrl, SCARD_ENROLL_OFFLINE_CERT_TEMPLATE Or SCARD_ENROLL_CROSS_CERT_TEMPLATE, "O")
		bAnyElements=bAnyElements Or bAnyElementsReturn

		' if there are no templates, we're kinda stuck
		If False=bAnyElements Then
%>
			<Option Value="X"><%=L_NoTemplates_ErrorMessage%></Option>
<%
		End If

		' set the return value and exit
		If 0<>Err.Number Then
			WriteTemplateError Err.Number
			WriteTemplateList=Err.Number
		ElseIf False=bAnyElements Then
			' signal no elements with -1
			WriteTemplateList=-1
		Else
			WriteTemplateList=0
		End If

	End Function

	'-----------------------------------------------------------------
	' write an error message to the web page
	Sub WriteTemplateError(nErrNumber)
%>
			<Option Value="X">(<%=L_Unexpected_ErrorMessage%> 0x<%=HEX(nErrNumber)%>)</Option>
<%
	End Sub
		
	'-----------------------------------------------------------------
	' enumerate the templates the match the given flags and add them to the web page
	Function EnumTemplates(SCrdEnrl, nRequestedTemplateFlags, sPrefix)
		Dim nNumTemplates, sRealName, sDisplayName, nTemplateIndex, nNumCAs, nCAIndex, oElement, bAnyElements
		Dim sKeySpec, sKeyFlags, sCSP, sCSPs, sSubjectFlags, sPrivateKeyFlags, sEnrollmentFlags
		Dim sCTE, sCTEOid, sCTEMajor, sCTEMinor, sCTEMinorFlag, sRASignature
                Const SCARD_CTINFO_KEYSPEC=1
                Const SCARD_CTINFO_KEYFLAGS=2
                Const SCARD_CTINFO_EXT_OID=3
                Const SCARD_CTINFO_EXT_MAJOR=4
                Const SCARD_CTINFO_EXT_MINOR=5
                Const SCARD_CTINFO_EXT_MINOR_FLAG=6
                Const SCARD_CTINFO_SUBJECTFLAG=7
                Const SCARD_CTINFO_CSPLIST_FIRST=8
                Const SCARD_CTINFO_CSPLIST_NEXT=9
                Const SCARD_CTINFO_GENERALFLAGS=10
                Const SCARD_CTINFO_ENROLLMENTFLAGS=11
                Const SCARD_CTINFO_PRIVATEKEYFLAGS=12
                Const SCARD_CTINFO_RA_SIGNATURE=13
		On Error Resume Next

		bAnyElements=False

		' get the number of known templates
		nNumTemplates=SCrdEnrl.getCertTemplateCount(nRequestedTemplateFlags)
		' loop over all the known templates
		For nTemplateIndex=1 To nNumTemplates

			'get the CertTemplate name
			sRealName=SCrdEnrl.enumCertTemplateName(nTemplateIndex-1, nRequestedTemplateFlags Or SCARD_ENROLL_CERT_TEMPLATE_REAL_NAME)
			sDisplayName=SCrdEnrl.enumCertTemplateName(nTemplateIndex-1, nRequestedTemplateFlags Or SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME)

			
			' see it if supported by our CA

			' get the number of CAs that support this template
			nNumCAs=SCrdEnrl.getCACount(sRealName)

			' loop over all of those CAs and see if one is ours
			For nCAIndex=1 To nNumCAs

				' If we find our CA, add this template to the list
				If sServerConfig=SCrdEnrl.enumCAName(nCAIndex-1, SCARD_ENROLL_CA_UNIQUE_NAME, sRealName) Then
					'get template extension info
					'Stop
					sKeySpec = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_KEYSPEC))

					sKeyFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_KEYFLAGS))

					sEnrollmentFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_ENROLLMENTFLAGS))

					'get private key flags
					sPrivateKeyFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_PRIVATEKEYFLAGS))

					sSubjectFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_SUBJECTFLAG))

					'get # of RA signatures
					sRASignature = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_RA_SIGNATURE))

					'get csp list separated by ?
					sCSPs = Empty
					sCSP = SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_CSPLIST_FIRST) 
					While Not IsEmpty(sCSP)
						If IsEmpty(sCSPs) Then
							sCSPs = sCSP
						Else
							sCSPs = sCSPs + "?" + sCSP
						End If
						sCSP = Empty
						sCSP = SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_CSPLIST_NEXT)
					Wend
					'above actually return no more item error so clean up
					Err.Clear

					sCTEOid = SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_OID)
					If ""=sCTEOid Then
						sCTE=";;;"
					Else
						sCTEMajor = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_MAJOR))
						sCTEMinorFlag = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_MINOR_FLAG))
						sCTEMinor = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_MINOR))
						sCTE = sCTEOid & ";" & sCTEMajor & ";" & sCTEMinorFlag & ";" & sCTEMinor
					End If

					' add it to the document
%>
			<Option Value="<%=sPrefix%>;<%=sRealName%>;<%=sKeySpec%>;<%=sKeyFlags%>;<%=sEnrollmentFlags%>;<%=sPrivateKeyFlags%>;<%=sSubjectFlags%>;<%=sRASignature%>;<%=sCSPs%>;<%=sCTE%>"><%=sDisplayName%></Option>
<%
					bAnyElements=True
				End If

			Next ' <- End CA loop

		Next ' <- End known template loop

		' return success
		EnumTemplates=bAnyElements

	End Function

	Function IsUserTemplateAvailable()
		On Error Resume Next
		Dim nTest, nNumCAs, nCAIndex
		Const sUserTemplate="User"

		'init
		IsUserTemplateAvailable = False

		'create the scrdenrl object
		Set SCrdEnrl=Server.CreateObject("SCrdEnr.SCrdEnr.1")
		' call an easy method to make sure everything is OK
		nTest=SCrdEnrl.CSPCount
		If 0<>Err.Number Then
			' something's wrong with SCrdEnrl, just return FALSE
			Exit Function
		End If

		'see if any CA support User template
		nNumCAs=SCrdEnrl.getCACount(sUserTemplate)
		If 0=nNumCAs Then
			'no CA support it
			Exit Function
		End If

		'loop over all of those CAs and see if one is ours
		For nCAIndex=1 To nNumCAs
			' If we find our CA, add this template to the list
			If sServerConfig=SCrdEnrl.enumCAName(nCAIndex-1, SCARD_ENROLL_CA_UNIQUE_NAME, sUserTemplate) Then
				IsUserTemplateAvailable = True
				Exit Function 'found it
			End If
		Next 'CA loop	
	End Function 'IsUserTemplateAvailable

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManagePolicyModuleExchange definition
//
//---------------------------------------------------------------------------

#include "expolicy.h"
#include "resource.h"       // main symbols


class CCertManagePolicyModuleExchange: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYEXCHANGELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModuleExchange, &CLSID_CCertManagePolicyModuleExchange>
{
public:
    CCertManagePolicyModuleExchange() {}
    ~CCertManagePolicyModuleExchange() {}

BEGIN_COM_MAP(CCertManagePolicyModuleExchange)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModuleExchange) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManagePolicyModuleExchange,
    wszCLASS_CERTMANAGEEXCHANGE TEXT(".1"),
    wszCLASS_CERTMANAGEEXCHANGE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);
private:
    HWND m_hWnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include "commctrl.h"
#include "module.h"
#include "policy.h"

#include "celib.h"

// ..\inc
#include "listvw.h"

// help ids
#define _CERTPDEF_
#include "cemmchlp.h"

extern HINSTANCE g_hInstance;


STDMETHODIMP
CCertManagePolicyModuleExchange::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    WCHAR const *pwsz = NULL;
    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == wcscmp(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_MODULE_NAME;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
	pwsz = g_wszDescription;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        uiStr = IDS_MODULE_COPYRIGHT;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_FILEVER))
        uiStr = IDS_MODULE_FILEVER;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        uiStr = IDS_MODULE_PRODUCTVER;
    else
        return S_FALSE;

    // load string from resource
    WCHAR szStr[MAX_PATH];

    if (NULL == pwsz)
    {
	LoadString(g_hInstance, uiStr, szStr, ARRAYSIZE(szStr));
	pwsz = szStr;
    }

    pvarProperty->bstrVal = SysAllocString(pwsz);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}

STDMETHODIMP
CCertManagePolicyModuleExchange::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvalProperty)
{
     if (strPropertyName == NULL)
         return S_FALSE;
     if (0 == wcscmp(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvalProperty->vt != VT_BSTR)
              return E_INVALIDARG;

         if (SysStringByteLen(pvalProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;

         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvalProperty->bstrVal;
         return S_OK;
     }

     return S_FALSE;
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam);

INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam);

INT_PTR CALLBACK dlgAddURL(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam);

typedef struct _POLICY_CONFIGSTRUCT
{
    const BSTR*  pstrConfig;
    ENUM_CATYPES CAType;
    HKEY         hkeyStorageLocation;
    LONG         Flags;

    DWORD        dwPageModified;
} POLICY_CONFIGSTRUCT, *PPOLICY_CONFIGSTRUCT;

// dwPageModified
#define PAGE1 (0x1)
#define PAGE2 (0x2)


void MessageBoxWarnReboot(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hInstance, IDS_WARNING_REBOOT, szText, ARRAYSIZE(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

void MessageBoxNoSave(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hInstance, IDS_WARNING_NOSAVE, szText, ARRAYSIZE(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

STDMETHODIMP
CCertManagePolicyModuleExchange::Configure(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags)
{
    HRESULT hr;
    VARIANT varValue;
    VariantInit(&varValue);

    ICertServerPolicy *pServer = NULL;
    POLICY_CONFIGSTRUCT sConfig = {NULL, ENUM_UNKNOWN_CA, NULL, 0, 0};

    BOOL fLocal;
    LPWSTR szMachine = NULL;
    HKEY hkeyHKLM = NULL;
    DWORD dwDisposition;

    hr = ceIsConfigLocal(strConfig, &szMachine, &fLocal);
    _JumpIfError(hr, Ret, "ceIsConfigLocal");

    // use callbacks for info
    hr = GetServerCallbackInterface(&pServer, 0);    // no context : 0
    _JumpIfError(hr, Ret, "GetServerCallbackInterface");

    // we need to find out who we're running under
    hr = pServer->GetCertificateProperty(wszPROPCATYPE, PROPTYPE_LONG, &varValue);
    _JumpIfError(hr, Ret, "GetCertificateProperty : wszPROPCATYPE");

    sConfig.CAType = (ENUM_CATYPES)varValue.lVal;
    VariantClear(&varValue);

    hr = PopulateRegistryDefaults(fLocal? NULL : szMachine, strStorageLocation);
    _PrintIfError(hr, "PopulateRegistryDefaults");

    if (!fLocal)
    {
        hr = RegConnectRegistry(
			szMachine,
			HKEY_LOCAL_MACHINE,
			&hkeyHKLM);
        _JumpIfError(hr, Ret, "RegConnectRegistry");
    }

    // open storage location: write perms if possible
    hr = RegCreateKeyEx(
        fLocal ? HKEY_LOCAL_MACHINE : hkeyHKLM,
        strStorageLocation,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &sConfig.hkeyStorageLocation,
        &dwDisposition);
    if (hr != S_OK)
    {
        hr = RegOpenKeyEx(
            fLocal ? HKEY_LOCAL_MACHINE : hkeyHKLM,
            strStorageLocation,
            0,
            KEY_READ,       // fallback: read-only
            &sConfig.hkeyStorageLocation);
        _JumpIfError(hr, Ret, "RegOpenKeyEx");
    }

    sConfig.pstrConfig = &strConfig;
    sConfig.Flags = dwFlags;


    PROPSHEETPAGE page[2];
    ZeroMemory(&page[0], sizeof(PROPSHEETPAGE));
    page[0].dwSize = sizeof(PROPSHEETPAGE);
    page[0].dwFlags = PSP_DEFAULT;
    page[0].hInstance = g_hInstance;
    page[0].lParam = (LPARAM)&sConfig;

    // make 2nd page exactly the same as this
    CopyMemory(&page[1], &page[0], sizeof(PROPSHEETPAGE));

    // now page1 vs. page2 diffcs
    page[0].pszTemplate = MAKEINTRESOURCE(IDD_POLICYPG1);
    page[0].pfnDlgProc = WizPage1DlgProc;

    page[1].pszTemplate = MAKEINTRESOURCE(IDD_POLICYPG2);
    page[1].pfnDlgProc = WizPage2DlgProc;



    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.pszCaption = MAKEINTRESOURCE(IDS_MODULE_NAME);
    sSheet.nPages = ARRAYSIZE(page);
    sSheet.ppsp = page;


    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

    if ((iRet > 0) && (sConfig.dwPageModified))  // successful modification
    {
        MessageBoxWarnReboot(NULL);
    }

Ret:
    if (sConfig.hkeyStorageLocation)
        RegCloseKey(sConfig.hkeyStorageLocation);

    if (szMachine)
        LocalFree(szMachine);

    if (hkeyHKLM)
        RegCloseKey(hkeyHKLM);

    if (pServer)
        pServer->Release();

    return hr;
}


CERTSVR_URL_PARSING rgPOSSIBLE_CRL_URLs[] =
{
 { L"ldap:", wszREGLDAPREVOCATIONCRLURL_OLD, REVEXT_CDPLDAPURL_OLD | REVEXT_CDPENABLE },
 { L"http:", wszREGREVOCATIONCRLURL_OLD,     REVEXT_CDPHTTPURL_OLD | REVEXT_CDPENABLE },
 { L"ftp:",  wszREGFTPREVOCATIONCRLURL_OLD,  REVEXT_CDPFTPURL_OLD | REVEXT_CDPENABLE },
 { L"file:", wszREGFILEREVOCATIONCRLURL_OLD, REVEXT_CDPFILEURL_OLD | REVEXT_CDPENABLE },
};


CERTSVR_URL_PARSING rgPOSSIBLE_AIA_URLs[] =
{
 { L"ldap:", wszREGLDAPISSUERCERTURL_OLD, ISSCERT_LDAPURL_OLD | ISSCERT_ENABLE},
 { L"http:", wszREGISSUERCERTURL_OLD,     ISSCERT_HTTPURL_OLD | ISSCERT_ENABLE},
 { L"ftp:",  wszREGFTPISSUERCERTURL_OLD,  ISSCERT_FTPURL_OLD | ISSCERT_ENABLE },
 { L"file:", wszREGFILEISSUERCERTURL_OLD, ISSCERT_FILEURL_OLD | ISSCERT_ENABLE},
};


void mySetModified(HWND hwndPage, POLICY_CONFIGSTRUCT* psConfig)
{
    if (psConfig->dwPageModified != 0)
    {
        PropSheet_Changed( ::GetParent(hwndPage), hwndPage);
    }
    else
    {
        PropSheet_UnChanged( ::GetParent(hwndPage), hwndPage);
    }
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam)
{
    POLICY_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (POLICY_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwRequestDisposition, dwType;
            DWORD cbRequestDisposition = sizeof(dwRequestDisposition);
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREGREQUESTDISPOSITION,
                0,
                &dwType,
                (PBYTE)&dwRequestDisposition,
                &cbRequestDisposition);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_DWORD))
                break;

            // if disposition includes Issue
            if ((dwRequestDisposition & REQDISP_MASK) == REQDISP_ISSUE)
            {
                // if pending bit set
                if (dwRequestDisposition & REQDISP_PENDINGFIRST)
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), BM_SETCHECK, TRUE, BST_CHECKED);
                else
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_SETCHECK, TRUE, BST_CHECKED);
            }

            // disallow "Pend first" if Enterprise (bug #259346)
            if ((psConfig->CAType == ENUM_ENTERPRISE_ROOTCA) ||
                (psConfig->CAType == ENUM_ENTERPRISE_SUBCA))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_TEXT_PENDFIRST), FALSE);
            }

            psConfig->dwPageModified &= ~PAGE1; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (psConfig->dwPageModified & PAGE1)
                {
                    DWORD dwCheckState, dwRequestDisposition;
                    dwCheckState = (DWORD)SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_GETCHECK, 0, 0);

                    if (dwCheckState == BST_CHECKED)
                        dwRequestDisposition = REQDISP_ISSUE;
                    else
                        dwRequestDisposition = REQDISP_ISSUE | REQDISP_PENDINGFIRST;

                    hr = RegSetValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREQUESTDISPOSITION,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwRequestDisposition,
                        sizeof(DWORD));
                    if (hr != ERROR_SUCCESS)
                    {
                        MessageBoxNoSave(hwndDlg);
                        psConfig->dwPageModified &= ~PAGE1;
                    }
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE1;
                mySetModified(hwndDlg, psConfig);
            }
            break;
        default:
            break;
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_RADIO_ISSUE:
        case IDC_RADIO_PENDFIRST:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (BN_CLICKED == HIWORD(wParam))
                {
                    psConfig->dwPageModified |= PAGE1;
                    mySetModified(hwndDlg, psConfig);
                }
            }
            break;

        default:
            break;
        }
    default:
        break;
    }

    return fReturn;
}


INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam)
{
    POLICY_CONFIGSTRUCT* psConfig;
    HWND hListView;
    BOOL fCRLSelection= FALSE;
    BOOL fReturn = FALSE;
    HRESULT hr;


    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (POLICY_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwAllBits, dwType;
            DWORD cbDWSize=sizeof(dwAllBits);

            LVCOLUMN lvCol;
            lvCol.mask = LVCF_FMT | LVCF_TEXT;
            lvCol.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvCol.pszText = L"";      // The text for the column.

                    // get all extension bits -
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREVOCATIONTYPE,		// CDP
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;

            // single column defn
            hListView = GetDlgItem(hwndDlg, IDC_CRL_LIST);
            ListView_SetExtendedListViewStyle(hListView, LVS_EX_CHECKBOXES);
            ListView_InsertColumn(hListView, 0, &lvCol);
            hr = PopulateListView(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_CRL_URLs, ARRAYSIZE(rgPOSSIBLE_CRL_URLs), dwAllBits);
            _PrintIfError(hr, "PopulateListView");

            // if none, remove <REMOVE> button
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVE_CRL), (0 != ListView_GetItemCount(hListView)));


                    // get all extension bits -
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGISSUERCERTURLFLAGS, 	// AIA
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;


            hListView = GetDlgItem(hwndDlg, IDC_AIA_LIST);
            ListView_SetExtendedListViewStyle(hListView, LVS_EX_CHECKBOXES);
            ListView_InsertColumn(hListView, 0, &lvCol);
            hr = PopulateListView(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_AIA_URLs, ARRAYSIZE(rgPOSSIBLE_AIA_URLs), dwAllBits);
            _PrintIfError(hr, "PopulateListView");

            // if none, remove <REMOVE> button
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVE_AIA), (0 != ListView_GetItemCount(hListView)));

            psConfig->dwPageModified &= ~PAGE2; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG2);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG2);
        break;
    }
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                BOOL fSaveFailed = FALSE;

                if (psConfig->dwPageModified & PAGE2)
                {
                    DWORD dwAllBits;
                    DWORD cbDWSize = sizeof(DWORD);
                    DWORD dwType;

                    fSaveFailed = TRUE; // assume failure

                    hListView = GetDlgItem(hwndDlg, IDC_CRL_LIST);
                    hr = WriteChanges(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_CRL_URLs, ARRAYSIZE(rgPOSSIBLE_CRL_URLs));
                    _JumpIfError(hr, saveFailed, "WriteChanges");

                    hListView = GetDlgItem(hwndDlg, IDC_AIA_LIST);
                    hr = WriteChanges(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_AIA_URLs, ARRAYSIZE(rgPOSSIBLE_AIA_URLs));
                    _JumpIfError(hr, saveFailed, "WriteChanges");

                    // get all extension bits - CDP
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREVOCATIONTYPE,
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;

                    // set all extension bits -
                    dwAllBits |= REVEXT_CDPLDAPURL_OLD | REVEXT_CDPHTTPURL_OLD | REVEXT_CDPFTPURL_OLD | REVEXT_CDPFILEURL_OLD | REVEXT_CDPENABLE;
                    hr = RegSetValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREVOCATIONTYPE,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwAllBits,
                        sizeof(DWORD));
                    _JumpIfError(hr, saveFailed, "RegSetValue");



                    // get all extension bits - AIA
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGISSUERCERTURLFLAGS, // AIA
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;

                    // set all extension bits -
                    dwAllBits |= ISSCERT_LDAPURL_OLD | ISSCERT_HTTPURL_OLD | ISSCERT_FTPURL_OLD| ISSCERT_FILEURL_OLD | ISSCERT_ENABLE;
                    hr = RegSetValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGISSUERCERTURLFLAGS,   // AIA
                        0,
                        REG_DWORD,
                        (PBYTE)&dwAllBits,
                        sizeof(DWORD));
                    _JumpIfError(hr, saveFailed, "RegSetValue");

                    // got all the way through the save
                    fSaveFailed = FALSE;
                }
saveFailed:
                if (fSaveFailed)
                {
                    MessageBoxNoSave(hwndDlg);
                    psConfig->dwPageModified &= ~PAGE2;
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE2;
                mySetModified(hwndDlg, psConfig);
            }
            break;

        case LVN_ITEMCHANGED:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                // just catch check/uncheck on existing items
                NMLISTVIEW* pParam = (NMLISTVIEW*)lParam;
                if ((pParam != NULL) && (pParam->uChanged & CDIS_CHECKED))
                {
                    psConfig->dwPageModified |= PAGE2;
                    mySetModified(hwndDlg, psConfig);
                }

            }
            break;
        default:
            break;
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_ADD_CRL:
            fCRLSelection = TRUE;
            // fall through
        case IDC_ADD_AIA:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                LPWSTR szNewURL = NULL;

                ADDURL_DIALOGARGS dlgArgs = {
                    fCRLSelection ? rgPOSSIBLE_CRL_URLs : rgPOSSIBLE_AIA_URLs,
                    (DWORD)(fCRLSelection ? ARRAYSIZE(rgPOSSIBLE_CRL_URLs) : ARRAYSIZE(rgPOSSIBLE_AIA_URLs)),
                    &szNewURL};

                if (IDOK != DialogBoxParam(
                    g_hInstance,
                    MAKEINTRESOURCE(IDD_ADDURL),
                    hwndDlg,
                    dlgAddURL,
                    (LPARAM)&dlgArgs))
                    break;

                if (NULL != szNewURL)
                {
                    hListView = GetDlgItem(hwndDlg, fCRLSelection ? IDC_CRL_LIST : IDC_AIA_LIST);

                    AddStringToCheckList(
                        hListView,
                        szNewURL,
                        NULL,
                        TRUE);

                    LocalFree(szNewURL); szNewURL = NULL;

                    // enable <REMOVE> button
                    ::EnableWindow(GetDlgItem(hwndDlg, fCRLSelection ? IDC_REMOVE_CRL : IDC_REMOVE_AIA), TRUE);

                    psConfig->dwPageModified |= PAGE2;
                    mySetModified(hwndDlg, psConfig);
                }

                break;
            }
        case IDC_REMOVE_CRL:
            fCRLSelection = TRUE;
            // fall through
        case IDC_REMOVE_AIA:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                hListView = GetDlgItem(hwndDlg, fCRLSelection ? IDC_CRL_LIST : IDC_AIA_LIST);

                int iSel;
                iSel = ListView_GetNextItem(hListView, -1, LVIS_SELECTED);

                // no selected item
                if (-1 == iSel)
                    break;

                ListView_DeleteItem(hListView, iSel);
                ListView_SetColumnWidth(hListView, 0, LVSCW_AUTOSIZE);

                // if none, remove <REMOVE> button
                ::EnableWindow(GetDlgItem(hwndDlg, (fCRLSelection? IDC_REMOVE_CRL : IDC_REMOVE_AIA)), (0 != ListView_GetItemCount(hListView)));

                psConfig->dwPageModified |= PAGE2;
                mySetModified(hwndDlg, psConfig);

                break;
            }

        default:
            break;
        }
    default:
        break;
    }

    return fReturn;
}


// attempt IA5 encoding

HRESULT
IsValidIA5URL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;
    CERT_AUTHORITY_INFO_ACCESS caio;
    CERT_ACCESS_DESCRIPTION cad;

    caio.cAccDescr = 1;
    caio.rgAccDescr = &cad;

    cad.pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    cad.AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    cad.AccessLocation.pwszURL = const_cast<WCHAR *>(pwszURL);

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    FALSE,
		    &pb,
		    &cb))
    {
	hr = ceHLastError();
	_JumpIfError(hr, error, "ceEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


INT_PTR CALLBACK dlgAddURL(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam)
{
    BOOL fReturn = FALSE;
    LPWSTR* pszNewURL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
    {
        ::SetWindowLong(hwnd, GWL_EXSTYLE, ::GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

        // stash the ADDURL_DIALOGARGS* we were given

        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lParam);
        break;
    }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_ADDURL);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_ADDURL);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            ADDURL_DIALOGARGS* pArgs;

            // snatch the ADDURL_DIALOGARGS* we were given
            pArgs = (ADDURL_DIALOGARGS*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (pArgs == NULL)
                break;

            WCHAR rgszURL[2*MAX_PATH];
            if (0 != GetDlgItemText(hwnd, IDC_EDITURL, rgszURL, (2*MAX_PATH)) )
            {
                if (-1 == DetermineURLType(
                    pArgs->rgAllowedURLs,
                    pArgs->cAllowedURLs,
                    rgszURL))
                {
                    // not found; bail with message
                    WCHAR szMsg[MAX_PATH*2];
                    LoadString(g_hInstance, IDS_INVALID_PREFIX, szMsg, ARRAYSIZE(szMsg));
                    for(DWORD dw=0; dw<pArgs->cAllowedURLs; dw++)
                    {
                        wcscat(szMsg, L"\n");
                        wcscat(szMsg, pArgs->rgAllowedURLs[dw].szKnownPrefix);
                    }
                    MessageBox(hwnd, szMsg, NULL, MB_OK);
                    return FALSE;
                }

                DWORD chBadBegin, chBadEnd;
                if (S_OK != ValidateTokens(
                        rgszURL,
                        &chBadBegin,
                        &chBadEnd))
                {
                    // not found; bail with message
                    WCHAR szMsg[MAX_PATH*2];
                    LoadString(g_hInstance, IDS_INVALID_TOKEN, szMsg, ARRAYSIZE(szMsg));
                    MessageBox(hwnd, szMsg, NULL, MB_OK);

                    // set selection starting from where validation failed
                    SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_SETSEL, chBadBegin, chBadEnd);
                    return FALSE;
                }

                if (S_OK != IsValidIA5URL(rgszURL))
                {
                    // encoding error; bail with message
                    WCHAR szMsg[MAX_PATH*2];
                    LoadString(g_hInstance, IDS_INVALID_ENCODING, szMsg, ARRAYSIZE(szMsg));
                    MessageBox(hwnd, szMsg, NULL, MB_OK);

                    // set selection starting from where validation failed
                    SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_SETSEL,  -1, -1);
                    return FALSE;
                }

                *(pArgs->ppszNewURL) = (LPWSTR) LocalAlloc(LMEM_FIXED, (wcslen(rgszURL)+1)*sizeof(WCHAR));
                if(*(pArgs->ppszNewURL) == NULL)
                {
                   return FALSE;
                }
                wcscpy(*(pArgs->ppszNewURL), rgszURL);
            }
        }
        // fall through for cleanup
        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            break;
        default:
            break;
        }

    default:
        break;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// copied from K2 SDK policy.cpp.
// modified by GregKr for expolicy.
//
// File:        expolicy.cpp
//
// Contents:    KMS-specific Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "policy.h"
#include "celib.h"
//#include "newcert.h"
#include <assert.h>

#include <exver.h>      // Exchange build version (rmj et al)
#include <kmsattr.h>    // strings used by both KMS and ExPolicy

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

BOOL fDebug = DBG_CERTSRV;

#if DBG_CERTSRV
#define EXP_FLAVOR  L" debug"
#else
#define EXP_FLAVOR
#endif

#define MAKEFILEVERSION(_rmaj, _rmin, _bmaj, _bmin)         \
        L#_rmaj L"." L#_rmin L"." L#_bmaj L"." L#_bmin EXP_FLAVOR

#define MAKE_FILEVERSION_STR(_rmaj, _rmin, _bmaj, _bmin)	\
        MAKEFILEVERSION(_rmaj, _rmin, _bmaj, _bmin)

#define VER_FILEVERSION_STR				                    \
        MAKE_FILEVERSION_STR(rmj, rmn, rmm, rup)

const WCHAR g_wszDescription[] =
    L"Microsoft Exchange KMServer Policy Module " VER_FILEVERSION_STR;


// worker
HRESULT
GetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerPolicy,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerPolicy,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Policy:SetContext");
    }

error:
    return(hr);
}


WCHAR const * const s_rgpwszRegMultiStrValues[] =
{
    wszREGLDAPISSUERCERTURL_OLD,
    wszREGISSUERCERTURL_OLD,
    wszREGFTPISSUERCERTURL_OLD,
    wszREGFILEISSUERCERTURL_OLD,
    wszREGLDAPREVOCATIONCRLURL_OLD,
    wszREGREVOCATIONCRLURL_OLD,
    wszREGFTPREVOCATIONCRLURL_OLD,
    wszREGFILEREVOCATIONCRLURL_OLD,
};


typedef struct _REGDWORDVALUE
{
    WCHAR const *pwszName;
    DWORD        dwValueDefault;
} REGDWORDVALUE;

const REGDWORDVALUE s_rgRegDWordValues[] =
{
    {
	wszREGREQUESTDISPOSITION,
	REQDISP_ISSUE
    },
    {
	wszREGISSUERCERTURLFLAGS,
	ISSCERT_ENABLE |
	    ISSCERT_LDAPURL_OLD |
	    ISSCERT_HTTPURL_OLD |
	    ISSCERT_FTPURL_OLD |
	    ISSCERT_FILEURL_OLD
    },
    {
	wszREGREVOCATIONTYPE,
	REVEXT_CDPENABLE |
	    REVEXT_CDPLDAPURL_OLD |
	    REVEXT_CDPHTTPURL_OLD |
	    REVEXT_CDPFTPURL_OLD |
	    REVEXT_CDPFILEURL_OLD
    },
};


HRESULT
CopyMultiStrRegValue(
    IN HKEY hkeySrc,
    IN HKEY hkeyDest,
    IN WCHAR const *pwszName)
{
    HRESULT hr;
    DWORD cbValue;
    DWORD dwType;
    WCHAR *pwszzAlloc = NULL;
    WCHAR *pwszzValue;

    hr = RegQueryValueEx(hkeyDest, pwszName, NULL, &dwType, NULL, &cbValue);
    if (S_OK == hr && REG_MULTI_SZ == dwType)
    {
	goto error;	// preserve existing value
    }

    hr = RegQueryValueEx(hkeySrc, pwszName, NULL, &dwType, NULL, &cbValue);
    if (S_OK == hr && REG_MULTI_SZ == dwType && sizeof(WCHAR) < cbValue)
    {
	pwszzAlloc = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue);
	if (NULL == pwszzAlloc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hr = RegQueryValueEx(
			hkeySrc,
			pwszName,
			NULL,
			&dwType,
			(BYTE *) pwszzAlloc,
			&cbValue);
	_JumpIfError(hr, error, "RegQueryValueEx");

	pwszzValue = pwszzAlloc;
    }
    else
    {
	pwszzValue = L"\0";
	cbValue = 2 * sizeof(WCHAR);
    }

    hr = RegSetValueEx(
		    hkeyDest,
		    pwszName,
		    NULL,
		    REG_MULTI_SZ,
		    (BYTE const *) pwszzValue,
		    cbValue);
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != pwszzAlloc)
    {
        LocalFree(pwszzAlloc);
    }
    return(ceHError(hr));
}


HRESULT
CopyDWordRegValue(
    IN HKEY hkeySrc,
    IN HKEY hkeyDest,
    IN REGDWORDVALUE const *prdv)
{
    HRESULT hr;
    DWORD cbValue;
    DWORD dwType;
    DWORD dwValue;

    hr = RegQueryValueEx(hkeyDest, prdv->pwszName, NULL, &dwType, NULL, &cbValue);
    if (S_OK == hr && REG_DWORD == dwType)
    {
	goto error;	// preserve existing value
    }

    cbValue = sizeof(dwValue);
    hr = RegQueryValueEx(
		    hkeySrc,
		    prdv->pwszName,
		    NULL,
		    &dwType,
		    (BYTE *) &dwValue,
		    &cbValue);
    if (S_OK != hr || REG_DWORD != dwType || sizeof(dwValue) != cbValue)
    {
	dwValue = prdv->dwValueDefault;
    }

    hr = RegSetValueEx(
		    hkeyDest,
		    prdv->pwszName,
		    NULL,
		    REG_DWORD,
		    (BYTE const *) &dwValue,
		    sizeof(dwValue));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    return(ceHError(hr));
}


HRESULT
PopulateRegistryDefaults(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszStorageLocation)
{
    HRESULT hr;
    HRESULT hr2;
    HKEY hkeyHKLM = NULL;
    HKEY hkeyDest = NULL;
    HKEY hkeySrc = NULL;
    DWORD dwDisposition;
    WCHAR const *pwsz;
    WCHAR *pwszSrc = NULL;
    DWORD cwcPrefix;
    DWORD cwc;
    DWORD i;

    DBGPRINT((TRUE, "pwszDest: '%ws'\n", pwszStorageLocation));
    pwsz = wcsrchr(pwszStorageLocation, L'\\');
    if (NULL == pwsz)
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "Invalid registry path");
    }
    pwsz++;
    cwcPrefix = SAFE_SUBTRACT_POINTERS(pwsz, pwszStorageLocation);
    cwc = cwcPrefix + WSZARRAYSIZE(wszCLASS_CERTPOLICY);
    pwszSrc = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszSrc)
    {
	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszSrc, pwszStorageLocation, cwcPrefix * sizeof(WCHAR));
    wcscpy(&pwszSrc[cwcPrefix], wszCLASS_CERTPOLICY);
    assert(wcslen(pwszSrc) == cwc);

    DBGPRINT((TRUE, "pwszSrc: '%ws'\n", pwszSrc));

    if (NULL != pwszMachine)
    {
        hr = RegConnectRegistry(
			pwszMachine,
			HKEY_LOCAL_MACHINE,
			&hkeyHKLM);
        _JumpIfError(hr, error, "RegConnectRegistry");
    }

    // open destination storage location for write

    hr = RegCreateKeyEx(
		NULL == pwszMachine? HKEY_LOCAL_MACHINE : hkeyHKLM,
		pwszStorageLocation,
		0,
		NULL,
		0,
		KEY_READ | KEY_WRITE,
		NULL,
		&hkeyDest,
		&dwDisposition);
    if (hr != S_OK)
    {
        _JumpError(hr, error, "RegOpenKeyEx");
    }

    // open source storage location for read

    hr = RegOpenKeyEx(
		NULL == pwszMachine? HKEY_LOCAL_MACHINE : hkeyHKLM,
		pwszSrc,
		0,
		KEY_READ,
		&hkeySrc);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    hr = S_OK;
    for (i = 0; i < ARRAYSIZE(s_rgpwszRegMultiStrValues); i++)
    {
	hr2 = CopyMultiStrRegValue(
			hkeySrc,
			hkeyDest,
			s_rgpwszRegMultiStrValues[i]);
	if (S_OK != hr2)
	{
	    _PrintErrorStr(
			hr2,
			"CopyMultiStrRegValue",
			s_rgpwszRegMultiStrValues[i]);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

    for (i = 0; i < ARRAYSIZE(s_rgRegDWordValues); i++)
    {
	hr2 = CopyDWordRegValue(
			hkeySrc,
			hkeyDest,
			&s_rgRegDWordValues[i]);
	if (S_OK != hr2)
	{
	    _PrintErrorStr(
			hr2,
			"CopyDWordRegValue",
			s_rgRegDWordValues[i].pwszName);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }


error:
    if (NULL != pwszSrc)
    {
        LocalFree(pwszSrc);
    }
    if (NULL != hkeyHKLM)
    {
        RegCloseKey(hkeyHKLM);
    }
    if (NULL != hkeyDest)
    {
        RegCloseKey(hkeyDest);
    }
    if (NULL != hkeySrc)
    {
        RegCloseKey(hkeySrc);
    }
    return(ceHError(hr));
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::~CCertPolicyExchange -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertPolicyExchange::~CCertPolicyExchange()
{
    _Cleanup();
}


VOID
CCertPolicyExchange::_FreeStringArray(
    IN OUT DWORD *pcString,
    IN OUT LPWSTR **papstr)
{
    BSTR *apstr = *papstr;
    DWORD i;

    if (NULL != apstr)
    {
        for (i = *pcString; i-- > 0; )
        {
            if (NULL != apstr[i])
            {
                DBGPRINT((fDebug, "_FreeStringArray[%u]: '%ws'\n", i, apstr[i]));
                LocalFree(apstr[i]);
            }
        }
        LocalFree(apstr);
        *papstr = NULL;
    }
    *pcString = 0;
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_Cleanup -- free memory associated with this instance
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertPolicyExchange::_Cleanup()
{
    // RevocationExtension variables:

    _FreeStringArray(&m_cCDPRevocationURL, &m_ppwszCDPRevocationURL);

    if (NULL != m_pwszASPRevocationURL)
    {
        LocalFree(m_pwszASPRevocationURL);
    	m_pwszASPRevocationURL = NULL;
    }

    // AuthorityInfoAccessExtension variables:

    _FreeStringArray(&m_cIssuerCertURL, &m_ppwszIssuerCertURL);

    if (NULL != m_bstrMachineDNSName)
    {
        SysFreeString(m_bstrMachineDNSName);
        m_bstrMachineDNSName = NULL;
    }
    if (NULL != m_bstrCASanitizedName)
    {
        SysFreeString(m_bstrCASanitizedName);
        m_bstrCASanitizedName = NULL;
    }
}


HRESULT
CCertPolicyExchange::_ReadRegistryString(
    IN HKEY hkey,
    IN BOOL fURL,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszSuffix,
    OUT LPWSTR *ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    *ppwszOut = NULL;
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    NULL,
		    &cbValue);
    _JumpIfErrorStr2(hr, error, "RegQueryValueEx", pwszRegName, ERROR_FILE_NOT_FOUND);

    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpErrorStr(hr, error, "RegQueryValueEx TYPE", pwszRegName);
    }
    if (NULL != pwszSuffix)
    {
	cbValue += wcslen(pwszSuffix) * sizeof(WCHAR);
    }
    pwszRegValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
    if (NULL == pwszRegValue)
    {
        hr = E_OUTOFMEMORY;
        _JumpErrorStr(hr, error, "LocalAlloc", pwszRegName);
    }
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) pwszRegValue,
		    &cbValue);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", pwszRegName);

    // Handle malformed registry values cleanly:

    pwszRegValue[cbValue / sizeof(WCHAR)] = L'\0';
    if (NULL != pwszSuffix)
    {
	wcscat(pwszRegValue, pwszSuffix);
    }

    hr = ceFormatCertsrvStringArray(
			fURL,			// fURL
			m_bstrMachineDNSName, 	// pwszServerName_p1_2
			m_bstrCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			L"",			// pwszDomainDN_p5
			L"", 			// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9,
			FALSE,			// fDSAttrib_p10_11,
			1,       		// cStrings
			(LPCWSTR *) &pwszRegValue, // apwszStringsIn
			ppwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "ceFormatCertsrvStringArray");

error:
    if (NULL != pwszRegValue)
    {
        LocalFree(pwszRegValue);
    }
    return(ceHError(hr));
}


#if DBG_CERTSRV

VOID
CCertPolicyExchange::_DumpStringArray(
    IN char const *pszType,
    IN DWORD cpwsz,
    IN WCHAR const * const *ppwsz)
{
    DWORD i;
    WCHAR const *pwszName;

    for (i = 0; i < cpwsz; i++)
    {
	pwszName = L"";
	if (iswdigit(ppwsz[i][0]))
	{
	    pwszName = ceGetOIDName(ppwsz[i]);	// Static: do not free!
	}
	DBGPRINT((
		fDebug,
		"%hs[%u]: %ws%hs%ws\n",
		pszType,
		i,
		ppwsz[i],
		L'\0' != *pwszName? " -- " : "",
		pwszName));
    }
}
#endif // DBG_CERTSRV




HRESULT
CCertPolicyExchange::_AddStringArray(
    IN WCHAR const *pwszzValue,
    IN BOOL fURL,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr = S_OK;
    DWORD cString = 0;
    WCHAR const *pwsz;


    LPCWSTR *awszFormatStrings = NULL;
    LPWSTR *awszOutputStrings = NULL;


    // Count the number of strings we're adding
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        cString++;
    }
    if (0 == cString)		// no strings
    {
        goto error;
    }
    awszFormatStrings = (LPCWSTR *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cString * sizeof(LPWSTR));
    if (NULL == awszFormatStrings)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    cString = 0;
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        // Skip strings that start with a an unescaped minus sign.
        // Strings with an escaped minus sign (2 minus signs) are not skipped.

        if (L'-' == *pwsz)
        {
	    pwsz++;
	    if (L'-' != *pwsz)
	    {
                continue;
	    }
        }
        awszFormatStrings[cString++] = pwsz;
    }

    // if no strings to add, don't modify 
    if (cString > 0)
    {
        awszOutputStrings = (LPWSTR *) LocalAlloc(
			        LMEM_FIXED | LMEM_ZEROINIT,
			        (cString + *pcStrings)  * sizeof(LPWSTR));
        if (NULL == awszOutputStrings)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if (0 != *pcStrings)
        {
            assert(NULL != *papstrRegValues);
            CopyMemory(awszOutputStrings, *papstrRegValues, *pcStrings * sizeof(LPWSTR));
        }

        hr = ceFormatCertsrvStringArray(
			fURL,			// fURL
			m_bstrMachineDNSName,	// pwszServerName_p1_2
			m_bstrCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			L"",			// pwszDomainDN_p5
			L"",			// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9,
			FALSE,			// fDSAttrib_p10_11,
			cString,		// cStrings
			awszFormatStrings,	// apwszStringsIn
			&awszOutputStrings[*pcStrings]); // apwszStringsOut
        _JumpIfError(hr, error, "ceFormatCertsrvStringArray");

        *pcStrings = (*pcStrings) + cString;
        if (*papstrRegValues)
        {
            LocalFree(*papstrRegValues);
        }
        *papstrRegValues = awszOutputStrings;
        awszOutputStrings = NULL;
    }

error:

    if (awszOutputStrings)
    {
        LocalFree(awszOutputStrings);
    }
    if (awszFormatStrings)
    {
        LocalFree(awszFormatStrings);
    }
    return(ceHError(hr));
}


HRESULT
CCertPolicyExchange::_ReadRegistryStringArray(
    IN HKEY hkey,
    IN BOOL fURL,
    IN DWORD dwFlags,
    IN DWORD cRegNames,
    IN DWORD *aFlags,
    IN WCHAR const * const *apwszRegNames,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    for (i = 0; i < cRegNames; i++)
    {
        if (0 == (dwFlags & aFlags[i]))
        {
	    continue;
        }
        if (NULL != pwszzValue)
        {
	    LocalFree(pwszzValue);
	    pwszzValue = NULL;
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        NULL,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr2(hr, "RegQueryValueEx", apwszRegNames[i], ERROR_FILE_NOT_FOUND);
	    continue;
        }
        if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr(hr, "RegQueryValueEx TYPE", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly by adding two WCHAR L'\0's
	// allocate space for 3 WCHARs to allow for unaligned (odd) cbValue;

        pwszzValue = (WCHAR *) LocalAlloc(
				        LMEM_FIXED,
				        cbValue + 3 * sizeof(WCHAR));
        if (NULL == pwszzValue)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpErrorStr(hr, error, "LocalAlloc", apwszRegNames[i]);
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        (BYTE *) pwszzValue,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr(hr, "RegQueryValueEx", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly:

        pwszzValue[cbValue / sizeof(WCHAR)] = L'\0';
        pwszzValue[cbValue / sizeof(WCHAR) + 1] = L'\0';

        hr = _AddStringArray(pwszzValue, fURL, pcStrings, papstrRegValues);
        _JumpIfErrorStr(hr, error, "_AddStringArray", apwszRegNames[i]);
    }
    hr = S_OK;

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_InitRevocationExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyExchange::_InitRevocationExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;
    DWORD adwFlags[] = {
		REVEXT_CDPLDAPURL_OLD,
		REVEXT_CDPHTTPURL_OLD,
		REVEXT_CDPFTPURL_OLD,
		REVEXT_CDPFILEURL_OLD,
	    };
    WCHAR *apwszRegNames[] = {
		wszREGLDAPREVOCATIONCRLURL_OLD,
		wszREGREVOCATIONCRLURL_OLD,
		wszREGFTPREVOCATIONCRLURL_OLD,
		wszREGFILEREVOCATIONCRLURL_OLD,
	    };

    cb = sizeof(m_dwRevocationFlags);
    hr = RegQueryValueEx(
                hkey,
                wszREGREVOCATIONTYPE,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwRevocationFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwRevocationFlags) != cb)
    {
        goto error;
    }
    DBGPRINT((fDebug, "Revocation Flags = %x\n", m_dwRevocationFlags));


    // clean up from previous call
    if (NULL != m_ppwszCDPRevocationURL)
    {
        _FreeStringArray(&m_cCDPRevocationURL, &m_ppwszCDPRevocationURL);
    }

    if (NULL != m_pwszASPRevocationURL)
    {
        LocalFree(m_pwszASPRevocationURL);
        m_pwszASPRevocationURL = NULL;
    }

    if (REVEXT_CDPENABLE & m_dwRevocationFlags)
    {
        assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));
        hr = _ReadRegistryStringArray(
			    hkey,
			    TRUE,			// fURL
			    m_dwRevocationFlags,
			    ARRAYSIZE(adwFlags),
			    adwFlags,
			    apwszRegNames,
			    &m_cCDPRevocationURL,
			    &m_ppwszCDPRevocationURL);
        _JumpIfError(hr, error, "_ReadRegistryStringArray");

        _DumpStringArray("CDP", m_cCDPRevocationURL, m_ppwszCDPRevocationURL);
    }

    if (REVEXT_ASPENABLE & m_dwRevocationFlags)
    {
        hr = _ReadRegistryString(
			    hkey,
			    TRUE,			// fURL
			    wszREGREVOCATIONURL,	// pwszRegName
			    L"?",			// pwszSuffix
			    &m_pwszASPRevocationURL);	// pstrRegValue
        _JumpIfErrorStr(hr, error, "_ReadRegistryString", wszREGREVOCATIONCRLURL_OLD);
        _DumpStringArray("ASP", 1, &m_pwszASPRevocationURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_InitAuthorityInfoAccessExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyExchange::_InitAuthorityInfoAccessExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;
    DWORD adwFlags[] = {
		ISSCERT_LDAPURL_OLD,
		ISSCERT_HTTPURL_OLD,
		ISSCERT_FTPURL_OLD,
		ISSCERT_FILEURL_OLD,
	    };
    WCHAR *apwszRegNames[] = {
		wszREGLDAPISSUERCERTURL_OLD,
		wszREGISSUERCERTURL_OLD,
		wszREGFTPISSUERCERTURL_OLD,
		wszREGFILEISSUERCERTURL_OLD,
	    };

    // clean up from previous call
    if (NULL != m_ppwszIssuerCertURL)
    {
        _FreeStringArray(&m_cIssuerCertURL, &m_ppwszIssuerCertURL);
    }



    cb = sizeof(m_dwIssuerCertURLFlags);
    hr = RegQueryValueEx(
                hkey,
		wszREGISSUERCERTURLFLAGS,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwIssuerCertURLFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwIssuerCertURLFlags) != cb)
    {
        goto error;
    }
    DBGPRINT((fDebug, "Issuer Cert Flags = %x\n", m_dwIssuerCertURLFlags));

    if (ISSCERT_ENABLE & m_dwIssuerCertURLFlags)
    {
        assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));
        hr = _ReadRegistryStringArray(
				hkey,
				TRUE,			// fURL
				m_dwIssuerCertURLFlags,
				ARRAYSIZE(adwFlags),
				adwFlags,
				apwszRegNames,
				&m_cIssuerCertURL,
				&m_ppwszIssuerCertURL);
        _JumpIfError(hr, error, "_ReadRegistryStringArray");

        _DumpStringArray("Issuer Cert", m_cIssuerCertURL, m_ppwszIssuerCertURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::Initialize(
    /* [in] */ BSTR const strConfig)
{
    HRESULT hr;
    HKEY hkey = NULL;
    VARIANT varValue;
    ICertServerPolicy *pServer = NULL;

    VariantInit(&varValue);

    _Cleanup();

    hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

    // get storage location

    hr = pServer->GetCertificateProperty(
				wszPROPMODULEREGLOC,
				PROPTYPE_STRING,
				&varValue);
    _JumpIfError(hr, error, "GetCertificateProperty : wszPROPMODULEREGLOC");

    m_pwszRegStorageLoc = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(varValue.bstrVal) + 1) * sizeof(WCHAR));
    if (NULL == m_pwszRegStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }
    wcscpy(m_pwszRegStorageLoc, varValue.bstrVal);
    VariantClear(&varValue);

    hr = PopulateRegistryDefaults(NULL, m_pwszRegStorageLoc);
    _PrintIfError(hr, "Policy:PopulateRegistryDefaults");

    hr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
		m_pwszRegStorageLoc,
                0,              // dwReserved
                KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                &hkey);

    if ((HRESULT) ERROR_SUCCESS != hr)
    {
	hr = HRESULT_FROM_WIN32(hr);
	_JumpIfError(hr, error, "RegOpenKeyEx");
    }

    // Initialize the insertion string array.
    // Machine DNS name (%1)

    hr = pServer->GetCertificateProperty(
				wszPROPMACHINEDNSNAME,
				PROPTYPE_STRING,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", wszPROPMACHINEDNSNAME);

    m_bstrMachineDNSName = SysAllocString(varValue.bstrVal);
    if (NULL == m_bstrMachineDNSName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    VariantClear(&varValue);

    hr = pServer->GetCertificateProperty(
				wszPROPCERTCOUNT,
				PROPTYPE_LONG,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", wszPROPCERTCOUNT);

    m_iCert = varValue.lVal - 1;

    hr = pServer->GetCertificateProperty(
				wszPROPCRLINDEX,
				PROPTYPE_LONG,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", wszPROPCRLINDEX);

    m_iCRL = varValue.lVal;

    // get sanitized name

    hr = pServer->GetCertificateProperty(
				wszPROPSANITIZEDCANAME,
				PROPTYPE_STRING,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", wszPROPSANITIZEDCANAME);

    m_bstrCASanitizedName = SysAllocString(varValue.bstrVal);
    if (NULL == m_bstrCASanitizedName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    VariantClear(&varValue);

    _InitRevocationExtension(hkey);
    _InitAuthorityInfoAccessExtension(hkey);
    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(hr);
}


HRESULT
EnumerateExtensions(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varValue;
    BOOL fClose = FALSE;

    VariantInit(&varValue);
    hr = pServer->EnumerateExtensionsSetup(0);
    _JumpIfError(hr, error, "EnumerateExtensionsSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateExtensions(&strName);
        if (S_OK != hr)
        {
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
	    _JumpError(hr, error, "EnumerateExtensions");
        }
        hr = pServer->GetCertificateExtension(
                                        strName,
                                        PROPTYPE_BINARY,
                                        &varValue);
	_JumpIfError(hr, error, "GetCertificateExtension");

        hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "GetCertificateExtensionFlags");

        if (fDebug)
        {
            wprintf(
                L"Policy:EnumerateExtensions(%ws, Flags=%x, %x bytes)\n",
                strName,
                ExtFlags,
                SysStringByteLen(varValue.bstrVal));
        }
        VariantClear(&varValue);
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateExtensionsClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateExtensionsClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    VariantClear(&varValue);
    return(hr);
}


HRESULT
EnumerateAttributes(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    BOOL fClose = FALSE;
    BSTR strValue = NULL;

    hr = pServer->EnumerateAttributesSetup(0);
    _JumpIfError(hr, error, "EnumerateAttributesSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateAttributes(&strName);
        if (S_OK != hr)
        {
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
	    _JumpError(hr, error, "EnumerateAttributes");
        }

        hr = pServer->GetRequestAttribute(strName, &strValue);
	_JumpIfError(hr, error, "GetRequestAttribute");

        if (fDebug)
        {
            wprintf(
                L"Policy:EnumerateAttributes(%ws = %ws)\n",
                strName,
                strValue);
        }
        if (NULL != strValue)
        {
            SysFreeString(strValue);
            strValue = NULL;
        }
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateAttributesClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateAttributesClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
CheckRequestProperties(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    BSTR strName = NULL;

    VariantInit(&varValue);

    strName = SysAllocString(wszPROPREQUESTREQUESTID);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestProperty(strName, PROPTYPE_LONG, &varValue);
    _JumpIfError(hr, error, "GetRequestProperty");

    if (fDebug)
    {
        wprintf(
            L"Policy:CheckRequestProperties(%ws = %x)\n",
            strName,
            varValue.lVal);
    }
    VariantClear(&varValue);

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddRevocationExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddRevocationExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    ICertEncodeCRLDistInfo *pCRLDist = NULL;
    BSTR strCDPExtension = NULL;
    VARIANT varExtension;
    DWORD i;

    varExtension.vt = VT_BSTR;
    if (NULL != m_ppwszCDPRevocationURL)
    {
	hr = CoCreateInstance(
			CLSID_CCertEncodeCRLDistInfo,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeCRLDistInfo,
			(VOID **) &pCRLDist);
	_JumpIfError(hr, error, "CoCreateInstance");

	hr = pCRLDist->Reset(m_cCDPRevocationURL);
	_JumpIfError(hr, error, "Reset");

	for (i = 0; i < m_cCDPRevocationURL; i++)
	{
	    DWORD j;

	    hr = pCRLDist->SetNameCount(i, 1);
	    _JumpIfError(hr, error, "SetNameCount");

	    for (j = 0; j < 1; j++)
	    {
		hr = pCRLDist->SetNameEntry(
					i,
					j,
					CERT_ALT_NAME_URL,
					m_ppwszCDPRevocationURL[i]);
		_JumpIfError(hr, error, "SetNameEntry");
	    }
	}
	hr = pCRLDist->Encode(&strCDPExtension);
	_JumpIfError(hr, error, "Encode");

	varExtension.bstrVal = strCDPExtension;
	hr = pServer->SetCertificateExtension(
				TEXT(szOID_CRL_DIST_POINTS),
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "SetCertificateExtension", L"CDP");
    }
    if (NULL != m_pwszASPRevocationURL)
    {
	varExtension.bstrVal = SysAllocString(m_pwszASPRevocationURL);
	hr = pServer->SetCertificateExtension(
				TEXT(szOID_NETSCAPE_REVOCATION_URL),
				PROPTYPE_STRING,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "SetCertificateExtension", L"ASP");
	VariantClear(&varExtension);
    }

error:
    if (NULL != strCDPExtension)
    {
        SysFreeString(strCDPExtension);
    }
    if (NULL != pCRLDist)
    {
        pCRLDist->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddAuthorityInfoAccessExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddAuthorityInfoAccessExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    DWORD i;

    CERT_AUTHORITY_INFO_ACCESS caio;
    caio.rgAccDescr = NULL;

    if (NULL == m_ppwszIssuerCertURL)
    {
	goto error;
    }

    caio.cAccDescr = m_cIssuerCertURL;
    caio.rgAccDescr = (CERT_ACCESS_DESCRIPTION *) LocalAlloc(
			LMEM_FIXED,
			sizeof(CERT_ACCESS_DESCRIPTION) * m_cIssuerCertURL);
    if (NULL == caio.rgAccDescr)
    {
        hr = E_OUTOFMEMORY;
	_JumpIfError(hr, error, "LocalAlloc");
    }

    for (i = 0; i < m_cIssuerCertURL; i++)
    {
	caio.rgAccDescr[i].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
	caio.rgAccDescr[i].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
	caio.rgAccDescr[i].AccessLocation.pwszURL = m_ppwszIssuerCertURL[i];
    }

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	_JumpIfError(hr, error, "Policy:ceEncodeObject");
    }
    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_AUTHORITY_INFO_ACCESS),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension(AuthInfoAccess)");

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != caio.rgAccDescr)
    {
        LocalFree(caio.rgAccDescr);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddIssuerAltName2Extension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddIssuerAltName2Extension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strCertType = NULL;
    BSTR strName = NULL;
    BSTR strValue = NULL;
    BSTR strKMServerName = NULL;

    LPBYTE  pbEncName   = NULL;
    ULONG   cbEncName   = 0;

    LPBYTE  pbEncExten  = NULL;
    ULONG   cbEncExten  = 0;

    CERT_ALT_NAME_ENTRY cane    = { 0 };
    CERT_ALT_NAME_INFO  cani    = { 0 };

    strKMServerName = SysAllocString(k_wszKMServerName);
    if (NULL == strKMServerName)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strKMServerName, &strValue);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszKMServerName);

    // CertStrToName to turn string into encoded name blob

    if (!CertStrToNameW(
		X509_ASN_ENCODING,
		strValue,
		CERT_X500_NAME_STR,
		NULL,
		NULL,
		&cbEncName,
		NULL))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CertStrToNameW");
    }

    pbEncName = new BYTE [cbEncName];
    if (NULL == pbEncName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "new");
    }

    if (!CertStrToNameW(
		X509_ASN_ENCODING,
		strValue,
		CERT_X500_NAME_STR,
		NULL,
		pbEncName,
		&cbEncName,
		NULL))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CertStrToNameW");
    }

    // fill in alt name info

    cane.dwAltNameChoice        = CERT_ALT_NAME_DIRECTORY_NAME;
    cane.DirectoryName.cbData   = cbEncName;
    cane.DirectoryName.pbData   = pbEncName;

    cani.cAltEntry  = 1;
    cani.rgAltEntry = &cane;

    // encode alt name info

    if (!CryptEncodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		&cani,
		NULL,
		&cbEncExten))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncExten = new BYTE [cbEncExten];
    if (NULL == pbEncExten)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		&cani,
		pbEncExten,
		&cbEncExten))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CryptEncodeObject");
    }

    strExtension = SysAllocStringByteLen((char *) pbEncExten, cbEncExten);

    // add extension

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_ISSUER_ALT_NAME2),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension(IssuerAltName2)");

error:
    delete pbEncName;
    delete pbEncExten;
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strKMServerName)
    {
        SysFreeString(strKMServerName);
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddSubjectAltName2Extension
//
// Returns S_OK on success.
// Returns S_FALSE for special request.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddSubjectAltName2Extension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strCertType = NULL;
    BSTR strName = NULL;
    BSTR strDisplay = NULL;
    BSTR strRFC822 = NULL;

    BSTR strSubjAltNameRFC822 = NULL;
    BSTR strSubjAltNameDisplay = NULL;

    LPBYTE  pbEncName   = NULL;
    ULONG   cbEncName   = 0;

    LPBYTE  pbEncExten  = NULL;
    ULONG   cbEncExten  = 0;

    CERT_RDN_ATTR       rdnattr = { 0 };
    CERT_RDN            rdn     = { 0 };
    CERT_NAME_INFO      cni     = { 0 };
    CERT_ALT_NAME_ENTRY acane   [2] = { 0 };
    CERT_ALT_NAME_INFO  cani    = { 0 };

    strSubjAltNameDisplay = SysAllocString(k_wszSubjAltNameDisplay);
    if (NULL == strSubjAltNameDisplay)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strSubjAltNameDisplay, &strDisplay);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszSubjAltNameDisplay);

    strSubjAltNameRFC822 = SysAllocString(k_wszSubjAltNameRFC822);
    if (NULL == strSubjAltNameRFC822)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strSubjAltNameRFC822, &strRFC822);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszSubjAltNameRFC822);

    // this identifies special request from KMS

    if (0 == lstrcmpW(strDisplay, k_wszSpecialAttribute) &&
        0 == lstrcmpW(strRFC822, k_wszSpecialAttribute))
    {
        hr = _AddSpecialAltNameExtension(pServer);
	_JumpIfError(hr, error, "_AddSpecialAltNameExtension");

        // there are no subject names to add, so exit

        goto error;
    }

    // encode display name

    rdnattr.pszObjId        = szOID_COMMON_NAME;
    rdnattr.dwValueType     = CERT_RDN_UNICODE_STRING;
    rdnattr.Value.cbData    = SysStringByteLen(strDisplay);
    rdnattr.Value.pbData    = (LPBYTE) strDisplay;

    rdn.cRDNAttr    = 1;
    rdn.rgRDNAttr   = &rdnattr;

    cni.cRDN    = 1;
    cni.rgRDN   = &rdn;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME,
		    &cni,
		    NULL,
		    &cbEncName))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncName = new BYTE [cbEncName];
    if (NULL == pbEncName)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME,
		    &cni,
		    pbEncName,
		    &cbEncName))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    // fill in alt name info

    acane[0].dwAltNameChoice        = CERT_ALT_NAME_DIRECTORY_NAME;
    acane[0].DirectoryName.cbData   = cbEncName;
    acane[0].DirectoryName.pbData   = pbEncName;

    acane[1].dwAltNameChoice        = CERT_ALT_NAME_RFC822_NAME;
    acane[1].pwszRfc822Name         = strRFC822;

    cani.cAltEntry  = 2;
    cani.rgAltEntry = acane;

    // encode alt name info

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &cani,
		    NULL,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncExten = new BYTE [cbEncExten];
    if (NULL == pbEncExten)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &cani,
		    pbEncExten,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    strExtension = SysAllocStringByteLen((char*) pbEncExten, cbEncExten);

    // add extension

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			TEXT(szOID_SUBJECT_ALT_NAME2),
			PROPTYPE_BINARY,
			0,
			&varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strSubjAltNameRFC822)
    {
        SysFreeString(strSubjAltNameRFC822);
    }
    if (NULL != strSubjAltNameDisplay)
    {
        SysFreeString(strSubjAltNameDisplay);
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddSpecialAltNameExtension
//
// in response to request with both display and RFC822 equal to special value,
// fetch version info for CertSrv.exe and ExPolicy.dll, encode as multi-byte
// int, and set as IssuerAltName, marked critical. this should make cert
// unusable.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddSpecialAltNameExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr              = S_OK;
    BSTR    strExtension    = NULL;
    VARIANT varExtension;

    HRSRC   hExeVersion         = NULL;
    HGLOBAL hExeVersionInMem    = NULL;
    LPBYTE  pExeVersion         = NULL;

    // [0] to [3] are ExPolicy version.
    // [4] to [7] are CertServer version.
    WORD    awVersions   [] =
            { rmj, rmn, rmm, rup, 0, 0, 0, 0 };

    ULONG   ndxCertServer   = 4;

    CRYPT_INTEGER_BLOB  intblobVersions = { 0 };

    LPBYTE  pbEncExten  = NULL;
    ULONG   cbEncExten  = 0;

    // fill in version info

    if (NULL == (hExeVersion =
                    FindResource(NULL, MAKEINTRESOURCE(1), RT_VERSION)) ||
        NULL == (hExeVersionInMem = LoadResource(NULL, hExeVersion)) ||
        NULL == (pExeVersion = (LPBYTE) LockResource(hExeVersionInMem)))
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Find/Load/LockResource");
    }

    awVersions[ndxCertServer]       = ((LPWORD)pExeVersion)[25];
    awVersions[ndxCertServer + 1]   = ((LPWORD)pExeVersion)[24];
    awVersions[ndxCertServer + 2]   = ((LPWORD)pExeVersion)[27];
    awVersions[ndxCertServer + 3]   = ((LPWORD)pExeVersion)[26];

    intblobVersions.cbData  = sizeof(awVersions);
    intblobVersions.pbData  = (LPBYTE) awVersions;

    // encode version info

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_MULTI_BYTE_INTEGER,
		    &intblobVersions,
		    NULL,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncExten = new BYTE [cbEncExten];
    if (NULL == pbEncExten)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_MULTI_BYTE_INTEGER,
		    &intblobVersions,
		    pbEncExten,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    strExtension = SysAllocStringByteLen((char *) pbEncExten, cbEncExten);

    // add extension

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			TEXT(szOID_ISSUER_ALT_NAME),
			PROPTYPE_BINARY,
			EXTENSION_CRITICAL_FLAG,
			&varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:

    delete pbEncExten;

    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddBasicConstraintsExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_BASIC_CONSTRAINTS2_INFO bc2i;
    BSTR strExtension = NULL;
    VARIANT varExtension;

    bc2i.fCA = FALSE;
    bc2i.fPathLenConstraint = FALSE;
    bc2i.dwPathLenConstraint = 0;

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_BASIC_CONSTRAINTS2,
		    &bc2i,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = GetLastError();
	_JumpError(hr, error, "ceEncodeObject");
    }
    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_BASIC_CONSTRAINTS2),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strName = NULL;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BYTE KeyUsage = 0;
    BSTR strBitString = NULL;
    BSTR strKeyUsage = NULL;
    BSTR strValue = NULL;

    strKeyUsage = SysAllocString(k_wszKeyUsage);
    if (NULL == strKeyUsage)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strKeyUsage, &strValue);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszKeyUsage);

    if (0 == wcscmp(strValue, k_wszUsageSealing))
    {
	KeyUsage =  CERT_KEY_ENCIPHERMENT_KEY_USAGE;
    }
    else
    if (0 == wcscmp(strValue, k_wszUsageSigning))
    {
	KeyUsage =  CERT_DIGITAL_SIGNATURE_KEY_USAGE |
			CERT_NON_REPUDIATION_KEY_USAGE;
    }
    else
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "KeyUsage");
    }

    hr = CoCreateInstance(
		    CLSID_CCertEncodeBitString,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertEncodeBitString,
		    (VOID **) &pBitString);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (!ceConvertWszToBstr(
		&strBitString,
		(WCHAR const *) &KeyUsage,
		sizeof(KeyUsage)))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }

    hr = pBitString->Encode(
			sizeof(KeyUsage) * 8,
			strBitString,
			&strExtension);
    _JumpIfError(hr, error, "Encode");

    if (!ceConvertWszToBstr(&strName, TEXT(szOID_KEY_USAGE), -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    EXTENSION_CRITICAL_FLAG,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != strKeyUsage)
    {
        SysFreeString(strKeyUsage);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddEnhancedKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddEnhancedKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strName = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_ENHKEY_USAGE ceu;
    LPSTR pszEnhUsage = szOID_PKIX_KP_EMAIL_PROTECTION;

    ceu.cUsageIdentifier        = 1;
    ceu.rgpszUsageIdentifier    = &pszEnhUsage; // array of pszObjId

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ENHANCED_KEY_USAGE,
		    &ceu,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = GetLastError();
	_JumpError(hr, error, "ceEncodeObject");
    }

    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }

    if (!ceConvertWszToBstr(&strName, TEXT(szOID_ENHANCED_KEY_USAGE), -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != pbEncoded)
    {
	    LocalFree(pbEncoded);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::VerifyRequest
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::VerifyRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Context,
    /* [in] */ LONG bNewRequest,
    /* [in] */ LONG Flags,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    ICertServerPolicy *pServer = NULL;

    hr = GetServerCallbackInterface(&pServer, Context);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

    if (fDebug)
    {
        hr = EnumerateAttributes(pServer);
	_JumpIfError(hr, error, "EnumerateAttributes");

        hr = EnumerateExtensions(pServer);
	_JumpIfError(hr, error, "EnumerateExtensions");
    }
    hr = _AddIssuerAltName2Extension(pServer);
    _JumpIfError(hr, error, "_AddIssuerAltName2Extension");

    // also handles 'special' KMS request

    hr = _AddSubjectAltName2Extension(pServer);
    _JumpIfError(hr, error, "_AddSubjectAltName2Extension");

    hr = _AddBasicConstraintsExtension(pServer);
    _JumpIfError(hr, error, "_AddBasicConstraintsExtension");

    hr = _AddRevocationExtension(pServer);
    _JumpIfError(hr, error, "_AddRevocationExtension");

    hr = _AddAuthorityInfoAccessExtension(pServer);
    _JumpIfError(hr, error, "_AddAuthorityInfoAccessExtension");

    hr = _AddKeyUsageExtension(pServer);
    _JumpIfError(hr, error, "_AddKeyUsageExtension");

    hr = _AddEnhancedKeyUsageExtension(pServer);
    _JumpIfError(hr, error, "_AddEnhancedKeyUsageExtension");

    if (fDebug)
    {
        hr = EnumerateExtensions(pServer);
	_JumpIfError(hr, error, "EnumerateExtensions");
    }
    hr = CheckRequestProperties(pServer);
    _JumpIfError(hr, error, "_AddRevocationExtension");

error:
    *pDisposition = S_OK == hr? VR_INSTANT_OK : VR_INSTANT_BAD;
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::GetDescription
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::GetDescription(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription)
{
    HRESULT hr = S_OK;

    *pstrDescription = SysAllocString(g_wszDescription);
    if (NULL == *pstrDescription)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::ShutDown
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::ShutDown(VOID)
{
    return(S_OK);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------
STDMETHODIMP
CCertPolicyExchange::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;

    *ppManageModule = NULL;
    hr = CoCreateInstance(
                    CLSID_CCertManagePolicyModuleExchange,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


STDMETHODIMP
CCertPolicyExchange::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID *arr[] =
    {
        &IID_ICertPolicy,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
        {
            return(S_OK);
        }
    }
    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by expolicy.rc
//

#define IDS_CERTPOLICY_DESC             1
#define IDS_CERTMANAGEPOLICYMODULE_DESC 2

#define IDS_MODULE_NAME                 101
#define IDS_MODULE_COPYRIGHT            102
#define IDS_MODULE_FILEVER              103
#define IDS_MODULE_PRODUCTVER           104
#define IDS_WARNING_REBOOT              105
#define IDS_WARNING_NOSAVE              106
#define IDS_INVALID_PREFIX              107
#define IDS_INVALID_TOKEN               108
#define IDS_INVALID_ENCODING            109

#define IDC_RADIO_ISSUE                 201
#define IDC_EDITURL                     202
#define IDC_ADD_CRL                     203
#define IDC_REMOVE_CRL                  204
#define IDC_ADD_AIA                     205
#define IDC_REMOVE_AIA                  206
#define IDC_TEXT_PENDFIRST              207
#define IDC_RADIO_PENDFIRST             208
#define IDC_CRL_LIST                    209
#define IDC_AIA_LIST                    210

#define IDD_ADDURL                      301
#define IDD_POLICYPG1                   302
#define IDD_POLICYPG2                   303

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\expolicy\policy.h ===
// policy.h: Declaration of CCertPolicyExchange


#include "expolicy.h"
#include "resource.h"       // main symbols

#ifndef __BSTRC__DEFINED__
#define __BSTRC__DEFINED__
typedef OLECHAR const *BSTRC;
#endif

extern const WCHAR g_wszDescription[];

/////////////////////////////////////////////////////////////////////////////
// certpol

HRESULT
GetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context);

HRESULT
PopulateRegistryDefaults(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszStorageLocation);

class CCertPolicyExchange: 
    public CComDualImpl<ICertPolicy2, &IID_ICertPolicy2, &LIBID_CERTPOLICYEXCHANGELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertPolicyExchange, &CLSID_CCertPolicyExchange>
{
public:
    CCertPolicyExchange()
    {
        // RevocationExtension variables:

	m_dwRevocationFlags = 0;
	m_cCDPRevocationURL = 0;
	m_ppwszCDPRevocationURL = NULL;
	m_pwszASPRevocationURL = NULL;

	// AuthorityInfoAccessExtension variables:

        m_dwIssuerCertURLFlags = 0;
        m_cIssuerCertURL = 0;
	m_ppwszIssuerCertURL = NULL;

	m_bstrMachineDNSName = NULL;
	m_bstrCASanitizedName = NULL;
        m_pwszRegStorageLoc = NULL;
    }
    ~CCertPolicyExchange();

BEGIN_COM_MAP(CCertPolicyExchange)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertPolicy)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertPolicyExchange) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertPolicyExchange,
    wszCLASS_CERTPOLICYEXCHANGE TEXT(".1"),
    wszCLASS_CERTPOLICYEXCHANGE,
    IDS_CERTPOLICY_DESC,
    THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICertPolicy
public:
    STDMETHOD(Initialize)( 
	    /* [in] */ BSTR const strConfig);

    STDMETHOD(VerifyRequest)( 
	    /* [in] */ BSTR const strConfig,
	    /* [in] */ LONG Context,
	    /* [in] */ LONG bNewRequest,
	    /* [in] */ LONG Flags,
	    /* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetDescription)( 
	    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription);

    STDMETHOD(ShutDown)();

// ICertPolicy2
public:
    STDMETHOD(GetManageModule)(
                /* [out, retval] */ ICertManageModule **ppManageModule);

private:
    VOID _Cleanup();

#if DBG_CERTSRV
    VOID _DumpStringArray(
		IN char const *pszType,
		IN DWORD cpwsz,
		IN WCHAR const * const *ppwsz);
#else
    #define _DumpStringArray(pszType, cpwsz, ppwsz)
#endif

    VOID _FreeStringArray(
		IN OUT DWORD *pcString,
		IN OUT WCHAR ***pppwsz);

    HRESULT _AddStringArray(
		IN WCHAR const *pwszzValue,
		IN BOOL fURL,
		IN OUT DWORD *pcStrings,
		IN OUT WCHAR ***pppwszRegValues);

    HRESULT _ReadRegistryString(
		IN HKEY hkey,
		IN BOOL fURL,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszSuffix,
		OUT WCHAR **pwszRegValue);

    HRESULT _ReadRegistryStringArray(
		IN HKEY hkey,
		IN BOOL fURL,
		IN DWORD dwFlags,
		IN DWORD cRegNames,
		IN DWORD *aFlags,
		IN WCHAR const * const *ppwszRegNames,
		IN OUT DWORD *pcStrings,
		IN OUT WCHAR ***pppwszRegValues);

    VOID _InitRevocationExtension(
		IN HKEY hkey);

    VOID _InitAuthorityInfoAccessExtension(
		IN HKEY hkey);

    HRESULT _AddIssuerAltName2Extension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddSubjectAltName2Extension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddRevocationExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddAuthorityInfoAccessExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddEnhancedKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddSpecialAltNameExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddBasicConstraintsExtension(
                IN ICertServerPolicy *pServer);

private:
    // Add local variables here!

    // RevocationExtension variables:

    DWORD   m_dwRevocationFlags;
    DWORD   m_cCDPRevocationURL;
    WCHAR **m_ppwszCDPRevocationURL;
    WCHAR  *m_pwszASPRevocationURL;

    // AuthorityInfoAccessExtension variables:

    DWORD   m_dwIssuerCertURLFlags;
    DWORD   m_cIssuerCertURL;
    WCHAR **m_ppwszIssuerCertURL;

    BSTR    m_bstrMachineDNSName;
    BSTR    m_bstrCASanitizedName;
    WCHAR  *m_pwszRegStorageLoc;

    DWORD   m_iCert;
    DWORD   m_iCRL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:	$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\certpsam.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certpsam.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "policy.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertPolicySample, CCertPolicySample)
    OBJECT_ENTRY(CLSID_CCertManagePolicyModuleSample, CCertManagePolicyModuleSample)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(size_t cb)
{
    return(LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb));
}


void __RPC_USER
MIDL_user_free(void __RPC_FAR *pb)
{
    LocalFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManagePolicyModuleSample definition
//
//---------------------------------------------------------------------------

#include "certpsam.h"
#include "resource.h"       // main symbols


class CCertManagePolicyModuleSample: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYSAMPLELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModuleSample, &CLSID_CCertManagePolicyModuleSample>
{
public:
    CCertManagePolicyModuleSample() {}
    ~CCertManagePolicyModuleSample() {}

BEGIN_COM_MAP(CCertManagePolicyModuleSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModuleSample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManagePolicyModuleSample,
    wszCLASS_CERTMANAGEPOLICYMODULESAMPLE TEXT(".1"),
    wszCLASS_CERTMANAGEPOLICYMODULESAMPLE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include "module.h"
#include "policy.h"


STDMETHODIMP
CCertManagePolicyModuleSample::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    LPWSTR szStr = NULL;
    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == wcscmp(strPropertyName, wszCMM_PROP_NAME))
        szStr = wsz_SAMPLE_NAME;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
        szStr = wsz_SAMPLE_DESCRIPTION;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        szStr = wsz_SAMPLE_COPYRIGHT;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_FILEVER))
        szStr = wsz_SAMPLE_FILEVER;
    else if (0 == wcscmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        szStr = wsz_SAMPLE_PRODUCTVER;
    else
        return S_FALSE;  

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManagePolicyModuleSample::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty)
{
     // no settable properties supported
     return S_FALSE;
}
        
STDMETHODIMP
CCertManagePolicyModuleSample::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG Flags)
{
    MessageBox(NULL, L"No Configurable Options", NULL, MB_OK|MB_ICONINFORMATION);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\policy0.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        policy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#define wszCLASS_CERTPOLICYSAMPLEPREFIX TEXT("CertAuthority_Sample") 

#define wszCLASS_CERTPOLICYSAMPLE wszCLASS_CERTPOLICYSAMPLEPREFIX  wszCERTPOLICYMODULE_POSTFIX

#define wszCLASS_CERTMANAGEPOLICYMODULESAMPLE wszCLASS_CERTPOLICYSAMPLEPREFIX wszCERTMANAGEPOLICY_POSTFIX

#define wsz_SAMPLE_NAME           L"Sample/Test Policy Module"
#define wsz_SAMPLE_DESCRIPTION    L"Sample Policy Module"
#define wsz_SAMPLE_COPYRIGHT      L"(c)2000 Microsoft"
#define wsz_SAMPLE_FILEVER        L"v 1.0"
#define wsz_SAMPLE_PRODUCTVER     L"v 5.00"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        policy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif


// worker
HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Policy:polGetServerCallbackInterface");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerPolicy,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerPolicy,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Policy:CoCreateInstance");

    if (NULL == *ppServer)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Policy:CoCreateInstance");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Policy:SetContext");
    }

error:
    return hr;
}


HRESULT
polGetProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN DWORD PropType,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    VariantClear(pvarOut);
    strName = SysAllocString(pwszPropertyName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    if (fRequest)
    {
	hr = pServer->GetRequestProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetRequestProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = pServer->GetCertificateProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetCertificateProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polGetStringProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    hr = polGetProperty(pServer, fRequest, PROPTYPE_STRING, pwszPropertyName, &var);
    _JumpIfError2(
	    hr,
	    error,
	    "Policy:polGetProperty",
	    CERTSRV_E_PROPERTY_EMPTY);

    if (VT_BSTR != var.vt || NULL == var.bstrVal || L'\0' == var.bstrVal)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *pstrOut = var.bstrVal;
    var.vt = VT_EMPTY;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetLongProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    hr = polGetProperty(pServer, fRequest, PROPTYPE_LONG, pwszPropertyName, &var);
    _JumpIfError2(hr, error, "Policy:polGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    if (VT_I4 != var.vt)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *plOut = var.lVal;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, TRUE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, FALSE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, TRUE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, FALSE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszAttributeName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetRequestAttribute(strName, pstrOut);
    _JumpIfErrorStr(hr, error, "Policy:GetRequestAttribute", pwszAttributeName);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::~CCertPolicySample -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertPolicySample::~CCertPolicySample()
{
    _Cleanup();
}


VOID
CCertPolicySample::_FreeStringArray(
    IN OUT DWORD *pcString,
    IN OUT LPWSTR **papstr)
{
    BSTR *apstr = *papstr;
    DWORD i;

    if (NULL != apstr)
    {
        for (i = *pcString; i-- > 0; )
        {
            if (NULL != apstr[i])
            {
                DBGPRINT((fDebug, "_FreeStringArray[%u]: '%ws'\n", i, apstr[i]));
                LocalFree(apstr[i]);
            }
        }
        LocalFree(apstr);
        *papstr = NULL;
    }
    *pcString = 0;
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_Cleanup -- free memory associated with this instance
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_Cleanup()
{
    DWORD i;

    if (m_strDescription)
    {
        SysFreeString(m_strDescription);
        m_strDescription = NULL;
    }

    // RevocationExtension variables:

    if (NULL != m_wszASPRevocationURL)
    {
        LocalFree(m_wszASPRevocationURL);
    	m_wszASPRevocationURL = NULL;
    }


    // SubjectAltNameExtension variables:

    for (i = 0; i < 2; i++)
    {
	if (NULL != m_astrSubjectAltNameProp[i])
	{
	    SysFreeString(m_astrSubjectAltNameProp[i]);
	    m_astrSubjectAltNameProp[i] = NULL;
	}
	if (NULL != m_astrSubjectAltNameObjectId[i])
	{
	    SysFreeString(m_astrSubjectAltNameObjectId[i]);
	    m_astrSubjectAltNameObjectId[i] = NULL;
	}
    }

    _FreeStringArray(&m_cEnableRequestExtensions, &m_apstrEnableRequestExtensions);
    _FreeStringArray(&m_cDisableExtensions, &m_apstrDisableExtensions);

    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
        m_strCAName = NULL;
    }
    if (NULL != m_strCASanitizedName)
    {
        SysFreeString(m_strCASanitizedName);
        m_strCASanitizedName = NULL;
    }
    if (NULL != m_strCASanitizedDSName)
    {
        SysFreeString(m_strCASanitizedDSName);
        m_strCASanitizedDSName = NULL;
    }

    if (NULL != m_strRegStorageLoc)
    {
        SysFreeString(m_strRegStorageLoc);
        m_strRegStorageLoc = NULL;
    }

    if (NULL != m_pCert)
    {
        CertFreeCertificateContext(m_pCert);
        m_pCert = NULL;
    }

    if (m_strMachineDNSName)
    {
        SysFreeString(m_strMachineDNSName);
        m_strMachineDNSName=NULL;
    }

}


HRESULT
CCertPolicySample::_ReadRegistryString(
    IN HKEY hkey,
    IN BOOL fURL,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszSuffix,
    OUT LPWSTR *ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    *ppwszOut = NULL;
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    NULL,
		    &cbValue);
    _JumpIfErrorStr2(hr, error, "Policy:RegQueryValueEx", pwszRegName, ERROR_FILE_NOT_FOUND);

    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpErrorStr(hr, error, "Policy:RegQueryValueEx TYPE", pwszRegName);
    }
    if (NULL != pwszSuffix)
    {
	cbValue += wcslen(pwszSuffix) * sizeof(WCHAR);
    }
    pwszRegValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
    if (NULL == pwszRegValue)
    {
        hr = E_OUTOFMEMORY;
        _JumpErrorStr(hr, error, "Policy:LocalAlloc", pwszRegName);
    }
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) pwszRegValue,
		    &cbValue);
    _JumpIfErrorStr(hr, error, "Policy:RegQueryValueEx", pwszRegName);

    // Handle malformed registry values cleanly:

    pwszRegValue[cbValue / sizeof(WCHAR)] = L'\0';
    if (NULL != pwszSuffix)
    {
	wcscat(pwszRegValue, pwszSuffix);
    }

    hr = ceFormatCertsrvStringArray(
			fURL,			// fURL
			m_strMachineDNSName, 	// pwszServerName_p1_2
			m_strCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			L"",		// pwszDomainDN_p5
			L"", 	// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9
			TRUE,			// fDSAttrib_p10_11
			1,       		// cStrings
			(LPCWSTR *) &pwszRegValue, // apwszStringsIn
			ppwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "Policy:ceFormatCertsrvStringArray");

error:
    if (NULL != pwszRegValue)
    {
        LocalFree(pwszRegValue);
    }
    return(ceHError(hr));
}


#if DBG_CERTSRV

VOID
CCertPolicySample::_DumpStringArray(
    IN char const *pszType,
    IN DWORD count,
    IN BSTR const *apstr)
{
    DWORD i;
    WCHAR const *pwszName;

    for (i = 0; i < count; i++)
    {
	pwszName = L"";
	if (iswdigit(apstr[i][0]))
	{
	    pwszName = ceGetOIDName(apstr[i]);	// Static: do not free!
	}
	DBGPRINT((
		fDebug,
		"%hs[%u]: %ws%hs%ws\n",
		pszType,
		i,
		apstr[i],
		L'\0' != *pwszName? " -- " : "",
		pwszName));
    }
}
#endif // DBG_CERTSRV


HRESULT
CCertPolicySample::_SetSystemStringProp(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const *pwszValue)
{
    HRESULT hr;
    BSTR strName = NULL;
    VARIANT varValue;

    varValue.vt = VT_NULL;
    varValue.bstrVal = NULL;

    if (!ceConvertWszToBstr(&strName, pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }

    if (NULL != pwszValue)
    {
        if (!ceConvertWszToBstr(&varValue.bstrVal, pwszValue, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertWszToBstr");
	}
	varValue.vt = VT_BSTR;
    }
    
    hr = pServer->SetCertificateProperty(strName, PROPTYPE_STRING, &varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
CCertPolicySample::_AddStringArray(
    IN WCHAR const *pwszzValue,
    IN BOOL fURL,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr = S_OK;
    DWORD cString = 0;
    WCHAR const *pwsz;
    LPCWSTR *awszFormatStrings = NULL;
    LPWSTR *awszOutputStrings = NULL;

    // Count the number of strings we're adding
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        cString++;
    }
    if (0 == cString)		// no strings
    {
        goto error;
    }
    awszFormatStrings = (LPCWSTR *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cString * sizeof(LPWSTR));
    if (NULL == awszFormatStrings)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:LocalAlloc");
    }

    cString = 0;
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        // Skip strings that start with a an unescaped minus sign.
        // Strings with an escaped minus sign (2 minus signs) are not skipped.

        if (L'-' == *pwsz)
        {
	    pwsz++;
	    if (L'-' != *pwsz)
	    {
                continue;
	    }
        }
        awszFormatStrings[cString++] = pwsz;
    }

    // if no strings to add, don't modify
    if (cString > 0)
    {
        awszOutputStrings = (LPWSTR *) LocalAlloc(
			        LMEM_FIXED | LMEM_ZEROINIT,
			        (cString + *pcStrings) * sizeof(LPWSTR));
        if (NULL == awszOutputStrings)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "Policy:LocalAlloc");
        }

        if (0 != *pcStrings)
        {
            assert(NULL != *papstrRegValues);
            CopyMemory(awszOutputStrings, *papstrRegValues, *pcStrings * sizeof(LPWSTR));
        }

        hr = ceFormatCertsrvStringArray(
		fURL,				// fURL
		m_strMachineDNSName,		// pwszServerName_p1_2
		m_strCASanitizedName,		// pwszSanitizedName_p3_7
		m_iCert,			// iCert_p4
		L"",			// pwszDomainDN_p5
		L"",			// pwszConfigDN_p6
		m_iCRL,				// iCRL_p8
		FALSE,				// fDeltaCRL_p9
		TRUE,				// fDSAttrib_p10_11
		cString,			// cStrings
		awszFormatStrings,		// apwszStringsIn
		awszOutputStrings + (*pcStrings)); // apwszStringsOut
	_JumpIfError(hr, error, "Policy:ceFormatCertsrvStringArray");

        *pcStrings = (*pcStrings) + cString;
        if (*papstrRegValues)
        {
            LocalFree(*papstrRegValues);
        }
        *papstrRegValues = awszOutputStrings;
        awszOutputStrings = NULL;
    }

error:

    if (awszOutputStrings)
    {
        LocalFree(awszOutputStrings);
    }
    if (awszFormatStrings)
    {
        LocalFree(awszFormatStrings);
    }
    return(ceHError(hr));
}


HRESULT
CCertPolicySample::_ReadRegistryStringArray(
    IN HKEY hkey,
    IN BOOL fURL,
    IN DWORD dwFlags,
    IN DWORD cRegNames,
    IN DWORD *aFlags,
    IN WCHAR const * const *apwszRegNames,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    for (i = 0; i < cRegNames; i++)
    {
        if (0 == (dwFlags & aFlags[i]))
        {
	    continue;
        }
        if (NULL != pwszzValue)
        {
	    LocalFree(pwszzValue);
	    pwszzValue = NULL;
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        NULL,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr2(hr, "Policy:RegQueryValueEx", apwszRegNames[i], ERROR_FILE_NOT_FOUND);
	    continue;
        }
        if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx TYPE", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly by adding two WCHAR L'\0's
	// allocate space for 3 WCHARs to allow for unaligned (odd) cbValue;

        pwszzValue = (WCHAR *) LocalAlloc(
				        LMEM_FIXED,
				        cbValue + 3 * sizeof(WCHAR));
        if (NULL == pwszzValue)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpErrorStr(hr, error, "Policy:LocalAlloc", apwszRegNames[i]);
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        (BYTE *) pwszzValue,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly:

        pwszzValue[cbValue / sizeof(WCHAR)] = L'\0';
        pwszzValue[cbValue / sizeof(WCHAR) + 1] = L'\0';

        hr = _AddStringArray(
			pwszzValue,
			fURL,
			pcStrings,
			papstrRegValues);
        _JumpIfErrorStr(hr, error, "_AddStringArray", apwszRegNames[i]);
    }
    hr = S_OK;

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_InitRevocationExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_InitRevocationExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;

    cb = sizeof(m_dwRevocationFlags);
    hr = RegQueryValueEx(
                hkey,
                wszREGREVOCATIONTYPE,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwRevocationFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwRevocationFlags) != cb)
    {
        goto error;
    }
    DBGPRINT((fDebug, "Revocation Flags = %x\n", m_dwRevocationFlags));

    // clean up from previous call

    if (NULL != m_wszASPRevocationURL)
    {
	LocalFree(m_wszASPRevocationURL);
	m_wszASPRevocationURL = NULL;
    }

    if (REVEXT_ASPENABLE & m_dwRevocationFlags)
    {
        hr = _ReadRegistryString(
			    hkey,
			    TRUE,			// fURL
			    wszREGREVOCATIONURL,	// pwszRegName
			    L"?",			// pwszSuffix
			    &m_wszASPRevocationURL);	// pstrRegValue
        _JumpIfErrorStr(hr, error, "_ReadRegistryString", wszREGREVOCATIONURL);
        _DumpStringArray("ASP", 1, &m_wszASPRevocationURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_InitRequestExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_InitRequestExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
		EDITF_REQUESTEXTENSIONLIST,
	    };
    WCHAR *apwszRegNames[] = {
		wszREGENABLEREQUESTEXTENSIONLIST,
	    };

    assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));

    // clean up from previous call
    if (m_apstrEnableRequestExtensions)
    {
        _FreeStringArray(&m_cEnableRequestExtensions, &m_apstrEnableRequestExtensions);
    }


    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cEnableRequestExtensions,
			&m_apstrEnableRequestExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray("Request", m_cEnableRequestExtensions, m_apstrEnableRequestExtensions);

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_InitDisableExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_InitDisableExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
		EDITF_DISABLEEXTENSIONLIST,
	    };
    WCHAR *apwszRegNames[] = {
		wszREGDISABLEEXTENSIONLIST,
	    };

    assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));
    // clean up from previous call
    if (m_apstrDisableExtensions)
    {
        _FreeStringArray(&m_cDisableExtensions, &m_apstrDisableExtensions);
    }


    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cDisableExtensions,
			&m_apstrDisableExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray("Disable", m_cDisableExtensions, m_apstrDisableExtensions);

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_InitSubjectAltNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_InitSubjectAltNameExtension(
    IN HKEY hkey,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszObjectId,
    IN DWORD iAltName)
{
    DWORD err;
    DWORD dwType;
    DWORD cbbuf;
    WCHAR awcbuf[MAX_PATH];

    cbbuf = sizeof(awcbuf) - 2 * sizeof(WCHAR);
    err = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,         // lpdwReserved
		    &dwType,
		    (BYTE *) awcbuf,
		    &cbbuf);
    if (ERROR_SUCCESS != err ||
        REG_SZ != dwType ||
        sizeof(awcbuf) - 2 * sizeof(WCHAR) <= cbbuf)
    {
        goto error;
    }
    if (0 == lstrcmpi(awcbuf, wszATTREMAIL1) ||
	0 == lstrcmpi(awcbuf, wszATTREMAIL2))
    {
        if (!ceConvertWszToBstr(
			&m_astrSubjectAltNameObjectId[iAltName],
			pwszObjectId,
			-1))
	{
	    _JumpError(E_OUTOFMEMORY, error, "Policy:ceConvertWszToBstr");
	}

        if (!ceConvertWszToBstr(
			&m_astrSubjectAltNameProp[iAltName],
			wszPROPSUBJECTEMAIL,
			-1))
	{
	    _JumpError(E_OUTOFMEMORY, error, "Policy:ceConvertWszToBstr");
	}
    }
    DBGPRINT((
	fDebug,
	"Policy: %ws(RDN=%ws): %ws\n",
	pwszRegName,
	awcbuf,
	m_astrSubjectAltNameProp[iAltName]));

error:
    ;
}



//+--------------------------------------------------------------------------
// CCertPolicySample::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::Initialize(
    /* [in] */ BSTR const strConfig)
{
    HRESULT     hr;
    DWORD       err;
    HKEY        hkey = NULL;
    WCHAR       sz[MAX_PATH];
    DWORD       dwType;
    DWORD       dwSize;
    LPWSTR      wszShortMachineName = NULL;
    ICertServerPolicy *pServer = NULL;
    BOOL fCritSecEntered = FALSE;

    CERT_RDN_ATTR rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE, };
    CERT_RDN rdn = { 1, &rdnAttr };

    rdnAttr.Value.pbData = NULL;

    DBGPRINT((fDebug, "Policy:Initialize:\n"));

    if (!m_fPolicyCriticalSection)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&m_PolicyCriticalSection);
    fCritSecEntered = TRUE;

    __try
    {
	_Cleanup();

	m_strCAName = SysAllocString(strConfig);

	// get server callbacks

	hr = polGetServerCallbackInterface(&pServer, 0);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");

	// get storage location
	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPMODULEREGLOC,
				    &m_strRegStorageLoc);
	_LeaveIfErrorStr(hr, "Policy:polGetCertificateStringProperty", wszPROPMODULEREGLOC);


	assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
	wcscpy(sz, wsz_SAMPLE_DESCRIPTION);

	m_strDescription = SysAllocString(sz);
	if (NULL == m_strDescription)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "Policy:SysAllocString");
	}

	// get CA type
	hr = polGetCertificateLongProperty(pServer, wszPROPCATYPE, (LONG *) &m_CAType);
	_LeaveIfErrorStr(hr, "Policy:polGetCertificateLongProperty", wszPROPCATYPE);


	// get sanitized name
	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDCANAME,
				    &m_strCASanitizedName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDCANAME);

	// get sanitized name
	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDSHORTNAME,
				    &m_strCASanitizedDSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDSHORTNAME);

	err = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    m_strRegStorageLoc,
		    0,              // dwReserved
		    KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
		    &hkey);

	if (ERROR_SUCCESS != err)
	{
	    hr = HRESULT_FROM_WIN32(err);

	    _LeaveErrorStr(hr, "Policy:Initialize:RegOpenKeyEx", m_strRegStorageLoc);
	}

	// Ignore error codes.

	dwSize = sizeof(m_dwDispositionFlags);
	err = RegQueryValueEx(
			hkey,
			wszREGREQUESTDISPOSITION,
			0,
			&dwType,
			(BYTE *) &m_dwDispositionFlags,
			&dwSize);
	if (ERROR_SUCCESS != err)
	{
	    m_dwDispositionFlags = 0;
	}
	DBGPRINT((fDebug, "Disposition Flags = %x\n", m_dwDispositionFlags));

	dwSize = sizeof(m_dwEditFlags);
	err = RegQueryValueEx(
			hkey,
			wszREGEDITFLAGS,
			0,
			&dwType,
			(BYTE *) &m_dwEditFlags,
			&dwSize);
	if (ERROR_SUCCESS != err)
	{
	    m_dwEditFlags = 0;
	}
	DBGPRINT((fDebug, "Edit Flags = %x\n", m_dwEditFlags));

	dwSize = sizeof(m_CAPathLength);
	err = RegQueryValueEx(
			hkey,
			wszREGCAPATHLENGTH,
			0,
			&dwType,
			(BYTE *) &m_CAPathLength,
			&dwSize);
	if (ERROR_SUCCESS != err)
	{
	    m_CAPathLength = CAPATHLENGTH_INFINITE;
	}
	DBGPRINT((fDebug, "CAPathLength = %x\n", m_CAPathLength));


	// Initialize the insertion string array.
	// Machine DNS name (%1)

	hr = polGetCertificateStringProperty(
			    pServer,
			    wszPROPMACHINEDNSNAME,
			    &m_strMachineDNSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPMACHINEDNSNAME);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCERTCOUNT,
				    (LONG *) &m_iCert);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCERTCOUNT);
	m_iCert--;

	hr = polGetCertificateLongProperty(pServer, wszPROPCRLINDEX, (LONG *) &m_iCRL);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCRLINDEX);
	


	_InitRevocationExtension(hkey);
	_InitRequestExtensionList(hkey);
	_InitDisableExtensionList(hkey);

	{
	    _InitSubjectAltNameExtension(
				hkey,
				wszREGSUBJECTALTNAME,
				TEXT(szOID_SUBJECT_ALT_NAME),
				0);
	    _InitSubjectAltNameExtension(
				hkey,
				wszREGSUBJECTALTNAME2,
				TEXT(szOID_SUBJECT_ALT_NAME2),
				1);
	}

	hr = S_OK;
    }
    __except(hr = ceHError(GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    if (NULL != pServer)
    {
	pServer->Release();
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&m_PolicyCriticalSection);
    }
    return(hr);
}


DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR **ppwsz)
{
    DWORD i;

    for (i = 0; i < count; i++)
    {
	if (0 == wcscmp(pwsz, ppwsz[i]))
	{
	    break;
	}
    }
    return(i < count? i : MAXDWORD);
}


HRESULT
CCertPolicySample::_EnumerateExtensions(
    IN ICertServerPolicy *pServer,
    IN LONG bNewRequest,
    IN BOOL fFirstPass)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varValue;
    BOOL fClose = FALSE;
    BOOL fEnable;
    BOOL fDisable;

    VariantInit(&varValue);

    hr = pServer->EnumerateExtensionsSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateExtensionsSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateExtensions(&strName);
        if (S_FALSE == hr)
        {
            hr = S_OK;
            break;
        }
        _JumpIfError(hr, error, "Policy:EnumerateExtensions");

        hr = pServer->GetCertificateExtension(
                                        strName,
                                        PROPTYPE_BINARY,
                                        &varValue);
        _JumpIfError(hr, error, "Policy:GetCertificateExtension");

        hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	fEnable = FALSE;
	fDisable = FALSE;

        if (fFirstPass)
        {
            if (bNewRequest && (EXTENSION_DISABLE_FLAG & ExtFlags))
            {
                switch (EXTENSION_ORIGIN_MASK & ExtFlags)
                {
                    case EXTENSION_ORIGIN_REQUEST:
                    case EXTENSION_ORIGIN_RENEWALCERT:
                    case EXTENSION_ORIGIN_PKCS7:
                    case EXTENSION_ORIGIN_CMC:
                    if ((EDITF_ENABLEREQUESTEXTENSIONS & m_dwEditFlags) ||
			MAXDWORD != polFindObjIdInList(
					    strName,
					    m_cEnableRequestExtensions,
					    m_apstrEnableRequestExtensions))
                    {
			fEnable = TRUE;
                    }
                    break;
                }
            }
        }
        else
        {
            if (0 == (EXTENSION_DISABLE_FLAG & ExtFlags) &&
		MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cDisableExtensions,
				    m_apstrDisableExtensions))
            {
                fDisable = TRUE;
            }
        }

        if (fDisable || fEnable)
        {
            if (fEnable)
            {
                ExtFlags &= ~EXTENSION_DISABLE_FLAG;
            }
            else
            {
                ExtFlags |= EXTENSION_DISABLE_FLAG;
            }
            hr = pServer->SetCertificateExtension(
			            strName,
			            PROPTYPE_BINARY,
			            ExtFlags,
			            &varValue);
            _JumpIfError(hr, error, "Policy:SetCertificateExtension");
        }

        if (fFirstPass || fDisable || fEnable)
        {
	    DBGPRINT((
		fDebug,
                "Policy:EnumerateExtensions(%ws, Flags=%x, %x bytes)%hs\n",
                strName,
                ExtFlags,
                SysStringByteLen(varValue.bstrVal),
		fDisable? " DISABLING" : (fEnable? " ENABLING" : "")));
        }
        VariantClear(&varValue);
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateExtensionsClose();
        if (S_OK != hr2)
        {
            if (S_OK == hr)
            {
                hr = hr2;
            }
	    _PrintError(hr2, "Policy:EnumerateExtensionsClose");
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    VariantClear(&varValue);
    return(hr);
}


HRESULT
EnumerateAttributes(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    BOOL fClose = FALSE;
    BSTR strValue = NULL;

    hr = pServer->EnumerateAttributesSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateAttributesSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateAttributes(&strName);
	if (S_FALSE == hr)
	{
	    hr = S_OK;
	    break;
	}
	_JumpIfError(hr, error, "Policy:EnumerateAttributes");

        hr = pServer->GetRequestAttribute(strName, &strValue);
	_JumpIfError(hr, error, "Policy:GetRequestAttribute");

	DBGPRINT((
		fDebug,
                "Policy:EnumerateAttributes(%ws = %ws)\n",
                strName,
                strValue));
        if (NULL != strValue)
        {
            SysFreeString(strValue);
            strValue = NULL;
        }
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateAttributesClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateAttributesClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }

    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
CheckRequestProperties(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    LONG lRequestId;

    hr = polGetRequestLongProperty(pServer, wszPROPREQUESTREQUESTID, &lRequestId);
    _JumpIfError(hr, error, "Policy:polGetRequestLongProperty");

    DBGPRINT((
	fDebug,
	"Policy:CheckRequestProperties(%ws = %u)\n",
	wszPROPREQUESTREQUESTID,
	lRequestId));

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_AddRevocationExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddRevocationExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strASPExtension = NULL;
    VARIANT varExtension;
    DWORD i;

    if (NULL != m_wszASPRevocationURL)
    {
	strASPExtension = SysAllocString(m_wszASPRevocationURL);
	if (NULL == strASPExtension)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strASPExtension;
	hr = pServer->SetCertificateExtension(
				TEXT(szOID_NETSCAPE_REVOCATION_URL),
				PROPTYPE_STRING,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "Policy:SetCertificateExtension", L"ASP");
    }

error:
    if (NULL != strASPExtension)
    {
        SysFreeString(strASPExtension);
    }
    return(hr);
}


#define HIGHBIT(bitno)	(1 << (7 - (bitno)))	// bit counted from high end

#define SSLBIT_CLIENT	((BYTE) HIGHBIT(0))	// certified for client auth
#define SSLBIT_SERVER	((BYTE) HIGHBIT(1))	// certified for server auth
#define SSLBIT_SMIME	((BYTE) HIGHBIT(2))	// certified for S/MIME
#define SSLBIT_SIGN	((BYTE) HIGHBIT(3))	// certified for signing

#define SSLBIT_RESERVED	((BYTE) HIGHBIT(4))	// reserved for future use

#define SSLBIT_CASSL	((BYTE) HIGHBIT(5))	// CA for SSL auth certs
#define SSLBIT_CASMIME	((BYTE) HIGHBIT(6))	// CA for S/MIME certs
#define SSLBIT_CASIGN	((BYTE) HIGHBIT(7))	// CA for signing certs

#define NSCERTTYPE_CLIENT  ((BYTE) SSLBIT_CLIENT)
#define NSCERTTYPE_SERVER  ((BYTE) (SSLBIT_SERVER | SSLBIT_CLIENT))
#define NSCERTTYPE_SMIME   ((BYTE) SSLBIT_SMIME)
#define NSCERTTYPE_CA	   ((BYTE) (SSLBIT_CASSL | SSLBIT_CASMIME | SSLBIT_CASIGN))

//+--------------------------------------------------------------------------
// CCertPolicySample::_AddOldCertTypeExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddOldCertTypeExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr = S_OK;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    BSTR strCertType = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    DWORD cb;

    VariantInit(&varConstraints);

    if (EDITF_ADDOLDCERTTYPE & m_dwEditFlags)
    {
	BYTE CertType;

	if (!fCA)
	{
	    hr = pServer->GetCertificateExtension(
					TEXT(szOID_BASIC_CONSTRAINTS2),
					PROPTYPE_BINARY,
					&varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = ceHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	hr = CoCreateInstance(
			CLSID_CCertEncodeBitString,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeBitString,
			(VOID **) &pBitString);
	_JumpIfError(hr, error, "Policy:CoCreateInstance");

	CertType = NSCERTTYPE_CLIENT;	// Default to client auth. cert
	if (fCA)
	{
	    CertType = NSCERTTYPE_CA;
	}
	else
	{
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
	    if (S_OK == hr)
	    {
		if (0 == lstrcmpi(strCertType, L"server"))
		{
		    CertType = NSCERTTYPE_SERVER;
		}
	    }
	}

        if (!ceConvertWszToBstr(
		    &strBitString,
		    (WCHAR const *) &CertType,
		    sizeof(CertType)))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertWszToBstr");
	}

	hr = pBitString->Encode(
			    sizeof(CertType) * 8,
			    strBitString,
			    &strExtension);
	_JumpIfError(hr, error, "Policy:BitString:Encode");

        varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strExtension;
	hr = pServer->SetCertificateExtension(
				TEXT(szOID_NETSCAPE_CERT_TYPE),
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }

error:
    VariantClear(&varConstraints);
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_AddAuthorityKeyId
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddAuthorityKeyId(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo = NULL;
    DWORD cbInfo = 0;
    LONG ExtFlags = 0;

    // Optimization

    if ((EDITF_ENABLEAKIKEYID |
	 EDITF_ENABLEAKIISSUERNAME |
	 EDITF_ENABLEAKIISSUERSERIAL) ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL |
	  EDITF_ENABLEAKICRITICAL) & m_dwEditFlags))
    {
        goto error;
    }

    hr = pServer->GetCertificateExtension(
                                    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
                                    PROPTYPE_BINARY,
                                    &varExtension);
    _JumpIfError(hr, error, "Policy:GetCertificateExtension");

    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

    if (VT_BSTR != varExtension.vt)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Policy:GetCertificateExtension");
    }

    cbInfo = 0;
    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
                    X509_AUTHORITY_KEY_ID2,
                    (PBYTE)varExtension.bstrVal,
                    SysStringByteLen(varExtension.bstrVal),
		    FALSE,
                    (PVOID *)&pInfo,
                    &cbInfo))
    {
	hr = ceHLastError();
	_JumpIfError(hr, error, "Policy:ceDecodeObject");
    }

    // Make Any Modifications Here

    if (0 == (EDITF_ENABLEAKIKEYID & m_dwEditFlags))
    {
        pInfo->KeyId.cbData = 0;
        pInfo->KeyId.pbData = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERNAME & m_dwEditFlags))
    {
        pInfo->AuthorityCertIssuer.cAltEntry = 0;
        pInfo->AuthorityCertIssuer.rgAltEntry = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERSERIAL & m_dwEditFlags))
    {
        pInfo->AuthorityCertSerialNumber.cbData = 0;
        pInfo->AuthorityCertSerialNumber.pbData = NULL;
    }
    if (EDITF_ENABLEAKICRITICAL & m_dwEditFlags)
    {
	ExtFlags |= EXTENSION_CRITICAL_FLAG;
    }
    if (0 ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL) & m_dwEditFlags))
    {
	ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    VariantClear(&varExtension);

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_KEY_ID2,
		    pInfo,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "Policy:ceEncodeObject");
    }
    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtension(AuthorityKeyId2)");

error:
    if (NULL != pInfo)
    {
	LocalFree(pInfo);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddDefaultKeyUsageExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr;
    BSTR strName = NULL;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    VARIANT varKeyUsage;
    CRYPT_BIT_BLOB *pKeyUsage = NULL;
    DWORD cb;
    BYTE abKeyUsage[1];
    BYTE *pbKeyUsage;
    DWORD cbKeyUsage;

    VariantInit(&varConstraints);
    VariantInit(&varKeyUsage);

    if (EDITF_ADDOLDKEYUSAGE & m_dwEditFlags)
    {
	BOOL fModified = FALSE;

	if (!fCA)
	{
	    hr = pServer->GetCertificateExtension(
					TEXT(szOID_BASIC_CONSTRAINTS2),
					PROPTYPE_BINARY,
					&varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = ceHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	ZeroMemory(abKeyUsage, sizeof(abKeyUsage));
	pbKeyUsage = abKeyUsage;
	cbKeyUsage = sizeof(abKeyUsage);

	hr = pServer->GetCertificateExtension(
				    TEXT(szOID_KEY_USAGE),
				    PROPTYPE_BINARY,
				    &varKeyUsage);
	if (S_OK == hr)
	{
	    if (!ceDecodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    (BYTE const *) varKeyUsage.bstrVal,
			    SysStringByteLen(varKeyUsage.bstrVal),
			    FALSE,
			    (VOID **) &pKeyUsage,
			    &cb))
	    {
		hr = GetLastError();
		_PrintError(hr, "Policy:ceDecodeObject");
	    }
	    else if (0 != cb && NULL != pKeyUsage && 0 != pKeyUsage->cbData)
	    {
		pbKeyUsage = pKeyUsage->pbData;
		cbKeyUsage = pKeyUsage->cbData;
	    }
	}

	if ((CERT_KEY_ENCIPHERMENT_KEY_USAGE & pbKeyUsage[0]) &&
	    (CERT_KEY_AGREEMENT_KEY_USAGE & pbKeyUsage[0]))
	{
	    pbKeyUsage[0] &= ~CERT_KEY_AGREEMENT_KEY_USAGE;
	    pbKeyUsage[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE |
				CERT_NON_REPUDIATION_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fCA)
	{
	    pbKeyUsage[0] |= CERT_KEY_CERT_SIGN_KEY_USAGE |
				CERT_CRL_SIGN_KEY_USAGE |
				CERT_DIGITAL_SIGNATURE_KEY_USAGE |
				CERT_NON_REPUDIATION_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fModified)
	{
	    hr = CoCreateInstance(
			    CLSID_CCertEncodeBitString,
			    NULL,               // pUnkOuter
			    CLSCTX_INPROC_SERVER,
			    IID_ICertEncodeBitString,
			    (VOID **) &pBitString);
	    _JumpIfError(hr, error, "Policy:CoCreateInstance");

	    if (!ceConvertWszToBstr(
			&strBitString,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:ceConvertWszToBstr");
	    }

	    hr = pBitString->Encode(cbKeyUsage * 8, strBitString, &strExtension);
	    _JumpIfError(hr, error, "Policy:Encode");

	    if (!ceConvertWszToBstr(&strName, TEXT(szOID_KEY_USAGE), -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:ceConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    varExtension.bstrVal = strExtension;
	    hr = pServer->SetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    0,
				    &varExtension);
	    _JumpIfError(hr, error, "Policy:SetCertificateExtension");
	}
    }
    hr = S_OK;

error:
    VariantClear(&varConstraints);
    VariantClear(&varKeyUsage);
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddDefaultBasicConstraintsExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL               fCA)
{
    HRESULT hr;
    VARIANT varExtension;
    LONG ExtFlags;
    CERT_EXTENSION Ext;
    CERT_EXTENSION *pExtension = NULL;
    BSTR strCertType = NULL;

    VariantInit(&varExtension);

    if (EDITF_BASICCONSTRAINTSCA & m_dwEditFlags)
    {
        hr = pServer->GetCertificateExtension(
				        TEXT(szOID_BASIC_CONSTRAINTS2),
				        PROPTYPE_BINARY,
				        &varExtension);
        if (S_OK == hr)
        {
	    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
	    DWORD cb;

	    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	    if (S_OK == hr)
	    {
                Ext.pszObjId = szOID_BASIC_CONSTRAINTS2;
                Ext.fCritical = FALSE;
                if (EXTENSION_CRITICAL_FLAG & ExtFlags)
                {
                    Ext.fCritical = TRUE;
                }
                Ext.Value.pbData = (BYTE *) varExtension.bstrVal;
                Ext.Value.cbData = SysStringByteLen(varExtension.bstrVal);
		pExtension = &Ext;

		cb = sizeof(Constraints);
		if (!fCA && CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        Ext.Value.pbData,
			        Ext.Value.cbData,
			        0,
			        &Constraints,
			        &cb))
		{
		    fCA = Constraints.fCA;
		}
	    }
	}
    }

    if (EDITF_ATTRIBUTECA & m_dwEditFlags)
    {
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == lstrcmpi(strCertType, L"ca"))
                {
                    fCA = TRUE;
                }
            }
        }
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == lstrcmpi(strCertType, wszCERTTYPE_SUBORDINATE_CA))
                {
                    fCA = TRUE;
                }
            }
	}
    }

    // For standalone, the extension is only enabled if it's a CA

    hr = AddBasicConstraintsCommon(pServer, pExtension, fCA, fCA);
    _JumpIfError(hr, error, "Policy:AddBasicConstraintsCommon");

error:
    VariantClear(&varExtension);
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    return(hr);
}


HRESULT
CCertPolicySample::AddBasicConstraintsCommon(
    IN ICertServerPolicy *pServer,
    IN CERT_EXTENSION const *pExtension,
    IN BOOL fCA,
    IN BOOL fEnableExtension)
{
    HRESULT hr;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    CERT_CONTEXT const *pIssuerCert;
    CERT_EXTENSION *pIssuerExtension;
    LONG ExtFlags = 0;
    BYTE *pbConstraints = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    CERT_BASIC_CONSTRAINTS2_INFO IssuerConstraints;
    ZeroMemory(&IssuerConstraints, sizeof(IssuerConstraints));

    DWORD cb;

    pIssuerCert = _GetIssuer(pServer);
    if (NULL == pIssuerCert)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "_GetIssuer");
    }

    if (NULL != pExtension)
    {
        cb = sizeof(Constraints);
        if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_BASIC_CONSTRAINTS2,
			pExtension->Value.pbData,
			pExtension->Value.cbData,
			0,
			&Constraints,
			&cb))
        {
	    hr = ceHLastError();
	    _JumpError(hr, error, "Policy:CryptDecodeObject");
        }

        // Cert templates use CAPATHLENGTH_INFINITE to indicate
        // fPathLenConstraint should be FALSE.

        if (CAPATHLENGTH_INFINITE == Constraints.dwPathLenConstraint)
        {

            // NOTE: This is ok as certcli already sets fPathLenConstraint to FALSE
            // for templates in this case.
	    Constraints.fPathLenConstraint = FALSE;

            // NOTE: This is ok as autoenrollment ignores dwPathLenConstraint
            // if fPathLenConstraint is FALSE;
	    Constraints.dwPathLenConstraint = 0;
        }
        if (pExtension->fCritical)
        {
	    ExtFlags = EXTENSION_CRITICAL_FLAG;
        }
    }
    else
    {
	Constraints.fCA = fCA;
	Constraints.fPathLenConstraint = FALSE;
	Constraints.dwPathLenConstraint = 0;
    }
    if (EDITF_BASICCONSTRAINTSCRITICAL & m_dwEditFlags)
    {
        ExtFlags = EXTENSION_CRITICAL_FLAG;
    }

    // Check basic constraints against the issuer's cert.

    pIssuerExtension = CertFindExtension(
				szOID_BASIC_CONSTRAINTS2,
				pIssuerCert->pCertInfo->cExtension,
				pIssuerCert->pCertInfo->rgExtension);
    if (NULL != pIssuerExtension)
    {
        cb = sizeof(IssuerConstraints);
        if (!CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        pIssuerExtension->Value.pbData,
			        pIssuerExtension->Value.cbData,
			        0,
			        &IssuerConstraints,
			        &cb))
        {
            hr = ceHLastError();
            _JumpError(hr, error, "Policy:CryptDecodeObject");
        }
        if (!IssuerConstraints.fCA)
        {
            hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
            _JumpError(hr, error, "Policy:CA cert not a CA cert");
        }
    }

    if (Constraints.fCA)
    {
        if (IssuerConstraints.fPathLenConstraint)
        {
            if (0 == IssuerConstraints.dwPathLenConstraint)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:CA cert is a leaf CA cert");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint >
	            IssuerConstraints.dwPathLenConstraint - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint =
                IssuerConstraints.dwPathLenConstraint - 1;
            }
        }
        if (CAPATHLENGTH_INFINITE != m_CAPathLength)
        {
            if (0 == m_CAPathLength)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:Registry says not to issue CA certs");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint > m_CAPathLength - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint = m_CAPathLength - 1;
            }
        }
    }

    if (!fEnableExtension)
    {
        ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS2,
                    &Constraints,
		    0,
		    FALSE,
                    &pbConstraints,
                    &cb))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "Policy:ceEncodeObject");
    }

    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbConstraints,
			cb))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    TEXT(szOID_BASIC_CONSTRAINTS2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:SetCertificateExtensioo");

error:
    if (NULL != pbConstraints)
    {
        LocalFree(pbConstraints);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }

    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_SetValidityPeriod
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_SetValidityPeriod(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR strPeriodString = NULL;
    BSTR strPeriodCount = NULL;
    BSTR strNameNotBefore = NULL;
    BSTR strNameNotAfter = NULL;
    VARIANT varValue;
    LONG lDelta;
    ENUM_PERIOD enumValidityPeriod;
    BOOL fValidDigitString;

    VariantInit(&varValue);

    if (!(EDITF_ATTRIBUTEENDDATE & m_dwEditFlags))
    {
	hr = S_OK;
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODSTRING,
			&strPeriodString);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODSTRING,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODCOUNT,
			&strPeriodString);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODCOUNT,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    // Swap Count and String BSTRs if backwards -- Windows 2000 had it wrong.

    lDelta = ceWtoI(strPeriodCount, &fValidDigitString);
    if (!fValidDigitString)
    {
	BSTR str = strPeriodCount;

	strPeriodCount = strPeriodString;
	strPeriodString = str;

	lDelta = ceWtoI(strPeriodCount, &fValidDigitString);
	if (!fValidDigitString)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Policy:ceWtoI");
	}
    }

    hr = ceTranslatePeriodUnits(strPeriodString, lDelta, &enumValidityPeriod, &lDelta);
    _JumpIfError(hr, error, "Policy:ceTranslatePeriodUnits");

    strNameNotBefore = SysAllocString(wszPROPCERTIFICATENOTBEFOREDATE);
    if (NULL == strNameNotBefore)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strNameNotBefore,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    hr = ceMakeExprDate(&varValue.date, lDelta, enumValidityPeriod);
    _JumpIfError(hr, error, "Policy:ceMakeExprDate");

    strNameNotAfter = SysAllocString(wszPROPCERTIFICATENOTAFTERDATE);
    if (NULL == strNameNotAfter)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->SetCertificateProperty(
				strNameNotAfter,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != strPeriodString)
    {
	SysFreeString(strPeriodString);
    }
    if (NULL != strPeriodCount)
    {
	SysFreeString(strPeriodCount);
    }
    if (NULL != strNameNotBefore)
    {
        SysFreeString(strNameNotBefore);
    }
    if (NULL != strNameNotAfter)
    {
        SysFreeString(strNameNotAfter);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_AddSubjectAltNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------
HRESULT
CCertPolicySample::_AddSubjectAltNameExtension(
    IN ICertServerPolicy *pServer,
    IN DWORD iAltName)
{
    HRESULT hr = S_OK;
    ICertEncodeAltName *pAltName = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strCertType = NULL;
    BSTR strName = NULL;
    VARIANT varValue;

    VariantInit(&varValue);
    if (NULL != m_astrSubjectAltNameProp[iAltName])
    {
	hr = CoCreateInstance(
			CLSID_CCertEncodeAltName,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeAltName,
			(VOID **) &pAltName);
	_JumpIfError(hr, error, "Policy:CoCreateInstance");

	hr = pServer->GetRequestProperty(
				    m_astrSubjectAltNameProp[iAltName],
				    PROPTYPE_STRING,
				    &varValue);
	if (S_OK != hr)
	{
	    DBGPRINT((
		fDebug,
		"Policy:GetRequestProperty(%ws):%hs %x\n",
		m_astrSubjectAltNameProp[iAltName],
		CERTSRV_E_PROPERTY_EMPTY == hr? " MISSING ATTRIBUTE" : "",
		hr));
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		hr = S_OK;
	    }
	    goto error;
	}
        if (VT_BSTR != varValue.vt)
	{
 	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}

        if (L'\0' == varValue.bstrVal[0])
	{
	    hr = S_OK;
	    goto error;
	}
        if (!ceConvertWszToBstr(&strName, varValue.bstrVal, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertWszToBstr");
	}

	hr = pAltName->Reset(1);
	_JumpIfError(hr, error, "Policy:AltName:Reset");

	hr = pAltName->SetNameEntry(0, CERT_ALT_NAME_RFC822_NAME, strName);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");

	hr = pAltName->Encode(&strExtension);
	_JumpIfError(hr, error, "Policy:AltName:Encode");

        varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strExtension;
	hr = pServer->SetCertificateExtension(
				m_astrSubjectAltNameObjectId[iAltName],
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != pAltName)
    {
        pAltName->Release();
    }
    VariantClear(&varValue);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_AddTemplateNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddTemplateNameExtension(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr = S_OK;
    BSTRC strTemplateName;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varExtension;
    CERT_NAME_VALUE *pName = NULL;
    CERT_NAME_VALUE NameValue;
    DWORD cbEncoded;
    BYTE *pbEncoded = NULL;
    BOOL fUpdate = TRUE;

    VariantInit(&varExtension);

    strTemplateName = pRequest->GetTemplateName();
    if (NULL == strTemplateName)
    {
        hr = S_OK;
        goto error;
    }

    strName = SysAllocString(TEXT(szOID_ENROLL_CERTTYPE_EXTENSION));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    hr = pServer->GetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    &varExtension);
    _PrintIfError2(hr, "Policy:GetCertificateExtension", hr);
    if (S_OK == hr && VT_BSTR == varExtension.vt)
    {
	hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	if (0 == (EXTENSION_DISABLE_FLAG & ExtFlags))
	{
	    if (!ceDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			(BYTE *) varExtension.bstrVal,
			SysStringByteLen(varExtension.bstrVal),
			FALSE,
			(VOID **) &pName,
			&cbEncoded))
	    {
		hr = ceHLastError();
		_JumpError(hr, error, "Policy:ceDecodeObject");
	    }

	    // case sensitive compare -- make sure it matches case of template

	    if (0 == lstrcmp(
			(WCHAR const *) pName->Value.pbData,
			strTemplateName))
	    {
		fUpdate = FALSE;
	    }
	}
    }
    if (fUpdate)
    {
	VariantClear(&varExtension);
	varExtension.bstrVal = NULL;

	NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
	NameValue.Value.pbData = (BYTE *) strTemplateName;
	NameValue.Value.cbData = 0;

	if (!ceEncodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			&NameValue,
			0,
			FALSE,
			&pbEncoded,
			&cbEncoded))
	{
	    hr = ceHLastError();
	    _JumpError(hr, error, "Policy:ceEncodeObject");
	}
	if (!ceConvertWszToBstr(
			    &varExtension.bstrVal,
			    (WCHAR const *) pbEncoded,
			    cbEncoded))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertWszToBstr");
	}
	varExtension.vt = VT_BSTR;

	hr = pServer->SetCertificateExtension(
				strName,
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }
    hr = S_OK;

error:
    VariantClear(&varExtension);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}


STDMETHODIMP
CCertPolicySample::VerifyRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Context,
    /* [in] */ LONG bNewRequest,
    /* [in] */ LONG Flags,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr = E_FAIL;
    ICertServerPolicy *pServer = NULL;
    CRequestInstance Request;
    BOOL fCA = FALSE;
    BSTR strDisposition = NULL;
    BOOL fCritSecEntered = FALSE;

    if (!m_fPolicyCriticalSection)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&m_PolicyCriticalSection);
    fCritSecEntered = TRUE;

    __try
    {
	if (NULL == pDisposition)
	{
	    hr = E_POINTER;
	    _LeaveError(hr, "Policy:pDisposition");
	}
	*pDisposition = VR_INSTANT_BAD;

	hr = polGetServerCallbackInterface(&pServer, Context);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");


	// only need to check user access for original submitter: resubmittal is restricted to admin
	if (bNewRequest && (0 == (m_dwEditFlags & EDITF_IGNOREREQUESTERGROUP)))
	{
	    BOOL fRequesterAccess = FALSE;

	    // Is this user allowed to request certs?
	    hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPREQUESTERCAACCESS,
				    (LONG *) &fRequesterAccess);
	    _PrintIfErrorStr(
			hr,
			"Policy:polGetCertificateLongProperty",
			wszPROPREQUESTERCAACCESS);
	    if (hr != S_OK || !fRequesterAccess)
	    {
		hr = E_ACCESSDENIED;
		_JumpError(hr, deny, "Policy:fRequesterAccess");
	    }
	}


	hr = Request.Initialize(
			    this,
			    pServer);
	_LeaveIfError(hr, "Policy:VerifyRequest:Request.Initialize");

	hr = _EnumerateExtensions(pServer, bNewRequest, TRUE);
	_LeaveIfError(hr, "_EnumerateExtensions");

	{
	    hr = _SetValidityPeriod(pServer);
	    _LeaveIfError(hr, "_SetValidityPeriod");

	    hr = _AddDefaultBasicConstraintsExtension(
				    pServer,
				    Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultBasicConstraintsExtension");

	    hr = _AddDefaultKeyUsageExtension(pServer, Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultKeyUsageExtension");

	    hr = _AddSubjectAltNameExtension(pServer, 0);
	    _LeaveIfError(hr, "_AddSubjectAltNameExtension");

	    hr = _AddSubjectAltNameExtension(pServer, 1);
	    _LeaveIfError(hr, "_AddSubjectAltNameExtension");
	}

	hr = EnumerateAttributes(pServer);
	_LeaveIfError(hr, "Policy:EnumerateAttributes");

	hr = _AddRevocationExtension(pServer);
	_LeaveIfError(hr, "_AddRevocationExtension");

	hr = _AddOldCertTypeExtension(pServer, Request.IsCARequest());
	_LeaveIfError(hr, "_AddOldCertTypeExtension");

	hr = _AddAuthorityKeyId(pServer);
	_LeaveIfError(hr, "_AddAuthorityKeyId");


	hr = _AddTemplateNameExtension(pServer, &Request);
	_LeaveIfError(hr, "_AddTemplateNameExtension");

	hr = CheckRequestProperties(pServer);
	_JumpIfError(hr, deny, "Policy:CheckRequestProperties"); // pass hr as Disposition

	if (EDITF_DISABLEEXTENSIONLIST & m_dwEditFlags)
	{
	    hr = _EnumerateExtensions(pServer, bNewRequest, FALSE);
	    _LeaveIfError(hr, "_EnumerateExtensions");
	}

	if (bNewRequest &&
	    (
	     (REQDISP_PENDINGFIRST & m_dwDispositionFlags)))
	{
	    *pDisposition = VR_PENDING;
	}
	else switch (REQDISP_MASK & m_dwDispositionFlags)
	{
	    default:
	    case REQDISP_PENDING:
		*pDisposition = VR_PENDING;
		break;

	    case REQDISP_ISSUE:
		*pDisposition = VR_INSTANT_OK;
		break;

	    case REQDISP_DENY:
		*pDisposition = VR_INSTANT_BAD;
		break;

	    case REQDISP_USEREQUESTATTRIBUTE:
		*pDisposition = VR_INSTANT_OK;
		hr = polGetRequestAttribute(
				    pServer,
				    wszPROPDISPOSITION,
				    &strDisposition);
		if (S_OK == hr)
		{
		    if (0 == lstrcmpi(wszPROPDISPOSITIONDENY, strDisposition))
		    {
			*pDisposition = VR_INSTANT_BAD;
		    }
		    if (0 == lstrcmpi(wszPROPDISPOSITIONPENDING, strDisposition))
		    {
			*pDisposition = VR_PENDING;
		    }
		}
		hr = S_OK;
		break;
	}
deny:
	if (FAILED(hr))
	{
	    *pDisposition = hr;	// pass failed HRESULT back as Disposition
	}
	else if (hr != S_OK)
	{
	    *pDisposition = VR_INSTANT_BAD;
	}
	hr = S_OK;
    }
    __except(hr = ceHError(GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != strDisposition)
    {
	SysFreeString(strDisposition);
    }
    if (NULL != pServer)
    {
        pServer->Release();
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&m_PolicyCriticalSection);
    }
    //_PrintIfError(hr, "Policy:VerifyRequest(hr)");
    //_PrintError(*pDisposition, "Policy:VerifyRequest(*pDisposition)");
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::GetDescription
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::GetDescription(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription)
{
    HRESULT hr = S_OK;

    if (NULL != *pstrDescription)
    {
        SysFreeString(*pstrDescription);
    }

    *pstrDescription = SysAllocString(m_strDescription);
    if (NULL == *pstrDescription)
    {
        hr = E_OUTOFMEMORY;
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::ShutDown
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::ShutDown(VOID)
{
    // called once, as Server unloading policy dll
    _Cleanup();
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
		    CLSID_CCertManagePolicyModuleSample,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
		    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_GetIssuer
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

PCCERT_CONTEXT
CCertPolicySample::_GetIssuer(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    BSTR strName = NULL;

    VariantInit(&varValue);
    if (NULL != m_pCert)
    {
        hr = S_OK;
	goto error;
    }
    strName = SysAllocString(wszPROPRAWCACERTIFICATE);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(strName, PROPTYPE_BINARY, &varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    m_pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    (BYTE *) varValue.bstrVal,
				    SysStringByteLen(varValue.bstrVal));
    if (NULL == m_pCert)
    {
	hr = ceHLastError();
	_JumpError(hr, error, "Policy:CertCreateCertificateContext");
    }

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(m_pCert);
}


STDMETHODIMP
CCertPolicySample::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
        &IID_ICertPolicy,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (IsEqualGUID(*arr[i], riid))
        {
            return(S_OK);
        }
    }
    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\policy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//--------------------------------------------------------------------------

#include "certpsam.h"
#include "resource.h"

#ifndef wszATTREMAIL1
# define wszATTREMAIL1			TEXT("E")
# define wszATTREMAIL2			TEXT("EMail")
#endif

#ifndef wszCERTTYPE_SUBORDINATE_CA
# define wszCERTTYPE_SUBORDINATE_CA	L"SubCA"
#endif

#ifndef wszCERTTYPE_CROSS_CA
# define wszCERTTYPE_CROSS_CA		L"CrossCA"
#endif

extern BOOL fDebug;

class CRequestInstance;

#ifndef __BSTRC__DEFINED__
#define __BSTRC__DEFINED__
typedef OLECHAR const *BSTRC;
#endif

HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context);

HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut);

DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR **ppwsz);

// 
// Class CCertPolicySample
// 
// Actual policy module for a CA Policy
//
//

class CCertPolicySample: 
    public CComDualImpl<ICertPolicy2, &IID_ICertPolicy2, &LIBID_CERTPOLICYSAMPLELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertPolicySample, &CLSID_CCertPolicySample>
{
public:
    CCertPolicySample()
    {
        HRESULT hr;
	
	m_strDescription = NULL;

        // RevocationExtension variables:

	m_dwRevocationFlags = 0;
	m_wszASPRevocationURL = NULL;

        m_dwDispositionFlags = 0;
        m_dwEditFlags = 0;

	// CertTypeExtension variables:

	m_astrSubjectAltNameProp[0] = NULL;
	m_astrSubjectAltNameProp[1] = NULL;
	m_astrSubjectAltNameObjectId[0] = NULL;
	m_astrSubjectAltNameObjectId[1] = NULL;

	m_cEnableRequestExtensions = 0;
	m_apstrEnableRequestExtensions = NULL;

	m_cDisableExtensions = 0;
	m_apstrDisableExtensions = NULL;

	// CA Name
        m_strRegStorageLoc = NULL;

	m_strCAName = NULL;
        m_strCASanitizedName = NULL;
        m_strCASanitizedDSName = NULL;
        m_strMachineDNSName = NULL;

	m_fPolicyCriticalSection = FALSE;
	__try
	{
	    InitializeCriticalSection(&m_PolicyCriticalSection);
	    m_fPolicyCriticalSection = TRUE;
	}
	__except(hr = ceHError(GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER)
	{
	}

        // CA and cert type info

        m_CAType = ENUM_UNKNOWN_CA;

        m_hrLastUpdateResult = S_OK;
        m_pCert = NULL;
        m_iCRL = 0;

    }
    ~CCertPolicySample();

BEGIN_COM_MAP(CCertPolicySample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertPolicy)
    COM_INTERFACE_ENTRY(ICertPolicy2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertPolicySample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertPolicySample,
    wszCLASS_CERTPOLICYSAMPLE TEXT(".1"),
    wszCLASS_CERTPOLICYSAMPLE,
    IDS_CERTPOLICY_DESC,
    THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICertPolicy
public:
    STDMETHOD(Initialize)( 
		/* [in] */ BSTR const strConfig);

    STDMETHOD(VerifyRequest)( 
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Context,
		/* [in] */ LONG bNewRequest,
		/* [in] */ LONG Flags,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetDescription)( 
		/* [out, retval] */ BSTR __RPC_FAR *pstrDescription);

    STDMETHOD(ShutDown)();

// ICertPolicy2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

public:
    HRESULT AddBasicConstraintsCommon(
		IN ICertServerPolicy *pServer,
		IN CERT_EXTENSION const *pExtension,
		IN BOOL fCA,
		IN BOOL fEnableExtension);

    BSTRC GetPolicyDescription() { return(m_strDescription); }


private:
    CERT_CONTEXT const *_GetIssuer(
		IN ICertServerPolicy *pServer);

    HRESULT _EnumerateExtensions(
		IN ICertServerPolicy *pServer,
		IN LONG bNewRequest,
		IN BOOL fFirstPass);

#if DBG_CERTSRV
    VOID _DumpStringArray(
		IN char const *pszType,
		IN DWORD count,
		IN BSTR const *apstr);
#else
    #define _DumpStringArray(pszType, count, apstr)
#endif

    VOID _FreeStringArray(
		IN OUT DWORD *pcString,
		IN OUT LPWSTR **papstr);

    VOID _Cleanup();


    HRESULT _SetSystemStringProp(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszName,
		OPTIONAL IN WCHAR const *pwszValue);

    HRESULT _AddStringArray(
		IN WCHAR const *pwszzValue,
		IN BOOL fURL,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papstrRegValues);

    HRESULT _ReadRegistryString(
		IN HKEY hkey,
		IN BOOL fURL,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszSuffix,
		OUT LPWSTR *pwszRegValue);

    HRESULT _ReadRegistryStringArray(
		IN HKEY hkey,
		IN BOOL fURL,
		IN DWORD dwFlags,
		IN DWORD cRegNames,
		IN DWORD *aFlags,
		IN WCHAR const * const *apwszRegNames,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papstrRegValues);

    VOID _InitRevocationExtension(
		IN HKEY hkey);

    VOID _InitSubjectAltNameExtension(
		IN HKEY hkey,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszObjectId,
		IN DWORD iAltName);

    VOID _InitRequestExtensionList(
		IN HKEY hkey);

    VOID _InitDisableExtensionList(
		IN HKEY hkey);

    HRESULT _AddRevocationExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddOldCertTypeExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddTemplateNameExtension(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _AddSubjectAltNameExtension(
		IN ICertServerPolicy *pServer,
		IN DWORD iAltName);

    HRESULT _AddAuthorityKeyId(
		IN ICertServerPolicy *pServer);

    HRESULT _AddDefaultKeyUsageExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddDefaultBasicConstraintsExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _SetValidityPeriod(
		IN ICertServerPolicy *pServer);


private:
    // RevocationExtension variables:

    PCCERT_CONTEXT m_pCert;

    BSTR  m_strDescription;

    DWORD m_dwRevocationFlags;
    LPWSTR m_wszASPRevocationURL;

    DWORD m_dwDispositionFlags;
    DWORD m_dwEditFlags;
    DWORD m_CAPathLength;

    DWORD m_cEnableRequestExtensions;
    LPWSTR *m_apstrEnableRequestExtensions;

    DWORD m_cDisableExtensions;
    LPWSTR *m_apstrDisableExtensions;

    // SubjectAltNameExtension variables:

    BSTR m_astrSubjectAltNameProp[2];
    BSTR m_astrSubjectAltNameObjectId[2];

    // CertTypeExtension variables:

    BSTR m_strRegStorageLoc;
    BSTR m_strCAName;

    BSTR m_strCASanitizedName;
    BSTR m_strCASanitizedDSName;

    BSTR m_strMachineDNSName;

    CRITICAL_SECTION m_PolicyCriticalSection;
    BOOL m_fPolicyCriticalSection;
    
    // CA and cert type info

    ENUM_CATYPES m_CAType;

    DWORD m_hrLastUpdateResult;

    DWORD m_iCert;
    DWORD m_iCRL;

};

// 
// Class CRequestInstance
// 
// Instance data for a certificate that is being created.
//

class CRequestInstance
{

public:
    CRequestInstance()
    {
        m_strTemplateName = NULL;
	m_strTemplateObjId = NULL;
	m_pPolicy = NULL;

    }

    ~CRequestInstance();

    HRESULT Initialize(
		IN CCertPolicySample *pPolicy,
		IN ICertServerPolicy *pServer);

    HRESULT SetTemplateName(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszTemplateName,
		IN WCHAR const *pwszTemplateObjId);

    BSTRC GetTemplateName() { return(m_strTemplateName); }
    BSTRC GetTemplateObjId() { return(m_strTemplateObjId); }


    BOOL IsCARequest() { return(m_fCA); }

    CCertPolicySample *GetPolicy() { return(m_pPolicy); }

private:

    HRESULT _SetFlagsProperty(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszPropName,
		IN DWORD dwFlags);

    BOOL _TemplateNamesMatch(
		IN WCHAR const *pwszTemplateName1,
		IN WCHAR const *pwszTemplateName2);

    VOID _Cleanup();		
private:			
    CCertPolicySample *m_pPolicy;
    BSTR                   m_strTemplateName;	// certificate type requested
    BSTR                   m_strTemplateObjId;	// certificate type requested
    DWORD                  m_dwTemplateMajorVersion;
    DWORD                  m_dwTemplateMinorVersion;
    BOOL		   m_fCA;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\policy0.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//--------------------------------------------------------------------------

#include "certpsam.h"
#include "resource.h"

#ifndef wszATTREMAIL1
# define wszATTREMAIL1			TEXT("E")
# define wszATTREMAIL2			TEXT("EMail")
#endif

#ifndef wszCERTTYPE_SUBORDINATE_CA
# define wszCERTTYPE_SUBORDINATE_CA	L"SubCA"
#endif

#ifndef wszCERTTYPE_CROSS_CA
# define wszCERTTYPE_CROSS_CA		L"CrossCA"
#endif

extern BOOL fDebug;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        request.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"


VOID
reqCleanup()
{
}


CRequestInstance::~CRequestInstance()
{
    _Cleanup();
}


VOID
CRequestInstance::_Cleanup()
{
    if (NULL != m_strTemplateName)
    {
        SysFreeString(m_strTemplateName);
        m_strTemplateName = NULL;
    }
    if (NULL != m_strTemplateObjId)
    {
        SysFreeString(m_strTemplateObjId);
        m_strTemplateObjId = NULL;
    }
}


static WCHAR const *s_apwszCATypes[] =
{
    wszCERTTYPE_SUBORDINATE_CA,
    wszCERTTYPE_CROSS_CA,
};

//+--------------------------------------------------------------------------
// CRequestInstance::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::Initialize(
    IN CCertPolicySample *pPolicy,
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hrTemplate = S_OK;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    CERT_NAME_VALUE *pName = NULL;
    BSTR strTemplateObjId = NULL;	// from V2 template extension
    BSTR strTemplateName = NULL;	// from V1 template extension
    BSTR strTemplateRA = NULL;		// from request attributes
    WCHAR const *pwszTemplateName;
    WCHAR const *pwszTemplateObjId;
    VARIANT varValue;
    DWORD cbType;
    DWORD i;
    BOOL fConflict;
    BOOL fRAObjId = FALSE;

    m_pPolicy = pPolicy;
    m_fCA = FALSE;


    // Retrieve the template ObjId from the V2 cert template info extension

    m_dwTemplateMajorVersion = 0;
    m_dwTemplateMinorVersion = 0;
    hr = pServer->GetCertificateExtension(
                                    TEXT(szOID_CERTIFICATE_TEMPLATE),
                                    PROPTYPE_BINARY,
                                    &varValue);
    _PrintIfErrorStr(
		hr,
		"Policy:GetCertificateExtension",
		TEXT(szOID_CERTIFICATE_TEMPLATE));
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERTIFICATE_TEMPLATE,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    FALSE,
		    (VOID **) &pTemplate,
		    &cbType))
        {
            hr = ceHLastError();
	    _JumpError(hr, error, "Policy:ceDecodeObject");
        }
	if (!ceConvertSzToBstr(&strTemplateObjId, pTemplate->pszObjId, -1))
	{
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertSzToBstr");
        }
	m_dwTemplateMajorVersion = pTemplate->dwMajorVersion;
	m_dwTemplateMinorVersion = pTemplate->dwMinorVersion;
	DBGPRINT((
	    fDebug,
	    pTemplate->fMinorVersion?
		"Extension Template Info: %ws V%u.%u\n" :
		"Extension Template Info: %ws V%u%\n",
	    strTemplateObjId,
	    m_dwTemplateMajorVersion,
	    m_dwTemplateMinorVersion));
    }

    // Retrieve template Name from the V1 cert template name extension

    hr = pServer->GetCertificateExtension(
                                    TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
                                    PROPTYPE_BINARY,
                                    &varValue);
    _PrintIfErrorStr(
		hr,
		"Policy:GetCertificateExtension",
		TEXT(szOID_ENROLL_CERTTYPE_EXTENSION));
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    FALSE,
		    (VOID **) &pName,
		    &cbType))
        {
            hr = ceHLastError();
	    _JumpError(hr, error, "Policy:ceDecodeObject");
        }
        strTemplateName = SysAllocStringByteLen(
					(char *) pName->Value.pbData,
					pName->Value.cbData);
        if (NULL == strTemplateName)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocStringByteLen");
        }
	DBGPRINT((fDebug, "Extension Template: %ws\n", strTemplateName));
    }

    fConflict = FALSE;

    // Retrieve the template from the request attributes

    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strTemplateRA);
    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "Policy:polGetRequestAttribute", wszPROPCERTTEMPLATE);
	hr = S_OK;


    }
    else
    {
	DBGPRINT((fDebug, "Attribute Template: %ws\n", strTemplateRA));
	if (NULL != strTemplateObjId &&
	    !_TemplateNamesMatch(strTemplateObjId, strTemplateRA))
	{
	    fConflict = TRUE;
	}
	if (NULL != strTemplateName &&
	    !_TemplateNamesMatch(strTemplateName, strTemplateRA))
	{
	    fConflict = TRUE;
	}
	hr = ceVerifyObjId(strTemplateRA);
	fRAObjId = S_OK == hr;
    }

    if (NULL != strTemplateObjId &&
	NULL != strTemplateName &&
	!_TemplateNamesMatch(strTemplateObjId, strTemplateName))
    {
	fConflict = TRUE;
    }

    if (fConflict)
    {
	hrTemplate = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
	if (NULL != strTemplateObjId)
	{
	    _PrintErrorStr(
			hr,
			"Policy:Extension Template ObjId",
			strTemplateObjId);
	}
	if (NULL != strTemplateName)
	{
	    _PrintErrorStr(
			hr,
			"Policy:Extension Template Name",
			strTemplateName);
	}
	if (NULL != strTemplateRA)
	{
	    _PrintErrorStr(
			hr,
			"Policy:Attribute Template",
			strTemplateRA);
	}
    }

    pwszTemplateName = strTemplateName;
    pwszTemplateObjId = strTemplateObjId;
    if (fRAObjId)
    {
	if (NULL == pwszTemplateObjId)
	{
	    pwszTemplateObjId = strTemplateRA;
	}
    }
    else
    {
	if (NULL == pwszTemplateName)
	{
	    pwszTemplateName = strTemplateRA;
	}
    }


    {
	for (i = 0; i < ARRAYSIZE(s_apwszCATypes); i++)
	{
	    if (0 == lstrcmpi(s_apwszCATypes[i], strTemplateObjId))
	    {
		m_fCA = TRUE;
		break;
	    }
	}
    }
    hr = SetTemplateName(pServer, pwszTemplateName, pwszTemplateObjId);
    _JumpIfError(hr, error, "Policy:SetTemplateName");

    if (S_OK != hr)
    {
	_JumpError(hr, error, "Policy:Missing or conflicting template name");
    }

error:
    if (S_OK != hrTemplate)
    {
	hr = hrTemplate;	// override secondary errors
    }
    VariantClear(&varValue);
    if (NULL != pName)
    {
        LocalFree(pName);
    }
    if (NULL != pTemplate)
    {
        LocalFree(pTemplate);
    }
    if (NULL != strTemplateObjId)
    {
        SysFreeString(strTemplateObjId);
    }
    if (NULL != strTemplateName)
    {
        SysFreeString(strTemplateName);
    }
    if (NULL != strTemplateRA)
    {
        SysFreeString(strTemplateRA);
    }
    return(hr);
}


BOOL
CRequestInstance::_TemplateNamesMatch(
    IN WCHAR const *pwszTemplateName1,
    IN WCHAR const *pwszTemplateName2)
{
    HRESULT hr1;
    HRESULT hr2;
    BOOL fMatch = TRUE;

    if (0 == lstrcmpi(pwszTemplateName1, pwszTemplateName2))
    {
	goto done;	// identical names
    }

    {
	hr1 = ceVerifyObjId(pwszTemplateName1);
	hr2 = ceVerifyObjId(pwszTemplateName2);
	if ((S_OK == hr1) ^ (S_OK == hr2))
	{
	    goto done;
	}
    }
    fMatch = FALSE;

done:
    return(fMatch);
}


//+--------------------------------------------------------------------------
// CRequestInstance::SetTemplateName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::SetTemplateName(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszTemplateName,
    IN WCHAR const *pwszTemplateObjId)
{
    HRESULT hr=E_INVALIDARG;
    BSTR strProp = NULL;
    BSTR strTemplateName = NULL;

    if (NULL != pwszTemplateName)
    {
	m_strTemplateName = SysAllocString(pwszTemplateName);
	if (NULL == m_strTemplateName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateName;
    }

    if (NULL != pwszTemplateObjId)
    {
	m_strTemplateObjId = SysAllocString(pwszTemplateObjId);
	if (NULL == m_strTemplateObjId)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateObjId;
    }

    if (NULL != strTemplateName)
    {
	VARIANT var;

	strProp = SysAllocString(wszPROPCERTIFICATETEMPLATE);
	if (NULL == strProp)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	var.vt = VT_BSTR;
	var.bstrVal = strTemplateName;

	hr = pServer->SetCertificateProperty(strProp, PROPTYPE_STRING, &var);
	_JumpIfError(hr, error, "Policy:SetCertificateProperty");
    }

error:
    if (NULL != strProp)
    {
	SysFreeString(strProp);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\request0.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        request.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\policy\sample\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certpsam.rc
//
#define IDS_CERTPOLICY_DESC	1
#define IDS_CERTMANAGEPOLICYMODULE_DESC 2


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\common.h ===
//--------------------------------------------------------------------
// Common - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-11-99
//
// Common definitions for the CEP project
//--------------------------------------------------------------
#ifndef CEP_COMMON_H
#define CEP_COMMON_H

#ifdef __cplusplus
extern "C" {
#endif


#define CEP_STORE_NAME                  L"CEP"
#define CEP_DLL_NAME                    L"mscep.dll"
#define	CERTSVC_NAME					L"certsvc"
#define	CEP_DIR_NAME					L"mscep"
#define	IIS_NAME						L"w3svc"
#define ENCODE_TYPE						PKCS_7_ASN_ENCODING | X509_ASN_ENCODING

#define MSCEP_REFRESH_LOCATION          L"Software\\Microsoft\\Cryptography\\MSCEP\\Refresh" 
#define MSCEP_PASSWORD_LOCATION         L"Software\\Microsoft\\Cryptography\\MSCEP\\EnforcePassword" 
#define MSCEP_PASSWORD_MAX_LOCATION     L"Software\\Microsoft\\Cryptography\\MSCEP\\PasswordMax" 
#define MSCEP_PASSWORD_VALIDITY_LOCATION     L"Software\\Microsoft\\Cryptography\\MSCEP\\PasswordValidity" 
#define MSCEP_CACHE_REQUEST_LOCATION    L"Software\\Microsoft\\Cryptography\\MSCEP\\CacheRequest" 
#define MSCEP_CATYPE_LOCATION			L"Software\\Microsoft\\Cryptography\\MSCEP\\CAType"

#define MSCEP_KEY_REFRESH               L"RefreshPeriod"
#define MSCEP_KEY_PASSWORD              L"EnforcePassword"
#define MSCEP_KEY_PASSWORD_MAX          L"PasswordMax"
#define MSCEP_KEY_PASSWORD_VALIDITY     L"PasswordValidity"
#define MSCEP_KEY_CACHE_REQUEST			L"CacheRequest"
#define MSCEP_KEY_CATYPE				L"CAType"


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //CEP_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\cepasn.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#include <windows.h>
#include "cepasn.h"

ASN1module_t CEPASN_Module = NULL;

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_IssuerAndSerialNumber,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_IssuerAndSerialNumber,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_IssuerAndSerialNumber,
};
static const ULONG sizetab[1] = {
    SIZE_CEPASN_Module_PDU_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL CEPASN_Module_Startup(void)
{
    CEPASN_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x61706563);
}

void ASN1CALL CEPASN_Module_Cleanup(void)
{
    ASN1_CloseModule(CEPASN_Module);
    CEPASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->issuer))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val)
{
    if (val) {
	ASN1open_free(&(val)->issuer);
	ASN1intx_free(&(val)->serialNumber);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\cepca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cepca.cpp
//
//  Contents:   Cisco enrollment protocal implementation.
//				This file has CA specific code.
//
//
//	BOOL	fResult = FALSE;
//	fResult = TRUE;
//
//	CommonReturn:
//
//		return fResult;
//
//	ErrorReturn:
//
//		fResult=FALSE;
//		goto CommonReturn;
//
//	SET_ERROR(InvalidArgErr, E_INVALIDARG);
//
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>


//--------------------------------------------------------------------------
//
//	InitCAInformation
//
//--------------------------------------------------------------------------
BOOL	InitCAInformation(CEP_CA_INFO	*pCAInfo)
{
	BOOL			fResult = FALSE;
	long			nCount=0;
	long			nIndex=0;
	WCHAR			wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD			dwSize=MAX_COMPUTERNAME_LENGTH + 1;
	HRESULT			hr = E_FAIL;
	DWORD			cbData=0;
	DWORD			dwData=0;
	DWORD			dwType=0;
	long			dwErr=0;

	ICertConfig		*pICertConfig=NULL;
	BSTR			bstrFieldName=NULL;
	BSTR			bstrFieldValue=NULL;
    HKEY            hKeyCAType=NULL;


	memset(pCAInfo, 0, sizeof(CEP_CA_INFO));

	//we should only worry about the NetBois name.  Do not care about the DNS
	//GetComputerNameW in Win2K only returns NetBois name
	//NT5 SPECIFIC
	//TODO: We need to get the DNS name and parse for the NetBoise name that way
	if(!GetComputerNameW(wszComputerName, &dwSize))
		goto TraceErr;

	if(S_OK != (hr=CoCreateInstance(CLSID_CCertConfig,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_ICertConfig,
									(void **)&pICertConfig)))
		goto CertSrvErr;

	if(S_OK != (hr=pICertConfig->Reset(nIndex, &nCount)))
		goto CertSrvErr;

	if(0==nCount)
		goto NoSrvErr;

	if(NULL == (bstrFieldName=SysAllocString(L"Server")))
		goto MemoryErr;

	while(nIndex != -1)
	{
		//find the configuration that matches the current machine's name
		if(S_OK != (hr=pICertConfig->GetField(bstrFieldName, &bstrFieldValue)))
			goto CertSrvErr;

		if(0==_wcsnicmp(bstrFieldValue, wszComputerName, wcslen(wszComputerName)))
		{
			if(NULL == ((pCAInfo->bstrCAMachine)=SysAllocString(bstrFieldValue)))
				goto MemoryErr;

			//CA name
			SysFreeString(bstrFieldName);  
			bstrFieldName=NULL;

			if(NULL == (bstrFieldName=SysAllocString(L"Authority")))
				goto MemoryErr;

			if(S_OK != (hr=pICertConfig->GetField(bstrFieldName, &(pCAInfo->bstrCAName))))
				goto CertSrvErr;

			if(NULL == pCAInfo->bstrCAName)
				goto FailErr;

			//CA config
			SysFreeString(bstrFieldName);  
			bstrFieldName=NULL;

			if(NULL == (bstrFieldName=SysAllocString(L"Config")))
				goto MemoryErr;

			if(S_OK != (hr=pICertConfig->GetField(bstrFieldName, &(pCAInfo->bstrCAConfig))))
				goto CertSrvErr;

			if(NULL == pCAInfo->bstrCAConfig)
				goto FailErr;

			if(S_OK != (hr=CoCreateInstance(CLSID_CCertRequest,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_ICertRequest,
											(void **)&(pCAInfo->pICertRequest))))
				goto CertSrvErr;

			//success
			break;
		}

		SysFreeString(bstrFieldValue);
		bstrFieldValue=NULL;

		hr = pICertConfig->Next(&nIndex);

		if( (S_OK != hr) && (-1 != nIndex))
			goto CertSrvErr;
	}

	if(-1 == nIndex)
		goto NoSrvErr;

	//get the CA's type from the registry
	cbData=sizeof(dwData);
		
	//we have to have the knowledge of the ca type
	if(ERROR_SUCCESS != (dwErr =  RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_CATYPE_LOCATION,
                    0,
                    KEY_READ,
                    &hKeyCAType)))
		goto RegErr;

    if(ERROR_SUCCESS != (dwErr = RegQueryValueExU(
                    hKeyCAType,
                    MSCEP_KEY_CATYPE,
                    NULL,
                    &dwType,
                    (BYTE *)&dwData,
                    &cbData)))
		goto RegErr;

	if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
		goto RegErr;

	if(0 == dwData)
		pCAInfo->fEnterpriseCA=FALSE;
	else
		pCAInfo->fEnterpriseCA=TRUE;

	//get the hProv to generate the random password
	if(!CryptAcquireContextU(&(pCAInfo->hProv),
                NULL,
                MS_DEF_PROV_W,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

    if(hKeyCAType)
        RegCloseKey(hKeyCAType);

	if(bstrFieldName)
		SysFreeString(bstrFieldName);

	if(bstrFieldValue)
		SysFreeString(bstrFieldValue);

	if(pICertConfig)
		pICertConfig->Release();

	return fResult;

ErrorReturn:

	FreeCAInformation(pCAInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(CertSrvErr, hr);
SET_ERROR(NoSrvErr, E_FAIL);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(FailErr, E_FAIL);
SET_ERROR_VAR(RegErr, dwErr);
}

//--------------------------------------------------------------------------
//
//	GetCACertFromInfo
//
//--------------------------------------------------------------------------
BOOL	GetCACertFromInfo(CEP_CA_INFO	*pCAInfo, HCERTSTORE *pHCACertStore)
{
	BOOL			fResult = FALSE;
	HRESULT			hr = S_OK;	
	CERT_BLOB		CertBlob;
	DWORD			dwFlags=0;
	PCCERT_CONTEXT	pPreCert=NULL;
	DWORD			cbData=0;
	
	BSTR			bstrCACert=NULL;
	PCCERT_CONTEXT	pCurCert=NULL; 
	BYTE			*pbData=NULL;

	if(NULL == (pCAInfo->pICertRequest))
		goto InvalidArgErr;

	//NT5 SPECIFIC: fExchangeCertificate can only be FALSE
	if(S_OK != (hr=(pCAInfo->pICertRequest)->GetCACertificate(
							FALSE,
							pCAInfo->bstrCAConfig,
							CR_OUT_BINARY | CR_OUT_CHAIN,
							&bstrCACert)))
		goto CAErr;

	if(NULL == bstrCACert)
		goto UnexpectedErr;

	CertBlob.cbData = (DWORD)SysStringByteLen(bstrCACert);
	CertBlob.pbData = (BYTE *)bstrCACert;

	if(NULL == (*pHCACertStore = CertOpenStore(
							CERT_STORE_PROV_PKCS7,
							ENCODE_TYPE,
							NULL,
							0,
							&CertBlob)))
		goto TraceErr;

	//we now need to get the CA's certificate's MD5 hash
	while(pCurCert=CertEnumCertificatesInStore(*pHCACertStore,
												pPreCert))
	{
		dwFlags = CERT_STORE_SIGNATURE_FLAG;
		if(CertVerifySubjectCertificateContext(pCurCert,
												pCurCert,
												&dwFlags) && (0==dwFlags))

			break;

		pPreCert=pCurCert;
	}

	if(NULL==pCurCert)
		goto InvalidArgErr;

	//get the MD5 hash
	if(!CertGetCertificateContextProperty(pCurCert,
										CERT_MD5_HASH_PROP_ID,
										NULL,
										&cbData))
		goto TraceErr;

	pbData=(BYTE *)malloc(cbData);

	if(NULL==pbData)
		goto MemoryErr;

	if(!CertGetCertificateContextProperty(pCurCert,
										CERT_MD5_HASH_PROP_ID,
										pbData,
										&cbData))
		goto TraceErr;


	if(!ConvertByteToWstr(pbData, cbData, &(pCAInfo->pwszCAHash), TRUE))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	if(pbData)
		free(pbData);

	if(pCurCert)
		CertFreeCertificateContext(pCurCert);

	if(bstrCACert)
		SysFreeString(bstrCACert);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(CAErr, hr);		 
TRACE_ERROR(TraceErr);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	FreeCAInformation
//
//--------------------------------------------------------------------------
BOOL	FreeCAInformation(CEP_CA_INFO	*pCAInfo)
{
	if(pCAInfo)
	{
		if(pCAInfo->bstrCAMachine)
			SysFreeString(pCAInfo->bstrCAMachine);

		if(pCAInfo->bstrCAName)
			SysFreeString(pCAInfo->bstrCAName);

		if(pCAInfo->bstrCAConfig)
			SysFreeString(pCAInfo->bstrCAConfig);

		if(pCAInfo->pwszCAHash)
			free(pCAInfo->pwszCAHash);

		if(pCAInfo->hProv)
			CryptReleaseContext(pCAInfo->hProv, 0);

		if(pCAInfo->pICertRequest)
			(pCAInfo->pICertRequest)->Release();

		//reset the data
		memset(pCAInfo, 0, sizeof(CEP_CA_INFO));
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	OperationGetCACert
//
//--------------------------------------------------------------------------
BOOL	OperationGetCACert(HCERTSTORE		hCACertStore,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData)
{
	BOOL				fResult = FALSE;
	CERT_BLOB			CertBlob;			

	CertBlob.cbData=0;
	CertBlob.pbData=NULL;

	if(!CertSaveStore(hCACertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto CertErr;

	CertBlob.pbData = (BYTE *)malloc(CertBlob.cbData);

	if(NULL == CertBlob.pbData)
		goto MemoryErr;

	if(!CertSaveStore(hCACertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto CertErr;

	//copy the memory
	*ppbData=CertBlob.pbData;
	*pcbData=CertBlob.cbData;
	
	CertBlob.pbData=NULL;

	fResult = TRUE;

CommonReturn:

	if(CertBlob.pbData)
		free(CertBlob.pbData);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(CertErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\cepasn.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#ifndef _CEPASN_Module_H_
#define _CEPASN_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct IssuerAndSerialNumber {
    ASN1open_t issuer;
    ASN1intx_t serialNumber;
} IssuerAndSerialNumber;
#define IssuerAndSerialNumber_PDU 0
#define SIZE_CEPASN_Module_PDU_0 sizeof(IssuerAndSerialNumber)


extern ASN1module_t CEPASN_Module;
extern void ASN1CALL CEPASN_Module_Startup(void);
extern void ASN1CALL CEPASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _CEPASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\cepcache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       ceppswrd.cpp
//
//  Contents:   Cisco enrollment protocol implementation.  This module
//				implement the request hash table.
//              
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

DWORD							g_dwRequestDuration=0;
CEP_REQUEST_TABLE_INFO			g_CEPRequestTable;

//***************************************************************************
//
//	The following are APIs called internally.
//
//
//***************************************************************************
//--------------------------------------------------------------------------
//
//	CEPRequestFreeRequestEntry
//
//--------------------------------------------------------------------------
void	CEPRequestFreeRequestEntry(CEP_REQUEST_ENTRY *pRequestEntry)
{
	if(pRequestEntry)
	{

		free(pRequestEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPRequestFreeValidityEntry
//
//--------------------------------------------------------------------------
void CEPRequestFreeValidityEntry(CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry, 
								  BOOL							fFreeRequestEntry)
{
	if(pValidityEntry)
	{
		if(fFreeRequestEntry)
			CEPRequestFreeRequestEntry(pValidityEntry->pRequestEntry);

		free(pValidityEntry);
	}
}


//--------------------------------------------------------------------------
//
//	CEPHashRequest
//
//  For any cases that we can not convert the psz, we use index 0.
//--------------------------------------------------------------------------
BOOL CEPHashRequest(BYTE	*pbHash, DWORD	*pdw)
{
	BYTE	byte=0;

	*pdw=0;

	if(!pbHash)
		return FALSE;

	byte=pbHash[0];

	*pdw=(DWORD)byte;

	if(*pdw >= CEP_HASH_TABLE_SIZE)
		*pdw=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPSearchRequest
//  
//--------------------------------------------------------------------------
CEP_REQUEST_ENTRY  *CEPSearchRequest(BYTE	*pbHash, DWORD *pdwIndex)
{
	CEP_REQUEST_ENTRY		*pRequestEntry=NULL;
	DWORD					dwHashIndex=0;

	if(pdwIndex)
		*pdwIndex=0;

	if(NULL==pbHash)
		return NULL;

	//hash based on the 1st byte
	if(!CEPHashRequest(pbHash, &dwHashIndex))
		return NULL;

	for(pRequestEntry=g_CEPRequestTable.rgRequestEntry[dwHashIndex]; NULL != pRequestEntry; pRequestEntry=pRequestEntry->pNext)
	{
		if(0==memcmp(pRequestEntry->pbHash, pbHash, CEP_MD5_HASH_SIZE))
		{
			break;
		}
	}

	if(pRequestEntry)
	{
		if(pdwIndex)
			*pdwIndex=dwHashIndex; 
	}

	return pRequestEntry;
}

//--------------------------------------------------------------------------
//
//	CEPInsertValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertValidityEntry(CEP_REQUEST_VALIDITY_ENTRY *pValidityEntry)
{
	if(!pValidityEntry)
		return FALSE;

	if(g_CEPRequestTable.pTimeNew)
	{
		g_CEPRequestTable.pTimeNew->pNext=pValidityEntry;
		pValidityEntry->pPrevious=g_CEPRequestTable.pTimeNew;
		g_CEPRequestTable.pTimeNew=pValidityEntry;
	}
	else
	{
		//no item in the list yet
		g_CEPRequestTable.pTimeOld=pValidityEntry;
		g_CEPRequestTable.pTimeNew=pValidityEntry;
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	CEPInsertRequestEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertRequestEntry(CEP_REQUEST_ENTRY *pRequestEntry, DWORD dwHashIndex)
{

	if(!pRequestEntry)
		return FALSE;

	if(g_CEPRequestTable.rgRequestEntry[dwHashIndex])
	{
	   g_CEPRequestTable.rgRequestEntry[dwHashIndex]->pPrevious=pRequestEntry;
	   pRequestEntry->pNext=g_CEPRequestTable.rgRequestEntry[dwHashIndex];
	   g_CEPRequestTable.rgRequestEntry[dwHashIndex]=pRequestEntry;
	}
	else
	{
		//1st item
		g_CEPRequestTable.rgRequestEntry[dwHashIndex]=pRequestEntry;
	}

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPRequestRemoveValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPRequestRemoveValidityEntry(CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry)
{
	BOOL	fResult=FALSE;

	if(!pValidityEntry)
		goto InvalidArgErr;

	if(pValidityEntry->pPrevious)
		pValidityEntry->pPrevious->pNext=pValidityEntry->pNext;
	else
	{
		//1st item
		g_CEPRequestTable.pTimeOld=pValidityEntry->pNext;
	}

	if(pValidityEntry->pNext)
		pValidityEntry->pNext->pPrevious=pValidityEntry->pPrevious;
	else
	{
		//last itme
		g_CEPRequestTable.pTimeNew=pValidityEntry->pPrevious;

	}

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPRequestRemoveRequestEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPRequestRemoveRequestEntry(CEP_REQUEST_ENTRY	*pRequestEntry, DWORD dwIndex)
{
	BOOL	fResult=FALSE;

	if(!pRequestEntry)
		goto InvalidArgErr;


	if(pRequestEntry->pPrevious)
		pRequestEntry->pPrevious->pNext=pRequestEntry->pNext;
	else
		g_CEPRequestTable.rgRequestEntry[dwIndex]=pRequestEntry->pNext;

	if(pRequestEntry->pNext)
		pRequestEntry->pNext->pPrevious=pRequestEntry->pPrevious;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPRequestRefresh
//
//--------------------------------------------------------------------------
BOOL	CEPRequestRefresh()
{
	BOOL						fResult=FALSE;	
	DWORD						dwHashIndex=0;
	CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry=NULL;

	while(g_CEPRequestTable.pTimeOld)
	{
		if(!CEPHashIsCurrentTimeEntry(&(g_CEPRequestTable.pTimeOld->TimeStamp), 0, g_dwRequestDuration))
		{  
			if(!CEPHashRequest(g_CEPRequestTable.pTimeOld->pRequestEntry->pbHash, &dwHashIndex))
			{
				g_CEPRequestTable.pTimeOld->pPrevious=NULL;
				goto InvalidArgErr;
			}

			CEPRequestRemoveRequestEntry(g_CEPRequestTable.pTimeOld->pRequestEntry, dwHashIndex);

			CEPRequestFreeRequestEntry(g_CEPRequestTable.pTimeOld->pRequestEntry);

			pValidityEntry=g_CEPRequestTable.pTimeOld;

			g_CEPRequestTable.pTimeOld=g_CEPRequestTable.pTimeOld->pNext;

			CEPRequestFreeValidityEntry(pValidityEntry, FALSE);
		}
		else
		{	
			//we find a new enough entry
			g_CEPRequestTable.pTimeOld->pPrevious=NULL;
			break;
		}
	}

	//we have get rid of all items
	if(NULL == g_CEPRequestTable.pTimeOld)
	{
		g_CEPRequestTable.pTimeNew=NULL;
	}
	
	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//***************************************************************************
//
//	The following are APIs called by the upper (external) layer
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	InitRequestTable
//
//--------------------------------------------------------------------------
BOOL	WINAPI	InitRequestTable()
{
	DWORD				cbData=0;
	DWORD				dwData=0;
	DWORD				dwType=0;

    HKEY                hKey=NULL;

	memset(&g_CEPRequestTable, 0, sizeof(CEP_REQUEST_TABLE_INFO));

	g_dwRequestDuration=CEP_REQUEST_DURATION;

	if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_CACHE_REQUEST_LOCATION,
                    0,
                    KEY_READ,
                    &hKey))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        MSCEP_KEY_CACHE_REQUEST,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				g_dwRequestDuration=dwData;	
			}
		}
	}

    if(hKey)
        RegCloseKey(hKey);

	return TRUE;

}

//--------------------------------------------------------------------------
//
//	ReleaseRequestTable
//
//--------------------------------------------------------------------------
BOOL WINAPI  ReleaseRequestTable()
{

	CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry=NULL;

	if(g_CEPRequestTable.pTimeOld)
	{
		do{
			pValidityEntry=g_CEPRequestTable.pTimeOld;

			g_CEPRequestTable.pTimeOld = g_CEPRequestTable.pTimeOld->pNext;
			
			CEPRequestFreeValidityEntry(pValidityEntry, TRUE);
		}
		while(g_CEPRequestTable.pTimeOld);
	}
			
	memset(&g_CEPRequestTable, 0, sizeof(CEP_REQUEST_TABLE_INFO));
	

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPRequestRetrieveRequestIDFromHash
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPRequestRetrieveRequestIDFromHash(BYTE			*pbHash, 
													   DWORD	*pdwRequestID)
{
	BOOL					fResult=FALSE;
	CEP_REQUEST_ENTRY		*pRequestEntry=NULL;
	DWORD					dwIndex=0;

	*pdwRequestID=0;
	
	//delete all stale requests
	CEPRequestRefresh();

	if(NULL == (pRequestEntry=CEPSearchRequest(pbHash, &dwIndex)))
		goto InvalidArgErr;

	*pdwRequestID=pRequestEntry->dwRequestID;


	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	CEPRequestAddHashAndRequestID
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPRequestAddHashAndRequestID(BYTE		*pbHash, 
												DWORD	dwRequestID)
{
	BOOL							fResult=FALSE;
	SYSTEMTIME						SystemTime;	
	DWORD							dwHashIndex=0;


	CEP_REQUEST_ENTRY				*pRequestEntry=NULL;
	CEP_REQUEST_VALIDITY_ENTRY		*pValidityEntry=NULL;

	
	//delete all stale requests
	CEPRequestRefresh();

	if(!CEPHashRequest(pbHash, &dwHashIndex))
		goto InvalidArgErr;

	pRequestEntry=(CEP_REQUEST_ENTRY *)malloc(sizeof(CEP_REQUEST_ENTRY));

	if(!pRequestEntry)
		goto MemoryErr;

	memset(pRequestEntry, 0, sizeof(CEP_REQUEST_ENTRY));
	
	pValidityEntry=(CEP_REQUEST_VALIDITY_ENTRY *)malloc(sizeof(CEP_REQUEST_VALIDITY_ENTRY));

	if(!pValidityEntry)
		goto MemoryErr;

	memset(pValidityEntry, 0, sizeof(CEP_REQUEST_VALIDITY_ENTRY));

	memcpy(pRequestEntry->pbHash, pbHash, CEP_MD5_HASH_SIZE);

	pRequestEntry->dwRequestID=dwRequestID;
	pRequestEntry->pValidityEntry=pValidityEntry;
	pRequestEntry->pNext=NULL;
	pRequestEntry->pPrevious=NULL;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pValidityEntry->TimeStamp)))
		goto TraceErr;

	pValidityEntry->pRequestEntry=pRequestEntry;
	pValidityEntry->pNext=NULL;
	pValidityEntry->pPrevious=NULL;


	CEPInsertValidityEntry(pValidityEntry);

	CEPInsertRequestEntry(pRequestEntry, dwHashIndex);

	fResult=TRUE;
 
CommonReturn:

	return fResult;

ErrorReturn:

	if(pRequestEntry)
		CEPRequestFreeRequestEntry(pRequestEntry);

	if(pValidityEntry)
		CEPRequestFreeValidityEntry(pValidityEntry, FALSE);

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\cephash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cephash.cpp
//
//  Contents:   Cisco enrollment protocal implementation 
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

CEP_HASH_TABLE_INFO			g_CEPHashTable;

//***************************************************************************
//
//	The following are APIs called internally.
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	CEPHashFreeHashEntry
//
//--------------------------------------------------------------------------
void	CEPHashFreeHashEntry(CEP_HASH_ENTRY *pHashEntry)
{
	if(pHashEntry)
	{
		if(pHashEntry->pszTransactionID)
			free(pHashEntry->pszTransactionID);

		free(pHashEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPHashFreeTimeEntry
//
//--------------------------------------------------------------------------
void CEPHashFreeTimeEntry(CEP_TIME_ENTRY *pTimeEntry, BOOL fFreeHashEntry)
{
	if(pTimeEntry)
	{
		if(fFreeHashEntry)
			CEPHashFreeHashEntry(pTimeEntry->pHashEntry);

		free(pTimeEntry);
	}
}



//--------------------------------------------------------------------------
//
//	CEPHashByte
//
//  For any cases that we can not convert the psz, we use index 0.
//--------------------------------------------------------------------------
BOOL CEPHashByte(LPSTR psz, DWORD	*pdw)
{
	CHAR	sz[3];

	*pdw=0;

	if(!psz)
		return FALSE;

	if(2 <= strlen(psz))
	{

		memcpy(sz, psz, 2 * sizeof(CHAR));
		sz[3]='\0';

		*pdw=strtoul(sz, NULL, 16);

		if(ULONG_MAX == *pdw)
			*pdw=0;
	}

	if(*pdw >= CEP_HASH_TABLE_SIZE)
		*pdw=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPSearchTransactionID
//  
//--------------------------------------------------------------------------
CEP_HASH_ENTRY  *CEPSearchTransactionID(CERT_BLOB	*pTransactionID, DWORD *pdwIndex)
{
	CEP_HASH_ENTRY		*pHashEntry=NULL;
	DWORD				dwHashIndex=0;

	if(pdwIndex)
		*pdwIndex=0;

	if(NULL==pTransactionID->pbData)
		return NULL;

	//hash based on the 1st and 2nd character
	if(!CEPHashByte((LPSTR)(pTransactionID->pbData), &dwHashIndex))
		return NULL;

	for(pHashEntry=g_CEPHashTable.rgHashEntry[dwHashIndex]; NULL != pHashEntry; pHashEntry=pHashEntry->pNext)
	{
		if(0==strcmp((LPSTR)(pTransactionID->pbData), pHashEntry->pszTransactionID))
		{
			break;
		}
	}

	if(pHashEntry)
	{
		if(pdwIndex)
			*pdwIndex=dwHashIndex; 
	}

	return pHashEntry;
}

//--------------------------------------------------------------------------
//
//	CEPInsertTimeEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertTimeEntry(CEP_TIME_ENTRY *pTimeEntry)
{
	BOOL	fResult=FALSE;

	if(g_CEPHashTable.pTimeNew)
	{
		g_CEPHashTable.pTimeNew->pNext=pTimeEntry;
		pTimeEntry->pPrevious=g_CEPHashTable.pTimeNew;
		g_CEPHashTable.pTimeNew=pTimeEntry;
	}
	else
	{
		//no item in the list yet
		g_CEPHashTable.pTimeOld=pTimeEntry;
		g_CEPHashTable.pTimeNew=pTimeEntry;
	}

	fResult=TRUE;

	return fResult;
}


//--------------------------------------------------------------------------
//
//	CEPInsertHashEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertHashEntry(CEP_HASH_ENTRY *pHashEntry, DWORD dwHashIndex)
{
	BOOL	fResult=FALSE;

	if(g_CEPHashTable.rgHashEntry[dwHashIndex])
	{
	   g_CEPHashTable.rgHashEntry[dwHashIndex]->pPrevious=pHashEntry;
	   pHashEntry->pNext=g_CEPHashTable.rgHashEntry[dwHashIndex];
	   g_CEPHashTable.rgHashEntry[dwHashIndex]=pHashEntry;
	}
	else
	{
		//1st item
		g_CEPHashTable.rgHashEntry[dwHashIndex]=pHashEntry;
	}


	fResult=TRUE;

	return fResult;
}

//--------------------------------------------------------------------------
//
//	CEPHashRemoveTimeEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPHashRemoveTimeEntry(CEP_TIME_ENTRY	*pTimeEntry)
{
	BOOL	fResult=FALSE;

	if(!pTimeEntry)
		goto InvalidArgErr;

	if(pTimeEntry->pPrevious)
		pTimeEntry->pPrevious->pNext=pTimeEntry->pNext;
	else
	{
		//1st item
		g_CEPHashTable.pTimeOld=pTimeEntry->pNext;
	}

	if(pTimeEntry->pNext)
		pTimeEntry->pNext->pPrevious=pTimeEntry->pPrevious;
	else
	{
		//last itme
		g_CEPHashTable.pTimeNew=pTimeEntry->pPrevious;

	}

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPHashRemoveHashEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPHashRemoveHashEntry(CEP_HASH_ENTRY	*pHashEntry, DWORD dwIndex)
{
	BOOL	fResult=FALSE;

	if(!pHashEntry)
		goto InvalidArgErr;


	if(pHashEntry->pPrevious)
		pHashEntry->pPrevious->pNext=pHashEntry->pNext;
	else
		g_CEPHashTable.rgHashEntry[dwIndex]=pHashEntry->pNext;

	if(pHashEntry->pNext)
		pHashEntry->pNext->pPrevious=pHashEntry->pPrevious;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	CEPHashCheckCurrentTime
//
//	If we are still waiting for the pending results, use the default
//	waiting time, otherwise, use the cach time 
//--------------------------------------------------------------------------
BOOL CEPHashCheckCurrentTime(FILETIME *pTimeStamp, BOOL fFinished, DWORD dwRefreshDays)
{
	DWORD	dwDays=0;
	DWORD	dwMinutes=0;

	if(fFinished)
	{
		dwMinutes=g_dwRequestDuration;
	}
	else
	{
		dwDays=dwRefreshDays;
	}


	return CEPHashIsCurrentTimeEntry(pTimeStamp, dwDays, dwMinutes);

}

//--------------------------------------------------------------------------
//
//	CEPHashIsCurrentTimeEntry
//
//	If anything went wrong, we think the time entry is not current.
//--------------------------------------------------------------------------
BOOL CEPHashIsCurrentTimeEntry(FILETIME *pTimeStamp, DWORD dwRefreshDays, DWORD dwMinutes)
{
	BOOL				fCurrent=FALSE;
	SYSTEMTIME			SystemTime;	
	FILETIME			CurrentTime;
	ULARGE_INTEGER		dwSeconds;
    ULARGE_INTEGER      OldTime;
	FILETIME			UpdatedTimeStamp;

	if(!pTimeStamp)
		goto CLEANUP;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(CurrentTime)))
		goto CLEANUP;

	//add the # of seconds
    //// FILETIME is in units of 100 nanoseconds (10**-7)
	if(dwRefreshDays)
		dwSeconds.QuadPart=dwRefreshDays * 24 * 3600;
	else
		dwSeconds.QuadPart=dwMinutes * 60;

    dwSeconds.QuadPart=dwSeconds.QuadPart * 10000000;

    OldTime.LowPart=pTimeStamp->dwLowDateTime;
    OldTime.HighPart=pTimeStamp->dwHighDateTime;

    OldTime.QuadPart = OldTime.QuadPart + dwSeconds.QuadPart;

	UpdatedTimeStamp.dwLowDateTime=OldTime.LowPart;
	UpdatedTimeStamp.dwHighDateTime=OldTime.HighPart;

	//1 means CurrentTime is greater than the UpdatedTimeStamp
	if( 1 == CompareFileTime(&CurrentTime, &UpdatedTimeStamp))
		goto CLEANUP;

	fCurrent=TRUE;

CLEANUP:

	return fCurrent;
}

//--------------------------------------------------------------------------
//
//	CEPHashRefresh
//
//--------------------------------------------------------------------------
BOOL	CEPHashRefresh(DWORD	dwRefreshDays)
{
	BOOL			fResult=FALSE;	
	DWORD			dwHashIndex=0;
	CEP_TIME_ENTRY	*pTimeEntry=NULL;

	while(g_CEPHashTable.pTimeOld)
	{
		if(!CEPHashCheckCurrentTime(&(g_CEPHashTable.pTimeOld->TimeStamp), g_CEPHashTable.pTimeOld->pHashEntry->fFinished, dwRefreshDays))
		{  
			if(!CEPHashByte(g_CEPHashTable.pTimeOld->pHashEntry->pszTransactionID, &dwHashIndex))
			{
				g_CEPHashTable.pTimeOld->pPrevious=NULL;
				goto InvalidArgErr;
			}

			CEPHashRemoveHashEntry(g_CEPHashTable.pTimeOld->pHashEntry, dwHashIndex);

			CEPHashFreeHashEntry(g_CEPHashTable.pTimeOld->pHashEntry);

			pTimeEntry=g_CEPHashTable.pTimeOld;

			g_CEPHashTable.pTimeOld=g_CEPHashTable.pTimeOld->pNext;

			CEPHashFreeTimeEntry(pTimeEntry, FALSE);
		}
		else
		{	
			//we find a new enough entry
			g_CEPHashTable.pTimeOld->pPrevious=NULL;
			break;
		}
	}


	//we have get rid of all items
	if(NULL == g_CEPHashTable.pTimeOld)
		g_CEPHashTable.pTimeNew=NULL;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//***************************************************************************
//
//	The following are APIs called by the upper (external) layer
//
//
//***************************************************************************

//
// Function called without critical section protection
//
//--------------------------------------------------------------------------
//
//	InitHashTable
//
//--------------------------------------------------------------------------
BOOL InitHashTable()
{
	memset(&g_CEPHashTable, 0, sizeof(CEP_HASH_TABLE_INFO));

	return TRUE;
}



//--------------------------------------------------------------------------
//
//	ReleaseHashTable
//
//--------------------------------------------------------------------------
BOOL ReleaseHashTable()
{

	CEP_TIME_ENTRY	*pTimeEntry=NULL;

	//free the timestamp list and the hash table's doublie linked lists
	if(g_CEPHashTable.pTimeOld)
	{
		do{
			pTimeEntry=g_CEPHashTable.pTimeOld;

			g_CEPHashTable.pTimeOld = g_CEPHashTable.pTimeOld->pNext;
			
			//free both the time entry and the hash entry
			CEPHashFreeTimeEntry(pTimeEntry, TRUE);
		}
		while(g_CEPHashTable.pTimeOld);
	}
			
	memset(&g_CEPHashTable, 0, sizeof(CEP_HASH_TABLE_INFO));
	

	return TRUE;
}


//
// Function called with critical section protection
//
//--------------------------------------------------------------------------
//
//	CEPHashGetRequestID
//  
//  Retriev the MS Cert Server's requestID based on the transaction ID
//--------------------------------------------------------------------------
BOOL CEPHashGetRequestID(	DWORD		dwRefreshDays,
				CERT_BLOB  *pTransactionID, 
						 DWORD		*pdwRequestID)
{
	BOOL			fResult=FALSE;
	CEP_HASH_ENTRY	*pHashEntry=NULL;
	
	*pdwRequestID=0;

	//we refresh the time list so that we only keep most up-to-date entries
	if(0 != dwRefreshDays)
		CEPHashRefresh(dwRefreshDays);


	if(NULL == (pHashEntry=CEPSearchTransactionID(pTransactionID, NULL)))
		goto InvalidArgErr;

	//we do not process the stable items.  They could exit due to the 
	//20 minutes buffer
	if(!CEPHashCheckCurrentTime(&(pHashEntry->pTimeEntry->TimeStamp), 
								pHashEntry->fFinished, 
								dwRefreshDays))
		goto InvalidArgErr;


	*pdwRequestID=pHashEntry->dwRequestID;

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	CEPHashRemoveRequestAndTransaction
//
//  
//--------------------------------------------------------------------------
BOOL CEPHashRemoveRequestAndTransaction(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	BOOL			fResult=FALSE;
	CEP_HASH_ENTRY	*pHashEntry=NULL;
	DWORD			dwIndex=0;
	

	if(NULL == (pHashEntry=CEPSearchTransactionID(pTransactionID, &dwIndex)))
		goto InvalidArgErr;

	CEPHashRemoveTimeEntry(pHashEntry->pTimeEntry);

	CEPHashRemoveHashEntry(pHashEntry, dwIndex);

	CEPHashFreeTimeEntry(pHashEntry->pTimeEntry, FALSE);

	CEPHashFreeHashEntry(pHashEntry);

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}
//--------------------------------------------------------------------------
//
//	CEPHashMarkTransactionFinished
//
//  
//--------------------------------------------------------------------------
BOOL CEPHashMarkTransactionFinished(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	BOOL			fResult=FALSE;
	CEP_HASH_ENTRY	*pHashEntry=NULL;
	DWORD			dwIndex=0; 
	SYSTEMTIME		SystemTime;	
	

	if(NULL == (pHashEntry=CEPSearchTransactionID(pTransactionID, &dwIndex)))
		goto InvalidArgErr;

	pHashEntry->fFinished=TRUE;

	//re-timestamp the entry since it should last for another 20 minutes for
	//retrial cases
	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pHashEntry->pTimeEntry->TimeStamp)))
		goto InvalidArgErr;

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	AddRequestAndTransaction
//
//  Add a requestID and TransactionID pair
//--------------------------------------------------------------------------
BOOL CEPHashAddRequestAndTransaction(DWORD		dwRefreshDays, 
									 DWORD		dwRequestID, 
									 CERT_BLOB	*pTransactionID)
{	 

	BOOL				fResult=FALSE;
	SYSTEMTIME			SystemTime;	
	DWORD				dwHashIndex=0;


	CEP_HASH_ENTRY		*pHashEntry=NULL;
	CEP_TIME_ENTRY		*pTimeEntry=NULL;
		
	//remove the old requestID/transactionID pair
	CEPHashRemoveRequestAndTransaction(dwRequestID, pTransactionID);


	if(!CEPHashByte((LPSTR)(pTransactionID->pbData), &dwHashIndex))
		goto InvalidArgErr;


	pHashEntry=(CEP_HASH_ENTRY *)malloc(sizeof(CEP_HASH_ENTRY));

	if(!pHashEntry)
		goto MemoryErr;

	memset(pHashEntry, 0, sizeof(CEP_HASH_ENTRY));
	
	pTimeEntry=(CEP_TIME_ENTRY *)malloc(sizeof(CEP_TIME_ENTRY));

	if(!pTimeEntry)
		goto MemoryErr;

	memset(pTimeEntry, 0, sizeof(CEP_TIME_ENTRY));

	pHashEntry->pszTransactionID=(LPSTR)malloc(strlen((LPSTR)(pTransactionID->pbData))+1);
	if(!(pHashEntry->pszTransactionID))
		goto MemoryErr;

	strcpy(pHashEntry->pszTransactionID,(LPSTR)(pTransactionID->pbData));
	pHashEntry->dwRequestID=dwRequestID;
	pHashEntry->fFinished=FALSE;
	pHashEntry->pTimeEntry=pTimeEntry;
	pHashEntry->pNext=NULL;
	pHashEntry->pPrevious=NULL;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pTimeEntry->TimeStamp)))
		goto TraceErr;
	pTimeEntry->pHashEntry=pHashEntry;
	pTimeEntry->pNext=NULL;
	pTimeEntry->pPrevious=NULL;


	CEPInsertTimeEntry(pTimeEntry);

	CEPInsertHashEntry(pHashEntry, dwHashIndex);

	//we refresh the time list so that we only keep most up-to-date entries
	if(0 != dwRefreshDays)
		CEPHashRefresh(dwRefreshDays);

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	if(pHashEntry)
		CEPHashFreeHashEntry(pHashEntry);

	if(pTimeEntry)
		CEPHashFreeTimeEntry(pTimeEntry, FALSE);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//***************************************************************************
//
//	obsolete
//
//
//***************************************************************************
/*

//TODO: Send to database later
//DWORD			g_dwRequestID=0;
//CERT_BLOB		g_TransactionID={0, NULL};


//--------------------------------------------------------------------------
//
//	GetRequestID
//
// TODO: we need to call the database layer in this case
//--------------------------------------------------------------------------
BOOL GetRequestID(CERT_BLOB *pTransactionID, 
				  DWORD		*pdwRequestID)
{
	*pdwRequestID=0;

	if(NULL==pTransactionID->pbData)
		return FALSE;

	//make sure we have the correct transaction ID
	if(0!=strcmp((LPSTR)(pTransactionID->pbData), (LPSTR)(g_TransactionID.pbData)))
		return FALSE;

	*pdwRequestID=g_dwRequestID;

	return TRUE;

}

//--------------------------------------------------------------------------
//
//	DeleteRequestAndTransaction
//
// TODO: we need to call the database layer in this case
//--------------------------------------------------------------------------
BOOL DeleteRequestAndTransaction(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	g_dwRequestID=0;

	if(g_TransactionID.pbData)
		free(g_TransactionID.pbData);

	g_TransactionID.pbData=NULL;
	g_TransactionID.cbData=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CopyRequestAndTransaction
//
// TODO: we need to call the database layer in this case
//--------------------------------------------------------------------------
BOOL CopyRequestAndTransaction(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	//delete the old requestID/transactionID pair
	DeleteRequestAndTransaction(dwRequestID, pTransactionID);

	g_dwRequestID=dwRequestID;

	g_TransactionID.pbData=(BYTE *)malloc(strlen((LPSTR)(pTransactionID->pbData))+1);

	if(NULL == g_TransactionID.pbData)
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	g_TransactionID.cbData=strlen((LPSTR)(pTransactionID->pbData));

	memcpy(g_TransactionID.pbData, (LPSTR)(pTransactionID->pbData), g_TransactionID.cbData+1);

	return TRUE;
}	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\ceppswrd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       ceppswrd.cpp
//
//  Contents:   Cisco enrollment protocol implementation.  This module
//				implement the password hash table.
//              
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

DWORD						g_dwPasswordCount=0;
DWORD						g_dwMaxPassword=0;
DWORD						g_dwPasswordValidity=0;
CEP_PASSWORD_TABLE_INFO		g_CEPPasswordTable;

//***************************************************************************
//
//	The following are APIs called internally.
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	CEPPasswordFreePasswordEntry
//
//--------------------------------------------------------------------------
void	CEPPasswordFreePasswordEntry(CEP_PASSWORD_ENTRY *pPasswordEntry)
{
	if(pPasswordEntry)
	{
		if(pPasswordEntry->pwszPassword)
			free(pPasswordEntry->pwszPassword);

		free(pPasswordEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPPasswordFreeValidityEntry
//
//--------------------------------------------------------------------------
void CEPPasswordFreeValidityEntry(CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry, 
								  BOOL							fFreePasswordEntry)
{
	if(pValidityEntry)
	{
		if(fFreePasswordEntry)
			CEPPasswordFreePasswordEntry(pValidityEntry->pPasswordEntry);

		free(pValidityEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPHashPassword
//
//  For any cases that we can not convert the psz, we use index 0.
//--------------------------------------------------------------------------
BOOL CEPHashPassword(LPWSTR pwsz, DWORD	*pdw)
{
	WCHAR	wsz[3];

	*pdw=0;

	if(!pwsz)
		return FALSE;

	if(2 <= wcslen(pwsz))
	{
		memcpy(wsz, pwsz, 2 * sizeof(WCHAR));
		wsz[3]=L'\0';

		*pdw=wcstoul(wsz, NULL, 16);

		if(ULONG_MAX == *pdw)
			*pdw=0;
	}

	if(*pdw >= CEP_HASH_TABLE_SIZE)
		*pdw=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPSearchPassword
//  
//--------------------------------------------------------------------------
CEP_PASSWORD_ENTRY  *CEPSearchPassword(LPWSTR	pwszPassword, DWORD *pdwIndex)
{
	CEP_PASSWORD_ENTRY		*pPasswordEntry=NULL;
	DWORD					dwHashIndex=0;

	if(pdwIndex)
		*pdwIndex=0;

	if(NULL==pwszPassword)
		return NULL;

	//hash based on the 1st and 2nd character
	if(!CEPHashPassword(pwszPassword, &dwHashIndex))
		return NULL;

	for(pPasswordEntry=g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]; NULL != pPasswordEntry; pPasswordEntry=pPasswordEntry->pNext)
	{
		if(0==wcscmp(pwszPassword, pPasswordEntry->pwszPassword))
		{
			break;
		}
	}

	if(pPasswordEntry)
	{
		if(pdwIndex)
			*pdwIndex=dwHashIndex; 
	}

	return pPasswordEntry;
}

//--------------------------------------------------------------------------
//
//	CEPInsertValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertValidityEntry(CEP_PASSWORD_VALIDITY_ENTRY *pValidityEntry)
{
	if(!pValidityEntry)
		return FALSE;

	if(g_CEPPasswordTable.pTimeNew)
	{
		g_CEPPasswordTable.pTimeNew->pNext=pValidityEntry;
		pValidityEntry->pPrevious=g_CEPPasswordTable.pTimeNew;
		g_CEPPasswordTable.pTimeNew=pValidityEntry;
	}
	else
	{
		//no item in the list yet
		g_CEPPasswordTable.pTimeOld=pValidityEntry;
		g_CEPPasswordTable.pTimeNew=pValidityEntry;
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	CEPInsertPasswordEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertPasswordEntry(CEP_PASSWORD_ENTRY *pPasswordEntry, DWORD dwHashIndex)
{

	if(!pPasswordEntry)
		return FALSE;

	if(g_CEPPasswordTable.rgPasswordEntry[dwHashIndex])
	{
	   g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]->pPrevious=pPasswordEntry;
	   pPasswordEntry->pNext=g_CEPPasswordTable.rgPasswordEntry[dwHashIndex];
	   g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]=pPasswordEntry;
	}
	else
	{
		//1st item
		g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]=pPasswordEntry;
	}

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPPasswordRemoveValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPPasswordRemoveValidityEntry(CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry)
{
	BOOL	fResult=FALSE;

	if(!pValidityEntry)
		goto InvalidArgErr;

	if(pValidityEntry->pPrevious)
		pValidityEntry->pPrevious->pNext=pValidityEntry->pNext;
	else
	{
		//1st item
		g_CEPPasswordTable.pTimeOld=pValidityEntry->pNext;
	}

	if(pValidityEntry->pNext)
		pValidityEntry->pNext->pPrevious=pValidityEntry->pPrevious;
	else
	{
		//last itme
		g_CEPPasswordTable.pTimeNew=pValidityEntry->pPrevious;

	}

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPPasswordRemovePasswordEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPPasswordRemovePasswordEntry(CEP_PASSWORD_ENTRY	*pPasswordEntry, DWORD dwIndex)
{
	BOOL	fResult=FALSE;

	if(!pPasswordEntry)
		goto InvalidArgErr;


	if(pPasswordEntry->pPrevious)
		pPasswordEntry->pPrevious->pNext=pPasswordEntry->pNext;
	else
		g_CEPPasswordTable.rgPasswordEntry[dwIndex]=pPasswordEntry->pNext;

	if(pPasswordEntry->pNext)
		pPasswordEntry->pNext->pPrevious=pPasswordEntry->pPrevious;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPPasswordRefresh
//
//--------------------------------------------------------------------------
BOOL	CEPPasswordRefresh()
{
	BOOL						fResult=FALSE;	
	DWORD						dwHashIndex=0;
	CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry=NULL;

	while(g_CEPPasswordTable.pTimeOld)
	{
		if(!CEPHashIsCurrentTimeEntry(&(g_CEPPasswordTable.pTimeOld->TimeStamp), 0, g_dwPasswordValidity))
		{  
			if(!CEPHashPassword(g_CEPPasswordTable.pTimeOld->pPasswordEntry->pwszPassword, &dwHashIndex))
			{
				g_CEPPasswordTable.pTimeOld->pPrevious=NULL;
				goto InvalidArgErr;
			}

			CEPPasswordRemovePasswordEntry(g_CEPPasswordTable.pTimeOld->pPasswordEntry, dwHashIndex);

			CEPPasswordFreePasswordEntry(g_CEPPasswordTable.pTimeOld->pPasswordEntry);

			pValidityEntry=g_CEPPasswordTable.pTimeOld;

			g_CEPPasswordTable.pTimeOld=g_CEPPasswordTable.pTimeOld->pNext;

			CEPPasswordFreeValidityEntry(pValidityEntry, FALSE);
		   
			if(g_dwPasswordCount >= 1)
				g_dwPasswordCount--;
		}
		else
		{	
			//we find a new enough entry
			g_CEPPasswordTable.pTimeOld->pPrevious=NULL;
			break;
		}
	}


	//we have get rid of all items
	if(NULL == g_CEPPasswordTable.pTimeOld)
	{
		g_CEPPasswordTable.pTimeNew=NULL;
		g_dwPasswordCount=0;
	}
	

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//***************************************************************************
//
//	The following are APIs called by the upper (external) layer
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	InitPasswordTable
//
//--------------------------------------------------------------------------
BOOL	WINAPI	InitPasswordTable()
{
	DWORD				cbData=0;
	DWORD				dwData=0;
	DWORD				dwType=0;

    HKEY                hKey=NULL;

	memset(&g_CEPPasswordTable, 0, sizeof(CEP_PASSWORD_TABLE_INFO));

	g_dwPasswordCount=0;
	g_dwMaxPassword=CEP_MAX_PASSWORD;
	g_dwPasswordValidity=CEP_PASSWORD_VALIDITY;

	if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_PASSWORD_MAX_LOCATION,
                    0,
                    KEY_READ,
                    &hKey))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        MSCEP_KEY_PASSWORD_MAX,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				g_dwMaxPassword=dwData;	
			}
		}
	}

 	dwType=0;
	dwData=0;
    if(hKey)
        RegCloseKey(hKey);

	hKey=NULL;

	if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_PASSWORD_VALIDITY_LOCATION,
                    0,
                    KEY_READ,
                    &hKey))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        MSCEP_KEY_PASSWORD_VALIDITY,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				g_dwPasswordValidity=dwData;	
			}
		}
	}

    if(hKey)
        RegCloseKey(hKey);

	return TRUE;

}

//--------------------------------------------------------------------------
//
//	ReleasePasswordTable
//
//--------------------------------------------------------------------------
BOOL WINAPI  ReleasePasswordTable()
{

	CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry=NULL;

	//free the timestamp list and the password table's doublie linked lists
	if(g_CEPPasswordTable.pTimeOld)
	{
		do{
			pValidityEntry=g_CEPPasswordTable.pTimeOld;

			g_CEPPasswordTable.pTimeOld = g_CEPPasswordTable.pTimeOld->pNext;
			
			CEPPasswordFreeValidityEntry(pValidityEntry, TRUE);
		}
		while(g_CEPPasswordTable.pTimeOld);
	}
			
	memset(&g_CEPPasswordTable, 0, sizeof(CEP_PASSWORD_TABLE_INFO));
	

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPAddPasswordToTable
//
//	Need to be protected by the critical section.
//
//	Last error is set to CRYPT_E_NO_MATCH if the max number of password is 
//	reached.
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPAddPasswordToTable(LPWSTR	pwszPassword)
{
	BOOL							fResult=FALSE;
	SYSTEMTIME						SystemTime;	
	DWORD							dwHashIndex=0;


	CEP_PASSWORD_ENTRY				*pPasswordEntry=NULL;
	CEP_PASSWORD_VALIDITY_ENTRY		*pValidityEntry=NULL;

	EnterCriticalSection(&PasswordCriticalSec);

	if(NULL==pwszPassword)
		goto InvalidArgErr;

	//delete all expired passwords
	CEPPasswordRefresh();

	if(g_dwPasswordCount >= g_dwMaxPassword)
		goto NoMatchErr;

	g_dwPasswordCount++;

	if(!CEPHashPassword(pwszPassword, &dwHashIndex))
		goto InvalidArgErr;


	pPasswordEntry=(CEP_PASSWORD_ENTRY *)malloc(sizeof(CEP_PASSWORD_ENTRY));

	if(!pPasswordEntry)
		goto MemoryErr;

	memset(pPasswordEntry, 0, sizeof(CEP_PASSWORD_ENTRY));
	
	pValidityEntry=(CEP_PASSWORD_VALIDITY_ENTRY *)malloc(sizeof(CEP_PASSWORD_VALIDITY_ENTRY));

	if(!pValidityEntry)
		goto MemoryErr;

	memset(pValidityEntry, 0, sizeof(CEP_PASSWORD_VALIDITY_ENTRY));

	pPasswordEntry->pwszPassword=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszPassword)+1));
	if(!(pPasswordEntry->pwszPassword))
		goto MemoryErr;

	wcscpy(pPasswordEntry->pwszPassword,pwszPassword);

	//no usage has been requested
	pPasswordEntry->dwUsageRequested=0;
	pPasswordEntry->pValidityEntry=pValidityEntry;
	pPasswordEntry->pNext=NULL;
	pPasswordEntry->pPrevious=NULL;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pValidityEntry->TimeStamp)))
		goto TraceErr;

	pValidityEntry->pPasswordEntry=pPasswordEntry;
	pValidityEntry->pNext=NULL;
	pValidityEntry->pPrevious=NULL;


	CEPInsertValidityEntry(pValidityEntry);

	CEPInsertPasswordEntry(pPasswordEntry, dwHashIndex);

	fResult=TRUE;
 
CommonReturn:

 	LeaveCriticalSection(&PasswordCriticalSec);

	return fResult;

ErrorReturn:

	if(pPasswordEntry)
		CEPPasswordFreePasswordEntry(pPasswordEntry);

	if(pValidityEntry)
		CEPPasswordFreeValidityEntry(pValidityEntry, FALSE);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(NoMatchErr, CRYPT_E_NO_MATCH);
TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	CEPVerifyPasswordAndDeleteFromTable
//
//	Need to be protected by the critical section.
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPVerifyPasswordAndDeleteFromTable(LPWSTR	pwszPassword, DWORD dwUsage)
{
	BOOL					fResult=FALSE;
	CEP_PASSWORD_ENTRY		*pPasswordEntry=NULL;
	DWORD					dwIndex=0;
	
	EnterCriticalSection(&PasswordCriticalSec);

	//delete all expired passwords
	CEPPasswordRefresh();

	if(NULL == (pPasswordEntry=CEPSearchPassword(pwszPassword, &dwIndex)))
		goto InvalidArgErr;

	//verify the usage.

	//only one signature and one exchange key per password
	if(0 != ((pPasswordEntry->dwUsageRequested) & dwUsage))
		goto InvalidArgErr;

	pPasswordEntry->dwUsageRequested = (pPasswordEntry->dwUsageRequested) | dwUsage;

	//remove the password only if both signature and exchange key are requested
	if(((pPasswordEntry->dwUsageRequested) & CEP_REQUEST_SIGNATURE) &&
	   ((pPasswordEntry->dwUsageRequested) & CEP_REQUEST_EXCHANGE))
	{

		CEPPasswordRemoveValidityEntry(pPasswordEntry->pValidityEntry);

		CEPPasswordRemovePasswordEntry(pPasswordEntry, dwIndex);

		CEPPasswordFreeValidityEntry(pPasswordEntry->pValidityEntry, FALSE);

		CEPPasswordFreePasswordEntry(pPasswordEntry);

		if(g_dwPasswordCount >= 1)
			g_dwPasswordCount--;
	}

	fResult=TRUE;

 
CommonReturn:

 	LeaveCriticalSection(&PasswordCriticalSec);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\mscep.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       mscep.cpp
//
//  Contents:   Cisco enrollment protocal implementation 
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

CRITICAL_SECTION			CriticalSec;
CRITICAL_SECTION			PasswordCriticalSec;

static BOOL					g_fInit=FALSE;	
static BOOL					g_fRelease=FALSE;

HCERTSTORE					g_HCACertStore=NULL;
CEP_RA_INFO					g_RAInfo;
CEP_CA_INFO					g_CAInfo={NULL, NULL, NULL, NULL, NULL, FALSE, NULL};

HCRYPTASN1MODULE			ICM_hAsn1Module=NULL;
HMODULE						g_hMSCEPModule=NULL;


//-----------------------------------------------------------------------------------
//
//	DllMain
//
//------------------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
	BOOL	fResult = TRUE;

    switch(fdwReason) 
	{

		case DLL_PROCESS_ATTACH:

				g_hMSCEPModule=hInstDLL;

				InitializeCriticalSection(&CriticalSec);

				InitializeCriticalSection(&PasswordCriticalSec);

				CEPASN_Module_Startup();

				if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(
						CEPASN_Module, 0, NULL)))
					fResult = FALSE;

			break;

		case DLL_PROCESS_DETACH:

				I_CryptUninstallAsn1Module(ICM_hAsn1Module);

				CEPASN_Module_Cleanup();

				DeleteCriticalSection(&PasswordCriticalSec);

				DeleteCriticalSection(&CriticalSec);

			break;
    }
			  
    return(fResult);
}

//-----------------------------------------------------------------------------------
//
//	DllRegisterServer
//
//------------------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;

    return	hr;
}

//-----------------------------------------------------------------------------------
//
//	DllUnregisterServer
//
//------------------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    HRESULT hr = S_OK;

    return hr;
}
  
//-----------------------------------------------------------------------------------
//
//	DecodeIssuerAndSerialNumber
//	
//	Decoding routine to decode a IssuerAndSerialNumber blob and return the 
//	SerialNumber 
//
//------------------------------------------------------------------------------------
BOOL WINAPI GetSerialNumberFromBlob(BYTE *pbEncoded, 
									DWORD cbEncoded, 
									CRYPT_INTEGER_BLOB *pSerialNumber)
{
	BOOL					fResult = FALSE;
	ASN1error_e				Asn1Err;
    ASN1decoding_t			pDec;

	IssuerAndSerialNumber   *pisn=NULL;              

	if((!pSerialNumber) || (!pbEncoded))
		goto InvalidArgErr;

	pDec = I_CryptGetAsn1Decoder(ICM_hAsn1Module);

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&pisn,
            IssuerAndSerialNumber_PDU,
            pbEncoded,
            cbEncoded)))
        goto DecodeIssuerAndSerialNumberError;

	//we now reverse the byte
	PkiAsn1ReverseBytes(pisn->serialNumber.value,
						pisn->serialNumber.length);

	pSerialNumber->cbData=pisn->serialNumber.length;
	if(!(pSerialNumber->pbData = (BYTE *)malloc(pSerialNumber->cbData)))
		goto MemoryErr;

	memcpy(pSerialNumber->pbData, pisn->serialNumber.value, pSerialNumber->cbData); 

	fResult = TRUE;

CommonReturn:

	if(pisn)
		PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//-----------------------------------------------------------------------------------
//
//	GetExtensionVersion
//	
//	IIS initialization code
//
//------------------------------------------------------------------------------------
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO  *pVer)
{
	BOOL			fResult = FALSE;
	HRESULT			hr = S_OK;
	BOOL			fOleInit=FALSE;

	//copy the version/description
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR,
                                         HSE_VERSION_MAJOR );
    lstrcpyn( pVer->lpszExtensionDesc,
              "This is the implementation of cisco enrollment protocol",
               HSE_MAX_EXT_DLL_NAME_LEN);

	if(g_fInit)
		return TRUE;

	EnterCriticalSection(&CriticalSec);
	
	//retest in the case of lock: the second thread has passed the 1st test 
	//and was waiting for the criticcal section
	if(g_fInit)
	{	
		LeaveCriticalSection(&CriticalSec);
		return TRUE;
	}

	//initialize the state information
	if(FAILED(hr=CoInitialize(NULL)))
		goto OleErr;

	fOleInit=TRUE;

	if(!InitCAInformation(&g_CAInfo))
		goto InitErr;

	if(!GetCACertFromInfo(&g_CAInfo, &g_HCACertStore))
		goto InitErr;

	if(!GetRAInfo(&g_RAInfo))
		goto InitErr;

	//we add the RA and CA cert to the g_hCACertStore
	if(!CertAddCertificateContextToStore(g_HCACertStore,
										g_RAInfo.pRACert,
										CERT_STORE_ADD_NEW,
										NULL))
		goto InitErr;
			
	if(!CertAddCertificateContextToStore(g_HCACertStore,
										g_RAInfo.pRASign,
										CERT_STORE_ADD_NEW,
										NULL))
		goto InitErr;

	if(!InitHashTable())
		goto InitErr;

	if(!InitPasswordTable())
		goto InitErr;

	if(!InitRequestTable())
		goto InitErr;

    fResult=TRUE;

CommonReturn:

	g_fInit=fResult;

	LeaveCriticalSection(&CriticalSec);

	return fResult;

ErrorReturn:

	//clean up the global data.
	if(g_HCACertStore)
	{
		CertCloseStore(g_HCACertStore, 0);
		g_HCACertStore=NULL;
	}

	FreeRAInformation(&g_RAInfo);

	FreeCAInformation(&g_CAInfo);

	if(fOleInit)
		CoUninitialize();

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(InitErr);
SET_ERROR_VAR(OleErr, hr);
}


//-----------------------------------------------------------------------------------
//
//	GetExtensionVersion.
//	
//	IIS load/initialization code.
//
//------------------------------------------------------------------------------------
DWORD WINAPI   HttpExtensionProc(EXTENSION_CONTROL_BLOCK	*pECB)
{
	DWORD	dwHttp = HSE_STATUS_ERROR;
	LPSTR	pszTagValue=NULL;
	LPSTR	pszMsgValue=NULL;
	DWORD	dwOpType = 0;
	DWORD	cbData=0;
    CHAR    szBuff[1024];
    DWORD   cbBuff;
	LPSTR	pszContentType=NULL;
	DWORD	dwException=0;
	BOOL	f401Response=FALSE;

	BYTE	*pbData=NULL;

	//we use the try{}except here to prevent malicous requests
 __try {


	if(NULL==pECB)
		goto InvalidArgErr;

	if(NULL==(pECB->lpszQueryString))
		goto InvalidArgErr;

	//user are asking for the CEP information/password
	if(0 == strlen(pECB->lpszQueryString))
	{
		pszContentType=CONTENT_TYPE_HTML;

		if(g_RAInfo.fPassword)
		{
			if(IsAnonymousAccess(pECB))
				f401Response=TRUE;
			else
			{
				if(g_CAInfo.fEnterpriseCA)
				{
					if(!CheckACLOnCertTemplate(&g_CAInfo))
					{
						//return HTML error messages
						if(!OperationDisplayAccessHTML(&pbData, &cbData))
							goto OperationErr;
					}
				}
			}
		}
	
		if((FALSE==f401Response) && (NULL==pbData))
		{
			if(!OperationGetDisplayInfoForCEP(g_CAInfo.pwszCAHash,
											  g_CAInfo.hProv,
												g_RAInfo.fPassword, 
												&pbData, 
												&cbData))
				goto OperationErr;
		}
	}
	else
	{

		//get the operation
		if(NULL==(pszTagValue=GetTagValue(pECB->lpszQueryString, GET_TAG_OP)))
			goto InvalidArgErr;

		if(strlen(pszTagValue) > strlen(GET_OP_CA))
		{
			if(0==_strnicmp(pszTagValue, GET_OP_CA, strlen(GET_OP_CA)))
			{
				dwOpType = OPERATION_GET_CACERT;
				pszTagValue += strlen(GET_OP_CA);
			}
		}

		if( 0 == dwOpType)
		{
			if(strlen(pszTagValue) > strlen(GET_OP_PKI))
			{
				if(0==_strnicmp(pszTagValue, GET_OP_PKI, strlen(GET_OP_PKI)))
				{
					dwOpType = OPERATION_GET_PKI;
					pszTagValue += strlen(GET_OP_PKI);
				}
			}
		}
		
		if(0 == dwOpType)
			goto InvalidArgErr;

		//get the message value
		if(NULL==(pszMsgValue=GetTagValue(pszTagValue, GET_TAG_MSG)))
			goto InvalidArgErr;

		//get the return blob
		switch(dwOpType)
		{
			case OPERATION_GET_CACERT:
					
					if(!OperationGetCACert(g_HCACertStore,
											pszMsgValue, 
											&pbData, 
											&cbData))
						goto OperationErr;
	   				
					pszContentType = CONTENT_TYPE_CA_RA;

				break;

			case OPERATION_GET_PKI:

					if(!OperationGetPKI(
										&g_RAInfo,
										&g_CAInfo,
										pszMsgValue, 
										&pbData, 
										&cbData))
						goto OperationErr;

					pszContentType = CONTENT_TYPE_PKI;

				break;

			default:
					goto InvalidArgErr;
				break;
		}
	}

	if(f401Response)
	{
		if(!(pECB->ServerSupportFunction(pECB->ConnID,HSE_REQ_SEND_RESPONSE_HEADER,
							  ACCESS_MESSAGE,  
							  NULL, 
							  NULL)))
			goto WriteErr;

		dwHttp = HSE_STATUS_ERROR;
	}
	else
	{

		//write the header and the real data
		pECB->dwHttpStatusCode = 200;

		// write headers
		sprintf(szBuff, "Content-Length: %d\r\nContent-Type: %s\r\n\r\n", cbData, pszContentType);
		cbBuff = strlen(szBuff);

		if(!(pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER, NULL, &cbBuff, (LPDWORD)szBuff)))
			goto WriteErr;

		// write users data
		if(!(pECB->WriteClient(pECB->ConnID, pbData, &cbData, HSE_IO_SYNC)))
			goto WriteErr;

		dwHttp = HSE_STATUS_SUCCESS;

	}

 } __except(EXCEPTION_EXECUTE_HANDLER)
 {
    dwException = GetExceptionCode();
    goto ExceptionErr;
 }

CommonReturn:

	if(pbData)
		free(pbData);

	return dwHttp;

ErrorReturn:

	dwHttp = HSE_STATUS_ERROR;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(OperationErr);
TRACE_ERROR(WriteErr);
SET_ERROR_VAR(ExceptionErr, dwException);
}



//-----------------------------------------------------------------------------------
//
//	TerminateExtension.
//	
//	IIS unload/cleanup code
//
//------------------------------------------------------------------------------------
BOOL  WINAPI   TerminateExtension(DWORD dwFlags)
{
	if(g_fRelease)
		return TRUE;

	EnterCriticalSection(&CriticalSec);
	
	//retest in the case of lock: the second thread has passed the 1st test 
	//and was waiting for the criticcal section
	if(g_fRelease)
	{	
		LeaveCriticalSection(&CriticalSec);
		return TRUE;
	}

	ReleaseRequestTable();

	ReleasePasswordTable();

	ReleaseHashTable();

	if(g_HCACertStore)
	{
		CertCloseStore(g_HCACertStore, 0);
		g_HCACertStore=NULL;
	}

	FreeRAInformation(&g_RAInfo);

	FreeCAInformation(&g_CAInfo);

	//only if fInit is TRUE, that we have an outstanding CoInitialize() call
	if(g_fInit)
		CoUninitialize();

	g_fRelease=TRUE;

	LeaveCriticalSection(&CriticalSec);

	//we always allow unload
	return TRUE;
}

//***********************************************************************************
//
//	Helper functions for the password table
//
//***********************************************************************************
//-----------------------------------------------------------------------------------
//
//	CEPObtainPassword
//
//------------------------------------------------------------------------------------
BOOL WINAPI		CEPObtainPassword(HCRYPTPROV	hProv,
								  LPWSTR		*ppwszPassword)
{
	BYTE		pbData[CEP_PASSWORD_LENGTH];

	memset(pbData, 0, CEP_PASSWORD_LENGTH);

	if(!CryptGenRandom(hProv, CEP_PASSWORD_LENGTH, pbData))
		return FALSE;

	return ConvertByteToWstr(pbData, CEP_PASSWORD_LENGTH, ppwszPassword, FALSE);
}



//***********************************************************************************
//
//	Helper functions for ISAPI dll entry points
//
//***********************************************************************************
//-----------------------------------------------------------------------------------
//
//	IsAnonymousAccess
//
//------------------------------------------------------------------------------------
BOOL WINAPI IsAnonymousAccess(EXTENSION_CONTROL_BLOCK	*pECB)
{
	BOOL	fAccess=TRUE;
	DWORD	dwSize=0;

	BYTE	*pbData=NULL;
	
	pECB->GetServerVariable(pECB->ConnID,     
					"REMOTE_USER", 
					NULL,    
					&dwSize);

	if(0==dwSize)
		goto CLEANUP;

	pbData=(BYTE *)malloc(dwSize);

	if(NULL==pbData)
		goto CLEANUP;

	if(!(pECB->GetServerVariable(pECB->ConnID,     
					"REMOTE_USER", 
					pbData,    
					&dwSize)))
		goto CLEANUP;

	if(0 == strlen((LPSTR)pbData))
		goto CLEANUP;

	fAccess=FALSE;

CLEANUP:

	if(pbData)
		free(pbData);

	return fAccess;
}


//-----------------------------------------------------------------------------------
//
//	CheckACLOnCertTemplate
//
//------------------------------------------------------------------------------------
BOOL WINAPI CheckACLOnCertTemplate(CEP_CA_INFO			*g_CAInfo)
{
	HRESULT		hr=S_OK;
	HANDLE		hThread=NULL;	//no need to close

	HCERTTYPE	hCertType=NULL;
	HANDLE		hToken=NULL;

	//first of all, we need to revert to ourselves since
	//we are under impersonation and delegation is not 
	//supported by default, thus we can not access the DS.
	//we are ganranteed to have a thread token under impersonation
	hThread=GetCurrentThread();
	
	if(NULL == hThread)
		return FALSE;


	if(!OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
		return FALSE;

	RevertToSelf();

	if(S_OK != CAFindCertTypeByName(	wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE, 
										NULL, 
										CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM, 
										&hCertType))
		return FALSE;

	hr = CACertTypeAccessCheck(hCertType, hToken);

	SetThreadToken(&hThread, hToken);

	CloseHandle(hToken); 

	if(hCertType)
		CACloseCertType(hCertType);

	return (S_OK == hr);
}

//-----------------------------------------------------------------------------------
//
//	OperationDisplayAccessHTML
//
//------------------------------------------------------------------------------------
BOOL WINAPI OperationDisplayAccessHTML(BYTE **ppbData, DWORD *pcbData)
{

	return LoadIDToTemplate(IDS_ACCESS_DENIED, 										  
							  ppbData, 
							  pcbData);
}

//-----------------------------------------------------------------------------------
//
//	OperationGetDisplayInfoForCEP
//
//------------------------------------------------------------------------------------
BOOL WINAPI OperationGetDisplayInfoForCEP(LPWSTR		pwszCAHash,
										  HCRYPTPROV	hProv,
										  BOOL			fPassword, 
										  BYTE			**ppbData, 
										  DWORD			*pcbData)
{
	BOOL		fResult=FALSE;
	HRESULT		hr=E_FAIL;
	UINT		idsMsg=IDS_TOO_MANY_PASSWORD;

	LPWSTR		pwszPassword=NULL;
	LPWSTR		pwszText=NULL;

	if(fPassword)
	{
		if(!CEPObtainPassword(hProv, &pwszPassword))
		{
			idsMsg=IDS_FAIL_TO_GET_PASSWORD;
			goto InfoWithLastErrorReturn;
		}

		if(!CEPAddPasswordToTable(pwszPassword))
		{
			if(CRYPT_E_NO_MATCH == GetLastError())
			{
				idsMsg=IDS_TOO_MANY_PASSWORD;
				goto InfoWithIDReturn;
			}
			else
			{
				idsMsg=IDS_FAIL_TO_ADD_PASSWORD;
				goto InfoWithLastErrorReturn;
			}
		}

		if(!FormatMessageUnicode(&pwszText, IDS_CEP_INFO_WITH_PASSWORD, pwszCAHash, 
									pwszPassword, g_dwPasswordValidity))
			goto TraceErr;

	}
	else
	{
		if(!FormatMessageUnicode(&pwszText, IDS_CEP_INFO_NO_PASSWORD, pwszCAHash))
			goto TraceErr;
	}

	fResult=LoadWZToTemplate(pwszText, ppbData, pcbData);

CommonReturn:

	if(pwszText)
		LocalFree((HLOCAL)pwszText);

	if(pwszPassword)
		free(pwszPassword);

	return fResult;

InfoWithIDReturn:

	fResult=LoadIDToTemplate(idsMsg, ppbData, pcbData);

	goto CommonReturn;	

InfoWithLastErrorReturn:

	hr=HRESULT_FROM_WIN32(GetLastError());

	fResult=LoadIDAndHRToTempalte(idsMsg, hr, ppbData, pcbData);

	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}


//-----------------------------------------------------------------------------------
//
//	LoadIDToTemplate
//
//------------------------------------------------------------------------------------
BOOL WINAPI LoadIDToTemplate(UINT				idsMsg, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData)
{
	BOOL	fResult=FALSE;
    WCHAR   wsz[MAX_STRING_SIZE];
	
    if(!LoadStringU(g_hMSCEPModule, idsMsg, wsz, sizeof(wsz)))
		return FALSE;

	return LoadWZToTemplate(wsz, ppbData, pcbData);
} 

//-----------------------------------------------------------------------------------
//
//	LoadIDToTemplate
//
//------------------------------------------------------------------------------------
BOOL WINAPI LoadIDAndHRToTempalte(UINT			idsMsg, 
								  HRESULT		hr, 
								  BYTE			**ppbData, 
								  DWORD			*pcbData)
{
	BOOL	fResult=FALSE; 
	WCHAR	wszUnknownError[50];

	LPWSTR	pwszErrorMsg=NULL;
	LPWSTR	pwszText=NULL;


	if(!FAILED(hr))
		hr=E_FAIL;

    //using W version because this is a NT5 only function call
    if(FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPWSTR) &pwszErrorMsg,
                        0,
                        NULL))
	{

		if(!FormatMessageUnicode(&pwszText, idsMsg, pwszErrorMsg))
			goto TraceErr;
	}
	else
	{
	
		if(!LoadStringU(g_hMSCEPModule, IDS_ERROR_UNKONWN, wszUnknownError, sizeof(wszUnknownError)))
			goto TraceErr;

		if(!FormatMessageUnicode(&pwszText, idsMsg, wszUnknownError))
			goto TraceErr;
	}

	fResult=LoadWZToTemplate(pwszText, ppbData, pcbData);

CommonReturn:

 	if(pwszText)
		LocalFree((HLOCAL)pwszText);

	if(pwszErrorMsg)
		LocalFree((HLOCAL)pwszErrorMsg);

	return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
}


//-----------------------------------------------------------------------------------
//
//	LoadWZToTemplate
//
//------------------------------------------------------------------------------------
BOOL WINAPI LoadWZToTemplate(LPWSTR				pwsz, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData)
{
	BOOL	fResult=FALSE;
	
	LPWSTR	pwszHTML=NULL;

	if(!FormatMessageUnicode(&pwszHTML, IDS_HTML_TEMPLATE, pwsz))
		goto TraceErr;

	fResult=CopyWZToBuffer(pwszHTML, ppbData, pcbData);

CommonReturn:

	if(pwszHTML)
		LocalFree((HLOCAL)pwszHTML);

	return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
} 


//-----------------------------------------------------------------------------------
//
//	CopyWZToBuffer
//
//------------------------------------------------------------------------------------
BOOL WINAPI CopyWZToBuffer(	LPWSTR				pwszData, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData)
{
	BOOL	fResult=FALSE;
	DWORD	dwSize=0;

	*ppbData=NULL;
	*pcbData=0;

	dwSize=sizeof(WCHAR) * (wcslen(pwszData) + 1);

	*ppbData=(BYTE *)malloc(dwSize);

	if(NULL==ppbData)
		goto MemoryErr;

	memcpy(*ppbData, pwszData, dwSize);

	*pcbData=dwSize;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
} 

//------------------------------------------------------------------------
//	   Convert the byte to its Hex presentation.
//
//	   Precondition: byte is less than 15
//
//------------------------------------------------------------------------
ULONG	ByteToHex(BYTE	byte,	LPWSTR	wszZero, LPWSTR wszA)
{
	ULONG	uValue=0;

	if(((ULONG)byte)<=9)
	{
		uValue=((ULONG)byte)+ULONG(*wszZero);	
	}
	else
	{
		uValue=(ULONG)byte-10+ULONG(*wszA);

	}

	return uValue;

}

//--------------------------------------------------------------------------
//
//	  ConvertByteToWstr
//
//		If fSpace is TRUE, we add a space every 2 bytes.
//--------------------------------------------------------------------------
BOOL WINAPI	ConvertByteToWstr(BYTE			*pbData, 
							  DWORD			cbData, 
							  LPWSTR		*ppwsz, 
							  BOOL			fSpace)
{
	BOOL	fResult=FALSE;
	DWORD	dwBufferSize=0;
	DWORD	dwBufferIndex=0;
	DWORD	dwEncodedIndex=0;
	LPWSTR	pwszSpace=L" ";
	LPWSTR	pwszZero=L"0";
	LPWSTR	pwszA=L"A";

	if(!pbData || !ppwsz)
		goto InvalidArgErr;

	//calculate the memory needed, in bytes
	//we need 3 wchars per byte, along with the NULL terminator
	dwBufferSize=sizeof(WCHAR)*(cbData*3+1);

	*ppwsz=(LPWSTR)malloc(dwBufferSize);

	if(NULL==(*ppwsz))
		goto MemoryErr;

	dwBufferIndex=0;

	//format the wchar buffer one byte at a time
	for(dwEncodedIndex=0; dwEncodedIndex<cbData; dwEncodedIndex++)
	{
		//copy the space between every four bytes.  Skip for the 1st byte
		if(fSpace)
		{
			if((0!=dwEncodedIndex) && (0==(dwEncodedIndex % 4 )))
			{
				(*ppwsz)[dwBufferIndex]=pwszSpace[0];
				dwBufferIndex++;
			}
		}


		//format the higher 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 (pbData[dwEncodedIndex]&UPPER_BITS)>>4,
			 pwszZero, pwszA);

		dwBufferIndex++;

		//format the lower 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 pbData[dwEncodedIndex]&LOWER_BITS,
			 pwszZero, pwszA);

		dwBufferIndex++;

	}

	//add the NULL terminator to the string
	(*ppwsz)[dwBufferIndex]=L'\0';

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL WINAPI	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    if(!LoadStringU(g_hMSCEPModule, ids, wszFormat, sizeof(wszFormat)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


//string
#define		IDS_HTML_TEMPLATE						3001
#define		IDS_ACCESS_DENIED						3002
#define		IDS_ERROR_UNKONWN						3003
#define		IDS_TOO_MANY_PASSWORD					3004
#define		IDS_CEP_INFO_WITH_PASSWORD				3005
#define		IDS_CEP_INFO_NO_PASSWORD				3006
#define		IDS_FAIL_TO_GET_PASSWORD				3007
#define		IDS_FAIL_TO_ADD_PASSWORD				3008
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\cepra.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cepca.cpp
//
//  Contents:   Cisco enrollment protocal implementation.
//				This file has the control's (ra) specific code.
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>		


//--------------------------------------------------------------------------
//
//	FreeRAInformation
//
//--------------------------------------------------------------------------
BOOL	FreeRAInformation(CEP_RA_INFO	*pRAInfo)
{
	if(pRAInfo)
	{
		if(pRAInfo->fFree)
		{
			if(pRAInfo->hRAProv)
				CryptReleaseContext(pRAInfo->hRAProv, 0);
		}

		if(pRAInfo->fSignFree)
		{
			if(pRAInfo->hSignProv)
				CryptReleaseContext(pRAInfo->hSignProv, 0);
		}

		if(pRAInfo->pRACert)
			CertFreeCertificateContext(pRAInfo->pRACert);

		if(pRAInfo->pRASign)
			CertFreeCertificateContext(pRAInfo->pRASign);

		memset(pRAInfo, 0, sizeof(CEP_RA_INFO));
	}

	return TRUE;
}

/*
//--------------------------------------------------------------------------
//
//	GetRAInfo
//
//--------------------------------------------------------------------------
BOOL	GetRAInfo(CEP_RA_INFO	*pRAInfo)
{
	BOOL				fResult = FALSE;
	HCERTSTORE			hCEPStore=NULL;
	DWORD				dwSize=0;
	DWORD				dwIndex=0;
	HANDLE				hThread=NULL;	//no need to close
	HANDLE				hToken=NULL;

	HCERTSTORE			hSignStore=NULL;


    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
   
	memset(pRAInfo, 0, sizeof(CEP_RA_INFO));

    // so we can get access to the local machine's private key
	hThread=GetCurrentThread();
	
	if(NULL != hThread)
	{
		if(OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
		{
			if(hToken)
			{
				//no need to check for return here.  If this failed, just go on
				RevertToSelf();
			}
		}
	}


	//sign RA
	if(!(hSignStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
                            L"CEPSIGN")))
		goto TraceErr;


	if(!(pRAInfo->pRASign=CertEnumCertificatesInStore(
                              hSignStore,
                              NULL)))
		goto TraceErr;

	//the RA cert should have private key and enrollment agent usage
	dwSize=0;

	if(!CertGetCertificateContextProperty(
                pRAInfo->pRASign,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &dwSize) || (0==dwSize))
		goto InvalidArgErr;


	if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRASign,
										CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
										NULL,
										&(pRAInfo->hSignProv),
										&(pRAInfo->dwSignKeySpec),
										&(pRAInfo->fSignFree)))
		goto TraceErr;


	//exchange RA	
	
	if(!(hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
                            CEP_STORE_NAME)))
		goto TraceErr;


	if(!(pRAInfo->pRACert=CertEnumCertificatesInStore(
                              hCEPStore,
                              NULL)))
		goto TraceErr;

	//the RA cert should have private key and enrollment agent usage
	dwSize=0;

	if(!CertGetCertificateContextProperty(
                pRAInfo->pRACert,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &dwSize) || (0==dwSize))
		goto InvalidArgErr;


	if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRACert,
										CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
										NULL,
										&(pRAInfo->hRAProv),
										&(pRAInfo->dwKeySpec),
										&(pRAInfo->fFree)))
		goto TraceErr;

    if(!CertGetEnhancedKeyUsage(pRAInfo->pRACert,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  NULL,
                                  &dwSize))
		goto InvalidArgErr;
	

    if(NULL==(pKeyUsage=(CERT_ENHKEY_USAGE *)malloc(dwSize)))
		goto MemoryErr;

    if (!CertGetEnhancedKeyUsage(pRAInfo->pRACert,
                                 CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                 pKeyUsage,
                                 &dwSize))
		goto InvalidArgErr;

	for(dwIndex=0; dwIndex < pKeyUsage->cUsageIdentifier; dwIndex++)
	{
		if(0 == strcmp(pKeyUsage->rgpszUsageIdentifier[dwIndex], szOID_ENROLLMENT_AGENT))
		{
			fResult=TRUE;
			break;
		}

	}

	if(!fResult)
		goto ErrorReturn;	

 
CommonReturn:

	if(hCEPStore)
		CertCloseStore(hCEPStore, 0);

	if(hSignStore)
		CertCloseStore(hSignStore, 0);

	if(pKeyUsage)
		free(pKeyUsage);

	//if hToken is valid, we reverted to ourselves.
	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

	return fResult;

ErrorReturn:

	FreeRAInformation(pRAInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}	 */

//--------------------------------------------------------------------------
//
//	SigningCert
//
//--------------------------------------------------------------------------
BOOL WINAPI SigningCert(PCCERT_CONTEXT pCertContext)
{
	BOOL				fSign=FALSE;
	PCERT_EXTENSION		pExt=NULL;
	DWORD				cbSize=0;

	CRYPT_BIT_BLOB		*pKeyUsage=NULL;

	if(!pCertContext)
		goto CLEANUP;


	if(!(pExt=CertFindExtension(
				szOID_KEY_USAGE,
				pCertContext->pCertInfo->cExtension,
				pCertContext->pCertInfo->rgExtension)))
		goto CLEANUP;

	if(!CryptDecodeObject(ENCODE_TYPE,
						X509_KEY_USAGE,
						pExt->Value.pbData,
						pExt->Value.cbData,
						0,
						NULL,
						&cbSize))
		goto CLEANUP;

	pKeyUsage=(CRYPT_BIT_BLOB *)malloc(cbSize);
	if(NULL==pKeyUsage)
		goto CLEANUP;

	if(!CryptDecodeObject(ENCODE_TYPE,
						X509_KEY_USAGE,
						pExt->Value.pbData,
						pExt->Value.cbData,
						0,
						pKeyUsage,
						&cbSize))
		goto CLEANUP;


	 if(CERT_DIGITAL_SIGNATURE_KEY_USAGE & (pKeyUsage->pbData[0]))
		 fSign=TRUE;

CLEANUP:

	if(pKeyUsage)
		free(pKeyUsage);

	return fSign;
}

//--------------------------------------------------------------------------
//
//	GetConfigInfo
//
//--------------------------------------------------------------------------
BOOL WINAPI GetConfigInfo(DWORD *pdwRefreshDays, BOOL *pfPassword)
{
	DWORD				cbData=0;
	DWORD				dwData=0;
	DWORD				dwType=0;
	BOOL				fResult=FALSE;
	long				dwErr=0;

    HKEY                hKeyRefresh=NULL;
    HKEY                hKeyPassword=NULL;	 

	if(!pdwRefreshDays || !pfPassword)
		goto InvalidArgErr;

	//default the refresh days
	*pdwRefreshDays=CEP_REFRESH_DAY;	
	*pfPassword=FALSE;

    if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_REFRESH_LOCATION,
                    0,
                    KEY_READ,
                    &hKeyRefresh))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKeyRefresh,
                        MSCEP_KEY_REFRESH,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				*pdwRefreshDays=dwData;	
			}
		}
	}

	dwType=0;
	dwData=0;
	cbData=sizeof(dwData);
	
	//we have to have the knowledge of the password policy
	if(ERROR_SUCCESS != (dwErr =  RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_PASSWORD_LOCATION,
                    0,
                    KEY_READ,
                    &hKeyPassword)))
		goto RegErr;

    if(ERROR_SUCCESS != (dwErr = RegQueryValueExU(
                    hKeyPassword,
                    MSCEP_KEY_PASSWORD,
                    NULL,
                    &dwType,
                    (BYTE *)&dwData,
                    &cbData)))
		goto RegErr;

	if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
		goto RegErr;

	if(0 == dwData)
		*pfPassword=FALSE;
	else
		*pfPassword=TRUE;

	fResult=TRUE;

 
CommonReturn:

    if(hKeyRefresh)
        RegCloseKey(hKeyRefresh);

    if(hKeyPassword)
        RegCloseKey(hKeyPassword);

	return fResult;

ErrorReturn:

	if(pdwRefreshDays)
		*pdwRefreshDays=0;

	if(pfPassword)
		*pfPassword=FALSE;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(RegErr, dwErr);
}
//--------------------------------------------------------------------------
//
//	GetRAInfo
//
//	We need to have two RA cert: One for signature cert (also the enrollment
//	agent) and one for the key encipherment.
//--------------------------------------------------------------------------
BOOL	GetRAInfo(CEP_RA_INFO	*pRAInfo)
{
	BOOL				fResult = FALSE; 
	BOOL				fFound = FALSE;
	DWORD				dwSize=0;
	DWORD				dwIndex=0;
	HANDLE				hThread=NULL;	//no need to close
	PCCERT_CONTEXT		pPreCert=NULL;

	HCERTSTORE			hCEPStore=NULL;
    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
	PCCERT_CONTEXT		pCurCert=NULL;
	HANDLE				hToken=NULL;
   
	memset(pRAInfo, 0, sizeof(CEP_RA_INFO)); 

	if(!GetConfigInfo(&(pRAInfo->dwRefreshDays), &(pRAInfo->fPassword)))
		goto TraceErr;

    // so we can get access to the local machine's private key
	hThread=GetCurrentThread();
	
	if(NULL != hThread)
	{
		if(OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
		{
			if(hToken)
			{
				//no need to check for return here.  If this failed, just go on
				RevertToSelf();
			}
		}
	}


	if(!(hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
                            CEP_STORE_NAME)))
		goto TraceErr;


	while(pCurCert=CertEnumCertificatesInStore(hCEPStore,
											pPreCert))
	{

		//has to have a private key
		dwSize=0;

		if(!CertGetCertificateContextProperty(
					pCurCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					NULL,
					&dwSize) || (0==dwSize))
			goto InvalidArgErr;


		//decide based on the key usage
		if(SigningCert(pCurCert))
		{
			//one signing RA Only
			if(pRAInfo->pRASign)
				goto InvalidArgErr;
			
			if(!(pRAInfo->pRASign=CertDuplicateCertificateContext(pCurCert)))
				goto TraceErr;

			if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRASign,
												CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
												NULL,
												&(pRAInfo->hSignProv),
												&(pRAInfo->dwSignKeySpec),
												&(pRAInfo->fSignFree)))
				goto TraceErr;

			//has to have the enrollment agent eku
			dwSize=0;

			if(!CertGetEnhancedKeyUsage(pCurCert,
										  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
										  NULL,
										  &dwSize))
				goto InvalidArgErr;
		

			if(NULL==(pKeyUsage=(CERT_ENHKEY_USAGE *)malloc(dwSize)))
				goto MemoryErr;

			if (!CertGetEnhancedKeyUsage(pCurCert,
										 CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
										 pKeyUsage,
										 &dwSize))
				goto InvalidArgErr;

			fFound=FALSE;

			for(dwIndex=0; dwIndex < pKeyUsage->cUsageIdentifier; dwIndex++)
			{
				if(0 == strcmp(pKeyUsage->rgpszUsageIdentifier[dwIndex], szOID_ENROLLMENT_AGENT))
				{
					fFound=TRUE;
					break;
				}

			}

			if(!fFound)
				goto InvalidArgErr;	
		}
		else
		{
			//one encryption RA only
			if(pRAInfo->pRACert)
				goto InvalidArgErr;

 			if(!(pRAInfo->pRACert=CertDuplicateCertificateContext(pCurCert)))
				goto TraceErr;

			if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRACert,
												CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
												NULL,
												&(pRAInfo->hRAProv),
												&(pRAInfo->dwKeySpec),
												&(pRAInfo->fFree)))
				goto TraceErr;

		}



		if(pKeyUsage)
		{		
			free(pKeyUsage);
			pKeyUsage=NULL;
		}

		pPreCert=pCurCert;
	}
											

	//we have to have both RA certs
	if((NULL == pRAInfo->pRACert) ||
	   (NULL == pRAInfo->pRASign))
	   goto InvalidArgErr;


	fResult=TRUE;

 
CommonReturn:

	if(hCEPStore)
		CertCloseStore(hCEPStore, 0);

	if(pKeyUsage)
		free(pKeyUsage);

	//if hToken is valid, we reverted to ourselves.
	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

	if(pCurCert)
		CertFreeCertificateContext(pCurCert);

	return fResult;

ErrorReturn:

	FreeRAInformation(pRAInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}


//--------------------------------------------------------------------------
//
//	OperationGetPKI
//
//--------------------------------------------------------------------------
BOOL	OperationGetPKI(	CEP_RA_INFO		*pRAInfo,
							CEP_CA_INFO		*pCAInfo,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData)
{
	BOOL				fResult = FALSE;
	CEP_MESSAGE_INFO	MsgInfo;
	DWORD				cbContent=0;
	DWORD				cbEnvelop=1;
	BYTE				bFoo=0;

	BYTE				*pbContent=NULL;
	BYTE				*pbEnvelop=&bFoo;


	memset(&MsgInfo, 0, sizeof(CEP_MESSAGE_INFO));

	if(!GetReturnInfoAndContent(pRAInfo, pCAInfo, szMsg, &pbContent, &cbContent, &MsgInfo))
		goto TraceErr;

	//envelop the data
	if(MESSAGE_STATUS_SUCCESS == MsgInfo.dwStatus)
	{
		if(!EnvelopData(MsgInfo.pSigningCert, pbContent, cbContent,
						&pbEnvelop, &cbEnvelop))
			goto TraceErr;
	}

	//sign the data with authenticated attributes 
	//when the dwStatus is not SUCCESS, the pbEnvelop is NULL and cbEnvelop is 0.

 	if(!SignData(&MsgInfo, pRAInfo, pbEnvelop, cbEnvelop, ppbData, pcbData))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	if(pbContent)
		free(pbContent);

    	if(&bFoo != pbEnvelop)
		free(pbEnvelop);
	
	FreeMessageInfo(&MsgInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	SignData
//
//  the messageType is always response and the senderNonce should be generated
//	in case the pending and failure, pbEnvelop will be NULL.
//
//	In the initial GetContentFromPKCS7, we retrive MessageType, TransactionID,
//	RecipientNonce, signing Cert serial number.
//
//	In the process, we get the dwStatus and dwErrorInfo when applicable.  
////--------------------------------------------------------------------------
BOOL SignData(CEP_MESSAGE_INFO		*pMsgInfo, 
			  CEP_RA_INFO			*pRAInfo, 
			  BYTE					*pbEnvelop, 
			  DWORD					cbEnvelop, 
			  BYTE					**ppbData, 
			  DWORD					*pcbData)
{
	BOOL						fResult = FALSE;
	CMSG_SIGNER_ENCODE_INFO		SignerInfo;
	CMSG_SIGNED_ENCODE_INFO		SignEncodedInfo;
	CERT_BLOB					CertBlob;
	BOOL						fProvFree=FALSE;
    PCCRYPT_OID_INFO            pOIDInfo=NULL;
	ALG_ID						AlgValue=CALG_MD5;
	DWORD						cAttr=0;
	CRYPT_ATTR_BLOB				rgAttrBlob[CEP_RESPONSE_AUTH_ATTR_COUNT];
	DWORD						dwIndex=0;

	HCRYPTMSG					hMsg=NULL;
 	CRYPT_ATTRIBUTE				rgAttr[CEP_RESPONSE_AUTH_ATTR_COUNT];

	if(!pMsgInfo || !pRAInfo || !ppbData || !pcbData)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	pMsgInfo->dwMessageType=MESSAGE_TYPE_CERT_RESPONSE;

	if(!GenerateSenderNonce(&(pMsgInfo->SenderNonce)))
		goto TraceErr;

	memset(&SignerInfo, 0, sizeof(SignerInfo));
	memset(&SignEncodedInfo, 0, sizeof(SignEncodedInfo)); 

	SignEncodedInfo.cbSize=sizeof(SignEncodedInfo);
	SignEncodedInfo.cSigners=1;
	SignEncodedInfo.rgSigners=&SignerInfo,
/*	SignEncodedInfo.cCertEncoded=1;		   
	SignEncodedInfo.rgCertEncoded=&CertBlob; */
	SignEncodedInfo.cCertEncoded=0;
	SignEncodedInfo.rgCertEncoded=NULL; 
	SignEncodedInfo.cCrlEncoded=0;
	SignEncodedInfo.rgCrlEncoded=NULL;

	CertBlob.cbData=pRAInfo->pRASign->cbCertEncoded;
	CertBlob.pbData=pRAInfo->pRASign->pbCertEncoded;

	SignerInfo.cbSize=sizeof(SignerInfo);
	SignerInfo.pCertInfo=pRAInfo->pRASign->pCertInfo;

	//specify AlgID
	if(pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_ALGID_KEY,
                            &AlgValue,
                            CRYPT_HASH_ALG_OID_GROUP_ID))
		SignerInfo.HashAlgorithm.pszObjId=(LPSTR)(pOIDInfo->pszOID);
	else
		SignerInfo.HashAlgorithm.pszObjId=szOID_RSA_MD5;


	//get the private key
	SignerInfo.hCryptProv=pRAInfo->hSignProv;
	SignerInfo.dwKeySpec=pRAInfo->dwSignKeySpec;


	//get the autheticated attributes
	//together we should have 6 attributes: TransactionID, MessageType, PkiStatus,
	//ErrorInfo, senderNonce, and recipientNonce
	memset(rgAttr, 0, CEP_RESPONSE_AUTH_ATTR_COUNT * sizeof(CRYPT_ATTRIBUTE));
	memset(rgAttrBlob, 0, CEP_RESPONSE_AUTH_ATTR_COUNT * sizeof(CRYPT_ATTR_BLOB));


	for(dwIndex=0; dwIndex<CEP_RESPONSE_AUTH_ATTR_COUNT; dwIndex++)
	{
		rgAttr[dwIndex].cValue=1;
		rgAttr[dwIndex].rgValue=&(rgAttrBlob[dwIndex]);
	}

	cAttr=0;	
			
	//TransactionID
	rgAttr[cAttr].pszObjId=szOIDVerisign_TransactionID;

	//transactionID internally are stored as a string
	pMsgInfo->TransactionID.cbData=strlen((LPSTR)(pMsgInfo->TransactionID.pbData));

	if(!CEPAllocAndEncodeName(CERT_RDN_PRINTABLE_STRING,
							pMsgInfo->TransactionID.pbData,
							pMsgInfo->TransactionID.cbData,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;
								
	cAttr++;

	//MessageType
	rgAttr[cAttr].pszObjId=szOIDVerisign_MessageType;

	if(!CEPAllocAndEncodeDword(CERT_RDN_PRINTABLE_STRING,
							pMsgInfo->dwMessageType,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;

	cAttr++;

	//Status
	rgAttr[cAttr].pszObjId=szOIDVerisign_PkiStatus;

	if(!CEPAllocAndEncodeDword(CERT_RDN_PRINTABLE_STRING,
							pMsgInfo->dwStatus,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;

	cAttr++;

	//ErrorInfo	only if the error case
	if(MESSAGE_STATUS_FAILURE == pMsgInfo->dwStatus)
	{
		rgAttr[cAttr].pszObjId=szOIDVerisign_FailInfo;

		if(!CEPAllocAndEncodeDword(CERT_RDN_PRINTABLE_STRING,
								pMsgInfo->dwErrorInfo,
								&(rgAttr[cAttr].rgValue[0].pbData),
								&(rgAttr[cAttr].rgValue[0].cbData)))
			goto TraceErr;

		cAttr++;
	}

	//senderNonce
	rgAttr[cAttr].pszObjId=szOIDVerisign_SenderNonce;

	if(!CEPAllocAndEncodeName(CERT_RDN_OCTET_STRING,
							pMsgInfo->SenderNonce.pbData,
							pMsgInfo->SenderNonce.cbData,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;

	cAttr++;

	//recipientNonce
	rgAttr[cAttr].pszObjId=szOIDVerisign_RecipientNonce;

	if(!CEPAllocAndEncodeName(CERT_RDN_OCTET_STRING,
							pMsgInfo->RecipientNonce.pbData,
							pMsgInfo->RecipientNonce.cbData,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;	

	cAttr++;

	SignerInfo.cAuthAttr=cAttr;
	SignerInfo.rgAuthAttr=rgAttr;

	//message encoding
	if(NULL==(hMsg=CryptMsgOpenToEncode(ENCODE_TYPE,
								0,
								CMSG_SIGNED,
								&SignEncodedInfo,
								NULL,	//we are encoding as CMSG_DATA(7.1)
								NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbEnvelop,
						cbEnvelop,
						TRUE))
		goto TraceErr;


	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbData))
		goto TraceErr;

	*ppbData=(BYTE *)malloc(*pcbData);
	if(NULL==(*ppbData))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbData,
						pcbData))
		goto TraceErr;


	fResult = TRUE;

CommonReturn:
	
	for(dwIndex=0; dwIndex < cAttr; dwIndex ++)
	{
		if(rgAttrBlob[dwIndex].pbData)
			free(rgAttrBlob[dwIndex].pbData);
	}

	if(hMsg)
		CryptMsgClose(hMsg);


	return fResult;

ErrorReturn:

	if(ppbData)
	{
		if(*ppbData)
		{
			free(*ppbData);
			*ppbData=NULL;
		}
	}

	if(pcbData)
		*pcbData=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	CEPAllocAndEncodeDword
//
//	PreCondition: ppbEncoded and pcbEncoded should not be NULL.
//				The dwData is no more than 10
//--------------------------------------------------------------------------
BOOL	CEPAllocAndEncodeDword(DWORD	dwValueType,
							DWORD	dwData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded)
{
	BOOL				fResult = FALSE;
	CHAR				szString[10];
	BYTE				*pbData=NULL;
	DWORD				cbData=0;

	_ltoa(dwData, szString, 10);

	pbData=(BYTE *)szString;
	cbData=strlen(szString);

	return CEPAllocAndEncodeName(dwValueType, pbData, cbData, ppbEncoded, pcbEncoded);
}


//--------------------------------------------------------------------------
//
//	CEPAllocAndEncodeName
//
//	PreCondition: ppbEncoded and pcbEncoded should not be NULL.
//--------------------------------------------------------------------------
BOOL	CEPAllocAndEncodeName(DWORD	dwValueType,
							BYTE	*pbData,
							DWORD	cbData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded)
{
	CERT_NAME_VALUE		CertName;

	*ppbEncoded=NULL;
	*pcbEncoded=0;

	CertName.dwValueType=dwValueType;
	CertName.Value.pbData=pbData;
	CertName.Value.cbData=cbData;

	return CEPAllocAndEncode(X509_ANY_STRING,
							&CertName,
							ppbEncoded,
							pcbEncoded);

}


//--------------------------------------------------------------------------
//
//	GenerateSenderNonce
//
//	We use GUID to generate a random 16 byte number
//
//--------------------------------------------------------------------------
BOOL GenerateSenderNonce(CRYPT_INTEGER_BLOB *pBlob)
{
	BOOL			fResult = FALSE;
	GUID			guid;
	BYTE			*pData=NULL;

	UuidCreate(&guid);

	pBlob->cbData=sizeof(guid.Data1) + sizeof(guid.Data2) +
					sizeof(guid.Data3) + sizeof(guid.Data4);

	pBlob->pbData=(BYTE *)malloc(pBlob->cbData);
	if(NULL==(pBlob->pbData))
		goto MemoryErr;

	pData=pBlob->pbData;

	memcpy(pData, &(guid.Data1), sizeof(guid.Data1));
	pData += sizeof(guid.Data1);

	memcpy(pData, &(guid.Data2), sizeof(guid.Data2));
	pData += sizeof(guid.Data2);

	memcpy(pData, &(guid.Data3), sizeof(guid.Data3));
	pData += sizeof(guid.Data3);

	memcpy(pData, &(guid.Data4), sizeof(guid.Data4));

	fResult = TRUE;

CommonReturn:	 

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	EnvelopData
//
//	In the initial GetContentFromPKCS7, we retrieve pSigningCert for 
//	GetCertInitial, CertReq, and GetCert request.
//
//	In the process,we retrieve pSigningCert for GetCRL request.
//--------------------------------------------------------------------------
BOOL EnvelopData(PCCERT_CONTEXT	pSigningCert, 
				 BYTE			*pbContent, 
				 DWORD			cbContent,
				 BYTE			**ppbEnvelop, 
				 DWORD			*pcbEnvelop)
{
	BOOL						fResult = FALSE;
	CMSG_ENVELOPED_ENCODE_INFO	EnvInfo;

	HCRYPTMSG					hMsg=NULL;

	if(!pSigningCert || !pbContent || !ppbEnvelop || !pcbEnvelop)
		goto InvalidArgErr;

	*ppbEnvelop=NULL;
	*pcbEnvelop=0;

	memset(&EnvInfo, 0, sizeof(CMSG_ENVELOPED_ENCODE_INFO));

	EnvInfo.cbSize=sizeof(CMSG_ENVELOPED_ENCODE_INFO);
    EnvInfo.hCryptProv=NULL;
    EnvInfo.ContentEncryptionAlgorithm.pszObjId=szOID_OIWSEC_desCBC;
    EnvInfo.pvEncryptionAuxInfo=NULL;
    EnvInfo.cRecipients=1;
    EnvInfo.rgpRecipients=(PCERT_INFO *)(&(pSigningCert->pCertInfo));


	if(NULL==(hMsg=CryptMsgOpenToEncode(ENCODE_TYPE,
								0,
								CMSG_ENVELOPED,
								&EnvInfo,
								NULL,	//we are encoding as CMSG_DATA(7.1)
								NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbContent,
						cbContent,
						TRUE))
		goto TraceErr;


	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbEnvelop))
		goto TraceErr;

	*ppbEnvelop=(BYTE *)malloc(*pcbEnvelop);
	if(NULL==(*ppbEnvelop))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbEnvelop,
						pcbEnvelop))
		goto TraceErr;
	
	fResult = TRUE;

CommonReturn:

	if(hMsg)
		CryptMsgClose(hMsg);

	return fResult;

ErrorReturn:

	if(ppbEnvelop)
	{
		if(*ppbEnvelop)
		{
			free(*ppbEnvelop);
			*ppbEnvelop=NULL;
		}
	}

	if(pcbEnvelop)
		*pcbEnvelop=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	DecodeCertW
//
//--------------------------------------------------------------------------
HRESULT
DecodeCertW(
    IN void const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BOOL fRet;

    //init
    *ppbOut = NULL;
    *pcbOut = 0;

    while (TRUE)
    {
        fRet = CryptStringToBinaryW((LPCWSTR)pchIn, cchIn, Flags, pbOut, &cbOut, NULL, NULL);

        if (!fRet)
        {
            hr = GetLastError();
            goto error;
        }
        if (NULL != pbOut)
        {
            break; //done
        }
        pbOut = (BYTE*)LocalAlloc(LMEM_FIXED, cbOut);
        if (NULL == pbOut)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }
    *ppbOut = pbOut;
    pbOut = NULL;
    *pcbOut = cbOut;

    hr = S_OK;
error:
    if (NULL != pbOut)
    {
        LocalFree(pbOut);
    }
    return hr;
}


//--------------------------------------------------------------------------
//
//	GetReturnInfoAndContent
//
//--------------------------------------------------------------------------
BOOL	GetReturnInfoAndContent(CEP_RA_INFO		*pRAInfo,	
							CEP_CA_INFO			*pCAInfo,
							LPSTR				szMsg, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{

	BOOL				fResult = FALSE;
	DWORD				cbBase64Decoded=0;
	DWORD				cbReqEnv=0;
	DWORD				cbReqDecrypt=0;
	DWORD				cbSize=0;
	HRESULT				hr=E_FAIL;
	
	BYTE				*pbBase64Decoded=NULL;
	BYTE				*pbReqEnv=NULL;
	BYTE				*pbReqDecrypt=NULL;
	WCHAR				wszBuffer[INTERNET_MAX_PATH_LENGTH * 2 +1];
	LPWSTR				pwszMsg=NULL;
	LPWSTR				pwszBuffer=NULL;

	//convert sz to wsz
	pwszMsg=MkWStr(szMsg);

	if(NULL==pwszMsg)
		goto MemoryErr;

	//we need to get rid of the escape characters
	if(S_OK != (hr=CoInternetParseUrl(pwszMsg,
				PARSE_UNESCAPE,
				0,
				wszBuffer,
				INTERNET_MAX_PATH_LENGTH*2,
				&cbSize,
				0)))
	{
		//S_FALSE means that the buffer is too small
		if(S_FALSE != hr)
			goto TraceErr;

		if(0==cbSize)
			goto TraceErr;

		//allocate the buffer
		pwszBuffer=(LPWSTR)malloc(cbSize * sizeof(WCHAR));
		if(NULL==pwszBuffer)
			goto MemoryErr;

		*pwszBuffer=L'\0';

		if(S_OK != CoInternetParseUrl(pwszMsg,
					PARSE_UNESCAPE,
					0,
					pwszBuffer,
					cbSize,
					&cbSize,
					0))

		goto TraceErr;
	}
	
    if(S_OK != DecodeCertW(
        pwszBuffer ? pwszBuffer : wszBuffer,
        pwszBuffer ? wcslen(pwszBuffer) : wcslen(wszBuffer),
        CRYPT_STRING_BASE64_ANY, //DECF_BASE64_ANY,
        &pbBase64Decoded,
        &cbBase64Decoded))
		goto FailureStatusReturn;

	//get the message type, transaction ID, recepientNonce, serial number in the 
	//signer_info of the most outer PKCS#7 and inner content
	if(!GetContentFromPKCS7(pbBase64Decoded,
							cbBase64Decoded,
							&pbReqEnv,
							&cbReqEnv,
							pMsgInfo))
		goto FailureStatusReturn;

	//decrypt the inner content
	if(!DecryptMsg(pRAInfo, pbReqEnv, cbReqEnv, &pbReqDecrypt, &cbReqDecrypt))
		goto FailureStatusReturn;

	//get the return inner content based on the message type
	switch(pMsgInfo->dwMessageType)
	{

		case	MESSAGE_TYPE_CERT_REQUEST:
				//we use the signing RA cert as the enrollment agent
				if(!ProcessCertRequest( pRAInfo->dwRefreshDays,
										pRAInfo->fPassword, 
									    pRAInfo->pRACert,
										pRAInfo->pRASign, 
										pCAInfo, 
										pbReqDecrypt,
										cbReqDecrypt, 
										ppbData, 
										pcbData,
										pMsgInfo))
					goto TraceErr;

			break;
		case	MESSAGE_TYPE_GET_CERT_INITIAL:
				if(!ProcessCertInitial(pRAInfo->dwRefreshDays, pCAInfo, pbReqDecrypt,
										cbReqDecrypt, ppbData, pcbData,
										pMsgInfo))
					goto TraceErr;

			break;
		case	MESSAGE_TYPE_GET_CERT:
				if(!ProcessGetCert(pCAInfo, pbReqDecrypt,
									cbReqDecrypt, ppbData, pcbData,
									pMsgInfo))
					goto TraceErr;
			
			break;
		case	MESSAGE_TYPE_GET_CRL:
				if(!ProcessGetCRL(pCAInfo, pbReqDecrypt,
									cbReqDecrypt, ppbData, pcbData,
									pMsgInfo))
					goto TraceErr;

			break;
		default:
				goto InvalidArgErr;
			break;
	}



	fResult = TRUE;

CommonReturn:

	if(pwszBuffer)
		free(pwszBuffer);

	if(pwszMsg)
		FreeWStr(pwszMsg);

	//memory from certcli.dll.  Has to be freed by LocalFree()
	if(pbBase64Decoded)
		LocalFree(pbBase64Decoded);

	if(pbReqEnv)
		free(pbReqEnv);

	if(pbReqDecrypt)
		free(pbReqDecrypt);

	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=MESSAGE_FAILURE_BAD_MESSAGE_CHECK;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn; 


ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	RetrieveContextFromSerialNumber
//
//
//--------------------------------------------------------------------------
BOOL WINAPI RetrieveContextFromSerialNumber(CEP_CA_INFO	*pCAInfo, 
										CERT_BLOB		*pSerialNumber, 
										PCCERT_CONTEXT	*ppCertContext)
{
	BOOL		fResult = FALSE;
	DWORD		cb=0;
	long		dwDisposition=0;
	HRESULT		hr=E_FAIL;
	DWORD		cbCert=0;
	BYTE		*pbCert=NULL;

	LPWSTR		pwsz=NULL;
	BSTR		bstrCert=NULL;
	LPWSTR		pwszNewConfig=NULL;
	BSTR		bstrNewConfig=NULL;

	if(S_OK != (hr=MultiByteIntegerToWszBuf(
			FALSE,
			pSerialNumber->cbData,
			pSerialNumber->pbData,
			&cb,
			NULL)))
		goto SetHrErr;

	pwsz=(LPWSTR)malloc(cb);
	if(NULL==pwsz)
		goto MemoryErr;

	if(S_OK != (hr=MultiByteIntegerToWszBuf(
			FALSE,
			pSerialNumber->cbData,
			pSerialNumber->pbData,
			&cb,
			pwsz)))
		goto SetHrErr;

	//contatenate the serialNumber with the config string
	pwszNewConfig=(LPWSTR)malloc(sizeof(WCHAR) * 
				(wcslen(pCAInfo->bstrCAConfig)+wcslen(pwsz)+wcslen(L"\\")+1));
	if(NULL==pwszNewConfig)
		goto MemoryErr;

	//the config string to retrieve the cert based on the 
	//serialNumber is configString\SerialNumber
	//
	wcscpy(pwszNewConfig, pCAInfo->bstrCAConfig);
	wcscat(pwszNewConfig, L"\\");
	wcscat(pwszNewConfig, pwsz);

	bstrNewConfig=SysAllocString(pwszNewConfig);

	if(NULL==bstrNewConfig)
		goto MemoryErr;
	
	if(S_OK != (hr=pCAInfo->pICertRequest->RetrievePending(0,
													bstrNewConfig,
													&dwDisposition)))
		goto SetHrErr;

	if(S_OK != (hr= pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
									&bstrCert)))
		goto SetHrErr;

	cbCert = (DWORD)SysStringByteLen(bstrCert);
	pbCert = (BYTE *)bstrCert;

	if(!(*ppCertContext=CertCreateCertificateContext(ENCODE_TYPE,
												pbCert,
												cbCert)))
		goto TraceErr;


	fResult = TRUE;

CommonReturn:

	if(pwsz)
		free(pwsz);

	if(bstrCert)
		SysFreeString(bstrCert);

	if(pwszNewConfig)
		free(pwszNewConfig);

	if(bstrNewConfig)
		SysFreeString(bstrNewConfig);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(SetHrErr, hr);
TRACE_ERROR(TraceErr);
}
//--------------------------------------------------------------------------
//
//	ProcessGetCRL
//
//
//--------------------------------------------------------------------------
BOOL WINAPI ProcessGetCRL(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL					fResult = FALSE;
	DWORD					dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
	DWORD					cbUrlArray=0;
	DWORD					dwIndex=0;

	PCCERT_CONTEXT			pCertContext=NULL;
	PCCRL_CONTEXT			pCRLContext=NULL;
	PCRYPT_URL_ARRAY		pUrlArray = NULL;


	if(!pCAInfo || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	//retrieve the cert context from the serialNumber
	//protected by the critical Section since it uses ICertRequest interface
	EnterCriticalSection(&CriticalSec);

	if(!RetrieveContextFromSerialNumber(pCAInfo, &(pMsgInfo->SerialNumber), &pCertContext))
	{
		LeaveCriticalSection(&CriticalSec);	  

		goto FailureStatusReturn;
	}

	LeaveCriticalSection(&CriticalSec);	  

	if(!CryptGetObjectUrl(
			URL_OID_CERTIFICATE_CRL_DIST_POINT,
			(LPVOID)pCertContext,
			CRYPT_GET_URL_FROM_EXTENSION,
			NULL,
			&cbUrlArray,
			NULL,
			NULL,
			NULL))
		goto FailureStatusReturn;

	pUrlArray=(PCRYPT_URL_ARRAY)malloc(cbUrlArray);
	if(NULL == pUrlArray)
		goto FailureStatusReturn;

	if(!CryptGetObjectUrl(
			URL_OID_CERTIFICATE_CRL_DIST_POINT,
			(LPVOID)pCertContext,
			CRYPT_GET_URL_FROM_EXTENSION,
			pUrlArray,
			&cbUrlArray,
			NULL,
			NULL,
			NULL))
		goto FailureStatusReturn;
	
	for(dwIndex=0; dwIndex < pUrlArray->cUrl; dwIndex++)
	{

		if(CryptRetrieveObjectByUrlW (
			pUrlArray->rgwszUrl[dwIndex],
			CONTEXT_OID_CRL,
			CRYPT_WIRE_ONLY_RETRIEVAL,	//we should try to hit the wire
			0,
			(LPVOID *)&pCRLContext,
			NULL,
			NULL,
			NULL,
			NULL))
				break;
	}

	if(NULL==pCRLContext)
		goto FailureStatusReturn;


   	//package the CRL in an empty PKCS7
	if(!PackageBlobToPKCS7(CEP_CONTEXT_CRL, pCRLContext->pbCrlEncoded, 
							pCRLContext->cbCrlEncoded, ppbData, pcbData))
		goto FailureStatusReturn;

	//this is the signing cert to which our response should be encrypted
	if(NULL==(pMsgInfo->pSigningCert=CertDuplicateCertificateContext(pCertContext)))
		goto FailureStatusReturn;

	fResult = TRUE;

CommonReturn:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pUrlArray)
		free(pUrlArray);

	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	if(ppbData)
	{
		if(*ppbData)
			free(*ppbData);	

		*ppbData=NULL;
	}
	
	if(pcbData)
		*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	ProcessGetCert
//
//
//--------------------------------------------------------------------------
BOOL WINAPI ProcessGetCert(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL					fResult = FALSE;
	DWORD					dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;


	CRYPT_INTEGER_BLOB		SerialNumber;
	PCCERT_CONTEXT			pCertContext=NULL;

	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	memset(&SerialNumber, 0, sizeof(CRYPT_INTEGER_BLOB));

	//get the serialnumber from the request
	if(!GetSerialNumberFromBlob(pbRequest, 
								cbRequest, 
								&SerialNumber))
		goto FailureStatusReturn;

	//retrieve the cert context from the serialNumber
	//protected by the critical Section since it uses ICertRequest interface
	EnterCriticalSection(&CriticalSec);

	if(!RetrieveContextFromSerialNumber(pCAInfo, (CERT_BLOB*)&SerialNumber, &pCertContext))
	{
		LeaveCriticalSection(&CriticalSec);	  

		goto FailureStatusReturn;
	}

	LeaveCriticalSection(&CriticalSec);	  

   	//package it in an empty PKCS7
	if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pCertContext->pbCertEncoded, 
							pCertContext->cbCertEncoded, ppbData, pcbData))
		goto FailureStatusReturn;

	//this is the signing cert to which our response should be encrypted
/*	if(NULL==(pMsgInfo->pSigningCert=CertDuplicateCertificateContext(pCertContext)))
		goto FailureStatusReturn;  */

	fResult = TRUE;

CommonReturn:

	if(SerialNumber.pbData)
		free(SerialNumber.pbData);

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	if(ppbData)
	{
		if(*ppbData)
			free(*ppbData);	

		*ppbData=NULL;
	}
	
	if(pcbData)
		*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	ProcessCertInitial
//
//
//--------------------------------------------------------------------------
BOOL	ProcessCertInitial(	DWORD		dwRefreshDays,
					CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL	fResult = FALSE;
	DWORD	dwRequestID=0;
	DWORD	cbCert=0;
	BYTE	*pbCert=NULL;	
	DWORD	dwErrorInfo=MESSAGE_FAILURE_BAD_CERT_ID;
	long	dwDisposition=0;

	BSTR	bstrCert=NULL;

	EnterCriticalSection(&CriticalSec);	  


	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	//map the trasactionID to the request ID
	if(!CEPHashGetRequestID(dwRefreshDays, &(pMsgInfo->TransactionID), &dwRequestID))
		goto FailureStatusReturn;


	if(S_OK != pCAInfo->pICertRequest->RetrievePending(dwRequestID,
													pCAInfo->bstrCAConfig,
													&dwDisposition))
		goto FailureStatusReturn;

	switch(dwDisposition)
	{
		case CR_DISP_ISSUED:
				if(S_OK != pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
												&bstrCert))
					goto FailureStatusReturn;

				cbCert = (DWORD)SysStringByteLen(bstrCert);
				pbCert = (BYTE *)bstrCert;

   				//package it in an empty PKCS7
				if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pbCert, cbCert, ppbData, pcbData))
					goto FailureStatusReturn;

				pMsgInfo->dwStatus=MESSAGE_STATUS_SUCCESS;

				//mark the finished for RequesetID/TransactionID pair
				CEPHashMarkTransactionFinished(dwRequestID, &(pMsgInfo->TransactionID));

			break;
		case CR_DISP_UNDER_SUBMISSION:
				
				pMsgInfo->dwStatus=MESSAGE_STATUS_PENDING;

			break;
		case CR_DISP_INCOMPLETE:
			                           
		case CR_DISP_ERROR:   
			                           
		case CR_DISP_DENIED:   
			                           
		case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
			                          
		case CR_DISP_REVOKED:

		default:

				//mark the finished for RequesetID/TransactionID pair
				CEPHashMarkTransactionFinished(dwRequestID, &(pMsgInfo->TransactionID));

				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;

			break;
	}

	fResult = TRUE;

CommonReturn:

	if(bstrCert)
		SysFreeString(bstrCert);

	LeaveCriticalSection(&CriticalSec);	  

	return fResult;	   

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	PackageBlobToPKCS7
//
//	Precondition: ppbData and pcbData is guaranteed not to be NULL
//--------------------------------------------------------------------------
BOOL PackageBlobToPKCS7(DWORD	dwCEP_Context,
						BYTE	*pbEncoded, 
						DWORD	cbEncoded, 
						BYTE	**ppbData, 
						DWORD	*pcbData)
{
	BOOL		fResult=FALSE;

	CERT_BLOB	CertBlob;	
	HCERTSTORE	hCertStore=NULL;


	if((!pbEncoded) || (0==cbEncoded))
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	if(NULL == (hCertStore = CertOpenStore(
							CERT_STORE_PROV_MEMORY,
							ENCODE_TYPE,
							NULL,
							0,
							NULL)))
		goto TraceErr;

	switch(dwCEP_Context)
	{
		case CEP_CONTEXT_CERT:
			if(!CertAddEncodedCertificateToStore(hCertStore,
											ENCODE_TYPE,
											pbEncoded,
											cbEncoded,
											CERT_STORE_ADD_ALWAYS,
											NULL))
				goto TraceErr;

			break;
		case CEP_CONTEXT_CRL:
			if(!CertAddEncodedCRLToStore(hCertStore,
											ENCODE_TYPE,
											pbEncoded,
											cbEncoded,
											CERT_STORE_ADD_ALWAYS,
											NULL))
				goto TraceErr;

			break;
		default:
				goto InvalidArgErr;
			break;

	}	

	CertBlob.cbData=0;
	CertBlob.pbData=NULL;

	if(!CertSaveStore(hCertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto TraceErr;

	CertBlob.pbData = (BYTE *)malloc(CertBlob.cbData);

	if(NULL == CertBlob.pbData)
		goto MemoryErr;

	if(!CertSaveStore(hCertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto TraceErr;

	//copy the memory
	*ppbData=CertBlob.pbData;
	*pcbData=CertBlob.cbData;
	
	CertBlob.pbData=NULL;

	fResult = TRUE;

CommonReturn:

	if(CertBlob.pbData)
		free(CertBlob.pbData);

	if(hCertStore)
		CertCloseStore(hCertStore, 0);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	 CEPRetrievePasswordFromRequest
//
//--------------------------------------------------------------------------
BOOL WINAPI	CEPRetrievePasswordFromRequest(BYTE		*pbRequest, 
										   DWORD	cbRequest, 
										   LPWSTR	*ppwszPassword,
										   DWORD	*pdwUsage)
{
	BOOL				fResult=FALSE;
	DWORD				cbData=0;
	DWORD				dwIndex=0;
	DWORD				cbNameValue=0;
	DWORD				dwExt=0;
	DWORD				cbExtensions=0;
	DWORD				cbSize=0;

	CERT_REQUEST_INFO	*pCertRequestInfo=NULL;
	CERT_NAME_VALUE		*pbNameValue=NULL;
	CERT_EXTENSIONS		*pExtensions=NULL;
	CRYPT_BIT_BLOB		*pKeyUsage=NULL;

	*ppwszPassword=NULL;
	*pdwUsage=0;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
						  pbRequest,
						  cbRequest,
						  (void **)&pCertRequestInfo,
						  &cbData))
		goto TraceErr;

	//get the key usage
	for(dwIndex=0; dwIndex < pCertRequestInfo->cAttribute; dwIndex++)
	{
		if((0 == strcmp(szOID_RSA_certExtensions, pCertRequestInfo->rgAttribute[dwIndex].pszObjId)) ||
			(0 == strcmp(szOID_CERT_EXTENSIONS, pCertRequestInfo->rgAttribute[dwIndex].pszObjId))
		   )
		{	
			if(CEPAllocAndDecode(X509_EXTENSIONS,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].pbData,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].cbData,
								 (void **)&pExtensions,
								 &cbExtensions))
			{
				for(dwExt=0; dwExt < pExtensions->cExtension; dwExt++)
				{
					if(0==strcmp(szOID_KEY_USAGE, pExtensions->rgExtension[dwExt].pszObjId))
					{
						if(CEPAllocAndDecode(X509_KEY_USAGE,
											pExtensions->rgExtension[dwExt].Value.pbData,
											pExtensions->rgExtension[dwExt].Value.cbData,
											(void **)&pKeyUsage,
											&cbSize))
						{
							if(pKeyUsage->pbData)
							{

								if(CERT_DIGITAL_SIGNATURE_KEY_USAGE & (pKeyUsage->pbData[0]))
									(*pdwUsage)	= (*pdwUsage) | CEP_REQUEST_SIGNATURE;

								if(CERT_KEY_ENCIPHERMENT_KEY_USAGE & (pKeyUsage->pbData[0]))
									(*pdwUsage)	= (*pdwUsage) | CEP_REQUEST_EXCHANGE;
							}
						}

						if(pKeyUsage)
							free(pKeyUsage);

						pKeyUsage=NULL;
						cbSize=0;
					}
				}
			}

			if(pExtensions)
				free(pExtensions);

			pExtensions=NULL;
			cbExtensions=0;
		}
	}

	//get the password
	for(dwIndex=0; dwIndex < pCertRequestInfo->cAttribute; dwIndex++)
	{
		if(0 == strcmp(szOID_RSA_challengePwd, 
			pCertRequestInfo->rgAttribute[dwIndex].pszObjId))
			break;
	}

	if(dwIndex == pCertRequestInfo->cAttribute)
		goto InvalidArgErr;

	if(!CEPAllocAndDecode(X509_UNICODE_ANY_STRING,
						 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].pbData,
						 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].cbData,
						 (void **)&pbNameValue,
						 &cbNameValue))
		goto TraceErr;

	if(CERT_RDN_PRINTABLE_STRING != (pbNameValue->dwValueType))
		goto InvalidArgErr;

	cbData=wcslen((LPWSTR)(pbNameValue->Value.pbData));

	*ppwszPassword=(LPWSTR)malloc(sizeof(WCHAR) * (cbData + 1));
	if(NULL==(*ppwszPassword))
		goto MemoryErr;

	wcscpy(*ppwszPassword,(LPWSTR)(pbNameValue->Value.pbData)); 

	fResult=TRUE;

CommonReturn:

	if(pExtensions)
		free(pExtensions);

	if(pKeyUsage)
		free(pKeyUsage);

	if(pbNameValue)
		free(pbNameValue);

	if(pCertRequestInfo)
		free(pCertRequestInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//--------------------------------------------------------------------------
//
//	AltNameExist
//
//	Return TRUE is szOID_SUBJECT_ALT_NAME2 is present in the PKCS10
//	FALSE otherwise
//--------------------------------------------------------------------------
BOOL WINAPI AltNameExist(BYTE *pbRequest, DWORD cbRequest)
{
	BOOL				fResult = FALSE;  
	DWORD				cbData=0;
	DWORD				cbExtensions=0;
	DWORD				dwIndex=0; 
	DWORD				dwExt=0;

	CERT_REQUEST_INFO	*pCertRequestInfo=NULL;
	CERT_EXTENSIONS		*pExtensions=NULL;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
						  pbRequest,
						  cbRequest,
						  (void **)&pCertRequestInfo,
						  &cbData))
		goto ErrorReturn;

	for(dwIndex=0; dwIndex < pCertRequestInfo->cAttribute; dwIndex++)
	{
		if((0 == strcmp(szOID_RSA_certExtensions, pCertRequestInfo->rgAttribute[dwIndex].pszObjId)) ||
			(0 == strcmp(szOID_CERT_EXTENSIONS, pCertRequestInfo->rgAttribute[dwIndex].pszObjId))
		   )
		{	
			if(CEPAllocAndDecode(X509_EXTENSIONS,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].pbData,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].cbData,
								 (void **)&pExtensions,
								 &cbExtensions))
			{
				for(dwExt=0; dwExt < pExtensions->cExtension; dwExt++)
				{
					if(0==strcmp(szOID_SUBJECT_ALT_NAME2, pExtensions->rgExtension[dwExt].pszObjId))
					{
						fResult=TRUE;
						goto CommonReturn;
					}
				}
			}

			if(pExtensions)
				free(pExtensions);

			pExtensions=NULL;
			cbExtensions=0;
		}
	}

CommonReturn:

	if(pExtensions)
		free(pExtensions);

	if(pCertRequestInfo)
		free(pCertRequestInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;
}

//--------------------------------------------------------------------------
//
//	CEPAllocAndEncode
//
//--------------------------------------------------------------------------
BOOL WINAPI CEPAllocAndEncode(LPCSTR lpszStructType,
							void	*pStructInfo,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded)
{
	BOOL	fResult=FALSE;

	*pcbEncoded=0;

	if(!CryptEncodeObject(ENCODE_TYPE,
						  lpszStructType,
						  pStructInfo,
						  NULL,
						  pcbEncoded))
		goto TraceErr;

	*ppbEncoded=(BYTE *)malloc(*pcbEncoded);
	if(NULL==(*ppbEncoded))
		goto MemoryErr;

	if(!CryptEncodeObject(ENCODE_TYPE,
						  lpszStructType,
						  pStructInfo,
						  *ppbEncoded,
						  pcbEncoded))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	if(*ppbEncoded)
	{
		free(*ppbEncoded);
		*ppbEncoded=NULL;
	}

	*pcbEncoded=0;

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr); 
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	ConvertIPStringToBinary
//
//	Conver the IP address in the format of "xxx.xx.xx.xx" to an arry of 
//	bytes.  One byte per xxx
//--------------------------------------------------------------------------
BOOL ConvertIPStringToBinary(LPWSTR				pwszIP,
							CRYPT_DATA_BLOB		*pIPAddress)
{
	BOOL	fResult = FALSE;   
	LPWSTR	pwszTok=NULL;
	DWORD	cTok=0;
	DWORD	dwIndex=0;

	if(!pwszIP || !pIPAddress)
		goto InvalidArgErr;

	pIPAddress->pbData=NULL;
	pIPAddress->cbData=0;

	pwszTok=wcstok(pwszIP, L".");
	
	while(NULL != pwszTok)
	{
		cTok++;
		pwszTok=wcstok(NULL, L".");
	}

	pIPAddress->pbData=(BYTE *)malloc(cTok);
	if(NULL==pIPAddress->pbData)
		goto MemoryErr;

	pIPAddress->cbData=cTok;

	pwszTok=pwszIP;

	for(dwIndex=0; dwIndex < cTok; dwIndex++)
	{
		pIPAddress->pbData[dwIndex]=(BYTE)_wtol(pwszTok);		
		pwszTok=pwszTok+wcslen(pwszTok)+1;
	}

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	GetAltNameElement
//
//	We create the subject alternative extension based on the PKCS10.
//	unstructedName(DNS name) and unstructedAddress (IP address) are included.
//  At lease one element should be present.
//--------------------------------------------------------------------------
BOOL WINAPI	GetAltNameElement(BYTE				*pb10, 
						   DWORD				cb10, 
						   LPWSTR				*ppwszDNS, 
						   CRYPT_DATA_BLOB		*pIPAddress)
{
	BOOL					fResult = FALSE;
	DWORD					cbRequestInfo=0;
	DWORD					cbNameInfo=0;
	DWORD					dwRDN=0;
	DWORD					dwAttr=0;
	PCERT_RDN_ATTR			pAttr=NULL;
	DWORD					cb=0;

	CERT_REQUEST_INFO		*pRequestInfo=NULL;
	CERT_NAME_INFO			*pNameInfo=NULL;

	if(!pb10 || !ppwszDNS || !pIPAddress)
		goto InvalidArgErr;

	*ppwszDNS=NULL;
	pIPAddress->cbData=0;
	pIPAddress->pbData=NULL;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
						  pb10,
						  cb10,
						  (void **)&pRequestInfo,
						  &cbRequestInfo))
		goto TraceErr;

	if(!CEPAllocAndDecode(X509_UNICODE_NAME,
						 pRequestInfo->Subject.pbData,
						 pRequestInfo->Subject.cbData,
						 (void **)&pNameInfo,
						 &cbNameInfo))
		goto TraceErr;

	for(dwRDN=0; dwRDN<pNameInfo->cRDN; dwRDN++)
	{
		for(dwAttr=0; dwAttr<pNameInfo->rgRDN[dwRDN].cRDNAttr; dwAttr++)
		{
			pAttr=&(pNameInfo->rgRDN[dwRDN].rgRDNAttr[dwAttr]);

			//we are happy if we have found both the IPAddress and the fqdn
			if((*ppwszDNS) && (pIPAddress->pbData))
				break;

			if((NULL==*ppwszDNS) && (0 == strcmp(szOID_RSA_unstructName,pAttr->pszObjId)))
			{
				cb=sizeof(WCHAR) * (1+wcslen((LPWSTR)(pAttr->Value.pbData)));

				*ppwszDNS=(LPWSTR)malloc(cb); 

				if(NULL == *ppwszDNS)
					goto MemoryErr;

				wcscpy(*ppwszDNS, (LPWSTR)(pAttr->Value.pbData));
			}
			else
			{
				if((NULL==pIPAddress->pbData) && (0 == strcmp(szOID_RSA_unstructAddr,pAttr->pszObjId)))
				{
					if(!ConvertIPStringToBinary((LPWSTR)(pAttr->Value.pbData),
												pIPAddress))
						goto TraceErr;
				}
			}
		}
	}

	//we need to have some element
	if((NULL == *ppwszDNS) && (NULL==pIPAddress->pbData))
		goto InvalidArgErr;

	fResult = TRUE;

CommonReturn:

	if(pNameInfo)
		free(pNameInfo);

	if(pRequestInfo)
		free(pRequestInfo);

	return fResult;

ErrorReturn:

	if(ppwszDNS)
	{
		if(*ppwszDNS)
		{
			free(*ppwszDNS);
			*ppwszDNS=NULL;
		}
	}

	if(pIPAddress)
	{
		if(pIPAddress->pbData)
		{
			free(pIPAddress->pbData);
			pIPAddress->pbData=NULL;
		}

		pIPAddress->cbData=0;
	}

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	CreateAltNameExtenions
//
//--------------------------------------------------------------------------
BOOL WINAPI	CreateAltNameExtenions(LPWSTR			pwszDNS,
							   CRYPT_DATA_BLOB	*pIPAddress,
							   BYTE				**ppbExt, 
							   DWORD			*pcbExt)
{
	BOOL					fResult = FALSE;
	CERT_ALT_NAME_INFO		AltNameInfo;
	CERT_ALT_NAME_ENTRY		rgAltNameEntry[2];
	DWORD					cAltNameEntry=0;

	//DNS name
	if(pwszDNS)
	{
		rgAltNameEntry[cAltNameEntry].dwAltNameChoice=CERT_ALT_NAME_DNS_NAME;
		rgAltNameEntry[cAltNameEntry].pwszDNSName=pwszDNS;
		cAltNameEntry++;
	}

	//IP address
	if(pIPAddress->pbData)
	{
		rgAltNameEntry[cAltNameEntry].dwAltNameChoice=CERT_ALT_NAME_IP_ADDRESS;
		rgAltNameEntry[cAltNameEntry].IPAddress.cbData=pIPAddress->cbData;
		rgAltNameEntry[cAltNameEntry].IPAddress.pbData=pIPAddress->pbData;
		cAltNameEntry++;
	}


	memset(&AltNameInfo, 0, sizeof(CERT_ALT_NAME_INFO));
	AltNameInfo.cAltEntry=cAltNameEntry;
	AltNameInfo.rgAltEntry=rgAltNameEntry;

	if(!CEPAllocAndEncode(szOID_SUBJECT_ALT_NAME2,
							&AltNameInfo,
							ppbExt,
							pcbExt))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}


//--------------------------------------------------------------------------
//
//	AddAltNameInRequest
//
//--------------------------------------------------------------------------
BOOL WINAPI AddAltNameInRequest(PCCERT_CONTEXT	pRACert, 
								BYTE			*pb10, 
								DWORD			cb10, 
								LPWSTR			pwszDNS,
								CRYPT_DATA_BLOB	*pIPAddress,
								BYTE			**ppb7, 
								DWORD			*pcb7)
{
	BOOL						fResult = FALSE;
	DWORD						cbExt=0;
	CERT_EXTENSIONS				Exts;
	CERT_EXTENSION				Ext;
	DWORD						cbAllExt=0;
	CRYPT_SIGN_MESSAGE_PARA		signPara;
	CRYPT_ATTRIBUTE				AuthAttr;
    PCCRYPT_OID_INFO            pOIDInfo=NULL;
	ALG_ID						AlgValue=CALG_SHA1;
	CRYPT_ATTR_BLOB				AttrBlob;

	BYTE						*pbExt=NULL;
	BYTE						*pbAllExt=NULL;

	if(!pRACert || !pb10 || !ppb7 || !pcb7)
		goto InvalidArgErr;

	*ppb7=NULL;
	*pcb7=0;

	if(!CreateAltNameExtenions(pwszDNS, pIPAddress, &pbExt, &cbExt))
		goto TraceErr;
	
	Exts.cExtension=1;
	Exts.rgExtension=&Ext;

	Ext.pszObjId=szOID_SUBJECT_ALT_NAME2;
	Ext.fCritical=TRUE;
	Ext.Value.pbData=pbExt;
	Ext.Value.cbData=cbExt;

	if(!CEPAllocAndEncode(X509_EXTENSIONS,
						  &Exts,
						  &pbAllExt,
						  &cbAllExt))
		goto TraceErr;

	AuthAttr.pszObjId=szOID_CERT_EXTENSIONS;
	AuthAttr.cValue=1;
	AuthAttr.rgValue=&AttrBlob;

	AttrBlob.pbData=pbAllExt;
	AttrBlob.cbData=cbAllExt;


	memset(&signPara, 0, sizeof(signPara));

	signPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signPara.dwMsgEncodingType       = ENCODE_TYPE;
    signPara.pSigningCert            = pRACert;
    signPara.cMsgCert                = 1;
    signPara.rgpMsgCert              = &pRACert;
	signPara.cAuthAttr				= 1;
	signPara.rgAuthAttr				= &AuthAttr; 

	if(pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_ALGID_KEY,
                        &AlgValue,
                        CRYPT_HASH_ALG_OID_GROUP_ID))
		signPara.HashAlgorithm.pszObjId=(LPSTR)(pOIDInfo->pszOID);
	else
		signPara.HashAlgorithm.pszObjId=szOID_OIWSEC_sha1;


	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			NULL,
			pcb7))
		goto TraceErr;

	*ppb7=(BYTE *)malloc(*pcb7);
	if(NULL==(*ppb7))
		goto MemoryErr;
	
	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			*ppb7,
			pcb7))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	if(pbAllExt)
		free(pbAllExt);

	if(pbExt)
		free(pbExt);

	return fResult;

ErrorReturn:
	
	if(ppb7)
	{
		if(*ppb7)
		{
			free(*ppb7);
			*ppb7=NULL;
		}
	}

	if(pcb7)
		*pcb7=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}
//--------------------------------------------------------------------------
//
//	MakePKCS7Request
//
//--------------------------------------------------------------------------
BOOL WINAPI MakePKCS7Request(PCCERT_CONTEXT	pRACert, 
								BYTE			*pb10, 
								DWORD			cb10, 
								BYTE			**ppb7, 
								DWORD			*pcb7)
{
	BOOL						fResult = FALSE;
	CRYPT_SIGN_MESSAGE_PARA		signPara;
    PCCRYPT_OID_INFO            pOIDInfo=NULL;
	ALG_ID						AlgValue=CALG_SHA1;


	if(!pRACert || !pb10 || !ppb7 || !pcb7)
		goto InvalidArgErr;

	*ppb7=NULL;
	*pcb7=0;


	memset(&signPara, 0, sizeof(signPara));

	signPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signPara.dwMsgEncodingType       = ENCODE_TYPE;
    signPara.pSigningCert            = pRACert;
    signPara.cMsgCert                = 1;
    signPara.rgpMsgCert              = &pRACert;
	signPara.cAuthAttr				= 0;
	signPara.rgAuthAttr				= NULL; 

	if(pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_ALGID_KEY,
                        &AlgValue,
                        CRYPT_HASH_ALG_OID_GROUP_ID))
		signPara.HashAlgorithm.pszObjId=(LPSTR)(pOIDInfo->pszOID);
	else
		signPara.HashAlgorithm.pszObjId=szOID_OIWSEC_sha1;


	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			NULL,
			pcb7))
		goto TraceErr;

	*ppb7=(BYTE *)malloc(*pcb7);
	if(NULL==(*ppb7))
		goto MemoryErr;
	
	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			*ppb7,
			pcb7))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:
	
	if(ppb7)
	{
		if(*ppb7)
		{
			free(*ppb7);
			*ppb7=NULL;
		}
	}

	if(pcb7)
		*pcb7=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

/*//--------------------------------------------------------------------------
//
//	GetLogonInfoFromValue
//
//	The pwszString can be of format "name;password" or "domain\name;password"
//
//--------------------------------------------------------------------------
BOOL GetLogonInfoFromValue(PCCERT_CONTEXT		pRAEncrypt,
						   LPWSTR				pwszString,
						   LPWSTR				*ppwszDomain,
						   LPWSTR				*ppwszUser,
						   LPWSTR				*ppwszPassword)
{
	BOOL		fResult=FALSE;
	LPWSTR		pwsz=NULL;
	BOOL		fDomain=FALSE;
	BOOL		fPassword=FALSE;
	LPWSTR		pwszPlainText=NULL;

	*ppwszDomain=NULL;
	*ppwszUser=NULL;
	*ppwszPassword=NULL;
						 
	if(NULL==pwszString)
		goto InvalidArgErr;

	if(0 == wcslen(pwszString))
		goto InvalidArgErr;

	for(pwsz=pwszString; *pwsz!=L'\0'; pwsz++)
	{
		if(*pwsz==L'\\')
		{
			if(fDomain)
				goto InvalidArgErr;

			fDomain=TRUE;

			*pwsz='\0';
		}
		else
		{
			if(*pwsz==L';')
			{
				if(fPassword)
					goto InvalidArgErr;

				fPassword=TRUE;

				*pwsz='\0';
			}
		}

	}

	//have to have userName and password.  
	//One and only one ";" should be found
	if(!fPassword)
		goto InvalidArgErr;

	//one or no "\" should be found
	if(fDomain)
	{
		*ppwszDomain=pwszString;
		*ppwszUser=*ppwszDomain + wcslen(*ppwszDomain) + 1;
	}
	else
	{
		*ppwszDomain=NULL;
		*ppwszUser=pwszString;
	}

	*ppwszPassword = *ppwszUser + wcslen(*ppwszUser) + 1;

	if(fDomain)
	{
		if(L'\0'==(**ppwszDomain))
			goto InvalidArgErr;
	}

	if((L'\0'==(**ppwszUser)) || (L'\0'==(**ppwszPassword)))
		goto InvalidArgErr;

	//convert the encrypted password to the plain text form
	if(!CEPDecryptPassword(pRAEncrypt,
						   *ppwszPassword,
						   &pwszPlainText))
		goto TraceErr;

	*ppwszPassword=pwszPlainText;
	
	fResult = TRUE;

CommonReturn:

	return fResult;
	
ErrorReturn:

	*ppwszDomain=NULL;
	*ppwszUser=NULL;
	*ppwszPassword=NULL;	 

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
}  */


/*//--------------------------------------------------------------------------
//
//	CEPGetTokenFromPKCS10
//
//	If fPassword is TRUE, an impersonation has to occur.
//--------------------------------------------------------------------------
BOOL CEPGetTokenFromPKCS10(BOOL					fPassword,
						   PCCERT_CONTEXT		pRAEncrypt,
						   BYTE					*pbRequest, 
						   DWORD				cbRequest, 
						   HANDLE				*phToken)
{
	BOOL				fResult=FALSE;
	DWORD				cbRequestInfo=0;
	DWORD				dwIndex=0;
	CRYPT_ATTRIBUTE		*pAttr=NULL;
	DWORD				cbData=0;
	LPWSTR				pwszDomain=NULL;
	LPWSTR				pwszUserName=NULL;
	LPWSTR				pwszPassword=NULL;

	CERT_REQUEST_INFO	*pRequestInfo=NULL;
	CERT_NAME_VALUE		*pCertNameValue=NULL;

	*phToken=NULL;

	if((!pbRequest) || (0==cbRequest))
		goto InvalidArgErr;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
				  pbRequest,
				  cbRequest,
				  (void **)&pRequestInfo,
				  &cbRequestInfo))
		goto TraceErr;

	for(dwIndex=0; dwIndex < pRequestInfo->cAttribute; dwIndex++)
	{
		if(0 == strcmp(szOID_RSA_challengePwd, (pRequestInfo->rgAttribute[dwIndex]).pszObjId))
		{
			pAttr= &(pRequestInfo->rgAttribute[dwIndex]);
			break;
		}
	}

	if(NULL==pAttr)
	{
		if(fPassword)
			goto InvalidArgErr;
		else
		{
			*phToken=NULL;
			fResult=TRUE;
			goto CommonReturn;
		}
	}

	if(CEPAllocAndDecode(X509_UNICODE_ANY_STRING,
				  pAttr->rgValue[0].pbData,
				  pAttr->rgValue[0].cbData,
				  (void **)&pCertNameValue,
				  &cbData))
	{
		if(GetLogonInfoFromValue(pRAEncrypt,
								(LPWSTR)(pCertNameValue->Value.pbData),
								&pwszDomain,
								&pwszUserName,
								&pwszPassword))
		{
			if(!LogonUserW(pwszUserName,
						  pwszDomain,
						  pwszPassword,
						  LOGON32_LOGON_INTERACTIVE,
						  LOGON32_PROVIDER_DEFAULT,
						  phToken))
				*phToken=NULL;
		}
	}

	if(NULL == *phToken)
	{
		if(fPassword)
			goto InvalidArgErr;
	}

	fResult = TRUE;

CommonReturn:

	if(pRequestInfo)
		free(pRequestInfo);

	if(pCertNameValue)
		free(pCertNameValue);

	return fResult;
	
ErrorReturn:
	
	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
} */


//--------------------------------------------------------------------------
//
//	CEPCopyRequestAndRequestID
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPCopyRequestAndRequestID(BYTE		*pbRequest, 
											  DWORD		cbRequest, 
											DWORD		dwRequestID)
{
	BOOL			fResult=FALSE;
	BYTE			pbHash[CEP_MD5_HASH_SIZE];
	DWORD			cbData=0;

	
	cbData=CEP_MD5_HASH_SIZE;

	if(!CryptHashCertificate(
			NULL,
			CALG_MD5,
			0,
			pbRequest,
			cbRequest,
			pbHash,
			&cbData))
		goto TraceErr;


	if(!CEPRequestAddHashAndRequestID(pbHash, dwRequestID))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;
	
ErrorReturn:	

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	CEPGetCertFromPKCS10
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPGetCertFromPKCS10(CEP_CA_INFO	*pCAInfo,
							 BYTE			*pbRequest, 
							 DWORD			cbRequest, 
							 BYTE			**ppbData, 
							 DWORD			*pcbData,
							 CEP_MESSAGE_INFO		*pMsgInfo)
{
	BOOL	fResult = FALSE;
	DWORD	dwRequestID=0;
	DWORD	cbCert=0;
	BYTE	*pbCert=NULL;	
	DWORD	dwErrorInfo=MESSAGE_FAILURE_BAD_CERT_ID;
	long	dwDisposition=0;
	BYTE	pbHash[CEP_MD5_HASH_SIZE];
	DWORD	cbData=0;


	BSTR	bstrCert=NULL;


	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	cbData=CEP_MD5_HASH_SIZE;

	if(!CryptHashCertificate(
			NULL,
			CALG_MD5,
			0,
			pbRequest,
			cbRequest,
			pbHash,
			&cbData))
		goto TraceErr;

	if(!CEPRequestRetrieveRequestIDFromHash(pbHash, &dwRequestID))
		goto InvalidArgErr;

	if(S_OK != pCAInfo->pICertRequest->RetrievePending(dwRequestID,
													pCAInfo->bstrCAConfig,
													&dwDisposition))
		goto InvalidArgErr;

	switch(dwDisposition)
	{
		case CR_DISP_ISSUED:
				if(S_OK != pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
												&bstrCert))
					goto FailureStatusReturn;

				cbCert = (DWORD)SysStringByteLen(bstrCert);
				pbCert = (BYTE *)bstrCert;

   				//package it in an empty PKCS7
				if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pbCert, cbCert, ppbData, pcbData))
					goto FailureStatusReturn;

				pMsgInfo->dwStatus=MESSAGE_STATUS_SUCCESS;

			break;
		case CR_DISP_UNDER_SUBMISSION:
				
				pMsgInfo->dwStatus=MESSAGE_STATUS_PENDING;

			break;
		case CR_DISP_INCOMPLETE:
			                           
		case CR_DISP_ERROR:   
			                           
		case CR_DISP_DENIED:   
			                           
		case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
			                          
		case CR_DISP_REVOKED:

		default:

				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;

			break;
	}

	fResult = TRUE;

CommonReturn:

	if(bstrCert)
		SysFreeString(bstrCert);

	return fResult;	   

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	ProcessCertRequest
//
//--------------------------------------------------------------------------
BOOL	ProcessCertRequest(	DWORD				dwRefreshDays,
							BOOL				fPassword,
						    PCCERT_CONTEXT		pRAEncrypt,
						    PCCERT_CONTEXT		pRACert,
							CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{					
	BOOL				fResult = FALSE;
	HRESULT				hr=E_FAIL;
	DWORD				dwFlags=0;
	long				dwDisposition=0;
	DWORD				dwErrorInfo=MESSAGE_FAILURE_BAD_MESSAGE_CHECK;
	DWORD				cbNewRequest=0;
	DWORD				cbCert=0;
	BYTE				*pbCert=NULL;
	DWORD				dwRequestID=0;
	DWORD				dwUsage=0;
	
	BSTR				bstrRequest=NULL;
	BYTE				*pbNewRequest=NULL;
	BSTR				bstrCert=NULL;
	BSTR				bstrAttr=NULL;
	LPWSTR				pwszDNS=NULL;
	CRYPT_DATA_BLOB		IPAddress={0, NULL};
	LPWSTR				pwszPassword=NULL;

	EnterCriticalSection(&CriticalSec);	 

	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	//check to see if the PKCS10 is in our cached request table
	//if so, we return messages based on the cached requestID
	if(CEPGetCertFromPKCS10(pCAInfo, pbRequest, cbRequest, ppbData, pcbData, pMsgInfo))
	{
		fResult=TRUE;
	}
	else
	{

		//if the password is required, we need to make sure the password
		//supplied is valid.
		if(fPassword)
		{
			if(!CEPRetrievePasswordFromRequest(pbRequest, cbRequest, &pwszPassword, &dwUsage))
			{
				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;
			}

			if(!CEPVerifyPasswordAndDeleteFromTable(pwszPassword, dwUsage))
			{
				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;
			}
		}

		//if the altname extention is not in the PKCS10, we need to add it
		//otherwise, just use the PKCS10

		dwFlags = CR_IN_PKCS10;
		pbNewRequest=pbRequest;
		cbNewRequest=cbRequest;

		if(!AltNameExist(pbRequest, cbRequest))
		{
			if(GetAltNameElement(pbRequest, cbRequest, &pwszDNS, &IPAddress))
			{
				if(!AddAltNameInRequest(pRACert, pbRequest, cbRequest, pwszDNS, &IPAddress, &pbNewRequest, &cbNewRequest))
					goto TraceErr;

				dwFlags = CR_IN_PKCS7;
			}
		}
        
        //we always want to make a PKCS7 request so that we can work with enterprise CA
        if(CR_IN_PKCS10 == dwFlags)
        {
            if(!MakePKCS7Request(pRACert, pbRequest, cbRequest, &pbNewRequest, &cbNewRequest))
                goto TraceErr;

            dwFlags = CR_IN_PKCS7;
        }

		if(!(bstrRequest=SysAllocStringByteLen((LPCSTR)pbNewRequest, cbNewRequest)))
			goto MemoryErr;

		//we are requesting a IPSEC offline cert template
		if(!(bstrAttr=SysAllocString(L"CertificateTemplate:IPSECIntermediateOffline\r\n")))
			goto MemoryErr;

		if(S_OK != (hr=pCAInfo->pICertRequest->Submit(
								CR_IN_BINARY | dwFlags,
								bstrRequest,
								bstrAttr,
								pCAInfo->bstrCAConfig,
								&dwDisposition)))
		   goto FailureStatusReturn;

		dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;

		switch(dwDisposition)
		{
			case CR_DISP_ISSUED:

					if(S_OK != pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
													&bstrCert))
						goto FailureStatusReturn;

					cbCert = (DWORD)SysStringByteLen(bstrCert);
					pbCert = (BYTE *)bstrCert;	 

   					//package it in an empty PKCS7
					if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pbCert, cbCert, ppbData, pcbData))
						goto FailureStatusReturn;

					pMsgInfo->dwStatus=MESSAGE_STATUS_SUCCESS;

					//copy the PKCS10 to the cached request table
					if(S_OK == (hr=pCAInfo->pICertRequest->GetRequestId((long*)(&dwRequestID))))
					{
						CEPCopyRequestAndRequestID(pbRequest, cbRequest, dwRequestID);
					}

				break;
			case CR_DISP_UNDER_SUBMISSION:

					//copy the transactionID/requestID pair	
					if(S_OK == (hr=pCAInfo->pICertRequest->GetRequestId((long*)(&dwRequestID))))
					{
						if(!CEPHashAddRequestAndTransaction(dwRefreshDays,
														dwRequestID,
														&(pMsgInfo->TransactionID)))
							goto DatabaseErr;
						
						//also copy the PKCS10 to the cached request table for retrial cases
						CEPCopyRequestAndRequestID(pbRequest, cbRequest, dwRequestID);						
					}

					pMsgInfo->dwStatus=MESSAGE_STATUS_PENDING;

				break;

			case CR_DISP_INCOMPLETE:
										   
			case CR_DISP_ERROR:   
										   
			case CR_DISP_DENIED:   
										   
			case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
										  
			case CR_DISP_REVOKED:

			default:
					dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
					goto FailureStatusReturn;

				break;
		}
	}

	
	fResult = TRUE;

CommonReturn:

	if(pwszPassword)
		free(pwszPassword);

	if(bstrCert)
		SysFreeString(bstrCert);

	if(bstrRequest)
		SysFreeString(bstrRequest);

	if(bstrAttr)
		SysFreeString(bstrAttr);

	if(pwszDNS)
		free(pwszDNS);

	if(IPAddress.pbData)
		free(IPAddress.pbData);

	if(dwFlags == CR_IN_PKCS7)
	{
		if(pbNewRequest)
			free(pbNewRequest);
	}	  

	LeaveCriticalSection(&CriticalSec);	   

	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;
	
ErrorReturn:	


	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
TRACE_ERROR(DatabaseErr);
}


//--------------------------------------------------------------------------
//
//	DecryptMsg
//
//--------------------------------------------------------------------------
BOOL WINAPI DecryptMsg(CEP_RA_INFO		*pRAInfo, 
					   BYTE				*pbReqEnv, 
					   DWORD			cbReqEnv, 
					   BYTE				**ppbReqDecrypt, 
					   DWORD			*pcbReqDecrypt)
{
	BOOL					fResult = FALSE; 
	CMSG_CTRL_DECRYPT_PARA	DecryptPara;
	BOOL					fProvFree=FALSE;

	HCRYPTMSG				hMsg=NULL;

	if(!pRAInfo || !pbReqEnv || !ppbReqDecrypt || !pcbReqDecrypt)
		goto InvalidArgErr;

	*ppbReqDecrypt=NULL;
	*pcbReqDecrypt=0;

	if(NULL == (hMsg=CryptMsgOpenToDecode(
						ENCODE_TYPE,
						0,
						0,
						NULL,
						NULL,
						NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbReqEnv,
						cbReqEnv,
						TRUE))
		goto TraceErr;

	//decrypt
	memset(&DecryptPara, 0, sizeof(CMSG_CTRL_DECRYPT_PARA));

	DecryptPara.cbSize=sizeof(CMSG_CTRL_DECRYPT_PARA);
	DecryptPara.dwRecipientIndex=0;
	DecryptPara.hCryptProv=pRAInfo->hRAProv;
	DecryptPara.dwKeySpec=pRAInfo->dwKeySpec;

	if(!CryptMsgControl(hMsg,
						0,
						CMSG_CTRL_DECRYPT,
						&DecryptPara))
		goto TraceErr;

	//get the content
	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbReqDecrypt))
		goto TraceErr;

	*ppbReqDecrypt=(BYTE *)malloc(*pcbReqDecrypt);
	if(NULL==(*ppbReqDecrypt))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbReqDecrypt,
						pcbReqDecrypt))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	if(hMsg)
		CryptMsgClose(hMsg);	

	return fResult;

ErrorReturn:

	if(ppbReqDecrypt)
	{
		if(*ppbReqDecrypt)
		{
			free(*ppbReqDecrypt);
			*ppbReqDecrypt=NULL;
		}
	}

	if(pcbReqDecrypt)
		*pcbReqDecrypt=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//--------------------------------------------------------------------------
//
//	GetContentFromPKCS7
//
//--------------------------------------------------------------------------
BOOL	WINAPI	GetContentFromPKCS7(BYTE				*pbMessage,
									DWORD				cbMessage,
									BYTE				**ppbContent,
									DWORD				*pcbContent,
									CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL				fResult = FALSE;
	DWORD				cbAuth=0;
	DWORD				dwIndex=0;
	CRYPT_ATTRIBUTE		*pOneAuth=NULL;
	DWORD				cb=0;
	DWORD				cbCertInfo=0;
 	PCCERT_CONTEXT		pCertPre=NULL;


	HCRYPTMSG			hMsg=NULL;
	CRYPT_ATTRIBUTES	*pbAuth=NULL;
	void				*pb=NULL;
	CERT_INFO			*pbCertInfo=NULL;
	HCERTSTORE			hCertStore=NULL; 
	PCCERT_CONTEXT		pCertCur=NULL;

	if(!pMsgInfo || !ppbContent || !pcbContent)
		goto InvalidArgErr;

	*ppbContent=NULL;
	*pcbContent=0;

	memset(pMsgInfo, 0, sizeof(CEP_MESSAGE_INFO));

	if(NULL == (hMsg=CryptMsgOpenToDecode(
						ENCODE_TYPE,
						0,
						0,
						NULL,
						NULL,
						NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbMessage,
						cbMessage,
						TRUE))
		goto TraceErr;

	//get the content
	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbContent))
		goto TraceErr;

	*ppbContent=(BYTE *)malloc(*pcbContent);
	if(NULL==(*ppbContent))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbContent,
						pcbContent))
		goto TraceErr;

	//get message type
	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_AUTH_ATTR_PARAM,
						0,
						NULL,
						&cbAuth))
		goto TraceErr;

	pbAuth=(CRYPT_ATTRIBUTES *)malloc(cbAuth);
	if(NULL==pbAuth)
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_AUTH_ATTR_PARAM,
						0,
						pbAuth,
						&cbAuth))
		goto TraceErr;

	for(dwIndex=0; dwIndex < pbAuth->cAttr; dwIndex++)
	{
		pOneAuth=&(pbAuth->rgAttr[dwIndex]);

		if((!(pOneAuth->pszObjId)) || (!(pOneAuth->rgValue)))
			continue;

		if((0==(pOneAuth->rgValue[0].cbData)) || (!(pOneAuth->rgValue[0].pbData)))
			continue;
		
		if(0 == strcmp(pOneAuth->pszObjId, szOIDVerisign_MessageType))
		{	
			
			if(!CEPAllocAndDecode(X509_ANY_STRING,
								  pOneAuth->rgValue[0].pbData,
								  pOneAuth->rgValue[0].cbData,
								  (void **)&pb,
								  &cb))
				goto TraceErr;

			if(CERT_RDN_PRINTABLE_STRING != ((CERT_NAME_VALUE *)pb)->dwValueType)
				goto InvalidArgErr;

			pMsgInfo->dwMessageType = atol((LPSTR)(((CERT_NAME_VALUE *)pb)->Value.pbData));
		}
		else
		{
			if(0 == strcmp(pOneAuth->pszObjId, szOIDVerisign_SenderNonce))
			{
				if(!CEPAllocAndDecode(X509_OCTET_STRING,
									  pOneAuth->rgValue[0].pbData,
									  pOneAuth->rgValue[0].cbData,
									  (void **)&pb,
									  &cb))
					goto TraceErr;

				//the SenderNonce in the request is the recipienNonce in the response
				if(!AllocAndCopyBlob(&(pMsgInfo->RecipientNonce),
								 (CERT_BLOB *)pb))
					goto TraceErr;
								
			}
			else
			{
				if(0 == strcmp(pOneAuth->pszObjId, szOIDVerisign_TransactionID))
				{
					if(!CEPAllocAndDecode(X509_ANY_STRING,
										  pOneAuth->rgValue[0].pbData,
										  pOneAuth->rgValue[0].cbData,
										  (void **)&pb,
										  &cb))
						goto TraceErr;

					if(CERT_RDN_PRINTABLE_STRING != ((CERT_NAME_VALUE *)pb)->dwValueType)
						goto InvalidArgErr;

					if(!AllocAndCopyString(&(pMsgInfo->TransactionID),
							(LPSTR)(((CERT_NAME_VALUE *)pb)->Value.pbData)))
						goto TraceErr;

				}
			}
		}

		if(pb)
			free(pb);

		pb=NULL;
		cb=0;
	}

	//we have to have TrasanctionID and messageType
	if((0 == pMsgInfo->dwMessageType)||(NULL == (pMsgInfo->TransactionID.pbData)))
		goto InvalidArgErr;

	//we get the serial number of the signing certificate
	cbCertInfo=0;
	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_CERT_INFO_PARAM,
						0,
						NULL,
						&cbCertInfo))
		goto TraceErr;

	pbCertInfo=(CERT_INFO *)malloc(cbCertInfo);
	if(NULL==pbCertInfo)
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_CERT_INFO_PARAM,
						0,
						pbCertInfo,
						&cbCertInfo))
		goto TraceErr;

	if(!AllocAndCopyBlob(&(pMsgInfo->SerialNumber), (CERT_BLOB *)(&(pbCertInfo->SerialNumber))))
		goto TraceErr;

	//we get the rounter's CA issued certificate for GetCertInitial message
	if((MESSAGE_TYPE_GET_CERT_INITIAL == pMsgInfo->dwMessageType) ||
		(MESSAGE_TYPE_CERT_REQUEST == pMsgInfo->dwMessageType) ||
		(MESSAGE_TYPE_GET_CERT == pMsgInfo->dwMessageType)
		)
	{
		if(NULL == (hCertStore=CertOpenStore(CERT_STORE_PROV_MSG,
											ENCODE_TYPE,
											NULL,
											0,
											hMsg)))
			goto TraceErr;

		pCertPre=NULL;
		while(pCertCur=CertEnumCertificatesInStore(hCertStore, pCertPre))
		{
			if(SameCert(pCertCur->pCertInfo, pbCertInfo))
			{
				if(NULL==(pMsgInfo->pSigningCert=CertDuplicateCertificateContext(pCertCur)))
					goto TraceErr;

				break;
			}

			pCertPre=pCertCur;
		}

		if(NULL == (pMsgInfo->pSigningCert))
			goto InvalidArgErr; 
	}


	fResult = TRUE;	

CommonReturn:


	if(pCertCur)
		CertFreeCertificateContext(pCertCur);

	if(hCertStore)
		CertCloseStore(hCertStore, 0);

	if(pbCertInfo)
		free(pbCertInfo);

	if(pb)
		free(pb);

	if(pbAuth)
		free(pbAuth);

	if(hMsg)
		CryptMsgClose(hMsg);

	return fResult;


ErrorReturn:

	if(ppbContent)
	{
		if(*ppbContent)
		{
			free(*ppbContent);
			*ppbContent=NULL;
		}
	}

	if(pcbContent)
		*pcbContent=0;
	

	FreeMessageInfo(pMsgInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	SameCert
//
//--------------------------------------------------------------------------
BOOL WINAPI SameCert(CERT_INFO *pCertInfoOne, CERT_INFO *pCertInfoTwo)
{
	if(!pCertInfoOne || !pCertInfoTwo)
		return FALSE;

	if(!SameBlob(&(pCertInfoOne->SerialNumber), &(pCertInfoTwo->SerialNumber)))
		return FALSE;

	if(!SameBlob((CRYPT_INTEGER_BLOB *)(&(pCertInfoOne->Issuer)), 
				 (CRYPT_INTEGER_BLOB *)(&(pCertInfoTwo->Issuer))))
		return FALSE;

	return TRUE;

}


//--------------------------------------------------------------------------
//
//	SameBlob
//
//--------------------------------------------------------------------------
BOOL WINAPI SameBlob(CRYPT_INTEGER_BLOB *pBlobOne, CRYPT_INTEGER_BLOB *pBlobTwo)
{
	if(!pBlobOne || !pBlobTwo)
		return FALSE;

	if(pBlobOne->cbData != pBlobTwo->cbData)
		return FALSE;

	if(0!=(memcmp(pBlobOne->pbData, pBlobTwo->pbData,pBlobTwo->cbData)))
		return FALSE;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPAllocAndDecode
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPAllocAndDecode(	LPCSTR	lpszStructType,
									BYTE	*pbEncoded,
									DWORD	cbEncoded,
									void	**ppb,
									DWORD	*pcb)
{
	BOOL	fResult = FALSE;

	*pcb=0;
	*ppb=NULL;

	if(!CryptDecodeObject(ENCODE_TYPE,
						lpszStructType,
						pbEncoded,
						cbEncoded,
						0,
						NULL,
						pcb))
		goto DecodeErr;

	*ppb=malloc(*pcb);

	if(NULL==(*ppb))
		goto MemoryErr;

	if(!CryptDecodeObject(ENCODE_TYPE,
						lpszStructType,
						pbEncoded,
						cbEncoded,
						0,
						*ppb,
						pcb))
		goto DecodeErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	if(ppb)
	{
		if(*ppb)
		{
			free(*ppb);
			*ppb=NULL;
		}
	}

	if(pcb)
		*pcb=0;

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(DecodeErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	FreeMessageInfo
//
//--------------------------------------------------------------------------
void	WINAPI	FreeMessageInfo(CEP_MESSAGE_INFO		*pMsgInfo)
{
	if(pMsgInfo)
	{
		if(pMsgInfo->TransactionID.pbData)
			free(pMsgInfo->TransactionID.pbData);

		if(pMsgInfo->SenderNonce.pbData)
			free(pMsgInfo->SenderNonce.pbData);

		if(pMsgInfo->RecipientNonce.pbData)
			free(pMsgInfo->RecipientNonce.pbData);

		if(pMsgInfo->SerialNumber.pbData)
			free(pMsgInfo->SerialNumber.pbData);

		if(pMsgInfo->pSigningCert)
			CertFreeCertificateContext(pMsgInfo->pSigningCert);

		memset(pMsgInfo, 0, sizeof(CEP_MESSAGE_INFO));
	}
}


//--------------------------------------------------------------------------
//
//	AllocAndCopyBlob
//
//--------------------------------------------------------------------------
BOOL	WINAPI	AllocAndCopyBlob(CERT_BLOB	*pDestBlob,
							 CERT_BLOB	*pSrcBlob)
{
	memset(pDestBlob, 0, sizeof(CERT_BLOB));

	if(NULL==pSrcBlob->pbData)
	{
		SetLastError(E_INVALIDARG);
		return FALSE;
	}

	pDestBlob->pbData = (BYTE *)malloc(pSrcBlob->cbData);

	if(NULL==(pDestBlob->pbData))
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	pDestBlob->cbData=pSrcBlob->cbData;
	memcpy(pDestBlob->pbData, pSrcBlob->pbData, pDestBlob->cbData);

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	AllocAndCopyString
//
//--------------------------------------------------------------------------
BOOL WINAPI	AllocAndCopyString(CERT_BLOB	*pDestBlob,
							LPSTR		psz)
{
	if(!psz)
	{
		SetLastError(E_INVALIDARG);
		return FALSE;
	}

	pDestBlob->cbData=0;
	pDestBlob->pbData=NULL;


	pDestBlob->pbData=(BYTE*)malloc(strlen(psz) + 1);
	if(NULL == pDestBlob->pbData)
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	pDestBlob->cbData=strlen(psz);
	strcpy((LPSTR)pDestBlob->pbData, psz);

	return TRUE;
}




//--------------------------------------------------------------------------
//
//	GetTagValue
//
//--------------------------------------------------------------------------
LPSTR	GetTagValue(LPSTR szString, LPSTR szTag)
{

	LPSTR	pszValue=NULL;
	DWORD	cbString=0;
	DWORD	cbTag=0;

	cbString = strlen(szString);
	cbTag = strlen(szTag);

	for(pszValue=szString; cbString > cbTag; pszValue++, cbString--)
	{
		if((*pszValue) == (*szTag))		
		{
			if(0==_strnicmp(pszValue, szTag, cbTag))
			{
				//skip the tag
				pszValue += cbTag * sizeof(CHAR);
				return pszValue;
			}
		}

	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\mscep\private.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       private.h
//
//  Contents:   The private include file for cryptext.dll.
//
//  History:    May-13-1999	xiaohs	Created
//
//--------------------------------------------------------------
#ifndef CEP_PRIVATE_H
#define CEP_PRIVATE_H


#ifdef __cplusplus
extern "C" {
#endif


#define	GET_TAG_OP				"operation="
#define	GET_TAG_MSG				"&message="
#define	GET_OP_CA				"GetCACert"
#define	GET_OP_PKI				"PKIOperation"
#define	CONTENT_TYPE_CA_RA		"application/x-x509-ca-ra-cert"
#define	CONTENT_TYPE_PKI		"application/x-pki-message"
#define	CONTENT_TYPE_HTML		"text/html"

#define ACCESS_MESSAGE			"401 You do not have permission to enroll for an IPSEC intermediate offline certificate template for CEP"  

#define	OPERATION_GET_CACERT	1
#define	OPERATION_GET_PKI		2

#define	MESSAGE_TYPE_CERT_RESPONSE		3
#define	MESSAGE_TYPE_CERT_REQUEST		19
#define	MESSAGE_TYPE_GET_CERT_INITIAL	20
#define	MESSAGE_TYPE_GET_CERT			21
#define	MESSAGE_TYPE_GET_CRL			22


#define	MESSAGE_STATUS_SUCCESS			0
#define	MESSAGE_STATUS_FAILURE			2
#define	MESSAGE_STATUS_PENDING			3


#define	MESSAGE_FAILURE_BAD_ALG_ID			0
#define	MESSAGE_FAILURE_BAD_MESSAGE_CHECK	1
#define	MESSAGE_FAILURE_BAD_REQUEST			2
#define	MESSAGE_FAILURE_BAD_TIME			3
#define	MESSAGE_FAILURE_BAD_CERT_ID			4

#define	CEP_CONTEXT_CERT					1
#define	CEP_CONTEXT_CRL						2


//together we should have 6 attributes: TransactionID, MessageType, PkiStatus,
//ErrorInfo, senderNonce, and recipientNonce
#define	CEP_RESPONSE_AUTH_ATTR_COUNT		6
										
#define	szOIDVerisign_MessageType			"2.16.840.1.113733.1.9.2"
#define	szOIDVerisign_PkiStatus				"2.16.840.1.113733.1.9.3"
#define	szOIDVerisign_FailInfo				"2.16.840.1.113733.1.9.4"
#define	szOIDVerisign_SenderNonce			"2.16.840.1.113733.1.9.5"
#define	szOIDVerisign_RecipientNonce		"2.16.840.1.113733.1.9.6"
#define	szOIDVerisign_TransactionID			"2.16.840.1.113733.1.9.7"



#define	MAX_STRING_SIZE						512


#define	CEP_REQUEST_SIGNATURE				0x01
#define	CEP_REQUEST_EXCHANGE				0x02

//-----------------------------------------------------------------------
//	Externs
//
//------------------------------------------------------------------------
extern CRITICAL_SECTION			CriticalSec;
extern CRITICAL_SECTION			PasswordCriticalSec;

//need for the web page display
extern DWORD					g_dwPasswordValidity;

//needed for the pending retrieval table
extern DWORD					g_dwRequestDuration;


//**************************************************************************
//
//  The defines for the transactionID and requestID mapping table
//
struct _CEP_TIME_ENTRY;

//-----------------------------------------------------------------------
//  CEP_HASH_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_HASH_ENTRY
{
	LPSTR				pszTransactionID;
	DWORD				dwRequestID;
	BOOL				fFinished;
	_CEP_TIME_ENTRY		*pTimeEntry;
	_CEP_HASH_ENTRY		*pNext;
	_CEP_HASH_ENTRY		*pPrevious;
}CEP_HASH_ENTRY;


//-----------------------------------------------------------------------
//  CEP_TIME_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_TIME_ENTRY
{
	FILETIME			TimeStamp;
	CEP_HASH_ENTRY		*pHashEntry;
	_CEP_TIME_ENTRY		*pNext;
	_CEP_TIME_ENTRY		*pPrevious;
}CEP_TIME_ENTRY;


//-----------------------------------------------------------------------
//  CEP_HASH_TABLE_INFO
//
//------------------------------------------------------------------------
//we hash based on the 1st byte
#define		CEP_HASH_TABLE_SIZE			256
#define		CEP_REFRESH_DAY				7	
	
typedef struct _CEP_HASH_TABLE_INFO
{
	CEP_HASH_ENTRY	*rgHashEntry[CEP_HASH_TABLE_SIZE];	//the hash table
	CEP_TIME_ENTRY	*pTimeOld;							//the list of hash entry with its timestamp
	CEP_TIME_ENTRY	*pTimeNew;
}CEP_HASH_TABLE_INFO;




//**************************************************************************
//
//  The defines for the password hash table
//
//-----------------------------------------------------------------------
//  CEP_PASSWORD_TABLE
//
//------------------------------------------------------------------------
#define		CEP_PASSWORD_LENGTH				8
#define		CEP_MAX_PASSWORD				1000
#define		CEP_PASSWORD_VALIDITY			60				//in minutes

#define	    UPPER_BITS			            0xF0
#define	    LOWER_BITS			            0x0F


struct _CEP_PASSWORD_VALIDITY_ENTRY;

//-----------------------------------------------------------------------
//  CEP_PASSWORD_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_PASSWORD_ENTRY
{
	LPWSTR							pwszPassword;
	DWORD							dwUsageRequested;
	_CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry;
	_CEP_PASSWORD_ENTRY				*pNext;
	_CEP_PASSWORD_ENTRY				*pPrevious;
}CEP_PASSWORD_ENTRY;

//-----------------------------------------------------------------------
//  CEP_PASSWORD_VALIDITY_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_PASSWORD_VALIDITY_ENTRY
{
	FILETIME						TimeStamp;
	CEP_PASSWORD_ENTRY				*pPasswordEntry;
	_CEP_PASSWORD_VALIDITY_ENTRY	*pNext;
	_CEP_PASSWORD_VALIDITY_ENTRY	*pPrevious;
}CEP_PASSWORD_VALIDITY_ENTRY;   

//-----------------------------------------------------------------------
//  CEP_PASSWORD_TABLE_INFO
//
//------------------------------------------------------------------------
	
typedef struct _CEP_PASSWORD_TABLE_INFO
{
	CEP_PASSWORD_ENTRY				*rgPasswordEntry[CEP_HASH_TABLE_SIZE];	//the hash table
	CEP_PASSWORD_VALIDITY_ENTRY		*pTimeOld;								//the list of hash entry with its timestamp
	CEP_PASSWORD_VALIDITY_ENTRY		*pTimeNew;
}CEP_PASSWORD_TABLE_INFO;


//**************************************************************************
//
//  The defines for the request hash table
//

//**************************************************************************
#define		CEP_MD5_HASH_SIZE				16
#define		CEP_REQUEST_DURATION			20

struct _CEP_REQUEST_VALIDITY_ENTRY;

//-----------------------------------------------------------------------
//  CEP_REQUEST_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_REQUEST_ENTRY
{
	BYTE							pbHash[CEP_MD5_HASH_SIZE];
	DWORD							dwRequestID;
	_CEP_REQUEST_VALIDITY_ENTRY		*pValidityEntry;
	_CEP_REQUEST_ENTRY				*pNext;
	_CEP_REQUEST_ENTRY				*pPrevious;
}CEP_REQUEST_ENTRY;

//-----------------------------------------------------------------------
//  CEP_REQUEST_VALIDITY_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_REQUEST_VALIDITY_ENTRY
{
	FILETIME						TimeStamp;
	CEP_REQUEST_ENTRY				*pRequestEntry;
	_CEP_REQUEST_VALIDITY_ENTRY		*pNext;
	_CEP_REQUEST_VALIDITY_ENTRY		*pPrevious;
}CEP_REQUEST_VALIDITY_ENTRY;   



//-----------------------------------------------------------------------
//  CEP_REQUEST_TABLE_INFO
//
//------------------------------------------------------------------------
	
typedef struct _CEP_REQUEST_TABLE_INFO
{
	CEP_REQUEST_ENTRY				*rgRequestEntry[CEP_HASH_TABLE_SIZE];	//the hash table
	CEP_REQUEST_VALIDITY_ENTRY		*pTimeOld;									//the list of hash entry with its timestamp
	CEP_REQUEST_VALIDITY_ENTRY		*pTimeNew;
}CEP_REQUEST_TABLE_INFO;


//
//  The defines for CA and RA message
//

//-----------------------------------------------------------------------
//  CEP_CA_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_CA_INFO
{
	BSTR			bstrCAMachine;
	BSTR			bstrCAName;
	BSTR			bstrCAConfig;
	LPWSTR			pwszCAHash;
	HCRYPTPROV		hProv;
	BOOL			fEnterpriseCA;
	ICertRequest	*pICertRequest;
}CEP_CA_INFO;

//-----------------------------------------------------------------------
//  CEP_RA_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_RA_INFO
{
	HCRYPTPROV		hRAProv;
	DWORD			dwKeySpec;
	PCCERT_CONTEXT	pRACert;
	PCCERT_CONTEXT	pRASign;
	BOOL			fFree;
	HCRYPTPROV		hSignProv;
	DWORD			dwSignKeySpec;
	BOOL			fSignFree;
	DWORD			dwRefreshDays;
	BOOL			fPassword;
}CEP_RA_INFO;

//-----------------------------------------------------------------------
//  CEP_MESSAGE_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_MESSAGE_INFO
{
	CERT_BLOB			TransactionID;	 //internally a string
	DWORD				dwMessageType;
	DWORD				dwStatus;
	DWORD				dwErrorInfo;
	CERT_BLOB			SenderNonce;
	CERT_BLOB			RecipientNonce;
	CERT_BLOB			SerialNumber;
	PCCERT_CONTEXT		pSigningCert;
}CEP_MESSAGE_INFO;


//-----------------------------------------------------------------------
//
//  Function prototypes
//
//------------------------------------------------------------------------
BOOL	WINAPI	InitRequestTable();

BOOL	WINAPI  ReleaseRequestTable();

BOOL	WINAPI	CEPRequestRetrieveRequestIDFromHash(BYTE			*pbHash, 
													   DWORD	*pdwRequestID);

BOOL	WINAPI	CEPRequestAddHashAndRequestID(BYTE		*pbHash, 
												DWORD	dwRequestID);

BOOL	WINAPI	InitPasswordTable();

BOOL	WINAPI  ReleasePasswordTable();

BOOL	WINAPI	CEPAddPasswordToTable(LPWSTR	pwszPassword);

BOOL	WINAPI	CEPVerifyPasswordAndDeleteFromTable(LPWSTR	pwszPassword, DWORD dwUsage);

BOOL	InitHashTable();

BOOL	ReleaseHashTable();

BOOL	GetRAInfo(CEP_RA_INFO	*pRAInfo);

BOOL	GetCACertFromInfo(CEP_CA_INFO	*pCAInfo, HCERTSTORE *pHCACertStore);

BOOL	InitCAInformation(CEP_CA_INFO	*pCAInfo);

BOOL	FreeCAInformation(CEP_CA_INFO	*pCAInfo);

BOOL	FreeRAInformation(CEP_RA_INFO	*pRAInfo);

LPSTR	GetTagValue(LPSTR szString, LPSTR szTag);

BOOL	OperationGetCACert(HCERTSTORE		hCACertStore,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData);

BOOL	OperationGetPKI(	CEP_RA_INFO		*pRAInfo,
							CEP_CA_INFO		*pCAInfo,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData);

BOOL	WINAPI GetSerialNumberFromBlob(BYTE *pbEncoded, 
										DWORD cbEncoded, 
										CRYPT_INTEGER_BLOB *pSerialNumber);

BOOL	GetReturnInfoAndContent(CEP_RA_INFO		*pRAInfo,	
							CEP_CA_INFO			*pCAInfo,
							LPSTR				szMsg, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL WINAPI DecryptMsg(CEP_RA_INFO		*pRAInfo, 
					   BYTE				*pbReqEnv, 
					   DWORD			cbReqEnv, 
					   BYTE				**ppbReqDecrypt, 
					   DWORD			*pcbReqDecrypt);



BOOL	WINAPI	GetContentFromPKCS7(BYTE				*pbMessage,
									DWORD				cbMessage,
									BYTE				**ppbContent,
									DWORD				*pbContent,
									CEP_MESSAGE_INFO	*pMsgInfo);

void	WINAPI	FreeMessageInfo(CEP_MESSAGE_INFO		*pMsgInfo);


BOOL	WINAPI	AllocAndCopyBlob(CERT_BLOB	*pDestBlob,
							 CERT_BLOB	*pSrcBlob);


BOOL	WINAPI	CEPAllocAndDecode(	LPCSTR	lpszStructType,
									BYTE	*pbEncoded,
									DWORD	cbEncoded,
									void	**ppb,
									DWORD	*pcb); 

BOOL WINAPI	CEPRetrievePasswordFromRequest(BYTE		*pbRequest, 
										   DWORD	cbRequest, 
										   LPWSTR	*ppwszPassword,
										   DWORD	*pdwUsage);

BOOL WINAPI AltNameExist(BYTE *pbRequest, DWORD cbRequest);

BOOL WINAPI SameCert(CERT_INFO *pCertInfoOne, CERT_INFO *pCertInfoTwo);

BOOL WINAPI SameBlob(CRYPT_INTEGER_BLOB *pBlobOne, CRYPT_INTEGER_BLOB *pBlobTwo);

BOOL EnvelopData(PCCERT_CONTEXT	pSigningCert, 
				 BYTE			*pbContent, 
				 DWORD			cbContent,
				 BYTE			**ppbEnvelop, 
				 DWORD			*pcbEnvelop);

BOOL CEPHashGetRequestID(	DWORD		dwRefreshDays,
				CERT_BLOB *pTrasactionID, 
				  DWORD		*pdwRequestID);

BOOL CEPHashMarkTransactionFinished(DWORD	dwRequestID, CERT_BLOB *pTransactionID);

BOOL CEPHashAddRequestAndTransaction(DWORD dwRefreshDays, 
									 DWORD	dwRequestID, 
									 CERT_BLOB *pTransactionID);

BOOL CEPHashIsCurrentTimeEntry(FILETIME *pTimeStamp, DWORD dwRefreshDays, DWORD dwMinutes);


BOOL WINAPI ProcessGetCRL(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL WINAPI ProcessGetCert(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL	ProcessCertInitial(	DWORD				dwRefreshDays,
						    CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL	ProcessCertRequest(	DWORD				dwRefreshDays,
						    BOOL				fPassword,
						    PCCERT_CONTEXT		pRAEncrypt,
						    PCCERT_CONTEXT		pRACert,
							CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);



BOOL PackageBlobToPKCS7(DWORD	dwCEP_Context,
						BYTE	*pbEncoded, 
						DWORD	cbEncoded, 
						BYTE	**ppbData, 
						DWORD	*pcbData);


BOOL GenerateSenderNonce(CRYPT_INTEGER_BLOB *pBlob);

BOOL SignData(CEP_MESSAGE_INFO		*pMsgInfo, 
			  CEP_RA_INFO			*pRAInfo, 
			  BYTE					*pbEnvelop, 
			  DWORD					cbEnvelop, 
			  BYTE					**ppbData, 
			  DWORD					*pcbData);

BOOL	CEPAllocAndEncodeName(DWORD	dwValueType,
							BYTE	*pbData,
							DWORD	cbData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded);


BOOL	CEPAllocAndEncodeDword(DWORD	dwValueType,
							DWORD	dwData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded);


BOOL WINAPI CEPAllocAndEncode(LPCSTR lpszStructType,
							void	*pStructInfo,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded);


BOOL WINAPI AddAltNameInRequest(PCCERT_CONTEXT	pRACert, 
								BYTE			*pb10, 
								DWORD			cb10, 
								LPWSTR			pwszDNS,
								CRYPT_DATA_BLOB	*pIPAddress,
								BYTE			**ppb7, 
								DWORD			*pcb7);

BOOL WINAPI CreateAltNameExtenions(LPWSTR		pwszDNS,
							   CRYPT_DATA_BLOB	*pIPAddress,
							   BYTE				**pbExt, 
							   DWORD			*pcbExt);

BOOL WINAPI	GetAltNameElement(BYTE				*pb10, 
						   DWORD				cb10, 
						   LPWSTR				*ppwszDNS, 
						   CRYPT_DATA_BLOB		*pIPAddress);

BOOL ConvertIPStringToBinary(LPWSTR				pwszIP,
							CRYPT_DATA_BLOB		*pIPAddress);

BOOL WINAPI	AllocAndCopyString(CERT_BLOB	*pDestBlob,
							LPSTR		psz);

BOOL WINAPI RetrieveContextFromSerialNumber(CEP_CA_INFO	*pCAInfo, 
										CERT_BLOB		*pSerialNumber, 
										PCCERT_CONTEXT	*ppCertContext);

BOOL WINAPI GetConfigInfo(DWORD *pdwRefreshDays, BOOL *pfPassword);

BOOL CEPGetTokenFromPKCS10(BOOL					fPassword,
						   PCCERT_CONTEXT		pRAEncrypt,
						   BYTE					*pbRequest, 
						   DWORD				cbRequest, 
						   HANDLE				*phToken);

BOOL GetLogonInfoFromValue(PCCERT_CONTEXT		pRAEncrypt,
						   LPWSTR				pwszString,
						   LPWSTR				*ppwszDomain,
						   LPWSTR				*ppwszUser,
						   LPWSTR				*ppwszPassword);

BOOL CEPDecryptPassword(PCCERT_CONTEXT		pRAEncrypt,
						LPWSTR				pwszEncrypt,
						LPWSTR				*ppwszDecrypt);


BOOL WINAPI IsAnonymousAccess(EXTENSION_CONTROL_BLOCK	*pECB);

BOOL WINAPI CheckACLOnCertTemplate(CEP_CA_INFO			*g_CAInfo);

BOOL WINAPI OperationDisplayAccessHTML(BYTE **ppbData, DWORD *pcbData);

BOOL WINAPI OperationGetDisplayInfoForCEP(LPWSTR		pwszCAHash, 
										  HCRYPTPROV	hProv,
										  BOOL			fPassword, 
										  BYTE			**ppbData, 
										  DWORD			*pcbData);
BOOL WINAPI LoadIDToTemplate(UINT				idsMsg, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData);

BOOL WINAPI LoadWZToTemplate(LPWSTR				pwsz, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData);


BOOL WINAPI	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...);

BOOL WINAPI CopyWZToBuffer(	LPWSTR				pwszData, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData);

BOOL WINAPI LoadIDAndHRToTempalte(UINT			idsMsg, 
								  HRESULT		hr, 
								  BYTE			**ppbData, 
								  DWORD			*pcbData);

BOOL WINAPI	ConvertByteToWstr(BYTE			*pbData, 
							  DWORD			cbData, 
							  LPWSTR		*ppwsz, 
							  BOOL			fSpace);

BOOL	WINAPI	CEPGetCertFromPKCS10(CEP_CA_INFO	*pCAInfo,
							 BYTE				*pbRequest, 
							 DWORD				cbRequest, 
							 BYTE				**ppbData, 
							 DWORD				*pcbData,							 	
							 CEP_MESSAGE_INFO	*pMsgInfo);



#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //CEP_PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\setup\errorhandling.h ===
//--------------------------------------------------------------------
// ErrorHandling - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Macro definitions for CertSrv style error handling
//

#ifndef ERROR_HANDLING_H
#define ERROR_HANDLING_H


#define _Verify(expression, hr, label) \
    if (!(expression)) { \
        wprintf(L"Verify failed: '%s' is false.\n", L## #expression); \
        hr=E_UNEXPECTED; \
        goto label; \
    }

#define _IgnoreError(hr, errorsource) \
    wprintf(L##errorsource L" failed with 0x%08X, ignored.\n", hr);

#define _JumpError(hr, label, errorsource) \
    wprintf(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpErrorStr(hr, label, errorsource, wstr) \
    wprintf(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpIfError(hr, label, errorsource) \
    if (FAILED(hr)) { \
        wprintf(L##errorsource L" failed with 0x%08X.\n", hr); \
        goto label; \
    }

#define _JumpIfErrorStr(hr, label, errorsource, wstr) \
    if (FAILED(hr)) { \
        wprintf(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
        goto label; \
    }

#define _JumpIfOutOfMemory(hr, label, pointer) \
    if (NULL==(pointer)) { \
        hr=E_OUTOFMEMORY; \
        wprintf(L"Out of memory.\n"); \
        goto label; \
    }

#define _TrapException(hr) \
    __except(hr=myHExceptionCode(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER) {}

#define _TeardownError(hr, hr2, errorsource) \
    if (FAILED(hr2)) { \
        wprintf(L##errorsource L" failed with 0x%08X during teardown.\n", hr2); \
        if (!FAILED(hr)) { \
            hr=hr2; \
        } \
    }


#endif ERROR_HANDLING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\setup\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


//icon
#define IDI_MAINFRAME                   200			


//bitmap
#define IDB_WIN2K                       300

//dialogue
#define IDD_WELCOME						120
#define IDD_CHALLENGE					121
#define IDD_ENROLL						122
#define IDD_CSP							123
#define IDD_COMPLETION					124
#define IDD_ABOUT						125
#define IDD_COPYING						126


//control
#define	IDC_BIG_BOLD_TITLE				1003
#define	IDC_BOLD_TITLE					1004
#define	IDC_CHALLENGE_CHECK				1005
#define	IDC_COMPLETION_LIST				1006
#define IDC_ENROLL_NAME                 1007
#define IDC_ENROLL_EMAIL                1008
#define IDC_ENROLL_COMPANY              1009
#define IDC_ENROLL_DEPARTMENT           1010
#define IDC_ENROLL_CITY                 1011
#define IDC_ENROLL_STATE                1012
#define IDC_ENROLL_COUNTRY              1013
#define	IDC_ENORLL_ADV_CHECK			1014
#define	IDC_CSP_SIGN_LIST				1015
#define	IDC_CSP_ENCRYPT_LIST			1016
#define	IDC_CSP_SIGN_COMBO				1017
#define	IDC_CSP_ENCRYPT_COMBO			1018


#define IDC_WIZARD_STATIC               -1

//string
#define IDS_MEG_CAPTION					3000
#define	IDS_NO_NT5						3001
#define	IDS_NO_IIS						3002
#define	IDS_NO_GOOD_CA					3003
#define	IDS_NO_CA_RUNNING				3004
#define	IDS_CEP_ERROR_MSG_HR			3005	
#define	IDS_CEP_ERROR_MSG				3006
#define	IDS_WIZARD_CAPTION				3007
#define	IDS_FAIL_INIT_WIZARD			3008
#define	IDS_FAIL_DELETE_RA				3009
#define	IDS_ENROLL_REQUIRE_NAME			3010
#define	IDS_CHALLENGE_PHRASE			3011
#define	IDS_YES							3012
#define	IDS_NO							3013
#define	IDS_RA_CREDENTIAL				3014
#define	IDS_FAIL_UPDATE_REGISTRY		3015
#define	IDS_FAIL_ADD_VROOT				3016
#define	IDS_FAIL_START_IIS				3017
#define	IDS_FAIL_UPDATE_CERTSVC			3018
#define	IDS_FAIL_START_CERTSVC			3019
#define	IDS_FAIL_ENROLL_RA_CERT			3020
#define	IDS_NO_MEMORY					3021
#define	IDS_EXISTING_RA					3022
#define	IDS_PROCESS_PENDING				3023
#define	IDS_CEP_SUCCESS_INFO			3024
#define	IDS_FAIL_GET_COMPUTER_NAME		3025
#define	IDS_ENROLL_COUNTRY_TOO_LARGE	3026
#define	IDS_FAIL_GET_CSP_INFO			3027
#define	IDS_SIGN_CSP					3028			
#define	IDS_SIGN_KEY_LENGTH				3029
#define	IDS_ENCRYPT_CSP					3030
#define	IDS_ENCRYPT_KEY_LENGTH			3031
#define	IDS_SELECT_SIGN_CSP				3032
#define	IDS_SELECT_ENCRYPT_CSP			3033
#define	IDS_SELECT_SIGN_KEY_LENGTH		3034
#define	IDS_SELECT_ENCRYPT_KEY_LENGTH	3035	
#define	IDS_FAIL_GET_CA_TYPE			3036	
#define	IDS_NOT_ENT_ADMIN				3037
#define	IDS_NOT_MACHINE_ADMIN			3038
#define	IDS_FAIL_ADD_TEMPLATE			3039
#define	IDS_CAN_NOT_START_CA			3040
#define	IDS_CAN_NOT_ROOT_CA				3041
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\setup\cepsetup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cepsetup.cpp
//
//  Contents:   The setup code for MSCEP
//--------------------------------------------------------------------------

#include	"global.hxx"
#include	<dbgdef.h>		
#include	"setuputil.h"
#include	"cepsetup.h"
#include	"resource.h"

//-----------------------------------------------------------------------
//
// Global data
//
//-----------------------------------------------------------------------

HMODULE				g_hModule=NULL;

//-----------------------------------------------------------------------
//CN has to be the 1st item and O the third in the following list and C is the last item.  No other requirements for 
//the order
//-----------------------------------------------------------------------

CEP_ENROLL_INFO		g_rgRAEnrollInfo[RA_INFO_COUNT]=        
		{L"CN=",         	 IDC_ENROLL_NAME,        
         L"E=",           	 IDC_ENROLL_EMAIL,       
         L"O=",				 IDC_ENROLL_COMPANY,     
         L"OU=",			 IDC_ENROLL_DEPARTMENT,  
         L"L=",           	 IDC_ENROLL_CITY,        
		 L"S=",				 IDC_ENROLL_STATE,       
		 L"C=",				 IDC_ENROLL_COUNTRY,     
		};
	

//-----------------------------------------------------------------------
//the key length table
//-----------------------------------------------------------------------
DWORD g_rgdwKeyLength[] =
{
    512,
    1024,
    2048,
    4096,
};

DWORD g_dwKeyLengthCount=sizeof(g_rgdwKeyLength)/sizeof(g_rgdwKeyLength[0]);

DWORD g_rgdwSmallKeyLength[] =
{
    128,
    256,
    512,
    1024,
};

DWORD g_dwSmallKeyLengthCount=sizeof(g_rgdwSmallKeyLength)/sizeof(g_rgdwSmallKeyLength[0]);

//the list of possible default key lenght in the order of preference
DWORD g_rgdwDefaultKey[] =
{
    1024,
    2048,
	512,
	256,
    4096,
	128
};

DWORD g_dwDefaultKeyCount=sizeof(g_rgdwDefaultKey)/sizeof(g_rgdwDefaultKey[0]);

//-----------------------------------------------------------------------
//
//The winProc for each of the setup wizard page
//
//-----------------------------------------------------------------------


//-----------------------------------------------------------------------
//Welcome
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Welcome(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO			*pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);
				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBigBold, hwndDlg,IDC_BIG_BOLD_TITLE);
			break;

		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//Chanllenge
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Challenge(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);

				//by default, we do use Challenge password
				SendMessage(GetDlgItem(hwndDlg, IDC_CHALLENGE_CHECK), BM_SETCHECK, BST_CHECKED, 0);  
			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //check for the Challenge password options
                            if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHALLENGE_CHECK, BM_GETCHECK, 0, 0))
                                pCEPWizardInfo->fPassword=TRUE;
                            else
                                pCEPWizardInfo->fPassword=FALSE;

							if(!EmptyCEPStore())
							{
								CEPMessageBox(hwndDlg, IDS_EXISTING_RA, MB_ICONINFORMATION|MB_OK|MB_APPLMODAL);

								if(IDNO==CEPMessageBox(hwndDlg, IDS_PROCESS_PENDING, MB_ICONQUESTION|MB_YESNO|MB_APPLMODAL))
								{
									SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
									break;
								}
							}
							

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Enroll
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Enroll(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;

	DWORD					dwIndex=0;
	DWORD					dwChar=0;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);
			   
				//by default, we do not use the advanced enrollment options
				SendMessage(GetDlgItem(hwndDlg, IDC_ENORLL_ADV_CHECK), BM_SETCHECK, BST_UNCHECKED, 0);  
				
				//preset the country string since we only allow 2 characters
                SetDlgItemTextU(hwndDlg, IDC_ENROLL_COUNTRY, L"US");

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //if the adv selection is made, it has to stay selected
                            if(pCEPWizardInfo->fEnrollAdv)
                                EnableWindow(GetDlgItem(hwndDlg, IDC_ENORLL_ADV_CHECK), FALSE);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

							//gather RA subject informaton
							for(dwIndex=0; dwIndex < RA_INFO_COUNT; dwIndex++)
							{
								if(pCEPWizardInfo->rgpwszName[dwIndex])
								{
									free(pCEPWizardInfo->rgpwszName[dwIndex]);
									pCEPWizardInfo->rgpwszName[dwIndex]=NULL;

								}

								if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
													   g_rgRAEnrollInfo[dwIndex].dwIDC,
													   WM_GETTEXTLENGTH, 0, 0)))
								{
									pCEPWizardInfo->rgpwszName[dwIndex]=(LPWSTR)malloc(sizeof(WCHAR)*(dwChar+1));

									if(NULL!=(pCEPWizardInfo->rgpwszName[dwIndex]))
									{
										GetDlgItemTextU(hwndDlg, g_rgRAEnrollInfo[dwIndex].dwIDC,
														pCEPWizardInfo->rgpwszName[dwIndex],
														dwChar+1);

									}
								}
							}
							
							//we require name and company
							if((NULL==(pCEPWizardInfo->rgpwszName[0])) ||
							   (NULL==(pCEPWizardInfo->rgpwszName[2]))
							  )
							{
								CEPMessageBox(hwndDlg, IDS_ENROLL_REQUIRE_NAME, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}


							//we only allow 2 characeters for the country
							if(NULL	!=(pCEPWizardInfo->rgpwszName[RA_INFO_COUNT -1]))
							{
								if(2 < wcslen(pCEPWizardInfo->rgpwszName[RA_INFO_COUNT -1]))
								{
									CEPMessageBox(hwndDlg, IDS_ENROLL_COUNTRY_TOO_LARGE, MB_ICONERROR|MB_OK|MB_APPLMODAL);
									SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
									break;
								}
							}

                            //check for the advanced options
                            if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_ENORLL_ADV_CHECK, BM_GETCHECK, 0, 0))
                                pCEPWizardInfo->fEnrollAdv=TRUE;
                            else
                                pCEPWizardInfo->fEnrollAdv=FALSE;


							//If the advanced is selected, skip the CSP Page
                            if(FALSE== pCEPWizardInfo->fEnrollAdv)
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_COMPLETION);
							
                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
// CSP
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_CSP(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
	NM_LISTVIEW FAR *       pnmv=NULL;	  
	BOOL					fSign=FALSE;
	int						idCombo=0;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);

				//populate the CSP list and key length combo box
				InitCSPList(hwndDlg, IDC_CSP_SIGN_LIST, TRUE,
							pCEPWizardInfo);

				InitCSPList(hwndDlg, IDC_CSP_ENCRYPT_LIST, FALSE,
							pCEPWizardInfo);

				RefreshKeyLengthCombo(hwndDlg, 
								  IDC_CSP_SIGN_LIST,
								  IDC_CSP_SIGN_COMBO, 
								  TRUE,
								  pCEPWizardInfo);

				RefreshKeyLengthCombo(hwndDlg, 
								  IDC_CSP_ENCRYPT_LIST,
								  IDC_CSP_ENCRYPT_COMBO, 
								  FALSE,
								  pCEPWizardInfo);

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

                    case LVN_ITEMCHANGED:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            pnmv = (LPNMLISTVIEW) lParam;

                            if(NULL==pnmv)
                                break;

                            if (pnmv->uNewState & LVIS_SELECTED)
                            {

								if(IDC_CSP_SIGN_LIST == (pnmv->hdr).idFrom)
								{
									fSign=TRUE;
									idCombo=IDC_CSP_SIGN_COMBO;
								}
								else
								{
									if(IDC_CSP_ENCRYPT_LIST != (pnmv->hdr).idFrom)
										break;

									fSign=FALSE;
									idCombo=IDC_CSP_ENCRYPT_COMBO;
								}

								RefreshKeyLengthCombo(
								   hwndDlg, 
								   (pnmv->hdr).idFrom,
								   idCombo, 
								   fSign,
								   pCEPWizardInfo);
							}

							break;

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

							//get the select CSP and key length
							if(!GetSelectedCSP(hwndDlg,
									IDC_CSP_SIGN_LIST,
									&(pCEPWizardInfo->dwSignProvIndex)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_SIGN_CSP, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

							if(!GetSelectedCSP(hwndDlg,
									IDC_CSP_ENCRYPT_LIST,
									&(pCEPWizardInfo->dwEncryptProvIndex)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_ENCRYPT_CSP, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

							if(!GetSelectedKeyLength(hwndDlg,
									IDC_CSP_SIGN_COMBO,
									&(pCEPWizardInfo->dwSignKeyLength)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_SIGN_KEY_LENGTH, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

							if(!GetSelectedKeyLength(hwndDlg,
									IDC_CSP_ENCRYPT_COMBO,
									&(pCEPWizardInfo->dwEncryptKeyLength)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_ENCRYPT_KEY_LENGTH, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//Completion
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Completion(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO			*pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    LV_COLUMNW              lvC;
    HCURSOR                 hPreCursor=NULL;
    HCURSOR                 hWinPreCursor=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);
            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCEPWizardInfo)
                break;
                
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

            SetControlFont(pCEPWizardInfo->hBigBold, hwndDlg,IDC_BIG_BOLD_TITLE);

            //insert two columns
            hwndControl=GetDlgItem(hwndDlg, IDC_COMPLETION_LIST);

            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;		// Left-align the column.
            lvC.cx = 20;				// Width of the column, in pixels.
            lvC.pszText = L"";			// The text for the column.
            lvC.iSubItem=0;

            if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                break;

            //2nd column is the content
            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;		// Left-align the column.
            lvC.cx = 10;				//(dwMaxSize+2)*7;          // Width of the column, in pixels.
            lvC.pszText = L"";			// The text for the column.
            lvC.iSubItem= 1;

            if (ListView_InsertColumnU(hwndControl, 1, &lvC) == -1)
                break;


           break;
		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK|PSWIZB_FINISH);

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(hwndControl=GetDlgItem(hwndDlg, IDC_COMPLETION_LIST))
                                DisplayConfirmation(hwndControl, pCEPWizardInfo);
					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

							//skip CSP page if adv is not selected
							if(FALSE == pCEPWizardInfo->fEnrollAdv)
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_ENROLL);

                        break;

                    case PSN_WIZFINISH:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //overwrite the cursor for this window class
                            hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
                            hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

							//do the real setup work
							I_DoSetupWork(hwndDlg, pCEPWizardInfo);

                            //set the cursor back
                            SetCursor(hPreCursor);
                            SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:

			    return FALSE;
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	  Helper Functions for the wizard pages
//
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//	 RefreshKeyLengthCombo
//
//--------------------------------------------------------------------------
BOOL	WINAPI	RefreshKeyLengthCombo(HWND				hwndDlg, 
								   int					idsList,
								   int					idsCombo, 
								   BOOL					fSign,
								   CEP_WIZARD_INFO		*pCEPWizardInfo)
{
	BOOL			fResult=FALSE;
	DWORD			dwDefaultKeyLength=0;
	DWORD			*pdwList=NULL;
	DWORD			dwListCount=0;
	DWORD			dwMax=0;
	DWORD			dwMin=0;
	DWORD			dwIndex=0;
	DWORD			dwCSPIndex=0;
	CEP_CSP_INFO	*pCSPInfo=NULL;
	int				iInsertedIndex=0;
	WCHAR			wszKeyLength[CEP_KEY_LENGTH_STRING];
	BOOL			fSelected=FALSE;

	//get the selected list view item 
	if(!GetSelectedCSP(hwndDlg,idsList,&dwCSPIndex))
		goto CLEANUP;

	pCSPInfo= &(pCEPWizardInfo->rgCSPInfo[dwCSPIndex]);

	if(fSign)
	{
		dwDefaultKeyLength=pCSPInfo->dwDefaultSign;
		pdwList=pCSPInfo->pdwSignList;
		dwListCount=	pCSPInfo->dwSignCount;
		dwMax=pCSPInfo->dwMaxSign;
		dwMin=pCSPInfo->dwMinSign;
	}
	else
	{
		dwDefaultKeyLength=pCSPInfo->dwDefaultEncrypt;
		pdwList=pCSPInfo->pdwEncryptList;
		dwListCount=pCSPInfo->dwEncryptCount;
		dwMax=pCSPInfo->dwMaxEncrypt;
		dwMin=pCSPInfo->dwMinEncrypt;
	}

	//clear out the combo box
	SendDlgItemMessageU(hwndDlg, idsCombo, CB_RESETCONTENT, 0, 0);	


	for(dwIndex=0; dwIndex < dwListCount; dwIndex++)
	{
		if((pdwList[dwIndex] >= dwMin) && (pdwList[dwIndex] <= dwMax))
		{
			_ltow(pdwList[dwIndex], wszKeyLength, 10);

			iInsertedIndex=SendDlgItemMessageU(hwndDlg, idsCombo, CB_ADDSTRING,
				0, (LPARAM)wszKeyLength);

			if((iInsertedIndex != CB_ERR) && (iInsertedIndex != CB_ERRSPACE))
			{
				SendDlgItemMessage(hwndDlg, idsCombo, CB_SETITEMDATA, 
									(WPARAM)iInsertedIndex, (LPARAM)pdwList[dwIndex]);
				
				if(dwDefaultKeyLength==pdwList[dwIndex])
				{
					SendDlgItemMessageU(hwndDlg, idsCombo, CB_SETCURSEL, iInsertedIndex, 0);
					fSelected=TRUE;
				}
			}
		}

	}

	if(fSelected==FALSE)
		SendDlgItemMessageU(hwndDlg, idsCombo, CB_SETCURSEL, 0, 0);

	fResult=TRUE;

CLEANUP:

	return fResult;
}


//--------------------------------------------------------------------------
//
//	 InitCSPList
//
//--------------------------------------------------------------------------
BOOL	WINAPI	InitCSPList(HWND				hwndDlg,
							int					idControl,
							BOOL				fSign,
							CEP_WIZARD_INFO		*pCEPWizardInfo)
{
	BOOL				fResult=FALSE;
	DWORD				dwIndex=0;
	CEP_CSP_INFO		*pCSPInfo=NULL;
	int					iInsertedIndex=0;
	HWND				hwndList=NULL;
    LV_ITEMW			lvItem;
    LV_COLUMNW          lvC;
	BOOL				fSelected=FALSE;

    if(NULL==(hwndList=GetDlgItem(hwndDlg, idControl)))
        goto CLEANUP;

    //insert a column into the list view
    memset(&lvC, 0, sizeof(LV_COLUMNW));

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.cx = 20; //(dwMaxSize+2)*7;            // Width of the column, in pixels.
    lvC.pszText = L"";   // The text for the column.
    lvC.iSubItem=0;

    if (-1 == ListView_InsertColumnU(hwndList, 0, &lvC))
		goto CLEANUP;

     // set up the fields in the list view item struct that don't change from item to item
	memset(&lvItem, 0, sizeof(LV_ITEMW));
    lvItem.mask = LVIF_TEXT | LVIF_STATE |LVIF_PARAM ;

	for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
	{
		fSelected=FALSE;

		pCSPInfo= &(pCEPWizardInfo->rgCSPInfo[dwIndex]);

		if(fSign)
		{
			if(!(pCSPInfo->fSignature))
				continue;

			if(dwIndex==pCEPWizardInfo->dwSignProvIndex)
				fSelected=TRUE;
		}
		else
		{
			if(!(pCSPInfo->fEncryption))
				continue;

			if(dwIndex==pCEPWizardInfo->dwEncryptProvIndex)
				fSelected=TRUE;
		}
	
		lvItem.iItem=dwIndex;
		lvItem.lParam = (LPARAM)dwIndex;
		lvItem.pszText=pCSPInfo->pwszCSPName;

        iInsertedIndex=ListView_InsertItemU(hwndList, &lvItem);

		if(fSelected)
		{
            ListView_SetItemState(
                            hwndList,
                            iInsertedIndex,
                            LVIS_SELECTED,
                            LVIS_SELECTED);
		}

	}  

    //make the column autosize
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

	fResult=TRUE;

CLEANUP:

	return fResult;
}


//--------------------------------------------------------------------------
//
//	 GetSelectedCSP
//
//--------------------------------------------------------------------------
BOOL WINAPI	GetSelectedCSP(HWND			hwndDlg,
					int				idControl,
					DWORD			*pdwCSPIndex)
{
	BOOL				fResult=FALSE;
	HWND				hwndControl=NULL;
    LV_ITEM				lvItem;
	int					iIndex=0;

    //get the window handle of the list view
    if(NULL==(hwndControl=GetDlgItem(hwndDlg, idControl)))
        goto CLEANUP;

     //now, mark the one that is selected
	if(-1 == (iIndex= ListView_GetNextItem(
            hwndControl, 		
            -1, 		
            LVNI_SELECTED		
        )))	
		goto CLEANUP;


	memset(&lvItem, 0, sizeof(LV_ITEM));
    lvItem.mask=LVIF_PARAM;
    lvItem.iItem=iIndex;

    if(!ListView_GetItem(hwndControl, &lvItem))
		goto CLEANUP;

	*pdwCSPIndex=lvItem.lParam;
	
	fResult=TRUE;

CLEANUP:

	return fResult;

}
//--------------------------------------------------------------------------
//
//	 GetSelectedKeyLength
//
//--------------------------------------------------------------------------
BOOL  WINAPI GetSelectedKeyLength(HWND			hwndDlg,
								int			idControl,
								DWORD			*pdwKeyLength)
{

	int				iIndex=0; 
	BOOL			fResult=FALSE;

    iIndex=(int)SendDlgItemMessage(hwndDlg, idControl, CB_GETCURSEL, 0, 0);

	if(CB_ERR==iIndex)
		goto CLEANUP;

	*pdwKeyLength=SendDlgItemMessage(hwndDlg, idControl, CB_GETITEMDATA, iIndex, 0);
    
	fResult=TRUE;

CLEANUP:

	return fResult;

}

//--------------------------------------------------------------------------
//
//	  FormatMessageStr
//
//--------------------------------------------------------------------------
int ListView_InsertItemU_IDS(HWND       hwndList,
                         LV_ITEMW       *plvItem,
                         UINT           idsString,
                         LPWSTR         pwszText)
{
    WCHAR   wszText[MAX_STRING_SIZE];


    if(pwszText)
        plvItem->pszText=pwszText;
    else
    {
        if(!LoadStringU(g_hModule, idsString, wszText, MAX_STRING_SIZE))
		    return -1;

        plvItem->pszText=wszText;
    }

    return ListView_InsertItemU(hwndList, plvItem);
}

//-------------------------------------------------------------------------
//
//	populate the wizards's confirmation page in the order of Challenge,
//	RA informaton, and CSPs
//
//-------------------------------------------------------------------------
void    WINAPI	DisplayConfirmation(HWND                hwndControl,
									CEP_WIZARD_INFO		*pCEPWizardInfo)
{
    WCHAR				wszYes[MAX_TITLE_LENGTH];
    DWORD				dwIndex=0;
    UINT				ids=0;
	BOOL				fNewItem=FALSE;
	WCHAR				wszLength[CEP_KEY_LENGTH_STRING];

    LV_COLUMNW			lvC;
    LV_ITEMW			lvItem;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //insert row by row
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;

    //*******************************************************************
	//challenge
    lvItem.iItem=0;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CHALLENGE_PHRASE, NULL);

    //content
    (lvItem.iSubItem)++;

	if(pCEPWizardInfo->fPassword) 
		ids=IDS_YES;
	else
		ids=IDS_NO;

    if(LoadStringU(g_hModule, ids, wszYes, MAX_TITLE_LENGTH))
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszYes);

	//***************************************************************************
	// RA credentials

    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_RA_CREDENTIAL, NULL);

	//content
	for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
	{
		if(pCEPWizardInfo->rgpwszName[dwIndex])
		{
            if(TRUE==fNewItem)
            {
                //increase the row
                lvItem.iItem++;
                lvItem.pszText=L"";
                lvItem.iSubItem=0;

                ListView_InsertItemU(hwndControl, &lvItem);
            }
            else
                fNewItem=TRUE;

			lvItem.iSubItem++;
			ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, pCEPWizardInfo->rgpwszName[dwIndex]);
		}
	}

	//***************************************************************************
	//CSPInfo
	if(pCEPWizardInfo->fEnrollAdv)
	{
		//signature CSP Name
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CSP, NULL);

		lvItem.iSubItem++;

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
				pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwSignProvIndex].pwszCSPName);


		//signaure key length
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_KEY_LENGTH, NULL);

		lvItem.iSubItem++;

		_ltow(pCEPWizardInfo->dwSignKeyLength, wszLength, 10);

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszLength);

		//encryption CSP name
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_ENCRYPT_CSP, NULL);

		lvItem.iSubItem++;

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
				pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwEncryptProvIndex].pwszCSPName);

		//encryption key length
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_ENCRYPT_KEY_LENGTH, NULL);

		lvItem.iSubItem++;

		_ltow(pCEPWizardInfo->dwEncryptKeyLength, wszLength, 10);

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszLength);
	}

    //autosize the columns
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndControl, 1, LVSCW_AUTOSIZE);


    return;
}

//--------------------------------------------------------------------
//
//	Main Function
//
//--------------------------------------------------------------------------
extern "C" int _cdecl wmain(int nArgs, WCHAR ** rgwszArgs) 
{
	BOOL					fResult=FALSE;
	UINT					idsMsg=IDS_FAIL_INIT_WIZARD;		
	HRESULT					hr=E_FAIL;
    PROPSHEETPAGEW          rgCEPSheet[CEP_PROP_SHEET];
    PROPSHEETHEADERW        cepHeader;
    CEP_PAGE_INFO			rgCEPPageInfo[CEP_PROP_SHEET]=
        {(LPCWSTR)MAKEINTRESOURCE(IDD_WELCOME),                 CEP_Welcome,
         (LPCWSTR)MAKEINTRESOURCE(IDD_CHALLENGE),               CEP_Challenge,
         (LPCWSTR)MAKEINTRESOURCE(IDD_ENROLL),					CEP_Enroll,
         (LPCWSTR)MAKEINTRESOURCE(IDD_CSP),						CEP_CSP,
         (LPCWSTR)MAKEINTRESOURCE(IDD_COMPLETION),              CEP_Completion,
		};
	DWORD					dwIndex=0;
    WCHAR                   wszTitle[MAX_TITLE_LENGTH];	  
	INT_PTR					iReturn=-1;
    ENUM_CATYPES			catype;
	DWORD					dwWaitCounter=0;
	BOOL					fEnterpriseCA=FALSE;


	CEP_WIZARD_INFO			CEPWizardInfo;

    memset(rgCEPSheet,		0,	sizeof(PROPSHEETPAGEW)*CEP_PROP_SHEET);
    memset(&cepHeader,		0,	sizeof(PROPSHEETHEADERW));
	memset(&CEPWizardInfo,	0,	sizeof(CEP_WIZARD_INFO));

	if(FAILED(CoInitialize(NULL)))
		return FALSE;

	if(NULL==(g_hModule=GetModuleHandle(NULL)))
		goto CommonReturn;   

	if(!IsValidInstallation(&idsMsg))
		goto ErrorReturn;

	if(!IsCaRunning())
	{
		if(S_OK != (hr=CepStartService(CERTSVC_NAME)))
		{
			idsMsg=IDS_NO_CA_RUNNING;
			goto ErrorWithHResultReturn;
		}
	}

	//make sure the CA is up running
    for (dwWaitCounter=0; dwWaitCounter < 15; dwWaitCounter++) 
	{
        if (!IsCaRunning()) 
            Sleep(1000);
		else 
            break;
    }

    if (15 == dwWaitCounter) 
	{
        idsMsg=IDS_CAN_NOT_START_CA;
		goto ErrorWithHResultReturn;
    }


	//make sure we have the correct admin rights based on the CA type
	if(S_OK != (hr=GetCaType(&catype)))
	{
		idsMsg=IDS_FAIL_GET_CA_TYPE;
		goto ErrorWithHResultReturn;
	}

	//some cisco routers only work with root CA
	if((ENUM_ENTERPRISE_ROOTCA != catype) && (ENUM_STANDALONE_ROOTCA != catype))
	{
		if(IDNO==CEPMessageBox(NULL, IDS_CAN_NOT_ROOT_CA, MB_ICONWARNING|MB_YESNO|MB_APPLMODAL))
		{
			fResult=FALSE;
			goto CommonReturn;
		}
	}

	if (ENUM_ENTERPRISE_ROOTCA==catype || ENUM_ENTERPRISE_SUBCA==catype) 
	{
		fEnterpriseCA=TRUE;

		// check for enterprise admin
		if(!IsUserInAdminGroup(TRUE))
		{
			idsMsg=IDS_NOT_ENT_ADMIN;
			goto ErrorReturn;
		}
	} 
	else 
	{
		// check for machine admin
		if(!IsUserInAdminGroup(FALSE))
		{
			idsMsg=IDS_NOT_MACHINE_ADMIN;
			goto ErrorReturn;
		}
	}

	//everything looks good.  We start the wizard page
	if(!CEPWizardInit())
		goto ErrorWithWin32Return;

	CEPWizardInfo.fEnrollAdv=FALSE;
	CEPWizardInfo.fPassword=TRUE;
	CEPWizardInfo.fEnterpriseCA=fEnterpriseCA;

	if(!CEPGetCSPInformation(&CEPWizardInfo))
	{
		idsMsg=IDS_FAIL_GET_CSP_INFO;
		goto ErrorWithWin32Return;
	}

	for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
	{
		CEPWizardInfo.rgpwszName[dwIndex]=NULL;
	}

	if(!SetupFonts(
		g_hModule,
		NULL,
		&(CEPWizardInfo.hBigBold),
		&(CEPWizardInfo.hBold)))
		goto ErrorReturn;


    for(dwIndex=0; dwIndex<CEP_PROP_SHEET; dwIndex++)
	{
        rgCEPSheet[dwIndex].dwSize=sizeof(rgCEPSheet[dwIndex]);

        rgCEPSheet[dwIndex].hInstance=g_hModule;

        rgCEPSheet[dwIndex].pszTemplate=rgCEPPageInfo[dwIndex].pszTemplate;

        rgCEPSheet[dwIndex].pfnDlgProc=rgCEPPageInfo[dwIndex].pfnDlgProc;

        rgCEPSheet[dwIndex].lParam=(LPARAM)&CEPWizardInfo;
	}

    //set up the header information
    cepHeader.dwSize=sizeof(cepHeader);
    cepHeader.dwFlags=PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    cepHeader.hwndParent=NULL;
    cepHeader.hInstance=g_hModule;

	if(LoadStringU(g_hModule, IDS_WIZARD_CAPTION, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
		cepHeader.pszCaption=wszTitle;

    cepHeader.nPages=CEP_PROP_SHEET;
    cepHeader.nStartPage=0;
    cepHeader.ppsp=rgCEPSheet;

    //create the wizard
    iReturn = PropertySheetU(&cepHeader);

	if(-1 == iReturn)
        goto ErrorWithWin32Return;

    if(0 == iReturn)
    {
        //cancel button is pushed.  We return FALSE so that 
		//the reboot will not happen.
        fResult=FALSE;
		goto CommonReturn;
    }

	fResult=TRUE;

CommonReturn:

	FreeCEPWizardInfo(&CEPWizardInfo);

	CoUninitialize();

	return fResult;

ErrorReturn:

	fResult=FALSE;

	CEPMessageBox(NULL, idsMsg, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithHResultReturn:

	fResult=FALSE;

	CEPErrorMessageBox(NULL, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithWin32Return:

	fResult=FALSE;

	hr=HRESULT_FROM_WIN32(GetLastError());

	CEPErrorMessageBox(NULL, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;
}

//**********************************************************************
//
//	Helper functions
//
//**********************************************************************
//-----------------------------------------------------------------------
//
//	 I_DoSetupWork
//
//	we are ready to do the real work
//-----------------------------------------------------------------------
BOOL	WINAPI	I_DoSetupWork(HWND	hWnd, CEP_WIZARD_INFO *pCEPWizardInfo)
{
	BOOL					fResult=FALSE;
	UINT					idsMsg=IDS_FAIL_INIT_WIZARD;		
	HRESULT					hr=E_FAIL;
	DWORD					dwWaitCounter=0;
	DWORD					dwIndex=0;
	BOOL					bStart=FALSE;
	DWORD					dwSize=0;
    WCHAR                   wszTitle[MAX_TITLE_LENGTH];	  

	LPWSTR					pwszRADN=NULL;
	LPWSTR					pwszComputerName=NULL;
	LPWSTR					pwszText=NULL;

	//************************************************************************************
	//delete all existing CEP certificates
	if(!RemoveRACertificates())
	{	
		idsMsg=IDS_FAIL_DELETE_RA;
		goto ErrorWithWin32Return;
	}

	//************************************************************************************
	//CEP policy registry
	if(!UpdateCEPRegistry(pCEPWizardInfo->fPassword,
						  pCEPWizardInfo->fEnterpriseCA))
	{
		idsMsg=IDS_FAIL_UPDATE_REGISTRY;
		goto ErrorWithWin32Return;
	}

	//************************************************************************************
	// Add the virtual root    
    if(S_OK != (hr=AddVDir(CEP_DIR_NAME)))
	{
		idsMsg=IDS_FAIL_ADD_VROOT;
		goto ErrorWithHResultReturn;
	}		  


 	//************************************************************************************
	//Update the certificate template and its ACLs for enterprise CA
	if (pCEPWizardInfo->fEnterpriseCA) 
	{
		// get the templates and permisisons right
		if(S_OK != (hr=DoCertSrvEnterpriseChanges()))
		{
			idsMsg=IDS_FAIL_ADD_TEMPLATE;
			goto ErrorWithHResultReturn;
		}
	} 


 	//************************************************************************************
	//Enroll for the RA certificate
	
	//build the name in the form of L"C=US;S=Washington;CN=TestSetupUtil"
	pwszRADN=(LPWSTR)malloc(sizeof(WCHAR));
	if(NULL==pwszRADN)
	{
		idsMsg=IDS_NO_MEMORY;
		goto ErrorReturn;
	}
	*pwszRADN=L'\0';

	for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
	{
		if((pCEPWizardInfo->rgpwszName)[dwIndex])
		{
			if(0 != wcslen(pwszRADN))
				wcscat(pwszRADN, L";");

			pwszRADN=(LPWSTR)realloc(pwszRADN,
					sizeof(WCHAR) * (wcslen(pwszRADN) +
									wcslen((pCEPWizardInfo->rgpwszName)[dwIndex]) + 
									wcslen(L";") + 
									wcslen(g_rgRAEnrollInfo[dwIndex].pwszPreFix) +
									1));

			if(NULL==pwszRADN)
			{
				idsMsg=IDS_NO_MEMORY;
				goto ErrorReturn;
			}

 			wcscat(pwszRADN,g_rgRAEnrollInfo[dwIndex].pwszPreFix);
 			wcscat(pwszRADN,(pCEPWizardInfo->rgpwszName)[dwIndex]);
		}
	}

	if(S_OK != (hr=EnrollForRACertificates(
					pwszRADN,							
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwSignProvIndex].pwszCSPName, 
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwSignProvIndex].dwCSPType, 
					pCEPWizardInfo->dwSignKeyLength,
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwEncryptProvIndex].pwszCSPName, 
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwEncryptProvIndex].dwCSPType, 
					pCEPWizardInfo->dwEncryptKeyLength)))
	{
		idsMsg=IDS_FAIL_ENROLL_RA_CERT;
		goto ErrorWithHResultReturn;
	}

 	//************************************************************************************
	//CA policy registry

	CepStopService(CERTSVC_NAME, &bStart);

    if(S_OK != (hr=DoCertSrvRegChanges(FALSE)))
	{
		idsMsg=IDS_FAIL_UPDATE_CERTSVC;
		goto ErrorWithHResultReturn;
	}	  

    if(S_OK != (hr=CepStartService(CERTSVC_NAME)))
	{
		idsMsg=IDS_FAIL_START_CERTSVC;
		goto ErrorWithHResultReturn;
	}

	//make sure the CA is up running
    for (dwWaitCounter=0; dwWaitCounter < 15; dwWaitCounter++) 
	{
        if (!IsCaRunning()) 
            Sleep(1000);
		else 
            break;
    }

    if (15 == dwWaitCounter) 
	{
        idsMsg=IDS_CAN_NOT_START_CA;
		goto ErrorWithHResultReturn;
    }

 	//************************************************************************************
	//success
	//inform the user of the password location and URL
	dwSize=0;

	GetComputerNameExW(ComputerNamePhysicalDnsHostname,
						NULL,
						&dwSize);

	pwszComputerName=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

	if(NULL==pwszComputerName)
	{
		idsMsg=IDS_NO_MEMORY;
		goto ErrorReturn;
	}

	
	if(!GetComputerNameExW(ComputerNamePhysicalDnsHostname,
						pwszComputerName,
						&dwSize))
	{
		idsMsg=IDS_FAIL_GET_COMPUTER_NAME;
		goto ErrorWithWin32Return;
	}

	if(!FormatMessageUnicode(&pwszText, IDS_CEP_SUCCESS_INFO, pwszComputerName, CEP_DIR_NAME, CEP_DLL_NAME))
	{
		idsMsg=IDS_NO_MEMORY;
		goto ErrorWithWin32Return;
	}

	wszTitle[0]=L'\0';

	LoadStringU(g_hModule, IDS_WIZARD_CAPTION, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0]));
	
	MessageBoxU(hWnd, pwszText, wszTitle, MB_OK | MB_APPLMODAL);

	fResult=TRUE;

CommonReturn:

	if(pwszText)
		LocalFree((HLOCAL)pwszText);

	if(pwszComputerName)
		free(pwszComputerName);

	if(pwszRADN)
		free(pwszRADN);

	return fResult;

ErrorReturn:

	fResult=FALSE;

	CEPMessageBox(hWnd, idsMsg, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithHResultReturn:

	fResult=FALSE;

	CEPErrorMessageBox(hWnd, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithWin32Return:

	fResult=FALSE;

	hr=HRESULT_FROM_WIN32(GetLastError());

	CEPErrorMessageBox(hWnd, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;
}

//-----------------------------------------------------------------------
//
//   CEPGetCSPInformation
//
//		We initialize the following members of CEP_WIZARD_INFO:
//
//	CEP_CSP_INFO		*rgCSPInfo;
//	DWORD				dwCSPCount;
//	DWORD				dwSignProvIndex;
//	DWORD				dwSignKeySize;
//	DWORD				dwEncryptProvIndex;
//	DWORD				dwEncryptKeySize;
//
//
// typedef struct _CEP_CSP_INFO
//{
//	LPWSTR		pwszCSPName;				
//	DWORD		dwCSPType;
//	BOOL		fSignature;
//	BOOL		fExchange;
//	DWORD		dwMaxSign;						//Max key length of signature
//	DWORD		dwMinSign;						//Min key length of signature
//	DWORD		dwDefaultSign;					//default key length of signature
//	DWORD		dwMaxEncrypt;
//	DWORD		dwMinEncrypt;
//	DWORD		dwDefaultEncrypt;
//	DWORD		*pdwSignList;					//the table of possible signing key length
//	DWORD		dwSignCount;				    //the count of entries in the table
//	DWORD		*pdwEncryptList;
//	DWORD		dwEncryptCount;
//}CEP_CSP_INFO;
//
//
//------------------------------------------------------------------------
BOOL WINAPI CEPGetCSPInformation(CEP_WIZARD_INFO *pCEPWizardInfo)
{
	BOOL				fResult=FALSE;
    DWORD				dwCSPIndex=0;	
	DWORD				dwProviderType=0;
	DWORD				cbSize=0;
	DWORD				dwFlags=0;
	DWORD				dwIndex=0;
	int					iDefaultSignature=-1;
	int					iDefaultEncryption=-1;
    PROV_ENUMALGS_EX	paramData;

	CEP_CSP_INFO		*pCSPInfo=NULL;
	HCRYPTPROV			hProv = NULL;

    //enum all the providers on the system
   while(CryptEnumProvidersU(
                            dwCSPIndex,
                            NULL,
                            0,
                            &dwProviderType,
                            NULL,
                            &cbSize))
   {

		pCSPInfo=(CEP_CSP_INFO	*)malloc(sizeof(CEP_CSP_INFO));

		if(NULL == pCSPInfo)
			goto MemoryErr;

		memset(pCSPInfo, 0, sizeof(CEP_CSP_INFO));

        pCSPInfo->pwszCSPName=(LPWSTR)malloc(cbSize);

		if(NULL==(pCSPInfo->pwszCSPName))
			goto MemoryErr;

        //get the CSP name and the type
        if(!CryptEnumProvidersU(
                            dwCSPIndex,
                            NULL,
                            0,
                            &(pCSPInfo->dwCSPType),
                            pCSPInfo->pwszCSPName,
                            &cbSize))
            goto TryNext;

		if(!CryptAcquireContextU(&hProv,
                NULL,
                pCSPInfo->pwszCSPName,
                pCSPInfo->dwCSPType,
                CRYPT_VERIFYCONTEXT))
			goto TryNext;

		//get the max/min of key length for both signature and encryption
		dwFlags=CRYPT_FIRST;
		cbSize=sizeof(paramData);
		memset(&paramData, 0, sizeof(PROV_ENUMALGS_EX));

		while(CryptGetProvParam(
                hProv,
                PP_ENUMALGS_EX,
                (BYTE *) &paramData,
                &cbSize,
                dwFlags))
        {
			if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(paramData.aiAlgid))
			{
				pCSPInfo->fSignature=TRUE;
				pCSPInfo->dwMaxSign = paramData.dwMaxLen;
				pCSPInfo->dwMinSign = paramData.dwMinLen;
			}

			if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(paramData.aiAlgid))
			{
				pCSPInfo->fEncryption=TRUE;
				pCSPInfo->dwMaxEncrypt = paramData.dwMaxLen;
				pCSPInfo->dwMinEncrypt = paramData.dwMinLen;
			}

			dwFlags=0;
			cbSize=sizeof(paramData);
			memset(&paramData, 0, sizeof(PROV_ENUMALGS_EX));
		}

		//the min/max has to within the limit
		if(pCSPInfo->fSignature)
		{
			if(pCSPInfo->dwMaxSign < g_rgdwSmallKeyLength[0])
				pCSPInfo->fSignature=FALSE;

			if(pCSPInfo->dwMinSign > g_rgdwKeyLength[g_dwKeyLengthCount-1])
				pCSPInfo->fSignature=FALSE;

		}

		if(pCSPInfo->fEncryption)
		{
			if(pCSPInfo->dwMaxEncrypt < g_rgdwSmallKeyLength[0])
				pCSPInfo->fEncryption=FALSE;

			if(pCSPInfo->dwMinEncrypt > g_rgdwKeyLength[g_dwKeyLengthCount-1])
				pCSPInfo->fEncryption=FALSE;
		}

		if((FALSE == pCSPInfo->fEncryption) && (FALSE==pCSPInfo->fSignature))
			goto TryNext;

		//decide the default key length
		for(dwIndex=0; dwIndex<g_dwDefaultKeyCount; dwIndex++)
		{	
			if((pCSPInfo->fSignature) && (0==pCSPInfo->dwDefaultSign))
			{
				if((g_rgdwDefaultKey[dwIndex] >= pCSPInfo->dwMinSign) &&
				   (g_rgdwDefaultKey[dwIndex] <= pCSPInfo->dwMaxSign)
				  )
				  pCSPInfo->dwDefaultSign=g_rgdwDefaultKey[dwIndex];
			}

			if((pCSPInfo->fEncryption) && (0==pCSPInfo->dwDefaultEncrypt))
			{
				if((g_rgdwDefaultKey[dwIndex] >= pCSPInfo->dwMinEncrypt) &&
				   (g_rgdwDefaultKey[dwIndex] <= pCSPInfo->dwMaxEncrypt)
				  )
				  pCSPInfo->dwDefaultEncrypt=g_rgdwDefaultKey[dwIndex];
			}
		}

		//make sure that we have find a default
		if((pCSPInfo->fSignature) && (0==pCSPInfo->dwDefaultSign))
			goto TryNext;

		if((pCSPInfo->fEncryption) && (0==pCSPInfo->dwDefaultEncrypt))
			goto TryNext;

		//decide the display list
		if(pCSPInfo->fSignature)
		{
			if(pCSPInfo->dwMaxSign <= g_rgdwSmallKeyLength[g_dwSmallKeyLengthCount-1])
			{
				pCSPInfo->pdwSignList=g_rgdwSmallKeyLength;
				pCSPInfo->dwSignCount=g_dwSmallKeyLengthCount;
			}
			else
			{
				pCSPInfo->pdwSignList=g_rgdwKeyLength;
				pCSPInfo->dwSignCount=g_dwKeyLengthCount;
			}
		}


		if(pCSPInfo->fEncryption)
		{
			if(pCSPInfo->dwMaxEncrypt <= g_rgdwSmallKeyLength[g_dwSmallKeyLengthCount-1])
			{
				pCSPInfo->pdwEncryptList=g_rgdwSmallKeyLength;
				pCSPInfo->dwEncryptCount=g_dwSmallKeyLengthCount;
			}
			else
			{
				pCSPInfo->pdwEncryptList=g_rgdwKeyLength;
				pCSPInfo->dwEncryptCount=g_dwKeyLengthCount;
			}
		}


		//the CSP looks good
		(pCEPWizardInfo->dwCSPCount)++;

		//realloc to mapped to LocalRealloc which does not take NULL
		if(1 == pCEPWizardInfo->dwCSPCount)
			pCEPWizardInfo->rgCSPInfo=(CEP_CSP_INFO	*)malloc(sizeof(CEP_CSP_INFO));
		else
			pCEPWizardInfo->rgCSPInfo=(CEP_CSP_INFO	*)realloc(pCEPWizardInfo->rgCSPInfo,
			(pCEPWizardInfo->dwCSPCount) * sizeof(CEP_CSP_INFO));

		if(NULL==pCEPWizardInfo->rgCSPInfo)
		{
			pCEPWizardInfo->dwCSPCount=0;
			goto MemoryErr;	
		}

		memcpy(&(pCEPWizardInfo->rgCSPInfo[(pCEPWizardInfo->dwCSPCount)-1]),
			pCSPInfo, sizeof(CEP_CSP_INFO));

		free(pCSPInfo);

		pCSPInfo=NULL;
		
		//we default to use RSA_FULL
		if(0 == _wcsicmp(pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwCSPCount-1].pwszCSPName,
						MS_DEF_PROV_W))
		{
			if(pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwCSPCount-1].fSignature)
			{
				iDefaultSignature=pCEPWizardInfo->dwCSPCount-1;
			}

			if(pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwCSPCount-1].fEncryption)
			{
				iDefaultEncryption=pCEPWizardInfo->dwCSPCount-1;
			}
		}


TryNext:
		cbSize=0;

		dwCSPIndex++;

		if(pCSPInfo)
		{
			if(pCSPInfo->pwszCSPName)
				free(pCSPInfo->pwszCSPName);

			free(pCSPInfo);
		}

		pCSPInfo=NULL;

		if(hProv)
			CryptReleaseContext(hProv, 0);

		hProv=NULL;
	}

	
	//we need to have some valid data
	if((0==pCEPWizardInfo->dwCSPCount) || (NULL==pCEPWizardInfo->rgCSPInfo))
		goto InvalidArgErr;

	//get the default CSP selection
	if(-1 != iDefaultSignature)
		pCEPWizardInfo->dwSignProvIndex=iDefaultSignature;
	else
	{
		//find the 1st signature CSP 
		for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
		{
			if(pCEPWizardInfo->rgCSPInfo[dwIndex].fSignature)
			{
				pCEPWizardInfo->dwSignProvIndex=dwIndex;
				break;
			}

			//we do no have signature CSPs
			if(dwIndex == pCEPWizardInfo->dwCSPCount)
				goto InvalidArgErr;

		}
	}

	pCEPWizardInfo->dwSignKeyLength=pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwSignProvIndex].dwDefaultSign;

	if(-1 != iDefaultEncryption)
		pCEPWizardInfo->dwEncryptProvIndex=iDefaultEncryption;
	else
	{
		//find the 1st exchange CSP
		for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
		{
			if(pCEPWizardInfo->rgCSPInfo[dwIndex].fEncryption)
			{
				pCEPWizardInfo->dwEncryptProvIndex=dwIndex;
				break;
			}

			//we do no have encryption CSPs
			if(dwIndex == pCEPWizardInfo->dwCSPCount)
				goto InvalidArgErr;
		}
	}

	pCEPWizardInfo->dwEncryptKeyLength=pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwEncryptProvIndex].dwDefaultEncrypt;


	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	if(pCSPInfo)
	{
		if(pCSPInfo->pwszCSPName)
			free(pCSPInfo->pwszCSPName);

		free(pCSPInfo);
	}

	if(hProv)
		CryptReleaseContext(hProv, 0);

	if(pCEPWizardInfo->rgCSPInfo)
	{
		for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
		{
			if(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName)
				free(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName);
		}

		free(pCEPWizardInfo->rgCSPInfo);
	}

	pCEPWizardInfo->dwCSPCount=0;

	pCEPWizardInfo->rgCSPInfo=NULL;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);   
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//-----------------------------------------------------------------------
//
//    UpdateCEPRegistry
//
//------------------------------------------------------------------------
BOOL WINAPI UpdateCEPRegistry(BOOL		fPassword, BOOL fEnterpriseCA)
{
	BOOL				fResult=FALSE;
	DWORD				dwDisposition=0;
	LPWSTR				pwszReg[]={MSCEP_REFRESH_LOCATION,          
								   MSCEP_PASSWORD_LOCATION,         
								   MSCEP_PASSWORD_MAX_LOCATION,     
								   MSCEP_PASSWORD_VALIDITY_LOCATION,
								   MSCEP_CACHE_REQUEST_LOCATION,    
								   MSCEP_CATYPE_LOCATION};
	DWORD			    dwRegCount=0;
	DWORD				dwRegIndex=0;


	HKEY				hKey=NULL;	


	//we delete all existing CEP related registry keys
	dwRegCount=sizeof(pwszReg)/sizeof(pwszReg[0]);

	for(dwRegIndex=0; dwRegIndex < dwRegCount; dwRegIndex++)
	{
		RegDeleteKeyU(HKEY_LOCAL_MACHINE, pwszReg[dwRegIndex]);
	}

	//password
	if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        MSCEP_PASSWORD_LOCATION,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
		goto RegErr;

	if(fPassword)
		dwDisposition=1;
	else
		dwDisposition=0;

    if(ERROR_SUCCESS !=  RegSetValueExU(
                hKey, 
                MSCEP_KEY_PASSWORD,
                0,
                REG_DWORD,
                (BYTE *)&dwDisposition,
                sizeof(dwDisposition)))
		goto RegErr;

	if(hKey)
		RegCloseKey(hKey);

	hKey=NULL;

	//caType
	dwDisposition=0;

	if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        MSCEP_CATYPE_LOCATION,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
		goto RegErr;

	if(fEnterpriseCA)
		dwDisposition=1;
	else
		dwDisposition=0;

    if(ERROR_SUCCESS !=  RegSetValueExU(
                hKey, 
                MSCEP_KEY_CATYPE,
                0,
                REG_DWORD,
                (BYTE *)&dwDisposition,
                sizeof(dwDisposition)))
		goto RegErr;

	fResult=TRUE;

CommonReturn:

	if(hKey)
		RegCloseKey(hKey);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(RegErr);   
}

//-----------------------------------------------------------------------
//
//    EmptyCEPStore
//
//------------------------------------------------------------------------
BOOL WINAPI EmptyCEPStore()
{
	BOOL				fResult=TRUE;
	
	HCERTSTORE			hCEPStore=NULL;
	PCCERT_CONTEXT		pCurCert=NULL;

	if(NULL == (hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG,
                            CEP_STORE_NAME)))
		return TRUE;


	if(NULL != (pCurCert=CertEnumCertificatesInStore(hCEPStore, NULL)))
	{
		CertFreeCertificateContext(pCurCert);
		fResult=FALSE;
	}

	CertCloseStore(hCEPStore, 0);

	return fResult;
}

//-----------------------------------------------------------------------
//
//    RemoveRACertificates
//
//------------------------------------------------------------------------
BOOL WINAPI RemoveRACertificates()
{
	PCCERT_CONTEXT		pCurCert=NULL;
	PCCERT_CONTEXT		pPreCert=NULL;
	PCCERT_CONTEXT		pDupCert=NULL;
	BOOL				fResult=TRUE;
	
	HCERTSTORE			hCEPStore=NULL;


	if(hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_OPEN_EXISTING_FLAG,
                            CEP_STORE_NAME))
	{
		while(pCurCert=CertEnumCertificatesInStore(hCEPStore,
												pPreCert))
		{

			if(pDupCert=CertDuplicateCertificateContext(pCurCert))
			{
				if(!CertDeleteCertificateFromStore(pDupCert))
				{
					fResult=FALSE;	
				}

				pDupCert=NULL;
			}
			else
				fResult=FALSE;
			
			pPreCert=pCurCert;
		}

		CertCloseStore(hCEPStore, 0);
	}

	return fResult;
}


//-----------------------------------------------------------------------
//
//     FreeCEPWizardInfo
//
//------------------------------------------------------------------------
void	WINAPI FreeCEPWizardInfo(CEP_WIZARD_INFO *pCEPWizardInfo)
{
	DWORD	dwIndex=0;

	if(pCEPWizardInfo)
	{
		DestroyFonts(pCEPWizardInfo->hBigBold,
					 pCEPWizardInfo->hBold);

		for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
		{
			if(pCEPWizardInfo->rgpwszName[dwIndex])
				free(pCEPWizardInfo->rgpwszName[dwIndex]);
		}

		if(pCEPWizardInfo->rgCSPInfo)
		{
			for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
			{
				if(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName)
					free(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName);
			}

			free(pCEPWizardInfo->rgCSPInfo);
		}

		memset(pCEPWizardInfo, 0, sizeof(CEP_WIZARD_INFO));
	}
}


//-----------------------------------------------------------------------
//
//     CEPWizardInit
//
//------------------------------------------------------------------------
BOOL    WINAPI CEPWizardInit()
{
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES
    };

    return InitCommonControlsEx(&initcomm);
}

//-----------------------------------------------------------------------
//
// IsValidInstallation
//
//------------------------------------------------------------------------
BOOL WINAPI	IsValidInstallation(UINT	*pidsMsg)
{
	if(!IsNT5())
	{
		*pidsMsg=IDS_NO_NT5;
		return FALSE;
	}

	if(!IsIISInstalled())
	{
		*pidsMsg=IDS_NO_IIS;
		return FALSE;
	}

	if(!IsGoodCaInstalled())
	{
		*pidsMsg=IDS_NO_GOOD_CA;
		return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//
// CEPErrorMessageBox
//
//------------------------------------------------------------------------
int WINAPI CEPErrorMessageBox(
    HWND        hWnd,
    UINT        idsReason,
	HRESULT		hr,
    UINT        uType
)
{

    WCHAR   wszReason[MAX_STRING_SIZE];
    WCHAR   wszCaption[MAX_STRING_SIZE];
    UINT    intReturn=0;

	LPWSTR	pwszText=NULL;
	LPWSTR	pwszErrorMsg=NULL;

    if(!LoadStringU(g_hModule, IDS_MEG_CAPTION, wszCaption, sizeof(wszCaption)))
         goto CLEANUP;

	if(!LoadStringU(g_hModule, idsReason, wszReason, sizeof(wszReason)))
         goto CLEANUP;

	if(!FAILED(hr))
		hr=E_FAIL;

    //using W version because this is a NT5 only function call
    if(FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPWSTR) &pwszErrorMsg,
                        0,
                        NULL))
	{

		if(!FormatMessageUnicode(&pwszText, IDS_CEP_ERROR_MSG_HR, wszReason, pwszErrorMsg))
			goto CLEANUP;

	}
	else
	{
		if(!FormatMessageUnicode(&pwszText, IDS_CEP_ERROR_MSG, wszReason))
			goto CLEANUP;
	}

	intReturn=MessageBoxU(hWnd, pwszText, wszCaption, uType);

	
CLEANUP:
	
	if(pwszText)
		LocalFree((HLOCAL)pwszText);

	if(pwszErrorMsg)
		LocalFree((HLOCAL)pwszText);

    return intReturn;
}


//-----------------------------------------------------------------------
//
// CEPMessageBox
//
//------------------------------------------------------------------------
int WINAPI CEPMessageBox(
    HWND        hWnd,
    UINT        idsText,
    UINT        uType
)
{

    WCHAR   wszText[MAX_STRING_SIZE];
    WCHAR   wszCaption[MAX_STRING_SIZE];
    UINT    intReturn=0;

    if(!LoadStringU(g_hModule, IDS_MEG_CAPTION, wszCaption, sizeof(wszCaption)))
         return 0;

    if(!LoadStringU(g_hModule, idsText, wszText, sizeof(wszText)))
        return 0;

	intReturn=MessageBoxU(hWnd, wszText, wszCaption, uType);

    return intReturn;
}

//--------------------------------------------------------------------------
//
//	 SetControlFont
//
//--------------------------------------------------------------------------
void WINAPI SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    )
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}


//--------------------------------------------------------------------------
//
//	  SetupFonts
//
//--------------------------------------------------------------------------
BOOL WINAPI SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    INT BigBoldFontSize = 12;

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * BigBoldFontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		*pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);

        if(*pBigBoldFont && *pBoldFont)
            return TRUE;
        else
        {
            if( *pBigBoldFont )
            {
                DeleteObject(*pBigBoldFont);
            }

            if( *pBoldFont )
            {
                DeleteObject(*pBoldFont);
            }
            return FALSE;
        }
    }

    return FALSE;
}


//--------------------------------------------------------------------------
//
//	  DestroyFonts
//
//--------------------------------------------------------------------------
void WINAPI DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}



//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL WINAPI	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    if(!LoadStringU(g_hModule, ids, wszFormat, sizeof(wszFormat)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\setup\setuputil.h ===
//--------------------------------------------------------------------
// SetupUtil - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Functions needed to set up CEP
//

#ifndef SETUP_UTIL_H
#define SETUP_UTIL_H

//--------------------------------------------------------------------
// prototypes
// Note: caller must call CoInitialize() first

BOOL IsNT5(void);
BOOL IsIISInstalled(void);
BOOL IsGoodCaInstalled(void);
BOOL IsCaRunning(void);
BOOL IsUserInAdminGroup(IN BOOL bEnterprise);
HRESULT AddVDir(IN const WCHAR * wszDirectory);
HRESULT CepStopService(IN const WCHAR * wszServiceName, OUT BOOL * pbWasRunning);
HRESULT CepStartService(IN const WCHAR * wszServiceName);
HRESULT EnrollForRACertificates(
            IN const WCHAR * wszDistinguishedName,
            IN const WCHAR * wszSignCSPName,
            IN DWORD dwSignCSPType,
            IN DWORD dwSignKeySize,
            IN const WCHAR * wszEncryptCSPName,
            IN DWORD dwEncryptCSPType,
            IN DWORD dwEncryptKeySize);
HRESULT DoCertSrvRegChanges(IN BOOL bDisablePendingFirst);
HRESULT GetCaType(OUT ENUM_CATYPES * pCAType);
HRESULT DoCertSrvEnterpriseChanges(void);

#endif //SETUP_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\setup\cepsetup.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       cepsetup.h
//
//  Contents:   The private include file for cepsetup.exe.
//
//  History:    August-12-1999	xiaohs	Created
//
//--------------------------------------------------------------
#ifndef CEPSETUP_H
#define CEPSETUP_H


#ifdef __cplusplus
extern "C" {
#endif

//-----------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------
#define		MAX_STRING_SIZE				512
#define		CEP_PROP_SHEET				5
#define		MAX_TITLE_LENGTH			128
#define		RA_INFO_COUNT				7
#define		CEP_KEY_LENGTH_STRING		15


//-----------------------------------------------------------------------
//
//  CEP_PAGE_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_PAGE_INFO
{
    LPCWSTR      pszTemplate;
    DLGPROC     pfnDlgProc;
}CEP_PAGE_INFO;


typedef struct _CEP_ENROLL_INFO
{
	LPWSTR		pwszPreFix;
	DWORD		dwIDC;
}CEP_ENROLL_INFO;


typedef struct _CEP_CSP_INFO
{
	LPWSTR		pwszCSPName;				
	DWORD		dwCSPType;
	BOOL		fSignature;
	BOOL		fEncryption;
	DWORD		dwMaxSign;						//Max key length of signature
	DWORD		dwMinSign;						//Min key length of signature
	DWORD		dwDefaultSign;					//default key length of signature
	DWORD		dwMaxEncrypt;
	DWORD		dwMinEncrypt;
	DWORD		dwDefaultEncrypt;
	DWORD		*pdwSignList;					//the table of possible signing key length
	DWORD		dwSignCount;				    //the count of entries in the table
	DWORD		*pdwEncryptList;
	DWORD		dwEncryptCount;
}CEP_CSP_INFO;


typedef struct _CEP_WIZARD_INFO
{
    HFONT               hBigBold;
    HFONT               hBold;
	BOOL				fEnrollAdv;
	BOOL				fPassword;
	LPWSTR				rgpwszName[RA_INFO_COUNT];
	CEP_CSP_INFO		*rgCSPInfo;
	DWORD				dwCSPCount;
	DWORD				dwSignProvIndex;
	DWORD				dwSignKeyLength;
	DWORD				dwEncryptProvIndex;
	DWORD				dwEncryptKeyLength;
	BOOL				fEnterpriseCA;
}CEP_WIZARD_INFO;


//-----------------------------------------------------------------------
//
// Function Prototypes
//
//-----------------------------------------------------------------------
BOOL	WINAPI		IsValidInstallation(UINT	*pidsMsg);

int		WINAPI		CEPMessageBox(
							HWND        hWnd,
							UINT        idsText,
							UINT        uType);

int		WINAPI		CEPErrorMessageBox(
							HWND        hWnd,
							UINT        idsReason,
							HRESULT		hr,
							UINT        uType
							);					 

BOOL	WINAPI		FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...);


BOOL    WINAPI		CEPWizardInit();

void	WINAPI		FreeCEPWizardInfo(CEP_WIZARD_INFO *pCEPWizardInfo);

void	WINAPI		SetControlFont(
							IN HFONT    hFont,
							IN HWND     hwnd,
							IN INT      nId
							);

BOOL	WINAPI		SetupFonts(
							IN HINSTANCE    hInstance,
							IN HWND         hwnd,
							IN HFONT        *pBigBoldFont,
							IN HFONT        *pBoldFont
							);

void	WINAPI		DestroyFonts(
							IN HFONT        hBigBoldFont,
							IN HFONT        hBoldFont
							);

BOOL	WINAPI		RemoveRACertificates();

void    WINAPI		DisplayConfirmation(HWND                hwndControl,
										CEP_WIZARD_INFO		*pCEPWizardInfo);


BOOL	WINAPI		UpdateCEPRegistry(BOOL		fPassword, BOOL fEnterpriseCA);


BOOL	WINAPI		EmptyCEPStore();

BOOL	WINAPI		CEPGetCSPInformation(CEP_WIZARD_INFO *pCEPWizardInfo);

BOOL	WINAPI		GetSelectedKeyLength(HWND			hwndDlg,
						  int			idControl,
						  DWORD			*pdwKeyLength);

BOOL	WINAPI		GetSelectedCSP(HWND			hwndDlg,
							int				idControl,
							DWORD			*pdwCSPIndex);

BOOL	WINAPI		RefreshKeyLengthCombo(HWND				hwndDlg, 
								   int					idsList,
								   int					idsCombo, 
								   BOOL					fSign,
								   CEP_WIZARD_INFO		*pCEPWizardInfo);

BOOL	WINAPI		InitCSPList(HWND				hwndDlg,
							int					idControl,
							BOOL				fSign,
							CEP_WIZARD_INFO		*pCEPWizardInfo);

BOOL	WINAPI		I_DoSetupWork(HWND	hWnd, CEP_WIZARD_INFO *pCEPWizardInfo);



#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //CEPSETUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certie3\certie3.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certie3.cpp
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdio.h>
#include "wincrypt.h"

int ln = 0;

// This has to be big enough to hold a registry value's data.
char szStr[5000];

#define DISPLAY(sz)	printf("%hs\n", sz)


void __cdecl
main(
    int argc,
    char **argv)
{
    char szRegPath[MAX_PATH] = "SOFTWARE\\Microsoft\\Cryptography\\";
    char sourceloc[MAX_PATH];
    char *pszFileOut;
    char *pszRegKey;
    HKEY hKeyBase;
    BOOL fAuth = FALSE;

    fAuth = argc > 1 && argv[1][0] == '-';
	
    if (fAuth)
    {
	pszFileOut = "ClientAuth.dat";
	strcpy(sourceloc, "HKEY_CURRENT_USER");
	pszRegKey = "PersonalCertificates\\ClientAuth\\Certificates";
	hKeyBase = HKEY_CURRENT_USER;
    }
    else
    {
	pszFileOut = "CertStore.dat";
	strcpy(sourceloc, "HKEY_LOCAL_MACHINE");
	pszRegKey = "CertificateStore\\Certificates";
	hKeyBase = HKEY_LOCAL_MACHINE;
    }

    ln = 0;
    strcat(szRegPath, pszRegKey);

    strcat(sourceloc, "\\");
    strcat(sourceloc, szRegPath);
    strcpy(szStr, "Collect information from Registry");
    DISPLAY(szStr);

    ln++;
    strcpy(szStr, "Registry location: ");
    strcat(szStr, sourceloc);
    DISPLAY(szStr);

    ln++;
    strcpy(szStr, "Target destination for registry dump: ");
    strcat(szStr, pszFileOut);
    DISPLAY(szStr);
		  

    // Declarations for the output file related stuff

    HCRYPTPROV hProv = NULL;
    HCERTSTORE hCertStore = NULL;
    CERT_INFO certinfo;
    CERT_CONTEXT const *pPrevCertContext = NULL;
    CERT_CONTEXT const *pCertContext = NULL;
    DWORD dwErr;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, 0))
    {
	dwErr = GetLastError();

	if (dwErr == NTE_BAD_KEYSET)
	{
	    strcpy(szStr, "NTE_BAD_KEYSET error on call CryptAcquireContext");
	    DISPLAY(szStr);
	    hProv = NULL;
	    if (!CryptAcquireContext(
				&hProv,
				NULL,
				NULL,
				PROV_RSA_FULL,
				CRYPT_NEWKEYSET))
	    {
		strcpy(szStr, "CryptAcquireContext - call failed");
		DISPLAY(szStr);
		exit(6);
	    }  
	}
    }

    HANDLE hFile = NULL;

    hFile = CreateFile(
		    pszFileOut,
		    GENERIC_WRITE,
		    0,
		    NULL,
		    CREATE_ALWAYS,
		    FILE_ATTRIBUTE_NORMAL,
		    NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
	printf("Couldn't open output file\n");
	exit(5);
    }

    hCertStore = CertOpenStore(
			CERT_STORE_PROV_MEMORY,
			X509_ASN_ENCODING,
			NULL,			// hProv
			CERT_STORE_NO_CRYPT_RELEASE_FLAG,
			NULL);
    if (NULL == hCertStore)
    {
	exit(8);
    }

    // Declarations for the registry stuff

    HKEY hkMain;
    HRESULT hr;

    hr = RegOpenKeyEx(
		    hKeyBase,
		    szRegPath, 
		    0,
		    KEY_QUERY_VALUE,
		    &hkMain);

    if (hr != S_OK)
    {
	exit(3);
    }

    // Use the RegQueryInfoKey function to determine the maximum size of the
    // name and data buffers, 

    CHAR ClassName[MAX_PATH] = "";	// Buffer for class name.
    DWORD dwcClassLen = MAX_PATH;	// Length of class string.
    DWORD dwcSubKeys;			// Number of sub keys.
    DWORD dwcMaxSubKey;			// Longest sub key size.
    DWORD dwcMaxClass;			// Longest class string.
    DWORD dwcValues;			// Number of values for this key.
    DWORD dwcMaxValueName;		// Longest Value name.
    DWORD dwcMaxValueData;		// Longest Value data.
    DWORD dwcSecDesc;			// Security descriptor.
    FILETIME ftLastWriteTime;		// Last write time.

    RegQueryInfoKey(
		hkMain,			// Key handle.
		ClassName,		// Buffer for class name.
		&dwcClassLen,		// Length of class string.
		NULL,			// Reserved.
		&dwcSubKeys,		// Number of sub keys.
		&dwcMaxSubKey,		// Longest sub key size.
		&dwcMaxClass,		// Longest class string.
		&dwcValues,		// Number of values for this key.
		&dwcMaxValueName,	// Longest Value name.
		&dwcMaxValueData,	// Longest Value data.
		&dwcSecDesc,		// Security descriptor.
		&ftLastWriteTime);	// Last write time

    DWORD i;
    CHAR ValueName[MAX_PATH];
    DWORD dwcValueName;

    // address of buffer for type code (this is returned by RegEnumValue)
    DWORD pType;

    // address of buffer for value data 
    unsigned char *pData = new unsigned char[dwcMaxValueData + 1];

    DWORD pcbData;		// address for size of data buffer 

    for (i = 0; i < dwcValues; i++)
    {
	ValueName[0] = '\0';
	dwcValueName = sizeof(ValueName)/sizeof(ValueName[0]);
	pcbData = dwcMaxValueData + 1;

	hr = RegEnumValue(
			hkMain, 
			i,		// index of value to query
			ValueName,	// address of buffer for value string
			&dwcValueName,	// address for size of value string buf
			NULL,		// reserved
			&pType,		// &pType
			pData,		// pData
			&pcbData);	// &pcbData

	hr = myHError(hr);
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
	    break;
	}
	if (S_OK != hr)
	{
	    exit(2);
	}

	// Display the value name

	ln++;
	strcpy(szStr, ValueName);
	DISPLAY(szStr);

	if (pType == REG_BINARY)
	{                
	    // Write the data which is pointed to by pData, 
	    // count of bytes is gotten from pcbData

	    CertAddEncodedCertificateToStore(
					hCertStore,
					X509_ASN_ENCODING,
					pData,
					pcbData,
					CERT_STORE_ADD_USE_EXISTING,
					NULL);
	}
    }

    // Save

    CertSaveStore(
        hCertStore,
        0,                          // dwEncodingType,
        CERT_STORE_SAVE_AS_STORE,
        CERT_STORE_SAVE_TO_FILE,
        (void *) hFile,
        0                           // dwFlags
        );

    // Close memory store

    CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    if (!CryptReleaseContext(hProv, 0))
    {
	exit(7);
    }
    RegCloseKey(hkMain);
    ln++;
    strcpy(szStr, "CertIE3.exe completed successfully");
    DISPLAY(szStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\cep\setup\setuputil.cpp ===
//--------------------------------------------------------------------
// SetupUtil - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Functions needed to set up CEP
//

//--------------------------------------------------------------------
// includes
#include "global.hxx"
#include <xenroll.h>
#include <dbgdef.h>
#include "ErrorHandling.h"
#include "SetupUtil.h"

//--------------------------------------------------------------------
// Constants
static const WCHAR gc_wszRegKeyServices[]=L"System\\CurrentControlSet\\Services";
static const WCHAR gc_wszCertSrvDir[]=L"CertSrv";

// from <wincrypt.h>
static const WCHAR gc_wszEnrollmentAgentOid[]=L"1.3.6.1.4.1.311.20.2.1"; //szOID_ENROLLMENT_AGENT

// from ca\include\certlib.h; ca\certlib\acl.cpp
const GUID GUID_ENROLL={0x0e10c968, 0x78fb, 0x11d2, {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55}};


//--------------------------------------------------------------------
// IIS magic
#undef DEFINE_GUID
#define INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <iwamreg.h>
#include <iadmw.h>
#include <iiscnfg.h>


//--------------------------------------------------------------------
// constants
#include "..\common.h"
#define MAX_METABASE_ATTEMPTS           10      // Times to bang head on wall
#define METABASE_PAUSE                  500     // Time to pause in msec
#define SERVICE_STOP_MAX_ATTEMPT        2*60*2  // # of half seconds in 2 minutes
#define SERVICE_STOP_HALF_SECOND        500     // # of milliseconds in half second
static const WCHAR gc_wszBaseRoot[]=L"/LM/W3svc/1/ROOT";
static const WCHAR gc_wszCepDllName[]=CEP_DLL_NAME;
static const WCHAR gc_wszCepStoreName[]=CEP_STORE_NAME;

//####################################################################
// module local functions

//--------------------------------------------------------------------
static HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep)
{
    HRESULT hr=pep->ExceptionRecord->ExceptionCode;
    if (!FAILED(hr)) {
        hr=HRESULT_FROM_WIN32(hr);
    }
    return hr;
}

//--------------------------------------------------------------------
static HRESULT
vrOpenRoot(
    IN IMSAdminBase *pIMeta,
    IN BOOL fReadOnly,
    OUT METADATA_HANDLE *phMetaRoot)
{
    HRESULT hr;
    unsigned int nAttempts;

    // Re-try a few times to see if we can get past the block
    nAttempts=0;
    do {

        // Pause on retry
        if (0!=nAttempts) {
            Sleep(METABASE_PAUSE);
        }

        // Make an attempt to open the root
        __try {
            hr=pIMeta->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                gc_wszBaseRoot,
                fReadOnly?
                    METADATA_PERMISSION_READ :
                    (METADATA_PERMISSION_READ |
                     METADATA_PERMISSION_WRITE),
                1000,
                phMetaRoot);
        } _TrapException(hr);

        nAttempts++;

    } while (HRESULT_FROM_WIN32(ERROR_PATH_BUSY)==hr && nAttempts<MAX_METABASE_ATTEMPTS);

    _JumpIfError(hr, error, "OpenKey"); 

error:
    return hr;
}

//--------------------------------------------------------------------
static HRESULT GetRegString(IN HKEY hKey, IN const WCHAR * wszValue, OUT WCHAR ** pwszString)
{
    HRESULT hr;
    DWORD dwDataSize;
    DWORD dwType;
    DWORD dwError;

    // must be cleaned up
    WCHAR * wszString=NULL;

    // init out params
    *pwszString=NULL;

    // get value
    dwDataSize=0;
    dwError=RegQueryValueExW(hKey, wszValue, NULL, &dwType, NULL, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszValue);
    }
    _Verify(REG_SZ==dwType, hr, error);
    wszString=(WCHAR *)LocalAlloc(LPTR, dwDataSize);
    _JumpIfOutOfMemory(hr, error, pwszString);
    dwError=RegQueryValueExW(hKey, wszValue, NULL, &dwType, (BYTE *)wszString, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszValue);
    }
    _Verify(REG_SZ==dwType, hr, error);

    // it worked
    hr=S_OK;
    *pwszString=wszString;
    wszString=NULL;

error:
    if (NULL!=wszString) {
        LocalFree(wszString);
    }
    return hr;
}

//--------------------------------------------------------------------
static HRESULT OpenCertSrvConfig(HKEY * phkey)
{
    HRESULT hr;
    DWORD dwError;
    DWORD dwType;
    DWORD dwDataSize;

    // must be cleaned up
    HKEY hServices=NULL;
    HKEY hCertSvc=NULL;
    HKEY hConfig=NULL;

    // initialize out params
    *phkey=NULL;

    // Open HKLM\System\CurrentControlSet\Services
    dwError=RegOpenKeyExW(HKEY_LOCAL_MACHINE, gc_wszRegKeyServices, 0, KEY_READ, &hServices);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", gc_wszRegKeyServices);
    }

    // open CertSvc\Configuration
    dwError=RegOpenKeyExW(hServices, wszSERVICE_NAME, 0, KEY_READ, &hCertSvc);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszSERVICE_NAME);
    }
    dwError=RegOpenKeyExW(hCertSvc, wszREGKEYCONFIG, 0, KEY_READ, &hConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszREGKEYCONFIG);
    }

    // we were successfull
    hr=S_OK;
    *phkey=hConfig;
    hConfig=0;

error:
    if (NULL!=hConfig) {
        RegCloseKey(hConfig);
    }
    if (NULL!=hCertSvc) {
        RegCloseKey(hCertSvc);
    }
    if (NULL!=hServices) {
        RegCloseKey(hServices);
    }
    return hr;
}

//--------------------------------------------------------------------
static HRESULT OpenCurrentCAConfig(HKEY * phkey)
{
    HRESULT hr;
    DWORD dwError;
    DWORD dwType;
    DWORD dwDataSize;

    // must be cleaned up
    HKEY hConfig=NULL;
    HKEY hCurConfig=NULL;
    WCHAR * wszActiveConfig=NULL;

    // initialize out params
    *phkey=NULL;

    // Open HKLM\System\CurrentControlSet\Services\CertSvc\Configuration
    hr=OpenCertSrvConfig(&hConfig);
    _JumpIfError(hr, error, "OpenCertSrvConfig");

    // get value "active"
    hr=GetRegString(hConfig, wszREGACTIVE, &wszActiveConfig);
    _JumpIfErrorStr(hr, error, "GetRegString", wszREGACTIVE);

    // and open <active>
    dwError=RegOpenKeyExW(hConfig, wszActiveConfig, 0, KEY_ALL_ACCESS, &hCurConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszActiveConfig);
    }

    // we were successfull
    hr=S_OK;
    *phkey=hCurConfig;
    hCurConfig=0;

error:
    if (NULL!=hCurConfig) {
        RegCloseKey(hCurConfig);
    }
    if (NULL!=wszActiveConfig) {
        LocalFree(wszActiveConfig);
    }
    if (NULL!=hConfig) {
        RegCloseKey(hConfig);
    }
    return hr;
}


//--------------------------------------------------------------------
static HRESULT GetLocalConfigString(OUT WCHAR ** pwszConfigString)
{
    HRESULT hr;

    // must be cleaned up
    HKEY hCurConfig=NULL;
    WCHAR * wszComputerName=NULL;
    WCHAR * wszCAName=NULL;
    WCHAR * wszConfigString=NULL;

    // init out params
    *pwszConfigString=NULL;

    // get the CA's registry key
    hr=OpenCurrentCAConfig(&hCurConfig);
    _JumpIfError(hr, error, "OpenCurrentCAConfig");

    // get info from the registry
    hr=GetRegString(hCurConfig, wszREGCASERVERNAME, &wszComputerName);
    _JumpIfErrorStr(hr, error, "GetRegString", wszREGCASERVERNAME);

    hr=GetRegString(hCurConfig, wszREGCOMMONNAME, &wszCAName);
    _JumpIfErrorStr(hr, error, "GetRegString", wszREGCOMMONNAME);

    // build the config string
    wszConfigString=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszComputerName)+1+wcslen(wszCAName)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszConfigString);

    wcscpy(wszConfigString, wszComputerName);
    wcscat(wszConfigString, L"\\");
    wcscat(wszConfigString, wszCAName);

    // it worked
    hr=S_OK;
    *pwszConfigString=wszConfigString;
    wszConfigString=NULL;

error:
    if (NULL!=wszComputerName) {
        LocalFree(wszComputerName);
    }
    if (NULL!=wszCAName) {
        LocalFree(wszCAName);
    }
    if (NULL!=hCurConfig) {
        RegCloseKey(hCurConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
// stolen from certlib.cpp. use this until Pete fixes the api.
static HRESULT GetCADsName(OUT WCHAR **pwszName)
{
#define cwcCNMAX        64              // 64 chars max for CN
#define cwcCHOPHASHMAX  (1+5)           // "-%05hu" decimal USHORT hash digits
#define cwcSUFFIXMAX    (1 + 5 + 1)     // five decimal digits plus parentheses
#define cwcCHOPBASE     (cwcCNMAX-(cwcCHOPHASHMAX+cwcSUFFIXMAX))

    HRESULT hr;
    DWORD cwc;
    DWORD cwcCopy;
    WCHAR wszDSName[cwcCHOPBASE+cwcCHOPHASHMAX+1];

    // must be cleaned up
    HKEY hConfig=NULL;
    WCHAR * wszSanitizedName=NULL;

    // initialize out params
    *pwszName=NULL;

    // Open HKLM\System\CurrentControlSet\Services\CertSvc\Configuration
    hr=OpenCertSrvConfig(&hConfig);
    _JumpIfError(hr, error, "OpenCertSrvConfig");

    // get value "active" - this is the sanitized name
    hr=GetRegString(hConfig, wszREGACTIVE, &wszSanitizedName);
    _JumpIfErrorStr(hr, error, "GetRegString", wszREGACTIVE);


    // ----- begin stolen code -----
    cwc = wcslen(wszSanitizedName);
    cwcCopy = cwc;
    if (cwcCHOPBASE < cwcCopy)
    {
        cwcCopy = cwcCHOPBASE;
    }
    CopyMemory(wszDSName, wszSanitizedName, cwcCopy * sizeof(WCHAR));
    wszDSName[cwcCopy] = L'\0';

    if (cwcCHOPBASE < cwc)
    {
        // Hash the rest of the name into a USHORT
        USHORT usHash = 0;
        DWORD i;
        WCHAR *pwsz;

        // Truncate an incomplete sanitized Unicode character
        
        pwsz = wcsrchr(wszDSName, L'!');
        if (NULL != pwsz && wcslen(pwsz) < 5)
        {
            cwcCopy -= wcslen(pwsz);
            *pwsz = L'\0';
        }

        for (i = cwcCopy; i < cwc; i++)
        {
            USHORT usLowBit = (0x8000 & usHash)? 1 : 0;

            usHash = ((usHash << 1) | usLowBit) + wszSanitizedName[i];
        }
        wsprintf(&wszDSName[cwcCopy], L"-%05hu", usHash);
        //CSASSERT(wcslen(wszDSName) < ARRAYSIZE(wszDSName));
    }
    // ----- end stolen code -----

    *pwszName=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszDSName)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *pwszName);
    wcscpy(*pwszName, wszDSName);

    hr=S_OK;
error:
    if (NULL!=wszSanitizedName) {
        LocalFree(wszSanitizedName);
    }
    if (NULL!=hConfig) {
        RegCloseKey(hConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
static HRESULT EnrollForRACert(
            IN const WCHAR * wszDistinguishedName,
            IN const WCHAR * wszCSPName,
            IN DWORD dwCSPType,
            IN DWORD dwKeySize,
            IN DWORD dwKeySpec,
            IN const WCHAR * wszTemplate
            )
{
    HRESULT hr;
    LONG nDisposition;
    LONG nRequestID;

    // must be cleaned up
    ICEnroll3 * pXEnroll=NULL;
    WCHAR * wszConfigString=NULL;
    BSTR bszRequest=NULL;
    ICertRequest * pICertRequest=NULL;
    ICertAdmin * pICertAdmin=NULL;
    BSTR bszCertificate=NULL;

    // get the config string
    hr=GetLocalConfigString(&wszConfigString);
    _JumpIfError(hr, error, "GetLocalConfigString");

    // create XEnroll
    hr=CoCreateInstance(
        CLSID_CEnroll,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICEnroll3,
        (void **)&pXEnroll);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_CEnroll)");

    // build the Offline enrollment agent cert.

    hr=pXEnroll->put_ProviderName((WCHAR *)wszCSPName);
    _JumpIfError(hr, error, "put_ProviderName");
    hr=pXEnroll->put_ProviderType(dwCSPType);
    _JumpIfError(hr, error, "put_ProviderType");
    hr=pXEnroll->put_ProviderFlags(CRYPT_MACHINE_KEYSET); // used in CryptAcquireContext
    _JumpIfError(hr, error, "put_ProviderFlags");
    hr=pXEnroll->put_GenKeyFlags(dwKeySize<<16);
    _JumpIfError(hr, error, "put_GenKeyFlags");
    hr=pXEnroll->put_KeySpec(dwKeySpec);
    _JumpIfError(hr, error, "put_KeySpec");
    hr=pXEnroll->put_LimitExchangeKeyToEncipherment(AT_KEYEXCHANGE==dwKeySpec);
    _JumpIfError(hr, error, "put_LimitExchangeKeyToEncipherment");
    hr=pXEnroll->put_UseExistingKeySet(FALSE);
    _JumpIfError(hr, error, "put_UseExistingKeySet");
    hr=pXEnroll->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE); // the keys attached to the dummy request cert go in the local machine store
    _JumpIfError(hr, error, "put_RequestStoreFlags");
    hr=pXEnroll->addCertTypeToRequest((WCHAR *)wszTemplate);
    _JumpIfErrorStr(hr, error, "addCertTypeToRequest", wszTemplate);

    hr=pXEnroll->createPKCS10((WCHAR *)wszDistinguishedName, (WCHAR *)gc_wszEnrollmentAgentOid, &bszRequest);
    _JumpIfError(hr, error, "CreatePKCS10");

    // create ICertRequest
    hr=CoCreateInstance(
        CLSID_CCertRequest,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICertRequest,
        (void **)&pICertRequest);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_CCertRequest)");

    // request the cert
    hr=pICertRequest->Submit(CR_IN_BASE64, bszRequest, L""/*Attributes*/, wszConfigString, &nDisposition);
    _JumpIfError(hr, error, "Submit");

    // did we get it?
    if (CR_DISP_UNDER_SUBMISSION==nDisposition) {
        // we need to approve it. No problem!
        hr=pICertRequest->GetRequestId(&nRequestID);
        _JumpIfError(hr, error, "GetRequestId");

        // create ICertAdmin
        hr=CoCreateInstance(
            CLSID_CCertAdmin,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_ICertAdmin,
            (void **)&pICertAdmin);
        _JumpIfError(hr, error, "CoCreateInstance(CLSID_CCertAdmin)");

        // resubmit it
        hr=pICertAdmin->ResubmitRequest(wszConfigString, nRequestID, &nDisposition);
        _JumpIfError(hr, error, "ResubmitRequest");
        // This should have worked, but we're going to ignore the 
        //   returned disposition and use the one from the next call.

        // now, get the cert that we just approved
        hr=pICertRequest->RetrievePending(nRequestID, wszConfigString, &nDisposition);
        _JumpIfError(hr, error, "RetrievePending");
    }

    // We should have it by now.
    _Verify(CR_DISP_ISSUED==nDisposition, hr, error);

    // grab the cert from the CA
    hr=pICertRequest->GetCertificate(CR_OUT_BASE64, &bszCertificate);
    _JumpIfError(hr, error, "GetCertificate");


    // install the cert

    
    hr=pXEnroll->put_MyStoreName((WCHAR *)gc_wszCepStoreName); // We have to use our special store
    _JumpIfError(hr, error, "put_MyStoreName");
    hr=pXEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE); // the keys attached to the final cert also go in the local machine store
    _JumpIfError(hr, error, "put_MyStoreFlags");
    hr=pXEnroll->put_RootStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);
    _JumpIfError(hr, error, "put_RootStoreFlags");
    hr=pXEnroll->put_CAStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);
    _JumpIfError(hr, error, "put_CAStoreFlags");
    hr=pXEnroll->put_SPCFileName(L"");
    _JumpIfError(hr, error, "put_MyStoreName");

    hr=pXEnroll->acceptPKCS7(bszCertificate);
    _JumpIfError(hr, error, "acceptPKCS7");


    // all done
    hr=S_OK;
error:
    if (NULL!=bszCertificate) {
        SysFreeString(bszCertificate);
    }
    if (NULL!=pICertAdmin) {
        pICertAdmin->Release();
    }
    if (NULL!=pICertRequest) {
        pICertRequest->Release();
    }
    if (NULL!=bszRequest) {
        SysFreeString(bszRequest);
    }
    if (NULL!=wszConfigString) {
        LocalFree(wszConfigString);
    }
    if (NULL!=pXEnroll) {
        pXEnroll->Release();
    }

    return hr;
}

//--------------------------------------------------------------------
// DEBUG, not used
static BOOL DumpTokenGroups(void)
{
#define MAX_NAME 256
    DWORD i, dwSize = 0, dwResult = 0;
    HANDLE hToken;
    PTOKEN_GROUPS pGroupInfo;
    SID_NAME_USE SidType;
    char lpName[MAX_NAME];
    char lpDomain[MAX_NAME];
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
   
    // Open a handle to the access token for the calling process.

    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken )) {
        printf( "OpenProcessToken Error %u\n", GetLastError() );
        return FALSE;
    }

    // Call GetTokenInformation to get the buffer size.

    if(!GetTokenInformation(hToken, TokenGroups, NULL, dwSize, &dwSize)) {
        dwResult = GetLastError();
        if( dwResult != ERROR_INSUFFICIENT_BUFFER ) {
            printf( "GetTokenInformation Error %u\n", dwResult );
            return FALSE;
        }
    }

    // Allocate the buffer.

    pGroupInfo = (PTOKEN_GROUPS) GlobalAlloc( GPTR, dwSize );

    // Call GetTokenInformation again to get the group information.

    if(! GetTokenInformation(hToken, TokenGroups, pGroupInfo, 
                            dwSize, &dwSize ) ) {
        printf( "GetTokenInformation Error %u\n", GetLastError() );
        return FALSE;
       }


    // Loop through the group SIDs looking for the administrator SID.
    for(i=0; i<pGroupInfo->GroupCount; i++) {

        // Lookup the account name and print it.

        dwSize = MAX_NAME;
        if( !LookupAccountSidA( NULL, pGroupInfo->Groups[i].Sid,
                              lpName, &dwSize, lpDomain, 
                              &dwSize, &SidType ) ) {
            dwResult = GetLastError();
            if( dwResult == ERROR_NONE_MAPPED )
                strcpy( lpName, "NONE_MAPPED" );
            else {
                printf("LookupAccountSid Error %u\n", GetLastError());
                return FALSE;
            }
        }

        char * szSid=NULL;
        if (!ConvertSidToStringSidA(pGroupInfo->Groups[i].Sid, &szSid)) {
            printf("ConvertSidToStringSid Error %u\n", GetLastError());
            return FALSE;
        }
 
        // Find out if the SID is enabled in the token
        char * szEnable;
        if (pGroupInfo->Groups[i].Attributes & SE_GROUP_ENABLED) {
            szEnable="enabled";
        } else if (pGroupInfo->Groups[i].Attributes & SE_GROUP_USE_FOR_DENY_ONLY) {
            szEnable="deny-only";
        } else {
            szEnable="not enabled";
        }

        printf( "Member of %s\\%s (%s) (%s)\n", 
                lpDomain, lpName, szSid, szEnable );

        LocalFree(szSid);
    }

    if ( pGroupInfo )
        GlobalFree( pGroupInfo );
    return TRUE;
}

//--------------------------------------------------------------------
// DEBUG, not used
static void DumpAcl(PACL pAcl, ACL_SIZE_INFORMATION aclsizeinfo)
{
    HRESULT hr;
    unsigned int nIndex;
    DWORD dwError;

    wprintf(L"/-- begin ACL ---\n");
    for (nIndex=0; nIndex<aclsizeinfo.AceCount; nIndex++) {
        ACE_HEADER * pAceHeader;
        PSID pSid=NULL;
        wprintf(L"| ");
        if (!GetAce(pAcl, nIndex, (void**)&pAceHeader)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            wprintf(L" (GetAce failed:0x%08X)\n", hr);
            continue;
        }
        wprintf(L"[");
        if (ACCESS_ALLOWED_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aA_");
            pSid=&((ACCESS_ALLOWED_ACE *)pAceHeader)->SidStart;
        } else if (ACCESS_DENIED_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aD_");
            pSid=&((ACCESS_DENIED_ACE *)pAceHeader)->SidStart;
        } else if (ACCESS_ALLOWED_OBJECT_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aAo");
            pSid=&((ACCESS_ALLOWED_OBJECT_ACE *)pAceHeader)->SidStart;
            if (((ACCESS_ALLOWED_OBJECT_ACE *)pAceHeader)->Flags!=(ACE_OBJECT_TYPE_PRESENT|ACE_INHERITED_OBJECT_TYPE_PRESENT)) {
                pSid=((BYTE *)pSid)-sizeof(GUID);
            }
        } else if (ACCESS_DENIED_OBJECT_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aDo");
            pSid=&((ACCESS_DENIED_OBJECT_ACE *)pAceHeader)->SidStart;
            if (((ACCESS_DENIED_OBJECT_ACE *)pAceHeader)->Flags!=(ACE_OBJECT_TYPE_PRESENT|ACE_INHERITED_OBJECT_TYPE_PRESENT)) {
                pSid=((BYTE *)pSid)-sizeof(GUID);
            }
        } else {
            wprintf(L"sa?");
        }

        wprintf(L"] ");
        if (NULL!=pSid) {
            // print the sid
            {
                WCHAR wszName[MAX_NAME];
                WCHAR wszDomain[MAX_NAME];
                DWORD dwSize=MAX_NAME;
                SID_NAME_USE SidType;
                if(!LookupAccountSidW(
                        NULL, pSid,
                        wszName, &dwSize, wszDomain, 
                        &dwSize, &SidType))
                {
                    dwError=GetLastError();
                    if (dwError==ERROR_NONE_MAPPED) {
                        wprintf(L"(Unknown)");
                    } else {
                        hr=HRESULT_FROM_WIN32(dwError);
                        wprintf(L"(Error 0x%08X)", hr);
                    }
                } else {
                    wprintf(L"%s\\%s", wszDomain, wszName);
                }
            }
            { 
                WCHAR * wszSid=NULL;
                if (!ConvertSidToStringSidW(pSid, &wszSid)) {
                    hr=HRESULT_FROM_WIN32(GetLastError());
                    wprintf(L"(Error 0x%08X)", hr);
                } else {
                    wprintf(L" %s", wszSid);
                    LocalFree(wszSid);
                }
            }
        }
        wprintf(L"\n");
    
    }
    wprintf(L"\\-- end ACL ---\n");
}

//--------------------------------------------------------------------
static HRESULT GetRootDomEntitySid(SID ** ppSid, DWORD dwEntityRid)
{
    HRESULT hr;
    NET_API_STATUS nasError;
    unsigned int nSubAuthorities;
    unsigned int nSubAuthIndex;

    // must be cleaned up
    SID * psidRootDomEntity=NULL;
    USER_MODALS_INFO_2 * pumi2=NULL;
    DOMAIN_CONTROLLER_INFOW * pdci=NULL;
    DOMAIN_CONTROLLER_INFOW * pdciForest=NULL;

    // initialize out params
    *ppSid=NULL;


    // get the forest name
    nasError=DsGetDcNameW(NULL, NULL, NULL, NULL, 0, &pdciForest);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        _JumpError(hr, error, "DsGetDcNameW");
    }

    // get the top level DC name
    nasError=DsGetDcNameW(NULL, pdciForest->DnsForestName, NULL, NULL, 0, &pdci);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        _JumpError(hr, error, "DsGetDcNameW");
    }

    // get the domain Sid on the top level DC.
    nasError=NetUserModalsGet(pdci->DomainControllerName, 2, (LPBYTE *)&pumi2);
    if(NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        _JumpError(hr, error, "NetUserModalsGet");
    }

    nSubAuthorities=*GetSidSubAuthorityCount(pumi2->usrmod2_domain_id);

    // allocate storage for new Sid. account domain Sid + account Rid
    psidRootDomEntity=(SID *)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(nSubAuthorities+1)));
    _JumpIfOutOfMemory(hr, error, psidRootDomEntity);

    // copy the first few peices into the SID
    if (!InitializeSid(psidRootDomEntity, 
            GetSidIdentifierAuthority(pumi2->usrmod2_domain_id), 
            (BYTE)(nSubAuthorities+1)))
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "InitializeSid");
    }

    // copy existing subauthorities from account domain Sid into new Sid
    for (nSubAuthIndex=0; nSubAuthIndex < nSubAuthorities ; nSubAuthIndex++) {
        *GetSidSubAuthority(psidRootDomEntity, nSubAuthIndex)=
            *GetSidSubAuthority(pumi2->usrmod2_domain_id, nSubAuthIndex);
    }

    // append Rid to new Sid
    *GetSidSubAuthority(psidRootDomEntity, nSubAuthorities)=dwEntityRid;

    *ppSid=psidRootDomEntity;
    psidRootDomEntity=NULL;
    hr=S_OK;

error:
    if (NULL!=psidRootDomEntity) {
        FreeSid(psidRootDomEntity);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdci);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdciForest);
    }
    if (NULL!=pumi2) {
        NetApiBufferFree(pumi2);
    }

    return hr;
}

//--------------------------------------------------------------------
static HRESULT GetEntAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS);
}

//--------------------------------------------------------------------
static HRESULT GetRootDomAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ADMINS);
}

//--------------------------------------------------------------------
static HRESULT GetThisComputerSid(SID ** ppSid)
{
    HRESULT hr;
    DWORD cchSize;
    DWORD dwSidSize;
    DWORD dwDomainSize;
    SID_NAME_USE snu;

    // must be cleaned up
    SID * psidThisComputer=NULL;
    WCHAR * wszName=NULL;
    WCHAR * wszDomain=NULL;

    // initialize out params
    *ppSid=NULL;

    // get the size of the computer's name
    cchSize=0;
    _Verify(!GetComputerObjectNameW(NameSamCompatible, NULL, &cchSize), hr, error);
    if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetComputerObjectNameW");
    }

	// bug in GetComputerObjectNameW
	cchSize++;

    // allocate memory
    wszName=(WCHAR *)LocalAlloc(LPTR, cchSize*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszName);

    // get the computer's name
    if (!GetComputerObjectNameW(NameSamCompatible, wszName, &cchSize)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetComputerObjectNameW");
    }

    // get the size of the sid
    dwSidSize=0;
    dwDomainSize=0;
    _Verify(!LookupAccountNameW(NULL, wszName, NULL, &dwSidSize, NULL, &dwDomainSize, &snu), hr, error);
    if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "LookupAccountNameW");
    }

    // allocate memory
    wszDomain=(WCHAR *)LocalAlloc(LPTR, dwDomainSize*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszDomain);
    psidThisComputer=(SID *)LocalAlloc(LPTR, dwSidSize);
    _JumpIfOutOfMemory(hr, error, psidThisComputer);
    
    // get the sid
    if (!LookupAccountNameW(NULL, wszName, psidThisComputer, &dwSidSize, wszDomain, &dwDomainSize, &snu)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "LookupAccountNameW");
    }

    // success!
    *ppSid=psidThisComputer;
    psidThisComputer=NULL;
    hr=S_OK;

error:
    if (NULL!=psidThisComputer) {
        LocalFree(psidThisComputer);
    }
    if (NULL!=wszName) {
        LocalFree(wszName);
    }
    if (NULL!=wszDomain) {
        LocalFree(wszDomain);
    }

    return hr;

}


//--------------------------------------------------------------------
static HRESULT ConfirmAccess(PSECURITY_DESCRIPTOR * ppSD, SID * pTrustworthySid, BOOL * pbSDChanged)
{
    //define ENROLL_ACCESS_MASK (0x130)
    HRESULT hr;
    PACL pAcl;
    BOOL bAclPresent;
    BOOL bDefaultAcl;
    unsigned int nIndex;
    ACL_SIZE_INFORMATION aclsizeinfo;
    bool bSidInAcl;

    // must be cleaned up
    PSECURITY_DESCRIPTOR pAbsSD=NULL;
    ACL * pAbsDacl=NULL;
    ACL * pAbsSacl=NULL;
    SID * pAbsOwner=NULL;
    SID * pAbsPriGrp=NULL;
    ACL * pNewDacl=NULL;
    PSECURITY_DESCRIPTOR pNewSD=NULL;

    // initialize out params
    *pbSDChanged=FALSE;

    // get the (D)ACL from the security descriptor
    if (!GetSecurityDescriptorDacl(*ppSD, &bAclPresent, &pAcl, &bDefaultAcl)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }
    _Verify(bAclPresent, hr, error);
    if (NULL==pAcl) {
        // NULL acl -> allow all access
        goto success;
    }

    // find out how many ACEs
    if (!GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetAclInformation");
    }

    //DumpAcl(pAcl,aclsizeinfo);

    // find our sid in the acl
    bSidInAcl=false;
    for (nIndex=0; nIndex<aclsizeinfo.AceCount; nIndex++) {
        ACE_HEADER * pAceHeader;
        ACCESS_ALLOWED_OBJECT_ACE * pAccessAce;
        PSID pSid=NULL;
        if (!GetAce(pAcl, nIndex, (void**)&pAceHeader)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetAce");
        }

        // find the sid for this ACE
        if (ACCESS_ALLOWED_OBJECT_ACE_TYPE!=pAceHeader->AceType && ACCESS_DENIED_OBJECT_ACE_TYPE!=pAceHeader->AceType) {
            // we are only interested in OBJECT ace types
            continue;
        }

        // note that ACCESS_ALLOWED_OBJECT_ACE and ACCESS_DENIED_OBJECT_ACE are the same structurally.
        pAccessAce=(ACCESS_ALLOWED_OBJECT_ACE *)pAceHeader;
        _Verify(ACE_OBJECT_TYPE_PRESENT==pAccessAce->Flags, hr, error);
        pSid=((BYTE *)&pAccessAce->SidStart)-sizeof(GUID);

        // confirm the GUID
        if (!IsEqualGUID(pAccessAce->ObjectType, GUID_ENROLL)) {
            continue;
        }

        // make sure this is the sid we are looking for
        if (!EqualSid(pSid, pTrustworthySid)) {
            continue;
        }

        // Was this a denial?
        if (ACCESS_DENIED_OBJECT_ACE_TYPE==pAceHeader->AceType) {
            // It's not anymore!
            pAceHeader->AceType=ACCESS_ALLOWED_OBJECT_ACE_TYPE;
            *pbSDChanged=TRUE;
        }

        // is the mask wrong?
        if (0==(pAccessAce->Mask&ACTRL_DS_CONTROL_ACCESS)) {
            // It's not anymore!
            pAccessAce->Mask|=ACTRL_DS_CONTROL_ACCESS;
            *pbSDChanged=TRUE;
        }

        // The sid is now in the acl and set to allow access.
        bSidInAcl=true;
        break;
    }

    // Was the sid in the acl?
    if (false==bSidInAcl) {
        SECURITY_DESCRIPTOR_CONTROL sdcon;
        DWORD dwRevision;
        DWORD dwNewAclSize;
        DWORD dwAbsSDSize=0;
        DWORD dwDaclSize=0;
        DWORD dwSaclSize=0;
        DWORD dwOwnerSize=0;
        DWORD dwPriGrpSize=0;
        ACE_HEADER * pFirstAce;
        DWORD dwRelSDSize=0;

        // we have to be self-relative
        if (!GetSecurityDescriptorControl(*ppSD, &sdcon, &dwRevision)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetSecurityDescriptorControl");
        }
        _Verify(sdcon&SE_SELF_RELATIVE, hr, error);

        // get the sizes
        _Verify(!MakeAbsoluteSD(*ppSD, NULL, &dwAbsSDSize, NULL, &dwDaclSize, NULL, &dwSaclSize, NULL,  &dwOwnerSize, NULL, &dwPriGrpSize), hr, error);
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeAbsoluteSD");
        }

        // allocate memory
        pAbsSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwAbsSDSize);
        _JumpIfOutOfMemory(hr, error, pAbsSD);
        pAbsDacl=(ACL * )LocalAlloc(LPTR, dwDaclSize);
        _JumpIfOutOfMemory(hr, error, pAbsDacl);
        pAbsSacl=(ACL * )LocalAlloc(LPTR, dwSaclSize);
        _JumpIfOutOfMemory(hr, error, pAbsSacl);
        pAbsOwner=(SID *)LocalAlloc(LPTR, dwOwnerSize);
        _JumpIfOutOfMemory(hr, error, pAbsOwner);
        pAbsPriGrp=(SID *)LocalAlloc(LPTR, dwPriGrpSize);
        _JumpIfOutOfMemory(hr, error, pAbsPriGrp);

        // copy the SD to the memory buffers
        if (!MakeAbsoluteSD(*ppSD, pAbsSD, &dwAbsSDSize, pAbsDacl, &dwDaclSize, pAbsSacl, &dwSaclSize, pAbsOwner,  &dwOwnerSize, pAbsPriGrp, &dwPriGrpSize)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeAbsoluteSD");
        }
        
        // get the current size info for the dacl
        if (!GetAclInformation(pAbsDacl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetAclInformation");
        }

        // figure out the new size
        dwNewAclSize=aclsizeinfo.AclBytesInUse+sizeof(_ACCESS_ALLOWED_OBJECT_ACE)
            -sizeof(GUID) //ACCESS_ALLOWED_OBJECT_ACE::InheritedObjectType
            -sizeof(DWORD) //ACCESS_ALLOWED_OBJECT_ACE::SidStart
            +GetLengthSid(pTrustworthySid);
    
        // allocate memory
        pNewDacl=(ACL *)LocalAlloc(LPTR, dwNewAclSize);
        _JumpIfOutOfMemory(hr, error, pNewDacl);
    
        // init the header
        if (!InitializeAcl(pNewDacl, dwNewAclSize, ACL_REVISION_DS)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "InitializeAcl");
        }

        // find the first ace in the dacl
        if (!GetAce(pAbsDacl, 0, (void **)&pFirstAce)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetAce");
        }

        // add all the old aces
        if (!AddAce(pNewDacl, ACL_REVISION_DS, 0, pFirstAce, aclsizeinfo.AclBytesInUse-sizeof(ACL))) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "AddAce");
        }

        // finally, add the new acl
        if (!AddAccessAllowedObjectAce(pNewDacl, ACL_REVISION_DS, OBJECT_INHERIT_ACE, ACTRL_DS_CONTROL_ACCESS, (GUID *)&GUID_ENROLL, NULL, pTrustworthySid)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "AddAccessAllowedObjectAce");
        }

        // stick the new dacl in the sd
        if (!SetSecurityDescriptorDacl(pAbsSD, TRUE, pNewDacl, FALSE)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "SetSecurityDescriptorDacl");
        }

        // compact everything back together
        // get the size
        _Verify(!MakeSelfRelativeSD(pAbsSD, NULL, &dwRelSDSize), hr, error);
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeSelfRelativeSD");
        }

        // allocate memory
        pNewSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwRelSDSize);
        _JumpIfOutOfMemory(hr, error, pNewSD);

        // copy the SD to the new memory buffer
        if (!MakeSelfRelativeSD(pAbsSD, pNewSD, &dwRelSDSize)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeSelfRelativeSD");
        }

        // Whew! We made it!
        LocalFree(*ppSD);
        *ppSD=pNewSD;
        pNewSD=NULL;
        *pbSDChanged=TRUE;

    } // <- end if sid not in acl

    _Verify(IsValidSecurityDescriptor(*ppSD), hr, error);

success:
    hr=S_OK;

error:
    if (NULL!=pNewSD) {
        LocalFree(pNewSD);
    }
    if (NULL!=pNewDacl) {
        LocalFree(pNewDacl);
    }
    if (NULL!=pAbsSD) {
        LocalFree(pAbsSD);
    }
    if (NULL!=pAbsDacl) {
        LocalFree(pAbsDacl);
    }
    if (NULL!=pAbsSacl) {
        LocalFree(pAbsSacl);
    }
    if (NULL!=pAbsOwner) {
        LocalFree(pAbsOwner);
    }
    if (NULL!=pAbsPriGrp) {
        LocalFree(pAbsPriGrp);
    }
    return hr;
}

//####################################################################
// public functions

//--------------------------------------------------------------------
BOOL IsNT5(void)
{
    HRESULT hr;
    OSVERSIONINFO ovi;
    static BOOL s_fDone=FALSE;
    static BOOL s_fNT5=FALSE;

    if (!s_fDone) {

        s_fDone=TRUE;

        // get and confirm platform info
        ovi.dwOSVersionInfoSize = sizeof(ovi);
        if (!GetVersionEx(&ovi)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetVersionEx");
        }
        if (VER_PLATFORM_WIN32_NT!=ovi.dwPlatformId) {
            hr=ERROR_CANCELLED;
            _JumpError(hr, error, "Not a supported OS");
        }
        if (5<=ovi.dwMajorVersion) {
            s_fNT5=TRUE;
        }
    }

error:
    return s_fNT5;
}

//--------------------------------------------------------------------
BOOL IsIISInstalled(void)
{
    HRESULT hr;

    // must be cleaned up
    IMSAdminBase * pIMeta=NULL;

    hr=CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pIMeta);
    if (FAILED(hr)) {
        _IgnoreError(hr, "CoCreateInstance(CLSID_MSAdminBase)");
    }

//error:
    if (NULL!=pIMeta) {
        pIMeta->Release();
    }

    return (S_OK==hr);
}

//--------------------------------------------------------------------
HRESULT AddVDir(IN const WCHAR * wszDirectory)
{

    HRESULT hr;
    METADATA_RECORD mr;
    DWORD dwAccessPerms;
    DWORD dwAuthenticationType;
    const WCHAR * wszKeyType=IIS_CLASS_WEB_VDIR_W;
    WCHAR wszSysDirBuf[MAX_PATH];

    // must be cleaned up
    IMSAdminBase * pIMeta=NULL;
    IWamAdmin * pIWam=NULL;
    METADATA_HANDLE hMetaRoot=NULL;
    METADATA_HANDLE hMetaKey=NULL;
    WCHAR * wszPhysicalPath=NULL;           // "c:\winnt\system32\certsrv\mscep"
    WCHAR * wszRelativeVirtualPath=NULL;    // "certsrv/mscep"
    WCHAR * wszFullVirtualPath=NULL;        // "/LM/W3svc/1/ROOT/certsrv/mscep"
    
    // build the directories
    if (FALSE==GetSystemDirectoryW(wszSysDirBuf, MAX_PATH)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetSystemDirectory");
    }

    wszPhysicalPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszSysDirBuf)+1+wcslen(gc_wszCertSrvDir)+1+wcslen(wszDirectory)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszPhysicalPath);
    wcscpy(wszPhysicalPath, wszSysDirBuf);
    wcscat(wszPhysicalPath, L"\\");
    wcscat(wszPhysicalPath, gc_wszCertSrvDir);
    wcscat(wszPhysicalPath, L"\\");
    wcscat(wszPhysicalPath, wszDirectory);

    wszRelativeVirtualPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(gc_wszCertSrvDir)+1+wcslen(wszDirectory)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszRelativeVirtualPath);
    wcscpy(wszRelativeVirtualPath, gc_wszCertSrvDir);
    wcscat(wszRelativeVirtualPath, L"/");
    wcscat(wszRelativeVirtualPath, wszDirectory);

    wszFullVirtualPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(gc_wszBaseRoot)+1+wcslen(wszRelativeVirtualPath)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszFullVirtualPath);
    wcscpy(wszFullVirtualPath, gc_wszBaseRoot);
    wcscat(wszFullVirtualPath, L"/");
    wcscat(wszFullVirtualPath, wszRelativeVirtualPath);


    // Create an instance of the metabase object
    hr=CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_MSAdminBase)");

    // open the top level
    hr=vrOpenRoot(pIMeta, FALSE/*not read-only*/, &hMetaRoot);
    _JumpIfError(hr, error, "vrOpenRoot");

    // Add new VDir called gc_wszVRootName
    __try {
        hr=pIMeta->AddKey(hMetaRoot, wszRelativeVirtualPath);
    } _TrapException(hr);
    if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)==hr) {
        // That's fine.
        _IgnoreError(hr, "AddKey");
    } else {
        _JumpIfErrorStr(hr, error, "AddKey", wszRelativeVirtualPath);
    }

    // close the root key
    __try {
        hr=pIMeta->CloseKey(hMetaRoot);
    } _TrapException(hr);
    hMetaRoot=NULL;
    _JumpIfError(hr, error, "CloseKey");


    // Open the new VDir
    __try {
        hr=pIMeta->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            wszFullVirtualPath,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            1000,
            &hMetaKey);
    } _TrapException(hr);
    _JumpIfErrorStr(hr, error, "OpenKey", wszFullVirtualPath);

    // Set the physical path for this VDir

    // virtual root path
    mr.dwMDIdentifier=MD_VR_PATH;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=STRING_METADATA;
    mr.dwMDDataLen=(wcslen(wszPhysicalPath)+1)*sizeof(WCHAR);
    mr.pbMDData=(BYTE *)(wszPhysicalPath);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");
    
    // access permissions on VRoots: read & execute
    dwAccessPerms=MD_ACCESS_EXECUTE | MD_ACCESS_READ;
    mr.dwMDIdentifier=MD_ACCESS_PERM;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=DWORD_METADATA;
    mr.dwMDDataLen=sizeof(dwAccessPerms);
    mr.pbMDData=(BYTE *)(&dwAccessPerms);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // indicate that what we created is a vroot - set the key type 
    mr.dwMDIdentifier=MD_KEY_TYPE;
    mr.dwMDAttributes=METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType=IIS_MD_UT_SERVER;
    mr.dwMDDataType=STRING_METADATA;
    mr.dwMDDataLen=(wcslen(wszKeyType)+1)*sizeof(WCHAR);
    mr.pbMDData=(BYTE *)(wszKeyType);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // set authentication to be anonymous or NTLM
    dwAuthenticationType=MD_AUTH_ANONYMOUS|MD_AUTH_NT;
    mr.dwMDIdentifier=MD_AUTHORIZATION;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=DWORD_METADATA;
    mr.dwMDDataLen=sizeof(dwAuthenticationType);
    mr.pbMDData=reinterpret_cast<BYTE *>(&dwAuthenticationType);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // set the default document
    mr.dwMDIdentifier=MD_DEFAULT_LOAD_FILE;
    mr.dwMDAttributes=METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=STRING_METADATA;
    mr.dwMDDataLen=(wcslen(gc_wszCepDllName)+1)*sizeof(WCHAR);
    mr.pbMDData=(BYTE *)(gc_wszCepDllName);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // done with this key.
    __try {
        hr=pIMeta->CloseKey(hMetaKey);
    } _TrapException(hr);
    hMetaKey=NULL;
    _JumpIfError(hr, error, "CloseKey");
    
    // Flush out the changes and close
    __try {
        hr=pIMeta->SaveData();
    } _TrapException(hr);
    // BUGBUG: HACK HACK swallow this error
    // _JumpIfError(hr, "SaveData");
    if (FAILED(hr)) {
        _IgnoreError(hr, "SaveData");
    }
    hr=S_OK;
    // end BUGBUG
    
    // Create a 'web application' so that scrdenrl.dll runs in-process
    // Create an instance of the metabase object
    hr=CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IWamAdmin,
        (void **) &pIWam);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_WamAdmin)");

    // Create the application running in-process
    __try {
        hr=pIWam->AppCreate(wszFullVirtualPath, TRUE);
    } _TrapException(hr);
    _JumpIfError(hr, error, "AppCreate");


error:
    if (NULL!=wszFullVirtualPath) {
        LocalFree(wszFullVirtualPath);
    }
    if (NULL!=wszRelativeVirtualPath) {
        LocalFree(wszRelativeVirtualPath);
    }
    if (NULL!=wszPhysicalPath) {
        LocalFree(wszPhysicalPath);
    }
    if (NULL!=hMetaKey) {
        HRESULT hr2;
        __try {
            hr2=pIMeta->CloseKey(hMetaKey);
        } _TrapException(hr2);
        _TeardownError(hr, hr2, "CloseKey");
    }
    if (NULL!=hMetaRoot) {
        HRESULT hr2;
        __try {
            hr2=pIMeta->CloseKey(hMetaRoot);
        } _TrapException(hr2);
        _TeardownError(hr, hr2, "CloseKey");
    }
    if (NULL!=pIWam) {
        pIWam->Release();
    }
    if (NULL!=pIMeta) {
        pIMeta->Release();
    }
    return hr;
}


//--------------------------------------------------------------------
HRESULT CepStopService(const WCHAR * wszServiceName, BOOL * pbWasRunning)
{
    HRESULT hr;
    SERVICE_STATUS ss;
    unsigned int nAttempts;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hService=NULL;

    // initialize out parameters
    *pbWasRunning=FALSE;

    // talk to the service manager
    hSCManager=OpenSCManagerW(NULL/*machine*/, NULL/*db*/, SC_MANAGER_ALL_ACCESS);
    if (NULL==hSCManager) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    // get to the service
    hService=OpenServiceW(hSCManager, wszServiceName, SERVICE_ALL_ACCESS);
    if (NULL==hService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "OpenService", wszServiceName);
    }

    // see if the service is running
    if (FALSE==QueryServiceStatus(hService, &ss)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "QueryServiceStatus", wszServiceName);
    }
    if (SERVICE_STOPPED!=ss.dwCurrentState && SERVICE_STOP_PENDING!=ss.dwCurrentState) {
        *pbWasRunning=TRUE;
    }

    // begin the service stopping loop
    for (nAttempts=0; SERVICE_STOPPED!=ss.dwCurrentState && nAttempts<SERVICE_STOP_MAX_ATTEMPT; nAttempts++) {

        // service is running, must stop it.
        if (SERVICE_STOP_PENDING!=ss.dwCurrentState) {
            if (!ControlService(hService, SERVICE_CONTROL_STOP, &ss)) {
                hr=HRESULT_FROM_WIN32(GetLastError());
                _JumpErrorStr(hr, error, "ControlService(Stop)", wszServiceName);
            }
        }

        // wait a little while
        Sleep(SERVICE_STOP_HALF_SECOND);

        // see if the service is running
        if (FALSE==QueryServiceStatus(hService, &ss)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpErrorStr(hr, error, "QueryServiceStatus", wszServiceName);
        }
    }

    if (nAttempts>=SERVICE_STOP_MAX_ATTEMPT) {
        // it never stopped
        hr=HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
        _JumpErrorStr(hr, error, "Stopping service", wszServiceName);
    }

    hr=S_OK;

error:
    if (NULL!=hService) {
        CloseServiceHandle(hService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return hr;
}

//--------------------------------------------------------------------
HRESULT CepStartService(const WCHAR * wszServiceName)
{
    HRESULT hr;
    SERVICE_STATUS ss;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hService=NULL;

    // talk to the service manager
    hSCManager=OpenSCManagerW(NULL/*machine*/, NULL/*db*/, SC_MANAGER_ALL_ACCESS);
    if (NULL==hSCManager) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    // get to the service
    hService=OpenServiceW(hSCManager, wszServiceName, SERVICE_ALL_ACCESS);
    if (NULL==hService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "OpenService", wszServiceName);
    }

    // now, start the service.
    if (FALSE==StartServiceW(hService, 0 /*num args*/, NULL /*args*/)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    hr=S_OK;

error:
    if (NULL!=hService) {
        CloseServiceHandle(hService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return hr;
}

//--------------------------------------------------------------------
BOOL IsGoodCaInstalled(void)
{
    HRESULT hr;
    DWORD dwError;
    DWORD dwType;
    DWORD dwDataSize;
    DWORD dwSetupStatus;
    BOOL bResult=FALSE;
    DWORD dwCAType;

    // must be cleaned up
    HKEY hCurConfig=NULL;

    // get the current configuration
    hr=OpenCurrentCAConfig(&hCurConfig);
    _JumpIfError(hr, error, "OpenCurrentCAConfig");

    //  get value SetupStatus
    dwDataSize=sizeof(dwSetupStatus);
    dwError=RegQueryValueExW(hCurConfig, wszREGSETUPSTATUS, NULL, &dwType, (BYTE *)&dwSetupStatus, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGSETUPSTATUS);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    _Verify(sizeof(dwSetupStatus)==dwDataSize, hr, error);

    // make sure we have all the needed components set up
    _Verify(0!=(dwSetupStatus&SETUP_SERVER_FLAG), hr, error);
    _Verify(0!=(dwSetupStatus&SETUP_CLIENT_FLAG), hr, error);
    _Verify(0==(dwSetupStatus&SETUP_SUSPEND_FLAG), hr, error);

    // Check the CA Type too
    dwDataSize=sizeof(dwCAType);
    dwError=RegQueryValueExW(hCurConfig, wszREGCATYPE, NULL, &dwType, (BYTE *)&dwCAType, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGCATYPE);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    _Verify(sizeof(dwCAType)==dwDataSize, hr, error);

    _Verify(dwCAType<=ENUM_UNKNOWN_CA, hr, error);

    
    bResult=TRUE;
error:
    if (NULL!=hCurConfig) {
        RegCloseKey(hCurConfig);
    }
    return bResult;
}

//--------------------------------------------------------------------
BOOL IsCaRunning(void)
{
    HRESULT hr;
    SERVICE_STATUS ss;
    BOOL bResult=FALSE;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hService=NULL;

    // talk to the service manager
    hSCManager=OpenSCManagerW(NULL/*machine*/, NULL/*db*/, SC_MANAGER_ALL_ACCESS);
    if (NULL==hSCManager) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    // get to the service
    hService=OpenServiceW(hSCManager, wszSERVICE_NAME, SERVICE_ALL_ACCESS);
    if (NULL==hService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "OpenService", wszSERVICE_NAME);
    }

    // see if the service is running
    if (FALSE==QueryServiceStatus(hService, &ss)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "QueryServiceStatus", wszSERVICE_NAME);
    }
    _Verify(SERVICE_RUNNING==ss.dwCurrentState, hr, error)
    _Verify(0!=(SERVICE_ACCEPT_PAUSE_CONTINUE&ss.dwControlsAccepted), hr, error);

    // looks like it is
    bResult=TRUE;

error:
    if (NULL!=hService) {
        CloseServiceHandle(hService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return bResult;
}

//--------------------------------------------------------------------
HRESULT EnrollForRACertificates(
            IN const WCHAR * wszDistinguishedName,
            IN const WCHAR * wszSignCSPName,
            IN DWORD dwSignCSPType,
            IN DWORD dwSignKeySize,
            IN const WCHAR * wszEncryptCSPName,
            IN DWORD dwEncryptCSPType,
            IN DWORD dwEncryptKeySize)
{
    HRESULT hr;

    hr=EnrollForRACert(
        wszDistinguishedName,
        wszSignCSPName,
        dwSignCSPType,
        dwSignKeySize,
        AT_SIGNATURE,
        wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE);
    _JumpIfError(hr, error, "EnrollForRACert(OfflineEnrollmentAgent)");

    hr=EnrollForRACert(
        wszDistinguishedName,
        wszEncryptCSPName,
        dwEncryptCSPType,
        dwEncryptKeySize,
        AT_KEYEXCHANGE,
        wszCERTTYPE_CEP_ENCRYPTION);
    _JumpIfError(hr, error, "EnrollForRACert(CepEncryption)");

    // all done
    hr=S_OK;
error:

    return hr;
}

//--------------------------------------------------------------------
HRESULT DoCertSrvRegChanges(IN BOOL bDisablePendingFirst)
{
    HRESULT hr;
    DWORD dwDataSize;
    DWORD dwType;
    DWORD dwError;
    WCHAR * wszTravel;
    DWORD dwNewDataSize;
    DWORD dwRequestDisposition;

    bool bSubjectTemplateAlreadyModified=false;

    // must be cleaned up
    HKEY hCaConfig=NULL;
    WCHAR * mwszSubjectTemplate=NULL;
    HKEY hPolicyModules=NULL;
    HKEY hCurPolicy=NULL;
    WCHAR * wszCurPolicy=NULL;

    // get the current CA config key
    hr=OpenCurrentCAConfig(&hCaConfig);
    _JumpIfError(hr, error, "OpenCurrentCAConfig");

    //
    // add strings to the SubjectTemplate value
    //

    // get the size of the Multi_SZ
    dwDataSize=0;
    dwError=RegQueryValueExW(hCaConfig, wszREGSUBJECTTEMPLATE, NULL, &dwType, NULL, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGSUBJECTTEMPLATE);
    }
    _Verify(REG_MULTI_SZ==dwType, hr, error);

    // add exra space for the strings we want to add
    dwDataSize+=(wcslen(wszPROPUNSTRUCTUREDNAME)+1)*sizeof(WCHAR);
    dwDataSize+=(wcslen(wszPROPUNSTRUCTUREDADDRESS)+1)*sizeof(WCHAR);
    dwDataSize+=(wcslen(wszPROPDEVICESERIALNUMBER)+1)*sizeof(WCHAR);
    dwNewDataSize=dwDataSize;
    mwszSubjectTemplate=(WCHAR *)LocalAlloc(LPTR, dwDataSize);
    _JumpIfOutOfMemory(hr, error, mwszSubjectTemplate);

    // get the Multi_SZ
    dwError=RegQueryValueExW(hCaConfig, wszREGSUBJECTTEMPLATE, NULL, &dwType, (BYTE *)mwszSubjectTemplate, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGSUBJECTTEMPLATE);
    }
    _Verify(REG_MULTI_SZ==dwType, hr, error);

    // walk to the end
    for (wszTravel=mwszSubjectTemplate; 0!=wcslen(wszTravel); wszTravel+=wcslen(wszTravel)+1) {
        // while walking, make sure we haven't added these strings already
        if (0==wcscmp(wszTravel, wszPROPUNSTRUCTUREDNAME)) {
            bSubjectTemplateAlreadyModified=true;
            break;
        }
    }
    // we are now pointing at the last '\0' in the string, which we will overwrite

    // did we do this already? If so, don't do it again.
    if (false==bSubjectTemplateAlreadyModified) {

        // add the strings
        wcscpy(wszTravel, wszPROPUNSTRUCTUREDNAME);
        wszTravel+=wcslen(wszTravel)+1;
        wcscpy(wszTravel, wszPROPUNSTRUCTUREDADDRESS);
        wszTravel+=wcslen(wszTravel)+1;
        wcscpy(wszTravel, wszPROPDEVICESERIALNUMBER);
        wszTravel+=wcslen(wszTravel)+1;
        // add extra terminator
        wszTravel[0]='\0';

        // save the Multi_SZ
        dwError=RegSetValueExW(hCaConfig, wszREGSUBJECTTEMPLATE, NULL, dwType, (BYTE *)mwszSubjectTemplate, dwNewDataSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegSetValueExW", wszREGSUBJECTTEMPLATE);
        }
    }

    //
    // remove the Pending First flag from the current policy settings
    //

    if (FALSE!=bDisablePendingFirst) {

        // open the current policy
        dwError=RegOpenKeyExW(hCaConfig, wszREGKEYPOLICYMODULES, NULL, KEY_READ, &hPolicyModules);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegOpenKeyExW", wszREGKEYPOLICYMODULES);
        }

        hr=GetRegString(hPolicyModules, wszREGACTIVE, &wszCurPolicy);
        _JumpIfErrorStr(hr, error, "GetRegString", wszREGACTIVE);

        dwError=RegOpenKeyExW(hPolicyModules, wszCurPolicy, NULL, KEY_ALL_ACCESS, &hCurPolicy);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegOpenKeyExW", wszCurPolicy);
        }

        // read the value
        dwDataSize=sizeof(dwRequestDisposition);
        dwError=RegQueryValueExW(hCurPolicy, wszREGREQUESTDISPOSITION, NULL, &dwType, (BYTE *)&dwRequestDisposition, &dwDataSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGREQUESTDISPOSITION);
        }
        _Verify(REG_DWORD==dwType, hr, error);
        _Verify(sizeof(dwRequestDisposition)==dwDataSize, hr, error);

        // clear the pending-first flag
        dwRequestDisposition&=~REQDISP_PENDINGFIRST;

        // save the vale
        dwError=RegSetValueExW(hCurPolicy, wszREGREQUESTDISPOSITION, NULL, dwType, (BYTE *)&dwRequestDisposition, dwDataSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegSetValueExW", wszREGREQUESTDISPOSITION);
        }
    }

    // all done
    hr=S_OK;
error:
    if (NULL!=wszCurPolicy) {
        LocalFree(wszCurPolicy);
    }
    if (NULL!=hCurPolicy) {
        RegCloseKey(hCurPolicy);
    }
    if (NULL!=hPolicyModules) {
        RegCloseKey(hPolicyModules);
    }
    if (NULL!=mwszSubjectTemplate) {
        LocalFree(mwszSubjectTemplate);
    }
    if (NULL!=hCaConfig) {
        RegCloseKey(hCaConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT GetCaType(OUT ENUM_CATYPES * pCAType)
{
    HRESULT hr;
    DWORD dwDataSize;
    DWORD dwCAType;
    DWORD dwType;
    DWORD dwError;

    // must be cleaned up
    HKEY hCaConfig=NULL;

    // init out params
    *pCAType=ENUM_UNKNOWN_CA;

    // get the current CA config key
    hr=OpenCurrentCAConfig(&hCaConfig);
    _JumpIfError(hr, error, "OpenCurrentCAConfig");

    // read the CA Type
    dwDataSize=sizeof(dwCAType);
    dwError=RegQueryValueExW(hCaConfig, wszREGCATYPE, NULL, &dwType, (BYTE *)&dwCAType, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGCATYPE);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    _Verify(sizeof(dwCAType)==dwDataSize, hr, error);

    _Verify(dwCAType<=ENUM_UNKNOWN_CA, hr, error);

    // all done
    hr=S_OK;
    *pCAType=(ENUM_CATYPES)dwCAType;

error:
    if (NULL!=hCaConfig) {
        RegCloseKey(hCaConfig);
    }
    return hr;
}


//--------------------------------------------------------------------
BOOL IsUserInAdminGroup(IN BOOL bEnterprise)
{
    BOOL bIsMember=FALSE;
    HRESULT hr;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority=SECURITY_NT_AUTHORITY;

    // must be cleaned up
    HANDLE hAccessToken=NULL;
    HANDLE hDupToken=NULL;
    SID * psidLocalAdmins=NULL;
    SID * psidEntAdmins=NULL;
    SID * psidRootDomAdmins=NULL;

    // Get the access token for this process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hAccessToken)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenProcessToken");
    }

    // CheckTokenMembership must operate on impersonation token, so make one
    if (!DuplicateToken(hAccessToken, SecurityIdentification, &hDupToken)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "DuplicateToken");
    }

    if (bEnterprise) {
        // see if the user is a member of the [domain]\Enmterprised Administrators group
        BOOL bIsEntAdmin=FALSE;
        BOOL bIsRootDomAdmin=FALSE;

        // get the Enterpise Admin SID
        hr=GetEntAdminSid(&psidEntAdmins);
        _JumpIfError(hr, error, "GetEntAdminSid");

        // check for membership
        if (!CheckTokenMembership(hDupToken, psidEntAdmins, &bIsEntAdmin)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "CheckTokenMembership");
        }

        // get the root Domain Admin SID
        hr=GetRootDomAdminSid(&psidRootDomAdmins);
        _JumpIfError(hr, error, "GetRootDomAdminSid");

        // check for membership
        if (!CheckTokenMembership(hDupToken, psidRootDomAdmins, &bIsRootDomAdmin)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "CheckTokenMembership");
        }

        // either one will do
        bIsMember=(bIsEntAdmin || bIsRootDomAdmin);

    } else {
        // see if the user is a member of the BUILTIN\Administrators group

        // get the well-known SID
        if (!AllocateAndInitializeSid(&siaNtAuthority, 2, 
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, (void **)&psidLocalAdmins))
        {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "AllocateAndInitializeSid");
        }

        // check for membership
        if (!CheckTokenMembership(hDupToken, psidLocalAdmins, &bIsMember)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "CheckTokenMembership");
        }
    }


error:
    if (NULL!=hAccessToken) {
        CloseHandle(hAccessToken);
    }

    if (NULL!=hDupToken) {
        CloseHandle(hDupToken);
    }

    if (NULL!=psidLocalAdmins) {
        FreeSid(psidLocalAdmins);
    }

    if (NULL!=psidEntAdmins) {
        FreeSid(psidEntAdmins);
    }

    if (NULL!=psidRootDomAdmins) {
        FreeSid(psidRootDomAdmins);
    }

    return bIsMember;
}


//--------------------------------------------------------------------
HRESULT DoCertSrvEnterpriseChanges(void)
{
    HRESULT hr;
    DWORD dwFlags;
    BOOL bSDChanged1;
    BOOL bSDChanged2;
    BOOL bSDChanged3;

    // must be cleaned up
    HCERTTYPE hEAOTemplate=NULL;
    HCERTTYPE hCETemplate=NULL;
    HCERTTYPE hIIOTemplate=NULL;
    PSECURITY_DESCRIPTOR pSD=NULL;
    WCHAR * wszCAName=NULL;
    HCAINFO hCA=NULL;
    SID * psidEntAdmins=NULL;
    SID * psidRootDomAdmins=NULL;
    SID * psidThisComputer=NULL;

    //
    // first, make sure the CA will issue the cert templates we want
    //

    // get the sanitized CA name
    hr=GetCADsName(&wszCAName);
    _JumpIfError(hr, error, "GetCADsName");

    // get the CA (in the DS)
    hr=CAFindByName(wszCAName, NULL, 0, &hCA);
    _JumpIfErrorStr(hr, error, "CAFindCaByName", wszCAName);

    // check the flags to confirm it supports templates
    hr=CAGetCAFlags(hCA, &dwFlags);
    _JumpIfError(hr, error, "CAGetCAFlags");
    _Verify(0==(dwFlags&CA_FLAG_NO_TEMPLATE_SUPPORT), hr, error);

    // get the enrollment agent offline template
    hr=CAFindCertTypeByName(wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE, NULL, CT_ENUM_USER_TYPES, &hEAOTemplate);
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE);
    // make sure that the CA will issue this template
    hr=CAAddCACertificateType(hCA, hEAOTemplate);
    _JumpIfErrorStr(hr, error, "CAAddCACertificateType", wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE);

    // get the CEP encryption template
    hr=CAFindCertTypeByName(wszCERTTYPE_CEP_ENCRYPTION, NULL, CT_ENUM_MACHINE_TYPES, &hCETemplate);
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", wszCERTTYPE_CEP_ENCRYPTION);
    // make sure that the CA will issue this template
    hr=CAAddCACertificateType(hCA, hCETemplate);
    _JumpIfErrorStr(hr, error, "CAAddCACertificateType", wszCERTTYPE_CEP_ENCRYPTION);

    // get the IPSEC Intermediate offline template
    hr=CAFindCertTypeByName(wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE, NULL, CT_ENUM_MACHINE_TYPES, &hIIOTemplate);
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE);
    // make sure that the CA will issue this template
    hr=CAAddCACertificateType(hCA, hIIOTemplate);
    _JumpIfErrorStr(hr, error, "CAAddCACertificateType", wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE);

    // make sure that all gets written.
    hr=CAUpdateCA(hCA);
    _JumpIfError(hr, error, "CAUpdateCA");



    //
    // now, check the ACLs
    //

    // get the Enterpise Admin SID
    hr=GetEntAdminSid(&psidEntAdmins);
    _JumpIfError(hr, error, "GetEntAdminSid");

    // get the root Domain Admin SID
    hr=GetRootDomAdminSid(&psidRootDomAdmins);
    _JumpIfError(hr, error, "GetRootDomAdminSid");

    // get this computer's SID
    hr=GetThisComputerSid(&psidThisComputer);
    _JumpIfError(hr, error, "GetThisComputerSid");

    // enrollment agent offline template needs Enterprise Admins and root Domain Admins
    hr=CACertTypeGetSecurity(hEAOTemplate, &pSD);
    _JumpIfError(hr, error, "CACertTypeGetSecurity");

    hr=ConfirmAccess(&pSD, psidEntAdmins, &bSDChanged1);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidRootDomAdmins, &bSDChanged2);
    _JumpIfError(hr, error, "ConfirmAccess");

    if (bSDChanged1 || bSDChanged2) {
        hr=CACertTypeSetSecurity(hEAOTemplate, pSD);
        _JumpIfError(hr, error, "CACertTypeSetSecurity");

        hr=CAUpdateCertType(hEAOTemplate);
        _JumpIfError(hr, error, "CAUpdateCertType");
    }

    LocalFree(pSD);
    pSD=NULL;

    
    // CEP encryption template needs Enterprise Admins and root Domain Admins
    hr=CACertTypeGetSecurity(hCETemplate, &pSD);
    _JumpIfError(hr, error, "CACertTypeGetSecurity");

    hr=ConfirmAccess(&pSD, psidEntAdmins, &bSDChanged1);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidRootDomAdmins, &bSDChanged2);
    _JumpIfError(hr, error, "ConfirmAccess");

    if (bSDChanged1 || bSDChanged2) {
        hr=CACertTypeSetSecurity(hCETemplate, pSD);
        _JumpIfError(hr, error, "CACertTypeSetSecurity");

        hr=CAUpdateCertType(hCETemplate);
        _JumpIfError(hr, error, "CAUpdateCertType");
    }

    LocalFree(pSD);
    pSD=NULL;

    // IPSEC Intermediate offline template needs Enterprise Admins and root Domain Admins and the current machine
    hr=CACertTypeGetSecurity(hIIOTemplate, &pSD);
    _JumpIfError(hr, error, "CACertTypeGetSecurity");

    hr=ConfirmAccess(&pSD, psidEntAdmins, &bSDChanged1);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidRootDomAdmins, &bSDChanged2);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidThisComputer, &bSDChanged3);
    _JumpIfError(hr, error, "ConfirmAccess");

    if (bSDChanged1 || bSDChanged2 || bSDChanged3) {
        hr=CACertTypeSetSecurity(hIIOTemplate, pSD);
        _JumpIfError(hr, error, "CACertTypeSetSecurity");

        hr=CAUpdateCertType(hIIOTemplate);
        _JumpIfError(hr, error, "CAUpdateCertType");
    }

    hr=S_OK;
error:
    if (NULL!=psidThisComputer) {
        LocalFree(psidThisComputer);
    }
    if (NULL!=psidEntAdmins) {
        FreeSid(psidEntAdmins);
    }
    if (NULL!=psidRootDomAdmins) {
        FreeSid(psidRootDomAdmins);
    }
    if (NULL!=pSD) {
        LocalFree(pSD);
    }
    if (NULL!=hEAOTemplate) {
        CACloseCertType(hEAOTemplate);
    }
    if (NULL!=hCETemplate) {
        CACloseCertType(hCETemplate);
    }
    if (NULL!=hIIOTemplate) {
        CACloseCertType(hIIOTemplate);
    }
    if (NULL!=wszCAName) {
        LocalFree(wszCAName);
    }
    if (NULL!=hCA) {
        CACloseCA(hCA);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\admin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       admin.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <setupapi.h>
#include <ocmanage.h>
#include "initcert.h"
#include "cscsp.h"


HRESULT
verbDenyRequest(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    BOOL fMustRelease = FALSE;

    hr = cuGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_DenyRequest(&diAdmin, g_pwszConfig, RequestId);
    _JumpIfError(hr, error, "Admin_DenyRequest");

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    return(hr);
}


WCHAR const *
wszFromSubmitDisposition(
    LONG Disposition)
{
    DWORD idMsg;

    switch (Disposition)
    {
	case CR_DISP_INCOMPLETE: idMsg = IDS_CR_DISP_INCOMPLETE; break;
	case CR_DISP_ERROR:      idMsg = IDS_CR_DISP_ERROR;      break;
	case CR_DISP_DENIED:     idMsg = IDS_CR_DISP_DENIED;     break;
	case CR_DISP_ISSUED:     idMsg = IDS_CR_DISP_ISSUED;     break;
	case CR_DISP_ISSUED_OUT_OF_BAND:
				 idMsg = IDS_CR_DISP_ISSUED_OUT_OF_BAND; break;
	case CR_DISP_UNDER_SUBMISSION:
				 idMsg = IDS_CR_DISP_UNDER_SUBMISSION; break;
	case CR_DISP_REVOKED:    idMsg = IDS_CR_DISP_REVOKED;    break;
	    
	default:                 idMsg = IDS_UNKNOWN;            break;
    }
    return(myLoadResourceString(idMsg));
}


HRESULT
verbResubmitRequest(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    LONG Disposition;
    BOOL fMustRelease = FALSE;

    hr = cuGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_ResubmitRequest(&diAdmin, g_pwszConfig, RequestId, &Disposition);
    _JumpIfError(hr, error, "Admin_ResubmitRequest");

    if (CR_DISP_UNDER_SUBMISSION == Disposition)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_PENDING_REQUESTID), // "Certificate request is pending: RequestId: %u"
	    RequestId);
	wprintf(wszNewLine);
    }
    else if (CR_DISP_ISSUED == Disposition)
    {
	wprintf(myLoadResourceString(IDS_CERT_ISSUED)); // "Certificate issued."
	wprintf(wszNewLine);
    }
    else
    {
	if (FAILED(Disposition))
	{
	    hr = Disposition;
	    Disposition = CR_DISP_DENIED;
	}
	wprintf(
	    myLoadResourceString(IDS_CERT_NOT_ISSUED_DISPOSITION), // "Certificate has not been issued: Disposition: %d -- %ws"
	    Disposition,
	    wszFromSubmitDisposition(Disposition));
	wprintf(wszNewLine);
	if (S_OK != hr)
	{
	    WCHAR const *pwszMessage;

	    pwszMessage = myGetErrorMessageText(hr, FALSE);
	    if (NULL != pwszMessage)
	    {
		wprintf(L"%ws\n", pwszMessage);
		LocalFree(const_cast<WCHAR *>(pwszMessage));
	    }
	}
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    return(hr);
}


typedef struct _cuCRLREASON
{
    WCHAR *pwszReason;
    LONG   lReason;
    int    idReason;
} cuCRLREASON;

#define cuREASON(r, id)		{ L#r, (r), (id) }

cuCRLREASON g_cuReason[] =
{
  cuREASON(CRL_REASON_UNSPECIFIED,	IDS_CRL_REASON_UNSPECIFIED),
  cuREASON(CRL_REASON_KEY_COMPROMISE,	IDS_CRL_REASON_KEY_COMPROMISE),
  cuREASON(CRL_REASON_CA_COMPROMISE,	IDS_CRL_REASON_CA_COMPROMISE),
  cuREASON(CRL_REASON_AFFILIATION_CHANGED, IDS_CRL_REASON_AFFILIATION_CHANGED),
  cuREASON(CRL_REASON_SUPERSEDED,	IDS_CRL_REASON_SUPERSEDED),
  cuREASON(CRL_REASON_CESSATION_OF_OPERATION,
					IDS_CRL_REASON_CESSATION_OF_OPERATION),
  cuREASON(CRL_REASON_CERTIFICATE_HOLD, IDS_CRL_REASON_CERTIFICATE_HOLD),
  cuREASON(CRL_REASON_REMOVE_FROM_CRL,	IDS_CRL_REASON_REMOVE_FROM_CRL),
  { L"Unrevoke", MAXDWORD,		IDS_CRL_REASON_UNREVOKE },
  { NULL,	 MAXDWORD,		IDS_CRL_REASON_UNRECOGNIZED },
};

#define wszCRLPREFIX	L"CRL_REASON_"

HRESULT
cuParseReason(
    IN WCHAR const *pwszReason,
    OUT LONG *plReason)
{
    HRESULT hr;
    
    hr = cuGetSignedLong(pwszReason, plReason);
    if (S_OK != hr)
    {
	cuCRLREASON const *pr;
	
	for (pr = g_cuReason; ; pr++)
	{
	    if (NULL == pr->pwszReason)
	    {
		hr = E_INVALIDARG;
		_JumpIfError(hr, error, "Invalid Reason string");
	    }
	    if (0 == lstrcmpi(pr->pwszReason, pwszReason))
	    {
		break;
	    }
	    if (wcslen(pr->pwszReason) > WSZARRAYSIZE(wszCRLPREFIX) &&
		0 == memcmp(
			pr->pwszReason,
			wszCRLPREFIX,
			WSZARRAYSIZE(wszCRLPREFIX) * sizeof(WCHAR)) &&
		0 == lstrcmpi(
			    &pr->pwszReason[WSZARRAYSIZE(wszCRLPREFIX)],
			    pwszReason))
	    {
		break;
	    }
	}
	*plReason = pr->lReason;
	hr = S_OK;
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


int
cuidCRLReason(
    IN LONG Reason)
{
    cuCRLREASON const *pr;
    
    for (pr = g_cuReason; NULL != pr->pwszReason; pr++)
    {
	if (pr->lReason == Reason)
	{
	    break;
	}
    }
    return(pr->idReason);
}


WCHAR const *
wszCRLReason(
    IN LONG Reason)
{
    return(myLoadResourceString(cuidCRLReason(Reason)));
}


HRESULT
verbRevokeCertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszReason,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BSTR strSerialNumber = NULL;
    LONG Reason = CRL_REASON_UNSPECIFIED;
    SYSTEMTIME st;
    FILETIME ft;
    DATE Date;
    BOOL fMustRelease = FALSE;

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "SystemTimeToFileTime");
    }
    hr = myFileTimeToDate(&ft, &Date);
    _JumpIfError(hr, error, "myFileTimeToDate");

    //Date -= 1.0;		// Revoke effective yesterday

    hr = myMakeSerialBstr(pwszSerialNumber, &strSerialNumber);
    _JumpIfError(hr, error, "myMakeSerialBstr");

    if (NULL != pwszReason)
    {
	hr = cuParseReason(pwszReason, &Reason);
	_JumpIfError(hr, error, "Invalid Reason");
    }

    wprintf(myLoadResourceString(IDS_REVOKING), strSerialNumber); // "Revoking "%ws""
    wprintf(L" -- %ws", wszCRLReason(Reason));	// "Reason: xxxx"
    wprintf(wszNewLine);

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_RevokeCertificate(
			&diAdmin,
			g_pwszConfig,
			strSerialNumber,
			Reason,
			Date);
    _JumpIfError(hr, error, "Admin_DenyRequest");

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
cuParseDaysHours(
    IN WCHAR const *pwszDaysHours,
    OUT FILETIME *pft)
{
    HRESULT hr;
    WCHAR *pwszDays = NULL;
    WCHAR *pwszHours;
    DWORD dwDays;
    DWORD dwHours;
    BOOL fValid;
    LONGLONG delta;

    hr = myDupString(pwszDaysHours, &pwszDays);
    _JumpIfError(hr, error, "myDupString");

    hr = E_INVALIDARG;
    pwszHours = wcschr(pwszDays, L':');
    if (NULL == pwszHours)
    {
	_JumpError(hr, error, "missing colon");
    }
    *pwszHours++ = L'\0';
    dwDays = myWtoI(pwszDays, &fValid);
    if (!fValid)
    {
	_JumpError(hr, error, "bad day count");
    }
    dwHours = myWtoI(pwszHours, &fValid);
    if (!fValid)
    {
	_JumpError(hr, error, "bad hour count");
    }
    if (0 == dwDays && 0 == dwHours)
    {
	_JumpError(hr, error, "zero day+hour counts");
    }
    GetSystemTimeAsFileTime(pft);

    // add specified days and hours to compute expiration date

    delta = dwDays * CVT_DAYS;
    delta += dwHours * CVT_HOURS;
    myAddToFileTime(pft, delta * CVT_BASE);
    hr = S_OK;

error:
    if (NULL != pwszDays)
    {
	LocalFree(pwszDays);
    }
    return(hr);
}


HRESULT
verbPublishCRL(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszDaysHours,
    OPTIONAL IN WCHAR const *pwszDelta,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    DATE Date;
    DWORD Flags = 0;

    if (NULL != pwszDaysHours && 0 == lstrcmpi(L"delta", pwszDaysHours))
    {
	WCHAR const *pwsz = pwszDaysHours;

	pwszDaysHours = pwszDelta;
	pwszDelta = pwsz;
    }
    Date = 0.0;
    if (NULL != pwszDaysHours)
    {
	if (0 == lstrcmpi(L"republish", pwszDaysHours))
	{
	    Flags |= CA_CRL_REPUBLISH;
	}
	else
	{
	    FILETIME ft;
	    
	    hr = cuParseDaysHours(pwszDaysHours, &ft);
	    _JumpIfError(hr, error, "cuParseDaysHours");

	    hr = myFileTimeToDate(&ft, &Date);
	    _JumpIfError(hr, error, "myFileTimeToDate");
	}
    }
    if (NULL != pwszDelta)
    {
	if (0 != lstrcmpi(L"delta", pwszDelta))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad delta arg");
	}
	Flags |= CA_CRL_DELTA;
    }
    if (0 == (CA_CRL_DELTA & Flags))
    {
	Flags |= CA_CRL_BASE;
    }

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    if ((CA_CRL_DELTA | CA_CRL_REPUBLISH) & Flags)
    {
	hr = Admin2_PublishCRLs(&diAdmin, g_pwszConfig, Date, Flags);
	_JumpIfError(hr, error, "Admin2_PublishCRLs");
    }
    else
    {
	BOOL fV1 = g_fV1Interface;

	if (!fV1)
	{
	    hr = Admin2_PublishCRLs(&diAdmin, g_pwszConfig, Date, Flags);
	    if (E_NOTIMPL != hr)
	    {
		_JumpIfError(hr, error, "Admin2_PublishCRLs");
	    }
	    else
	    {
		_PrintError(hr, "Admin2_PublishCRLs down level server");
		fV1 = TRUE;
	    }
	}
	if (fV1)
	{
	    hr = Admin_PublishCRL(&diAdmin, g_pwszConfig, Date);
	    _JumpIfError(hr, error, "Admin_PublishCRL");
	}
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    return(hr);
}


HRESULT
verbGetCRL(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszDelta,
    OPTIONAL IN WCHAR const *pwszIndex,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    BOOL fDelta = FALSE;
    DWORD CertIndex = MAXDWORD;	// default to latest CRL
    BSTR strCRL = NULL;

    if (NULL != pwszDelta && 0 != lstrcmpi(L"delta", pwszDelta))
    {
	WCHAR const *pwsz = pwszIndex;

	pwszIndex = pwszDelta;
	pwszDelta = pwsz;
    }
    if (NULL != pwszDelta && 0 == lstrcmpi(L"delta", pwszDelta))
    {
	fDelta = TRUE;
    }
    if (NULL != pwszIndex)
    {
	hr = cuGetSignedLong(pwszIndex, (LONG *) &CertIndex);
	_JumpIfErrorStr(hr, error, "Cert index not a number", pwszIndex);
    }
    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    if (fDelta)
    {
	hr = Admin2_GetCAProperty(
			    &diAdmin,
			    g_pwszConfig,
			    CR_PROP_DELTACRL,
			    CertIndex,
			    PROPTYPE_BINARY,
			    CR_OUT_BINARY,
			    &strCRL);
	_JumpIfError(hr, error, "Admin2_GetCAProperty");
    }
    else
    {
	BOOL fV1 = g_fV1Interface;

	if (!fV1)
	{
	    hr = Admin2_GetCAProperty(
				&diAdmin,
				g_pwszConfig,
				CR_PROP_BASECRL,
				CertIndex,
				PROPTYPE_BINARY,
				CR_OUT_BINARY,
				&strCRL);

	    if (E_NOTIMPL != hr)
	    {
		_JumpIfError(hr, error, "Admin2_GetCAProperty");
	    }
	    else
	    {
		_PrintError(hr, "Admin2_CAProperty down level server");
		fV1 = TRUE;
	    }
	}
	if (fV1)
	{
	    if (NULL != pwszIndex)
	    {
		hr = cuGetCAInfo(
			    pwszOption,
			    pwszfnOut,
			    g_wszCAInfoCRL,
			    pwszIndex);
		_JumpIfError(hr, error, "cuGetCAInfo");
	    }
	    else
	    {
		hr = Admin_GetCRL(
			    &diAdmin,
			    g_pwszConfig,
			    CR_OUT_BINARY,
			    &strCRL);
		_JumpIfError(hr, error, "Admin_GetCRL");
	    }
	}
    }

    // if not already saved by cuGetCAInfo

    if (NULL != strCRL)
    {
	hr = EncodeToFileW(
		    pwszfnOut,
		    (BYTE const *) strCRL,
		    SysStringByteLen(strCRL),
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strCRL)
    {
	SysFreeString(strCRL);
    }
    return(hr);
}


HRESULT
FindCertAndSign(
    OPTIONAL IN CERT_EXTENSION const *pExtKeyId,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    IN BYTE const *pbUnsigned,
    IN DWORD cbUnsigned,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_AUTHORITY_KEY_ID2_INFO *pKeyId = NULL;
    DWORD cbKeyId;
    WCHAR *strKeyId = NULL;
    CERT_CONTEXT const *pCert = NULL;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    BOOL fCallerFreeProv;
    CHAR *pszObjId = NULL;
    
    *ppbOut = NULL;
    if (NULL == pbHash && NULL != pExtKeyId)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_AUTHORITY_KEY_ID2,
			pExtKeyId->Value.pbData,
			pExtKeyId->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pKeyId,
			&cbKeyId))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
	pbHash = pKeyId->KeyId.pbData;
	cbHash = pKeyId->KeyId.cbData;
    }
    if (0 != cbHash && NULL != pbHash)
    {
	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strKeyId);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");
    }

    // Find CA cert by KeyId from the szOID_AUTHORITY_KEY_IDENTIFIER2 extension.
    // Look in HKLM and HKCU My and CA stores.

    hr = myGetCertificateFromPicker(
			    g_hInstance,
			    NULL,		// hwndParent
			    IDS_GETCERT_TITLE,
			    IDS_GETCERT_SUBTITLE,

			    // dwFlags: HKLM+HKCU My store
			    CUCS_MYSTORE |
				CUCS_MACHINESTORE |
				CUCS_USERSTORE |
				CUCS_PRIVATEKEYREQUIRED |
				CUCS_ARCHIVED |
				(g_fCryptSilent? CUCS_SILENT : 0),
			    strKeyId,
			    0,
			    NULL,
			    0,		// cpszObjId
			    NULL,	// apszObjId
			    &pCert);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

    if (NULL == pCert)
    {
	hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	_JumpError(hr, error, "no cert");
    }

    hr = cuDisplayCertName(
		    TRUE,
		    NULL,
		    myLoadResourceString(IDS_SIGNINGSUBJECT), // "Signing certificate Subject"
		    g_wszPad4,
		    &pCert->pCertInfo->Subject);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    // Search for and load the cryptographic provider and private key. 

    hr = myLoadPrivateKey(
		    &pCert->pCertInfo->SubjectPublicKeyInfo,
		    CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
		    &hProv,
		    &dwKeySpec,
		    &fCallerFreeProv);
    _JumpIfError(hr, error, "myLoadPrivateKey");

    if (AT_SIGNATURE != dwKeySpec)
    {
	hr = NTE_BAD_KEY_STATE;
	DBGPRINT((DBG_SS_CERTUTIL, "dwKeySpec = %u\n", dwKeySpec));
	_JumpError(hr, error, "dwKeySpec");
    }

    // The CA cert's private key is available -- use it to sign the data.
    // Sign the Cert or CRL and encode the signed info.

    hr = myGetSigningOID(hProv, NULL, 0, CALG_SHA1, &pszObjId);
    _JumpIfError(hr, error, "myGetSigningOID");

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszObjId,
			const_cast<BYTE *>(pbUnsigned),
			cbUnsigned,
			CERTLIB_USE_LOCALALLOC,
			ppbOut,
			pcbOut);
    _JumpIfError(hr, error, "myEncodeSignedContent");

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != pKeyId)
    {
	LocalFree(pKeyId);
    }
    if (NULL != strKeyId)
    {
	SysFreeString(strKeyId);
    }
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
SignCRL(
    IN CRL_CONTEXT const *pCRLContext,
    OPTIONAL IN FILETIME const *pftNextUpdate,
    IN BOOL fAdd,
    IN WCHAR const * const *ppwszSerialList,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRL_INFO const *pCRLInfo;
    CRL_INFO CRLInfoOut;
    LLFILETIME llftDelta;
    LLFILETIME llft;
    BYTE *pbUnsigned = NULL;
    DWORD cbUnsigned;
    CERT_EXTENSION *pExtKeyId;

    ZeroMemory(&CRLInfoOut, sizeof(CRLInfoOut));

    *ppbOut = NULL;

    // CRL extensions to strip out of the re-signed CRL:

    static char const * const apszObjIdFilter[] = {
	szOID_CRL_NEXT_PUBLISH,
    };

    pCRLInfo = pCRLContext->pCrlInfo;
    CRLInfoOut = *pCRLInfo;
    CRLInfoOut.rgExtension = NULL;
    CRLInfoOut.cExtension = 0;

    GetSystemTimeAsFileTime(&llft.ft);
    llftDelta.ll = CCLOCKSKEWMINUTESDEFAULT * CVT_MINUTES;
    llftDelta.ll *= CVT_BASE;
    llft.ll -= llftDelta.ll;
    CRLInfoOut.ThisUpdate = llft.ft;

    if (NULL != pftNextUpdate)
    {
	CRLInfoOut.NextUpdate = *pftNextUpdate;
    }
    else
    {
	// NextUpdateOut = ThisUpdateOut + (NextUpdate - ThisUpdate);

	llftDelta.ft = pCRLInfo->NextUpdate;
	llft.ft = pCRLInfo->ThisUpdate;
	llftDelta.ll -= llft.ll;

	llft.ft = CRLInfoOut.ThisUpdate;
	llftDelta.ll += llft.ll;

	CRLInfoOut.NextUpdate = llftDelta.ft;
    }

    hr = cuDumpFileTime(IDS_THISUPDATE, NULL, &CRLInfoOut.ThisUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    hr = cuDumpFileTime(IDS_NEXTUPDATE, NULL, &CRLInfoOut.NextUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    wprintf(myLoadResourceString(IDS_CRLENTRIES)); // "CRL Entries:"
    wprintf(L" %u\n", pCRLInfo->cCRLEntry);

    wprintf(wszNewLine);

    pExtKeyId = NULL;
    if (0 != pCRLInfo->cExtension)
    {
	CERT_EXTENSION *pExt;
	DWORD i;
	DWORD j;

	CRLInfoOut.rgExtension = (CERT_EXTENSION *) LocalAlloc(
					LMEM_FIXED, 
					pCRLInfo->cExtension *
					    sizeof(CRLInfoOut.rgExtension[0]));
	if (NULL == CRLInfoOut.rgExtension)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pExt = pCRLInfo->rgExtension;
	for (i = 0; i < pCRLInfo->cExtension; i++)
	{
	    for (j = 0; ; j++)
	    {
		if (j >= ARRAYSIZE(apszObjIdFilter))
		{
		    CRLInfoOut.rgExtension[CRLInfoOut.cExtension++] = *pExt;
		    break;
		}
		if (0 == strcmp(apszObjIdFilter[j], pExt->pszObjId))
		{
		    break;		// skip this extension
		}
	    }
	    if (0 == strcmp(szOID_AUTHORITY_KEY_IDENTIFIER2, pExt->pszObjId))
	    {
		pExtKeyId = pExt;
	    }
	    pExt++;
	}
    }

    if (!myEncodeObject(
                    X509_ASN_ENCODING,
                    X509_CERT_CRL_TO_BE_SIGNED,
                    &CRLInfoOut,
                    0,
                    CERTLIB_USE_LOCALALLOC,
                    &pbUnsigned,               // pbEncoded
                    &cbUnsigned))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    hr = FindCertAndSign(
		    pExtKeyId,
		    NULL,
		    0,
		    pbUnsigned,
		    cbUnsigned,
		    ppbOut,
		    pcbOut);
    _JumpIfError(hr, error, "FindCertAndSign");

error:
    if (NULL != CRLInfoOut.rgExtension)
    {
	LocalFree(CRLInfoOut.rgExtension);
    }
    if (NULL != pbUnsigned)
    {
	LocalFree(pbUnsigned);
    }
    return(hr);
}


HRESULT
SignCert(
    IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN FILETIME const *pftNotAfter,
    IN WCHAR const * const *ppwszObjIdList,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_INFO const *pCertInfo;
    CERT_INFO CertInfoOut;
    LLFILETIME llftCurrent;
    LLFILETIME llftDelta;
    LLFILETIME llft;
    BYTE *pbUnsigned = NULL;
    DWORD cbUnsigned;
    BYTE const *pbHash;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    CERT_EXTENSION *pExtKeyId;
    CERT_EXTENSION ExtKeyId;

    ZeroMemory(&CertInfoOut, sizeof(CertInfoOut));

    *ppbOut = NULL;

    pCertInfo = pCertContext->pCertInfo;
    CertInfoOut = *pCertInfo;

    GetSystemTimeAsFileTime(&llftCurrent.ft);
    llftDelta.ll = CCLOCKSKEWMINUTESDEFAULT * CVT_MINUTES;
    llftDelta.ll *= CVT_BASE;
    llftCurrent.ll -= llftDelta.ll;

    if (0 < CompareFileTime(&CertInfoOut.NotBefore, &llftCurrent.ft))
    {
	CertInfoOut.NotBefore = llftCurrent.ft;
    }
    if (NULL != pftNotAfter)
    {
	CertInfoOut.NotAfter = *pftNotAfter;
    }
    else
    {
	// NotAfterOut = CurrentTime + (NotAfter - NotBefore);

	llftDelta.ft = pCertInfo->NotAfter;
	llft.ft = pCertInfo->NotBefore;
	llftDelta.ll -= llft.ll;

	llftDelta.ll += llftCurrent.ll;

	CertInfoOut.NotAfter = llftDelta.ft;
    }

    hr = cuDumpFileTime(IDS_NOTBEFORE, NULL, &CertInfoOut.NotBefore);
    _JumpIfError(hr, error, "cuDumpFileTime");

    hr = cuDumpFileTime(IDS_NOTAFTER, NULL, &CertInfoOut.NotAfter);
    _JumpIfError(hr, error, "cuDumpFileTime");

    wprintf(wszNewLine);

    pbHash = NULL;
    pExtKeyId = CertFindExtension(
			szOID_AUTHORITY_KEY_IDENTIFIER2, 
			pCertInfo->cExtension,
			pCertInfo->rgExtension);
    if (NULL == pExtKeyId)
    {
	hr = cuVerifySignature(
			pCertContext->pbCertEncoded,
			pCertContext->cbCertEncoded,
			&pCertContext->pCertInfo->SubjectPublicKeyInfo,
			TRUE);
	if (S_OK == hr)
	{
	    if (CertGetCertificateContextProperty(
					    pCertContext,
					    CERT_KEY_IDENTIFIER_PROP_ID,
					    abHash,
					    &cbHash))
	    {
		pbHash = abHash;
	    }
	}
    }
    else
    {
	ExtKeyId = *pExtKeyId;	// in case it's deleted or moved.
	pExtKeyId = &ExtKeyId;
    }
    if (NULL != ppwszObjIdList)
    {
	DWORD i;

	for (i = 0; NULL != ppwszObjIdList[i]; i++)
	{
	    char *pszObjId;
	    CERT_EXTENSION *pExt;
	    
	    hr = myVerifyObjId(ppwszObjIdList[i]);
	    _JumpIfError(hr, error, "myVerifyObjId");

	    if (!myConvertWszToSz(&pszObjId, ppwszObjIdList[i], -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "myConvertWszToSz");
	    }
	    pExt = CertFindExtension(
			    pszObjId,
			    CertInfoOut.cExtension,
			    CertInfoOut.rgExtension);
	    if (NULL != pExt)
	    {
		DWORD iDel;

		iDel = SAFE_SUBTRACT_POINTERS(pExt, CertInfoOut.rgExtension);
wprintf(L"iDel=%u cExt=%u\n", iDel, CertInfoOut.cExtension);
		if (0 == --CertInfoOut.cExtension)
		{
		    CertInfoOut.dwVersion = CERT_V1;
		    continue;		// verify the rest of the ObjIds
		}
		if (iDel < CertInfoOut.cExtension)
		{
wprintf(L"copy %u to %u, len=%u\n", iDel + 1, iDel, CertInfoOut.cExtension - iDel);
		    MoveMemory(
			&CertInfoOut.rgExtension[iDel], 
			&CertInfoOut.rgExtension[iDel + 1], 
			(CertInfoOut.cExtension - iDel) *
			    sizeof(CertInfoOut.rgExtension[iDel]));
		}
	    }
	    LocalFree(pszObjId);
	}
    }
    if (!myEncodeObject(
                    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
                    &CertInfoOut,
                    0,
                    CERTLIB_USE_LOCALALLOC,
                    &pbUnsigned,               // pbEncoded
                    &cbUnsigned))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    hr = FindCertAndSign(
		    pExtKeyId,
		    pbHash,
		    cbHash,
		    pbUnsigned,
		    cbUnsigned,
		    ppbOut,
		    pcbOut);
    _JumpIfError(hr, error, "FindCertAndSign");

error:
    if (NULL != pbUnsigned)
    {
	LocalFree(pbUnsigned);
    }
    return(hr);
}


HRESULT
verbSign(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszDaysHours,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    FILETIME ftNextUpdate;
    FILETIME *pftNextUpdate;
    CRL_CONTEXT const *pCRLContext = NULL;
    CERT_CONTEXT const *pCertContext = NULL;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BOOL fAdd = FALSE;
    WCHAR **ppwszList = NULL;

    pftNextUpdate = NULL;
    if (NULL != pwszDaysHours)
    {
	if (L'-' == *pwszDaysHours || L'+' == *pwszDaysHours)
	{
	    fAdd = L'+' == *pwszDaysHours++;
	    hr = cuParseStrings(
			pwszDaysHours,
			FALSE,
			NULL,
			NULL,
			&ppwszList,
			NULL);
	    _JumpIfError(hr, error, "cuParseStrings");
	}
	else
	{
	    hr = cuParseDaysHours(pwszDaysHours, &ftNextUpdate);
	    _JumpIfError(hr, error, "cuParseDaysHours");

	    pftNextUpdate = &ftNextUpdate;
	    pwszDaysHours = NULL;
	}
    }

    // Load and decode CRL and certificate

    hr = cuLoadCRL(pwszfnIn, &pCRLContext);
    if (S_OK == hr)
    {
	hr = SignCRL(
		pCRLContext,
		pftNextUpdate,
		fAdd,
		ppwszList,
		&pbOut,
		&cbOut);
	_JumpIfError(hr, error, "SignCRL");
    }
    else
    {
	hr = cuLoadCert(pwszfnIn, &pCertContext);
	if (S_OK == hr)
	{
	    if (fAdd)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "cannot add extensions to cert");
	    }
	    hr = SignCert(
		    pCertContext,
		    pftNextUpdate,
		    ppwszList,
		    &pbOut,
		    &cbOut);
	    _JumpIfError(hr, error, "SignCert");
	}
	else
	{
	    cuPrintError(IDS_FORMAT_LOADTESTCRL, hr);
	    goto error;
	}

    }

    // Write encoded & signed CRL or Cert to file

    hr = EncodeToFileW(
		pwszfnOut,
		pbOut,
		cbOut,
		CRYPT_STRING_BINARY | g_EncodeFlags);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	goto error;
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_OUTPUT_LENGTH), // "Output Length = %d"
	cuFileSize(pwszfnOut));
    wprintf(wszNewLine);

    hr = S_OK;

error:
    cuFreeStringArray(ppwszList);
    if (NULL != pbOut)
    {
	LocalFree(pbOut);
    }
    cuUnloadCRL(&pCRLContext);
    cuUnloadCert(&pCertContext);
    return(hr);
}


HRESULT
verbShutDownServer(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = CertSrvServerControl(g_pwszConfig, CSCONTROL_SHUTDOWN, NULL, NULL);
    _JumpIfError(hr, error, "CertSrvServerControl");

error:
    if (E_ACCESSDENIED == hr)
    {
        g_uiExtraErrorInfo = IDS_ERROR_ACCESSDENIED_CAUSE;
    }
    return(hr);
}


HRESULT
verbIsValidCertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BSTR strSerialNumber = NULL;
    LONG Reason = CRL_REASON_KEY_COMPROMISE;
    BOOL fMustRelease = FALSE;
    LONG Disposition;

    hr = myMakeSerialBstr(pwszSerialNumber, &strSerialNumber);
    _JumpIfError(hr, error, "myMakeSerialBstr");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_IsValidCertificate(
			&diAdmin,
			g_pwszConfig,
			strSerialNumber,
			&Disposition);
    _JumpIfError(hr, error, "Admin_IsValidCertificate");

    switch (Disposition)
    {
	case CA_DISP_INVALID:
	    wprintf(myLoadResourceString(IDS_CERT_DISPOSITION_INVALID), strSerialNumber); // "Certificate disposition for "%ws" is invalid"
	    wprintf(wszNewLine);
	    break;

	case CA_DISP_VALID:
	    wprintf(myLoadResourceString(IDS_CERT_DISPOSITION_VALID), strSerialNumber); // "Certificate disposition for "%ws" is valid"
	    wprintf(wszNewLine);
	    break;

	case CA_DISP_UNDER_SUBMISSION:
	    wprintf(myLoadResourceString(IDS_CERT_DISPOSITION_PENDING), strSerialNumber); // "Certificate request for "%ws" is pending"
	    wprintf(wszNewLine);
	    break;

	case CA_DISP_REVOKED:
	    hr = Admin_GetRevocationReason(&diAdmin, &Reason);
	    if (S_OK != hr)
	    {
		_PrintIfError(hr, "Admin_GetRevocationReason");
		Reason = CRL_REASON_UNSPECIFIED;
	    }
	    wprintf(
		myLoadResourceString(IDS_CERT_DISPOSITION_REVOKED), // "Certificate disposition for "%ws" is revoked (%ws)"
		strSerialNumber,
		wszCRLReason(Reason));
	    wprintf(wszNewLine);
	    break;
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


#define wszREQUEST	L"Request"
#define wszCERT		L"Cert"

HRESULT
verbDeleteRow(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRowIdOrDate,
    OPTIONAL IN WCHAR const *pwszTable,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszLocalTime = NULL;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    DWORD Flags;
    LONG RowId;
    DATE date;
    LONG Table;
    LONG Count;

    hr = cuGetLong(pwszRowIdOrDate, &RowId);
    if (S_OK != hr)
    {
	FILETIME ftCurrent;
	FILETIME ftQuery;
	
	RowId = 0;

	hr = myWszLocalTimeToGMTDate(pwszRowIdOrDate, &date);
	_JumpIfError(hr, error, "invalid RowId or date");

	hr = myGMTDateToWszLocalTime(&date, FALSE, &pwszLocalTime);
	_JumpIfError(hr, error, "myGMTDateToWszLocalTime");

	GetSystemTimeAsFileTime(&ftCurrent);

	hr = myDateToFileTime(&date, &ftQuery);
	_JumpIfError(hr, error, "myDateToFileTime");

	if (0 > CompareFileTime(&ftCurrent, &ftQuery))
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_DATE_IN_FUTURE), // "The date specified is in the future: %ws"
		pwszLocalTime);
	    wprintf(wszNewLine);
	    if (!g_fForce)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "date in future");
	    }
	}
    }
    else
    {
	if (0 == RowId)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "zero RowId");
	}
	date = 0.0;
    }

    hr = E_INVALIDARG;
    Table = CVRC_TABLE_REQCERT;
    Flags = 0;
    if (NULL == pwszTable)
    {
	if (0 == RowId)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_DATE_REQUIRES_TABLE), // "One of the following tables must be specified when deleting rows older than %ws:"
		pwszLocalTime);
	    wprintf(wszNewLine);
	    wprintf(L"  %ws\n", wszREQUEST);
	    wprintf(L"  %ws\n", wszCERT);
	    wprintf(L"  %ws\n", g_wszCRL);
	    _JumpError(hr, error, "date requires table");
	}
    }
    else
    if (0 == lstrcmpi(wszREQUEST, pwszTable))
    {
	Flags = CDR_REQUEST_LAST_CHANGED; // assume date query
    }
    else
    if (0 == lstrcmpi(wszCERT, pwszTable))
    {
	Flags = CDR_EXPIRED;		// assume date query
    }
    else
    if (0 == lstrcmpi(g_wszExt, pwszTable))
    {
	Table = CVRC_TABLE_EXTENSIONS;
	if (0 == RowId)
	{
	    _JumpError(hr, error, "no date in Extension table");
	}
    }
    else
    if (0 == lstrcmpi(g_wszAttrib, pwszTable))
    {
	Table = CVRC_TABLE_ATTRIBUTES;
	if (0 == RowId)
	{
	    _JumpError(hr, error, "no date in Request Attribute table");
	}
    }
    else
    if (0 == lstrcmpi(g_wszCRL, pwszTable))
    {
	Table = CVRC_TABLE_CRL;		// assume date query
    }
    else
    {
	_JumpError(hr, error, "bad table name");
    }
    if (0 != RowId)
    {
	Flags = 0;			// not a date query
 
    }
    else if (g_fVerbose)
    {
	wprintf(L"%ws\n", pwszLocalTime);
    }

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    Count = 0;
    hr = Admin2_DeleteRow(
			&diAdmin,
			g_pwszConfig,
			Flags,
			date,
			Table,
			RowId,
			&Count);
    wprintf(myLoadResourceString(IDS_FORMAT_DELETED_ROW_COUNT), Count);
    wprintf(wszNewLine);
    _JumpIfError(hr, error, "Admin2_DeleteRow");

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != pwszLocalTime)
    {
	LocalFree(pwszLocalTime);
    }
    return(hr);
}


HRESULT
verbSetAttributes(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    BSTR strAttributes = NULL;
    WCHAR *pwsz;
    BOOL fMustRelease = FALSE;

    if (!ConvertWszToBstr(&strAttributes, pwszAttributes, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    for (pwsz = strAttributes; L'\0' != *pwsz; pwsz++)
    {
	switch (*pwsz)
	{
	    case L';':
		*pwsz = L'\n';
		break;

	    case L'\\':
		if (L'n' == pwsz[1])
		{
		    *pwsz++ = L'\r';
		    *pwsz = L'\n';
		}
		break;
	}
    }

    hr = cuGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_SetRequestAttributes(
			    &diAdmin,
			    g_pwszConfig,
			    RequestId,
			    strAttributes);
    _JumpIfError(hr, error, "Admin_SetAttributes");

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strAttributes)
    {
	SysFreeString(strAttributes);
    }
    return(hr);
}


HRESULT
verbSetExtension(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszExtensionName,
    IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszValue)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    LONG Flags;
    BSTR strExtensionName = NULL;
    BSTR strValue = NULL;
    LONG PropType;
    VARIANT var;
    BOOL fMustRelease = FALSE;
    BYTE *pbValue = NULL;
    DWORD cbValue;

    hr = cuGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    if (!ConvertWszToBstr(&strExtensionName, pwszExtensionName, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = cuGetLong(pwszFlags, &Flags);
    _JumpIfError(hr, error, "Flags must be a number");

    if (~EXTENSION_POLICY_MASK & Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags must be <= 0xffff");
    }
    if (L'@' == *pwszValue)
    {
	pwszValue++;

	// Read in and decode the extension from a file.
	// Try Hex-Ascii, Base64 with and without a header, then binary.
	hr = DecodeFileW(pwszValue, &pbValue, &cbValue, CRYPT_STRING_HEX_ANY);
	if (S_OK != hr)
	{
	    hr = DecodeFileW(pwszValue, &pbValue, &cbValue, CRYPT_STRING_ANY);
	    _JumpIfError(hr, error, "DecodeFileW");
	}

	CSASSERT(NULL != pbValue && 0 != cbValue);

	var.vt = VT_BSTR;
	PropType = PROPTYPE_BINARY;

	DumpHex(0, pbValue, cbValue);
	if (!ConvertWszToBstr(&strValue, (WCHAR const *) pbValue, cbValue))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
	var.bstrVal = strValue;
    }
    else
    {
	hr = cuGetLong(pwszValue, &var.lVal);
	if (S_OK == hr)
	{
	    var.vt = VT_I4;
	    PropType = PROPTYPE_LONG;
	}
	else
	{
	    hr = myWszLocalTimeToGMTDate(pwszValue, &var.date);
	    if (S_OK == hr)
	    {
		var.vt = VT_DATE;
		PropType = PROPTYPE_DATE;
	    }
	    else
	    {
		var.vt = VT_BSTR;
		PropType = PROPTYPE_STRING;
		if (!ConvertWszToBstr(&strValue, pwszValue, MAXDWORD))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
		}
		var.bstrVal = strValue;
	    }
	}
    }

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    if (S_OK != hr)
    {
	_JumpError(hr, error, "Admin_Init");
    }
    fMustRelease = TRUE;

    hr = Admin_SetCertificateExtension(
			&diAdmin,
			g_pwszConfig,
			RequestId,
			strExtensionName,
			PropType,
			Flags,
			&var);
    _JumpIfError(hr, error, "Admin_SetExtension");

error:
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strExtensionName)
    {
	SysFreeString(strExtensionName);
    }
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
verbImportCertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCertificateFile,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    LONG dwReqID;
    CERT_CONTEXT const *pCertContext = NULL;
    DISPATCHINTERFACE diAdmin;
    BOOL fRelease = FALSE;
    
    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fRelease = TRUE;

    hr = cuLoadCert(pwszCertificateFile, &pCertContext);
    _JumpIfError(hr, error, "cuLoadCert");

    hr = Admin_ImportCertificate(
			    &diAdmin,
			    g_pwszConfig,
			    (WCHAR const *) pCertContext->pbCertEncoded,
			    pCertContext->cbCertEncoded,
			    (g_fForce? ICF_ALLOWFOREIGN : 0) | CR_IN_BINARY,
			    &dwReqID);
    _JumpIfError(hr, error, "Admin_ImportCertificate");

    wprintf(myLoadResourceString(IDS_FORMAT_IMPORTCERT), dwReqID);
    wprintf(wszNewLine);

error:
    cuUnloadCert(&pCertContext);
    if (fRelease)
    {
        Admin_Release(&diAdmin);
    }
    return(hr);
}


HRESULT
GetArchivedKey(
    IN WCHAR const *pwszConfig,
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszfnRecoveryBlob)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BOOL fRelease = FALSE;
    BSTR strKey = NULL;
    WCHAR *pwszT = NULL;

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fRelease = TRUE;

    hr = Admin2_GetArchivedKey(
			&diAdmin,
			pwszConfig,
			RequestId,
			CR_OUT_BINARY,
			&strKey);
    _JumpIfError(hr, error, "Admin_GetArchivedKey");

    if (NULL == pwszfnRecoveryBlob)
    {
	hr = myCryptBinaryToString(
			    (BYTE const *) strKey,
			    SysStringByteLen(strKey),
			    CRYPT_STRING_BASE64HEADER,
			    &pwszT);
	_JumpIfError(hr, error, "myCryptBinaryToString");

	cuPrintCRLFString(NULL, pwszT);
    }
    else
    {
	hr = EncodeToFileW(
		    pwszfnRecoveryBlob,
		    (BYTE const *) strKey,
		    SysStringByteLen(strKey),
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (NULL != strKey)
    {
	SysFreeString(strKey);
    }
    if (fRelease)
    {
        Admin_Release(&diAdmin);
    }
    return(hr);
}


typedef struct _GETKEYSERIAL {
    struct _GETKEYSERIAL *Next;
    BSTR                  strConfig;
    LONG		  RequestId;
    BSTR                  strSerialNumber;
    BSTR                  strCommonName;
    BSTR                  strUPN;
    BSTR                  strHash;
    BSTR                  strCert;
} GETKEYSERIAL;


VOID
FreeKeySerialEntry(
    IN OUT GETKEYSERIAL *pks)
{
    if (NULL != pks->strConfig)
    {
	SysFreeString(pks->strConfig);
    }
    if (NULL != pks->strSerialNumber)
    {
	SysFreeString(pks->strSerialNumber);
    }
    if (NULL != pks->strCommonName)
    {
	SysFreeString(pks->strCommonName);
    }
    if (NULL != pks->strUPN)
    {
	SysFreeString(pks->strUPN);
    }
    if (NULL != pks->strHash)
    {
	SysFreeString(pks->strHash);
    }
    if (NULL != pks->strCert)
    {
	SysFreeString(pks->strCert);
    }
    LocalFree(pks);
}


HRESULT
AddKeySerialList(
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszUPN,
    IN WCHAR const *pwszHash,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN OUT GETKEYSERIAL **ppksList)
{
    HRESULT hr;
    GETKEYSERIAL *pksNew = NULL;
    GETKEYSERIAL *pksT;
    GETKEYSERIAL *pksPrev;
    BOOL fNewConfig = TRUE;

    pksNew = (GETKEYSERIAL *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    sizeof(*pksNew));
    if (NULL == pksNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pksNew->RequestId = RequestId;

    pksNew->strConfig = SysAllocString(pwszConfig);
    pksNew->strSerialNumber = SysAllocString(pwszSerialNumber);
    pksNew->strCommonName = SysAllocString(pwszCommonName);
    pksNew->strUPN = SysAllocString(pwszUPN);
    pksNew->strHash = SysAllocString(pwszHash);
    pksNew->strCert = SysAllocStringByteLen((char const *) pbCert, cbCert);
    if (NULL == pksNew->strConfig ||
	NULL == pksNew->strSerialNumber ||
	(NULL != pwszCommonName && NULL == pksNew->strCommonName) ||
	(NULL != pwszUPN && NULL == pksNew->strUPN) ||
	NULL == pksNew->strHash ||
	NULL == pksNew->strCert)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pksPrev = NULL;
    for (pksT = *ppksList; NULL != pksT; pksT = pksT->Next)
    {
	if (NULL != pksT->strConfig)
	{
	    fNewConfig = 0 != lstrcmp(pksT->strConfig, pksNew->strConfig);
	}
	pksPrev = pksT;
    }
    if (NULL == pksPrev)
    {
	*ppksList = pksNew;
    }
    else
    {
	pksPrev->Next = pksNew;
    }
    if (!fNewConfig)
    {
	SysFreeString(pksNew->strConfig);
	pksNew->strConfig = NULL;
    }
    pksNew = NULL;
    hr = S_OK;

error:
    if (NULL != pksNew)
    {
	FreeKeySerialEntry(pksNew);
    }
    return(hr);
}


HRESULT
cuViewQuery(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszColumn,
    IN WCHAR const *pwszValue1,
    OPTIONAL IN WCHAR const *pwszValue2,
    IN OUT GETKEYSERIAL **ppksList,
    OUT BOOL *pfConnectionFailed)
{
    HRESULT hr;
    DWORD cwc;
    DISPATCHINTERFACE diView;
    DISPATCHINTERFACE diViewRow;
    DISPATCHINTERFACE diViewColumn;
    BOOL fMustRelease = FALSE;
    BOOL fMustReleaseRow = FALSE;
    BOOL fMustReleaseColumn = FALSE;
    LONG ColIndex;
    LONG RowIndex;
    DWORD cRow;
    VARIANT var;
    LONG RequestId;
    DWORD i;
    static WCHAR *apwszCol[] =
    {
#define IV_REQUESTID	0
	wszPROPCERTIFICATEREQUESTID,

#define IV_SERIALNUMBER	1
	wszPROPCERTIFICATESERIALNUMBER,

#define IV_COMMONNAME	2
	wszPROPCOMMONNAME,

#define IV_ARCHIVEDKEY	3
	wszPROPREQUESTRAWARCHIVEDKEY,

#define IV_HASH		4
	wszPROPCERTIFICATEHASH,

#define IV_CERT		5
	wszPROPRAWCERTIFICATE,

#define IV_UPN		6
	wszPROPCERTIFICATEUPN,
    };
    static LONG altype[] =
    {
	PROPTYPE_LONG,
	PROPTYPE_STRING,
	PROPTYPE_STRING,
	PROPTYPE_BINARY,
	PROPTYPE_STRING,
	PROPTYPE_BINARY,
	PROPTYPE_STRING,
    };
    BSTR astrValue[ARRAYSIZE(apwszCol)];

    ZeroMemory(&astrValue, sizeof(astrValue));
    VariantInit(&var);
    *pfConnectionFailed = TRUE;
    
    DBGPRINT((
	DBG_SS_CERTUTILI,
	"Query(%ws, %ws == %ws + %ws)\n",
	pwszConfig,
	pwszColumn,
	pwszValue1,
	pwszValue2));

    hr = View_Init(g_DispatchFlags, &diView);
    _JumpIfError(hr, error, "View_Init");

    fMustRelease = TRUE;

    hr = View_OpenConnection(&diView, pwszConfig);
    _JumpIfError(hr, error, "View_OpenConnection");

    *pfConnectionFailed = FALSE;

    hr = View_GetColumnIndex(
			&diView,
			CVRC_COLUMN_SCHEMA,
			pwszColumn,
			&ColIndex);
    _JumpIfErrorStr(hr, error, "View_GetColumnIndex", pwszColumn);

    cwc = wcslen(pwszValue1);
    if (NULL != pwszValue2)
    {
	cwc += wcslen(pwszValue2);
    }
    var.bstrVal = SysAllocStringLen(NULL, cwc);
    if (NULL == var.bstrVal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }
    var.vt = VT_BSTR;
    wcscpy(var.bstrVal, pwszValue1);
    if (NULL != pwszValue2)
    {
	wcscat(var.bstrVal, pwszValue2);
    }

    hr = View_SetRestriction(
			&diView,
			ColIndex,		// Restriction ColumnIndex
			CVR_SEEK_EQ,
			CVR_SORT_ASCEND,
			&var);			// pvarValue
    _JumpIfError(hr, error, "View_SetRestriction");

    hr = View_SetResultColumnCount(&diView, ARRAYSIZE(apwszCol));
    _JumpIfError(hr, error, "View_SetResultColumnCount");

    for (i = 0; i < ARRAYSIZE(apwszCol); i++)
    {
	hr = View_GetColumnIndex(
			    &diView,
			    CVRC_COLUMN_SCHEMA,
			    apwszCol[i],
			    &ColIndex);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "View_GetColumnIndex",
		    apwszCol[i]);

	hr = View_SetResultColumn(&diView, ColIndex);
	_JumpIfError(hr, error, "View_SetResultColumn");
    }

    hr = View_OpenView(&diView, &diViewRow);
    _JumpIfError(hr, error, "View_OpenView");

    fMustReleaseRow = TRUE;

    for (cRow = 0; ; cRow++)
    {
	hr = ViewRow_Next(&diViewRow, &RowIndex);
	if (S_FALSE == hr || (S_OK == hr && -1 == RowIndex))
	{
	    break;
	}
	_JumpIfError(hr, error, "ViewRow_Next");

	if (fMustReleaseColumn)
	{
	    ViewColumn_Release(&diViewColumn);
	    fMustReleaseColumn = FALSE;
	}
	hr = ViewRow_EnumCertViewColumn(&diViewRow, &diViewColumn);
	_JumpIfError(hr, error, "ViewRow_EnumCertViewColumn");

	fMustReleaseColumn = TRUE;

	for (i = 0; i < ARRAYSIZE(apwszCol); i++)
	{
	    VOID *pv;
	    
	    hr = ViewColumn_Next(&diViewColumn, &ColIndex);
	    if (S_FALSE == hr || (S_OK == hr && -1 == ColIndex))
	    {
		break;
	    }
	    _JumpIfError(hr, error, "ViewColumn_Next");

	    pv = &RequestId;
	    if (PROPTYPE_LONG != altype[i])
	    {
		pv = &astrValue[i];
	    }

	    hr = ViewColumn_GetValue(
				&diViewColumn,
				CV_OUT_BINARY,
				altype[i],
				pv);
	    if (S_OK != hr)
	    {
		_PrintErrorStr2(
			hr,
			"ViewColumn_GetValue",
			apwszCol[i],
			CERTSRV_E_PROPERTY_EMPTY);
		if (CERTSRV_E_PROPERTY_EMPTY != hr)
		{
		    goto error;
		}
	    }
	}

	DBGPRINT((
	    DBG_SS_CERTUTILI,
	    "RequestId=%u  Serial=%ws  CN=%ws  UPN=%ws  Key=%u\n",
	    RequestId,
	    astrValue[IV_SERIALNUMBER],
	    astrValue[IV_COMMONNAME],
	    astrValue[IV_UPN],
	    NULL != astrValue[IV_ARCHIVEDKEY]));

	if (NULL != astrValue[IV_SERIALNUMBER] &&
	    NULL != astrValue[IV_HASH] &&
	    NULL != astrValue[IV_CERT] &&
	    (g_fForce || NULL != astrValue[IV_ARCHIVEDKEY]))
	{
	    hr = AddKeySerialList(
			    pwszConfig,
			    RequestId,
			    astrValue[IV_SERIALNUMBER],
			    astrValue[IV_COMMONNAME],
			    astrValue[IV_UPN],
			    astrValue[IV_HASH],
			    (BYTE const *) astrValue[IV_CERT],
			    SysStringByteLen(astrValue[IV_CERT]),
			    ppksList);
	    _JumpIfError(hr, error, "AddKeySerialList");
	}

	for (i = 0; i < ARRAYSIZE(astrValue); i++)
	{
	    if (NULL != astrValue[i])
	    {
		SysFreeString(astrValue[i]);
		astrValue[i] = NULL;
	    }
	}
    }
    hr = S_OK;

error:
    if (fMustReleaseColumn)
    {
	ViewColumn_Release(&diViewColumn);
    }
    if (fMustReleaseRow)
    {
	ViewRow_Release(&diViewRow);
    }
    if (fMustRelease)
    {
	View_Release(&diView);
    }
    for (i = 0; i < ARRAYSIZE(astrValue); i++)
    {
	if (NULL != astrValue[i])
	{
	    SysFreeString(astrValue[i]);
	}
    }
    VariantClear(&var);
    return(hr);
}


#define wszUSERS	L"Users"
#define wszRECIPIENTS	L"recipients"

#define wszUSERSNL	wszUSERS L"\n"
#define wszRECIPIENTSNL	wszRECIPIENTS L"\n"
#define wszNLRECIPIENTS	L"\n" wszRECIPIENTS

HRESULT
GetKey(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszCommonName,
    OPTIONAL IN WCHAR const *pwszRequesterName,
    OPTIONAL IN WCHAR const *pwszUPN,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OPTIONAL IN WCHAR const *pwszHash,
    IN OUT GETKEYSERIAL **ppksList)
{
    HRESULT hr;
    BOOL fConnectionFailed;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_QUERYING), pwszConfig);
	wprintf(L"...");
    }
    if (NULL != pwszSerialNumber)
    {
	if (!g_fQuiet)
	{
	    wprintf(L"...");
	}
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCERTIFICATESERIALNUMBER,
		    pwszSerialNumber,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	if (S_OK != hr)
	{
	    _PrintIfErrorStr(hr, "cuViewQuery", wszPROPCERTIFICATESERIALNUMBER);
	    if (fConnectionFailed)
	    {
		goto error;
	    }
	}
    }
    if (NULL != pwszHash)
    {
	if (!g_fQuiet)
	{
	    wprintf(L"...");
	}
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCERTIFICATEHASH,
		    pwszHash,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPCERTIFICATEHASH);
    }

    if (!g_fQuiet)
    {
	wprintf(L"...");
    }
    hr = cuViewQuery(
		pwszConfig,
		wszPROPCOMMONNAME,
		pwszCommonName,
		NULL,
		ppksList,
		&fConnectionFailed);
    _PrintIfErrorStr(hr, "cuViewQuery", wszPROPSUBJECTCOMMONNAME);

    if (!g_fQuiet)
    {
	wprintf(L"...");
    }
    hr = cuViewQuery(
		pwszConfig,
		wszPROPCOMMONNAME,
		wszUSERSNL,
		pwszCommonName,
		ppksList,
		&fConnectionFailed);
    _PrintIfErrorStr(hr, "cuViewQuery", wszPROPSUBJECTCOMMONNAME L"+" wszUSERS);

    if (!g_fQuiet)
    {
	wprintf(L"...");
    }
    hr = cuViewQuery(
		pwszConfig,
		wszPROPCOMMONNAME,
		wszRECIPIENTSNL,
		pwszCommonName,
		ppksList,
		&fConnectionFailed);
    _PrintIfErrorStr(hr, "cuViewQuery", wszPROPSUBJECTCOMMONNAME L"+" wszUSERS);

    if (!g_fQuiet)
    {
	wprintf(L"...");
    }
    hr = cuViewQuery(
		pwszConfig,
		wszPROPCOMMONNAME,
		pwszCommonName,
		wszNLRECIPIENTS,
		ppksList,
		&fConnectionFailed);
    _PrintIfErrorStr(hr, "cuViewQuery", wszPROPSUBJECTCOMMONNAME L"+" wszUSERS);

    if (NULL != pwszRequesterName)
    {
	if (!g_fQuiet)
	{
	    wprintf(L"...");
	}
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPREQUESTERNAME,
		    pwszRequesterName,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPREQUESTERNAME);
    }

    if (NULL != pwszUPN)
    {
	if (!g_fQuiet)
	{
	    wprintf(L"...");
	}
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCERTIFICATEUPN,
		    pwszUPN,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPCERTIFICATEUPN);
    }

    if (!g_fQuiet)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
cuConvertEscapeSequences(
    IN OUT WCHAR *pwsz)
{
    WCHAR *pwszSrc = pwsz;
    WCHAR *pwszDst = pwsz;

    while (L'\0' != *pwszSrc)
    {
	WCHAR wc = *pwszSrc++;

	if (L'\\' == wc)
	{
	    switch (*pwszSrc)
	    {
		case 'n':
		    wc = L'\n';
		    pwszSrc++;
		    break;

		case 'r':
		    wc = L'\r';
		    pwszSrc++;
		    break;

		case 't':
		    wc = L'\t';
		    pwszSrc++;
		    break;

		default:
		    break;
	    }
	}
	*pwszDst++ = wc;
    }
    *pwszDst = L'\0';
}


WCHAR *
SplitToken(
    IN OUT WCHAR **ppwszIn,
    IN WCHAR *pwcSeparator)
{
    WCHAR *pwszOut = NULL;
    WCHAR *pwszNext = NULL;
    WCHAR *pwszIn;
    WCHAR *pwsz;

    pwszIn = *ppwszIn;
    if (NULL != pwszIn)
    {
	pwszOut = pwszIn;
	pwsz = wcschr(pwszIn, *pwcSeparator);
	if (NULL != pwsz)
	{
	    *pwsz++ = L'\0';
	    pwszNext = pwsz;
	}
    }
    *ppwszIn = pwszNext;
    return(pwszOut);
}


HRESULT
SimplifyCommonName(
    IN WCHAR const *pwszCommonName,
    OUT WCHAR **ppwszSimpleName)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszRemain;
    WCHAR const *pwszToken;

    *ppwszSimpleName = NULL;

    hr = myDupString(pwszCommonName, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszRemain = pwszDup;
    while (TRUE)
    {
	pwszToken = SplitToken(&pwszRemain, wszNAMESEPARATORDEFAULT);
	if (NULL == pwszToken)
	{
	    pwszToken = pwszCommonName;
	    break;
	}
	if (0 != lstrcmpi(wszUSERS, pwszToken) &&
	    0 != lstrcmpi(wszRECIPIENTS, pwszToken))
	{
	    break;
	}
    }
    hr = myDupString(pwszToken, ppwszSimpleName);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
DumpGetRecoverMergeCommandLine(
    OPTIONAL IN BSTR const strConfig,	// NULL -> -RecoverKey command line
    IN BOOL fRecoverKey,
    IN GETKEYSERIAL const *pks,
    OPTIONAL OUT WCHAR **ppwszSimpleName)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CERT_INFO *pCertInfo;
    BSTR strSerialNumber = NULL;
    WCHAR *pwszSimpleName = NULL;

    if (NULL != ppwszSimpleName)
    {
	*ppwszSimpleName = NULL;
    }
    pcc = CertCreateCertificateContext(
			    X509_ASN_ENCODING,
			    (BYTE const *) pks->strCert,
			    SysStringByteLen(pks->strCert));
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pCertInfo = pcc->pCertInfo;

    // Convert serial number to string

    hr = MultiByteIntegerToBstr(
			FALSE,
			pCertInfo->SerialNumber.cbData,
			pCertInfo->SerialNumber.pbData,
			&strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = SimplifyCommonName(pks->strCommonName, &pwszSimpleName);
    _JumpIfError(hr, error, "SimplifyCommonName");

    if (NULL != strConfig)
    {
	wprintf(
	    L"%ws -config \"%ws\" -getkey %ws \"%ws-%ws.rec\"\n\n",
	    g_pwszProg,
	    strConfig,
	    strSerialNumber,
	    pwszSimpleName,
	    strSerialNumber);
    }
    else if (fRecoverKey)
    {
	wprintf(
	    L"%ws -p password -recoverkey \"%ws-%ws.rec\" \"%ws-%ws.pfx\"\n\n",
	    g_pwszProg,
	    pwszSimpleName,
	    strSerialNumber,
	    pwszSimpleName,
	    strSerialNumber);
    }
    else	// -MergePFX
    {
	wprintf(
	    L"%ws-%ws.pfx",
	    pwszSimpleName,
	    strSerialNumber);
    }
    if (NULL != ppwszSimpleName)
    {
	*ppwszSimpleName = pwszSimpleName;
	pwszSimpleName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != strSerialNumber)
    {
        SysFreeString(strSerialNumber);
    }
    if (NULL != pwszSimpleName)
    {
        LocalFree(pwszSimpleName);
    }
    return(hr);
}


HRESULT
DumpRecoveryCandidate(
    IN GETKEYSERIAL const *pks)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CERT_INFO *pCertInfo;

    pcc = CertCreateCertificateContext(
			    X509_ASN_ENCODING,
			    (BYTE const *) pks->strCert,
			    SysStringByteLen(pks->strCert));
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pCertInfo = pcc->pCertInfo;

    hr = cuDumpSerial(g_wszPad2, IDS_SERIAL, &pCertInfo->SerialNumber);
    _JumpIfError(hr, error, "cuDumpSerial");

    hr = cuDisplayCertName(
			FALSE,		// fMultiLine
			g_wszPad2,
			myLoadResourceString(IDS_SUBJECT), // "Subject"
			g_wszPad2,
			&pCertInfo->Subject);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    if (NULL != pks->strUPN)
    {
	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_UPN_COLON));	// "UPN:"
	wprintf(L"%ws\n", pks->strUPN);
    }

    wprintf(g_wszPad2);
    hr = cuDumpFileTime(IDS_NOTBEFORE, NULL, &pCertInfo->NotBefore);
    _JumpIfError(hr, error, "cuDumpFileTime");

    wprintf(g_wszPad2);
    hr = cuDumpFileTime(IDS_NOTAFTER, NULL, &pCertInfo->NotAfter);
    _JumpIfError(hr, error, "cuDumpFileTime");

    hr = cuDumpCertType(g_wszPad2, pCertInfo);
    _PrintIfError(hr, "cuDumpCertType");

    wprintf(g_wszPad2);
    hr = cuDisplayHash(NULL, pcc, NULL, CERT_SHA1_HASH_PROP_ID, L"sha1");
    _JumpIfError(hr, error, "cuDisplayHash");

error:
    wprintf(wszNewLine);
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
verbGetKey(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszUserNameOrSerialNumber,
    OPTIONAL IN WCHAR const *pwszfnRecoveryBlob,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diConfig;
    BOOL fMustRelease = FALSE;
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszSimpleName = NULL;
    WCHAR const *pwszRequesterName = NULL;
    WCHAR const *pwszUPN = NULL;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strHash = NULL;
    GETKEYSERIAL *pksList = NULL;
    GETKEYSERIAL *pksT;
    DWORD cCandidate;

    hr = myMakeSerialBstr(pwszUserNameOrSerialNumber, &strSerialNumber);
    CSASSERT((S_OK != hr) ^ (NULL != strSerialNumber));

    hr = WszToMultiByteInteger(
			    TRUE,
			    pwszUserNameOrSerialNumber,
			    &cbHash,
			    &pbHash);
    _PrintIfError2(hr, "WszToMultiByteInteger", hr);
    if (S_OK == hr)
    {
	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");
    }
    hr = myDupString(pwszUserNameOrSerialNumber, &pwszCommonName);
    _JumpIfError(hr, error, "myDupString");

    cuConvertEscapeSequences(pwszCommonName);

    if (NULL != wcschr(pwszUserNameOrSerialNumber, L'\\'))
    {
	pwszRequesterName = pwszUserNameOrSerialNumber;
    }
    if (NULL != wcschr(pwszUserNameOrSerialNumber, L'@'))
    {
	pwszUPN = pwszUserNameOrSerialNumber;
    }

    if (NULL == g_pwszConfig)
    {
	LONG i;
	LONG count;
	LONG Index;
	
	hr = Config_Init(g_DispatchFlags, &diConfig);
	_JumpIfError(hr, error, "Config_Init");

	fMustRelease = TRUE;

	hr = Config_Reset(&diConfig, 0, &count);
	_JumpIfError(hr, error, "Config_Reset");

	Index = 0;
	for (i = 0; i < count; i++)
	{
	    hr = Config_Next(&diConfig, &Index);
	    if (S_OK != hr && S_FALSE != hr)
	    {
		_JumpError(hr, error, "Config_Next");
	    }
	    hr = S_OK;
	    if (-1 == Index)
	    {
		break;
	    }

	    hr = Config_GetField(&diConfig, wszCONFIG_CONFIG, &strConfig);
	    _JumpIfError(hr, error, "Config_GetField");

	    hr = GetKey(
		    strConfig,
		    pwszCommonName,
		    pwszRequesterName,
		    pwszUPN,
		    strSerialNumber,
		    strHash,
		    &pksList);
	    _PrintIfError(hr, "GetKey");	// Ignore connection failures
	}
    }
    else
    {
	hr = GetKey(
		g_pwszConfig,
		pwszCommonName,
		pwszRequesterName,
		pwszUPN,
		strSerialNumber,
		strHash,
		&pksList);
	_JumpIfError(hr, error, "GetKey");
    }

    cCandidate = 0;
    for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
    {
	if (NULL != pksT->strConfig)
	{
	    wprintf(L"\n\"%ws\"\n", pksT->strConfig);
	}
	hr = DumpRecoveryCandidate(pksT);
	_PrintIfError(hr, "DumpRecoveryCandidate");

	cCandidate++;
    }
    if (NULL == pwszfnRecoveryBlob && 0 != cCandidate)
    {
	BSTR strConfigT;
	DWORD cPFX;

	strConfigT = NULL;
	for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
	{
	    if (NULL != pksT->strConfig)
	    {
		strConfigT = pksT->strConfig;
	    }
	    DumpGetRecoverMergeCommandLine(strConfigT, FALSE, pksT, NULL);
	}
	for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
	{
	    DumpGetRecoverMergeCommandLine(NULL, TRUE, pksT, NULL);
	}

	cPFX = 0;
	wprintf(L"%ws -p \"password,password\" -MergePFX \"", g_pwszProg);
	for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
	{
	    if (0 != cPFX)
	    {
		wprintf(L",");
	    }
	    DumpGetRecoverMergeCommandLine(
				NULL,
				FALSE,
				pksT,
				0 == cPFX? &pwszSimpleName : NULL);
	    cPFX++;
	}
	wprintf(L"\" \"%ws.pfx\"\n\n", pwszSimpleName);
    }
    if (1 != cCandidate)
    {
	hr = 0 == cCandidate? CRYPT_E_NOT_FOUND : TYPE_E_AMBIGUOUSNAME;
	_JumpError(hr, error, "GetKey");
    }
    hr = GetArchivedKey(
		    pksList->strConfig,
		    pksList->RequestId,
		    pwszfnRecoveryBlob);
    _JumpIfError(hr, error, "GetArchivedKey");

error:
    while (NULL != pksList)
    {
	pksT = pksList;
	pksList = pksList->Next;
	FreeKeySerialEntry(pksT);
    }
    if (fMustRelease)
    {
	Config_Release(&diConfig);
    }
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != pwszSimpleName)
    {
	LocalFree(pwszSimpleName);
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


VOID
DeleteKey(
    IN CRYPT_KEY_PROV_INFO const *pkpi)
{
    HCRYPTPROV hProv;

    CryptAcquireContext(
		    &hProv,
		    pkpi->pwszContainerName,
		    pkpi->pwszProvName,
		    pkpi->dwProvType,
		    CRYPT_DELETEKEYSET | pkpi->dwFlags);
}


HRESULT
SaveRecoveredKey(
    IN CERT_CONTEXT const *pccUser,
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    OPTIONAL IN WCHAR const *pwszfnPFX,
    OPTIONAL IN WCHAR const *pwszPassword)
{
    HRESULT hr;
    HCERTSTORE hStoreMemory = NULL;
    BOOL fMatchingKey;
    WCHAR wszPassword[MAX_PATH];
    CRYPT_KEY_PROV_INFO kpi;
    CRYPT_DATA_BLOB pfx;

    pfx.pbData = NULL;
    ZeroMemory(&kpi, sizeof(kpi));

    hr = myValidateKeyBlob(
		    pbKey,
		    cbKey,
		    &pccUser->pCertInfo->SubjectPublicKeyInfo,
		    CERT_V1 == pccUser->pCertInfo->dwVersion,
		    &kpi);
    _JumpIfError(hr, error, "myValidateKeyBlob");

    if (!CertSetCertificateContextProperty(
				    pccUser,
				    CERT_KEY_PROV_INFO_PROP_ID,
				    0,
				    &kpi))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }

    hStoreMemory = CertOpenStore(
			    CERT_STORE_PROV_MEMORY,
			    X509_ASN_ENCODING,
			    NULL,
			    0,
			    NULL);
    if (NULL == hStoreMemory)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Begin Chain Building

    hr = myAddChainToMemoryStore(hStoreMemory, pccUser);
    _JumpIfError(hr, error, "myAddChainToMemoryStore");

    // End Chain Building

    if (NULL != pwszfnPFX)
    {
	if (NULL == pwszPassword || 0 == wcscmp(L"*", pwszPassword))
	{
	    hr = cuGetPassword(TRUE, wszPassword, ARRAYSIZE(wszPassword));
	    _JumpIfError(hr, error, "cuGetPassword");

	    pwszPassword = wszPassword;
	}
    }
    hr = myPFXExportCertStore(
		hStoreMemory,
		&pfx,
		pwszPassword,
		EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY);
    _JumpIfError(hr, error, "myPFXExportCertStore");

    if (NULL != pwszfnPFX)
    {
	hr = EncodeToFileW(
		pwszfnPFX,
		pfx.pbData,
		pfx.cbData,
		CRYPT_STRING_BINARY | (g_fForce? DECF_FORCEOVERWRITE : 0));
	_JumpIfError(hr, error, "EncodeToFileW");
    }

error:
    if (NULL != hStoreMemory)
    {
	CertCloseStore(hStoreMemory, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != kpi.pwszContainerName)
    {
	DeleteKey(&kpi);
	LocalFree(kpi.pwszContainerName);
    }
    if (NULL != pfx.pbData)
    {
	LocalFree(pfx.pbData);
    }
    return(hr);
}


HRESULT
verbRecoverKey(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnRecoveryBlob,
    OPTIONAL IN WCHAR const *pwszfnPFX,
    OPTIONAL IN WCHAR const *pwszRecipientIndex,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    BYTE *pbIn = NULL;
    DWORD cbIn;
    BYTE *pbEncryptedPKCS7 = NULL;
    DWORD cbEncryptedPKCS7;
    DWORD cSigner;
    DWORD cRecipient;
    DWORD dwMsgType;
    char *pszInnerContentObjId = NULL;
    HCERTSTORE hStore = NULL;
    HCRYPTMSG hMsg = NULL;
    CERT_CONTEXT const *pccUser = NULL;
    BYTE abHashUserCert[CBMAX_CRYPT_HASH_LEN];
    CRYPT_HASH_BLOB BlobHash;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    DWORD RecipientIndex = MAXDWORD;

    if (NULL != pwszRecipientIndex)
    {
	hr = cuGetLong(pwszRecipientIndex, (LONG *) &RecipientIndex);
	_JumpIfError(hr, error, "RecipientIndex must be a number");
    }

    hr = DecodeFileW(pwszfnRecoveryBlob, &pbIn, &cbIn, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }

    // Decode outer PKCS 7 signed message, which contains all of the certs.

    hr = myDecodePKCS7(
		    pbIn,
		    cbIn,
		    &pbEncryptedPKCS7,
		    &cbEncryptedPKCS7,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    &hStore,
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7(outer)");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (CMSG_SIGNED != dwMsgType)
    {
	_JumpError(hr, error, "dwMsgType(outer)");
    }
    if (0 == cSigner)
    {
	_JumpError(hr, error, "cSigner(outer)");
    }
    if (0 != cRecipient)
    {
	_JumpError(hr, error, "cRecipient(outer)");
    }
    if (NULL == pszInnerContentObjId ||
	0 != strcmp(szOID_RSA_data, pszInnerContentObjId))
    {
	_JumpError(hr, error, "pszInnerContentObjId(outer)");
    }
    CSASSERT(NULL != hMsg);
    ZeroMemory(abHashUserCert, sizeof(abHashUserCert));
    BlobHash.cbData = sizeof(abHashUserCert);
    BlobHash.pbData = abHashUserCert;
    hr = cuDumpSigners(
		    hMsg,
		    pszInnerContentObjId,
		    hStore,
		    cSigner,
		    NULL == pbEncryptedPKCS7,	// fContentEmpty
		    TRUE,			// fVerifyOnly
		    BlobHash.pbData,
		    &BlobHash.cbData);
    _JumpIfError(hr, error, "cuDumpSigners(outer)");

    pccUser = CertFindCertificateInStore(
			hStore,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			0,			// dwFindFlags
			CERT_FIND_HASH,
			&BlobHash,
			NULL);
    if (NULL == pccUser)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertFindCertificateInStore");
    }
    LocalFree(pszInnerContentObjId);
    pszInnerContentObjId = NULL;

    CryptMsgClose(hMsg);
    hMsg = NULL;

    // Decode inner PKCS 7 encrypted message, which contains the private key.

    hr = myDecodePKCS7(
		    pbEncryptedPKCS7,
		    cbEncryptedPKCS7,
		    NULL,			// ppbContents
		    NULL,			// pcbContents
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    NULL,			// phStore
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7(inner)");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (CMSG_ENVELOPED != dwMsgType)
    {
	_JumpError(hr, error, "dwMsgType(inner)");
    }
    if (0 != cSigner)
    {
	_JumpError(hr, error, "cSigner(inner)");
    }
    if (0 == cRecipient)
    {
	_JumpError(hr, error, "cRecipient(inner)");
    }
    if (NULL == pszInnerContentObjId ||
	0 != strcmp(szOID_RSA_data, pszInnerContentObjId))
    {
	_JumpError(hr, error, "pszInnerContentObjId(inner)");
    }
    CSASSERT(NULL != hMsg);
    if (MAXDWORD != RecipientIndex && cRecipient <= RecipientIndex)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "RecipientIndex too large");
    }

    hr = cuDumpEncryptedAsnBinary(
			    hMsg,
			    cRecipient,
			    RecipientIndex,
			    hStore,
			    NULL,
			    pbEncryptedPKCS7,
			    cbEncryptedPKCS7,
			    TRUE,
			    &pbKey,
			    &cbKey);
    {
	HRESULT hr2;

	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_USER_CERT)); // "User Certificate:"
	wprintf(wszNewLine);

	hr2 = cuDumpIssuerSerialAndSubject(
			    &pccUser->pCertInfo->Issuer,
			    &pccUser->pCertInfo->SerialNumber,
			    &pccUser->pCertInfo->Subject,
			    NULL);		// hStore
	_PrintIfError(hr2, "cuDumpIssuerSerialAndSubject(user)");
    }

    if (CRYPT_E_NO_DECRYPT_CERT != hr)
    {
	_JumpIfError(hr, error, "cuDumpEncryptedAsnBinary");

	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	    hr = cuDumpPrivateKeyBlob(pbKey, cbKey, FALSE);
	    _JumpIfError(hr, error, "cuDumpPrivateKeyBlob");
	}

	// Verify the key matches the cert, then save in a PFX

	hr = SaveRecoveredKey(
			pccUser,
			pbKey,
			cbKey,
			pwszfnPFX,
			g_pwszPassword);
	_JumpIfError(hr, error, "SaveRecoveredKey");
    }
    else
    {
	// Can't decrypt the private key, list Recipient cert info.

	wprintf(myLoadResourceString(IDS_CANT_DECRYPT)); // "Cannot decrypt message content."
	wprintf(wszNewLine);
    }
    if (CRYPT_E_NO_DECRYPT_CERT == hr || NULL == pwszfnPFX)
    {
	HRESULT hrDecrypt = hr;

	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_NEED_RECOVERY_CERT)); // "Key recovery requires one of the following certificates and its private key:"
	wprintf(wszNewLine);

	hr = cuDumpRecipients(hMsg, hStore, cRecipient, TRUE);
	_JumpIfError(hr, error, "cuDumpRecipients");

	hr = hrDecrypt;
	_JumpIfError(hr, error, "Cannot decrypt");
    }
    hr = S_OK;

error:
    if (NULL != pccUser)
    {
	CertFreeCertificateContext(pccUser);
    }
    if (NULL != pbKey)
    {
        LocalFree(pbKey);
    }
    if (NULL != pbIn)
    {
        LocalFree(pbIn);
    }
    if (NULL != pbEncryptedPKCS7)
    {
        LocalFree(pbEncryptedPKCS7);
    }
    if (NULL != pszInnerContentObjId)
    {
        LocalFree(pszInnerContentObjId);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\backup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       backup.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


#include "certbcli.h"


HRESULT
verbDynamicFileList(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fServerOnline;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    WCHAR const *pwsz;
    BOOL fImpersonating = FALSE;

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    hr = CertSrvIsServerOnline(g_pwszConfig, &fServerOnline);
    _JumpIfError(hr, error, "CertSrvIsServerOnline");

    //wprintf(L"Cert Server Online -> %d\n", fServerOnline);

    if (!fServerOnline)
    {
	hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
	_JumpError(hr, error, "CertSrvIsServerOnline");
    }

    hr = CertSrvRestorePrepare(g_pwszConfig, 0, &hcsbc);
    _JumpIfError(hr, error, "CertSrvRestorePrepare");

    fBegin = TRUE;

    hr = CertSrvBackupGetDynamicFileList(hcsbc, &pwszzFileList, &cbList);
    _JumpIfError(hr, error, "CertSrvBackupGetDynamicFileList");

    for (pwsz = pwszzFileList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	wprintf(
	    L"%x: %ws\n",
	    SAFE_SUBTRACT_POINTERS((BYTE *) pwsz, (BYTE *) pwszzFileList),
	    pwsz);
    }
    wprintf(L"%x\n", cbList);

error:
    if (fBegin)
    {
	hr2 = CertSrvBackupEnd(hcsbc);
	_PrintIfError(hr, "CertSrvBackupEnd");
    }
    if (NULL != pwszzFileList)
    {
	CertSrvBackupFree(pwszzFileList);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


HRESULT
verbDatabaseLocations(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fServerOnline;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    WCHAR const *pwsz;
    BOOL fImpersonating = FALSE;

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    hr = CertSrvIsServerOnline(g_pwszConfig, &fServerOnline);
    _JumpIfError(hr, error, "CertSrvIsServerOnline");

    //wprintf(L"Cert Server Online -> %d\n", fServerOnline);

    if (!fServerOnline)
    {
	hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
	_JumpError(hr, error, "CertSrvIsServerOnline");
    }

    hr = CertSrvBackupPrepare(g_pwszConfig, 0, CSBACKUP_TYPE_FULL, &hcsbc);
    _JumpIfError(hr, error, "CertSrvBackupPrepare");

    fBegin = TRUE;

    hr = CertSrvRestoreGetDatabaseLocations(hcsbc, &pwszzFileList, &cbList);
    _JumpIfError(hr, error, "CertSrvRestoreGetDatabaseLocations");

    for (pwsz = pwszzFileList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	wprintf(
	    L"%x: %02x %ws\n",
	    SAFE_SUBTRACT_POINTERS((BYTE *) pwsz, (BYTE *) pwszzFileList),
	    *pwsz,
	    &pwsz[1]);
    }
    wprintf(L"%x\n", cbList);

error:
    if (fBegin)
    {
	hr2 = CertSrvBackupEnd(hcsbc);
	_PrintIfError(hr, "CertSrvBackupEnd");
    }
    if (NULL != pwszzFileList)
    {
	CertSrvBackupFree(pwszzFileList);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


DWORD
DBSetFlags(
    IN WCHAR const *pwszType,
    IN OUT DWORD *pFlags)
{
    HRESULT hr;
    
    if (NULL != pwszType)
    {
	if (0 == lstrcmpi(pwszType, L"Incremental"))
	{
	    *pFlags |= CDBBACKUP_INCREMENTAL;
	}
	else
	if (0 == lstrcmpi(pwszType, L"KeepLog"))
	{
	    *pFlags |= CDBBACKUP_KEEPOLDLOGS;
	}
	else
	{
	    hr = E_INVALIDARG;
	    _JumpError2(hr, error, "bad type", hr);
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
verbBackup(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszType1,
    IN WCHAR const *pwszType2)
{
    HRESULT hr;
    DWORD Flags = 0;

    if (NULL != pwszPassword)
    {
	hr = DBSetFlags(pwszPassword, &Flags);
	if (S_OK == hr)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Missing Password");
	}
    }
    hr = verbBackupPFX(pwszOption, pwszBackupDir, pwszPassword, NULL, NULL);
    _JumpIfError(hr, error, "verbBackupPFX");

    hr = verbBackupDB(pwszOption, pwszBackupDir, pwszType1, pwszType2, NULL);
    _JumpIfError(hr, error, "verbBackupDB");

error:
    return(hr);
}


typedef struct _CUBACKUP
{
    IN DWORD Flags;
    IN WCHAR const *pwszBackupDir;
    OUT DBBACKUPPROGRESS *pdbp;
} CUBACKUP;


DWORD
cuBackupThread(
    OPTIONAL IN OUT VOID *pvparms)
{
    HRESULT hr;
    CUBACKUP *pparms = (CUBACKUP *) pvparms;

    CSASSERT(NULL != pparms);
    hr = myBackupDB(
		g_pwszConfig,
		pparms->Flags,
		pparms->pwszBackupDir,
		pparms->pdbp);
    _JumpIfError(hr, error, "myBackupDB");

error:
    return(hr);
}


DWORD
cuRestoreThread(
    OPTIONAL IN OUT VOID *pvparms)
{
    HRESULT hr;
    CUBACKUP *pparms = (CUBACKUP *) pvparms;

    CSASSERT(NULL != pparms);
    hr = myRestoreDB(
		g_pwszConfig,
		pparms->Flags,
		pparms->pwszBackupDir,
		NULL,
		NULL,
		NULL,
		pparms->pdbp);
    _JumpIfError(hr, error, "myRestoreDB");

error:
    return(hr);
}


VOID
cuBackupRestoreProgress(
    IN BOOL fRestore,
    IN BOOL fIncremental,
    OPTIONAL IN DBBACKUPPROGRESS const *pdbp)
{
    DWORD id;
    DWORD dw;
    static DWORD s_LastValue;
    static DWORD s_LastState;
    static DWORD s_State;
    static DWORD s_EndState;
    static BOOL s_fDone;

    if (NULL == pdbp)
    {
	s_State = fIncremental? 1 : 0;	// Incremental starts with log files
	s_LastState = s_State - 1;
	s_LastValue = MAXDWORD;
	s_EndState = fRestore? 1 : 2;	// Restore ends with log files
	s_fDone = FALSE;
    }
    else
    {
	BOOL fPrint;

	switch (s_State)
	{
	    case 0:
		dw = pdbp->dwDBPercentComplete;
		id = fRestore?
		    IDS_RESTOREPROGRESSDB :	// "Restoring Database files"
		    IDS_BACKUPPROGRESSDB;	// "Backing up Database files"
		break;

	    case 1:
		dw = pdbp->dwLogPercentComplete;
		id = fRestore?
		    IDS_RESTOREPROGRESSLOG :	// "Restoring Log files"
		    IDS_BACKUPPROGRESSLOG;	// "Backing up Log files"
		break;

	    default:
		dw = pdbp->dwTruncateLogPercentComplete;
		CSASSERT(!fRestore);
		id = IDS_BACKUPPROGRESSTRUNCATELOG;	// "Truncating Logs"
		break;
	}

	fPrint = s_LastState != s_State || s_LastValue != dw;
#if 0
	if (g_fVerbose)
	{
	    wprintf(
		L"\n%ws %d %3u%% -- %d %3u%% -- %3u %3u %3u%ws",
		fPrint? L"+" : L"-",
		s_LastState,
		s_LastValue,
		s_State,
		dw,
		pdbp->dwDBPercentComplete,
		pdbp->dwLogPercentComplete,
		pdbp->dwTruncateLogPercentComplete,
		fPrint? L"\n" : L"");
	}
#endif
	if (fPrint)
	{
	    wprintf(L"\r%ws: %u%%", myLoadResourceString(id), dw);
	}
	s_LastState = s_State;
	s_LastValue = dw;
	if (!s_fDone && 100 <= dw)
	{
	    wprintf(wszNewLine);
	    if (s_EndState == s_State)
	    {
		s_fDone = TRUE;
	    }
	    else if (s_EndState > s_State)
	    {
		s_State++;
		cuBackupRestoreProgress(fRestore, fIncremental, pdbp);
	    }
	}
    }
}


DWORD
cuBackupRestoreDB(
    IN BOOL fRestore,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir)
{
    HRESULT hr = S_OK;
    DBBACKUPPROGRESS dbp;
    CUBACKUP parms;
    HANDLE hThread = NULL;
    DWORD ThreadId;
    BOOL fIncremental = 0 != (CDBBACKUP_INCREMENTAL & Flags);

    parms.Flags = Flags;
    parms.pwszBackupDir = pwszBackupDir;
    parms.pdbp = &dbp;
    ZeroMemory(&dbp, sizeof(dbp));

    hThread = CreateThread(
			NULL,		// lpThreadAttributes (Security Attr)
			0,		// dwStackSize
			fRestore? cuRestoreThread : cuBackupThread,
			&parms,		// lpParameter
			0,		// dwCreationFlags
			&ThreadId);
    if (NULL == hThread)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateThread");
    }

    DBGPRINT((DBG_SS_CERTUTILI, "Backup Thread = %x\n", ThreadId));

    // Wait for the backup thread to return.

    cuBackupRestoreProgress(fRestore, fIncremental, NULL);
    while (TRUE)
    {
	hr = WaitForSingleObject(hThread, 500);
	DBGPRINT((DBG_SS_CERTUTILI, "Wait for backup returns %x\n", hr));

	cuBackupRestoreProgress(fRestore, fIncremental, &dbp);

	if ((HRESULT) WAIT_OBJECT_0 == hr)
	{
	    // Backup thread returned.

	    if (!GetExitCodeThread(hThread, (DWORD *) &hr))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "GetExitCodeThread");
	    }
	    DBGPRINT((DBG_SS_CERTUTILI, "Backup thread exit: %x\n", hr));
	    _JumpIfError(hr, error, "cuBackupThread");

	    break;	// Backup Thread terminated successfully
	}

	// Wait failed.  Why?

	if ((HRESULT) WAIT_TIMEOUT != hr)
	{
	    _JumpError(hr, error, "WaitForSingleObject");
	}

	// Worker thread still busy.  Wait again...
    }

error:
    DBGPRINT((DBG_SS_CERTUTILI, "cuBackupThread returns %x\n", hr));
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    return(hr);
}


HRESULT
verbBackupDB(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszType1,
    IN WCHAR const *pwszType2,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Flags = 0;

    hr = DBSetFlags(pwszType1, &Flags);
    _JumpIfError(hr, error, "DBSetFlags");

    hr = DBSetFlags(pwszType2, &Flags);
    _JumpIfError(hr, error, "DBSetFlags");

    if (g_fForce)
    {
	Flags |= CDBBACKUP_OVERWRITE;
    }

    wprintf(
	myLoadResourceString(
	    (CDBBACKUP_INCREMENTAL & Flags)?
	     IDS_FORMAT_BACKEDUPDBNOFULL : // "Incremental database backup for %ws."
	     IDS_FORMAT_BACKEDUPDBFULL),   // "Full database backup for %ws."
	    g_pwszConfig);
    wprintf(wszNewLine);

    hr = myBackupDB(g_pwszConfig, (Flags|CDBBACKUP_VERIFYONLY), pwszBackupDir, NULL);
    if (S_OK != hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_INVALIDBACKUPDIR), // "Not a valid backup target directory: %ws."
	    pwszBackupDir);
	wprintf(wszNewLine);
	_JumpError(hr, error, "myBackupDB");
    }

    // Perfom the actual backup:

    hr = cuBackupRestoreDB(FALSE, Flags, pwszBackupDir);
    _JumpIfError(hr, error, "cuBackupRestoreDB");


    Flags &= ~CDBBACKUP_OVERWRITE;
    Flags |= CDBBACKUP_VERIFYONLY;

    hr = myRestoreDB(
		g_pwszConfig,
		Flags,
		pwszBackupDir,
		NULL,
		NULL,
		NULL,
		NULL);
    if (S_OK != hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_BADBACKUPRESULTS), // "Backup content verification failed: %ws."
	    pwszBackupDir);
	wprintf(wszNewLine);
	_JumpError(hr, error, "myRestoreDB");
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_BACKEDUPDB), // "Backed up database to %ws."
	pwszBackupDir);
    wprintf(wszNewLine);
    wprintf(
	myLoadResourceString(
	    (CDBBACKUP_KEEPOLDLOGS & Flags)?
	     IDS_FORMAT_BACKEDUPDBKEEP :    // "Database logs were preserved."
	     IDS_FORMAT_BACKEDUPDBNOKEEP)); // "Database logs successfully truncated."
    wprintf(wszNewLine);

error:
    return(hr);
}


HRESULT
cuGetPasswordString(
    IN LONG idMsg,
    OUT WCHAR *pwszPassword,
    IN DWORD cwcPassword)
{
    HRESULT hr;
    WCHAR *pwsz;
    WCHAR *pwszLast;
    LONG wc;
    HANDLE hConsole;
    DWORD InputMode = FILE_TYPE_UNKNOWN;
    DWORD ConsoleMode;

    // Prompt for password, making sure password isn't echoed.
    // If the stdin is redirected, don't bother querying/changing console mode.

    wprintf(L"%ws ", myLoadResourceString(idMsg));
    fflush(stdout);

    hConsole = GetStdHandle(STD_INPUT_HANDLE);
    if (INVALID_HANDLE_VALUE != hConsole)
    {
	InputMode = GetFileType(hConsole);
	if (FILE_TYPE_CHAR == InputMode)
	{
	    GetConsoleMode(hConsole, &ConsoleMode);
	    SetConsoleMode(
		    hConsole,
		    ~ENABLE_ECHO_INPUT & ConsoleMode);
		    //~(ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT) & ConsoleMode);
	}
    }

    pwsz = pwszPassword;
    pwszLast = &pwsz[cwcPassword - 1];

    while (TRUE)
    {
	wc = _fgetwchar();

	if (WEOF == wc || L'\r' == wc || L'\n' == wc)
	{
	    break;
	}
	if (L'\b' == wc)
	{
	    if (pwsz == pwszPassword)
	    {
		continue;	// don't backup buffer or console display
	    }
	    pwsz--;
	}
	else
	{
	    if (pwsz >= pwszLast)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		goto error;
	    }
	    *pwsz++ = (WCHAR) wc;
	    wc = L'*';
	}
	//_fputwchar((WCHAR) wc);
	//fflush(stdout);
    }
    CSASSERT(&pwszPassword[cwcPassword] > pwsz);
    *pwsz = L'\0';
    hr = S_OK;

error:
    if (FILE_TYPE_CHAR == InputMode)
    {
	SetConsoleMode(hConsole, ConsoleMode);
    }
    wprintf(wszNewLine);
    return(hr);
}


HRESULT
cuGetPassword(
    IN BOOL fVerify,
    OUT WCHAR *pwszPassword,
    IN DWORD cwcPassword)
{
    HRESULT hr;
    WCHAR wszPassword2[MAX_PATH];

    while (TRUE)
    {
	hr = cuGetPasswordString(
			fVerify? IDS_NEWPASSWORDPROMPT : IDS_PASSWORDPROMPT,
			pwszPassword,
			cwcPassword);
	_JumpIfError(hr, error, "cuGetPasswordString");

	if (!fVerify)
	{
	    break;
	}

	hr = cuGetPasswordString(
			IDS_CONFIRMPASSWORDPROMPT,
			wszPassword2,
			ARRAYSIZE(wszPassword2));
	_JumpIfError(hr, error, "cuGetPasswordString");

	if (0 == wcscmp(pwszPassword, wszPassword2))
	{
	    break;
	}
	wprintf(myLoadResourceString(IDS_NOCONFIRMPASSWORD));
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuGetLocalCANameFromConfig(
    OPTIONAL OUT WCHAR **ppwszMachine,
    OPTIONAL OUT WCHAR **ppwszCA)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwsz;
    WCHAR *pwszMachine = NULL;
    WCHAR *pwszCA = NULL;

    if (NULL != ppwszCA)
    {
	*ppwszCA = NULL;
    }

    pwsz = wcschr(g_pwszConfig, L'\\');
    if (NULL == pwsz)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad config string");
    }

    cwc = SAFE_SUBTRACT_POINTERS(pwsz, g_pwszConfig);
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    CopyMemory(pwszMachine, g_pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';
    if (0 != lstrcmpi(pwszMachine, g_pwszDnsName) &&
	0 != lstrcmpi(pwszMachine, g_pwszOldName))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "config string not local");
    }
    pwsz++;
    cwc = wcslen(pwsz);

    if (NULL != ppwszCA)
    {
	pwszCA = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszCA)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszCA, pwsz);
    }

    if (NULL != ppwszMachine)
    {
	*ppwszMachine = pwszMachine;
	pwszMachine = NULL;
    }
    if (NULL != ppwszCA)
    {
	*ppwszCA = pwszCA;
	pwszCA = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszMachine)
    {
    	LocalFree(pwszMachine);
    }
    if (NULL != pwszCA)
    {
	LocalFree(pwszCA);
    }
    return(hr);
}


HRESULT
verbBackupPFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR wszPassword[MAX_PATH];
    WCHAR *pwszMachine = NULL;
    WCHAR *pwszCA = NULL;
    WCHAR *pwszPFXFileOut = NULL;

    hr = cuGetLocalCANameFromConfig(&pwszMachine, &pwszCA);
    _JumpIfError(hr, error, "cuGetLocalCANameFromConfig");

    if (NULL == pwszPassword || 0 == wcscmp(L"*", pwszPassword))
    {
	hr = cuGetPassword(TRUE, wszPassword, ARRAYSIZE(wszPassword));
	_JumpIfError(hr, error, "cuGetPassword");

	pwszPassword = wszPassword;
    }
    hr = myCertServerExportPFX(
			pwszCA,
			pwszBackupDir,
			pwszPassword,
			g_fForce,
                        TRUE,  // attempt private key backup
			&pwszPFXFileOut);
    _JumpIfError(hr, error, "myCertServerExportPFX");

    wprintf(
	myLoadResourceString(IDS_FORMAT_BACKEDUP), // "Backed up keys and certificates for %ws\\%ws to %ws."
	pwszMachine,
	pwszCA,
	pwszPFXFileOut);
    wprintf(wszNewLine);

error:
    if (NULL != pwszPFXFileOut)
    {
	LocalFree(pwszPFXFileOut);
    }
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    if (NULL != pwszCA)
    {
	LocalFree(pwszCA);
    }
    return(hr);
}


HRESULT
verbRestore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = verbRestorePFX(pwszOption, pwszBackupDir, pwszPassword, NULL, NULL);
    _JumpIfError(hr, error, "verbRestorePFX");

    hr = verbRestoreDB(pwszOption, pwszBackupDir, NULL, NULL, NULL);
    _JumpIfError(hr, error, "verbRestoreDB");

error:
    return(hr);
}


HRESULT
verbRestoreDB(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Flags;

    hr = cuGetLocalCANameFromConfig(NULL, NULL);
    _JumpIfError(hr, error, "cuGetLocalCANameFromConfig");

    wprintf(
	myLoadResourceString(IDS_FORMAT_RESTOREDB), // "Restoring database for %ws."
	g_pwszConfig);
    wprintf(wszNewLine);

    Flags = CDBBACKUP_VERIFYONLY;
    if (g_fForce)
    {
	Flags |= CDBBACKUP_OVERWRITE;
    }
    while (TRUE)
    {
	hr = myRestoreDB(
		    g_pwszConfig,
		    Flags,
		    pwszBackupDir,
		    NULL,
		    NULL,
		    NULL,
		    NULL);
	if (S_OK == hr)
	{
	    break;
	}
	if (!(CDBBACKUP_INCREMENTAL & Flags))
	{
	    Flags |= CDBBACKUP_INCREMENTAL;
	    continue;
	}
	wprintf(
	    myLoadResourceString(IDS_FORMAT_INVALIDRESTOREDIR), // "Not a valid backup directory: %ws."
	    pwszBackupDir);
	wprintf(wszNewLine);
	_JumpError(hr, error, "myRestoreDB");
    }

    Flags &= ~CDBBACKUP_VERIFYONLY;


    // Perfom the actual restore:

    hr = cuBackupRestoreDB(TRUE, Flags, pwszBackupDir);
    _JumpIfError(hr, error, "cuBackupRestoreDB");


    wprintf(
	myLoadResourceString(
	    (CDBBACKUP_INCREMENTAL & Flags)?
	     IDS_FORMAT_RESTOREDDBNOFULL : // "Incremental database restore for %ws."
	     IDS_FORMAT_RESTOREDDBFULL),   // "Full database restore for %ws."
	    g_pwszConfig);
    wprintf(wszNewLine);

    wprintf(
	myLoadResourceString(IDS_FORMAT_RESTORE_NEEDS_RESTART), // "Stop and Start the Certificate Server to complete database restore from %ws."
	pwszBackupDir);
    wprintf(wszNewLine);

error:
    return(hr);
}


HRESULT
verbRestorePFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDirOrPFXFile,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR wszPassword[MAX_PATH];
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszPFXFile = NULL;

    if (NULL == pwszPassword || 0 == wcscmp(L"*", pwszPassword))
    {
	hr = cuGetPassword(FALSE, wszPassword, ARRAYSIZE(wszPassword));
	_JumpIfError(hr, error, "cuGetPassword");

	pwszPassword = wszPassword;
    }
    hr = myCertServerImportPFX(
			    pwszBackupDirOrPFXFile,
			    pwszPassword,
			    g_fForce,
			    &pwszCommonName,
			    &pwszPFXFile,
			    NULL);
    if (!g_fForce && HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_USE_FORCE), // "Certificate or key exists.  Use the %ws option to overwrite."
	    L"-f");
	wprintf(wszNewLine);
    }
    _JumpIfError(hr, error, "myCertServerImportPFX");

    wprintf(
	myLoadResourceString(IDS_FORMAT_RESTORED), // "Restored keys and certificates for %ws\\%ws from %ws."
	g_pwszDnsName,
	pwszCommonName,
	pwszPFXFile);
    wprintf(wszNewLine);

error:
    if (NULL != pwszPFXFile)
    {
	LocalFree(pwszPFXFile);
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    return(hr);
}


// #define DO_VECTOR_TEST

HRESULT
verbMACFile(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupFile,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CAutoLPWSTR pwszMAC;

    hr = ComputeMAC(pwszBackupFile, &pwszMAC);
    _JumpIfError(hr, error, "ComputeMAC");

    wprintf(
	myLoadResourceString(IDS_FORMAT_HASHFILEOUTPUT), // "SHA-1 hash of file %ws: %ws"
	pwszBackupFile,
	pwszMAC);
    wprintf(wszNewLine);

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\certdb2.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certdb2.h
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define _JET_RED_

#ifdef _JET_RED_
# define JETREDSELECT(jetbluearg, jetredarg)	jetredarg
# define JETREDPARM(jetredarg)			jetredarg,
#endif // _JET_RED_

// from old certdb.h
#define	TABLE_NAMES	( 0 )
#define	TABLE_REQUESTS	( 1 )
#define	TABLE_CERTIFICATES	( 2 )
#define	TABLE_REQUEST_ATTRIBS	( 3 )
#define	TABLE_EXTENSIONS	( 4 )
#define	MAX_EXTENSION_NAME	( 50 )

#define	DBTF_POLICYWRITEABLE	( 0x1 )
#define	DBTF_INDEXPRIMARY	( 0x2 )
#define	DBTF_INDEXREQUESTID	( 0x4 )


// stolen from misc .h files
#define szREGDBDSN		"DBDSN"
#define szREGDBUSER		"DBUser"
#define szREGDBPASSWORD		"DBPassword"

#define wszREGDBDSN		TEXT(szREGDBDSN)
#define wszREGDBUSER		TEXT(szREGDBUSER)
#define wszREGDBPASSWORD	TEXT(szREGDBPASSWORD)

//======================================================================
// Full path to "CertSvc\Queries":
#define wszREGKEYQUERIES	wszREGKEYCERTSVCPATH TEXT("\\Queries")


//======================================================================
// Values Under "CertSvc\Queries\<QueryNumber>":
#define szREGDBSQL		"SQL"

#define wszREGDBSQL		TEXT(szREGDBSQL)

#define wszREGKEYDEFAULTCONFIG     TEXT("DefaultConfiguration")
#define wszREGKEYDIRECTORY TEXT("ConfigurationDirectory")
#define wszREGKEYENABLED   TEXT("Enabled")
#define wszREGCONTAINERNAME     TEXT("KeySetName")


#define CR_FLG_NOTELETEX       0x00000000
#define CR_FLG_FORCETELETEX    0x00000001
#define CR_FLG_RENEWAL         0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\db2.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db2.cpp
//
// Contents:    Cert Server Data Base interface implementation
//
// History:     15-nov-96       hanshu created
//
//---------------------------------------------------------------------------

// NOTE: this is a TEMPORARY implementation of the old property-based
//       api onto the new table-based database. it is not a happy fit,
//       and this will be replaced by an update/query api that is
//       more appropriate to the relational model and scales better.
//
// FURTHER NOTE: there's now a caching layer that improves the performance
//       of the one-field-per-call design of the api. Set-operations are
//       not written to the data base immediately, but are queued up and
//       lazy-written in a single bulk-update sql operation. Get-operations
//       read from the queue or go to the database if needed. A further
//       optimization would be to do a bulk-read to prime the queue data,
//       but the present scheme is sufficient for the current pattern of
//       use where the cert is built up field-by-field.

#include <pch.cpp>

#pragma hdrstop

#include "certdb2.h"
#include "csprop2.h"
#include "db2.h"
#include "dbcore.h"
#include "odbc.h"

#define __myFILE__	"db2.cpp"


// NOTE: the only data base operation that needs concurency-protection is
//       the allocation of new RequestIDs and NameIDs in the Miscellaneous
//       table.
//
//       For now I assume that the ODBC drivers are thread-safe enough to
//       allow concurrent activity on separate HSTMTs; if this turns out to
//       be false, then every entry-point in this module must be serialized
//       globally.

DWORD   rgdwActualTable[] = // maps the above values to their actual host table
{
    TABLE_NAMES,
    TABLE_REQUESTS,
    TABLE_CERTIFICATES,
    TABLE_NAMES,
    TABLE_NAMES,
    TABLE_REQUEST_ATTRIBS,
    TABLE_EXTENSIONS
};


UCHAR   dsn[64]  = "CertSrv";  // default values
UCHAR   user[64] = "Admin";
UCHAR   pwd[64]  = "";

/////


DBTABLE_RED const db_adtRequests[] =
{
    {	// DWORD
	g_wszPropRequestRequestID,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RequestID",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// BLOB
	g_wszPropRequestRawRequest,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RawRequest",
	SQL_C_BINARY,
	SQL_LONGVARBINARY
    },
    {	// DWORD
	g_wszPropRequestAttributes,
	NULL,
	0,			// dwFlags
	cchATTRIBUTESMAX,	// dwcbMax
	TABLE_REQUESTS,
	L"RequestAttributes",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// DWORD
	g_wszPropRequestType,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RequestType",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// DWORD
	g_wszPropRequestFlags,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RequestFlags",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// DWORD
	g_wszPropRequestStatus,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RequestStatus",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// DWORD
	g_wszPropRequestStatusCode,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"StatusCode",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// DWORD
	g_wszPropRequestDisposition,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"Disposition",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// DWORD
	g_wszPropRequestDispositionMessage,
	NULL,
	0,			// dwFlags
	cchREQUESTDISPOSITIONMESSAGE,// dwcbMax
	TABLE_REQUESTS,
	L"DispositionMessage",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// FILETIME
	g_wszPropRequestSubmittedWhen,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"SubmittedWhen",
	SQL_C_TIMESTAMP,
	SQL_TIMESTAMP
    },
    {	// FILETIME
	g_wszPropRequestResolvedWhen,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"ResolvedWhen",
	SQL_C_TIMESTAMP,
	SQL_TIMESTAMP
    },
    {	// FILETIME
	g_wszPropRequestRevokedWhen,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RevokedWhen",
	SQL_C_TIMESTAMP,
	SQL_TIMESTAMP
    },
    {	// FILETIME
	g_wszPropRequestRevokedEffectiveWhen,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RevokedEffectiveWhen",
	SQL_C_TIMESTAMP,
	SQL_TIMESTAMP
    },
    {   // DWORD
	g_wszPropRequestRevokedReason,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,
	L"RevokedReason",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {   // DWORD
	g_wszPropRequestSubjectNameID,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_REQUESTS,//TABLE_CERTIFICATES,
	L"SubjectNameID",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// DWORD
	g_wszPropRequesterName,
	NULL,
	0,			// dwFlags
	cchREQUESTERNAMEMAX,	// dwcbMax
	TABLE_REQUESTS,
	L"RequesterName",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// DWORD
	g_wszPropRequesterAddress,
	NULL,
	0,			// dwFlags
	cchREQUESTERADDRESSMAX,	// dwcbMax
	TABLE_REQUESTS,
	L"RequesterAddress",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	NULL, NULL, 0, 0, NULL, 0, 0 } // Termination marker
};


DBTABLE_RED const db_adtCertificates[] =
{
    {	// DWORD
	g_wszPropCertificateRequestID,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"RequestID",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// BLOB
	g_wszPropRawCertificate,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"RawCertificate",
	SQL_C_BINARY,
	SQL_LONGVARBINARY
    },
    {	// DWORD
	wszPROPCERTIFICATEHASH,
	NULL,
	0,			// dwFlags
	cchHASHMAX,		// dwcbMax
	TABLE_CERTIFICATES,
	L"CertificateHash",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// DWORD
	g_wszPropCertificateType,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"CertificateType",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// DWORD
	g_wszPropCertificateSerialNumber,
	NULL,
	0,			// dwFlags
	cchSERIALNUMBERMAX,	// dwcbMax
	TABLE_CERTIFICATES,
	L"SerialNumber",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {   // DWORD
	g_wszPropCertificateIssuerNameID,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"IssuerNameID",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {   // DWORD
	g_wszPropCertificateSubjectNameID,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"SubjectNameID",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// FILETIME
	g_wszPropCertificateNotBeforeDate,
	NULL,
	DBTF_POLICYWRITEABLE,	// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"NotBefore",
	SQL_C_TIMESTAMP,
	SQL_TIMESTAMP
    },
    {	// FILETIME
	g_wszPropCertificateNotAfterDate,
	NULL,
	DBTF_POLICYWRITEABLE,	// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"NotAfter",
	SQL_C_TIMESTAMP,
	SQL_TIMESTAMP
    },
    {	// BLOB
	g_wszPropCertificateRawPublicKey,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"PublicKey",
	SQL_C_BINARY,
	SQL_LONGVARBINARY
    },
    {	// STRING
	g_wszPropCertificatePublicKeyAlgorithm,
	NULL,
	0,			// dwFlags
	cchOBJECTIDMAX,		// dwcbMax
	TABLE_CERTIFICATES,
	L"PublicKeyAlgorithm",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// BLOB
	g_wszPropCertificateRawPublicKeyAlgorithmParameters,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_CERTIFICATES,
	L"PublicKeyParams",
	SQL_C_BINARY,
	SQL_VARBINARY
    },
    {	NULL, NULL, 0, 0, NULL, 0, 0 } // Termination marker
};


DBTABLE_RED const db_adtNames[] =
{
    {	// STRING
	g_wszPropDistinguishedName,
	NULL,
	0,			// dwFlags
	cchDISTINGUISHEDNAMEMAX,// dwcbMax
	TABLE_SUBJECT_NAME,
	L"DistinguishedName",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// BLOB
	g_wszPropRawName,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_SUBJECT_NAME,
	L"RawName",
	SQL_C_BINARY,
	SQL_LONGVARBINARY
    },
    {	// DWORD
	g_wszPropNameType,
	NULL,
	0,			// dwFlags
	0,			// dwcbMax
	TABLE_SUBJECT_NAME,
	L"NameType",
	SQL_C_ULONG,
	SQL_INTEGER
    },
    {	// STRING
	g_wszPropCountry,
	TEXT(szOID_COUNTRY_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchCOUNTRYNAMEMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"Country",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropOrganization,
	TEXT(szOID_ORGANIZATION_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchORGANIZATIONNAMEMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"Organization",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropOrgUnit,
	TEXT(szOID_ORGANIZATIONAL_UNIT_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchORGANIZATIONALUNITNAMEMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"OrganizationalUnit",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropCommonName,
	TEXT(szOID_COMMON_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchCOMMONNAMEMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"CommonName",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropLocality,
	TEXT(szOID_LOCALITY_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchLOCALITYMANAMEMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"Locality",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropState,
	TEXT(szOID_STATE_OR_PROVINCE_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchSTATEORPROVINCENAMEMAX,// dwcbMax
	TABLE_SUBJECT_NAME,
	L"StateOrProvince",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropTitle,
	TEXT(szOID_TITLE),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchTITLEMAX,		// dwcbMax
	TABLE_SUBJECT_NAME,
	L"Title",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropGivenName,
	TEXT(szOID_GIVEN_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchGIVENNAMEMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"GivenName",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropInitials,
	TEXT(szOID_INITIALS),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchINITIALSMAX,		// dwcbMax
	TABLE_SUBJECT_NAME,
	L"Initials",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropSurName,
	TEXT(szOID_SUR_NAME),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchSURNAMEMAX,		// dwcbMax
	TABLE_SUBJECT_NAME,
	L"SurName",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropDomainComponent,
	TEXT(szOID_DOMAIN_COMPONENT),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchDOMAINCOMPONENTMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"DomainComponent",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropEMail,
	TEXT(szOID_RSA_emailAddr),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchEMAILMAX,		// dwcbMax
	TABLE_SUBJECT_NAME,
	L"EMail",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	// STRING
	g_wszPropStreetAddress,
	TEXT(szOID_STREET_ADDRESS),
	DBTF_POLICYWRITEABLE,	// dwFlags
	cchSTREETADDRESSMAX,	// dwcbMax
	TABLE_SUBJECT_NAME,
	L"StreetAddress",
	SQL_C_CHAR,
	SQL_VARCHAR
    },
    {	NULL, NULL, 0, 0, NULL, 0, 0 } // Termination marker
};


DBTABLE_RED const db_dtExtensionFlags =
{   // DWORD
    wszPROPCERTIFICATEEXTENSIONFLAGS,
    NULL,
    DBTF_POLICYWRITEABLE,	// dwFlags
    0,				// dwcbMax
    TABLE_EXTENSIONS,
    L"ExtensionFlags",
    SQL_C_ULONG,
    SQL_INTEGER
};


DBTABLE_RED const db_dtExtensionValue =
{   // BLOB
    wszPROPCERTIFICATEEXTENSIONVALUE,
    NULL,
    DBTF_POLICYWRITEABLE,	// dwFlags
    0,				// dwcbMax
    TABLE_EXTENSIONS,
    L"ExtensionRawValue",
    SQL_C_BINARY,
    SQL_VARBINARY
};


DBTABLE_RED const db_attrib =
{
    // STRING
    NULL,
    NULL,
    0,				// dwFlags
    cchATTRIBUTESMAX,		// dwcbMax
    TABLE_REQUEST_ATTRIBS,
    NULL,			// filled in dynamically
    SQL_C_CHAR,
    SQL_VARCHAR
};


// Note: Ordered DUPTABLE must match Names Table columns 1 to 1.

DUPTABLE const db_dntr[] =
{
    {
        "NameID",
        FALSE,
	SQL_C_ULONG,
        SQL_INTEGER,
        NULL,
    },
    {
        "DistinguishedName",
        FALSE,
        SQL_C_CHAR,
	SQL_VARCHAR,
        g_wszPropSubjectDistinguishedName,
    },
    {
        "RawName",
        FALSE,
        SQL_C_BINARY,
	SQL_LONGVARBINARY,
	g_wszPropSubjectRawName,
    },
    {
        "NameType",
        FALSE,
	SQL_C_ULONG,
        SQL_INTEGER,
        g_wszPropSubjectNameType,
    },
    {
        "Country",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectCountry,
    },
    {
        "Organization",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectOrganization,
    },
    {
        "OrganizationalUnit",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectOrgUnit,
    },
    {
        "CommonName",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectCommonName,
    },
    {
        "Locality",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectLocality,
    },
    {
        "StateOrProvince",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectState,
    },
    {
        "Title",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectTitle,
    },
    {
        "GivenName",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectGivenName,
    },
    {
        "Initials",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectInitials,
    },
    {
        "SurName",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectSurName,
    },
    {
        "DomainComponent",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectDomainComponent,
    },
    {
        "EMail",
        TRUE,
        SQL_C_CHAR,
	SQL_VARCHAR,
	g_wszPropSubjectEMail,
    },
};

/////

void Error ( CHAR* msg )
{
    wprintf(L"DBError: %hs\n", msg);
}

///// initialize database access


HRESULT
RedDBOpen(
    WCHAR const *pwszAuthority)
{
    STATUS  rc = SQL_SUCCESS;
    STATUS  rt;

    // get info from registry

    HKEY    hkey;
    HKEY    hkeyCA;
    int s;

    s = RegOpenKey(HKEY_LOCAL_MACHINE, wszREGKEYCONFIGPATH, &hkey);

    if (ERROR_SUCCESS == s)
    {
	s = RegOpenKey(hkey, pwszAuthority, &hkeyCA);

	if (ERROR_SUCCESS == s)
	{
	    DWORD size;

	    // Ignore errors -- just use the previously initialized values.
	
	    size = sizeof(dsn);
	    s = RegQueryValueExA(hkeyCA, szREGDBDSN, NULL, NULL, dsn, &size);

	    size = sizeof(user);
	    s = RegQueryValueExA(hkeyCA, szREGDBUSER, NULL, NULL, user, &size);

	    size = sizeof(pwd);
	    s = RegQueryValueExA(hkeyCA, szREGDBPASSWORD, NULL, NULL, pwd, &size);

	    RegCloseKey(hkeyCA);
	}
        RegCloseKey(hkey);
    }

    wprintf(myLoadResourceString(IDS_RED_CONNECTING), dsn, user);
    wprintf(wszNewLine);

    rc = odbcInitRequestQueue(dsn, user, pwd);

    if (ERROR_SUCCESS != rc)
    {
        goto error;
    }


error:
    return(rc);
}


/////

HRESULT
RedDBShutDown(VOID)     // finalise database access
{

    odbcFinishRequestQueue();

    return ERROR_SUCCESS;
}

/////


BOOL
dbVerifyPropertyLength(
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN BYTE const *pbProp)
{
    BOOL fOk = FALSE;

    switch (dwFlags & PROPTYPE_MASK)
    {
	case PROPTYPE_LONG:
	    fOk = sizeof(LONG) == cbProp;
	    break;

	case PROPTYPE_DATE:
	    fOk = sizeof(FILETIME) == cbProp;
	    break;

	case PROPTYPE_BINARY:
	    fOk = TRUE;		// nothing to check
	    break;

	case PROPTYPE_STRING:
	    if (MAXDWORD == cbProp)
	    {
		cbProp = wcslen((WCHAR const *) pbProp) * sizeof(WCHAR);
	    }
	    fOk =
		0 == cbProp ||
		NULL == pbProp ||
		wcslen((WCHAR const *) pbProp) * sizeof(WCHAR) == cbProp;
	    break;

	case PROPTYPE_ANSI:
	    if (MAXDWORD == cbProp)
	    {
		cbProp = strlen((char const *) pbProp);
	    }
	    fOk =
		0 == cbProp ||
		NULL == pbProp ||
		strlen((char const *) pbProp) == cbProp;
	    break;
    }
    return(fOk);
}




BOOL
dbVerifyPropertyValue(
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN DBTABLE_RED const *pdt)
{
    SWORD wType;
    DWORD err = ERROR_INVALID_PARAMETER;

    switch (dwFlags & PROPTYPE_MASK)
    {
	case PROPTYPE_LONG:
	    wType = SQL_C_ULONG;
	    break;

	case PROPTYPE_DATE:
	    wType = SQL_C_TIMESTAMP;
	    break;

	case PROPTYPE_BINARY:
	    wType = SQL_C_BINARY;
	    break;

	case PROPTYPE_STRING:
	    CSASSERT(!"dbVerifyPropertyValue: unexpected PROPTYPE_STRING");
	    cbProp /= sizeof(WCHAR);
	    wType = SQL_C_CHAR;
	    break;

	case PROPTYPE_ANSI:
	    wType = SQL_C_CHAR;
	    break;

	default:
	    DBGERRORPRINTLINE("Property value type unknown", err);
	    goto error;
    }
    if (pdt->wCType != wType)
    {
	DBGERRORPRINTLINE("Property value type mismatch", err);
	goto error;
    }

    // Note: cbProp and dwcbMax do not include the trailing '\0'.

    if (SQL_C_CHAR == wType && pdt->dwcbMax < cbProp)
    {
	err = ERROR_BUFFER_OVERFLOW;
	DBGERRORPRINTLINE("Property value string too long", err);
	DBGCODE(wprintf(
		    L"dbVerifyPropertyValue: len = %u, max = %u\n",
		    cbProp,
		    pdt->dwcbMax));
	goto error;
    }
    err = ERROR_SUCCESS;

error:
    return(err);
}


DWORD			// ERROR_*
RedDBGetPropertyW(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp)
{
    DWORD err;
    DWORD cchProp;
    char szProp[4 * MAX_PATH];
    DWORD *pcbPropT = pcbProp;
    BYTE *pbPropT = pbProp;
    DWORD FlagsT = dwFlags;

    if (PROPTYPE_STRING == (dwFlags & PROPTYPE_MASK))
    {
	FlagsT = (dwFlags & ~PROPTYPE_MASK) | PROPTYPE_ANSI;
	cchProp = sizeof(szProp);
	pcbPropT = &cchProp;
	pbPropT = (BYTE *) szProp;
    }
    err = RedDBGetProperty(ReqId, pwszPropName, FlagsT, pcbPropT, pbPropT);

    if (ERROR_SUCCESS != err)
    {
	goto error;
    }

    if (0 == *pcbPropT)
    {
	err = CERTSRV_E_PROPERTY_EMPTY;
	//DBGERRORPRINTLINE("Empty property", err);
    	goto error;
    }

    CSASSERT(dbVerifyPropertyLength(FlagsT, *pcbPropT, pbPropT));

    if (PROPTYPE_STRING == (dwFlags & PROPTYPE_MASK))
    {
	DWORD cwc;

	CSASSERT(strlen(szProp) == cchProp);

        // do size calc
	cwc = MultiByteToWideChar(
			    GetACP(),
			    0,			// dwFlags
			    szProp,			// lpMultiByteStr
			    -1,			// cchMultiByte
			    (WCHAR *) pbProp,	// lpWideCharStr
			    0); // cchWideChar
        if (*pcbProp < (cwc * sizeof(WCHAR)) )
        {
            *pcbProp = cwc * sizeof(WCHAR);
            err = ERROR_MORE_DATA;
            goto error;
        }

	cwc = MultiByteToWideChar(
			    GetACP(),
			    0,			// dwFlags
			    szProp,			// lpMultiByteStr
			    -1,			// cchMultiByte
			    (WCHAR *) pbProp,	// lpWideCharStr
			    cwc); // cchWideChar
	if (0 >= cwc)
	{
	    err = GetLastError();
	    DBGERRORPRINTLINE("MultiByteToWideChar", err);
	    goto error;
        }

        // report real size, but remove wchar on returned blob
        *pcbProp = cwc * sizeof(WCHAR);
        *pcbProp -= sizeof(WCHAR);

    }
    CSASSERT(dbVerifyPropertyLength(dwFlags, *pcbProp, pbProp));

error:
    return(err);
}


/////
// get a field value

STATUS
RedDBGetProperty(
    IN REQID ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp)
{
    RETCODE rc = SQL_SUCCESS;
    DWORD   err;
    HSTMT   hstmt = SQL_NULL_HSTMT;
    UCHAR   query[256], *whichquery;
    DBTABLE_RED dtOut;
    BYTE*   pbData = pbProp;
    DWORD   cbData = *pcbProp;
    SQLLEN  outlen;
    DWORD   dummy = 0;
    NAMEID  nameid = 0;
    DWORD   PropertyType;

    static UCHAR getreq[]  = "SELECT %ws FROM Requests WHERE RequestID = ?;";
    static UCHAR getcert[] = "SELECT %ws FROM Certificates WHERE RequestID = ?;";
    static UCHAR getsubject[] = "SELECT Names.%ws, Names.NameId FROM Certificates INNER JOIN "
	"Names ON Certificates.SubjectNameID = Names.NameId WHERE RequestID = ?;";
    static UCHAR getsubjectrequest[] = "SELECT Names.%ws, Names.NameId FROM Requests INNER JOIN "
	"Names ON Requests.SubjectNameID = Names.NameId WHERE RequestID = ?;";
    static UCHAR getissuer[] = "SELECT Names.%ws, Names.NameId FROM Certificates INNER JOIN "
	"Names ON Certificates.IssuerNameID = Names.NameId WHERE RequestID = ?;";
    static UCHAR getattribs[] = "SELECT AttributeValue FROM RequestAttributes WHERE AttributeName = \'%ws\' AND RequestID = ?;";
    static UCHAR getextensions[] = "SELECT %ws FROM CertificateExtensions WHERE ExtensionName = \'%ws\' AND RequestID = ?;";

    err = MapPropID(pwszPropName, dwFlags, &dtOut);
    if (ERROR_SUCCESS != err)
    {
	DBGERRORPRINTLINE("RedDBGetProperty: MapPropID", err);
        goto error;
    }
    err = dbVerifyPropertyValue(dwFlags, 0, &dtOut);
    if (ERROR_SUCCESS != err)
    {
	DBGERRORPRINTLINE("Property value type mismatch", err);
	goto error;
    }

    // answer field size queries for fixed-size types

    if (pbProp == NULL)
    {
        switch ( dtOut.wCType )
        {
        case SQL_C_TIMESTAMP:
            *pcbProp = sizeof(FILETIME);
            goto done;

        case SQL_C_ULONG:
            *pcbProp = sizeof(ULONG);
            goto done;

        default: // fall through and do dynamic determination for other types
            break;
        }
    }

    // build query string, filling in appropriate field name

    switch ( dtOut.dwTable )
    {
	case TABLE_REQUESTS:
	    whichquery = getreq;
	    break;

	case TABLE_CERTIFICATES:
	    whichquery = getcert;
	    break;

	case TABLE_SUBJECT_NAME:
	    whichquery = getsubject;
	    break;

	case TABLE_REQUESTSUBJECT_NAME:
	    whichquery = getsubjectrequest;
	    break;

	case TABLE_ISSUER_NAME:
	    whichquery = getissuer;
	    break;

	case TABLE_REQUEST_ATTRIBS:
	    whichquery = getattribs;
	    break;

	case TABLE_EXTENSIONS:
	    whichquery = getextensions;
	    break;

	default:
	    CSASSERT(!"Unknown table(2)");
    }

    if (dtOut.dwTable == TABLE_EXTENSIONS)
    {
        sprintf(
            (char *) query,
            (char *) whichquery,
            dtOut.pwszPropNameObjId,
            dtOut.pwszFieldName);
    }
    else
    {
        sprintf(
            (char *) query,
            (char *) whichquery,
            dtOut.pwszFieldName);
    }

    // prepare for output parameter conversion

    TIMESTAMP_STRUCT ts;

    if ( dtOut.wCType == SQL_C_TIMESTAMP )
    {
        // need to copy time format on the way out

	if (sizeof(FILETIME) > cbData)
	{
	    err = ERROR_BUFFER_OVERFLOW;
	    DBGERRORPRINTLINE("*pcbProp too small", err);
	    goto error;
	}
        pbData = (BYTE*)&ts;
        cbData = sizeof(ts);
    }

    // first see if this property is in the cache

    {
        if ( pbData == NULL )
        {
            // no data available - prepare to receive length

            pbData = (BYTE*)&dummy; // need non-NULL buffer address
            cbData = 0;
        }

        // not in cache - get data from data base

        rc = odbcGPDataFromDB(
                          ReqId,
                          dtOut.dwTable,
                          dtOut.wCType,
                          pbData,
                          cbData,
                          query,
                          &nameid,
                          &outlen);

        // Check for the case where caller was trying to find out
        // size of buffer needed to get a SQL_C_CHAR property.
        // Return size of string plus null terminator because of
        // ODBC always will null terminates strings that are returned
        // even if buffer is too small

        if ((SQL_SUCCESS_WITH_INFO == rc || SQL_SUCCESS == rc) &&
            NULL == pbProp &&
            SQL_C_CHAR == dtOut.wCType &&
            SQL_NULL_DATA != outlen)
        {
            outlen++;
        }

        if (SQL_SUCCESS_WITH_INFO == rc)
        {
            // not really interested in the extra info for now
            // natural truncation because cbData == 0.
            // disagreement on how to count terminating null.

            if (NULL != pbProp && SQL_C_CHAR != dtOut.wCType)
            {
                DBCHECKLINE(rc, hstmt);
            }
            rc = SQL_SUCCESS;
        }

    }

    if (SQL_SUCCESS == rc)
    {
        // return proper data size

        if (SQL_NULL_DATA == outlen)
        {
            *pcbProp = 0;
            goto done;
        }
        else if (dtOut.wCType == SQL_C_TIMESTAMP)
        {
            // convert from ODBC timestamp to FILETIME

            SYSTEMTIME  st;

            st.wYear    = ts.year;
            st.wMonth   = ts.month;
            st.wDay     = ts.day;
            st.wHour    = ts.hour;
            st.wMinute  = ts.minute;
            st.wSecond  = ts.second;
            st.wMilliseconds = 0;

            BOOL b = SystemTimeToFileTime ( &st, (FILETIME*)pbProp );
	    outlen = sizeof(FILETIME);
        }

        *pcbProp = (DWORD)outlen;

    }

    // done

    if ((rc == SQL_SUCCESS) && (pbProp != NULL) && ((DWORD) outlen > cbData))
    {
        err = ERROR_MORE_DATA;
	//DBGERRORPRINTLINE("RedDBGetProperty: Buffer too small", err);
	goto error;
    }
    CSASSERT(
	SQL_SUCCESS != rc ||
	dbVerifyPropertyLength(dwFlags, *pcbProp, pbProp));

    // handle this special case
    if (SQL_NO_DATA_FOUND == rc)
        err = ERROR_NO_MORE_ITEMS;
    else
        err = DBStatus(rc);

error:
done:
    if (ERROR_MORE_DATA != err)
    {
	_PrintIfErrorStr3(
		    err,
		    "RedDBGetProperty",
		    pwszPropName,
		    CERTSRV_E_PROPERTY_EMPTY,
		    ERROR_NO_MORE_ITEMS);
    }
    return(err);
}


// Search the passed DBTABLE_RED matching on property name or objectid string.

DBTABLE_RED const *
dbMapTable(
    WCHAR const *pwszPropName,
    DBTABLE_RED const *pdt)
{
    while (NULL != pdt->pwszPropName)
    {
        if (0 == lstrcmpi(pwszPropName, pdt->pwszPropName) ||
            (NULL != pdt->pwszPropNameObjId &&
	     0 == lstrcmpi(pwszPropName, pdt->pwszPropNameObjId)))
	{
	    return(pdt);
	}
	pdt++;
    }
    return(NULL);
}


/////
// map property-id to sql field name and odbc types

RETCODE
MapPropID(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    OUT DBTABLE_RED *pdtOut)
{
    DBTABLE_RED const *pdt = NULL;
    WCHAR wszPrefix[2 * (sizeof(wszPROPSUBJECTDOT) / sizeof(WCHAR))];
    DWORD dwTable;
    WCHAR *pwszExtensionName;
    RETCODE rc = SQL_SUCCESS;
    DBTABLE_RED const *pdbTable;

    CSASSERT(NULL != pwszPropName);

    dwTable = PROPTABLE_MASK & dwFlags;
    CSASSERT(PROPTABLE_REQUEST == dwTable ||
             PROPTABLE_CERTIFICATE == dwTable ||
             PROPTABLE_EXTENSION == dwTable ||
             PROPTABLE_ATTRIBUTE == dwTable);

    // Check to see if the request is for L"Subject.", L"RequestAttributes.",
    // etc.  If it matches one of the known prefixes, parse off the prefix,
    // and look up the rest of the property name in the appropriate table.
    // If L"RequestAttributes.", return the rest of the property name as the
    // AttributeName to retrieve the value field from the database.

    if (PROPTABLE_EXTENSION == dwTable)
    {
	CSASSERT(
	    ((PROPTABLE_EXTENSIONFLAGS | PROPTABLE_EXTENSIONVALUE) & dwFlags) ==
		PROPTABLE_EXTENSIONFLAGS ||
	    ((PROPTABLE_EXTENSIONFLAGS | PROPTABLE_EXTENSIONVALUE) & dwFlags) ==
		PROPTABLE_EXTENSIONVALUE);

	if (PROPTABLE_EXTENSIONVALUE & dwFlags)
	{
	    pdt = &db_dtExtensionValue;
	}
	else
	{
	    pdt = &db_dtExtensionFlags;
	}
	*pdtOut = *pdt;		// structure copy
	pdtOut->pwszPropNameObjId = pdtOut->pwszFieldName;
	pdtOut->pwszFieldName = pwszPropName;
    }
    else
    if (PROPTABLE_ATTRIBUTE == dwTable)
    {
	pdt = &db_attrib;
	*pdtOut = *pdt;		// structure copy
	pdtOut->pwszPropName = pwszPropName;
	pdtOut->pwszFieldName = pwszPropName;
    }
    else
    {
	WCHAR *pwsz;

	CSASSERT(
	    !((PROPTABLE_EXTENSIONFLAGS | PROPTABLE_EXTENSIONVALUE) & dwFlags));

	pwsz = wcschr(pwszPropName, L'.');

	if (NULL != pwsz &&
	    pwsz - pwszPropName + 2 <= sizeof(wszPrefix)/sizeof(WCHAR))
	{
	    BOOL fSubject, fRequestTable;

	    pwsz++;		// skip past L'.'

	    CopyMemory(
		wszPrefix,
		pwszPropName,
		SAFE_SUBTRACT_POINTERS(pwsz, pwszPropName) * sizeof(WCHAR));
	    wszPrefix[pwsz - pwszPropName] = L'\0';

	    fSubject = (0 == lstrcmpi(wszPrefix, g_wszPropSubjectDot));
        fRequestTable = (PROPTABLE_REQUEST == dwTable);     // SubjectNameID in Certificates or Requests?

	    if (fSubject)
	    {
		    pdt = dbMapTable(pwsz, db_adtNames);
		    if (NULL != pdt)
		    {
		        *pdtOut = *pdt;        // structure copy
		        pdtOut->dwTable =
                    fRequestTable? TABLE_REQUESTSUBJECT_NAME : TABLE_SUBJECT_NAME;
		    }
	    }
	}
    }
    if (NULL == pdt)
    {
	pdbTable = NULL;

	// Otherwise just search the Requests or Certificates table for a
	// matching property name or property objectid string.

        switch (dwTable)
        {
	    case PROPTABLE_REQUEST:
                pdbTable = db_adtRequests;
                break;

            case PROPTABLE_CERTIFICATE:
                pdbTable = db_adtCertificates;
                break;
        }

	if (NULL != pdbTable)
	{
	    pdt = dbMapTable(pwszPropName, pdbTable);
	}
	if (NULL != pdt)
	{
	    *pdtOut = *pdt;	// structure copy
	}
	else
	{
	    wprintf(
		L"DB: unknown \"%ws\" property: %ws\n",
		PROPTABLE_REQUEST == dwTable? L"Request" : L"Certificate",
		pwszPropName);
	    rc = SQL_NO_DATA_FOUND;
	}
    }

    return(rc);
}


STATUS
RedDBEnumerateSetup(
    IN DWORD        ReqId,
    IN DWORD        fExtOrAttr,
    OUT HANDLE      *phEnum)
{
    DWORD       err = ERROR_SUCCESS;

    err = odbcDBEnumSetup(ReqId, fExtOrAttr, phEnum);

    return(err);

}

STATUS
RedDBEnumerate(
    IN HANDLE hEnum,
    DWORD *pcb,
    WCHAR *pb)
{
    DWORD       err = ERROR_SUCCESS;

    err = odbcDBEnum(hEnum, pcb, pb);

    return(err);

}


STATUS
RedDBEnumerateClose(
    IN HANDLE hEnum)
{
    DWORD       err = ERROR_SUCCESS;

    err = odbcDBEnumClose(hEnum);

    return(err);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\certutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certut.h
//
//--------------------------------------------------------------------------

#include "resource.h"

const DWORD KMS_LOCKBOX_TAG      = 1;
const DWORD KMS_SIGNING_CERT_TAG = 2;
const DWORD KMS_SIGNATURE_TAG    = 3;
const DWORD KMS_USER_RECORD_TAG  = 4;

typedef struct _TagHeader {
    DWORD   tag;
    DWORD   cbSize;
} TagHeader;


typedef DWORD CERTFLAGS;
const CERTFLAGS CERTFLAGS_ALL           = 0xFFFFFFFF;
const CERTFLAGS CERTFLAGS_UNKNOWN       = 0x00000000;
        // nibble reserved for version number   V
const CERTFLAGS CERTFLAGS_REVOKED       = 0x00000001;
const CERTFLAGS CERTFLAGS_NOT_EXPIRED   = 0x00000002;
const CERTFLAGS CERTFLAGS_SIGNING       = 0x00000004;
const CERTFLAGS CERTFLAGS_SEALING       = 0x00000008;
const CERTFLAGS CERTFLAGS_CURRENT       = 0x00000010;
const CERTFLAGS CERTFLAGS_IMPORTED      = 0x00000100;

// these are broken V1 certs, not standard version 1
const CERTFLAGS CERTFLAGS_VERSION_1     = 0x00001000;

// KMServer does not use version 2 certs
// const CERTFLAGS CERTFLAGS_VERSION_2  = 0x00002000;

// these are proper version 3 certs
const CERTFLAGS CERTFLAGS_VERSION_3     = 0x00003000;

#define wszKMSCERTSTATUS	L"KMS.status"

#define wszCUREGDSTEMPLATEFLAGS	L"DSTemplateFlags"
#define wszCUREGDSCAFLAGS	L"DSCAFlags"
#define wszCUREGDSOIDFLAGS	L"DSOIDFlags"

#define wszREQUESTCLIENTID	L"RequestClientId"

extern WCHAR const g_wszAppName[];
extern WCHAR const *g_pwszProg;
extern HINSTANCE g_hInstance;

extern WCHAR const g_wszAttrib[];
extern WCHAR const g_wszExt[];
extern WCHAR const g_wszCRL[];

extern BOOL g_fIDispatch;
extern BOOL g_fEnterpriseRegistry;
extern BOOL g_fUserRegistry;
extern BOOL g_fUserTemplates;
extern BOOL g_fMachineTemplates;
extern BOOL g_fFullUsage;
extern BOOL g_fReverse;
extern BOOL g_fForce;
extern BOOL g_fVerbose;
extern BOOL g_fGMT;
extern BOOL g_fSeconds;
extern BOOL g_fDispatch;
extern DWORD g_DispatchFlags;
extern BOOL g_fQuiet;
extern DWORD g_EncodeFlags;
extern DWORD g_CryptEncodeFlags;
extern BOOL g_fCryptSilent;
extern BOOL g_fV1Interface;
extern BOOL g_fSplitASN;
extern BOOL g_fAdminInterface;

extern WCHAR *g_pwszConfig;
extern WCHAR *g_pwszOut;
extern WCHAR *g_pwszPassword;
extern WCHAR *g_pwszRestrict;
extern WCHAR *g_pwszDnsName;
extern WCHAR *g_pwszOldName;

extern WCHAR const g_wszEmpty[];
extern WCHAR const g_wszPad2[];
extern WCHAR const g_wszPad4[];
extern WCHAR const g_wszPad8[];
extern WCHAR const wszNewLine[];

extern UINT g_uiExtraErrorInfo;

extern WCHAR const g_wszSchema[];
extern WCHAR const g_wszEncode[];
extern WCHAR const g_wszEncodeHex[];
extern WCHAR const g_wszViewDelStore[];

extern WCHAR const g_wszCACert[];
extern WCHAR const g_wszCAChain[];
extern WCHAR const g_wszGetCRL[];
extern WCHAR const g_wszCAInfo[];

extern WCHAR const g_wszCAInfoCRL[];

extern CRITICAL_SECTION g_DBCriticalSection;

typedef HRESULT (FNVERB)(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4);

FNVERB verbUsage, verbDump, verbGetConfig,
    verbGetConfig2, verbGetCACertificate, verbVerifyKeys, verbVerifyCert,
    verbCheck7f, verbHexTranslate, verbBase64Translate, verbDenyRequest,
    verbResubmitRequest, verbRevokeCertificate, verbSetAttributes,
    verbSetExtension, verbPublishCRL, verbGetCRL, verbIsValidCertificate,
    verbViewDump, verbDBDump, verbPing, verbPingAdmin, verbShutDownServer,
    verbBackupPFX, verbRestorePFX, verbStore, verbBackupDB, verbRestoreDB,
    verbCSPDump, verbCSPTest, verbBackup, verbRestore, verbAddStore,
    verbDelStore, verbVerifyStore, verbOIDName, verbImportCertificate,
    verbDynamicFileList, verbDatabaseLocations, verbGetReg, verbSetReg,
    verbErrorDump, verbCreateVRoots, verbConvertMDB, verbGetConfig3,
    verbSetMapiInfo, verbGetMapiInfo, verbInstallCACert, verbRenewCACert,
    verbKey, verbDelKey, verbExtractMDB, verbDS, verbDSDel, verbDSPublish,
    verbDSCert, verbDSCRL, verbDSDeltaCRL, verbGetCAInfo, verbGetCAPropInfo,
    verbGetCertFromUI, verbMACFile, verbGetKey, verbRecoverKey,
    verbRepairStore, verbDelReg, verbExportPVK, verbExportPFX, verbImportPFX,
    verbDSTemplate, verbDSAddTemplate, verbTemplate, verbTemplateCAs,
    verbCATemplates, verbImportKMS, verbURLCache, verbSign, verbDeleteRow,
    verbPulse, verbMachineInfo, verbDCInfo, verbEntInfo, verbTCAInfo,
    verbViewOrDeleteStore, verbSCInfo, verbMergePFX;

HRESULT
cuGetCAInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber);

HRESULT
cuGetLocalCANameFromConfig(
    OPTIONAL OUT WCHAR **ppwszMachine,
    OPTIONAL OUT WCHAR **ppwszCA);

HRESULT
cuSetConfig();

HRESULT
cuSanitizeNameWithSuffix(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

VOID
cuPrintError(
    IN DWORD idmsg,
    IN HRESULT hr);

VOID
cuPrintErrorAndString(
    OPTIONAL IN WCHAR const *pwszProc,
    IN DWORD idmsg,
    IN HRESULT hr,
    OPTIONAL IN WCHAR const *pwszString);

VOID
cuPrintErrorMessageText(
    IN HRESULT hr);

HRESULT
cuGetLong(
    WCHAR const *pwszIn,
    LONG *pLong);

HRESULT
cuGetSignedLong(
    WCHAR const *pwszIn,
    LONG *pLong);

BOOL
cuParseDecimal(
    IN OUT WCHAR const **ppwc,
    IN OUT DWORD *pcwc,
    OUT DWORD *pdw);

HRESULT
cuParseStrings(
    IN WCHAR const *pwszStrings,
    IN BOOL fMatchPrefix,
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN WCHAR const * const *apwszAllowedPrefixes,
    OUT WCHAR ***papwszStrings,
    OPTIONAL OUT BOOL *pfAllFields);

VOID
cuFreeStringArray(
    IN OUT WCHAR **apwsz);

VOID
cuConvertEscapeSequences(
    IN OUT WCHAR *pwsz);

HRESULT
cuGetPassword(
    IN BOOL fVerify,
    OUT WCHAR *pwszPassword,
    IN DWORD cwcPassword);

HRESULT
cuDumpFileTimePeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT);

HRESULT
cuDumpFileTime(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT);

HRESULT
cuDumpFileTimeOrPeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT);

HRESULT
cuDumpDate(
    IN DATE const *pDate);

HRESULT
cuDumpFormattedProperty(
    IN DWORD dwPropId,
    OPTIONAL IN char const *pszObjId,
    IN BYTE const *pb,
    IN DWORD cb);

HRESULT
cuDecodeObjId(
    IN BYTE const *pbData,
    IN DWORD cbData,
    char **ppszObjId);

BOOL
cuDumpFormattedExtension(
    IN WCHAR const *pwszName,
    IN BYTE const *pbObject,
    IN DWORD cbObject);

HRESULT
cuDumpExtensionArray(
    IN DWORD idMessage,
    IN DWORD cExtension,
    IN CERT_EXTENSION const *rgExtension);

HRESULT
cuDumpSerial(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN DWORD idMessage,
    IN CRYPT_INTEGER_BLOB const *pSerial);

HRESULT
cuDumpPrivateKey(
    IN CERT_CONTEXT const *pCert,
    OPTIONAL OUT BOOL *pfSigningKey,
    OPTIONAL OUT BOOL *pfMatchingKey);

VOID
cuDumpPublicKey(
    IN CERT_PUBLIC_KEY_INFO const *pKey);

VOID
cuDumpAlgid(
    IN DWORD Algid);

VOID
cuDumpVersion(
    IN DWORD dwVersion);

HRESULT
cuDumpPrivateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN BOOL fQuiet);

HRESULT
cuDumpCertKeyProviderInfo(
    IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCert,
    OPTIONAL IN CRYPT_KEY_PROV_INFO *pkpi,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi);

HRESULT
cuDumpAsnBinary(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD iElement);


#define DVNS_DUMP		0x000000000
#define DVNS_VERIFYCERT		0x000000001
#define DVNS_REPAIRKPI		0x000000002
#define DVNS_CASTORE		0x000000004
#define DVNS_DUMPKEYS		0x000000008
#define DVNS_DUMPPROPERTIES	0x000000010
#define DVNS_SAVECERT		0x000000100
#define DVNS_SAVECRL		0x000000200
#define DVNS_SAVECTL		0x000000400
#define DVNS_SAVEPFX		0x000000800
#define DVNS_SAVEPVK		0x000001000
#define DVNS_WRITESTORE		0x000002000
#define DVNS_DSSTORE		0x000004000


HRESULT
cuDumpAndVerifyStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD iCertSave,
    IN DWORD iCRLSave,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPassword);

VOID
cuDumpOIDAndDescriptionA(
    IN char const *pszObjId);

VOID
cuDumpOIDAndDescription(
    IN WCHAR const *pwszObjId);

WCHAR const *
cuwszFromExtFlags(
    IN DWORD ExtFlags);

WCHAR const *
cuwszPropType(
   IN LONG PropType);


BOOL
cuRegPrintDwordValue(
    IN BOOL fPrintNameAndValue,
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwValue);

VOID
cuRegPrintAwszValue(
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const * const *prgpwszValues);

VOID
cuPrintSchemaEntry(
    OPTIONAL IN WCHAR const *pwszName,
    IN WCHAR const *pwszDisplayName,
    IN LONG Type,
    IN LONG cbMax);

VOID
cuUnloadCert(
    IN OUT CERT_CONTEXT const **ppCertContext);

HRESULT
cuLoadCert(
    IN WCHAR const *pwszfnCert,
    OUT CERT_CONTEXT const **ppCertContext);

VOID
cuUnloadCRL(
    IN OUT CRL_CONTEXT const **ppCRLContext);

HRESULT
cuLoadCRL(
    IN WCHAR const *pwszfnCRL,
    OUT CRL_CONTEXT const **ppCRLContext);

HRESULT
cuVerifySignature(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERT_PUBLIC_KEY_INFO const *pcpki,
    IN BOOL fSuppressError);

HRESULT
cuDumpIssuerSerialAndSubject(
    IN CERT_NAME_BLOB const *pIssuer,
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    OPTIONAL IN CERT_NAME_BLOB const *pSubject,
    OPTIONAL IN HCERTSTORE hStore);

HRESULT
cuDumpSigners(
    IN HCRYPTMSG hMsg,
    IN CHAR const *pszInnerContentObjId,
    IN HCERTSTORE hStore,
    IN DWORD cSigner,
    IN BOOL fContentEmpty,
    IN BOOL fVerifyOnly,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert);

HRESULT
cuDumpRecipients(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStoreWrapper,
    IN DWORD cRecipient,
    IN BOOL fQuiet);

HRESULT
cuDumpEncryptedAsnBinary(
    IN HCRYPTMSG hMsg,
    IN DWORD cRecipient,
    IN DWORD RecipientIndex,
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN HCERTSTORE hStorePKCS7,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BOOL fQuiet,
    OPTIONAL OUT BYTE **ppbDecrypted,
    OPTIONAL OUT DWORD *pcbDecrypted);


#define VS_OTHERERROR		0x00000001
#define VS_EXPIRED		0x00000002
#define VS_REVOKED		0x00000004
#define VS_UNTRUSTEDROOT	0x00000008
#define VS_INCOMPLETECHAIN	0x00000010
#define VS_NOREVOCATIONCHECK	0x00000020
#define VS_REVOCATIONOFFLINE	0x00000040

#define VS_ROOT			0x40000000
#define VS_ROOTSIGOK		0x80000000
#define VS_ERRORMASK		(VS_OTHERERROR | \
				 VS_EXPIRED | \
				 VS_REVOKED | \
				 VS_UNTRUSTEDROOT | \
				 VS_INCOMPLETECHAIN)

HRESULT
cuVerifyCertContext(
    IN CERT_CONTEXT const *pCert,
    OPTIONAL IN HCERTSTORE hStoreCA,
    OPTIONAL IN char *apszPolicies[],
    IN DWORD cPolicies,
    OUT DWORD *pVerifyState);

HRESULT
cuDisplayCertName(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszPad,
    IN CERT_NAME_BLOB const *pNameBlob);

HRESULT
cuDisplayCertNames(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    IN CERT_INFO const *pCertInfo);

HRESULT
cuDisplayHash(
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN CRL_CONTEXT const *pCRLContext,
    IN DWORD dwPropId,
    IN WCHAR const *pwszHashName);

HRESULT
cuGetCertType(
    IN CERT_INFO const *pCertInfo,
    OPTIONAL OUT WCHAR **ppwszCertTypeNameV1,
    OPTIONAL OUT WCHAR **ppwszDisplayNameV1,
    OPTIONAL OUT WCHAR **ppwszCertTypeObjId,
    OPTIONAL OUT WCHAR **ppwszCertTypeName,
    OPTIONAL OUT WCHAR **ppwszDisplayName);

HRESULT
cuGetGroupMembership(
    IN WCHAR const *pwszSamName);

HRESULT
cuDumpCertType(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN CERT_INFO const *pCertInfo);

HRESULT
cuGetTemplateNames(
    IN WCHAR const *pwszTemplate,
    OUT WCHAR **ppwszCN,
    OUT WCHAR **ppwszDisplayName);

VOID
cuPrintCRLFString(
    IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn);

int
cuidCRLReason(
    IN LONG Reason);

WCHAR const *
cuGetOIDNameA(
    IN char const *pszObjId);

WCHAR const *
cuGetOIDName(
    IN WCHAR const *pwszObjId);

VOID
cuPrintPossibleObjectIdName(
    IN WCHAR const *pwszObjId);

HRESULT
cuLoadKeys(
    OPTIONAL IN WCHAR const *pwszProvName,
    IN OUT DWORD *pdwProvType,
    IN WCHAR const *pwszKeyContainerName,
    IN BOOL fMachineKeyset,
    IN BOOL fSoftFail,
    OPTIONAL OUT HCRYPTPROV *phProv,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO **ppPubKeyInfo,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO **ppPubKeyInfoXchg);

VOID
cuCAInfoUsage(VOID);

DWORD
cuFileSize(
    IN WCHAR const *pwszfn);

HRESULT
cuPingCertSrv(
    IN WCHAR const *pwszConfig);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\db2.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db2.h
//
// Contents:    Cert Server Data Base interfaces
//
//---------------------------------------------------------------------------

#ifndef __DB2_H__
#define __DB2_H__

//+****************************************************
// DataBase Module:

#define MAX_EXTENSIONS            64

#define ENUMERATE_EXTENSIONS      0
#define ENUMERATE_ATTRIBUTES      1

DWORD			// ERROR_*
RedDBGetProperty(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp);

DWORD			// ERROR_*
RedDBGetPropertyW(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp);

DWORD
RedDBEnumerateSetup(
    IN DWORD ReqId,
    IN DWORD fExtOrAttr,
    OUT HANDLE *phEnum);

DWORD
RedDBEnumerate(
    IN HANDLE hEnum,
    IN OUT DWORD *pcb,
    OUT WCHAR *pb);

DWORD
RedDBEnumerateClose(
    IN HANDLE hEnum);

HRESULT
RedDBOpen(				// initialize database
    WCHAR const *pwszAuthority);

HRESULT
RedDBShutDown(VOID);		// terminate database access

WCHAR const *
DBMapAttributeName(
    IN WCHAR const *pwszAttributeName);
#endif // __DB2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\csprop2.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csprop2.h
//
// Contents:    Cert Server Property interfaces
//
//---------------------------------------------------------------------------

#ifndef __CSPROP2_H__
#define __CSPROP2_H__

#ifndef _JET_RED_
#include <certdb.h>
#endif // _JET_RED_

// begin_certsrv

//+--------------------------------------------------------------------------
// Name properties:

#define wszPROPDISTINGUISHEDNAME TEXT("DistinguishedName")
#define wszPROPRAWNAME           TEXT("RawName")
#define wszPROPNAMETYPE          TEXT("NameType")
#define wszPROPCOUNTRY           TEXT("Country")
#define wszPROPORGANIZATION      TEXT("Organization")
#define wszPROPORGUNIT           TEXT("OrgUnit")
#define wszPROPCOMMONNAME        TEXT("CommonName")
#define wszPROPLOCALITY          TEXT("Locality")
#define wszPROPSTATE             TEXT("State")
#define wszPROPTITLE             TEXT("Title")
#define wszPROPGIVENNAME         TEXT("GivenName")
#define wszPROPINITIALS          TEXT("Initials")
#define wszPROPSURNAME           TEXT("SurName")
#define wszPROPDOMAINCOMPONENT   TEXT("DomainComponent")
#define wszPROPEMAIL             TEXT("EMail")
#define wszPROPSTREETADDRESS     TEXT("StreetAddress")

//+--------------------------------------------------------------------------
// Subject Name properties:

#define wszPROPSUBJECTDOT	    TEXT("Subject.")
#define wszPROPSUBJECTDISTINGUISHEDNAME \
				    wszPROPSUBJECTDOT wszPROPDISTINGUISHEDNAME
#define wszPROPSUBJECTRAWNAME       wszPROPSUBJECTDOT wszPROPRAWNAME
#define wszPROPSUBJECTNAMETYPE      wszPROPSUBJECTDOT wszPROPNAMETYPE

#define wszPROPSUBJECTCOUNTRY       wszPROPSUBJECTDOT wszPROPCOUNTRY
#define wszPROPSUBJECTORGANIZATION  wszPROPSUBJECTDOT wszPROPORGANIZATION
#define wszPROPSUBJECTORGUNIT       wszPROPSUBJECTDOT wszPROPORGUNIT
#define wszPROPSUBJECTCOMMONNAME    wszPROPSUBJECTDOT wszPROPCOMMONNAME
#define wszPROPSUBJECTLOCALITY      wszPROPSUBJECTDOT wszPROPLOCALITY
#define wszPROPSUBJECTSTATE         wszPROPSUBJECTDOT wszPROPSTATE
#define wszPROPSUBJECTTITLE	    wszPROPSUBJECTDOT wszPROPTITLE
#define wszPROPSUBJECTGIVENNAME	    wszPROPSUBJECTDOT wszPROPGIVENNAME
#define wszPROPSUBJECTINITIALS	    wszPROPSUBJECTDOT wszPROPINITIALS
#define wszPROPSUBJECTSURNAME	    wszPROPSUBJECTDOT wszPROPSURNAME
#define wszPROPSUBJECTDOMAINCOMPONENT wszPROPSUBJECTDOT wszPROPDOMAINCOMPONENT
#define wszPROPSUBJECTEMAIL	    wszPROPSUBJECTDOT wszPROPEMAIL
#define wszPROPSUBJECTSTREETADDRESS wszPROPSUBJECTDOT wszPROPSTREETADDRESS

// end_certsrv

//+--------------------------------------------------------------------------
// Issuer Name properties:

#define wszPROPISSUERDOT	    TEXT("Issuer.")
#define wszPROPISSUERDISTINGUISHEDNAME \
				    wszPROPISSUERDOT wszPROPDISTINGUISHEDNAME
#define wszPROPISSUERRAWNAME        wszPROPISSUERDOT wszPROPRAWNAME
#define wszPROPISSUERNAMETYPE       wszPROPISSUERDOT wszPROPNAMETYPE

#define wszPROPISSUERCOUNTRY        wszPROPISSUERDOT wszPROPCOUNTRY
#define wszPROPISSUERORGANIZATION   wszPROPISSUERDOT wszPROPORGANIZATION
#define wszPROPISSUERORGUNIT        wszPROPISSUERDOT wszPROPORGUNIT
#define wszPROPISSUERCOMMONNAME     wszPROPISSUERDOT wszPROPCOMMONNAME
#define wszPROPISSUERLOCALITY       wszPROPISSUERDOT wszPROPLOCALITY
#define wszPROPISSUERSTATE          wszPROPISSUERDOT wszPROPSTATE
#define wszPROPISSUERTITLE	    wszPROPISSUERDOT wszPROPTITLE
#define wszPROPISSUERGIVENNAME	    wszPROPISSUERDOT wszPROPGIVENNAME
#define wszPROPISSUERINITIALS	    wszPROPISSUERDOT wszPROPINITIALS
#define wszPROPISSUERSURNAME	    wszPROPISSUERDOT wszPROPSURNAME
#define wszPROPISSUERDOMAINCOMPONENT wszPROPISSUERDOT wszPROPDOMAINCOMPONENT
#define wszPROPISSUEREMAIL	    wszPROPISSUERDOT wszPROPEMAIL
#define wszPROPISSUERSTREETADDRESS  wszPROPSUBJECTDOT wszPROPSTREETADDRESS

#define wszPROPISSUERCOUNTRYOBJID \
    wszPROPISSUERDOT TEXT(szOID_COUNTRY_NAME)

#define wszPROPISSUERORGANIZATIONOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATION_NAME)

#define wszPROPISSUERORGUNITOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATIONAL_UNIT_NAME)

#define wszPROPISSUERCOMMONNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_COMMON_NAME)

#define wszPROPISSUERLOCALITYOBJID \
    wszPROPISSUERDOT TEXT(szOID_LOCALITY_NAME)

#define wszPROPISSUERSTATEOBJID \
    wszPROPISSUERDOT TEXT(szOID_STATE_OR_PROVINCE_NAME)

#define wszPROPISSUERTITLEOBJID \
    wszPROPISSUERDOT TEXT(szOID_TITLE)

#define wszPROPISSUERGIVENNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_GIVEN_NAME)

#define wszPROPISSUERINITIALSOBJID \
    wszPROPISSUERDOT TEXT(szOID_INITIALS)

#define wszPROPISSUERSURNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_SUR_NAME)

#define wszPROPISSUERDOMAINCOMPONENTOBJID \
    wszPROPISSUERDOT TEXT(szOID_DOMAIN_COMPONENT)

#define wszPROPISSUEREMAILOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_emailAddr)

#define wszPROPISSUERSTREETADDRESSOBJID \
    wszPROPISSUERDOT TEXT(szOID_STREET_ADDRESS)


//+--------------------------------------------------------------------------
// For mapping request attribute names to internal property names:

// Map to wszPROPSUBJECTCOUNTRY:
#define wszATTRCOUNTRY1			TEXT("C")
#define wszATTRCOUNTRY2			TEXT("Country")

// Map to wszPROPSUBJECTORGANIZATION:
#define wszATTRORG1			TEXT("O")
#define wszATTRORG2			TEXT("Org")
#define wszATTRORG3			TEXT("Organization")

// Map to wszPROPSUBJECTORGUNIT:
#define wszATTRORGUNIT1			TEXT("OU")
#define wszATTRORGUNIT2			TEXT("OrgUnit")
#define wszATTRORGUNIT3			TEXT("OrganizationUnit")
#define wszATTRORGUNIT4			TEXT("OrganizationalUnit")

// Map to wszPROPSUBJECTCOMMONNAME:
#define wszATTRCOMMONNAME1		TEXT("CN")
#define wszATTRCOMMONNAME2		TEXT("CommonName")

// Map to wszPROPSUBJECTLOCALITY:
#define wszATTRLOCALITY1		TEXT("L")
#define wszATTRLOCALITY2		TEXT("Locality")

// Map to wszPROPSUBJECTSTATE:
#define wszATTRSTATE1			TEXT("S")
#define wszATTRSTATE2			TEXT("ST")
#define wszATTRSTATE3			TEXT("State")

// Map to wszPROPSUBJECTTITLE:
#define wszATTRTITLE1			TEXT("T")
#define wszATTRTITLE2			TEXT("Title")

// Map to wszPROPSUBJECTGIVENNAME:
#define wszATTRGIVENNAME1		TEXT("G")
#define wszATTRGIVENNAME2		TEXT("GivenName")

// Map to wszPROPSUBJECTINITIALS:
#define wszATTRINITIALS1		TEXT("I")
#define wszATTRINITIALS2		TEXT("Initials")

// Map to wszPROPSUBJECTSURNAME:
#define wszATTRSURNAME1			TEXT("SN")
#define wszATTRSURNAME2			TEXT("SurName")

// Map to wszPROPSUBJECTDOMAINCOMPONENT:
#define wszATTRDOMAINCOMPONENT1		TEXT("DC")
#define wszATTRDOMAINCOMPONENT2		TEXT("DomainComponent")

// Map to wszPROPSUBJECTEMAIL:
#define wszATTREMAIL1			TEXT("E")
#define wszATTREMAIL2			TEXT("EMail")

// Map to wszPROPSUBJECTSTREETADDRESS:
#define wszATTRSTREETADDRESS1		TEXT("Street")


// begin_certsrv

//+--------------------------------------------------------------------------
// Request properties:

#define wszPROPREQUESTREQUESTID		    TEXT("RequestID")
#define wszPROPREQUESTRAWREQUEST	    TEXT("RawRequest")
#define wszPROPREQUESTATTRIBUTES	    TEXT("RequestAttributes")
#define wszPROPREQUESTTYPE		    TEXT("RequestType")
#define wszPROPREQUESTFLAGS		    TEXT("RequestFlags")
#define wszPROPREQUESTSTATUS		    TEXT("Status")
#define wszPROPREQUESTSTATUSCODE	    TEXT("StatusCode")
#define wszPROPREQUESTDISPOSITION	    TEXT("Disposition")
#define wszPROPREQUESTDISPOSITIONMESSAGE    TEXT("DispositionMessage")
#define wszPROPREQUESTSUBMITTEDWHEN	    TEXT("SubmittedWhen")
#define wszPROPREQUESTRESOLVEDWHEN	    TEXT("ResolvedWhen")
#define wszPROPREQUESTREVOKEDWHEN	    TEXT("RevokedWhen")
#define wszPROPREQUESTREVOKEDEFFECTIVEWHEN  TEXT("RevokedEffectiveWhen")
#define wszPROPREQUESTREVOKEDREASON  	    TEXT("RevokedReason")
#define wszPROPREQUESTSUBJECTNAMEID	    TEXT("SubjectNameID") // no_certsrv
#define wszPROPREQUESTERNAME		    TEXT("RequesterName")
#define wszPROPREQUESTERADDRESS		    TEXT("RequesterAddress") // no_certsrv


//+--------------------------------------------------------------------------
// Request attribute properties:

#define wszPROPCHALLENGE		TEXT("Challenge")
#define wszPROPEXPECTEDCHALLENGE	TEXT("ExpectedChallenge")


//+--------------------------------------------------------------------------
// Certificate properties:

#define wszPROPCERTIFICATEREQUESTID	    TEXT("RequestID")
#define wszPROPRAWCERTIFICATE		    TEXT("RawCertificate")
#define wszPROPCERTIFICATEHASH		    TEXT("CertificateHash")
#define wszPROPCERTIFICATETYPE		    TEXT("CertificateType")
#define wszPROPCERTIFICATESERIALNUMBER	    TEXT("SerialNumber")
#define wszPROPCERTIFICATEISSUERNAMEID	    TEXT("IssuerNameID") // no_certsrv
#define wszPROPCERTIFICATESUBJECTNAMEID	    TEXT("SubjectNameID") // no_certsrv
#define wszPROPCERTIFICATENOTBEFOREDATE	    TEXT("NotBefore")
#define wszPROPCERTIFICATENOTAFTERDATE	    TEXT("NotAfter")
#define wszPROPCERTIFICATERAWPUBLICKEY	    TEXT("RawPublicKey")
#define wszPROPCERTIFICATEPUBLICKEYALGORITHM TEXT("PublicKeyAlgorithm")
#define wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS \
    TEXT("RawPublicKeyAlgorithmParameters")

//+--------------------------------------------------------------------------
// Certificate extension properties:

#define EXTENSION_CRITICAL_FLAG	 0x00000001
#define EXTENSION_DISABLE_FLAG	 0x00000002
#define EXTENSION_POLICY_MASK	 0x0000ffff	// Settable by admin+policy

#define EXTENSION_ORIGIN_REQUEST 0x00010000
#define EXTENSION_ORIGIN_POLICY	 0x00020000
#define EXTENSION_ORIGIN_ADMIN	 0x00030000
#define EXTENSION_ORIGIN_SERVER	 0x00040000
#define EXTENSION_ORIGIN_MASK	 0x000f0000

//+--------------------------------------------------------------------------
// GetProperty/SetProperty Flags:
//
// Choose one Type

#define PROPTYPE_LONG		 0x00000001	// Signed long
#define PROPTYPE_DATE		 0x00000002	// Date+Time
#define PROPTYPE_BINARY		 0x00000003	// Binary data
#define PROPTYPE_STRING		 0x00000004	// Unicode String
#define PROPTYPE_ANSI		 0x00000005	// Ansi String	no_certsrv
#define PROPTYPE_MASK		 0x000000ff
// end_certsrv

// Choose one Caller:

#define PROPCALLER_SERVER	 0x00000100
#define PROPCALLER_POLICY	 0x00000200
#define PROPCALLER_EXIT		 0x00000300
#define PROPCALLER_ADMIN	 0x00000400
#define PROPCALLER_REQUEST	 0x00000500
#define PROPCALLER_MASK		 0x00000f00

// Choose one Table:

#define PROPTABLE_REQUEST	 0x00001000
#define PROPTABLE_CERTIFICATE	 0x00002000
#define PROPTABLE_EXTENSION      0x00003000
#define PROPTABLE_ATTRIBUTE      0x00004000
#define PROPTABLE_MASK		 0x0000f000
#define PROPTABLE_EXTENSIONFLAGS 0x00010000
#define PROPTABLE_EXTENSIONVALUE 0x00020000


#define _254	254	// arbirtrary length
#define _64	64	// arbirtrary length

#define cchATTRIBUTESMAX		_254
#define cchATTRIBUTEVALUEMAX		_64
#define cchATTRIBUTENAMEMAX		_64

#define cchREQUESTDISPOSITIONMESSAGE    _64
#define cchREQUESTERNAMEMAX		_64
#define cchREQUESTERADDRESSMAX		_64

#define cchHASHMAX			_64
#define cchSERIALNUMBERMAX		_64

#define cchOBJECTIDMAX			31
#define cchPROPVALUEMAX			_64

#define cchDISTINGUISHEDNAMEMAX		254
#define cchCOUNTRYNAMEMAX		2
#define cchORGANIZATIONNAMEMAX		_64
#define cchORGANIZATIONALUNITNAMEMAX	_64
#define cchCOMMONNAMEMAX		_64
#define cchLOCALITYMANAMEMAX		_64
#define cchSTATEORPROVINCENAMEMAX	_64
#define cchTITLEMAX			_64
#define cchGIVENNAMEMAX			_64
#define cchINITIALSMAX			_64
#define cchSURNAMEMAX			_64
#define cchDOMAINCOMPONENTMAX		_64
#define cchEMAILMAX			_64
#define cchSTREETADDRESSMAX		_64


// begin_certsrv

// Request Status property values:

#define REQSTATUS_ACTIVE	1
#define REQSTATUS_ACCEPTED	2
#define REQSTATUS_DENIED	3
#define REQSTATUS_PENDING	4
#define REQSTATUS_ERROR		5

// end_certsrv


HRESULT
PropParseRequest(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN DWORD dwFlags,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest);

HRESULT
PropSetRequestTimeProperty(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN WCHAR const *pwszProp);

HRESULT
PropGetExtension(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue);

HRESULT
PropSetExtension(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue);


// CertIF property callback support:

typedef HRESULT (WINAPI FNCIGETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue);

FNCIGETPROPERTY PropCIGetProperty;


typedef HRESULT (WINAPI FNCISETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN VARIANT const *pvarPropertyValue);

FNCISETPROPERTY PropCISetProperty;


typedef HRESULT (WINAPI FNCIGETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT VARIANT *pvarValue);

FNCIGETEXTENSION PropCIGetExtension;


typedef HRESULT (WINAPI FNCISETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN VARIANT const *pvarValue);

FNCISETEXTENSION PropCISetExtension;



// CertIF property enumeration callback support:

#define CIE_OBJECTID	     0x00000001	// return object ids for names

#define CIE_TABLE_EXTENSIONS 0x00000010
#define CIE_TABLE_ATTRIBUTES 0x00000020
#define CIE_TABLE_MASK       0x000000f0



class CIENUM {
public:
    CIENUM() { m_penum = NULL; }

    HRESULT EnumSetup(IN LONG Context, IN DWORD Flags);
    HRESULT EnumNext(OUT BSTR *pstrPropertyName);
    HRESULT EnumClose();

private:
#ifdef _JET_RED_
    LONG   m_Flags;
    HANDLE m_penum;
#else // _JET_RED_
    IEnumCERTDBNAME *m_penum;
#endif // _JET_RED_
};

typedef HRESULT (WINAPI FNCIENUMSETUP)(
    IN LONG Context,
    IN DWORD Flags,
    IN OUT CIENUM *pciEnum);

FNCIENUMSETUP PropCIEnumSetup;


typedef HRESULT (WINAPI FNCIENUMNEXT)(
    IN OUT CIENUM *pciEnum,
    OUT BSTR *pstrPropertyName);

FNCIENUMNEXT PropCIEnumNext;


typedef HRESULT (WINAPI FNCIENUMCLOSE)(
    IN OUT CIENUM *pciEnum);

FNCIENUMCLOSE PropCIEnumClose;


#ifdef _JET_RED_

#define wszPROPCERTIFICATEEXTENSIONFLAGS	TEXT("Flags")
#define wszPROPCERTIFICATEEXTENSIONVALUE	TEXT("Value")


DWORD			// ERROR_*
PropCreateRequest(
    IN OUT DWORD *pReqId);

DWORD			// ERROR_*
PropTerminateRequest(
    IN DWORD ReqId);

DWORD			// ERROR_*
PropGetProperty(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp);

DWORD			// ERROR_*
PropGetPropertyA(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp);

DWORD			// ERROR_*
PropSetProperty(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    IN DWORD cbProp,
    IN BYTE const *pbProp);

#endif // _JET_RED_


#endif // __CSPROP2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\certutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certutil.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <setupapi.h>
#include <locale.h>
#include <io.h>
#include <fcntl.h>
#include "ocmanage.h"
#include "initcert.h"
#include "setupids.h"
#include "clibres.h"
#include "csresstr.h"

#define __dwFILE__	__dwFILE_CERTUTIL_CERTUTIL_CPP__

#define WM_DOCERTUTILMAIN		WM_USER+0

WCHAR const wszAppName[] = L"CertUtilApp";
WCHAR const *g_pwszProg = L"CertUtil";
HINSTANCE g_hInstance;

BOOL g_fIDispatch = FALSE;
BOOL g_fEnterpriseRegistry = FALSE;
BOOL g_fUserRegistry = FALSE;
BOOL g_fUserTemplates = FALSE;
BOOL g_fMachineTemplates = FALSE;
BOOL g_fNoCR = FALSE;
BOOL g_fFullUsage = FALSE;
BOOL g_fReverse = FALSE;
BOOL g_fForce = FALSE;
BOOL g_fVerbose = FALSE;
BOOL g_fGMT = FALSE;
BOOL g_fSeconds = FALSE;
DWORD g_DispatchFlags;
BOOL g_fQuiet = FALSE;
BOOL g_fCryptSilent = FALSE;
BOOL g_fV1Interface = FALSE;
BOOL g_fSplitASN = FALSE;
BOOL g_fAdminInterface = FALSE;
DWORD g_EncodeFlags;
DWORD g_CryptEncodeFlags;

WCHAR *g_pwszConfig = NULL;		// Don't free this one!
WCHAR *g_pwszConfigAlloc = NULL;	// Free this one instead!
WCHAR *g_pwszOut = NULL;
WCHAR *g_pwszPassword = NULL;
WCHAR *g_pwszRestrict = NULL;
WCHAR *g_pwszDnsName = NULL;
WCHAR *g_pwszOldName = NULL;

WCHAR const g_wszEmpty[] = L"";
WCHAR const g_wszPad2[] = L"  ";
WCHAR const g_wszPad4[] = L"    ";
WCHAR const g_wszPad8[] = L"        ";
WCHAR const wszNewLine[] = L"\n";

UINT g_uiExtraErrorInfo = 0;

CRITICAL_SECTION g_DBCriticalSection;

#define CCOL_VERB	16
#define CCOL_OPTIONBARE	16
#define CCOL_OPTIONARG	24

#define AF_ZERO			0
#define AF_NEEDCOINIT		0x00000002
#define AF_ACTIVECONFIG		0x00000004	// CA must be running
#define AF_PRIVATE		0x00000008	// Undocumented, untested
#define AF_STOPPARSINGARGS	0x00000010	// no more '-' args
#define AF_OPTIONALCONFIG	0x00000020
#define AF_RESTARTSERVER	0x00000040

#define AF_OPTION_PASSWORD	0x00002000
#define AF_OPTION_ADMIN		0x00004000
#define AF_OPTION_CONFIG	0x00008000
#define AF_OPTION_ENTERPRISE	0x00010000
#define AF_OPTION_FORCE		0x00020000
#define AF_OPTION_GMT		0x00040000
#define AF_OPTION_IDISPATCH	0x00080000
#define AF_OPTION_MT		0x00100000
#define AF_OPTION_NOCR		0x00200000
#define AF_OPTION_OUT		0x00400000
#define AF_OPTION_RESTRICT	0x00800000
#define AF_OPTION_REVERSE	0x01000000
#define AF_OPTION_SECONDS	0x02000000
#define AF_OPTION_SILENT	0x04000000
#define AF_OPTION_SPLIT		0x08000000
#define AF_OPTION_USER		0x10000000
#define AF_OPTION_UT		0x20000000
#define AF_OPTION_V1		0x40000000
#define AF_OPTION_VERBOSE	0x80000000

#define AF_OPTION_GENERIC	(AF_OPTION_SECONDS | AF_OPTION_GMT | AF_OPTION_VERBOSE)
#define AF_OPTION_MASK		0xffffff00

typedef struct _ARG
{
    WCHAR const *pwszArg;
    int		 idsDescription;
    int		 idsUsage;
    int		 idsArgDescription;
    int          cArgMin;
    int          cArgMax;
    DWORD	 Flags;
    BOOL        *pBool;
    WCHAR      **ppString;
    FNVERB      *pfnVerb;
    WCHAR const	* const *papwszUsageConstants;
    WCHAR const	*pwszUsage;
    WCHAR const	*pwszDescription;
} ARG;

WCHAR const g_wszCACert[] = L"ca.cert";
WCHAR const g_wszCAChain[] = L"ca.chain";
WCHAR const g_wszGetCRL[] = L"GetCRL";
WCHAR const g_wszCAInfo[] = L"CAInfo";

WCHAR const g_wszSchema[] = L"schema";
WCHAR const g_wszEncode[] = L"encode";
WCHAR const g_wszEncodeHex[] = L"encodehex";
WCHAR const g_wszViewDelStore[] = L"viewdelstore";

WCHAR const *g_papwszUsageViewTable[] =
    { L"Cert", L"Request", L"Ext", L"Attrib", L"CRL", NULL };
WCHAR const *g_papwszUsageCRL[] = { L"republish", L"delta", NULL };
WCHAR const *g_papwszUsageGetCRL[] = { L"delta", NULL };
WCHAR const *g_papwszUsageSchema[] = { L"Ext", L"Attrib", L"CRL", NULL };
WCHAR const *g_papwszUsageView[] =
 { L"Queue", L"Log", L"LogFail", L"Revoked", L"Ext", L"Attrib", L"CRL", NULL };
WCHAR const *g_papwszUsageBackup[] = { L"Incremental", L"KeepLog", NULL };
WCHAR const *g_papwszUsageDSPublish[] =
    { L"NTAuthCA", L"RootCA", L"SubCA", L"CrossCA", L"KRA", L"User", L"Machine", NULL };
WCHAR const *g_papwszUsageDCInfo[] =
    { L"Verify", L"DeleteBad", L"DeleteAll", NULL };
WCHAR const *g_papwszUsageTCAInfo[] = { L"ping", NULL };
WCHAR const *g_papwszUsageGetCert[] = { L"ERA", L"KRA", NULL };
WCHAR const *g_papwszUsageDelete[] = { L"delete", NULL };
WCHAR const *g_papwszUsageGetSetReg[] =
    { L"ca", L"restore", L"policy", L"exit", L"template", L"ProgId", NULL };


#define pargDEFAULT	(&aarg[0])	// Default to first entry
ARG aarg[] =
{
    {				// In first position to be the default
	L"dump",		// pwszArg
	IDS_DUMP_DESCRIPTION,	// "dump configuration information or files"
	IDS_DUMP_USAGEARGS,	// "[File]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_SPLIT | AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDump,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getconfig",		// pwszArg
	IDS_GETCONFIG_DESCRIPTION, // "get default configuration string"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetConfig,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getconfig2",		// pwszArg
	IDS_GETCONFIG2_DESCRIPTION, // "get default configuration string via ICertGetConfig"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetConfig2,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getconfig3",		// pwszArg
	IDS_GETCONFIG3_DESCRIPTION, // "get configuration via ICertConfig"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetConfig3,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"decodehex",		// pwszArg
	IDS_DECODEHEX_DESCRIPTION, // "Decode hexadecimal-encoded file"
	IDS_INFILEOUTFILE_USAGEARGS, // "InFile OutFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbHexTranslate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszEncodeHex,		// pwszArg
	IDS_ENCODEHEX_DESCRIPTION, // "Encode file in hexadecimal"
	IDS_ENCODEHEX_USAGEARGS, // "InFile OutFile [type]"
	0,			// idsArgDescription
	2,			// cArgMin
	3,			// cArgMax
	AF_OPTION_NOCR | AF_OPTION_FORCE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbHexTranslate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"decode",		// pwszArg
	IDS_DECODE_DESCRIPTION,	// "Decode Base64-encoded file"
	IDS_INFILEOUTFILE_USAGEARGS, // "InFile OutFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBase64Translate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszEncode,		// pwszArg
	IDS_ENCODE_DESCRIPTION,	// "Encode file to Base64"
	IDS_INFILEOUTFILE_USAGEARGS, // "InFile OutFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_NOCR | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBase64Translate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"deny",		// pwszArg
	IDS_DENY_DESCRIPTION,	// "Deny pending request"
	IDS_DENY_USAGEARGS,	// "RequestId"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDenyRequest,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"resubmit",		// pwszArg
	IDS_RESUBMIT_DESCRIPTION, // "Resubmit pending request"
	IDS_RESUBMIT_USAGEARGS,	// "RequestId"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbResubmitRequest,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"setattributes",	 // pwszArg
	IDS_SETATTRIBUTES_DESCRIPTION, // "Set attributes for pending request"
	IDS_SETATTRIBUTES_USAGEARGS, // "RequestId AttributeString"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetAttributes,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"setextension",	// pwszArg
	IDS_SETEXTENSION_DESCRIPTION, // "Set extension for pending request"
	IDS_SETEXTENSION_USAGEARGS, // "RequestId ExtensionName Flags {Long | Date | String | @InFile}"
	0,			// idsArgDescription
	4,			// cArgMin
	4,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetExtension,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"revoke",		// pwszArg
	IDS_REVOKE_DESCRIPTION,	// "Revoke Certificate"
	IDS_REVOKE_USAGEARGS,	// "SerialNumber"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRevokeCertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"isvalid",		// pwszArg
	IDS_ISVALID_DESCRIPTION, // "IsValid Certificate"
	IDS_ISVALID_USAGEARGS,	// "SerialNumber | CertHash"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbIsValidCertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"deleterow",		// pwszArg
	IDS_DELETEROW_DESCRIPTION, // "Delete server database row"
	IDS_DELETEROW_USAGEARGS, // "RowId | Date [%1 | %2 | %3 | %4 | %5]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDeleteRow,		// pfnVerb
	g_papwszUsageViewTable,	// papwszUsageConstants
    },
    {
	L"CRL",			// pwszArg
	IDS_CRL_DESCRIPTION,	// "Publish new CRL [optionally delta CRL only]"
	IDS_CRL_USAGEARGS,	// "[dd:hh | %1] [%2]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPublishCRL,		// pfnVerb
	g_papwszUsageCRL,	// papwszUsageConstants
    },
    {
	g_wszGetCRL,		// pwszArg
	IDS_GETCRL_DESCRIPTION,	// "Get CRL"
	IDS_GETCRL_USAGEARGS,	// "OutFile [Index] [%1]"
	0,			// idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCRL,              // pfnVerb
	g_papwszUsageGetCRL,	// papwszUsageConstants
    },
    {
	L"Sign",		// pwszArg
	IDS_SIGN_DESCRIPTION,	// "Re-sign CRL or Certificate"
	IDS_SIGN_USAGEARGS,	// "InFile OutFile [dd:hh]"
	0,			// idsArgDescription
	2,			// cArgMin
	3,			// cArgMax
	AF_OPTION_SILENT | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSign,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"importcert",
	IDS_IMPORTCERT_DESCRIPTION, // "Import a certificate file into the database"
	IDS_IMPORTCERT_USAGEARGS, // "Certfile"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbImportCertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	g_wszCACert,		// pwszArg
	IDS_CACERT_DESCRIPTION,	// "Retrieve the CA's certificate"
	IDS_CACERT_USAGEARGS,	// "OutCACertFile [Index]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCACertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszCAChain,		// pwszArg
	IDS_CACHAIN_DESCRIPTION,// "Retrieve the CA's certificate chain"
	IDS_CACHAIN_USAGEARGS,	// "OutCACertChainFile [Index]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCACertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszCAInfo,		// pwszArg
	IDS_CAINFO_DESCRIPTION,	// "Display CA Information"
	IDS_CAINFO_USAGEARGS,	// "[InfoName [Index | ErrorCode]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCAInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"CAPropInfo",		// pwszArg
	IDS_CAPROPINFO_DESCRIPTION,// "Display CA Property Type Information"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_IDISPATCH | AF_OPTION_ADMIN | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCAPropInfo,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"ping",		// pwszArg
	IDS_PING_DESCRIPTION,	// "Ping Certificate Server"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPing,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"pingadmin",		// pwszArg
	IDS_PINGADMIN_DESCRIPTION, // "Ping Certificate Server Admin interface"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPingAdmin,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"shutdown",		// pwszArg
	IDS_SHUTDOWN_DESCRIPTION, // "Shutdown Certificate Server"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbShutDownServer,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"installCert",		// pwszArg
	IDS_INSTALLCERT_DESCRIPTION, // "Install Certification Authority certificate"
	IDS_INSTALLCERT_USAGEARGS, // "CACertFile"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbInstallCACert,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"renewCert",		// pwszArg
	IDS_RENEWCERT_DESCRIPTION, // "Renew Certification Authority certificate"
	IDS_RENEWCERT_USAGEARGS, // "[ReuseKeys] [Machine\\ParemtCAName]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRenewCACert,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"hashfile",		// pwszArg
	IDS_HASHFILE_DESCRIPTION, // "Generates and displays cryptographic hash over a file"
	IDS_HASHFILE_USAGEARGS,	// "InFile"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbMACFile,		// pfnVerb
	NULL,			// papwszUsageConstants
    },  
    { L"", },
    {
	g_wszSchema,		// pwszArg
	IDS_SCHEMA_DESCRIPTION,	// "Dump Certificate Schema"
	IDS_SCHEMA_USAGE,	// "[%1 | %2 | %3]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_CONFIG | AF_OPTION_IDISPATCH | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewDump,		// pfnVerb
	g_papwszUsageSchema,	// papwszUsageConstants
    },
    {
	L"view",		// pwszArg
	IDS_VIEW_DESCRIPTION,	// "Dump Certificate View"
	IDS_VIEW_USAGE,		// "[%1 | %2 | %3 | %4 | %5 | %6 | %7]"
	IDS_VIEW_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_REVERSE | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT | AF_OPTION_OUT | AF_OPTION_RESTRICT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewDump,		// pfnVerb
	g_papwszUsageView,	// papwszUsageConstants
    },
    {
	L"db",			// pwszArg
	IDS_DB_DESCRIPTION,	// "Dump Raw Database"
	IDS_VIEW_USAGE,		// "[%1 | %2 | %3 | %4 | %5 | %6 | %7]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_OPTION_OUT | AF_OPTION_RESTRICT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDBDump,		// pfnVerb
	g_papwszUsageView,	// papwszUsageConstants
    },
    { L"", },
    {
	L"backup",		// pwszArg
	IDS_BACKUP_DESCRIPTION,	// "backup certificate server"
	IDS_BACKUP_USAGEARGS,	// "BackupDirectory [password [%1] [%2]]"
	0,			// idsArgDescription
	1,			// cArgMin
	4,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBackup,		// pfnVerb
	g_papwszUsageBackup,	// papwszUsageConstants
    },
    {
	L"backupDB",		// pwszArg
	IDS_BACKUPDB_DESCRIPTION, // "backup certificate server data base"
	IDS_BACKUPDB_USAGEARGS,	// "BackupDirectory [%1] [%2]"
	0,			// idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBackupDB,		// pfnVerb
	g_papwszUsageBackup,	// papwszUsageConstants
    },
    {
	L"backupKey",		// pwszArg
	IDS_BACKUPPFX_DESCRIPTION, // "backup certificate server certificate and private key"
	IDS_BACKUPPFX_USAGEARGS, // "BackupDirectory [password]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBackupPFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restore",		// pwszArg
	IDS_RESTORE_DESCRIPTION, // "restore certificate server"
	IDS_RESTORE_USAGEARGS,	// "BackupDirectory [password]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRestore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restoreDB",		// pwszArg
	IDS_RESTOREDB_DESCRIPTION, // "restore certificate server data base"
	IDS_RESTOREDB_USAGEARGS, // "BackupDirectory"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRestoreDB,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restoreKey",		// pwszArg
	IDS_RESTOREPFX_DESCRIPTION, // "restore certificate server certificate and private key"
	IDS_RESTOREPFX_USAGEARGS, // "BackupDirectory | PFXFile [password]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRestorePFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"exportPVK",		// pwszArg
	IDS_EXPORTPVK_DESCRIPTION, // "export certificate and private key for code signing"
	IDS_EXPORTPVK_USAGEARGS, // "CertIndex PVKFileBaseName [CertificateStoreName]"
	0,			// idsArgDescription
	2,			// cArgMin
	3,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_ENTERPRISE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbExportPVK,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"exportPFX",		// pwszArg
	IDS_EXPORTPFX_DESCRIPTION, // "export certificate and private key"
	IDS_EXPORTPFX_USAGEARGS, // "CertIndex PFXFile [password [CertificateStoreName]]"
	0,			// idsArgDescription
	2,			// cArgMin
	4,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbExportPFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"importPFX",		// pwszArg
	IDS_IMPORTPFX_DESCRIPTION, // "import certificate and private key"
	IDS_IMPORTPFX_USAGEARGS, // "PFXFile [password [CertificateStoreName]]"
	0,			// idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbImportPFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"importKMS",		// pwszArg
	IDS_IMPORTKMS_DESCRIPTION, // "import KMS User keys and certificates"
	IDS_IMPORTKMS_USAGEARGS, // "KMSExportFile [CertId]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_SPLIT | AF_OPTION_SILENT | AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbImportKMS,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dynamicfilelist",
	IDS_DYNAMICFILES_DESCRIPTION, // "Display Dynamic File List"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDynamicFileList,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"databaselocations",
	IDS_DATABASELOCATIONS_DESCRIPTION, // "Display Database Locations"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDatabaseLocations,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"store",		// pwszArg
	IDS_STORE_DESCRIPTION,	// "dump certificate store"
	IDS_STORE_USAGEARGS,	// "[CertificateStoreName [CertIndex [OutputFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	3,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbStore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"addstore",		// pwszArg
	IDS_ADDSTORE_DESCRIPTION, // "add certificate to store"
	IDS_ADDSTORE_USAGEARGS,	// "CertificateStoreName InFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbAddStore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"delstore",		// pwszArg
	IDS_DELSTORE_DESCRIPTION, // "delete certificate from store"
	IDS_DELSTORE_USAGEARGS,	// "CertificateStoreName CertIndex"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDelStore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"verifystore",		// pwszArg
	IDS_VERIFYSTORE_DESCRIPTION, // "verify certificate in store"
	IDS_VERIFYSTORE_USAGEARGS, // "CertificateStoreName [CertIndex]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbVerifyStore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"repairstore",		// pwszArg
	IDS_REPAIRSTORE_DESCRIPTION, // "repair certificate KeyPprovInfo in store"
	IDS_REPAIRSTORE_USAGEARGS, // "CertificateStoreName CertIndex"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRepairStore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"viewstore",		// pwszArg
	IDS_STORE_DESCRIPTION,	// "view certificate store"
	IDS_STORE_USAGEARGS,	// "[CertificateStoreName [CertIndex [OutputFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	3,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewOrDeleteStore,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszViewDelStore,	// pwszArg
	IDS_DELSTORE_DESCRIPTION, // "delete certificate from store"
	IDS_STORE_USAGEARGS,	// "[CertificateStoreName [CertIndex [OutputFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	3,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewOrDeleteStore,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"ds",			// pwszArg
	IDS_DS_DESCRIPTION,	// "Display DS DNs"
	IDS_DS_USAGEARGS,	// "[CN]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SPLIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDS,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsDel",		// pwszArg
	IDS_DSDEL_DESCRIPTION,	// "Delete DS DNs"
	IDS_DSDEL_USAGEARGS,	// "CN"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SPLIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSDel,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsPublish",		// pwszArg
	IDS_DSPUBLISH_DESCRIPTION, // "Publish Certificate or CRL to DS"
	IDS_DSPUBLISH_USAGEARGS, // "CertFile [%1 | %2 | %3 | %4 | %5 | %6 | %7]\nCRLFile [DSCDPContainer [DSCDPCN]]"
	IDS_DSPUBLISH_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSPublish,		// pfnVerb
	g_papwszUsageDSPublish,	// papwszUsageConstants
    },
    {
	L"dsCert",		// pwszArg
	IDS_DSCERT_DESCRIPTION,	// "Display DS Certificates"
	IDS_DSCERT_USAGEARGS,	// "[CertIndex [OutFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_ENTERPRISE | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSCert,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsCRL",		// pwszArg
	IDS_DSCRL_DESCRIPTION,	// "Display DS CRLs"
	IDS_DSCRL_USAGEARGS,	// "[CRLIndex [OutFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_IDISPATCH | AF_OPTION_ENTERPRISE | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSCRL,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsDeltaCRL",		// pwszArg
	IDS_DSDELTACRL_DESCRIPTION, // "Display DS Delta CRLs"
	IDS_DSDELTACRL_USAGEARGS,   // "[CRLIndex [OutFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_ENTERPRISE | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSDeltaCRL,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsTemplate",		// pwszArg
	IDS_DSTEMPLATE_DESCRIPTION, // "Display DS Template Attributes"
	IDS_DSTEMPLATE_USAGEARGS,   // "[Template]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_PRIVATE,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSTemplate,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsAddTemplate",	// pwszArg
	IDS_DSADDTEMPLATE_DESCRIPTION, // "Add DS Templates"
	IDS_DSADDTEMPLATE_USAGEARGS,   // "TemplateInfFile"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_PRIVATE | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSAddTemplate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"Template",		// pwszArg
	IDS_TEMPLATE_DESCRIPTION, // "Display Templates"
	IDS_TEMPLATE_USAGEARGS,   // "[Template]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_OPTION_UT | AF_OPTION_MT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbTemplate,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"TemplateCAs",		// pwszArg
	IDS_TEMPLATECAS_DESCRIPTION, // "Display CAs for Template"
	IDS_TEMPLATECAS_USAGEARGS,   // "Template"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbTemplateCAs,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"CATemplates",		// pwszArg
	IDS_CATEMPLATES_DESCRIPTION, // "Display Templates for CA"
	IDS_CATEMPLATES_USAGEARGS,   // "[Template]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_OPTION_UT | AF_OPTION_MT | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCATemplates,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"URLCache",		// pwszArg
	IDS_URLCACHE_DESCRIPTION, // "Display URL Cache"
	IDS_URLCACHE_USAGEARGS,   // "URL [%1]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbURLCache,		// pfnVerb
	g_papwszUsageDelete,	// papwszUsageConstants
    },
    {
	L"pulse",		// pwszArg
	IDS_PULSE_DESCRIPTION,	// "Pulse autoenrollment events"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPulse,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"MachineInfo",		// pwszArg
	IDS_MACHINEINFO_DESCRIPTION, // "Display DS machine object information"
	IDS_MACHINEINFO_USAGEARGS,   // "SAMMachineName$"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbMachineInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"DCInfo",		// pwszArg
	IDS_DCINFO_DESCRIPTION,	// "Display DC information"
	IDS_DCINFO_USAGEARGS,	// "[%1 | %2 | %3]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDCInfo,		// pfnVerb
	g_papwszUsageDCInfo,	// papwszUsageConstants
    },
    {
	L"EntInfo",		// pwszArg
	IDS_ENTINFO_DESCRIPTION, // "Display Enterprise information"
	IDS_ENTINFO_USAGEARGS,	// "SAMMachineName$"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbEntInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"TCAInfo",		// pwszArg
	IDS_TCAINFO_DESCRIPTION, // "Display CA information"
	IDS_TCAINFO_USAGEARGS,	// "[Domain | - [%1]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbTCAInfo,		// pfnVerb
	g_papwszUsageTCAInfo,	// papwszUsageConstants
    },
    {
	L"SCInfo",		// pwszArg
	IDS_SCINFO_DESCRIPTION,	// "Display Smart Card information"
	IDS_SCINFO_USAGEARGS,	// "[Reader Name]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SPLIT,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSCInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"key",			// pwszArg
	IDS_KEY_DESCRIPTION,	// "list key containers"
	IDS_KEY_USAGEARGS,	// "[KeyContainerName | *] [CSP | *]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbKey,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"delkey",		// pwszArg
	IDS_DELKEY_DESCRIPTION, // "delete named key container"
	IDS_DELKEY_USAGEARGS,	// "KeyContainerName [CSP]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDelKey,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"verifykeys",		// pwszArg
	IDS_VERIFYKEYS_DESCRIPTION, // "Verify public/private key set"
	IDS_VERIFYKEYS_USAGEARGS, // "[KeyContainerName CACertFile]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SILENT | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbVerifyKeys,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"verify",		// pwszArg
	IDS_VERIFY_DESCRIPTION,	// "Verify certificate chain"
	IDS_VERIFY_USAGEARGS,	// "CertFile [CACertFile]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_USER | AF_OPTION_SILENT | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbVerifyCert,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"csp",			// pwszArg
	IDS_CSP_DESCRIPTION,	// "list all CSPs installed on this machine"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCSPDump,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"csptest",		// pwszArg
	IDS_CSPTEST_DESCRIPTION,// "test one or all CSPs installed on this machine"
	IDS_CSPTEST_USAGEARGS,
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCSPTest,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getcert",		// pwszArg
	IDS_GETCERT_DESCRIPTION,// "select a certificate from a selection UI"
	IDS_GETCERT_USAGEARGS,  // "[ObjectId | %1 | %2 [CommonName]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCertFromUI,	// pfnVerb
	g_papwszUsageGetCert,	// papwszUsageConstants
    },
    { L"", },
    {
	L"vroot",		// pwszArg
	IDS_VROOT_DESCRIPTION,	// "Create/Delete Web Virtual Roots and File Share"
	IDS_VROOT_USAGEARGS,	// "[%1]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCreateVRoots,	// pfnVerb
	g_papwszUsageDelete,	// papwszUsageConstants
    },
    {
	L"7f",			// pwszArg
	IDS_7F_DESCRIPTION,	// "Check certificate for 0x7f length encodings"
	IDS_7F_USAGEARGS,	// "CertFile"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_PRIVATE,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCheck7f,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"oid",			// pwszArg
	IDS_OIDNAME_DESCRIPTION,// "Display or set ObjectId display name"
	IDS_OIDNAME_USAGEARGS,	// "ObjectId [DisplayName [LanguageId [Type]]]"
	IDS_OIDNAME_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	4,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbOIDName,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"error",		// pwszArg
	IDS_ERRCODE_DESCRIPTION,// "Display error code message text"
	IDS_ERRCODE_USAGEARGS,	// "ErrorCode"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_STOPPARSINGARGS,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbErrorDump,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getmapiinfo",		// pwszArg
	IDS_GETMAPI_DESCRIPTION,// "get MAPI info"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetMapiInfo,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"setmapiinfo",		// pwszArg
	IDS_SETMAPI_DESCRIPTION, // "set MAPI info"
	IDS_SETMAPI_USAGEARGS,
	0,			// idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetMapiInfo,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getreg",
	IDS_GETREG_DESCRIPTION,	// "Display registry value"
	IDS_GETREG_USAGEARGS,	// "[{%1|%2|%3|%4|%5}\\[%6\\]RegistryValueName"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_NEEDCOINIT | AF_OPTIONALCONFIG, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetReg,		// pfnVerb
	g_papwszUsageGetSetReg,	// papwszUsageConstants
    },
    {
	L"setreg",
	IDS_SETREG_DESCRIPTION,	// "Set registry value"
	IDS_SETREG_USAGEARGS,	// "[{%1|%2|%3|%4|%5}\\[%6\\]RegistryValueName Value"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_NEEDCOINIT | AF_OPTIONALCONFIG | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetReg,		// pfnVerb
	g_papwszUsageGetSetReg,	// papwszUsageConstants
    },
    {
	L"delreg",
	IDS_DELREG_DESCRIPTION,	// "Delete registry value"
	IDS_GETREG_USAGEARGS,	// "[{%1|%2|%3|%4|%5}\\[%6\\]RegistryValueName"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_NEEDCOINIT | AF_OPTIONALCONFIG | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDelReg,		// pfnVerb
	g_papwszUsageGetSetReg,	// papwszUsageConstants
    },
    {
	L"GetKey",
	IDS_GETKEY_DESCRIPTION,	// "Retrieve archived private key recovery blob"
	IDS_GETKEY_USAGEARGS,	// "UserNameOrSerialNumber [RecoveryBlobOutFile]"
	0,			// idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_USER | AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_NEEDCOINIT | AF_OPTIONALCONFIG, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetKey,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"RecoverKey",
	IDS_RECOVERKEY_DESCRIPTION, // "Recover archived private key"
	IDS_RECOVERKEY_USAGEARGS,   // "RecoveryBlobInFile PFXOutFile [RecipientIndex]"
	0,			// idsArgDescription
	2,			// cArgMin
	3,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_FORCE | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRecoverKey,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"MergePFX",
	IDS_MERGEPFX_DESCRIPTION, // "Merge PFX files"
	IDS_MERGEPFX_USAGEARGS,	// "PFXInFileList PFXOutFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbMergePFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"?",			// pwszArg
	IDS_USAGE_DESCRIPTION,	// "Display this usage message"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbUsage,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"f",			// pwszArg
	IDS_FORCE_DESCRIPTION,	// "Force overwrite"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	&g_fForce,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"idispatch",		// pwszArg
	IDS_IDISPATCH_DESCRIPTION, // "Use IDispatch instead of COM"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_IDISPATCH, // Flags
	&g_fIDispatch,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"enterprise",		// pwszArg
	IDS_ENTERPRISE_DESCRIPTION, // "Use Enterprise certificate store"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_ENTERPRISE,	// Flags
	&g_fEnterpriseRegistry,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"user",		// pwszArg
	IDS_USER_DESCRIPTION,	// "Use HKEY_CURRENT_USER certificate store"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_USER,		// Flags
	&g_fUserRegistry,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"ut",			// pwszArg
	IDS_UT_DESCRIPTION,	// "Display user templates"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_UT,		// Flags
	&g_fUserTemplates,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"mt",			// pwszArg
	IDS_MT_DESCRIPTION,	// "Display machine templates"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_MT,		// Flags
	&g_fMachineTemplates,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"nocr",		// pwszArg
	IDS_NOCR_DESCRIPTION,	// "Encode text without CR characters"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_NOCR, // Flags
	&g_fNoCR,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"gmt",			// pwszArg
	IDS_GMT_DESCRIPTION,	// "Display times as GMT"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_GMT,		// Flags
	&g_fGMT,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"seconds",		// pwszArg
	IDS_SECONDS_DESCRIPTION,// "Display times with seconds and milliseconds"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_SECONDS,	// Flags
	&g_fSeconds,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"silent",		// pwszArg
	IDS_SILENT_DESCRIPTION,	// "Use silent flag to acquire crypt context"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_SILENT,	// Flags
	&g_fCryptSilent,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"split",		// pwszArg
	IDS_SPLIT_DESCRIPTION,	// "Split embedded ASN.1 elements, and save to files"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_SPLIT,	// Flags
	&g_fSplitASN,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"v",			// pwszArg
	IDS_VERBOSE_DESCRIPTION, // "Verbose operation"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_VERBOSE,	// Flags
	&g_fVerbose,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"v1",			// pwszArg
	IDS_V1_DESCRIPTION,	// "Use V1 COM interfaces"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_V1, // Flags
	&g_fV1Interface,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"reverse",		// pwszArg
	IDS_REVERSE_DESCRIPTION, // "Reverse Log and Queue columns"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_REVERSE, // Flags
	&g_fReverse,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"admin",		// pwszArg
	IDS_ADMIN_DESCRIPTION,	// "Use ICertAdmin2 for CA Properties"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_ADMIN, // Flags
	&g_fAdminInterface,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"config",		// pwszArg
	IDS_CONFIG_DESCRIPTION,	// "CA and Machine name string"
	IDS_CONFIG_USAGE,	// "Machine\\CAName"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CONFIG,	// Flags
	NULL,			// pBool
	&g_pwszConfig,		// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restrict",		// pwszArg
	IDS_RESTRICT_DESCRIPTION, // "Comma-separated Restriction List"
	IDS_RESTRICT_USAGE,	// "RestrictionList"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_RESTRICT,	// Flags
	NULL,			// pBool
	&g_pwszRestrict,	// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"out",			// pwszArg
	IDS_OUT_DESCRIPTION,	// "Comma-separated Column List"
	IDS_OUT_USAGE,		// "ColumnList"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_OUT,		// Flags
	NULL,			// pBool
	&g_pwszOut,		// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"p",			// pwszArg
	IDS_PASSWORD_DESCRIPTION, // "password"
	IDS_PASSWORD_DESCRIPTION, // "password"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_PASSWORD,	// Flags
	NULL,			// pBool
	&g_pwszPassword,	// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
};


VOID
cuPrintErrorAndString(
    OPTIONAL IN WCHAR const *pwszProc,
    IN DWORD idmsg,
    IN HRESULT hr,
    OPTIONAL IN WCHAR const *pwszString)
{
    WCHAR const *pwsz;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszError = NULL;

    if (NULL != pwszProc)
    {
	wprintf(L"%ws: ", pwszProc);
    }
    if (0 != idmsg)
    {
	pwsz = myLoadResourceString(idmsg);	// "??? returned %ws"
	if (NULL == pwsz)
	{
	    pwsz =  L"Error: %ws";
	}
    }
    else
    {
	pwsz =  L"%ws";
    }
    pwszError = myGetErrorMessageText(hr, TRUE);
    if (NULL == pwszError)
    {
	pwszError = myHResultToString(awchr, hr);
    }
    wprintf(pwsz, pwszError);
    if (NULL != pwszString)
    {
	wprintf(L" -- %ws", pwszString);
    }
    wprintf(wszNewLine);
    if (NULL != pwszError && awchr != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
}


VOID
cuPrintError(
    IN DWORD idmsg,
    IN HRESULT hr)
{
    cuPrintErrorAndString(NULL, idmsg, hr, NULL);
}


VOID
cuPrintErrorMessageText(
    IN HRESULT hr)
{
    WCHAR const *pwszMessage;

    pwszMessage = myGetErrorMessageText(hr, FALSE);
    if (NULL != pwszMessage)
    {
	wprintf(L"%ws: %ws\n", g_pwszProg, pwszMessage);
	LocalFree(const_cast<WCHAR *>(pwszMessage));
    }
}
 

HRESULT
cuGetLong(
    WCHAR const *pwszIn,
    LONG *pLong)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR const *pwsz;
    LONG l;

    pwsz = pwszIn;
    if (NULL == pwsz)
    {
	_JumpError(hr, error, "NULL parm");
    }
    if (L'\0' == *pwsz)
    {
	_JumpError(hr, error, "empty string");
    }
    if (L'0' == *pwsz && (L'x' == pwsz[1] || L'X' == pwsz[1]))
    {
	pwsz += 2;
	l = 0;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswxdigit(*pwsz))
	    {
		_JumpErrorStr(hr, error, "Non-hex digit", pwszIn);
	    }
	    l <<= 4;
	    if (iswdigit(*pwsz))
	    {
		l |= *pwsz - L'0';
	    }
	    else if (L'A' <= *pwsz && L'F' >= *pwsz)
	    {
		l |= *pwsz - L'A' + 10;
	    }
	    else
	    {
		l |= *pwsz - L'a' + 10;
	    }
	}
	*pLong = l;
    }
    else
    {
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswdigit(*pwsz))
	    {
		_JumpErrorStr2(hr, error, "Non-decimal digit", pwszIn, hr);
	    }
	}
	*pLong = _wtol(pwszIn);
    }
    hr = S_OK;
    //wprintf(L"cuGetLong(%ws) --> %x (%d)\n", pwszIn, *pLong, *pLong);

error:
    return(hr);
}


HRESULT
cuGetSignedLong(
    WCHAR const *pwszIn,
    LONG *pLong)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR const *pwsz;
    LONG sign = 1;

    pwsz = pwszIn;
    if (NULL == pwsz)
    {
	_JumpError(hr, error, "NULL parm");
    }
    if (L'-' == *pwsz)
    {
	pwsz++;
	sign = -1;
    }
    else if (L'+' == *pwsz)
    {
	pwsz++;
    }
    hr = cuGetLong(pwsz, pLong);
    _JumpIfError2(hr, error, "cuGetLong", hr);

    *pLong *= sign;
    //wprintf(L"cuGetSignedLong(%ws) --> %x (%d)\n", pwszIn, *pLong, *pLong);

error:
    return(hr);
}


VOID
LoadUsage(
    IN OUT ARG *parg)
{
    HRESULT hr;

    if (0 != parg->idsUsage && NULL == parg->pwszUsage)
    {
	WCHAR const *pwszUsage = myLoadResourceString(parg->idsUsage);

	if (NULL == parg->papwszUsageConstants)
	{
	    parg->pwszUsage = pwszUsage;
	}
	else
	{
	    if (0 == FormatMessage(
			    FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_STRING |
				FORMAT_MESSAGE_ARGUMENT_ARRAY,
			    (VOID *) pwszUsage,
			    0,              // dwMessageID
			    0,              // dwLanguageID
			    (LPWSTR) &parg->pwszUsage,
			    0,
			    (va_list *) parg->papwszUsageConstants))
	    {
		hr = myHLastError();
		_PrintError(hr, "FormatMessage");
	    }
	}
    }
}


VOID
FreeUsage(
    IN OUT ARG *parg)
{
    if (NULL != parg->pwszUsage)
    {
	if (NULL != parg->papwszUsageConstants)
	{
	    LocalFree(const_cast<WCHAR *>(parg->pwszUsage));
	}
	parg->pwszUsage = NULL;
    }
}


BOOL
DumpArgOptions(
    IN DWORD dwOptionFlags)
{
    ARG *parg;
    BOOL fDisplayed = FALSE;
    WCHAR const *pwszPrefix = g_wszPad4;

    dwOptionFlags |= AF_OPTION_GENERIC;
    dwOptionFlags &= AF_OPTION_MASK;
    for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
    {
	if (NULL != parg->pfnVerb)
	{
	    continue;
	}
	if (!g_fFullUsage && (AF_PRIVATE & parg->Flags))
	{
	    continue;
	}
	if (L'\0' == parg->pwszArg[0])
	{
	    continue;
	}
	if (1 >= g_fVerbose && (AF_OPTION_GENERIC & parg->Flags))
	{
	    continue;
	}
	if (dwOptionFlags & parg->Flags)
	{
	    wprintf(
		L"%ws%ws-%ws",
		pwszPrefix,
		wszLBRACKET,
		parg->pwszArg);
	    if (0 != parg->idsUsage)
	    {
		LoadUsage(parg);
		wprintf(L" %ws", parg->pwszUsage);
	    }
	    wprintf(wszRBRACKET);
	    pwszPrefix = L" ";
	    fDisplayed = TRUE;
	}
    }
    if (fDisplayed)
    {
	wprintf(wszNewLine);
    }
    return(fDisplayed);
}


VOID
DumpArgUsage(
    IN ARG *parg)
{
    WCHAR const *pwsz;
    int *paidsUsage;
    
    if (0 != parg->idsUsage)
    {
	LoadUsage(parg);
    }
    pwsz = parg->pwszUsage;
    while (TRUE)
    {
	wprintf(
	    L"  %ws %ws-%ws%ws [%ws]",
	    g_pwszProg,
	    pargDEFAULT	== parg? wszLBRACKET : L"",
	    parg->pwszArg,
	    pargDEFAULT	== parg? wszRBRACKET : L"",
	    myLoadResourceString(IDS_USAGE_OPTIONS));
	if (NULL != pwsz)
	{
	    DWORD cwc = 0;

	    cwc = wcscspn(pwsz, L"\r\n");
	    if (0 != cwc)
	    {
		wprintf(L" %.*ws", cwc, pwsz);
		pwsz += cwc;
	    }
	    while ('\r' == *pwsz || '\n' == *pwsz)
	    {
		pwsz++;
	    }
	}
	wprintf(wszNewLine);
	if (NULL == pwsz || L'\0' == *pwsz)
	{
	    break;
	}
    }
    if (0 != parg->idsArgDescription)
    {
	HRESULT hr;
	WCHAR const *pwszArg = myLoadResourceString(parg->idsArgDescription);
	WCHAR *pwszArgFormatted = NULL;

	if (NULL != pwszArg && L'\0' != *pwszArg)
	{
	    if (0 == FormatMessage(
			    FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_STRING |
				FORMAT_MESSAGE_ARGUMENT_ARRAY,
			    (VOID *) pwszArg,
			    0,              // dwMessageID
			    0,              // dwLanguageID
			    (LPWSTR) &pwszArgFormatted,
			    wcslen(pwszArg),
			    (va_list *) parg->papwszUsageConstants))
	    {
		hr = myHLastError();
		_PrintError(hr, "FormatMessage");
	    }
	    pwsz = NULL != pwszArgFormatted? pwszArgFormatted : pwszArg;
	    while (L'\0' != *pwsz)
	    {
		DWORD cwc = 0;

		cwc = wcscspn(pwsz, L"\r\n");
		if (0 != cwc)
		{
		    wprintf(L"    %.*ws", cwc, pwsz);
		    pwsz += cwc;
		}
		wprintf(wszNewLine);
		if ('\r' == *pwsz)
		{
		    pwsz++;
		}
		if ('\n' == *pwsz)
		{
		    pwsz++;
		}
	    }
	    if (NULL != pwszArgFormatted)
	    {
		LocalFree(pwszArgFormatted);
	    }
	}
    }
}


VOID
Usage(
    IN DWORD msgid,
    OPTIONAL WCHAR const *pwszMsg,
    IN DWORD dwOption,
    OPTIONAL IN ARG *pargVerb)
{
    ARG *parg;
    DWORD dwFlags = AF_OPTION_GENERIC;
    WCHAR const *pwszArg;
    DWORD i;
    DWORD adwids[] =
    {
	IDS_USAGE_LIST_VERBS,		// "display verb list (command list)"
	IDS_FORMAT_USAGE_ONE_HELP,	// "display help for the %ws verb"
	IDS_USAGE_ALL_HELP,		// "display help for all verbs"
    };
    WCHAR const *apwszCommandLine[] =
    {
	L"%ws -?",	// IDS_USAGE_LIST_VERBS
	L"%ws -%ws -?",	// IDS_FORMAT_USAGE_ONE_HELP
	L"%ws -v -?",	// IDS_USAGE_ALL_HELP
    };

    // Display the error message for the detected usage error.  If the error
    // message requires it, point at the optional arg string to be displayed
    // along with the error message.

    if (0 != msgid)
    {
	if (NULL == pwszMsg && 0 != dwOption)
	{
	    for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	    {
		if (NULL != parg->pfnVerb)
		{
		    continue;
		}
		if (dwOption & parg->Flags)
		{
		    pwszMsg = parg->pwszArg;
		    break;
		}
	    }
	}

	// Display a command line usage error message.

	wprintf(L"%ws: ", g_pwszProg);
	wprintf(myLoadResourceString(msgid), pwszMsg);
	wprintf(L"\n\n");
    }
    else
    {
	// if no error and no verb selected, display all verbs & descriptions

	if (NULL == pargVerb)
	{
	    wprintf(L"\n%ws\n", myLoadResourceString(IDS_USAGE_VERBS));
	    for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	    {
		if (!g_fFullUsage && (AF_PRIVATE & parg->Flags))
		{
		    continue;
		}
		if (L'\0' == parg->pwszArg[0])
		{
		    wprintf(wszNewLine);
		    continue;
		}
		if (NULL != parg->pfnVerb)
		{
		    dwFlags |= parg->Flags;
		    if (0 != parg->idsDescription &&
			NULL == parg->pwszDescription)
		    {
			parg->pwszDescription = myLoadResourceString(
							    parg->idsDescription);
		    }
		    wprintf(L"  -");
		    myConsolePrintString(CCOL_VERB, parg->pwszArg);
		    wprintf(L" -- %ws\n", parg->pwszDescription);
		}
	    }
	}
    }

    // if in verbose mode, display full usage for all verbs.
    // if verb was specified, display usage for one verb.

    if ((0 == msgid && g_fVerbose) || NULL != pargVerb)
    {
	ARG *pargStart;
	ARG *pargEnd;

	wprintf(L"%ws\n", myLoadResourceString(IDS_USAGE_HEADER));

	if (NULL != pargVerb)
	{
	    pargStart = pargVerb;	// display one verb
	    pargEnd = &pargVerb[1];
	}
	else
	{
	    pargStart = aarg;		// display all verbs
	    pargEnd = &aarg[ARRAYSIZE(aarg)];
	}

	for (parg = pargStart ; parg < pargEnd; parg++)
	{
	    if (!g_fFullUsage &&
		(AF_PRIVATE & parg->Flags) &&
		parg != pargVerb)
	    {
		continue;		// skip private verbs unless specified
	    }
	    if (L'\0' == parg->pwszArg[0])
	    {
		continue;		// skip newline separator entries
	    }
	    if (NULL != parg->pfnVerb)	// if it's a verb (not an option entry)
	    {
		dwFlags |= parg->Flags;
		DumpArgUsage(parg);
		if (g_fVerbose)
		{
		    DumpArgOptions(parg->Flags);
		}

		// Special case for CAInfo verb:

		if (IDS_CAINFO_USAGEARGS == parg->idsUsage &&
		    (g_fFullUsage ||
		     (0 == msgid && g_fVerbose) ||
		     parg == pargVerb))
		{
		    cuCAInfoUsage();
		}
		wprintf(wszNewLine);
	    }
	}

	// display options and descriptions for displayed verbs

	wprintf(L"%ws\n", myLoadResourceString(IDS_OPTIONS_USAGEARGS));
	for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	{
	    if (L'\0' == parg->pwszArg[0])
	    {
		continue;
	    }
	    if (NULL != parg->pfnVerb)
	    {
		continue;
	    }
	    if (!g_fFullUsage && (AF_PRIVATE & parg->Flags))
	    {
		continue;
	    }

	    // skip options for undisplayed verbs,
	    // unless in verbose mode and no verb was specified

	    if ((!g_fVerbose || NULL != pargVerb) &&
		0 == (AF_OPTION_MASK & dwFlags & parg->Flags))
	    {
		continue;
	    }
	    wprintf(L"  -");
	    if (0 != parg->idsUsage)
	    {
		LONG ccol;
		LONG ccolOption = NULL != parg->ppString?
				    CCOL_OPTIONARG : CCOL_OPTIONBARE;
		
		LoadUsage(parg);
		ccol = myConsolePrintString(0, parg->pwszArg);
		wprintf(L" ");
		ccol++;
		myConsolePrintString(
				ccolOption <= ccol? 0 : ccolOption - ccol,
				parg->pwszUsage);
	    }
	    else
	    {
		myConsolePrintString(CCOL_OPTIONBARE, parg->pwszArg);
	    }
	    if (0 != parg->idsDescription && NULL == parg->pwszDescription)
	    {
		parg->pwszDescription = myLoadResourceString(
							parg->idsDescription);
	    }
	    wprintf(L" -- %ws\n", parg->pwszDescription);
	}

	for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	{
	    FreeUsage(parg);
	}
    }

    pwszArg = (NULL != pargVerb && NULL != pargVerb->pwszArg)?
		pargVerb->pwszArg : pargDEFAULT->pwszArg;

    wprintf(wszNewLine);
    for (i = 0; i < ARRAYSIZE(adwids); i++)
    {
	LONG ccol;
	WCHAR wsz[128];
	
	_snwprintf(
		wsz,
		ARRAYSIZE(wsz) - 1,
		apwszCommandLine[i],
		g_pwszProg,
		pwszArg);
	wsz[ARRAYSIZE(wsz) - 1] = L'\0';
	myConsolePrintString(CCOL_OPTIONARG, wsz);
	wprintf(L" -- ");
	wprintf(myLoadResourceString(adwids[i]), pwszArg);
	wprintf(wszNewLine);
    }
    wprintf(wszNewLine);
    if (0 != msgid)
    {
	exit(1);
    }
}


HRESULT
verbUsage(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszError,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    Usage(0, NULL, 0, NULL);
    return(S_OK);
}


VOID
cuUnloadCert(
    IN OUT CERT_CONTEXT const **ppCertContext)
{
    if (NULL != *ppCertContext)
    {
	CertFreeCertificateContext(*ppCertContext);
	*ppCertContext = NULL;
    }
}


HRESULT
cuLoadCert(
    IN WCHAR const *pwszfnCert,
    OUT CERT_CONTEXT const **ppCertContext)
{
    HRESULT hr;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    CERT_INFO *pCertInfo = NULL;
    DWORD cbCertInfo;

    *ppCertContext = NULL;

    hr = DecodeFileW(pwszfnCert, &pbCert, &cbCert, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }

    // Decode certificate

    cbCertInfo = 0;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    pbCert,
		    cbCert,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pCertInfo,
		    &cbCertInfo))
    {
	hr = myHLastError();
	_JumpError2(hr, error, "myDecodeObject", CRYPT_E_ASN1_BADTAG);
    }

    *ppCertContext = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				pbCert,
				cbCert);
    if (NULL == *ppCertContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

error:
    if (NULL != pCertInfo)
    {
	LocalFree(pCertInfo);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    return(hr);
}


VOID
cuUnloadCRL(
    IN OUT CRL_CONTEXT const **ppCRLContext)
{
    if (NULL != *ppCRLContext)
    {
	CertFreeCRLContext(*ppCRLContext);
	*ppCRLContext = NULL;
    }
}


HRESULT
cuLoadCRL(
    IN WCHAR const *pwszfnCRL,
    OUT CRL_CONTEXT const **ppCRLContext)
{
    HRESULT hr;
    BYTE *pbCRL = NULL;
    DWORD cbCRL;
    CRL_INFO *pCRLInfo = NULL;
    DWORD cbCRLInfo;

    *ppCRLContext = NULL;

    hr = DecodeFileW(pwszfnCRL, &pbCRL, &cbCRL, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }

    // Decode CRL

    cbCRLInfo = 0;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_CRL_TO_BE_SIGNED,
		    pbCRL,
		    cbCRL,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pCRLInfo,
		    &cbCRLInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    *ppCRLContext = CertCreateCRLContext(
				X509_ASN_ENCODING,
				pbCRL,
				cbCRL);
    if (NULL == *ppCRLContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCRLContext");
    }

error:
    if (NULL != pCRLInfo)
    {
	LocalFree(pCRLInfo);
    }
    if (NULL != pbCRL)
    {
	LocalFree(pbCRL);
    }
    return(hr);
}


HRESULT
cuSetConfig()
{
    HRESULT hr;

    if (NULL == g_pwszConfig)
    {
	hr = myGetConfig(CC_LOCALCONFIG, &g_pwszConfigAlloc);
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
	    wprintf(
		myLoadResourceString(IDS_ERR_FORMAT_NO_LOCAL_CONFIG), // "%ws: No local Certification Authority; use -config option"
		g_pwszProg);
	    wprintf(wszNewLine);
	    
	}
	_JumpIfError(hr, error, "myGetConfig");
    }
    else if (0 == lstrcmp(L"-", g_pwszConfig))
    {
	hr = myGetConfig(CC_UIPICKCONFIG, &g_pwszConfigAlloc);
	if (S_OK != hr)
	{
	    cuPrintError(IDS_ERR_CONFIGGETCONFIG, hr);
	    goto error;
	}
    }
    if (NULL != g_pwszConfigAlloc)
    {
	g_pwszConfig = g_pwszConfigAlloc;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ArgvMain(
    int argc,
    WCHAR *argv[],
    HWND hWndOwner)
{
    WCHAR const *pwszArg1 = NULL;
    WCHAR const *pwszArg2 = NULL;
    WCHAR const *pwszArg3 = NULL;
    WCHAR const *pwszArg4 = NULL;
    BOOL fDlgResult;
    ARG *pargVerb = NULL;
    DWORD dwOptionFlags = 0;
    DWORD dwExtraOptions;
    ARG *parg;
    HRESULT hr;
    BOOL fCoInit = FALSE;
    BOOL fStopParsing = FALSE;
    BOOL fInitCS = FALSE;
    FILE *pfRedirected = NULL;
	
    __try
    {
	InitializeCriticalSection(&g_DBCriticalSection);
	fInitCS = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    myVerifyResourceStrings(g_hInstance);

#ifdef TESTUUENCODE
    RunTests();
#endif

    while (!fStopParsing &&
	1 < argc &&
	(L'-' == argv[1][0] || L'/' == argv[1][0]) &&
	L'\0' != argv[1][1])
    {
	if (0 == lstrcmpi(&argv[1][1], L"stdio"))
	{
	    myConsolePrintfDisable(TRUE);
	}
	else if (0 == lstrcmp(&argv[1][1], L"uSAGE"))
	{
	    g_fFullUsage = TRUE;
	    Usage(0, NULL, 0, pargVerb);
	    hr = S_OK;
	    goto error;
	}
	else
	{
	    for (parg = aarg; ; parg++)
	    {
		if (parg >= &aarg[ARRAYSIZE(aarg)])
		{
		    Usage(
			IDS_FORMAT_USAGE_UNKNOWNARG,	// "Unknown arg: %ws"
			argv[1],
			0,
			pargVerb);
		    CSASSERT(FALSE);		// no deposit, no return
		    exit(1);
		}
		if (0 == lstrcmpi(&argv[1][1], parg->pwszArg))
		{
		    break;
		}
	    }
	    if (NULL != parg->pBool)
	    {
		(*parg->pBool)++;
		dwOptionFlags |= parg->Flags;
	    }
	    if (NULL != parg->ppString)
	    {
		if (2 >= argc)
		{
		    Usage(IDS_FORMAT_USAGE_MISSINGNAMEDARG, parg->pwszArg, 0, pargVerb); // "Missing %ws argument"
		}
		if (NULL != *parg->ppString)
		{
		    Usage(IDS_FORMAT_USAGE_REPEATEDNAMEDARG, parg->pwszArg, 0, pargVerb); // "Repeated %ws option"
		}
		*parg->ppString = argv[2];
		dwOptionFlags |= parg->Flags;
		argc--;
		argv++;
	    }
	    if (NULL != parg->pfnVerb)
	    {
		if (NULL != pargVerb)
		{
		    Usage(
			verbUsage == parg->pfnVerb?
			    0 :
			    IDS_FORMAT_USAGE_MULTIPLEVERBARGS, // "Multiple verb args: %ws"
			argv[1],
			0,
			pargVerb);
		    exit(1);
		}
		pargVerb = parg;
		if (AF_STOPPARSINGARGS & pargVerb->Flags)
		{
		    fStopParsing = TRUE;
		}
	    }
	}
	argc--;
	argv++;
    }
    if (NULL == pargVerb)
    {
	pargVerb = pargDEFAULT;
    }
    if (pargVerb->cArgMin > argc - 1)
    {
	wprintf(
	    myLoadResourceString(IDS_ERR_FORMAT_SHOW_TOO_FEW_ARGS), // "Expected at least %u args, received %u"
	    pargVerb->cArgMin,
	    argc - 1);
	wprintf(wszNewLine);

	Usage(IDS_USAGE_MISSINGARG, NULL, 0, pargVerb); // "missing argument"
    }
    if (pargVerb->cArgMax < argc - 1)
    {
	wprintf(
	    myLoadResourceString(IDS_ERR_FORMAT_SHOW_TOO_MANY_ARGS), // "Expected no more than %u args, received %u"
	    pargVerb->cArgMax,
	    argc - 1);

	wprintf(wszNewLine);

	Usage(IDS_USAGE_TOOMANYARGS, NULL, 0, pargVerb); // "too many arguments"
    }

    g_DispatchFlags = DISPSETUP_COM;
    if (g_fIDispatch)
    {
	g_DispatchFlags = DISPSETUP_IDISPATCH;
	if (1 < g_fIDispatch)
	{
	    g_DispatchFlags = DISPSETUP_COMFIRST;
	}
    }
    if (g_fForce)
    {
	g_EncodeFlags = DECF_FORCEOVERWRITE;
    }
    if (g_fNoCR)
    {
	g_CryptEncodeFlags = CRYPT_STRING_NOCR;
    }
#if 0
    wprintf(
	L"-%ws: %ws %ws carg=%u-%u Flags=%x pfn=%x\n",
	pargVerb->pwszArg,
	pargVerb->pwszUsage,
	pargVerb->pwszDescription,
	pargVerb->cArgMin,
	pargVerb->cArgMax,
	pargVerb->Flags,
	pargVerb->pfnVerb);
#endif

    hr = myGetComputerNames(&g_pwszDnsName, &g_pwszOldName);
    _JumpIfError(hr, error, "myGetComputerNames");

    if (AF_NEEDCOINIT & pargVerb->Flags)
    {
	hr = CoInitialize(NULL);
	if (S_OK != hr && S_FALSE != hr)
	{
	    _JumpError(hr, error, "CoInitialize");
	}
	fCoInit = TRUE;
    }

    if (AF_OPTION_CONFIG & pargVerb->Flags)
    {
	if (0 == (AF_NEEDCOINIT & pargVerb->Flags))
	{
	    Usage(IDS_USAGE_INTERNALVERBTABLEERROR, NULL, 0, pargVerb); // "Missing fCoInit flag"
	    goto error;
	}
	hr = cuSetConfig();
	_JumpIfError(hr, error, "cuSetConfig");
    }
    else if (0 == (AF_OPTIONALCONFIG & pargVerb->Flags))
    {
	if (NULL != g_pwszConfig)
	{
	    Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, AF_OPTION_CONFIG, pargVerb); // "Unexpected -%ws"
	}
    }
    if (NULL != g_pwszOut && 0 == (AF_OPTION_OUT & pargVerb->Flags))
    {
	Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, AF_OPTION_OUT, pargVerb); // "Unexpected %ws option"
    }
    if (NULL != g_pwszRestrict && 0 == (AF_OPTION_RESTRICT & pargVerb->Flags))
    {
	Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, AF_OPTION_RESTRICT, pargVerb); // "Unexpected %ws option"
    }
    dwExtraOptions = AF_OPTION_MASK &
			~AF_OPTION_GENERIC &
			dwOptionFlags &
			~pargVerb->Flags;

    if ((AF_OPTION_CONFIG & dwExtraOptions) &&
	(AF_OPTIONALCONFIG & pargVerb->Flags))
    {
	dwExtraOptions &= ~AF_OPTION_CONFIG;
    }
    if (0 != dwExtraOptions)
    {
	DBGPRINT((
	    DBG_SS_CERTUTIL,
	    "Extra options: 0x%x\n",
	    dwExtraOptions));
	Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, dwExtraOptions, pargVerb); // "Unexpected %ws option"
    }

    if (1 < argc)
    {
	pwszArg1 = argv[1];
	if (2 < argc)
	{
	    pwszArg2 = argv[2];
	    if (3 < argc)
	    {
		pwszArg3 = argv[3];
		if (4 < argc)
		{
		    pwszArg4 = argv[4];
		}
	    }
	}
    }

    __try
    {
	hr = (*pargVerb->pfnVerb)(
			    pargVerb->pwszArg,
			    pwszArg1,
			    pwszArg2,
			    pwszArg3,
			    pwszArg4);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (S_OK != hr)
    {
	WCHAR awchr[cwcHRESULTSTRING];

	wprintf(
	    myLoadResourceString(IDS_ERR_FORMAT_COMMAND_FAILED), // "%ws: -%ws command FAILED: %ws"
	    g_pwszProg,
	    pargVerb->pwszArg,
	    myHResultToString(awchr, hr));
	wprintf(wszNewLine);
	goto error;
    }
    if (!g_fQuiet)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_COMMAND_SUCCEEDED), // "%ws: -%ws command completed successfully."
	    g_pwszProg,
	    pargVerb->pwszArg);
	wprintf(wszNewLine);
	if (AF_RESTARTSERVER & pargVerb->Flags)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_RESTART_SERVER), // "The %ws service may need to be restarted for changes to take effect."
		wszSERVICE_NAME);
	    wprintf(wszNewLine);
	}
    }
	
error:
    if (S_OK != hr)
    {
	cuPrintErrorMessageText(hr);
        if (0 != g_uiExtraErrorInfo)
        {
            wprintf(myLoadResourceString(g_uiExtraErrorInfo));
            wprintf(wszNewLine);
        }
    }

    if (NULL != pfRedirected)
    {
        fclose(pfRedirected);
       _wfreopen(L"CON", L"w", stdout);
    }

    if (fCoInit)
    {
	CoUninitialize();
    }
    if (fInitCS)
    {
	DeleteCriticalSection(&g_DBCriticalSection);
    }
    return(hr);
}


//**************************************************************************
//  FUNCTION:	CertUtilPreMain
//  NOTES:	Based on vich's MkRootMain function; takes an LPSTR command
//		line and chews it up into argc/argv form so that it can be
//		passed on to a traditional C style main.
//**************************************************************************

#define ISBLANK(wc)	(L' ' == (wc) || L'\t' == (wc))

HRESULT 
CertUtilPreMain(
    WCHAR const *pwszCmdLine,
    HWND hWndOwner)
{
    HRESULT hr;
    WCHAR *pbuf;
    WCHAR *apszArg[20];
    int cArg = 0;
    WCHAR *p;
    WCHAR const *pchQuote;
    WCHAR **prgpwszExeName = NULL;
    int carg;

    csiLogOpen("+certutil.log");

    // Don't log passwords!
    //CSILOG(S_OK, IDS_LOG_COMMANDLINE, pwszCmdLine, NULL, NULL);
    prgpwszExeName = CommandLineToArgvW(L"", &carg);
    CSILOG(
	S_OK,
	IDS_LOG_COMMANDLINE,
	(NULL == prgpwszExeName || 1 > carg)?
	    L"certutil.exe" : prgpwszExeName[0],
	NULL,
	NULL);

    pbuf = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszCmdLine) + 1) * sizeof(WCHAR));
    if (NULL == pbuf)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    p = pbuf;

    apszArg[cArg++] = TEXT("CertUtil");
    while (*pwszCmdLine != TEXT('\0'))
    {
	while (ISBLANK(*pwszCmdLine))
	{
	    pwszCmdLine++;
	}
	if (*pwszCmdLine != TEXT('\0'))
	{
	    apszArg[cArg++] = p;
	    if (sizeof(apszArg)/sizeof(apszArg[0]) <= cArg)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Too many args");
	    }
	    pchQuote = NULL;
	    while (*pwszCmdLine != L'\0')
	    {
		if (NULL != pchQuote)
		{
		    if (*pwszCmdLine == *pchQuote)
		    {
			pwszCmdLine++;
			pchQuote = NULL;
			continue;
		    }
		}
		else
		{
		    if (ISBLANK(*pwszCmdLine))
		    {
			break;
		    }
		    if (L'"' == *pwszCmdLine)
		    {
			pchQuote = pwszCmdLine++;
			continue;
		    }
		}
		*p++ = *pwszCmdLine++;
	    }
	    *p++ = TEXT('\0');
	    if (*pwszCmdLine != TEXT('\0'))
	    {
		pwszCmdLine++;	// skip whitespace or quote character
	    }
	}
    }
    apszArg[cArg] = NULL;

    hr = ArgvMain(cArg, apszArg, hWndOwner);
    _JumpIfError(hr, error, "ArgvMain");

error:
    if (NULL != prgpwszExeName)
    {
	GlobalFree(prgpwszExeName);
    }
    if (NULL != pbuf)
    {
	LocalFree(pbuf);
    }
    CSILOG(hr, S_OK != hr? IDS_LOG_STATUS : IDS_LOG_STATUSOK, NULL, NULL, NULL);
    csiLogClose();
    return(hr);
}


//**************************************************************************
//  FUNCTION:	MainWndProc(...)
//  ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int nWCharsRequired;
    WCHAR *pwszCmdLine = NULL;
    CHAR const *pszCmdLine;
    HRESULT hr;
    LRESULT lr = 0;

    switch (msg)
    {
        case WM_CREATE:
        case WM_SIZE:
	    break;

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_DOCERTUTILMAIN:
	    pwszCmdLine = (WCHAR*)lParam;
	    hr = CertUtilPreMain(pwszCmdLine, hWnd);

	    PostQuitMessage(hr);
	    break;

        default:
	    lr = DefWindowProc(hWnd, msg, wParam, lParam);
	    break;
    }
    return(lr);
}


//+------------------------------------------------------------------------
//
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[pwszCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//
//  History:	12/07/96	JerryK	Added this Comment
//
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
{
    MSG msg;
    WNDCLASS wcApp;
    HWND hWndMain;

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");

    // Save the current instance
    g_hInstance = hInstance;

    // Set up the application's window class
    wcApp.style		= 0;
    wcApp.lpfnWndProc	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL,IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL,IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= wszAppName;

    if (!RegisterClass(&wcApp))
    {
	return(FALSE);
    }

    // Create Main Window
    hWndMain = CreateWindow(
			wszAppName,
			L"CertUtil Application",
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT,
			CW_USEDEFAULT, CW_USEDEFAULT,
			NULL,
			NULL,
			hInstance,
			NULL);
    if (NULL == hWndMain)
    {
	return(FALSE);
    }

    // Make window visible
    // ShowWindow(hWndMain, nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain, WM_DOCERTUTILMAIN, 0, (LPARAM) pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }

    if (NULL != g_pwszDnsName)
    {
	LocalFree(g_pwszDnsName);
    }
    if (NULL != g_pwszOldName)
    {
	LocalFree(g_pwszOldName);
    }
    if (NULL != g_pwszConfigAlloc)
    {
	LocalFree(g_pwszConfigAlloc);
    }
    myFreeResourceStrings("certutil.exe");
    myFreeColumnDisplayNames();
    myRegisterMemDump();
    return((int) msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\dbcnvt.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbcnvt.cpp
//
// Contents:    Cert Server Database conversion
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <esent.h>    // JET errors
#include <certdb.h>
#include <conio.h>

#include "certdb2.h"
#include "csprop2.h"
#include "db2.h"
#include "dbcore.h"
#include "odbc.h"

#undef DBG_CERTSRV_DEBUG_PRINT


BOOL
cuDBIsShutDownInProgress();

BOOL
cuDBAbortShutDown(
    IN DWORD dwCtrlType);

HRESULT
cuDBOpen(
    IN WCHAR const *pwszAuthority,
    IN BOOL fReadOnly,
    OUT ICertDB **ppdb);

HRESULT
cuDBPrintProperty(
    OPTIONAL IN ICertDBRow *prow,
    IN DWORD Type,
    IN WCHAR const *pwszColName,
    IN WCHAR const *pwszDisplayName,
    OPTIONAL IN BYTE const *pbValue,
    IN DWORD cbValue,
    OUT DWORD *pcbValue);


extern CRITICAL_SECTION g_DBEnumCriticalSection;
extern BOOL g_fDBEnumCSInit;
extern LIST_ENTRY g_DBEnumHandleList;

DWORD g_crowConvert;
DWORD g_crowSkipDuplicate;
DWORD g_crowSkipWrongCA;


HRESULT
PrintProperty(
    IN DWORD RequestId,
    IN WCHAR const *pwszTable,
    IN WCHAR const *pwszPropName,
    IN DWORD dwPropType,
    IN BYTE const *pbProp,
    IN DWORD cbProp)
{
    HRESULT hr = S_OK;
    
    if (g_fVerbose)
    {
	WCHAR wszName[MAX_PATH];
	BOOL fVerbose = g_fVerbose--;
	DWORD cb;

	wsprintf(wszName, L"%ws.%ws", pwszTable, pwszPropName);

	hr = cuDBPrintProperty(
			NULL,
			dwPropType,
			pwszPropName,
			wszName,
			pbProp,
			cbProp,
			&cb);
	g_fVerbose = fVerbose;
	_JumpIfError(hr, error, "cuDBPrintProperty");
    }

error:
    return(hr);
}


HRESULT 
TranslateToPropType(
    SWORD wCType,
    DWORD *pdwPropType)
{
    HRESULT hr = S_OK;

    // translate from SQL proptype to our type
    // Later, match these with the import table

    switch (wCType)
    {
	case SQL_C_ULONG:
	    *pdwPropType = PROPTYPE_LONG;
	    break;

	case SQL_C_BINARY:
	    *pdwPropType = PROPTYPE_BINARY;
	    break;

	case SQL_C_CHAR:
	    *pdwPropType = PROPTYPE_STRING;
	    break;

	case SQL_C_TIMESTAMP:
	    *pdwPropType = PROPTYPE_DATE;
	    break;

	default:
	    hr = E_UNEXPECTED;
            _JumpError(hr, error, "Illegal property type");
    }

error:
    return(hr);
}


HRESULT
GrowBuffer(
    IN DWORD cbProp,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    
    if (*pcbbuf < cbProp)
    {
        BYTE *pbNewAlloc = NULL;

        // alloc time!
        if (NULL != *ppbbuf)
	{
            pbNewAlloc = (BYTE *) LocalReAlloc(*ppbbuf, cbProp, LMEM_MOVEABLE);
	}
        else
	{
            pbNewAlloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbProp);
	}

        if (NULL == pbNewAlloc)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "Local[Re]Alloc");
        }
        *ppbbuf = pbNewAlloc;
        *pcbbuf = cbProp;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
GetDBPropertyAndReAlloc( 
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN DWORD PropType,
    OUT DWORD *pcbProp,
    IN OUT DWORD *pcbbuf,
    OUT BYTE **ppbbuf)
{
    HRESULT hr;
    
    EnterCriticalSection(&g_DBCriticalSection);
    if (cuDBIsShutDownInProgress())
    {
	hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	_JumpError(hr, error, "cuDBIsShutDownInProgress");
    }

    // if we have a pre-allocated buffer, use it
    *pcbProp = *pcbbuf;     // try our current buffer

    hr = prow->GetProperty(pwszPropName, PropType, pcbProp, *ppbbuf);
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
	{
	    *pcbProp = 0;
	    _JumpError2(
		    hr,
		    error,
		    "prow->GetProperty",
		    CERTSRV_E_PROPERTY_EMPTY);
	}

	// else HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW, go through realloc
    }
    else if (NULL != *ppbbuf)
    {
	// done if we passed non-null and got back S_OK

	goto error;
    }

    hr = GrowBuffer(*pcbProp, pcbbuf, ppbbuf);
    _JumpIfError(hr, error, "GrowBuffer");

    hr = prow->GetProperty(pwszPropName, PropType, pcbProp, *ppbbuf);
    if (S_OK != hr)
    {
	*pcbProp = 0;
	_JumpError(hr, error, "prow->GetProperty");
    }

error:
    LeaveCriticalSection(&g_DBCriticalSection);
    return(hr);
}


HRESULT
RedDBGetPropertyWAndReAlloc(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    OUT DWORD *pcbProp,
    IN OUT DWORD *pcbbuf,
    OUT BYTE **ppbbuf)
{
    HRESULT hr;
    
    // if we have a pre-allocated buffer, use it
    *pcbProp = *pcbbuf;     // try our current buffer

    hr = RedDBGetPropertyW(ReqId, pwszPropName, dwFlags, pcbProp, *ppbbuf);
    if (S_OK != hr)
    {
	if (ERROR_MORE_DATA != hr)
	{
	    *pcbProp = 0;
	    _JumpIfError3(
		    hr,
		    error,
		    "RedDBGetPropertyW",
		    ERROR_NO_MORE_ITEMS,
		    CERTSRV_E_PROPERTY_EMPTY);
	}

	// else ERROR_MORE_DATA: buffer not big enough, go through realloc
    }
    else if (NULL != *ppbbuf)
    {
	// done if we passed non-null and got back S_OK

	goto error;
    }

    hr = GrowBuffer(*pcbProp, pcbbuf, ppbbuf);
    _JumpIfError(hr, error, "GrowBuffer");

    hr = RedDBGetPropertyW(ReqId, pwszPropName, dwFlags, pcbProp, *ppbbuf);
    if (S_OK != hr)
    {
	*pcbProp = 0;
	_JumpError(hr, error, "RedDBGetPropertyW");
    }

error:
    return(hr);
}


#define ANCIENT_CR_DISP_INCOMPLETE	0x00000000  // request did not complete
#define ANCIENT_CR_DISP_ERROR		0x00000001  // request failed
#define ANCIENT_CR_DISP_DENIED		0x00000002  // request denied
#define ANCIENT_CR_DISP_ISSUED		0x00000003  // cert issued
#define ANCIENT_CR_DISP_ISSUED_OUT_OF_BAND 0x00000004  // cert issued separately
#define ANCIENT_CR_DISP_UNDER_SUBMISSION 0x00000005  // taken under submission
#define ANCIENT_CR_DISP_REVOKED          0x00000006 // revoked

HRESULT
FixupRequestDispositionProperty(
    IN OUT DWORD *pdwDisposition,
    IN DWORD cbDisposition)
{
    HRESULT hr = S_OK;
    DWORD dwOldDisposition = *pdwDisposition;
    DWORD dwNewDisposition;

    CSASSERT(sizeof(DWORD) == cbDisposition);
    if (sizeof(DWORD) != cbDisposition)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cbDisposition");
    }

    switch (dwOldDisposition)
    {
	case ANCIENT_CR_DISP_ERROR:
	case ANCIENT_CR_DISP_INCOMPLETE:
	    dwNewDisposition = DB_DISP_ERROR;
	    break;

	case ANCIENT_CR_DISP_DENIED:
	    dwNewDisposition = DB_DISP_DENIED;
	    break;

	case ANCIENT_CR_DISP_ISSUED:
	case ANCIENT_CR_DISP_ISSUED_OUT_OF_BAND:
	    dwNewDisposition = DB_DISP_ISSUED;
	    break;

	case ANCIENT_CR_DISP_UNDER_SUBMISSION:
	    dwNewDisposition = DB_DISP_PENDING;
	    break;

        case ANCIENT_CR_DISP_REVOKED:
            dwNewDisposition = DB_DISP_REVOKED;
            break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwOldDisposition");
	    break;
    }

    // make assignment since all went well
    *pdwDisposition = dwNewDisposition;

error:
    return(hr);
}


typedef struct _DBTABLE_ENTRY
{
    LPCWSTR            pwszTable;
    DBTABLE_RED const *rgTable;
    DWORD              dwTableType;
} DBTABLE_ENTRY;

DBTABLE_ENTRY dbTables[] = 
{
    { L"Request", db_adtRequests, PROPTABLE_REQUEST },
    { L"Certificate", db_adtCertificates, PROPTABLE_CERTIFICATE },
};


HRESULT
SetDBProperty(
    IN DWORD RequestId,
    IN ICertDBRow *prow,
    IN WCHAR const *pwszPropName,
    IN DWORD PropType,
    IN DWORD cbProp,
    IN BYTE const *pbProp)
{
    HRESULT hr;
    
    EnterCriticalSection(&g_DBCriticalSection);
    if (cuDBIsShutDownInProgress())
    {
	hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	_JumpError(hr, error, "cuDBIsShutDownInProgress");
    }

    hr = prow->SetProperty(pwszPropName, PropType, cbProp, pbProp);
    _JumpIfError(hr, error, "prow->SetProperty");

error:
    LeaveCriticalSection(&g_DBCriticalSection);
    return(hr);
}


#define RR_READONLY	0
#define RR_COMMIT	1
#define RR_ABORT	2

HRESULT
ReleaseDBRow(
    IN OUT ICertDBRow *prow,
    IN DWORD State)
{
    HRESULT hr = S_OK;
    
    if (NULL != prow)
    {
	EnterCriticalSection(&g_DBCriticalSection);

	if (!cuDBIsShutDownInProgress())
	{
	    if (RR_READONLY != State)
	    {
		hr = prow->CommitTransaction(RR_COMMIT == State);
		_PrintIfError(hr, "CommitTransaction");
	    }
	    prow->Release();
	}
	LeaveCriticalSection(&g_DBCriticalSection);
    }
    return(hr);
}


// convert one certificate or request table column

HRESULT
ConvertDBColumnName(
    IN DWORD RequestId,
    IN ICertDB *pdb,
    IN ICertDBRow *prow,
    IN DBTABLE_ENTRY const *pdbte,
    IN DBTABLE_RED const *pdbcol,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    DWORD dwPropType;
    BYTE const *pbProp;
    DWORD cbProp;

    hr = TranslateToPropType(pdbcol->wCType, &dwPropType);
    _JumpIfError(hr, error, "TranslateToPropType");

    // _NOT_ IssuerNameID

    WCHAR wszFullPropName[MAX_PATH];
    wcscpy(wszFullPropName, g_wszPropSubjectDot);
    wcscat(wszFullPropName, pdbcol->pwszPropName);

    // table: "Requests" or "Certificates" ? 
    hr = RedDBGetPropertyWAndReAlloc(
			    RequestId,
			    wszFullPropName,
			    dwPropType | pdbte->dwTableType,
			    &cbProp,
			    pcbbuf,
			    ppbbuf);
    if (hr != S_OK)
    {
	if (CERTSRV_E_PROPERTY_EMPTY == hr || ERROR_NO_MORE_ITEMS == hr)
	{
	    goto error;
	}
	_JumpIfError(hr, error, "RedDBGetPropertyWAndReAlloc");
    }
    pbProp = *ppbbuf;

    hr = PrintProperty(
		RequestId,
		L"\tNames",
		wszFullPropName,
		dwPropType,
		pbProp,
		cbProp);
    _JumpIfError(hr, error, "PrintProperty");

    // Separate names table has been removed in new db.  Now, names live within
    // each table (Certificates, Requests)

    hr = SetDBProperty(
		RequestId,
		prow,
		pdbcol->pwszPropName,
		dwPropType | pdbte->dwTableType, 
		cbProp,
		pbProp);
    _JumpIfError(hr, error, "SetDBProperty");

error:
    return(hr);
}


// convert one certificate or request table column

HRESULT
ConvertDBColumn(
    IN DWORD RequestId,
    IN ICertDB *pdb,
    IN ICertDBRow *prow,
    IN DBTABLE_ENTRY const *pdbte,
    IN DBTABLE_RED const *pdbcol,
    IN OUT BOOL *pfRevoked,
    IN OUT BOOL *pfReasonUnspecified,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    DWORD i;
    DWORD dwPropType;
    BYTE const *pbProp;
    DWORD cbProp;
    WCHAR wszFullTableCol[MAX_PATH];
    BOOL fSetProperty = TRUE;

    hr = TranslateToPropType(pdbcol->wCType, &dwPropType);
    _JumpIfError(hr, error, "TranslateToPropType");

    hr = RedDBGetPropertyWAndReAlloc(
				RequestId,
				pdbcol->pwszPropName,
				dwPropType | pdbte->dwTableType,
				&cbProp,
				pcbbuf,
				ppbbuf);
    if (hr != S_OK)
    {
	if (CERTSRV_E_PROPERTY_EMPTY == hr || ERROR_NO_MORE_ITEMS == hr)
	{
	    goto error;
	}
	_JumpError(hr, error, "RedDBGetPropertyWAndReAlloc");
    }
    pbProp = *ppbbuf;

    // special case: do lookup into names table
    CSASSERT(0 == lstrcmpi(g_wszPropRequestSubjectNameID, g_wszPropCertificateSubjectNameID));

    if (0 == lstrcmpi(g_wszPropRequestSubjectNameID, pdbcol->pwszPropName))
    {
	DWORD NameId = *(DWORD *) pbProp;
	DBTABLE_RED const *pdbcolT;

	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	    wprintf(myLoadResourceString(IDS_RED_BEGIN_NAMES), RequestId, NameId);
	    wprintf(wszNewLine);
	}
	for (pdbcolT = db_adtNames; NULL != pdbcolT->pwszPropName; pdbcolT++)
	{
	    hr = ConvertDBColumnName(
				RequestId,
				pdb,
				prow,
				pdbte,
				pdbcolT,
				pcbbuf,
				ppbbuf);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		continue;		// skip empty name columns
	    }
	    if (ERROR_NO_MORE_ITEMS == hr)
	    {
		break;			// done
	    }
	    _JumpIfError(hr, error, "ConvertDBColumnName");
	}
	if (g_fVerbose)
	{
	    wprintf(myLoadResourceString(IDS_RED_END_NAMES), RequestId, NameId);
	    wprintf(wszNewLine);
	    wprintf(wszNewLine);
	}
    }
    else
    {
	hr = PrintProperty(
		    RequestId,
		    pdbte->pwszTable,
		    pdbcol->pwszPropName,
		    dwPropType,
		    pbProp,
		    cbProp);
	_JumpIfError(hr, error, "PrintProperty");

	if (0 == lstrcmpi(
		    pdbcol->pwszPropName,
		    g_wszPropRequestDisposition))
	{
	    hr = FixupRequestDispositionProperty(
					    (DWORD *) pbProp,
					    cbProp);
	    _JumpIfError(hr, error, "FixupRequestDispositionProperty");
	}
	else if (0 == lstrcmpi(
			pdbcol->pwszPropName,
			g_wszPropRequestRevokedWhen))
	{
	    if (NULL != pbProp && 0 != cbProp)
	    {
		*pfRevoked = TRUE;
	    }
	}
	else if (0 == lstrcmpi(
			pdbcol->pwszPropName,
			g_wszPropRequestRevokedReason))
	{
	    if (NULL != pbProp && sizeof(DWORD) == cbProp)
	    {
		if (CRL_REASON_UNSPECIFIED == *(DWORD *) pbProp)
		{
		    *pfReasonUnspecified = TRUE;
		    fSetProperty = FALSE;
		}
	    }
	}


	// don't try and save AutoIncremented (first) field: RequestID

	if (fSetProperty &&
	    (pdbcol != pdbte->rgTable ||
	     0 != lstrcmpi(pdbcol->pwszPropName, g_wszPropRequestRequestID)))
	{
	    hr = SetDBProperty(
			RequestId,
			prow,
			pdbcol->pwszPropName,
			dwPropType | pdbte->dwTableType, 
			cbProp,
			pbProp);
	    _JumpIfError(hr, error, "SetDBProperty");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


// walk through columns in certificate or request table and convert them

HRESULT
ConvertDBTable(
    IN DWORD RequestId,
    IN ICertDB *pdb,
    IN ICertDBRow *prow,
    IN DBTABLE_ENTRY const *pdbte,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    DBTABLE_RED const *pdbcol;

    BOOL fRevoked = FALSE;
    BOOL fReasonUnspecified = FALSE;

    for (pdbcol = pdbte->rgTable; NULL != pdbcol->pwszPropName; pdbcol++)
    {
	    hr = ConvertDBColumn(
			    RequestId,
			    pdb,
			    prow,
			    pdbte,
			    pdbcol,
			    &fRevoked,
			    &fReasonUnspecified,
			    pcbbuf,
			    ppbbuf);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
	        continue;			// skip empty name columns
	    }
	    _JumpIfError2(hr, error, "ConvertDBColumn", ERROR_NO_MORE_ITEMS);
    }

    // CertSrv1.0 had a funny way of revoking: it set the RevokedWhen 
    // field, but didn't update the Request Disposition field.

    // Thus, after we walk through all columns, if we detected a RevokedWhen 
    // field, we go back and slam the g_wszPropRequestDisposition field with
    // DB_DISP_REVOKED.

    if (fRevoked)   
    {
        DWORD dwRevoked = DB_DISP_REVOKED;

	hr = SetDBProperty(
		    RequestId,
		    prow,
		    g_wszPropRequestDisposition,
		    PROPTYPE_LONG | pdbte->dwTableType, 
		    sizeof(dwRevoked),
		    (PBYTE)&dwRevoked);
	_JumpIfError(hr, error, "SetDBProperty DB_DISP_REVOKED");

	if (fReasonUnspecified)
	{
	    DWORD dwReason = CRL_REASON_UNSPECIFIED;

	    hr = SetDBProperty(
			RequestId,
			prow,
			g_wszPropRequestRevokedReason,
			PROPTYPE_LONG | pdbte->dwTableType, 
			sizeof(dwReason),
			(BYTE *) &dwReason);
	    _JumpIfError(hr, error, "SetDBProperty CRL_REASON_UNSPECIFIED");
	}
    }

    hr = S_OK;

error:
    return(hr);
}


// convert extensions for this request

HRESULT
ConvertDBExtensions(
    IN DWORD RequestId,
    IN ICertDB *pdb,
    IN ICertDBRow *prow,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    HANDLE hEnum = NULL;
    WCHAR wszPropName[MAX_PATH + 1];
    DWORD cwcPropName;
    DWORD dwPropType;
    DWORD dwExtFlags;
    BYTE const *pbProp;
    DWORD cbProp;

    hr = RedDBEnumerateSetup(RequestId, FALSE, &hEnum);
    _JumpIfError(hr, error, "RedDBEnumerateSetup");

    while (TRUE)
    {
	cwcPropName = ARRAYSIZE(wszPropName) - 1;
	hr = RedDBEnumerate(hEnum, &cwcPropName, wszPropName);
	if (S_OK != hr)
	{
	    break;
	}
	wszPropName[cwcPropName] = L'\0';	// terminate name

	hr = TranslateToPropType(db_dtExtensionFlags.wCType, &dwPropType);
	_JumpIfError(hr, error, "TranslateToPropType");

	hr = RedDBGetPropertyWAndReAlloc(
				RequestId,
				wszPropName,
				dwPropType |
				    PROPTABLE_EXTENSION |
				    PROPTABLE_EXTENSIONFLAGS,
				&cbProp,
				pcbbuf,
				ppbbuf);
	if (hr == CERTSRV_E_PROPERTY_EMPTY)
	{
	    // ext flags entry does not exist: not fatal
	    cbProp = 0;
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "RedDBGetPropertyWAndReAlloc");

	pbProp = *ppbbuf;

	CSASSERT(0 == cbProp || sizeof(DWORD) == cbProp);
	dwExtFlags = 0;		// default to 0
	if (cbProp == sizeof(DWORD))
	{
	    dwExtFlags = *(DWORD *) pbProp;
	}

	// extension flags
	hr = PrintProperty(
		    RequestId,
		    L"Extension <Flags>",
		    wszPropName,
		    dwPropType,
		    (BYTE *) &dwExtFlags,
		    cbProp);
	_JumpIfError(hr, error, "PrintProperty");

	hr = TranslateToPropType(db_dtExtensionValue.wCType, &dwPropType);
	_JumpIfError(hr, error, "TranslateToPropType");

	hr = RedDBGetPropertyWAndReAlloc(
				    RequestId,
				    wszPropName,
				    dwPropType |
					PROPTABLE_EXTENSION |
					PROPTABLE_EXTENSIONVALUE,
				    &cbProp,
				    pcbbuf,
				    ppbbuf);
	if (hr == CERTSRV_E_PROPERTY_EMPTY)
	{
	    // ext value entry does not exist: not fatal
	    cbProp = 0;
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "RedDBGetPropertyWAndReAlloc");

	pbProp = *ppbbuf;

	// extension value
	hr = PrintProperty(
		    RequestId,
		    L"Extension <Value>",
		    wszPropName,
		    dwPropType,
		    pbProp,
		    cbProp);
	_JumpIfError(hr, error, "PrintProperty");

	hr = prow->SetExtension(wszPropName, dwExtFlags, cbProp, pbProp);
	_JumpIfError(hr, error, "SetExtension");
    }
    hr = S_OK;

error:
    if (NULL != hEnum)
    {
	hr = RedDBEnumerateClose(hEnum);
	_JumpIfError(hr, error, "RedDBEnumerateClose");
    }
    return(hr);
}


// convert request attributes for this request

HRESULT
ConvertDBAttributes(
    IN DWORD RequestId,
    IN ICertDB *pdb,
    IN ICertDBRow *prow,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    HANDLE hEnum = NULL;
    WCHAR wszPropName[MAX_PATH + 1];
    DWORD cwcPropName;
    DWORD dwPropType;
    BYTE const *pbProp;
    DWORD cbProp;

    hr = RedDBEnumerateSetup(RequestId, TRUE, &hEnum);
    _JumpIfError(hr, error, "RedDBEnumerateSetup");

    while (TRUE)
    {
	cwcPropName = ARRAYSIZE(wszPropName) - 1;
	hr = RedDBEnumerate(hEnum, &cwcPropName, wszPropName);
	if (S_OK != hr)
	{
	    break;
	}
	wszPropName[cwcPropName] = L'\0';	// terminate name

	hr = TranslateToPropType(db_attrib.wCType, &dwPropType);
	_JumpIfError(hr, error, "TranslateToPropType");

	hr = RedDBGetPropertyWAndReAlloc(
				    RequestId,
				    wszPropName,
				    dwPropType | PROPTABLE_ATTRIBUTE,
				    &cbProp,
				    pcbbuf,
				    ppbbuf);
	if (hr == CERTSRV_E_PROPERTY_EMPTY)
	{
	    // attr entry does not exist: not fatal
	    cbProp = 0;
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "RedDBGetPropertyWAndReAlloc");

	pbProp = *ppbbuf;

	// get attribute 
	hr = PrintProperty(
		    RequestId,
		    L"Attribute",
		    wszPropName,
		    dwPropType,
		    pbProp,
		    cbProp);
	_JumpIfError(hr, error, "PrintProperty");

	hr = SetDBProperty(
		    RequestId,
		    prow,
		    wszPropName,
		    dwPropType | PROPTABLE_ATTRIBUTE, 
		    cbProp,
		    pbProp);
	_JumpIfError(hr, error, "SetDBProperty");
    }
    hr = S_OK;

error:
    if (NULL != hEnum)
    {
	hr = RedDBEnumerateClose(hEnum);
	_JumpIfError(hr, error, "RedDBEnumerateClose");
    }
    return(hr);
}


HRESULT
VerifyRedDBCertificate(
    DWORD RequestId,
    IN CERT_INFO const *pCACertInfo,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    DWORD cbCert;
    DWORD dw;
    
    hr = RedDBGetPropertyWAndReAlloc(
				RequestId,
				g_wszPropRawCertificate,
				PROPTYPE_BINARY | PROPTABLE_CERTIFICATE,
				&cbCert,
				pcbbuf,
				ppbbuf);
    _JumpIfError(hr, error, "RedDBGetPropertyWAndReAlloc");

    if (!CryptVerifyCertificateSignature(
			    NULL,
			    X509_ASN_ENCODING,
			    *ppbbuf,
			    cbCert,
			    const_cast<CERT_PUBLIC_KEY_INFO *>(
				&pCACertInfo->SubjectPublicKeyInfo)))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptVerifyCertificateSignature");
    }

error:
    if (1 < g_fForce)
    {
	hr = S_OK;
    }
    return(hr);
}


// walk through columns in certificate request tables and convert them.
// walk through related extensions and attributes and convert them.

HRESULT
ConvertDB(
    IN ICertDB *pdb,
    IN CERT_INFO const *pCACertInfo,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    DWORD RequestId;
    DWORD RequestIdNew;
    ICertDBRow *prow = NULL;
    DWORD i;
    DWORD cbProp;
    WCHAR wszSerial[15];
    WCHAR *pwszSerial = NULL;
    DWORD dwStart;
    DWORD dwEnd;
    WCHAR wszRowId[MAX_PATH];

    for (RequestId = 1; ; RequestId++)
    {
	// If the RequestId doesn't exist in the old database, we're done!
	
	hr = RedDBGetPropertyWAndReAlloc(
				    RequestId,
				    g_wszPropRequestRequestID,
				    PROPTYPE_LONG | PROPTABLE_REQUEST,
				    &cbProp,
				    pcbbuf,
				    ppbbuf);
	if (ERROR_NO_MORE_ITEMS == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "RedDBGetPropertyWAndReAlloc");

	CSASSERT(sizeof(DWORD) == cbProp);
	CSASSERT(*(DWORD const *) *ppbbuf == RequestId);

	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	}
	wsprintf(wszRowId, myLoadResourceString(IDS_RED_ROWID), RequestId);
	_cprintf("\r%ws\r", wszRowId);

	if (g_fVerbose)
	{
	    wprintf(L"----------------------------------------------------------------\n");
	}

	if (NULL != pwszSerial && wszSerial != pwszSerial)
	{
	    LocalFree(pwszSerial);
	    pwszSerial = NULL;
	}

	// Fetch old SerialNumber.  Generate one for failed requests.

	hr = RedDBGetPropertyWAndReAlloc(
				    RequestId,
				    g_wszPropCertificateSerialNumber,
				    PROPTYPE_STRING | PROPTABLE_CERTIFICATE,
				    &cbProp,
				    pcbbuf,
				    ppbbuf);
	if (S_OK != hr)
	{
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		_JumpError(hr, error, "RedDBGetPropertyWAndReAlloc");
	    }
	    wsprintf(wszSerial, L"ConvertMDB%04x", RequestId);
	    CSASSERT(wcslen(wszSerial) < ARRAYSIZE(wszSerial));
	    pwszSerial = wszSerial;
	}
	else
	{
	    hr = myDupString((WCHAR const *) *ppbbuf, &pwszSerial);
	    _JumpIfError(hr, error, "myDupString");
	}

	// If old SerialNumber already exists in new database, skip this row

        hr = pdb->OpenRow(TRUE, 0, pwszSerial, &prow);
	if (S_OK == hr)
	{
	    ReleaseDBRow(prow, RR_READONLY);
	    prow = NULL;
	    wprintf(myLoadResourceString(IDS_RED_SKIP_DUP), RequestId, pwszSerial);
	    wprintf(wszNewLine);
	    g_crowSkipDuplicate++;
	    continue;
	}

	hr = VerifyRedDBCertificate(RequestId, pCACertInfo, pcbbuf, ppbbuf);
	if (S_OK != hr && CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    wprintf(myLoadResourceString(IDS_RED_SKIP_BADCA), RequestId, pwszSerial);
	    g_crowSkipWrongCA++;
	    continue;
	}

        // RequestId 0, pwszSerialNumber NULL --> create new row

        hr = pdb->OpenRow(FALSE, 0, NULL, &prow);
        _JumpIfError(hr, error, "OpenRow");

	prow->GetRowId(&RequestIdNew);

	if (g_fVerbose)
	{
	    wprintf(
		myLoadResourceString(IDS_RED_ROW_MAP),
		RequestId,
		RequestIdNew);
	    wprintf(wszNewLine);
	}

	// Set SerialNumber in new database only if we generated one.

	if (wszSerial == pwszSerial)
	{
	    hr = SetDBProperty(
			RequestId,
			prow,
			g_wszPropCertificateSerialNumber,
			PROPTYPE_STRING |
			    PROPCALLER_ADMIN |
			    PROPTABLE_CERTIFICATE,
			wcslen(pwszSerial) * sizeof(WCHAR),
			(BYTE *) pwszSerial);
	    _JumpIfError(hr, error, "SetDBProperty");
	}

	// convert columns in certificate & request tables

        for (i = 0; i < ARRAYSIZE(dbTables); i++)
        {
	    hr = ConvertDBTable(
			    RequestId,
			    pdb,
			    prow,
			    &dbTables[i],
			    pcbbuf,
			    ppbbuf);
	    _JumpIfError(hr, error, "ConvertDBTable");
        }

	hr = ConvertDBExtensions(RequestId, pdb, prow, pcbbuf, ppbbuf);
	_JumpIfError(hr, error, "ConvertDBExtensions");

	hr = ConvertDBAttributes(RequestId, pdb, prow, pcbbuf, ppbbuf);
	_JumpIfError(hr, error, "ConvertDBAttributes");

	hr = ReleaseDBRow(prow, RR_COMMIT);
	prow = NULL;
        if (myJetHResult(JET_errKeyDuplicate) == hr)
        {
            CSASSERT(!"Discarding duplicate entry");
	    wprintf(myLoadResourceString(IDS_RED_SKIP_DUP), RequestId, pwszSerial);
	    wprintf(wszNewLine);
            continue;
        }
        _JumpIfError(hr, error, "ReleaseDBRow");

	g_crowConvert++;
    }
    _cprintf("\n");
    hr = S_OK;

error:
    if (NULL != pwszSerial && wszSerial != pwszSerial)
    {
	LocalFree(pwszSerial);
    }
    ReleaseDBRow(prow, RR_ABORT);
    return(hr);
}


HRESULT
LoadCACertFromDB(
    IN ICertDB *pdb,
    OUT BYTE **ppbCACert,
    OUT DWORD *pcbCACert,
    OUT CERT_INFO **ppCACertInfo,
    IN OUT DWORD *pcbbuf,
    IN OUT BYTE **ppbbuf)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD cbCertInfo;

    *ppbCACert = NULL;
    *ppCACertInfo = NULL;
    
    hr = pdb->OpenRow( 
		TRUE,	// fReadOnly
		1,	// ReqId
		NULL,   // pwszSerialNumber
		&prow);
    _JumpIfError(hr, error, "OpenRow");

    hr = GetDBPropertyAndReAlloc( 
			    prow,
			    g_wszPropRawCertificate,
			    PROPTYPE_BINARY |
				PROPCALLER_ADMIN |
				PROPTABLE_CERTIFICATE,
			    pcbCACert,
			    pcbbuf,
			    ppbbuf);
    _JumpIfError(hr, error, "GetDBPropertyAndReAlloc");

    *ppbCACert = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbCACert);
    if (NULL == *ppbCACert)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppbCACert, *ppbbuf, *pcbCACert);

    // Decode certificate

    cbCertInfo = 0;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    *ppbCACert,
		    *pcbCACert,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppCACertInfo,
		    &cbCertInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

error:
    ReleaseDBRow(prow, RR_READONLY);
    return(hr);
}


HRESULT
RedDBInit(
    OUT WCHAR **ppwszAuthority)
{
    HRESULT hr;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszAuthority = NULL;

    __try
    {
        InitializeCriticalSection(&g_DBEnumCriticalSection);
        g_fDBEnumCSInit = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    InitializeListHead(&g_DBEnumHandleList);

    hr = mySplitConfigString(g_pwszConfig, &pwszServer, &pwszAuthority);
    _JumpIfError(hr, error, "mySplitConfigString");

    if (NULL == pwszAuthority || L'\0' == *pwszAuthority)
    {
	wprintf(L"%ws\n", myLoadResourceString(IDS_INCOMPLETE_CONFIG)); // "Config string must include Authority name"
	hr = E_INVALIDARG;
	_JumpError(hr, error, "empty pwszAuthority");
    }

    // open old DB
    hr = RedDBOpen(pwszAuthority);     
    if (S_OK != hr)
    {
	wprintf(L"%ws\n", myLoadResourceString(IDS_RED_CANNOT_OPEN_MDB)); // "Cannot open old MDB Database...."
        _JumpError(hr, error, "RedDBOpen");
    }
    *ppwszAuthority = pwszAuthority;
    pwszAuthority = NULL;
    CSASSERT(S_OK == hr);

error:
    if (NULL != pwszServer)
    {
        LocalFree(pwszServer);
    }
    if (NULL != pwszAuthority)
    {
        LocalFree(pwszAuthority);
    }
    return(hr);
}


HRESULT
verbConvertMDB(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszAuthority = NULL;
    BOOL fRedDBOpened = FALSE;
    DWORD i;
    ICertDB *pdb = NULL;
    BYTE *pbCACert = NULL;
    DWORD cbCACert;
    CERT_INFO *pCACertInfo = NULL;
    DWORD cbbuf = 0;
    BYTE *pbbuf = NULL;

    // open old DB

    hr = RedDBInit(&pwszAuthority);
    _JumpIfError(hr, error, "RedDBInit");

    fRedDBOpened = TRUE;

    // new DB

    hr = cuDBOpen(pwszAuthority, FALSE, &pdb);
    _JumpIfError(hr, error, "cuDBOpen (new)");

    hr = LoadCACertFromDB(
			pdb,
			&pbCACert,
			&cbCACert,
			&pCACertInfo,
			&cbbuf,
			&pbbuf);
    _JumpIfError(hr, error, "LoadCACertFromDB");

    hr = ConvertDB(pdb, pCACertInfo, &cbbuf, &pbbuf);
    _JumpIfError(hr, error, "ConvertDB");

error:
    if (NULL != pwszAuthority)
    {
        LocalFree(pwszAuthority);
    }
    if (NULL != pCACertInfo)
    {
        LocalFree(pCACertInfo);
    }
    if (NULL != pbCACert)
    {
        LocalFree(pbCACert);
    }
    if (NULL != pbbuf)
    {
        LocalFree(pbbuf);
    }

    // Take critical section to make sure we wait for CTL-C DB shutdown.
    
    EnterCriticalSection(&g_DBCriticalSection);
    if (cuDBIsShutDownInProgress())
    {
	if (myJetHResult(JET_errTermInProgress) == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	}
    }
    LeaveCriticalSection(&g_DBCriticalSection);
    cuDBAbortShutDown(0);

    // old DB
    if (fRedDBOpened)
    {
        RedDBShutDown();
    }
    if (0 != g_crowSkipDuplicate)
    {
	wprintf(myLoadResourceString(IDS_RED_CROW_DUP), g_crowSkipDuplicate);
	wprintf(wszNewLine);
    }
    if (0 != g_crowSkipWrongCA)
    {
	wprintf(myLoadResourceString(IDS_RED_CROW_BADCA), g_crowSkipWrongCA);
	wprintf(wszNewLine);
    }
    wprintf(myLoadResourceString(IDS_RED_CROW_CONVERT), g_crowConvert);
    wprintf(wszNewLine);

    return(hr);
}


HRESULT
RegDBGetLongProperty(
    IN LONG RequestId,
    IN WCHAR const *pwszPropName,
    IN DWORD dwTable,
    OUT LONG *pLong)
{
    HRESULT hr;
    DWORD cbProp;
    
    cbProp = sizeof(*pLong);
    hr = RedDBGetPropertyW(
		    RequestId,
		    pwszPropName,
		    PROPTYPE_LONG | dwTable,
		    &cbProp,
		    (BYTE *) pLong);
    _JumpIfError(hr, error, "RedDBGetPropertyW");

    CSASSERT(sizeof(*pLong) == cbProp);

error:
    return(hr);
}


HRESULT
verbExtractMDB(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszAuthority = NULL;
    BOOL fRedDBOpened = FALSE;
    DWORD cbbuf = 0;
    BYTE *pbbuf = NULL;
    LONG RequestId;
    LONG l;
    BOOL fEnumerate;
    DWORD cbProp;

    hr = cuGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "cuGetLong");

    if (0 > RequestId)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad RequestId arg");
    }

    hr = RedDBInit(&pwszAuthority);
    _JumpIfError(hr, error, "RedDBInit");

    fRedDBOpened = TRUE;

    fEnumerate = FALSE;
    if (0 == RequestId)
    {
	RequestId = 1;
	fEnumerate = TRUE;
    }
    for ( ; ; RequestId++)
    {
	hr = RegDBGetLongProperty(
			    RequestId,
			    g_wszPropRequestRequestID,
			    PROPTABLE_REQUEST,
			    &l);
	_JumpIfError(hr, error, "RegDBGetLongProperty");

	if (l != RequestId)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "RequestId mismatch");
	}

	hr = RegDBGetLongProperty(
			    RequestId,
			    g_wszPropRequestDisposition,
			    PROPTABLE_REQUEST,
			    &l);
	_JumpIfError(hr, error, "RegDBGetLongProperty");

	if (ANCIENT_CR_DISP_ISSUED == l ||
	    ANCIENT_CR_DISP_ISSUED_OUT_OF_BAND == l ||
	    ANCIENT_CR_DISP_REVOKED == l)
	{
	    break;		// found an issued cert!
	}

	if (!fEnumerate)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "no such cert");
	}
    }

    hr = RedDBGetPropertyWAndReAlloc(
			    RequestId,
			    g_wszPropRawCertificate,
			    PROPTYPE_BINARY | PROPTABLE_CERTIFICATE,
			    &cbProp,
			    &cbbuf,
			    &pbbuf);
    _JumpIfErrorStr(
		hr,
		error,
		"RedDBGetPropertyWAndReAlloc",
		g_wszPropRawCertificate);

    if (NULL != pwszfnOut)
    {
	hr = EncodeToFileW(
		    pwszfnOut,
		    pbbuf,
		    cbProp,
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }
    if (g_fVerbose || NULL == pwszfnOut)
    {
	hr = cuDumpAsnBinary(pbbuf, cbProp, MAXDWORD);
	_JumpIfError(hr, error, "cuDumpAsnBinary");
    }

error:
    if (NULL != pwszAuthority)
    {
        LocalFree(pwszAuthority);
    }
    if (NULL != pbbuf)
    {
        LocalFree(pbbuf);
    }
    if (fRedDBOpened)
    {
        RedDBShutDown();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\dbcore.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbcore.cpp
//
// Contents:    Cert Server Database conversion
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certdb2.h"
#include "csprop2.h"
#include "dbcore.h"

//+--------------------------------------------------------------------------
// Name properties:

WCHAR const g_wszPropDistinguishedName[] = wszPROPDISTINGUISHEDNAME;
WCHAR const g_wszPropRawName[] = wszPROPRAWNAME;
WCHAR const g_wszPropNameType[] = wszPROPNAMETYPE;

WCHAR const g_wszPropCountry[] = wszPROPCOUNTRY;
WCHAR const g_wszPropOrganization[] = wszPROPORGANIZATION;
WCHAR const g_wszPropOrgUnit[] = wszPROPORGUNIT;
WCHAR const g_wszPropCommonName[] = wszPROPCOMMONNAME;
WCHAR const g_wszPropLocality[] = wszPROPLOCALITY;
WCHAR const g_wszPropState[] = wszPROPSTATE;
WCHAR const g_wszPropTitle[] = wszPROPTITLE;
WCHAR const g_wszPropGivenName[] = wszPROPGIVENNAME;
WCHAR const g_wszPropInitials[] = wszPROPINITIALS;
WCHAR const g_wszPropSurName[] = wszPROPSURNAME;
WCHAR const g_wszPropDomainComponent[] = wszPROPDOMAINCOMPONENT;
WCHAR const g_wszPropEMail[] = wszPROPEMAIL;
WCHAR const g_wszPropStreetAddress[] = wszPROPSTREETADDRESS;


//+--------------------------------------------------------------------------
// Subject Name properties:

WCHAR const g_wszPropSubjectDot[] = wszPROPSUBJECTDOT;
WCHAR const g_wszPropSubjectDistinguishedName[] = wszPROPSUBJECTDISTINGUISHEDNAME;
WCHAR const g_wszPropSubjectRawName[] = wszPROPSUBJECTRAWNAME;
WCHAR const g_wszPropSubjectNameType[] = wszPROPSUBJECTNAMETYPE;

WCHAR const g_wszPropSubjectCountry[] = wszPROPSUBJECTCOUNTRY;
WCHAR const g_wszPropSubjectOrganization[] = wszPROPSUBJECTORGANIZATION;
WCHAR const g_wszPropSubjectOrgUnit[] = wszPROPSUBJECTORGUNIT;
WCHAR const g_wszPropSubjectCommonName[] = wszPROPSUBJECTCOMMONNAME;

WCHAR const g_wszPropSubjectLocality[] = wszPROPSUBJECTLOCALITY;
WCHAR const g_wszPropSubjectState[] = wszPROPSUBJECTSTATE;
WCHAR const g_wszPropSubjectTitle[] = wszPROPSUBJECTTITLE;
WCHAR const g_wszPropSubjectGivenName[] = wszPROPSUBJECTGIVENNAME;
WCHAR const g_wszPropSubjectInitials[] = wszPROPSUBJECTINITIALS;
WCHAR const g_wszPropSubjectSurName[] = wszPROPSUBJECTSURNAME;
WCHAR const g_wszPropSubjectDomainComponent[] = wszPROPSUBJECTDOMAINCOMPONENT;
WCHAR const g_wszPropSubjectEMail[] = wszPROPSUBJECTEMAIL;
//WCHAR const g_wszPropSubjectStreetAddress[] = wszPROPSUBJECTSTREETADDRESS;


//+--------------------------------------------------------------------------
// Request properties:

WCHAR const g_wszPropRequestRequestID[] = wszPROPREQUESTREQUESTID;
WCHAR const g_wszPropRequestRawRequest[] = wszPROPREQUESTRAWREQUEST;
WCHAR const g_wszPropRequestAttributes[] = wszPROPREQUESTATTRIBUTES;
WCHAR const g_wszPropRequestType[] = wszPROPREQUESTTYPE;
WCHAR const g_wszPropRequestFlags[] = wszPROPREQUESTFLAGS;
WCHAR const g_wszPropRequestStatus[] = wszPROPREQUESTSTATUS;
WCHAR const g_wszPropRequestStatusCode[] = wszPROPREQUESTSTATUSCODE;
WCHAR const g_wszPropRequestDisposition[] = wszPROPREQUESTDISPOSITION;
WCHAR const g_wszPropRequestDispositionMessage[] = wszPROPREQUESTDISPOSITIONMESSAGE;
WCHAR const g_wszPropRequestSubmittedWhen[] = wszPROPREQUESTSUBMITTEDWHEN;
WCHAR const g_wszPropRequestResolvedWhen[] = wszPROPREQUESTRESOLVEDWHEN;
WCHAR const g_wszPropRequestRevokedWhen[] = wszPROPREQUESTREVOKEDWHEN;
WCHAR const g_wszPropRequestRevokedEffectiveWhen[] = wszPROPREQUESTREVOKEDEFFECTIVEWHEN;
WCHAR const g_wszPropRequestRevokedReason[] = wszPROPREQUESTREVOKEDREASON;
WCHAR const g_wszPropRequestSubjectNameID[] = wszPROPREQUESTSUBJECTNAMEID;
WCHAR const g_wszPropRequesterName[] = wszPROPREQUESTERNAME;
WCHAR const g_wszPropRequesterAddress[] = wszPROPREQUESTERADDRESS;


//+--------------------------------------------------------------------------
// Certificate properties:

WCHAR const g_wszPropCertificateRequestID[] = wszPROPCERTIFICATEREQUESTID;
WCHAR const g_wszPropRawCertificate[] = wszPROPRAWCERTIFICATE;
WCHAR const g_wszPropCertificateType[] = wszPROPCERTIFICATETYPE;
WCHAR const g_wszPropCertificateSerialNumber[] = wszPROPCERTIFICATESERIALNUMBER;
WCHAR const g_wszPropCertificateIssuerNameID[] = wszPROPCERTIFICATEISSUERNAMEID;
WCHAR const g_wszPropCertificateSubjectNameID[] = wszPROPCERTIFICATESUBJECTNAMEID;
WCHAR const g_wszPropCertificateNotBeforeDate[] = wszPROPCERTIFICATENOTBEFOREDATE;
WCHAR const g_wszPropCertificateNotAfterDate[] = wszPROPCERTIFICATENOTAFTERDATE;
WCHAR const g_wszPropCertificateRawPublicKey[] = wszPROPCERTIFICATERAWPUBLICKEY;
WCHAR const g_wszPropCertificatePublicKeyAlgorithm[] = wszPROPCERTIFICATEPUBLICKEYALGORITHM;
WCHAR const g_wszPropCertificateRawPublicKeyAlgorithmParameters[] = wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\ds.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ds.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


#include <winldap.h>
#include <wininet.h>
#include <winineti.h>	// for MAX_CACHE_ENTRY_INFO_SIZE
#include <setupapi.h>
#include <ocmanage.h>
#include <certca.h>

#include <autoenr.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#include "initcert.h"
#include "cainfop.h"
#include "csldap.h"
#include "certtype.h"
#include "certacl.h"
#include "csber.h"

WCHAR const s_wszLDAP[] = L"ldap:///";


HRESULT
cuGetTemplateNames(
    IN WCHAR const *pwszTemplate,
    OUT WCHAR **ppwszCN,
    OUT WCHAR **ppwszDisplayName)
{
    HRESULT hr;
    WCHAR *pwszCN = NULL;
    WCHAR *pwszDisplayName = NULL;
    HCERTTYPE hCertType = NULL;
    DWORD dwFlags;
    WCHAR **apwszCertTypeName = NULL;
    WCHAR **apwszCertTypeCN = NULL;

    *ppwszCN = NULL;
    *ppwszDisplayName = NULL;

    dwFlags = CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES;
    if (!g_fUserRegistry)
    {
	dwFlags |= CT_FIND_LOCAL_SYSTEM;
    }
    if (g_fForce)
    {
	dwFlags |= CT_FLAG_NO_CACHE_LOOKUP;
    }

    hr = CAFindCertTypeByName(pwszTemplate, NULL, dwFlags, &hCertType);
    if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
    {
	hr = CAFindCertTypeByName(
			    pwszTemplate,
			    NULL,
			    CT_FIND_BY_OID | dwFlags,
			    &hCertType);
    }
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pwszTemplate);

    hr = CAGetCertTypeProperty(
			hCertType,
			CERTTYPE_PROP_CN,
			&apwszCertTypeCN);
    _JumpIfError(hr, error, "CAGetCertTypeProperty");

    if (NULL != apwszCertTypeCN && NULL != apwszCertTypeCN[0])
    {
	hr = myDupString(apwszCertTypeCN[0], &pwszCN);
	_JumpIfError(hr, error, "myDupString");
    }

    hr = CAGetCertTypeProperty(
			hCertType,
			CERTTYPE_PROP_FRIENDLY_NAME,
			&apwszCertTypeName);
    _JumpIfError(hr, error, "CAGetCertTypeProperty");

    if (NULL != apwszCertTypeName && NULL != apwszCertTypeName[0])
    {
	hr = myDupString(apwszCertTypeName[0], &pwszDisplayName);
	_JumpIfError(hr, error, "myDupString");
    }

    if (NULL != pwszCN)
    {
	*ppwszCN = pwszCN;
        pwszCN = NULL;
    }
    if (NULL != pwszDisplayName)
    {
	*ppwszDisplayName = pwszDisplayName;
        pwszDisplayName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != hCertType)
    {
	if (NULL != apwszCertTypeName)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeName);
	}
	if (NULL != apwszCertTypeCN)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
	}
	CACloseCertType(hCertType);
    }
    if (NULL != pwszCN)
    {
        LocalFree(pwszCN);
    }
    if (NULL != pwszDisplayName)
    {
        LocalFree(pwszDisplayName);
    }
    return(hr);
}


HRESULT
DumpDSStore(
    OPTIONAL IN WCHAR const *pwszDN,
    IN BOOL fCRL,
    IN BOOL fDeltaCRL,
    IN DWORD iCert,
    IN DWORD iCRL,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    HCERTSTORE hStoreDS = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszCAName = NULL;
    WCHAR *pwszSanitizedName = NULL;
    WCHAR *pwszURL = NULL;
    WCHAR *pwszTemplateAlloc = NULL;
    WCHAR const *pwszTemplate;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;

    //if (NULL != pwszDN) wprintf(L"pwszDN = \"%ws\"\n", pwszDN);

    // Get the object name and open its cert or CRL store

    if (NULL == pwszDN)
    {
	if (NULL == g_pwszConfig)
	{
	    hr = cuSetConfig();
	    _JumpIfError(hr, error, "cuSetConfig");
	}
	pwszTemplate = fCRL?
	    g_wszzLDAPRevocationURLTemplate : g_wszzLDAPIssuerCertURLTemplate;

	hr = mySplitConfigString(g_pwszConfig, &pwszServer, &pwszCAName);
	_JumpIfError(hr, error, "mySplitConfigString");

	hr = mySanitizeName(pwszCAName, &pwszSanitizedName);
	_JumpIfError(hr, error, "mySanitizeName");

	hr = myLdapOpen(&pld, &strDomainDN, &strConfigDN);
	_JumpIfError(hr, error, "myLdapOpen");
    }
    else
    {
	pwszTemplate = fCRL?
			wszFCSAPARM_DSCRLATTRIBUTE : 
			(g_fEnterpriseRegistry?
			    wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE :
			    (g_fUserRegistry?
				wszFCSAPARM_DSUSERCERTATTRIBUTE :
				wszFCSAPARM_DSCACERTATTRIBUTE));

	pwszTemplateAlloc = (WCHAR *) LocalAlloc(
		LMEM_FIXED,
		(wcslen(s_wszLDAP) +
		 wcslen(pwszDN) +
		 wcslen(pwszTemplate) + 1) * sizeof(WCHAR));
	if (NULL == pwszTemplateAlloc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszTemplateAlloc, s_wszLDAP);
	wcscat(pwszTemplateAlloc, pwszDN);
	wcscat(pwszTemplateAlloc, pwszTemplate);
	pwszTemplate = pwszTemplateAlloc;
    }

    hr = myFormatCertsrvStringArray(
	FALSE,						// fURL
	NULL != pwszServer? pwszServer : g_wszEmpty,	// pwszServerName_p1_2
	NULL != pwszSanitizedName? pwszSanitizedName : g_wszEmpty,
						      // pwszSanitizedName_p3_7
	0,						// iCert_p4
	NULL != strDomainDN? strDomainDN : g_wszEmpty,	// pwszDomainDN_p5
	NULL != strConfigDN? strConfigDN : g_wszEmpty,	// pwszConfigDN_p6
	iCRL,						// iCRL_p8
	fDeltaCRL,					// fDeltaCRL_p9
	TRUE,						// fDSAttrib_p10_11
	1,						// cStrings
	&pwszTemplate,					// apwszStringsIn
	&pwszURL);					// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    wprintf(L"\n%ws:\n", pwszURL);

    hStoreDS = CertOpenStore(
			CERT_STORE_PROV_LDAP_W,
			X509_ASN_ENCODING,
			NULL,
			CERT_STORE_READONLY_FLAG |
			    CERT_STORE_ENUM_ARCHIVED_FLAG,
			(VOID *) pwszURL);
    if (NULL == hStoreDS)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CertOpenStore", pwszURL);
    }

    if (fCRL)
    {
	iCRL = MAXDWORD;
	if (NULL != pwszfnOut)
	{
	    iCRL = 0;
	}
    }
    hr = cuDumpAndVerifyStore(
			hStoreDS,
			DVNS_VERIFYCERT | DVNS_CASTORE | DVNS_DUMPPROPERTIES,
			NULL,		// pwszCertName
			iCert,
			iCRL,
			MAXDWORD,	// iCTL
			pwszfnOut,
			NULL);
    _JumpIfError(hr, error, "cuDumpAndVerifyStore");

error:
    if (NULL != pwszTemplateAlloc)
    {
	LocalFree(pwszTemplateAlloc);
    }
    if (NULL != pwszSanitizedName)
    {
	LocalFree(pwszSanitizedName);
    }
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszCAName)
    {
	LocalFree(pwszCAName);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != hStoreDS)
    {
	CertCloseStore(hStoreDS, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
verbDSCert(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCertIndex,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD iCert = MAXDWORD;
    WCHAR const *pwszDN = NULL;

    if (NULL != pwszCertIndex)
    {
	hr = cuGetLong(pwszCertIndex, (LONG *) &iCert);
	if (S_OK != hr)
	{
	    if (NULL != pwszfnOut)
	    {
		_JumpError(hr, error, "CertIndex must be a number");
	    }
	    pwszDN = pwszCertIndex;
	    iCert = MAXDWORD;
	}
    }
    hr = DumpDSStore(pwszDN, FALSE, FALSE, iCert, MAXDWORD, pwszfnOut);
    _JumpIfError(hr, error, "DumpDSStore");

error:
    return(hr);
}


HRESULT
GetCACertCount(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT DWORD *pcCACerts)
{
    HRESULT hr;
    BSTR str = NULL;
    DWORD cwc;
    WCHAR const *pwc;
    CAINFO CAInfo;

    hr = Request_GetCACertificate(
				pdiRequest,
				GETCERT_CAINFO,	// fExchangeCertificate
				g_pwszConfig,
				CR_OUT_BINARY,
				&str);
    _JumpIfError(hr, error, "Request_GetCACertificate(CAInfo)");

    cwc = wcslen(str);
    pwc = str;
		
    if (!cuParseDecimal(&pwc, &cwc, (DWORD *) &CAInfo.CAType) ||
	!cuParseDecimal(&pwc, &cwc, &CAInfo.cCASignatureCerts))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cuParseDecimal");
    }
    *pcCACerts = CAInfo.cCASignatureCerts;

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
    return(hr);
}


HRESULT
GetCRLState(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD iCRL,
    OUT DWORD *pState)
{
    HRESULT hr;
    BSTR str = NULL;
    DWORD cwc;
    WCHAR const *pwc;

    hr = Request_GetCACertificate(
			pdiRequest,
			GETCERT_CRLSTATEBYINDEX | iCRL,	// fExchangeCertificate
			g_pwszConfig,
			CR_OUT_BINARY,
			&str);
    _JumpIfError(hr, error, "Request_GetCACertificate");

    cwc = wcslen(str);
    pwc = str;
		
    if (!cuParseDecimal(&pwc, &cwc, pState))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cuParseDecimal");
    }

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
    return(hr);
}


HRESULT
DSCRLSub(
    IN BOOL fDeltaCRL,
    OPTIONAL IN WCHAR const *pwszCRLIndex,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    DWORD iCRL = MAXDWORD;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;
    WCHAR const *pwszDN = NULL;

    if (NULL != pwszCRLIndex)
    {
	hr = cuGetLong(pwszCRLIndex, (LONG *) &iCRL);
	if (S_OK != hr)
	{
	    if (NULL != pwszfnOut)
	    {
		_JumpError(hr, error, "CRLIndex must be a number");
	    }
	    pwszDN = pwszCRLIndex;
	    iCRL = MAXDWORD;
	}
    }
    if (NULL == pwszDN)
    {
	hr = cuSetConfig();
	_JumpIfError(hr, error, "cuSetConfig");
    }
    if (MAXDWORD == iCRL && NULL == pwszDN)
    {
	DWORD cCACerts;
	DWORD State;

	hr = Request_Init(g_DispatchFlags, &diRequest);
	_JumpIfError(hr, error, "Request_Init");

	fMustRelease = TRUE;

	hr = GetCACertCount(&diRequest, &cCACerts);
	_JumpIfError(hr, error, "GetCACertCount");

	for (iCRL = 0; iCRL < cCACerts; iCRL++)
	{
	    hr = GetCRLState(&diRequest, iCRL, &State);
	    _JumpIfError(hr, error, "GetCRLState");

	    if (CA_DISP_VALID != State)
	    {
		//wprintf(L"Skipping CRL.%u\n", iCRL);
		continue;
	    }
	    hr = DumpDSStore(NULL, TRUE, fDeltaCRL, MAXDWORD, iCRL, NULL);
	    _JumpIfError(hr, error, "DumpDSStore");
	}
    }
    else
    {
	hr = DumpDSStore(pwszDN, TRUE, fDeltaCRL, MAXDWORD, iCRL, pwszfnOut);
	_JumpIfError(hr, error, "DumpDSStore");
    }

error:
    if (fMustRelease)
    {
	Request_Release(&diRequest);
    }
    return(hr);
}


HRESULT
verbDSCRL(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCRLIndex,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = DSCRLSub(FALSE, pwszCRLIndex, pwszfnOut);
    _JumpIfError(hr, error, "DSCRLSub");

error:
    return(hr);
}


HRESULT
verbDSDeltaCRL(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCRLIndex,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = DSCRLSub(TRUE, pwszCRLIndex, pwszfnOut);
    _JumpIfError(hr, error, "DSCRLSub");

error:
    return(hr);
}


#define wszCOMMA	L","
#define wszCNEQUALS	L"CN="

BOOL
CACNBaseNameMatch(
    IN WCHAR const *pwszCNMatch,
    IN WCHAR const *pwszCN)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    BOOL fMatch = FALSE;
    BOOL fDigit;
    WCHAR *pwsz;

    hr = myDupString(pwszCN, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    pwsz = &pwszDup[wcslen(pwszDup) - 1];
    if (pwsz > pwszDup && wcRPAREN == *pwsz)
    {
	pwsz--;
	fDigit = FALSE;
	while (pwsz > pwszDup && iswdigit(*pwsz))
	{
	    fDigit = TRUE;
	    pwsz--;
	}
	if (!fDigit || pwsz <= pwszDup || wcLPAREN != *pwsz)
	{
	    _JumpError2(hr, error, "fDigit or wcLPAREN", hr);
	}
	*pwsz-- = L'\0';	// truncate trailing "(#)"
    }
    pwsz -= WSZARRAYSIZE(L"-CDP") - 1;
    if (pwsz > pwszDup && 0 == lstrcmpi(pwsz, L"-CDP"))
    {
	*pwsz = '\0';		// truncate trailing L"-CDP"
    }
    if (0 != lstrcmpi(pwszCNMatch, pwszDup))	// compare base name
    {
	_JumpError2(hr, error, "no base name match", hr);
    }
    fMatch = TRUE;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(fMatch);
}


BOOL
CACNMatches(
    OPTIONAL IN WCHAR const *pwszCNMatch, 
    OPTIONAL IN WCHAR const *pwszOIDCN,
    IN WCHAR const *pwszRevertCN, 
    IN WCHAR const *pwszSanitizedCN,
    OPTIONAL IN WCHAR const *pwszDisplayName,
    OPTIONAL IN WCHAR const *pwszAlternateCN)
{
    BOOL fMatch = TRUE;
    
    // If no match criteria, match everything
    
    if (NULL == pwszCNMatch)
    {
	goto match;
    }

    // Check against the Desanitized short name or Sanitized short name.
    
    if (0 == lstrcmpi(pwszCNMatch, pwszRevertCN) ||
	0 == lstrcmpi(pwszCNMatch, pwszSanitizedCN))
    {
	goto match;
    }

    // Check against the displayName
    
    if (NULL != pwszDisplayName && 0 == lstrcmpi(pwszCNMatch, pwszDisplayName))
    {
	goto match;
    }

    // Check against the alternate CN (msPKI-Cert-Template-OID)
    
    if (NULL != pwszAlternateCN && 0 == lstrcmpi(pwszCNMatch, pwszAlternateCN))
    {
	goto match;
    }

    // Check against the OID converted to a CN
    
    if (NULL != pwszOIDCN &&
	0 == lstrcmpi(pwszOIDCN, pwszRevertCN))
    {
	goto match;
    }

    // Check against the Desanitized short name or Sanitized short name,
    // stripped of the key index and CDP tags.
    
    if (CACNBaseNameMatch(pwszCNMatch, pwszRevertCN) ||
	CACNBaseNameMatch(pwszCNMatch, pwszSanitizedCN))
    {
	goto match;
    }
    fMatch = FALSE;	// can't say we didn't try...

match:
    return(fMatch);
}


HRESULT
BuildDN(
    IN WCHAR const *pwszRDN,
    IN WCHAR const *pwszContainer,
    IN BOOL fAddCNEquals,
    OUT WCHAR **ppwszDN)
{
    HRESULT hr;
    WCHAR *pwszDN = NULL;
    DWORD cwc;

    *ppwszDN = NULL;
    cwc = wcslen(pwszRDN) + 1 + wcslen(pwszContainer) + 1;
    if (fAddCNEquals)
    {
	cwc += WSZARRAYSIZE(wszCNEQUALS);
    }
    pwszDN = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszDN)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pwszDN = L'\0';
    if (fAddCNEquals)
    {
	wcscpy(pwszDN, wszCNEQUALS);
    }
    wcscat(pwszDN, pwszRDN);
    wcscat(pwszDN, wszCOMMA);
    wcscat(pwszDN, pwszContainer);
    *ppwszDN = pwszDN;
    pwszDN = NULL;
    hr = S_OK;

error:
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    return(hr);
}


HRESULT
DeleteDN(
    IN LDAP *pld,
    IN WCHAR const *pwszRDN,
    IN WCHAR const *pwszContainer)
{
    WCHAR *pwszDN = NULL;
    HRESULT hr;

    hr = BuildDN(pwszRDN, pwszContainer, TRUE, &pwszDN);
    _JumpIfError(hr, error, "BuildDN");

    hr = ldap_delete_s(pld, pwszDN);
    if (S_OK != hr)
    {
	hr = myHLdapError(pld, hr, NULL);
	_JumpErrorStr(hr, error, "ldap_delete_s", pwszDN);
    }

error:
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    return(hr);
}



#define DSAF_STRING		0x00000001
#define DSAF_FLAGS		0x00000002
#define DSAF_BINARY		0x00000003
#define DSAF_GUID		0x00000004
#define DSAF_ASNDATE		0x00000005
#define DSAF_ASN		0x00000006
#define DSAF_FILETIME		0x00000007
#define DSAF_EXTENSION		0x00000008	// see pszObjId

typedef struct _EXTTEMPLATE
{
    WCHAR const *pwszObjId;	// wszOID_*
    BYTE const  *pbTemplate;	// Template
    DWORD        cbTemplate;	// Template length
    DWORD        cbAdd;		// Additional encoded length
} EXTTEMPLATE;


typedef struct _DSATTR
{
    WCHAR const *pwszName;	// Attribute name
    DWORD        Flags;		// DSAF_*
    UINT         idMsg;		// IDS_FORMAT_*
    EXTTEMPLATE *pExtension;
} DSATTR;



BYTE s_abTemplateKeyUsage[] = { BER_BIT_STRING, 0x00, 0x00 };

EXTTEMPLATE s_ExtKeyUsage =
{
    TEXT(szOID_KEY_USAGE),
    s_abTemplateKeyUsage,
    sizeof(s_abTemplateKeyUsage),
    1
};


DSATTR s_DSAttrBinary =
{
    L"",
    DSAF_BINARY,
    0,
    NULL,
};

DSATTR s_DSAttrString =
{
    L"",
    DSAF_STRING,
    0,
    NULL,
};

DSATTR s_aDSAttr[] =
{
  { wszDSUSERCERTATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CERT_INDEX, NULL, },
  { wszDSCACERTATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CERT_INDEX, NULL, },
  { wszDSCROSSCERTPAIRATTRIBUTE,  DSAF_ASN, IDS_FORMAT_DUMP_CERT_INDEX, NULL, },
  { wszDSAUTHORITYCRLATTRIBUTE,   DSAF_ASN, IDS_FORMAT_DUMP_CRL_INDEX,  NULL, },
  { wszDSBASECRLATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CRL_INDEX,  NULL, },
  { wszDSDELTACRLATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CRL_INDEX,  NULL, },
  { CERTTYPE_PROP_CN,		         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_DN,		         DSAF_STRING,    0, NULL, },
  { L"name",			         DSAF_STRING,    0, NULL, },
  { L"showInAdvancedViewOnly",	         DSAF_STRING,    0, NULL, },
  { L"memberOf",			 DSAF_STRING,    0, NULL, },
  { L"operatingSystem",			 DSAF_STRING,    0, NULL, },
  { L"operatingSystemVersion",		 DSAF_STRING,    0, NULL, },
  { L"servicePrincipalName",		 DSAF_STRING,    0, NULL, },
  { L"sAMAccountName",			 DSAF_STRING,    0, NULL, },
  { L"description",			 DSAF_STRING,    0, NULL, },
  { L"isCriticalSystemObject",	         DSAF_STRING,    0, NULL, },
//{ L"uSNChanged",		         DSAF_STRING,    0, NULL, },
//{ L"uSNCreated",		         DSAF_STRING,    0, NULL, },
//{ L"instanceType",		         DSAF_STRING,    0, NULL, },
  { L"objectCategory",		         DSAF_STRING,    0, NULL, },
  { wszDSOBJECTCLASSATTRIBUTE,	         DSAF_STRING,    0, NULL, },
  { L"objectGUID",		         DSAF_GUID,      0, NULL, },
  { L"whenChanged",		         DSAF_ASNDATE,   0, NULL, },
  { L"whenCreated",		         DSAF_ASNDATE,   0, NULL, },
  { L"dSCorePropagationData",	         DSAF_ASNDATE,   0, NULL, },
  { CA_PROP_CERT_DN,		         DSAF_STRING,    0, NULL, },
  { CA_PROP_CERT_TYPES,		         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_FRIENDLY_NAME,         DSAF_STRING,    0, NULL, },
  { CA_PROP_DNSNAME,		         DSAF_STRING,    0, NULL, },
  { OID_PROP_LOCALIZED_NAME,	         DSAF_STRING,    0, NULL, },
  { OID_PROP_CPS,		         DSAF_STRING,    0, NULL, },
// Template Schema Version 1 properties:
  { CERTTYPE_PROP_FLAGS,	         DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_CSP_LIST,	         DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_DEFAULT_KEYSPEC,       DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_EXTENDED_KEY_USAGE,    DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_CRITICAL_EXTENSIONS,   DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_MAX_DEPTH,	         DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_REVISION,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_EXPIRATION,	         DSAF_FILETIME,  0, NULL, },
  { CERTTYPE_PROP_OVERLAP,	         DSAF_FILETIME,  0, NULL, },
  { CERTTYPE_PROP_KU,		         DSAF_EXTENSION, 0, &s_ExtKeyUsage, },
// Template Schema Version 2 properties:
  { CERTTYPE_RPOP_ENROLLMENT_FLAG,       DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_NAME_FLAG,	         DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_PRIVATE_KEY_FLAG,      DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_SCHEMA_VERSION,        DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_MINOR_REVISION,        DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_RA_SIGNATURE,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_MIN_KEY_SIZE,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_OID,		         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_SUPERSEDE,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_RA_POLICY,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_RA_APPLICATION_POLICY, DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_POLICY,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_APPLICATION_POLICY,    DSAF_STRING,    0, NULL, },
};

#define ISEMPTYATTR(pberval)	\
    (0 == (pberval)->bv_len || \
     (1 == (pberval)->bv_len && 0 == *(BYTE const *) (pberval)->bv_val))


WCHAR const s_wszPad0[] = L"    ";
WCHAR const s_wszPad1[] = L"\t";


#define wszPUBLICKEYSERVICESCONTAINER \
    L"CN=Public Key Services," \
    L"CN=Services"

WCHAR const g_wszCNAuthoritiesOld[] =
    L"CN=Certification Authorities";

WCHAR const g_wszCNAuthorities[] =
    L"CN=Certification Authorities,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszEnterpriseCAs[] =
    //L"CN=NTAuthCertificates,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNKRA[] =
    L"CN=KRA,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNEnrollment[] =
    L"CN=Enrollment Services,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNAIA[] =
    L"CN=AIA,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNOID[] =
    L"CN=OID,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNCDP[] =
    L"CN=CDP,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNTemplates[] =
    L"CN=Certificate Templates,"
    wszPUBLICKEYSERVICESCONTAINER;


typedef struct _DSDN
{
    DWORD Flags;
    WCHAR const *pwszCN;
    WCHAR const *pwszChild;
    WCHAR const *pwszAlternateCNAttribute;
} DSDN;

#define DSDF_ADDCNEQUALS	0x00000001
#define DSDF_RECURSEONELEVEL	0x00000002
#define DSDF_DELETE		0x00000004
#define DSDF_INFDUMP		0x00000008
#define DSDF_DOMAINDN		0x00000010
#define DSDF_BASE		0x00000020

#define DSDF_CA			0x00000100
#define DSDF_TEMPLATE		0x00000200
#define DSDF_OID		0x00000400

#define DSDF_TYPEMASK		0x00000700

DSDN s_aDSDN[] =
{
 { 0,		  wszPUBLICKEYSERVICESCONTAINER, L"NTAuthCertificates", NULL },
 { DSDF_CA | DSDF_DOMAINDN,	   g_wszCNAuthoritiesOld, NULL, NULL },
 { DSDF_CA,			   g_wszCNAuthorities, NULL, NULL },
 { 0,				   g_wszCNKRA,	      NULL, NULL },
 { DSDF_CA,			   g_wszCNEnrollment, NULL, NULL },
 { DSDF_CA,			   g_wszCNAIA,	      NULL, NULL },
 { DSDF_CA | DSDF_RECURSEONELEVEL, g_wszCNCDP,	      NULL, NULL },
 { DSDF_OID,			   g_wszCNOID,	      NULL, OID_PROP_OID },
 { DSDF_TEMPLATE,		   g_wszCNTemplates,  NULL, CERTTYPE_PROP_OID },
};


HRESULT
dumpDSStringAttribute(
    IN LDAP *pld,
    IN LDAPMessage *pres,
    IN DWORD dwFlags,
    IN WCHAR const *pwszAttrName,
    IN DSATTR const *pdsa)
{
    HRESULT hr;
    WCHAR **rgpwszval = NULL;
    BOOL fInfDump = 0 != (DSDF_INFDUMP & dwFlags);

    rgpwszval = ldap_get_values(pld, pres, (WCHAR * const) pwszAttrName);
    if (NULL != rgpwszval)
    {
	LONG lVal;
	BOOL fValidNumber;
	WCHAR const *pwszVal;
	BOOL fCompact;
	DWORD i;
	WCHAR const *pwszSep;
	
	fCompact = fInfDump ||
	    (1 >= g_fVerbose && (NULL == rgpwszval[0] || NULL == rgpwszval[1]));
	if (!fCompact)
	{
	    wprintf(L"%ws%ws\n", s_wszPad0, pwszAttrName);
	}
	for (i = 0; NULL != (pwszVal = rgpwszval[i]); i++)
	{
	    pwszSep = L"";
	    if (fCompact)
	    {
		if (0 == i)
		{
		    wprintf(L"%ws%ws =", s_wszPad0, pwszAttrName);
		}
		else
		{
		    pwszSep = L",";
		}
	    }
	    else
	    {
		wprintf(s_wszPad1);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_ELEMENT), // "Element %u:"
		    i);
	    }
	    wprintf(L"%ws \"%ws\"", pwszSep, pwszVal);

	    if (iswdigit(pwszVal[0]) || L'-' == pwszVal[0])
	    {
		if (L'-' == pwszVal[0])
		{
		    lVal = myWtoI(&pwszVal[1], &fValidNumber);
		    lVal = -lVal;
		}
		else
		{
		    lVal = myWtoI(pwszVal, &fValidNumber);
		}
		if (!fInfDump || g_fVerbose)
		{
		    if (fValidNumber)
		    {
			if (0 > lVal || 9 < lVal)
			{
			    wprintf(L" 0x%x", lVal);
			}
			if (DSAF_FLAGS == pdsa->Flags)
			{
			    WCHAR const *pwsz;

			    pwsz = pdsa->pwszName;
			    if (0 == lstrcmpi(CERTTYPE_PROP_FLAGS, pwsz))
			    {
				if (DSDF_CA & dwFlags)
				{
				    pwsz = wszCUREGDSCAFLAGS;
				}
				else if (DSDF_TEMPLATE & dwFlags)
				{
				    pwsz = wszCUREGDSTEMPLATEFLAGS;
				}
				else if (DSDF_OID & dwFlags)
				{
				    pwsz = wszCUREGDSOIDFLAGS;
				}
			    }
			    wprintf(wszNewLine);
			    cuRegPrintDwordValue(FALSE, pwsz, pwsz, lVal);
			}
		    }
		    else
		    {
			cuPrintPossibleObjectIdName(pwszVal);
		    }
		}
	    }
	    if (DSAF_ASNDATE == pdsa->Flags)
	    {
		WCHAR const *pwszT;
		FILETIME ft;
		DWORD cbft;
		DWORD cb;
		BYTE ab[MAX_PATH];

		cb = 0;
		ab[cb++] = BER_GENERALIZED_TIME;
		ab[cb++] = (BYTE) wcslen(pwszVal);

		for (pwszT = pwszVal; L'\0' != *pwszT; pwszT++)
		{
		    ab[cb++] = (BYTE) *pwszT;
		}
		cbft = sizeof(FILETIME);
		if (!CryptDecodeObject(
				X509_ASN_ENCODING,
				X509_CHOICE_OF_TIME,
				ab,
				cb,
				0,
				&ft,
				&cbft))
		{
		    wprintf(L"\n");
		    hr = myHLastError();
		    _PrintIfError(hr, "CryptDecodeObject");
		}
		else if (!fInfDump || g_fVerbose)
		{
		    cuDumpFileTime(0, NULL, &ft);
		}
	    }
	    else if (!fInfDump)
	    {
		wprintf(L"\n");
	    }
	    if (1 < g_fVerbose)
	    {
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 12,
		    (BYTE const *) pwszVal,
		    wcslen(pwszVal) * sizeof(WCHAR));
	    }
	}
	if (fInfDump)
	{
	    wprintf(L"\n");
	}
    }
    hr = S_OK;

//error:
    if (NULL != rgpwszval)
    {
	ldap_value_free(rgpwszval);
    }
    return(hr);
}


BOOL
isStringAttribute(
    berval **rgpberval)
{
    BOOL fString = FALSE;
    DWORD i;
    DWORD cbTotal = 0;

    for (i = 0; NULL != rgpberval[i]; i++)
    {
	BYTE const *pb = (BYTE const *) rgpberval[i]->bv_val;
	DWORD cb = rgpberval[i]->bv_len;

	cbTotal += cb;
	if (0 < cb && '-' == *pb)
	{
	    pb++;
	    cb--;
	}
	while (0 < cb--)
	{
	    if (('0' > *pb || '9' < *pb) && '.' != *pb)
	    {
		goto error;
	    }
	    pb++;
	}
    }
    if (0 < cbTotal)
    {
	fString = TRUE;
    }

error:
    return(fString);
}


HRESULT
dumpDSBinaryAttribute(
    IN LDAP *pld,
    IN LDAPMessage *pres,
    IN DWORD dwFlags,
    IN WCHAR const *pwszAttrName,
    IN DSATTR const *pdsa)
{
    HRESULT hr;
    berval **rgpberval = NULL;
    BOOL fNewLine = FALSE;
    BOOL fInfDump = 0 != (DSDF_INFDUMP & dwFlags);

    rgpberval = ldap_get_values_len(pld, pres, (WCHAR * const) pwszAttrName);
    if (NULL != rgpberval)
    {
	BOOL fCompact;
	DWORD i;
	WCHAR const *pwszInfQuote = fInfDump? L"\"" : L"";

	if (&s_DSAttrBinary == pdsa && isStringAttribute(rgpberval))
	{
	    hr = dumpDSStringAttribute(
				pld,
				pres,
				dwFlags,
				pwszAttrName,
				&s_DSAttrString);
	    _PrintIfError(hr, "dumpDSStringAttribute");
	    goto error;
	}

	fCompact = fInfDump ||
	    (1 >= g_fVerbose && (NULL == rgpberval[0] || NULL == rgpberval[1]));
	if (!fCompact)
	{
	    wprintf(L"%ws%ws\n", s_wszPad0, pwszAttrName);
	}
	for (i = 0; NULL != rgpberval[i]; i++)
	{
	    BOOL fEmpty = ISEMPTYATTR(rgpberval[i]);
	    WCHAR const *pwszSep;

	    if (fCompact)
	    {
		wprintf(L"%ws%ws", s_wszPad0, pwszAttrName);
		pwszSep = L" = ";
	    }
	    else
	    {
		wprintf(s_wszPad1);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_ELEMENT), // "Element %u:"
		    i);
		wprintf(
		    L" %u %ws",
		    rgpberval[i]->bv_len,
		    myLoadResourceString(IDS_BYTES)); // "Bytes"
		pwszSep = L" ";
	    }
	    if (fEmpty)
	    {
		wprintf(
		    L"%ws%ws\n",
		    pwszSep,
		    fInfDump?
			L"\"\"" :
			myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
	    }
	    else
	    {
		BOOL fHex = TRUE;
		
		if (DSAF_ASN == pdsa->Flags)
		{
		    if (!fInfDump)
		    {
			BOOL fVerboseOld = g_fVerbose;

			wprintf(wszNewLine);

			CSASSERT(g_fVerbose);
			g_fVerbose--;
			g_fQuiet = !g_fVerbose;
			if (g_fVerbose)
			{
			    g_fVerbose--;
			}
			if (0 != pdsa->idMsg)
			{
			    wprintf(
				myLoadResourceString(pdsa->idMsg),
				i);
			    wprintf(wszNewLine);
			}
			hr = cuDumpAsnBinary(
				    (BYTE const *) rgpberval[i]->bv_val,
				    rgpberval[i]->bv_len,
				    MAXDWORD);
			_PrintIfError(hr, "cuDumpAsnBinary");
			if (S_OK == hr)
			{
			    fHex = FALSE;
			}
			g_fVerbose = fVerboseOld;
			fNewLine = TRUE;
		    }
		}
		else if (DSAF_FILETIME == pdsa->Flags)
		{
		    FILETIME ft;
			
		    if (sizeof(ft) == rgpberval[i]->bv_len)
		    {
			wprintf(pwszSep);
			CopyMemory(&ft, rgpberval[i]->bv_val, sizeof(ft));
			hr = cuDumpFileTimeOrPeriod(0, pwszInfQuote, &ft);
			if (S_OK == hr)
			{
			    fHex = FALSE;
			}
		    }
		}
		else if (DSAF_EXTENSION == pdsa->Flags)
		{
		    if (!fInfDump)
		    {
			BOOL fQuietOld = g_fQuiet;
			DWORD cb;
			BYTE ab[MAX_PATH];

			cb = pdsa->pExtension->cbTemplate;
			CopyMemory(
				ab,
				pdsa->pExtension->pbTemplate,
				cb);
			CopyMemory(
				&ab[cb],
				rgpberval[i]->bv_val,
				rgpberval[i]->bv_len);
			ab[1] = (BYTE) (pdsa->pExtension->cbAdd + rgpberval[i]->bv_len);
			cb += rgpberval[i]->bv_len;

			wprintf(pwszSep);
			g_fQuiet = TRUE;
			if (!cuDumpFormattedExtension(
					pdsa->pExtension->pwszObjId,
					ab,
					cb))
			{
			    hr = myHLastError();
			    _PrintError(hr, "cuDumpFormattedExtension");
			}
			else
			{
			    fHex = FALSE;
			}
			g_fQuiet = fQuietOld;
			wprintf(wszNewLine);
		    }
		}
		else if (DSAF_GUID == pdsa->Flags)
		{
		    if (sizeof(GUID) == rgpberval[i]->bv_len)
		    {
			WCHAR *pwszGUID;
		    
			hr = myCLSIDToWsz(
				(GUID *) rgpberval[i]->bv_val,
				&pwszGUID);
			_PrintIfError(hr, "myCLSIDToWsz");
			if (S_OK == hr)
			{
			    wprintf(
				L"%ws%ws%ws%ws",
				pwszSep,
				pwszInfQuote,
				pwszGUID,
				pwszInfQuote);
			    LocalFree(pwszGUID);
			    fHex = FALSE;
			}
		    }
		    wprintf(wszNewLine);
		}
		else
		{
		    wprintf(wszNewLine);
		}
		if (fHex || 1 < g_fVerbose)
		{
		    if (fInfDump)
		    {
			BSTR strHex = NULL;
			
			hr = MultiByteIntegerToBstr(
					    TRUE,
					    rgpberval[i]->bv_len,
					    (BYTE const *) rgpberval[i]->bv_val,
					    &strHex);
			_JumpIfError(hr, error, "MultiByteIntegerToBstr");

			wprintf(L"%ws\"%ws\"\n", pwszSep, strHex);
			SysFreeString(strHex);
		    }
		    else
		    {
			DumpHex(
			    DH_NOADDRESS | DH_NOTABPREFIX | 12,
			    (BYTE const *) rgpberval[i]->bv_val,
			    rgpberval[i]->bv_len);
		    }
		}
	    }
	}
    }
    if (fNewLine)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    if (NULL != rgpberval)
    {
	ldap_value_free_len(rgpberval);
    }
    return(hr);
}


HRESULT
dumpDSAttributes(
    IN LDAP *pld,
    IN LDAPMessage *pres,
    IN DWORD dwFlags)
{
    HRESULT hr;
    WCHAR *pwszAttrName;
    BerElement *pber = NULL;
    
    for (pwszAttrName = ldap_first_attribute(pld, pres, &pber); 
	 pwszAttrName != NULL; 
	 pwszAttrName = ldap_next_attribute(pld, pres, pber))
    {
	DSATTR const *pdsa;
		    
	for (pdsa = s_aDSAttr; ; pdsa++)
	{
	    if (pdsa >= &s_aDSAttr[ARRAYSIZE(s_aDSAttr)])
	    {
		pdsa = &s_DSAttrBinary;	// Unknown attribute
		break;
	    }
	    if (0 == lstrcmpi(pwszAttrName, pdsa->pwszName))
	    {
		break;
	    }
	}

	switch (pdsa->Flags)
	{
	    case DSAF_ASNDATE:
	    case DSAF_STRING:
	    case DSAF_FLAGS:
		hr = dumpDSStringAttribute(
					pld,
					pres,
					dwFlags,
					pwszAttrName,
					pdsa);
		_PrintIfError(hr, "dumpDSStringAttribute");
		break;

	    case DSAF_GUID:
	    case DSAF_FILETIME:
	    case DSAF_EXTENSION:
	    case DSAF_BINARY:
	    case DSAF_ASN:
		hr = dumpDSBinaryAttribute(
					pld,
					pres,
					dwFlags,
					pwszAttrName,
					pdsa);
		_PrintIfError(hr, "dumpDSBinaryAttribute");
		break;

	    default:
		CSASSERT(FALSE && pdsa->Flags);
		break;
	}
	ldap_memfree(pwszAttrName);
	pwszAttrName = NULL;
    }
    wprintf(L"\n");
    hr = S_OK;

//error:
    if (NULL != pber)
    {
	//ber_free(pber, 0);
    }
    return(hr);
}


HRESULT
AddCNList(
    IN WCHAR const *pwszCN,
    IN OUT WCHAR ***pppwsz)
{
    HRESULT hr;
    DWORD cpwsz = 0;
    WCHAR **ppwsz = *pppwsz;
    WCHAR **ppwszAlloc = NULL;
    WCHAR *pwszDup = NULL;

    hr = myDupString(pwszCN, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    if (NULL != ppwsz)
    {
	for ( ; NULL != ppwsz[cpwsz]; cpwsz++)
	    ;
    }
    if (NULL == ppwsz)
    {
	ppwszAlloc = (WCHAR **) LocalAlloc(
					LMEM_FIXED,
					2 * sizeof(*ppwszAlloc));
    }
    else
    {
	ppwszAlloc = (WCHAR **) LocalReAlloc(
					ppwsz,
					(cpwsz + 2) * sizeof(*ppwszAlloc),
					LMEM_MOVEABLE | LMEM_ZEROINIT);
    }
    if (NULL == ppwszAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
		hr,
		error,
		NULL == ppwsz? "LocalAlloc" : "LocalReAlloc");
    }
    ppwszAlloc[cpwsz] = pwszDup;
    ppwszAlloc[cpwsz + 1] = NULL;
    pwszDup = NULL;
    *pppwsz = ppwszAlloc;
    hr = S_OK;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
dumpDSDNs(
    IN LDAP *pld,
    IN DWORD dwFlags,
    IN WCHAR const *pwszAlternateCNAttribute,
    IN WCHAR const *pwszCNMatch,
    IN WCHAR const *pwszRDN,
    OPTIONAL IN WCHAR const *pwszContainer,
    OPTIONAL OUT WCHAR ***pppwsz)
{
    HRESULT hr;
    WCHAR *pwszDNAlloc = NULL;
    WCHAR const *pwszDN;
    DWORD cwc;
    DWORD cres;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *pwszOIDCN = NULL;
    WCHAR *pwszAlternateCN = NULL;
    WCHAR *pwszDisplayName = NULL;
    WCHAR *pwszRevertCN = NULL;
    BOOL fFirst = TRUE;
    WCHAR **ppwszLdapVal = NULL;

    if (NULL != pppwsz)
    {
	*pppwsz = NULL;
    }
    if (NULL == pwszContainer)
    {
	pwszDN = pwszRDN;
    }
    else
    {
	hr = BuildDN(
		pwszRDN,
		pwszContainer,
		0 != (DSDF_ADDCNEQUALS & dwFlags),
		&pwszDNAlloc);
	_JumpIfError(hr, error, "BuildDN");

	pwszDN = pwszDNAlloc;
    }
    if (NULL != pwszCNMatch && iswdigit(*pwszCNMatch))
    {
	hr = myOIDHashOIDToString(pwszCNMatch, &pwszOIDCN);
	//_PrintIfError2(hr, "myOIDHashOIDToString", hr);
	_PrintIfError2(hr, "myOIDHashOIDToString", E_INVALIDARG);
    }

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;
    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszDN),	// base
		(DSDF_BASE & dwFlags)? LDAP_SCOPE_BASE : LDAP_SCOPE_ONELEVEL,
		NULL,				// filter
		NULL,				// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	hr = myHLdapError2(pld, hr, LDAP_NO_SUCH_OBJECT, NULL);
	_JumpErrorStr2(
		hr,
		error,
		"ldap_search_st",
		pwszDN,
		HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND));
    }
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	// No entries were found.

	goto error;
    }

    for (pres = ldap_first_entry(pld, pmsg); 
	 NULL != pres;
	 pres = ldap_next_entry(pld, pres))
    {
	if (NULL != pwszDisplayName)
	{
	    LocalFree(pwszDisplayName);
	    pwszDisplayName = NULL;
	}
	if (NULL != pwszAlternateCN)
	{
	    LocalFree(pwszAlternateCN);
	    pwszAlternateCN = NULL;
	}
	if (NULL != pwszRevertCN)
	{
	    LocalFree(pwszRevertCN);
	    pwszRevertCN = NULL;
	}

	CSASSERT(NULL == ppwszLdapVal);
	ppwszLdapVal = ldap_get_values(pld, pres, CA_PROP_DISPLAY_NAME);
	if (NULL != ppwszLdapVal)
	{
	    if (NULL != ppwszLdapVal[0])
	    {
		hr = myDupString(ppwszLdapVal[0], &pwszDisplayName);
		_JumpIfError(hr, error, "myDupString");
	    }
	    ldap_value_free(ppwszLdapVal);
	    ppwszLdapVal = NULL;
	}

	CSASSERT(NULL == ppwszLdapVal);
	if (NULL != pwszAlternateCNAttribute)
	{
	    ppwszLdapVal = ldap_get_values(
				pld,
				pres,
				const_cast<WCHAR *>(pwszAlternateCNAttribute));
	    if (NULL != ppwszLdapVal)
	    {
		if (NULL != ppwszLdapVal[0])
		{
		    hr = myDupString(ppwszLdapVal[0], &pwszAlternateCN);
		    _JumpIfError(hr, error, "myDupString");
		}
		ldap_value_free(ppwszLdapVal);
		ppwszLdapVal = NULL;
	    }
	}

	CSASSERT(NULL == ppwszLdapVal);
	ppwszLdapVal = ldap_get_values(pld, pres, CERTTYPE_PROP_CN);
	if (NULL != ppwszLdapVal)
	{
	    if (NULL != ppwszLdapVal[0])
	    {
		hr = myRevertSanitizeName(ppwszLdapVal[0], &pwszRevertCN);
		_JumpIfError(hr, error, "myRevertSanitizeName");

		if (CACNMatches(
			    pwszCNMatch,
			    pwszOIDCN,
			    pwszRevertCN,
			    ppwszLdapVal[0],
			    pwszDisplayName,
			    pwszAlternateCN))
		{
		    if (NULL != pppwsz)
		    {
			hr = AddCNList(ppwszLdapVal[0], pppwsz);
			_JumpIfError(hr, error, "AddCNList");
		    }
		    if (DSDF_INFDUMP & dwFlags)
		    {
			wprintf(L"\n[%ws]\n", ppwszLdapVal[0]);
		    }
		    else
		    {
			if (fFirst)
			{
			    wprintf(L"%ws:\n", pwszDN);
			}
			wprintf(
			    L"  %ws%ws%ws",
			    (DSDF_DELETE & dwFlags)?
				myLoadResourceString(IDS_DELETING) : // "Deleting"
				L"",
			    (DSDF_DELETE & dwFlags)? L" " : L"",
			    pwszRevertCN);
			if (0 != lstrcmpi(pwszRevertCN, ppwszLdapVal[0]))
			{
			    wprintf(L" -- %ws", ppwszLdapVal[0]);
			}
			wprintf(L"\n");
			if (!g_fVerbose &&
			    NULL != pwszAlternateCN &&
			    0 != lstrcmpi(pwszRevertCN, pwszAlternateCN))
			{
			    wprintf(L"    %ws\n", pwszAlternateCN);
			}
			if (!g_fVerbose &&
			    NULL != pwszDisplayName &&
			    0 != lstrcmpi(pwszRevertCN, pwszDisplayName))
			{
			    wprintf(L"    %ws\n", pwszDisplayName);
			}
		    }

		    if (DSDF_DELETE & dwFlags)
		    {
			DeleteDN(pld, ppwszLdapVal[0], pwszDN);
		    }
		    else if (g_fVerbose || (DSDF_INFDUMP & dwFlags))
		    {
			dumpDSAttributes(pld, pres, dwFlags);
		    }
		    fFirst = FALSE;
		}
	    }
	    ldap_value_free(ppwszLdapVal);
	    ppwszLdapVal = NULL;
	}
    }
    if (!fFirst)
    {
	wprintf(wszNewLine);
    }

    if (DSDF_RECURSEONELEVEL & dwFlags)
    {
	for (pres = ldap_first_entry(pld, pmsg); 
	     NULL != pres;
	     pres = ldap_next_entry(pld, pres))
	{
	    CSASSERT(NULL == ppwszLdapVal);
	    ppwszLdapVal = ldap_get_values(pld, pres, CERTTYPE_PROP_CN);
	    if (NULL != ppwszLdapVal)
	    {
		if (NULL != ppwszLdapVal[0])
		{
		    hr = dumpDSDNs(
				pld,
				DSDF_ADDCNEQUALS |
				    (~DSDF_RECURSEONELEVEL & dwFlags),
				pwszAlternateCNAttribute,
				pwszCNMatch,
				ppwszLdapVal[0],
				pwszDN,
				NULL);
		    _PrintIfError(hr, "dumpDSDNs");
		}
		ldap_value_free(ppwszLdapVal);
		ppwszLdapVal = NULL;
	    }
	}
    }

error:
    if (NULL != ppwszLdapVal)
    {
	ldap_value_free(ppwszLdapVal);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    if (NULL != pwszOIDCN)
    {
	LocalFree(pwszOIDCN);
    }
    if (NULL != pwszDisplayName)
    {
	LocalFree(pwszDisplayName);
    }
    if (NULL != pwszAlternateCN)
    {
	LocalFree(pwszAlternateCN);
    }
    if (NULL != pwszRevertCN)
    {
	LocalFree(pwszRevertCN);
    }
    if (NULL != pwszDNAlloc)
    {
	LocalFree(pwszDNAlloc);
    }
    return(hr);
}


HRESULT
DumpOrDeleteFromDS(
    OPTIONAL IN WCHAR const *pwszCN,
    IN BOOL fDelete)
{
    HRESULT hr;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;
    DSDN *pDSDN;
    BOOL fFullDN = FALSE;
    WCHAR awcType[4];	// for "CN=\0"

    hr = myLdapOpen(&pld, &strDomainDN, &strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    if (NULL != pwszCN && ARRAYSIZE(awcType) - 1 <= wcslen(pwszCN))
    {
	CopyMemory(awcType, pwszCN, sizeof(awcType) - sizeof(WCHAR));
	awcType[ARRAYSIZE(awcType) - 1] = L'\0';
	if (0 == lstrcmpi(L"CN=", awcType))
	{
	    dumpDSDNs(
		pld,
		DSDF_BASE | (fDelete? DSDF_DELETE : 0),
		NULL,
		NULL,
		pwszCN,
		NULL,
		NULL);
	    fFullDN = TRUE;
	}
    }
    if (!fFullDN)
    {
	for (pDSDN = s_aDSDN; pDSDN < &s_aDSDN[ARRAYSIZE(s_aDSDN)]; pDSDN++)
	{
	    DWORD dwFlags = (DSDF_TYPEMASK | DSDF_RECURSEONELEVEL) & pDSDN->Flags;
	    if (fDelete)
	    {
		dwFlags |= DSDF_DELETE;
	    }
	    if (NULL == pDSDN->pwszChild || !fDelete)
	    {
		dumpDSDNs(
		    pld,
		    dwFlags,
		    pDSDN->pwszAlternateCNAttribute,
		    NULL != pwszCN? pwszCN : pDSDN->pwszChild,
		    pDSDN->pwszCN,
		    (DSDF_DOMAINDN & pDSDN->Flags)? strDomainDN : strConfigDN,
		    NULL);
	    }
	}
    }

error:
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
verbDS(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCN,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = DumpOrDeleteFromDS(pwszCN, FALSE);
    _JumpIfError(hr, error, "DumpOrDeleteFromDS");

error:
    return(hr);
}


HRESULT
verbDSDel(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCN,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    CSASSERT(NULL != pwszCN);

    hr = DumpOrDeleteFromDS(pwszCN, TRUE);
    _JumpIfError(hr, error, "DumpOrDeleteFromDS");

error:
    return(hr);
}


#define wszINFSECTION_TEMPLATELIST	L"TemplateList"
#define wszINFKEY_TEMPLATE		L"Template"

HRESULT
verbDSTemplate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;
    WCHAR **ppwszTemplates = NULL;
    WCHAR **ppwsz;

    hr = myLdapOpen(&pld, &strDomainDN, &strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    wprintf(
	L"[Version]\n"
	L"Signature = \"$Windows NT$\"\n"
	L"\n");

    dumpDSDNs(
	    pld,
	    DSDF_TEMPLATE | DSDF_INFDUMP,
	    CERTTYPE_PROP_OID,
	    pwszTemplate,
	    g_wszCNTemplates,
	    strConfigDN,
	    &ppwszTemplates);

    if (NULL != ppwszTemplates)
    {
	wprintf(L"[%ws]\n", wszINFSECTION_TEMPLATELIST);
	for (ppwsz = ppwszTemplates; NULL != *ppwsz; ppwsz++)
	{
	    wprintf(L"    %ws = \"%ws\"\n", wszINFKEY_TEMPLATE, *ppwsz);
	}
    }

error:
    if (NULL != ppwszTemplates)
    {
	for (ppwsz = ppwszTemplates; NULL != *ppwsz; ppwsz++)
	{
	    LocalFree(*ppwsz);
	}
	LocalFree(ppwszTemplates);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


typedef struct _CTFLAGS {
    DWORD dwOption;
    WCHAR const *pwszLookupName;
    WCHAR const *pwszPropName;
} CTFLAGS;

// The last entry has a prefix added to distinguish the name enough to display
// the correct symbolic names for its bit fields.  "flags" is too generic.

CTFLAGS g_actf[] = {
    {
	CERTTYPE_ENROLLMENT_FLAG,
	CERTTYPE_RPOP_ENROLLMENT_FLAG,
	CERTTYPE_RPOP_ENROLLMENT_FLAG,
    },
    {
	CERTTYPE_SUBJECT_NAME_FLAG,
	CERTTYPE_PROP_NAME_FLAG,
	CERTTYPE_PROP_NAME_FLAG,
    },
    {
	CERTTYPE_PRIVATE_KEY_FLAG,
	CERTTYPE_PROP_PRIVATE_KEY_FLAG,
	CERTTYPE_PROP_PRIVATE_KEY_FLAG,
    },
    {
	CERTTYPE_GENERAL_FLAG,
	wszCUREGDSTEMPLATEFLAGS,
	CERTTYPE_PROP_FLAGS,
    },
};


typedef struct _CTPROP {
    BOOL         fString;
    WCHAR const *pwszPropName;
} CTPROP;

CTPROP g_actProp[] = {
    { TRUE,  CERTTYPE_PROP_CN, },
    { TRUE,  CERTTYPE_PROP_DN, },
    { TRUE,  CERTTYPE_PROP_FRIENDLY_NAME, },
    { TRUE,  CERTTYPE_PROP_EXTENDED_KEY_USAGE, },
    { TRUE,  CERTTYPE_PROP_CSP_LIST, },
    { TRUE,  CERTTYPE_PROP_CRITICAL_EXTENSIONS, },
    { FALSE, CERTTYPE_PROP_REVISION, },
    { FALSE, CERTTYPE_PROP_SCHEMA_VERSION, },
    { FALSE, CERTTYPE_PROP_MINOR_REVISION, },
    { FALSE, CERTTYPE_PROP_RA_SIGNATURE, },
    { FALSE, CERTTYPE_PROP_MIN_KEY_SIZE, },
    { TRUE,  CERTTYPE_PROP_OID, },
    { TRUE,  CERTTYPE_PROP_SUPERSEDE, },
    { TRUE,  CERTTYPE_PROP_RA_POLICY, },
    { TRUE,  CERTTYPE_PROP_RA_APPLICATION_POLICY, },
    { TRUE,  CERTTYPE_PROP_POLICY, },
    { TRUE,  CERTTYPE_PROP_APPLICATION_POLICY, },
};


# if 0
BYTE ab0[sizeof(FILETIME)] =
{ 0x00, 0x80, 0x37, 0xae, 0xff, 0xf4, 0xff, 0xff }; // 2 Weeks


BYTE ab1[sizeof(FILETIME)] =
{ 0x00, 0x40, 0x39, 0x87, 0x2e, 0xe1, 0xfe, 0xff }; // 1 Years


BYTE ab2[sizeof(FILETIME)] =
{ 0x00, 0x80, 0x72, 0x0e, 0x5d, 0xc2, 0xfd, 0xff }; // 2 Years


BYTE ab3[sizeof(FILETIME)] =
{ 0x00, 0x40, 0x1e, 0xa4, 0xe8, 0x65, 0xfa, 0xff }; // 5 Years


void
dumpConstantValidityPeriod(
    FILETIME const *pft)
{
    if (1 < g_fVerbose)
    {
	wprintf(wszNewLine);
	cuDumpFileTimeOrPeriod(0, NULL, pft);
	DumpHex(
	    DH_NOADDRESS | DH_NOASCIIHEX | DH_NOTABPREFIX | 4,
	    (BYTE const *) pft,
	    sizeof(*pft));
	wprintf(wszNewLine);
    }
}

void
dumpConstantValidityPeriods()
{
    dumpConstantValidityPeriod((FILETIME const *) ab0);
    dumpConstantValidityPeriod((FILETIME const *) ab1);
    dumpConstantValidityPeriod((FILETIME const *) ab2);
    dumpConstantValidityPeriod((FILETIME const *) ab3);
}
#endif


HRESULT
dsDumpTemplateInfo(
    IN HCERTTYPE hCertType)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    DWORD dwValue;
    DWORD dwKeySpec;
    FILETIME ftExpiration;
    FILETIME ftOverlap;
    CERT_EXTENSIONS *pCertExtensions;

    for (i = 0; i < ARRAYSIZE(g_actf); i++)
    {
	hr = CAGetCertTypeFlagsEx(hCertType, g_actf[i].dwOption, &dwValue);
	if (S_OK != hr)
	{
	    _PrintError(hr, "CAGetCertTypeFlagsEx");
	}
	else
	{
	    cuRegPrintDwordValue(
			    TRUE,
			    g_actf[i].pwszLookupName,
			    g_actf[i].pwszPropName,
			    dwValue);
	}
    }
    for (i = 0; i < ARRAYSIZE(g_actProp); i++)
    {
	WCHAR **rgpwszPropValues;

	hr = CAGetCertTypePropertyEx(
			    hCertType,
			    g_actProp[i].pwszPropName,
			    g_actProp[i].fString?
				(VOID *) &rgpwszPropValues : &dwValue);
	if (S_OK != hr)
	{
	    _PrintError(hr, "CAGetCertTypePropertyEx");
	}
	else
	{
	    if (g_actProp[i].fString)
	    {
		cuRegPrintAwszValue(
			    g_actProp[i].pwszPropName,
			    rgpwszPropValues);

		CAFreeCertTypeProperty(hCertType, rgpwszPropValues);
	    }
	    else
	    {
		cuRegPrintDwordValue(
				TRUE,
				g_actProp[i].pwszPropName,
				g_actProp[i].pwszPropName,
				dwValue);
	    }
	}
    }
    hr = CAGetCertTypeKeySpec(hCertType, &dwKeySpec);
    if (S_OK != hr)
    {
	_PrintError(hr, "CAGetCertTypeKeySpec");
    }
    else
    {
	WCHAR const *pwsz = NULL;

	switch (dwKeySpec)
	{
	    case AT_SIGNATURE:   pwsz = L"AT_SIGNATURE";   break;
	    case AT_KEYEXCHANGE: pwsz = L"AT_KEYEXCHANGE"; break;
	}
	if (NULL != pwsz)
	{
	    wprintf(L"  dwKeySpec = %ws\n", pwsz);
	}
    }

    hr = CAGetCertTypeExpiration(hCertType, &ftExpiration, &ftOverlap);
    if (S_OK != hr)
    {
	_PrintError(hr, "CAGetCertTypeExpiration");
    }
    else
    {
	wprintf(L"  " CERTTYPE_PROP_EXPIRATION L" = ");
	cuDumpFileTimeOrPeriod(0, NULL, &ftExpiration);
	if (g_fVerbose)
	{
	    DumpHex(
		DH_NOADDRESS | DH_NOASCIIHEX | DH_NOTABPREFIX | 8,
		(BYTE const *) &ftExpiration,
		sizeof(ftExpiration));
	}

	wprintf(L"  " CERTTYPE_PROP_OVERLAP L" = ");
	cuDumpFileTimeOrPeriod(0, NULL, &ftOverlap);
	if (g_fVerbose)
	{
	    DumpHex(
		DH_NOADDRESS | DH_NOASCIIHEX | DH_NOTABPREFIX | 8,
		(BYTE const *) &ftOverlap,
		sizeof(ftOverlap));
	}
    }

    hr = CAGetCertTypeExtensions(hCertType, &pCertExtensions);
    if (S_OK != hr)
    {
	_PrintError(hr, "CAGetCertTypeExtensions");
    }
    else
    {
	wprintf(wszNewLine);
	hr = cuDumpExtensionArray(
			IDS_TEMPLATE_EXTENSIONS,
			pCertExtensions->cExtension,
			pCertExtensions->rgExtension);
	_PrintIfError(hr, "cuDumpExtensionArray");

	CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
dsDumpTemplate(
    OPTIONAL IN HCAINFO hCAInfo,
    OPTIONAL IN WCHAR const *pwszTemplate,
    OPTIONAL OUT WCHAR **ppwszTemplate)
{
    HRESULT hr;
    BOOL fFound = FALSE;
    WCHAR const *pwszDisplayName = NULL;
    HCERTTYPE hCertType = NULL;
    DWORD dwFlags = 0;
    WCHAR **apwszCertTypeName = NULL;
    WCHAR **apwszCertTypeCN = NULL;

    if (NULL != ppwszTemplate)
    {
	*ppwszTemplate = NULL;
    }
    if (!g_fUserTemplates && !g_fMachineTemplates)
    {
	g_fUserTemplates = TRUE;
	g_fMachineTemplates = TRUE;
    }
    if (g_fUserTemplates)
    {
	dwFlags |= CT_ENUM_USER_TYPES;
    }
    if (g_fMachineTemplates)
    {
	dwFlags |= CT_ENUM_MACHINE_TYPES;
    }
    if (!g_fUserRegistry)
    {
	dwFlags |= CT_FIND_LOCAL_SYSTEM;
    }
    if (g_fForce)
    {
	dwFlags |= CT_FLAG_NO_CACHE_LOOKUP;
    }

    if (NULL != pwszTemplate)
    {
	hr = CAFindCertTypeByName(pwszTemplate, hCAInfo, dwFlags, &hCertType);
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
	{
	    hr = CAFindCertTypeByName(
				pwszTemplate,
				hCAInfo,
				CT_FIND_BY_OID | dwFlags,
				&hCertType);
	}
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
			hr,
			"CAFindCertTypeByName",
			pwszTemplate,
			HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
	    pwszDisplayName = pwszTemplate;
	}
	else
	{
	    fFound = TRUE;
	}
    }
    if (NULL == pwszTemplate || NULL != pwszDisplayName)
    {
	if (NULL != hCAInfo)
	{
	    hr = CAEnumCertTypesForCA(hCAInfo, dwFlags, &hCertType);
	    _JumpIfError(hr, error, "CAEnumCertTypesForCA");

	    if (NULL == hCertType)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		_JumpError(hr, error, "CAEnumCertTypesForCA");
	    }
	}
	else
	{
	    hr = CAEnumCertTypes(dwFlags, &hCertType);
	    _JumpIfError(hr, error, "CAEnumCertTypes");

	    if (NULL == hCertType)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		_JumpError(hr, error, "CAEnumCertTypes");
	    }
	}
    }
    while (TRUE)
    {
	HCERTTYPE hCertTypeNext;
	WCHAR const *pwszError = NULL;

        hr = CAGetCertTypeProperty(
			    hCertType,
			    CERTTYPE_PROP_FRIENDLY_NAME,
			    &apwszCertTypeName);
	_JumpIfError(hr, error, "CAGetCertTypeProperty");

	hr = CAGetCertTypeProperty(
			    hCertType,
			    CERTTYPE_PROP_CN,
			    &apwszCertTypeCN);
	_JumpIfError(hr, error, "CAGetCertTypeProperty");

	if (NULL != pwszDisplayName &&
	    (0 == lstrcmpi(pwszDisplayName, apwszCertTypeName[0]) ||
	     0 == lstrcmpi(pwszDisplayName, apwszCertTypeCN[0])))
	{
	    fFound = TRUE;
	    if (NULL != ppwszTemplate)
	    {
		hr = myDupString(apwszCertTypeCN[0], ppwszTemplate);
		_JumpIfError(hr, error, "myDupString");

		break;
	    }
	}
        if (NULL == ppwszTemplate && (fFound || NULL == pwszDisplayName))
	{
	    hr = CACertTypeAccessCheck(hCertType, NULL);
	    if (S_OK != hr)
	    {
		pwszError = myGetErrorMessageText(hr, FALSE);
	    }
	    wprintf(L"%ws: %ws", apwszCertTypeCN[0], apwszCertTypeName[0]);
	    if (NULL != pwszError)
	    {
		wprintf(L" -- %ws", pwszError);
		LocalFree(const_cast<WCHAR *>(pwszError));
	    }
	    wprintf(wszNewLine);
	    if (g_fVerbose)
	    {
		BOOL fVerboseOld = g_fVerbose;

		g_fVerbose--;
		dsDumpTemplateInfo(hCertType);
		g_fVerbose = fVerboseOld;
	    }
	}
        CAFreeCertTypeProperty(hCertType, apwszCertTypeName);
        apwszCertTypeName = NULL;

        CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
        apwszCertTypeCN = NULL;

	if (fFound)
	{
	    break;
	}
	hr = CAEnumNextCertType(hCertType, &hCertTypeNext);
	_JumpIfError(hr, error, "CAEnumNextCertType");

	CACloseCertType(hCertType);
	hCertType = hCertTypeNext;
	if (NULL == hCertType)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != hCertType)
    {
	if (NULL != apwszCertTypeName)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeName);
	}
	if (NULL != apwszCertTypeCN)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
	}
	CACloseCertType(hCertType);
    }
    return(hr);
}


HRESULT
verbTemplate(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = dsDumpTemplate(NULL, pwszTemplate, NULL);
    _JumpIfError(hr, error, "dsDumpTemplate");

error:
    return(hr);
}


int
dsCompareMachineNames(
    IN WCHAR const *pwszServer,
    IN WCHAR const *pwszDnsName)
{
    HRESULT hr;
    WCHAR const *pwsz;
    WCHAR *pwszMachine = NULL;
    int rc;

    rc = lstrcmpi(pwszServer, pwszDnsName);
    if (0 != rc)
    {
	pwsz = wcschr(pwszDnsName, '.');
	if (NULL != pwsz)
	{
	    DWORD cb;

	    cb = SAFE_SUBTRACT_POINTERS(pwsz, pwszDnsName) * sizeof(WCHAR);

	    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pwszMachine)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
		goto error;
	    }
	    CopyMemory(pwszMachine, pwszDnsName, cb);
	    pwszMachine[cb / sizeof(WCHAR)] = L'\0';

	    rc = lstrcmpi(pwszServer, pwszMachine);
	}
    }

error:
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    return(rc);
}


// Display Templates for specified CA

HRESULT
verbCATemplates(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCAName = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszCANameRevert = NULL;
    WCHAR *pwszCANameSanitized = NULL;
    WCHAR *pwszCANameSanitizedDS = NULL;
    HCAINFO hCAInfo = NULL;
    DWORD dwFlags = CA_FIND_INCLUDE_UNTRUSTED;
    WCHAR **apwszMachine = NULL;
    BOOL fFound = FALSE;

    hr = mySplitConfigString(g_pwszConfig, &pwszServer, &pwszCAName);
    _JumpIfError(hr, error, "mySplitConfigString");

    hr = myRevertSanitizeName(pwszCAName, &pwszCANameRevert);
    _JumpIfError(hr, error, "myRevertSanitizeName");

    hr = mySanitizeName(pwszCANameRevert, &pwszCANameSanitized);
    _JumpIfError(hr, error, "mySanitizeName");

    hr = mySanitizedNameToDSName(pwszCANameSanitized, &pwszCANameSanitizedDS);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    if (!g_fUserRegistry)
    {
	dwFlags |= CA_FIND_LOCAL_SYSTEM;
    }
    hr = CAFindByName(
		pwszCANameSanitizedDS,
		NULL,	// wszScope
		dwFlags,
		&hCAInfo);
    _JumpIfErrorStr(hr, error, "CAFindByName", pwszCAName);

    while (TRUE)
    {
	HCAINFO hCAInfoNext;

	hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &apwszMachine);
	_JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DNSNAME)");

	if (0 == dsCompareMachineNames(pwszServer, apwszMachine[0]))
	{
	    fFound = TRUE;

	    hr = dsDumpTemplate(hCAInfo, pwszTemplate, NULL);
	    _JumpIfError(hr, error, "dsDumpTemplate");
	}

	CAFreeCAProperty(hCAInfo, apwszMachine);
	apwszMachine = NULL;

	hr = CAEnumNextCA(hCAInfo, &hCAInfoNext);
	_JumpIfError(hr, error, "CAEnumNextCA");

	CACloseCA(hCAInfo);
	hCAInfo = hCAInfoNext;
	if (NULL == hCAInfo)
	{
	    break;
	}
    }
    if (!fFound)
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpError(hr, error, "CAEnumNextCA");
    }
    hr = S_OK;

error:
    if (NULL != apwszMachine)
    {
	CAFreeCAProperty(hCAInfo, apwszMachine);
    }
    if (NULL != hCAInfo)
    {
	CACloseCA(hCAInfo);
    }
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszCAName)
    {
	LocalFree(pwszCAName);
    }
    if (NULL != pwszCANameRevert)
    {
	LocalFree(pwszCANameRevert);
    }
    if (NULL != pwszCANameSanitized)
    {
	LocalFree(pwszCANameSanitized);
    }
    if (NULL != pwszCANameSanitizedDS)
    {
	LocalFree(pwszCANameSanitizedDS);
    }
    return(hr);
}


HRESULT
dsCAFindByCertType(
    IN WCHAR const *pwszTemplate,
    IN DWORD dwFlags,
    OUT HCAINFO *phCAInfo)
{
    HRESULT hr;
    WCHAR const *pwszCertType = pwszTemplate;
    WCHAR *pwszAlloc = NULL;
    
    while (TRUE)
    {
	hr = CAFindByCertType(
			pwszCertType,
			NULL,		// wszScope
			dwFlags,
			phCAInfo);
	if (S_OK == hr)
	{
	    if (NULL == *phCAInfo)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		_JumpError(hr, error, "CAFindByCertType");
	    }
	    break;
	}
	_PrintErrorStr2(
		hr,
		"CAFindByCertType",
		pwszCertType,
		HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
	if (NULL != pwszAlloc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	    _JumpError(hr, error, "CAFindByCertType");
	}
	hr = dsDumpTemplate(NULL, pwszTemplate, &pwszAlloc);
	_JumpIfError(hr, error, "dsDumpTemplate");

	if (NULL == pwszAlloc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	    _JumpError(hr, error, "dsDumpTemplate");
	}
	pwszCertType = pwszAlloc;
    }

error:
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    return(hr);
}


// Display CAs for specified Template

HRESULT
verbTemplateCAs(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HCAINFO hCAInfo = NULL;
    DWORD dwFlags = CA_FIND_INCLUDE_UNTRUSTED;
    WCHAR **apwszMachine = NULL;
    WCHAR **apwszCommonName = NULL;

    if (!g_fUserRegistry)
    {
	dwFlags |= CA_FIND_LOCAL_SYSTEM;
    }
    hr = dsCAFindByCertType(pwszTemplate, dwFlags, &hCAInfo);
    _JumpIfError(hr, error, "dsCAFindByCertType");

    while (TRUE)
    {
	HCAINFO hCAInfoNext;
	WCHAR const *pwszError = NULL;

	hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &apwszMachine);
	_JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DNSNAME)");

	hr = CAGetCAProperty(
			hCAInfo,
			CA_PROP_DISPLAY_NAME,
			&apwszCommonName);
	_JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DISPLAY_NAME)");

	hr = CAAccessCheck(hCAInfo, NULL);
	if (S_OK != hr)
	{
	    pwszError = myGetErrorMessageText(hr, FALSE);
	}
	wprintf(L"%ws\\%ws", apwszMachine[0], apwszCommonName[0]);
	if (NULL != pwszError)
	{
	    wprintf(L" -- %ws", pwszError);
	    LocalFree(const_cast<WCHAR *>(pwszError));
	}
	wprintf(wszNewLine);

	CAFreeCAProperty(hCAInfo, apwszMachine);
	apwszMachine = NULL;

	CAFreeCAProperty(hCAInfo, apwszCommonName);
	apwszCommonName = NULL;

	hr = CAEnumNextCA(hCAInfo, &hCAInfoNext);
	_JumpIfError(hr, error, "CAEnumNextCA");

	CACloseCA(hCAInfo);
	hCAInfo = hCAInfoNext;
	if (NULL == hCAInfo)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != apwszMachine)
    {
	CAFreeCAProperty(hCAInfo, apwszMachine);
    }
    if (NULL != apwszCommonName)
    {
	CAFreeCAProperty(hCAInfo, apwszCommonName);
    }
    if (NULL != hCAInfo)
    {
	CACloseCA(hCAInfo);
    }
    return(hr);
}


typedef struct _MODTYPE
{
    WCHAR const *pwszAttributeName;
    DWORD        dwType;
} MODTYPE;

#define MT_STRING	0
#define MT_IGNORE	1
#define MT_TIMEPERIOD	2
#define MT_BINARY	3

const MODTYPE s_amtTemplateAttributes[] =
{
    { CERTTYPE_PROP_CN,		MT_IGNORE },
    { L"instanceType",		MT_IGNORE },
    { CERTTYPE_PROP_DN,		MT_IGNORE },
    { L"objectCategory",	MT_IGNORE },
    { L"objectGUID",		MT_IGNORE },
    { L"name",			MT_IGNORE },
    { L"showInAdvancedViewOnly",MT_IGNORE },
    { L"uSNChanged",		MT_IGNORE },
    { L"uSNCreated",		MT_IGNORE },
    { L"whenChanged",		MT_IGNORE },
    { L"whenCreated",		MT_IGNORE },
    { L"dSCorePropagationData",	MT_IGNORE },

    { CERTTYPE_PROP_EXPIRATION,	MT_TIMEPERIOD },
    { CERTTYPE_PROP_OVERLAP,	MT_TIMEPERIOD },
    { CERTTYPE_PROP_KU,		MT_BINARY },
    { NULL,			MT_STRING }
};


DWORD
ModType(
    IN WCHAR const *pwszName)
{
    MODTYPE const *pmt;

    for (pmt = s_amtTemplateAttributes; NULL != pmt->pwszAttributeName; pmt++)
    {
	if (0 == lstrcmpi(pwszName, pmt->pwszAttributeName))
	{
	    break;
	}
    }
    return(pmt->dwType);
}


HRESULT
ConvertBinaryValue(
    IN WCHAR const *pwszValue,
    OUT BERVAL **ppber)
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;

    hr = WszToMultiByteInteger(TRUE, pwszValue, &cb, &pb);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    *ppber = (BERVAL *) LocalAlloc(LMEM_FIXED, sizeof(**ppber));
    if (NULL == *ppber)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    (*ppber)->bv_len = cb;
    (*ppber)->bv_val = (char *) pb;
    pb = NULL;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
ParseTimePeriod(
    IN WCHAR const *pwszValue,
    OUT LONGLONG *pll)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszCount;
    WCHAR *pwszNext;
    LONGLONG ll;
    DWORD lHours;
    DWORD lMinutes;
    DWORD lSeconds;
    
    ll = 0;
    
    hr = myDupString(pwszValue, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszCount = pwszDup;
    while (TRUE)
    {
	BOOL fValid;
	WCHAR *pwszString;
	DWORD dwCount;
	enum ENUM_PERIOD enumPeriod;
	LONG lCount;

	while (L' ' == *pwszCount)
	{
	    pwszCount++;
	}
	pwszNext = wcschr(pwszCount, L',');
	if (NULL == pwszNext)
	{
	    if (L'\0' == *pwszCount || NULL != wcschr(pwszCount, L':'))
	    {
		break;
	    }
	    pwszNext = &pwszCount[wcslen(pwszCount)];
	    pwszString = pwszNext;
	}
	else
	{
	    pwszString = pwszNext;
	    *pwszNext++ = L'\0';
	}
	while (pwszString > pwszCount && L' ' == *--pwszString)
	{
	    *pwszString = L'\0';
	}

	pwszString = wcschr(pwszCount, L' ');
	if (NULL == pwszString)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "bad time period", pwszCount);
	}
	*pwszString++ = L'\0';
	while (L' ' == *pwszString)
	{
	    pwszString++;
	}
	//wprintf(L"Period: '%ws' '%ws'\n", pwszCount, pwszString);

	dwCount = myWtoI(pwszCount, &fValid);
	if (!fValid)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "bad time period digit");
	}

	hr = myTranslatePeriodUnits(pwszString, dwCount, &enumPeriod, &lCount);
	_JumpIfError(hr, error, "myTranslatePeriodUnits");

	if (0 != dwCount)
	{
	    if (ENUM_PERIOD_YEARS == enumPeriod)
	    {
		// "Years" is implemented without considering leap years.
	    
		ll += (LONGLONG) (lCount * 365 * CVT_DAYS) * CVT_BASE;
	    }
	    else if (ENUM_PERIOD_MONTHS == enumPeriod)
	    {
		// "Months" is implemented assuming 30 days per month
	    
		ll += (LONGLONG) (lCount * 30 * CVT_DAYS) * CVT_BASE;
	    }
	    else if (ENUM_PERIOD_WEEKS == enumPeriod)
	    {
		// "Months" is implemented assuming 7 days per week
	    
		ll += (LONGLONG) (lCount * 7 * CVT_DAYS) * CVT_BASE;
	    }
	    else
	    {
		myMakeExprDateTime((FILETIME *) &ll, lCount, enumPeriod);
	    }
	}
	pwszCount = pwszNext;
    }
    if (3 == swscanf(pwszCount, L"%u:%02u:%02u", &lHours, &lMinutes, &lSeconds))
    {
	if (0 != lHours)
	{
	    myMakeExprDateTime((FILETIME *) &ll, lHours, ENUM_PERIOD_HOURS);
	}
	if (0 != lMinutes)
	{
	    myMakeExprDateTime((FILETIME *) &ll, lMinutes, ENUM_PERIOD_MINUTES);
	}
	if (0 != lSeconds)
	{
	    myMakeExprDateTime((FILETIME *) &ll, lSeconds, ENUM_PERIOD_SECONDS);
	}
    }
    *pll = -ll;
    hr = S_OK;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
ConvertTimePeriodValue(
    IN WCHAR const *pwszValue,
    OUT BERVAL **ppber)
{
    HRESULT hr;
    LONGLONG ll;
    BYTE *pb = NULL;

    hr = ParseTimePeriod(pwszValue, &ll);
    _JumpIfError(hr, error, "ParseTimePeriod");

    pb = (BYTE *) LocalAlloc(LMEM_FIXED, sizeof(ll));
    if (NULL == pb)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pb, &ll, sizeof(ll));

    *ppber = (BERVAL *) LocalAlloc(LMEM_FIXED, sizeof(**ppber));
    if (NULL == *ppber)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    (*ppber)->bv_len = sizeof(ll);
    (*ppber)->bv_val = (char *) pb;
    pb = NULL;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


VOID
FreeMods(
    IN DWORD cmod,
    LDAPMod *rgmod)
{
    DWORD imod;
    DWORD ival;
    
    if (NULL != rgmod)
    {
	for (imod = 0; imod < cmod; imod++)
	{
	    if (LDAP_MOD_BVALUES & rgmod[imod].mod_op)
	    {
		BERVAL **rgpber = rgmod[imod].mod_bvalues;

		if (NULL != rgpber)
		{
		    for (ival = 0; NULL != rgpber[ival]; ival++)
		    {
			if (rgpber[ival]->bv_val)
			{
			    LocalFree(rgpber[ival]->bv_val);
			}
			LocalFree(rgpber[ival]);
		    }
		    LocalFree(rgpber);
		}
	    }
	    else
	    {
		WCHAR **rgpwsz = rgmod[imod].mod_values;

		if (NULL != rgpwsz)
		{
		    for (ival = 0; NULL != rgpwsz[ival]; ival++)
		    {
			LocalFree(rgpwsz[ival]);
		    }
		    LocalFree(rgpwsz);
		}
	    }
	}
	LocalFree(rgmod);
    }
}


HRESULT
ConvertInfValuesToMods(
    IN DWORD cInfValues,
    INFVALUES const *rgInfValues,
    OUT WCHAR **ppwszCN,
    OUT DWORD *pcmod,
    OUT LDAPMod **prgmod)
{
    HRESULT hr;
    LDAPMod *rgmod = NULL;
    DWORD cmod = 0;
    DWORD imod;
    DWORD i;
    WCHAR *pwszCN = NULL;

    *ppwszCN = NULL;
    *prgmod = NULL;
    for (i = 0; i < cInfValues; i++)
    {
	if (MT_IGNORE != ModType(rgInfValues[i].pwszKey))
	{
	    cmod++;
	}
    }

    rgmod = (LDAPMod *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cmod * sizeof(rgmod[0]));
    if (NULL == rgmod)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    imod = 0;
    for (i = 0; i < cInfValues; i++)
    {
	INFVALUES const *pInfValues = &rgInfValues[i];
	DWORD dwType = ModType(pInfValues->pwszKey);
	WCHAR **ppwsz = NULL;
	BERVAL **ppber = NULL;
	DWORD ival;

	if (NULL != ppwszCN &&
	    NULL == pwszCN &&
	    0 == lstrcmpi(CERTTYPE_PROP_CN, pInfValues->pwszKey))
	{
	    hr = myDupString(pInfValues->rgpwszValues[0], &pwszCN);
	    _JumpIfError(hr, error, "myDupString");
	}
	if (MT_IGNORE != dwType)
	{
	    rgmod[imod].mod_op = LDAP_MOD_REPLACE;
	    rgmod[imod].mod_type = pInfValues->pwszKey;

	    if (MT_STRING == dwType)
	    {
		ppwsz = (WCHAR **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				(pInfValues->cValues + 1) * sizeof(ppwsz[0]));
		if (NULL == ppwsz)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		rgmod[imod].mod_values = ppwsz;
	    }
	    else
	    {
		ppber = (BERVAL **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				(pInfValues->cValues + 1) * sizeof(ppber[0]));
		if (NULL == ppber)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		rgmod[imod].mod_op |= LDAP_MOD_BVALUES;
		rgmod[imod].mod_bvalues = ppber;
	    }

	    for (ival = pInfValues->cValues; ival > 0; ival--)
	    {
		WCHAR const *pwszValue = pInfValues->rgpwszValues[ival - 1];
		
		switch (dwType)
		{
		    case MT_BINARY:
			hr = ConvertBinaryValue(pwszValue, ppber);
			_JumpIfErrorStr(
				    hr,
				    error,
				    "ConvertBinaryValue",
				    pInfValues->pwszKey);

			ppber++;
			CSASSERT(NULL == *ppber);
			break;

		    case MT_TIMEPERIOD:
			hr = ConvertTimePeriodValue(pwszValue, ppber);
			_JumpIfErrorStr(
				    hr,
				    error,
				    "ConvertTimePeriodValue",
				    pInfValues->pwszKey);

			ppber++;
			CSASSERT(NULL == *ppber);
			break;

		    default:
			CSASSERT(MT_STRING == dwType);
			hr = myDupString(pwszValue, ppwsz);
			_JumpIfErrorStr(
				    hr,
				    error,
				    "myDupString",
				    pInfValues->pwszKey);

			ppwsz++;
			CSASSERT(NULL == *ppwsz);
			break;
		}
	    }
	    imod++;
	}
    }
    CSASSERT(imod == cmod);
    *pcmod = cmod;
    *prgmod = rgmod;
    rgmod = NULL;
    if (NULL != ppwszCN)
    {
	*ppwszCN = pwszCN;
	pwszCN = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszCN)
    {
	LocalFree(pwszCN);
    }
    if (NULL != rgmod)
    {
	FreeMods(cmod, rgmod);
    }
    return(hr);
}


HRESULT
dsAddTemplate(
    IN HINF hInf,
    IN WCHAR const *pwszTemplate,
    IN OUT BSTR *pstrConfigDN,
    IN OUT LDAP **ppld)
{
    HRESULT hr;
    ULONG ldaperr;
    DWORD cInfValues;
    INFVALUES *rgInfValues = NULL;
    DWORD cmod;
    LDAPMod *rgmod = NULL;
    LDAPMod **rgpmod = NULL;
    DWORD imod;
    DWORD ival;
    WCHAR *pwszDNContainer = NULL;
    WCHAR *pwszDNTemplate = NULL;
    WCHAR *pwszCNAlloc = NULL;
    WCHAR const *pwszCN;
    UINT idmsg;
    WCHAR *pwszError = NULL;
    
    hr = myInfGetSectionValues(
			hInf,
			pwszTemplate,
			&cInfValues,
			&rgInfValues);
    _JumpIfError(hr, error, "myInfGetSectionValues");

    hr = ConvertInfValuesToMods(
			cInfValues,
			rgInfValues,
			&pwszCNAlloc,
			&cmod,
			&rgmod);
    _JumpIfError(hr, error, "ConvertInfValuesToMods");

    rgpmod = (LDAPMod **) LocalAlloc(
				LMEM_FIXED,
				(cmod + 3) * sizeof(rgpmod[0]));
    if (NULL == rgpmod)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    for (imod = 0; imod < cmod; imod++)
    {
	rgpmod[imod] = &rgmod[imod];
    }
    rgpmod[imod] = NULL;

    pwszCN = pwszCNAlloc;
    if (NULL == pwszCN)
    {
	pwszCN = pwszTemplate;
    }

    if (g_fVerbose)
    {
	for (imod = 0; NULL != rgpmod[imod]; imod++)
	{
	    WCHAR const *pwszSep = L"";
	    
	    wprintf(L"%ws =", rgpmod[imod]->mod_type);

	    if (LDAP_MOD_BVALUES & rgmod[imod].mod_op)
	    {
		BERVAL **ppber = rgpmod[imod]->mod_bvalues;

		wprintf(wszNewLine);
		for (ival = 0; NULL != ppber[ival]; ival++)
		{
		    DumpHex(
			DH_NOADDRESS | DH_NOTABPREFIX | 8,
			(BYTE const *) ppber[ival]->bv_val,
			ppber[ival]->bv_len);
		    wprintf(wszNewLine);
		}
	    }
	    else
	    {
		WCHAR **ppwsz = rgpmod[imod]->mod_values;

		for (ival = 0; NULL != ppwsz[ival]; ival++)
		{
		    wprintf(L"%ws \"%ws\"", pwszSep, ppwsz[ival]);
		    pwszSep = L",";
		}
		wprintf(wszNewLine);
	    }
	    if (1 < ival)
	    {
		wprintf(wszNewLine);
	    }
	}
    }

    if (NULL == *pstrConfigDN)
    {
	hr = myLdapOpen(ppld, NULL, pstrConfigDN);
	_JumpIfError(hr, error, "myLdapOpen");
    }
    CSASSERT(NULL != *pstrConfigDN);
    CSASSERT(NULL != *ppld);

    hr = BuildDN(g_wszCNTemplates, *pstrConfigDN, FALSE, &pwszDNContainer);
    _JumpIfError(hr, error, "BuildDN");

    hr = BuildDN(pwszCN, pwszDNContainer, TRUE, &pwszDNTemplate);
    _JumpIfError(hr, error, "BuildDN");

    DBGPRINT((DBG_SS_CERTUTILI, "Template DN: %ws\n", pwszDNTemplate));

    idmsg = IDS_CREATED_TEMPLATE;	// "Created DS Template"
    ldaperr = ldap_add_ext_s(*ppld, pwszDNTemplate, rgpmod, NULL, NULL);
    hr = myHLdapError3(
		    *ppld,
		    ldaperr,
		    LDAP_ALREADY_EXISTS,
		    LDAP_OBJECT_CLASS_VIOLATION,
		    &pwszError);
    _PrintIfErrorStr(hr, "ldap_add_ext_s", pwszCN);

    if (LDAP_ALREADY_EXISTS == ldaperr ||
	LDAP_OBJECT_CLASS_VIOLATION == ldaperr)
    {
	if (NULL != pwszError)
	{
	    LocalFree(pwszError);
	    pwszError = NULL;
	}
	for (imod = 0; NULL != rgpmod[imod]; imod++)
	{
	    rgmod[imod].mod_op =
		LDAP_MOD_REPLACE | (LDAP_MOD_BVALUES & rgmod[imod].mod_op);
	}
	idmsg = IDS_UPDATED_TEMPLATE;	// "Updated DS Template"
        ldaperr = ldap_modify_ext_s(*ppld, pwszDNTemplate, rgpmod, NULL, NULL);
        if (LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
        {
            ldaperr = LDAP_SUCCESS;
        }
	hr = myHLdapError(*ppld, ldaperr, &pwszError);
        _PrintIfErrorStr(hr, "ldap_modify_ext_s", pwszCN);
    }
    _JumpIfErrorStr(hr, error, "Add/Update", pwszCN);

    wprintf(L"%ws: %ws\n", myLoadResourceString(idmsg), pwszCN);
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pwszCNAlloc)
    {
	LocalFree(pwszCNAlloc);
    }
    if (NULL != pwszDNContainer)
    {
	LocalFree(pwszDNContainer);
    }
    if (NULL != pwszDNTemplate)
    {
	LocalFree(pwszDNTemplate);
    }
    if (NULL != rgpmod)
    {
	LocalFree(rgpmod);
    }
    if (NULL != rgmod)
    {
	FreeMods(cmod, rgmod);
    }
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }
    return(hr);
}


HRESULT
verbDSAddTemplate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnTemplateInf,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    BOOL fCritical;
    WCHAR *pwszzTemplateList = NULL;
    WCHAR const *pwsz;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;

    hr = myInfOpenFile(pwszfnTemplateInf, &hInf, &ErrorLine);
    _JumpIfError(hr, error, "myInfOpenFIle");

    hr = myInfGetKeyList(
		    hInf,
		    wszINFSECTION_TEMPLATELIST,
		    wszINFKEY_TEMPLATE,
		    &fCritical,
		    &pwszzTemplateList);
    _JumpIfErrorStr(hr, error, "myInfGetKeyList", wszINFSECTION_TEMPLATELIST);

    for (pwsz = pwszzTemplateList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	wprintf(L"[%ws]\n", pwsz);
	hr = dsAddTemplate(hInf, pwsz, &strConfigDN, &pld);
	_JumpIfError(hr, error, "dsAddTemplate");
    }

error:
    if (NULL != pwszzTemplateList)
    {
	LocalFree(pwszzTemplateList);
    }
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    myLdapClose(pld, NULL, strConfigDN);
    return(hr);
}


HRESULT
dsGetCommonName(
    IN CERT_NAME_BLOB const *pNameBlob,
    IN BOOL fAllowDefault,
    OUT WCHAR **ppwszCN)
{
    HRESULT hr;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    CERT_RDN *prdn;
    CERT_RDN *prdnEnd;
    WCHAR const *pwszCN = NULL;

    *ppwszCN = NULL;
    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	NULL == pwszCN && prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    CSASSERT(
		prdna->dwValueType == CERT_RDN_PRINTABLE_STRING ||
		prdna->dwValueType == CERT_RDN_UNICODE_STRING ||
		prdna->dwValueType == CERT_RDN_TELETEX_STRING ||
		prdna->dwValueType == CERT_RDN_IA5_STRING ||
		prdna->dwValueType == CERT_RDN_UTF8_STRING);

	    if (0 != strcmp(szOID_COMMON_NAME, prdna->pszObjId) ||
		NULL == prdna->Value.pbData ||
		sizeof(WCHAR) > prdna->Value.cbData ||
		L'\0' == *(WCHAR *) prdna->Value.pbData)
	    {
		continue;
	    }
	    pwszCN = (WCHAR const *) prdna->Value.pbData;
	    break;
        }
    }
    if (NULL == pwszCN)
    {
	if (!fAllowDefault)
	{
	    hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	    _JumpError(hr, error, "No CN");
	}
	pwszCN = L"Default";	// default CN
    }
    hr = myDupString(pwszCN, ppwszCN);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


#define DSP_OBJECT_NTAUTHCERT		0x00000001
#define DSP_OBJECT_ROOTTRUST		0x00000002
#define DSP_OBJECT_AIA			0x00000004
#define DSP_OBJECT_KRA			0x00000008
#define DSP_OBJECT_MASK			0x000000ff

#define DSP_ATTRIBUTE_CACERTIFICATE	0x00000100
#define DSP_ATTRIBUTE_USERCERTIFICATE	0x00000200
#define DSP_ATTRIBUTE_CROSSCERTPAIR	0x00000400
#define DSP_ATTRIBUTE_MASK		0x0000ff00

#define DSP_TYPE_KRACERT		0x00010000
#define DSP_TYPE_EECERT			0x00020000
#define DSP_TYPE_ROOTCACERT		0x00040000
#define DSP_TYPE_SUBCACERT		0x00080000
#define DSP_TYPE_MASK			0x00ff0000


typedef struct _DSOBJECTMAP {
    DWORD ObjectFlags;
    WCHAR const *pwszTemplate;
} DSOBJECTMAP;

DSOBJECTMAP s_rgObjectMap[] = {
    { DSP_OBJECT_NTAUTHCERT, g_wszLDAPNTAuthURLTemplate },
    { DSP_OBJECT_ROOTTRUST,  g_wszLDAPRootTrustURLTemplate },
    { DSP_OBJECT_AIA,        g_wszzLDAPIssuerCertURLTemplate },
    { DSP_OBJECT_KRA,        g_wszzLDAPKRACertURLTemplate },
};


HRESULT
dsPublishCert(
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszSanitizedCN,
    IN DWORD dspFlags,
    IN DWORD dwObjectType)
{
    HRESULT hr;
    WCHAR const *pwszAttribute;
    WCHAR *pwszServerName = NULL;	// Shouldn't be necessary
    WCHAR *pwszURL = NULL;
    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    DWORD dwDisposition;
    DWORD i;
    WCHAR *pwszError = NULL;

    hr = myGetMachineDnsName(&pwszServerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");
    
    hr = myLdapOpen(&pld, &strDomainDN, &strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    switch (DSP_ATTRIBUTE_MASK & dspFlags)
    {
	case DSP_ATTRIBUTE_CACERTIFICATE:
	    pwszAttribute = wszDSCACERTATTRIBUTE;
	    break;

	case DSP_ATTRIBUTE_USERCERTIFICATE:
	    pwszAttribute = wszDSUSERCERTATTRIBUTE;
	    break;

	case DSP_ATTRIBUTE_CROSSCERTPAIR:
	    pwszAttribute = wszDSCROSSCERTPAIRATTRIBUTE;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad attribute indicator");
    }

    for (i = 0; i < ARRAYSIZE(s_rgObjectMap); i++)
    {
	WCHAR const *pwszTemplate;

	if (0 == (s_rgObjectMap[i].ObjectFlags & DSP_OBJECT_MASK & dspFlags))
	{
	    continue;
	}
	pwszTemplate = s_rgObjectMap[i].pwszTemplate;

	hr = myFormatCertsrvStringArray(
				FALSE,		// fURL
				pwszServerName,	// pwszServerName_p1_2
				pwszSanitizedCN,// pwszSanitizedName_p3_7
				0,		// iCert_p4
				strDomainDN,	// pwszDomainDN_p5
				strConfigDN,	// pwszConfigDN_p6
				0,		// iCRL_p8
				FALSE,		// fDeltaCRL_p9
				FALSE,		// fDSAttrib_p10_11
				1,		// cStrings
				&pwszTemplate,	// apwszStringsIn
				&pwszURL);	// apwszStringsOut
	_JumpIfError(hr, error, "myFormatCertsrvStringArray");

	wprintf(L"%ws?%ws\n\n", pwszURL, pwszAttribute);

	if (g_fForce)
	{
	    dwObjectType |= LPC_CREATECONTAINER | LPC_CREATEOBJECT;
	}

	hr = myLdapPublishCertToDS(
			    pld,
			    pccPublish,
			    pwszURL,
			    pwszAttribute,
			    dwObjectType,
			    &dwDisposition,
			    &pwszError);
	_JumpIfError(hr, error, "myLdapPublishCertToDS");

	if (LDAP_SUCCESS == dwDisposition)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ADDED_TO_DS_STORE), // "%ws added to DS store."
		myLoadResourceString(IDS_CERTIFICATE)); // "Certificate"
	}
	else 
	{
	    CSASSERT(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwDisposition);
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ALREADY_IN_DS_STORE), // "%ws already in DS store."
		myLoadResourceString(IDS_CERTIFICATE)); // "Certificate"
	}
	wprintf(wszNewLine);
	wprintf(wszNewLine);

	LocalFree(pwszURL);
	pwszURL = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    if (NULL != pwszServerName)
    {
	LocalFree(pwszServerName);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
dsPublishCRL(
    OPTIONAL IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN BOOL fDelta,
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    WCHAR const *pwszAttribute;
    LDAP *pldT = NULL;
    DWORD dwDisposition;
    UINT idMsg = fDelta? IDS_PROP_DELTACRL : IDS_PROP_BASECRL;
    WCHAR *pwszError = NULL;

    pwszAttribute = fDelta? wszDSDELTACRLATTRIBUTE : wszDSBASECRLATTRIBUTE;
    wprintf(L"%ws?%ws\n\n", pwszURL, pwszAttribute);

    if (NULL == pld)
    {
	hr = myLdapOpen(&pldT, NULL, NULL);
	_JumpIfError(hr, error, "myLdapOpen");

	pld = pldT;
    }

    hr = myLdapPublishCRLToDS(
			pld,
			pCRLPublish,
			pwszURL,
			pwszAttribute,
			&dwDisposition,
			&pwszError);
    _JumpIfError(hr, error, "myLdapPublishCRLToDS");

    if (LDAP_SUCCESS == dwDisposition)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_ADDED_TO_DS_STORE), // "%ws added to DS store."
	    myLoadResourceString(idMsg));
    }
    else
    {
	CSASSERT(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwDisposition);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_ALREADY_IN_DS_STORE), // "%ws already in DS store."
	    myLoadResourceString(idMsg));
    }
    wprintf(wszNewLine);
    wprintf(wszNewLine);
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    myLdapClose(pldT, NULL, NULL);
    return(hr);
}


HRESULT
IsCrossCACert(
    IN CERT_CONTEXT const *pCertContext,
    OUT BOOL *pfCrossCA)
{
    HRESULT hr;
    WCHAR *pwszObjId = NULL;
    HCERTTYPE hCertType = NULL;
    DWORD dwValue;

    *pfCrossCA = FALSE;

    // CrossCA is a V2 template, so only fetch the template OID

    hr = cuGetCertType(
		pCertContext->pCertInfo,
		NULL,		// ppwszCertTypeNameV1
		NULL,		// ppwszDisplayNameV1
		&pwszObjId,	// ppwszCertTypeObjId
		NULL,		// ppwszCertTypeName
		NULL);		// ppwszDisplayName
    if (S_OK != hr || NULL == pwszObjId)
    {
	_PrintIfError2(hr, "cuGetCertType", CRYPT_E_NOT_FOUND);
	if (CRYPT_E_NOT_FOUND == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }
    hr = CAFindCertTypeByName(pwszObjId, NULL, CT_FIND_BY_OID, &hCertType);
    if (S_OK != hr)
    {
	_PrintErrorStr2(hr, "CAFindCertTypeByName", pwszObjId, hr);
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    _JumpErrorStr(hr, error, "CAFindCertTypeByName", pwszObjId);
	}
    }
    else
    {
	hr = CAGetCertTypeFlagsEx(hCertType, CERTTYPE_GENERAL_FLAG, &dwValue);
	_JumpIfError(hr, error, "CAGetCertTypeFlagsEx");

	if (CT_FLAG_IS_CROSS_CA & dwValue)
	{
	    *pfCrossCA = TRUE;
	}
    }
    hr = S_OK;

error:
    if (NULL != hCertType)
    {
	CACloseCertType(hCertType);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
IsCACert(
    IN CERT_CONTEXT const *pCertContext,
    OUT BOOL *pfCA)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;
    
    *pfCA = FALSE;
    pExt = CertFindExtension(
		    szOID_BASIC_CONSTRAINTS2,
		    pCertContext->pCertInfo->cExtension,
		    pCertContext->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	CERT_BASIC_CONSTRAINTS2_INFO Constraints;
	DWORD cb;

	cb = sizeof(Constraints);
	if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_BASIC_CONSTRAINTS2,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    &Constraints,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptDecodeObject");
	}
	*pfCA = Constraints.fCA;
    }
    hr = S_OK;

error:
    return(hr);
}


char const *g_apszKRAObjIds[] = {
    szOID_KP_KEY_RECOVERY_AGENT,
    szOID_EFS_RECOVERY,
    szOID_KP_KEY_RECOVERY,
};


HRESULT
IsKRACert(
    IN CERT_CONTEXT const *pCertContext,
    OUT BOOL *pfKRA)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;
    CERT_ENHKEY_USAGE *pKeyUsage = NULL;
    CERT_POLICIES_INFO *pPolicies = NULL;
    DWORD cb;
    DWORD i;
    DWORD j;
    
    *pfKRA = FALSE;
    pExt = CertFindExtension(
		    szOID_ENHANCED_KEY_USAGE,
		    pCertContext->pCertInfo->cExtension,
		    pCertContext->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_ENHANCED_KEY_USAGE,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pKeyUsage,
			&cb))
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "myDecodeObject");
	}
	for (i = 0; i < pKeyUsage->cUsageIdentifier; i++)
	{
	    char const *pszObjId = pKeyUsage->rgpszUsageIdentifier[i];

	    for (j = 0; j < ARRAYSIZE(g_apszKRAObjIds); j++)
	    {
		if (0 == strcmp(
			    pszObjId,
			    g_apszKRAObjIds[j]))
		{
		    *pfKRA = TRUE;
		    hr = S_OK;
		    goto error;
		}
	    }
	}
    }

    pExt = CertFindExtension(
		    szOID_APPLICATION_CERT_POLICIES,
		    pCertContext->pCertInfo->cExtension,
		    pCertContext->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT_POLICIES,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pPolicies,
			&cb))
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "myDecodeObject");
	}
	for (i = 0; i < pPolicies->cPolicyInfo; i++)
	{
	    CERT_POLICY_INFO *pPolicyInfo = &pPolicies->rgPolicyInfo[i];

	    for (j = 0; j < ARRAYSIZE(g_apszKRAObjIds); j++)
	    {
		if (0 == strcmp(
			    pPolicyInfo->pszPolicyIdentifier,
			    g_apszKRAObjIds[j]))
		{
		    *pfKRA = TRUE;
		    hr = S_OK;
		    goto error;
		}
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pKeyUsage)
    {
	LocalFree(pKeyUsage);
    }
    if (NULL != pPolicies)
    {
	LocalFree(pPolicies);
    }
    return(hr);
}

	
HRESULT
dsPublishCertFromContext(
    IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN WCHAR const *pwszType)
{
    HRESULT hr;
    BOOL fCrossCA;
    BOOL fCA;
    BOOL fKRA;
    BOOL fRoot;
    DWORD dspFlags;
    DWORD dwObjectType;
    WCHAR *pwszCN = NULL;
    WCHAR const *pwszSanitizedCN = NULL;
    WCHAR *pwszSanitizedCNAlloc = NULL;

    // If a CrossCA cert, publish to the Subject CN's AIA container.
    // If a CA cert, publish to the Subject CN's AIA container.
    // If a KRA cert, publish to the Issuer CN's KRA container.
    
    hr = IsCrossCACert(pCertContext, &fCrossCA);
    if (S_OK != hr)
    {
	_PrintError(hr, "IsCrossCACert");
	if (NULL == pwszType && !g_fForce)
	{
	    goto error;
	}
    }

    hr = IsCACert(pCertContext, &fCA);
    _JumpIfError(hr, error, "IsCACert");

    hr = IsKRACert(pCertContext, &fKRA);
    _JumpIfError(hr, error, "IsKRACert");

    fRoot = CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &pCertContext->pCertInfo->Subject,
			    &pCertContext->pCertInfo->Issuer);

    dwObjectType = LPC_CAOBJECT;
    if (NULL == pwszType || 0 == lstrcmp(L"-", pwszType))
    {
	if (fCrossCA)
	{
	    // Don't publish to "Certification Authorities" (root CAs)
	    // because Win2k crypt32 can't handle zero byte cACertificate
	    // attributes, and aborts processing valid roots.

	    dspFlags = DSP_OBJECT_AIA |
			    //DSP_OBJECT_ROOTTRUST |
			    DSP_ATTRIBUTE_CROSSCERTPAIR |
			    DSP_TYPE_SUBCACERT;
	}
	else
	if (fCA)
	{
	    dspFlags = DSP_OBJECT_AIA | DSP_ATTRIBUTE_CACERTIFICATE;
	    if (fRoot)
	    {
		dspFlags |= DSP_OBJECT_ROOTTRUST;
	    }
	}
	else
	if (fKRA)
	{
	    dspFlags = DSP_OBJECT_KRA | DSP_ATTRIBUTE_USERCERTIFICATE;
	    dwObjectType = LPC_KRAOBJECT;
	}
#if 0
	// publish User or Machine certs
	dwObjectType = LPC_USEROBJECT;
	dwObjectType = LPC_MACHINEOBJECT;
#endif
	else
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "non-CA, non-KRA cert");
	}
    }
    else
    {
	if (0 == lstrcmpi(L"NTAuthCA", pwszType))
	{
	    dspFlags = DSP_OBJECT_NTAUTHCERT |
			    DSP_ATTRIBUTE_CACERTIFICATE |
			    DSP_TYPE_ROOTCACERT |
			    DSP_TYPE_SUBCACERT;
	    pwszSanitizedCN = L"NTAuthCertificates";
	}
	else
	if (0 == lstrcmpi(L"RootCA", pwszType))
	{
	    dspFlags = DSP_OBJECT_AIA |
			    DSP_OBJECT_ROOTTRUST |
			    DSP_ATTRIBUTE_CACERTIFICATE |
			    DSP_TYPE_ROOTCACERT;
	}
	else
	if (0 == lstrcmpi(L"SubCA", pwszType))
	{
	    dspFlags = DSP_OBJECT_AIA |
			    DSP_ATTRIBUTE_CACERTIFICATE |
			    DSP_TYPE_SUBCACERT;
	}
	else
	if (0 == lstrcmpi(L"CrossCA", pwszType))
	{
	    // Don't publish to "Certification Authorities" (root CAs)
	    // because Win2k crypt32 can't handle zero byte cACertificate
	    // attributes, and aborts processing valid roots.

	    dspFlags = DSP_OBJECT_AIA |
			    //DSP_OBJECT_ROOTTRUST |
			    DSP_ATTRIBUTE_CROSSCERTPAIR |
			    DSP_TYPE_SUBCACERT;
	}
	else
	if (0 == lstrcmpi(L"KRA", pwszType))
	{
	    dspFlags = DSP_OBJECT_KRA |
			    DSP_ATTRIBUTE_USERCERTIFICATE |
			    DSP_TYPE_KRACERT | 
			    DSP_TYPE_EECERT;
	    dwObjectType = LPC_KRAOBJECT;
	}
#if 0
	else
	if (0 == lstrcmpi(L"User", pwszType))
	{
	    dspFlags = DSP_OBJECT_USER |
			    DSP_ATTRIBUTE_USERCERTIFICATE |
			    DSP_TYPE_EECERT;
	    dwObjectType = LPC_USEROBJECT;
	}
	else
	if (0 == lstrcmpi(L"Machine", pwszType))
	{
	    dspFlags = DSP_OBJECT_MACHINE |
			    DSP_ATTRIBUTE_USERCERTIFICATE |
			    DSP_TYPE_EECERT;
	    dwObjectType = LPC_MACHINEOBJECT;
	}
#endif
	else
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "pwszType", pwszType);
	}
	if (!fKRA && (DSP_TYPE_KRACERT & dspFlags))
	{
	    _PrintError(S_OK, "forcing KRA");
	}
	if (fCA && (DSP_TYPE_EECERT & dspFlags))
	{
	    _PrintError(S_OK, "forcing non-CA");
	}
	if (!fCA &&
	    ((DSP_TYPE_ROOTCACERT | DSP_TYPE_SUBCACERT) & dspFlags))
	{
	    _PrintError(S_OK, "forcing CA");
	}
	if (!fRoot &&
	    DSP_TYPE_ROOTCACERT ==
		((DSP_TYPE_ROOTCACERT | DSP_TYPE_SUBCACERT) & dspFlags))
	{
	    _PrintError(S_OK, "forcing Root");
	}
    }
    if (NULL == pwszSanitizedCN)
    {
	hr = dsGetCommonName(
		    fCA?
			&pCertContext->pCertInfo->Subject :
			&pCertContext->pCertInfo->Issuer,
		    TRUE,
		    &pwszCN);
	_JumpIfError(hr, error, "dsGetCommonName");

	hr = mySanitizeName(pwszCN, &pwszSanitizedCNAlloc);
	_JumpIfError(hr, error, "mySanitizeName");

	pwszSanitizedCN = pwszSanitizedCNAlloc;
    }
    hr = dsPublishCert(
		pCertContext,
		pwszSanitizedCN,
		dspFlags,
		dwObjectType);
    _JumpIfError(hr, error, "dsPublishCert");

error:
    if (NULL != pwszCN)
    {
	LocalFree(pwszCN);
    }
    if (NULL != pwszSanitizedCNAlloc)
    {
	LocalFree(pwszSanitizedCNAlloc);
    }
    return(hr);
}


HRESULT
dsPublishCRLFromContext(
    IN CRL_CONTEXT const *pCRLContext,
    IN BOOL fDelta)
{
    HRESULT hr;
    HRESULT hr2;
    CRL_DIST_POINTS_INFO *pcdp = NULL;
    CERT_EXTENSION *pExt;
    WCHAR *pwszURL = NULL;
    DWORD cb;
    DWORD i;
    DWORD j;

    pExt = CertFindExtension(
		    szOID_CRL_SELF_CDP,
		    pCRLContext->pCrlInfo->cExtension,
		    pCRLContext->pCrlInfo->rgExtension);
    if (NULL == pExt && !fDelta)
    {
	pExt = CertFindExtension(
			szOID_FRESHEST_CRL,
			pCRLContext->pCrlInfo->cExtension,
			pCRLContext->pCrlInfo->rgExtension);
    }
    if (NULL == pExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "CertFindExtension");
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    pExt->Value.pbData,
		    pExt->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcdp,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = S_OK;
    for (i = 0; i < pcdp->cDistPoint; i++)
    {
	CRL_DIST_POINT const *pDistPoint = &pcdp->rgDistPoint[i];

	if (CRL_DIST_POINT_FULL_NAME !=
	    pDistPoint->DistPointName.dwDistPointNameChoice)
	{
	    continue;
	}
	for (j = 0; j < pDistPoint->DistPointName.FullName.cAltEntry; j++)
	{
	    CERT_ALT_NAME_ENTRY const *pAltNameEntry = &pDistPoint->DistPointName.FullName.rgAltEntry[j];

#define wszLDAPCOLON	L"ldap:"
	    WCHAR awcLDAP[ARRAYSIZE(wszLDAPCOLON)];

	    if (CERT_ALT_NAME_URL != pAltNameEntry->dwAltNameChoice)
	    {
		continue;
	    }
	    if (ARRAYSIZE(awcLDAP) > wcslen(pAltNameEntry->pwszURL))
	    {
		continue;
	    }
	    CopyMemory(awcLDAP, pAltNameEntry->pwszURL, sizeof(awcLDAP));
	    awcLDAP[ARRAYSIZE(awcLDAP) - 1] = L'\0';
	    if (0 != lstrcmpi(wszLDAPCOLON, awcLDAP))
	    {
		continue;
	    }

	    if (NULL != pwszURL)
	    {
		LocalFree(pwszURL);
		pwszURL = NULL;
	    }

	    hr2 = myInternetUncanonicalizeURL(pAltNameEntry->pwszURL, &pwszURL);
	    _PrintIfError(hr2, "myInternetUncanonicalizeURL");
	    if (S_OK == hr)
	    {
		hr = hr2;		// Save first error
	    }

	    hr2 = dsPublishCRL(
			NULL,
			pCRLContext,
			fDelta,
			NULL != pwszURL? pwszURL : pAltNameEntry->pwszURL);
	    _PrintIfError(hr2, "dsPublishCRL");
	    if (S_OK == hr)
	    {
		hr = hr2;		// Save first error
	    }
	}
	_JumpIfError(hr, error, "dsPublishCRL");
    }

error:
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != pcdp)
    {
	LocalFree(pcdp);
    }
    return(hr);
}


HRESULT
dsPublishCRLFromParms(
    IN CRL_CONTEXT const *pCRLContext,
    IN BOOL fDelta,
    IN WCHAR const *pwszServerName,
    OPTIONAL IN WCHAR const *pwszSanitizedCN)
{
    HRESULT hr;
    WCHAR *pwszServerNameAlloc = NULL;	// Shouldn't be necessary
    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    WCHAR *pwszCN = NULL;
    WCHAR *pwszSanitizedCNAlloc = NULL;
    WCHAR *pwszURL = NULL;
    DWORD iCert = 0;
    DWORD iCRL = 0;
    WCHAR const *pwszTemplate;

    if (NULL == pwszServerName)
    {
	hr = myGetMachineDnsName(&pwszServerNameAlloc);
	_JumpIfError(hr, error, "myGetMachineDnsName");

	pwszServerName = pwszServerNameAlloc;
    }
    
    hr = myLdapOpen(&pld, &strDomainDN, &strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    if (NULL == pwszSanitizedCN)
    {
	CERT_EXTENSION *pExt;

	hr = dsGetCommonName(&pCRLContext->pCrlInfo->Issuer, FALSE, &pwszCN);
	_JumpIfError(hr, error, "dsGetCommonName");

	hr = mySanitizeName(pwszCN, &pwszSanitizedCNAlloc);
	_JumpIfError(hr, error, "mySanitizeName");

	pwszSanitizedCN = pwszSanitizedCNAlloc;

	pExt = CertFindExtension(
			szOID_CERTSRV_CA_VERSION,
			pCRLContext->pCrlInfo->cExtension,
			pCRLContext->pCrlInfo->rgExtension);
	if (NULL != pExt)
	{
	    DWORD NameId;
	    DWORD cb;

	    cb = sizeof(NameId);
	    NameId = 0;
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_INTEGER,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    &NameId,
			    &cb))
	    {
                hr = myHLastError();
		_JumpError(hr, error, "CryptDecodeObject");
	    }
	    iCert = CANAMEIDTOICERT(NameId);
	    iCRL = CANAMEIDTOIKEY(NameId);
	}
    }

    pwszTemplate = g_wszzLDAPRevocationURLTemplate;
    hr = myFormatCertsrvStringArray(
			    FALSE,		// fURL
			    pwszServerName,	// pwszServerName_p1_2
			    pwszSanitizedCN,	// pwszSanitizedName_p3_7
			    iCert,		// iCert_p4
			    strDomainDN,	// pwszDomainDN_p5
			    strConfigDN,	// pwszConfigDN_p6
			    iCRL,		// iCRL_p8
			    fDelta,		// fDeltaCRL_p9
			    FALSE,		// fDSAttrib_p10_11
			    1,			// cStrings
			    &pwszTemplate,	// apwszStringsIn
			    &pwszURL);		// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    hr = dsPublishCRL(pld, pCRLContext, fDelta, pwszURL);
    _JumpIfError(hr, error, "dsPublishCRL");

error:
    if (NULL != pwszCN)
    {
	LocalFree(pwszCN);
    }
    if (NULL != pwszSanitizedCNAlloc)
    {
	LocalFree(pwszSanitizedCNAlloc);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != pwszServerNameAlloc)
    {
	LocalFree(pwszServerNameAlloc);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


// pwszType: NTAuthCA | RootCA | SubCA | CrossCA | KRA | User | Machine
// pwszDSCDPContainer: machine name

HRESULT
verbDSPublish(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfn,
    OPTIONAL IN WCHAR const *pwszTypeOrDSCDPContainer,
    OPTIONAL IN WCHAR const *pwszDSCN,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertContext = NULL;
    CRL_CONTEXT const *pCRLContext = NULL;

    CSASSERT(NULL != pwszfn);
    hr = cuLoadCert(pwszfn, &pCertContext);
    if (S_OK == hr)
    {
	if (NULL != pwszDSCN)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "non-NULL CDP parms");
	}
	hr = dsPublishCertFromContext(pCertContext, pwszTypeOrDSCDPContainer);
	_JumpIfError(hr, error, "dsPublishCertFromContext");
    }
    else
    {
	CERT_EXTENSION *pExt;
	BOOL fDelta;

	hr = cuLoadCRL(pwszfn, &pCRLContext);
	if (S_OK != hr)
	{
	    cuPrintError(IDS_FORMAT_LOADCERTORCRL, hr);
#if 1
	    WCHAR *pwszURL = NULL;
	    HRESULT hr2 = myInternetUncanonicalizeURL(pwszfn, &pwszURL);
	    _PrintIfError(hr2, "myInternetUncanonicalizeURL");
	    if (NULL != pwszURL)
	    {
		LocalFree(pwszURL);
	    }
#endif
	    goto error;
	}
	pExt = CertFindExtension(
			szOID_DELTA_CRL_INDICATOR,
			pCRLContext->pCrlInfo->cExtension,
			pCRLContext->pCrlInfo->rgExtension);
	fDelta = NULL != pExt;

	if (NULL != pwszTypeOrDSCDPContainer)
	{
	    hr = dsPublishCRLFromParms(
				pCRLContext,
				fDelta,
				pwszTypeOrDSCDPContainer,
				pwszDSCN);
	    _JumpIfError(hr, error, "dsPublishCRLFromParms");
	}
	else
	{
	    hr = dsPublishCRLFromContext(pCRLContext, fDelta);
	    _JumpIfError(hr, error, "dsPublishCRLFromContext");
	}
    }

error:
    cuUnloadCRL(&pCRLContext);
    cuUnloadCert(&pCertContext);
    return(hr);
}


HRESULT
dsDumpOIDDisplayNames(
    IN LDAP *pld,
    IN WCHAR const *pwszOIDDN,
    IN WCHAR const *pwszObjId,
    IN DWORD dwLanguageId,
    IN OUT DWORD *pdwType,
    OUT BOOL *pfObjectExists,
    OUT BOOL *pfLangIdExists,
    OPTIONAL OUT WCHAR ***pppwszLdapVal)
{
    HRESULT hr;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    DWORD cres;
    WCHAR **ppwszLdapVal = NULL;
    
    *pfObjectExists = FALSE;
    *pfLangIdExists = FALSE;
    if (NULL != pppwszLdapVal)
    {
	*pppwszLdapVal = NULL;
    }
    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;
    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszOIDDN),	// base
		LDAP_SCOPE_BASE,
		NULL,				// filter
		NULL,				// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	hr = myHLdapError2(pld, hr, LDAP_NO_SUCH_OBJECT, NULL);
	_PrintErrorStr2(
		hr,
		"ldap_search_st",
		pwszOIDDN,
		HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND));
	if (HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND) != hr)
	{
	    goto error;
	}
    }
    else
    {
	cres = ldap_count_entries(pld, pmsg);
	if (0 != cres)
	{
	    for (pres = ldap_first_entry(pld, pmsg); 
		 NULL != pres && NULL == ppwszLdapVal; 
		 pres = ldap_next_entry(pld, pres))
	    {
		DWORD i;
		
		ppwszLdapVal = ldap_get_values(pld, pres, OID_PROP_OID);
		if (NULL != ppwszLdapVal)
		{
		    if (NULL != ppwszLdapVal[0] &&
			0 == lstrcmp(pwszObjId, ppwszLdapVal[0]))
		    {
			*pfObjectExists = TRUE;
		    }
		    ldap_value_free(ppwszLdapVal);
		    ppwszLdapVal = NULL;
		}
		if (*pfObjectExists)
		{
		    ppwszLdapVal = ldap_get_values(pld, pres, OID_PROP_TYPE);
		    if (NULL != ppwszLdapVal)
		    {
			if (NULL != ppwszLdapVal[0])
			{
			    DWORD dw = _wtoi(ppwszLdapVal[0]);

			    if (*pdwType != dw)
			    {
				if (MAXDWORD != *pdwType)
				{
				    wprintf(myLoadResourceString(IDS_TYPE_MISMATCH)); // "Type mismatch"
				    wprintf(wszNewLine);
				    hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
				    _JumpError(hr, error, "*pdwType mismatch");
				}
				*pdwType = dw;
			    }
			}
			ldap_value_free(ppwszLdapVal);
			ppwszLdapVal = NULL;
		    }

		    i = 0;
		    ppwszLdapVal = ldap_get_values(
					    pld,
					    pres,
					    OID_PROP_LOCALIZED_NAME);
		    if (NULL != ppwszLdapVal)
		    {
			for ( ; NULL != ppwszLdapVal[i]; i++)
			{
			    wprintf(L"  %u: %ws\n", i, ppwszLdapVal[i]);
			    if (!*pfLangIdExists)
			    {
				hr = myLdapOIDIsMatchingLangId(
						ppwszLdapVal[i],
						dwLanguageId,
						pfLangIdExists);
				_PrintIfError(hr, "myLdapOIDIsMatchingLangId");
			    }
			}
		    }
		    if (0 == i)
		    {
			wprintf(myLoadResourceString(IDS_NO_DISPLAY_NAMES)); // "No display names"
			wprintf(wszNewLine);
		    }
		    break;
		}
	    }
	}
    }
    if (NULL != pppwszLdapVal)
    {
	*pppwszLdapVal = ppwszLdapVal;
	ppwszLdapVal = NULL;
    }
    hr = S_OK;

error:
    if (NULL != ppwszLdapVal)
    {
	ldap_value_free(ppwszLdapVal);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


// Set OID_PROP_LOCALIZED_NAME on the appropriate OID object under g_wszCNOID.

HRESULT
verbOIDName(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszObjId,
    OPTIONAL IN WCHAR const *pwszDisplayName,
    OPTIONAL IN WCHAR const *pwszLanguageId,
    OPTIONAL IN WCHAR const *pwszType)
{
    HRESULT hr;
    DWORD dwLanguageId;
    DWORD dwType;
    WCHAR const *pwszName;
    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    WCHAR *pwszOIDCN = NULL;
    WCHAR *pwszOIDContainer = NULL;
    WCHAR *pwszOIDDN = NULL;
    WCHAR **ppwszLdapVal = NULL;
    BOOL fObjectExists = FALSE;
    BOOL fLangIdExists = FALSE;
    WCHAR *pwszError = NULL;
    
    if (NULL != pwszLanguageId)
    {
	hr = cuGetLong(pwszLanguageId, (LONG *) &dwLanguageId);
	_JumpIfError(hr, error, "dwLanguageId must be a number");

	if (64 * 1024 <= dwLanguageId)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwLanguageId too large");
	}
    }
    else
    {
	dwLanguageId = GetSystemDefaultLangID();
    }

    if (NULL != pwszType)
    {
	hr = cuGetLong(pwszType, (LONG *) &dwType);
	_JumpIfError(hr, error, "dwType must be a number");
    }
    else
    {
	dwType = MAXDWORD;
    }

    hr = myVerifyObjId(pwszObjId);
    if (S_OK != hr)
    {
	wprintf(myLoadResourceString(IDS_INVALID_OBJECTID)); // "Invalid ObjectId"
	wprintf(wszNewLine);
	_JumpError(hr, error, "myVerifyObjId");
    }
    pwszName = cuGetOIDName(pwszObjId);
    if (S_OK == hr || L'\0' != *pwszName)
    {
	if (L'\0' == *pwszName)
	{
	    pwszName = myLoadResourceString(IDS_UNKNOWN_OBJECTID); // "Unknown ObjectId"
	}
	wprintf(L"%ws -- %ws\n", pwszObjId, pwszName);
    }

    hr = myOIDHashOIDToString(pwszObjId, &pwszOIDCN);
    _JumpIfError(hr, error, "myOIDHashOIDToString");

    hr = myLdapOpen(&pld, &strDomainDN, &strConfigDN);
    if (S_OK != hr)
    {
	_PrintError2(hr, "myLdapOpen", HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));
	if (NULL == pwszDisplayName)
	{
	    hr = S_OK;
	}
	goto error;
    }

    hr = BuildDN(g_wszCNOID, strConfigDN, FALSE, &pwszOIDContainer);
    _JumpIfError(hr, error, "BuildDN");

    hr = BuildDN(pwszOIDCN, pwszOIDContainer, TRUE, &pwszOIDDN);
    _JumpIfError(hr, error, "BuildDN");

    hr = dsDumpOIDDisplayNames(
			pld,
			pwszOIDDN,
			pwszObjId,
			dwLanguageId,
			&dwType,
			&fObjectExists,
			&fLangIdExists,
			&ppwszLdapVal);
    _JumpIfError(hr, error, "dsDumpOIDDisplayNames");

    if (NULL != pwszDisplayName)
    {
	DWORD dwDisposition;

	if (!fObjectExists && !g_fForce)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "ldap_first/next_entry");
	}
	if (fLangIdExists && !g_fForce)
	{
	    hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
	    _JumpError(hr, error, "ldap_get_values");
	}
	//wprintf(L"%u: %u,%ws\n", dwType, dwLanguageId, pwszDisplayName);
	if (!fObjectExists)
	{
	    if (MAXDWORD == dwType)
	    {
		dwType = CERT_OID_TYPE_TEMPLATE;
	    }
	    hr = myLdapCreateOIDObject(
			    pld,
			    pwszOIDDN,
			    dwType,
			    pwszObjId,
			    &dwDisposition,
			    &pwszError);
	    _JumpIfError(hr, error, "myLdapCreateOIDObject");

	    CSASSERT(NULL == pwszError);
	}
	hr = myLdapAddOIDDisplayNameToAttribute(
				    pld,
				    ppwszLdapVal,
				    dwLanguageId,
				    pwszDisplayName,
				    pwszOIDDN,
				    OID_PROP_LOCALIZED_NAME,
				    &dwDisposition,
				    &pwszError);
	_JumpIfError(hr, error, "myLdapAddOIDDisplayNameToAttribute");

	wprintf(wszNewLine);
	if (LDAP_SUCCESS == dwDisposition)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ADDED_TO_DS_STORE), // "%ws added to DS store."
		myLoadResourceString(IDS_LOCALIZEDNAME)); // "Localized name"
	    wprintf(wszNewLine);

	    hr = dsDumpOIDDisplayNames(
				pld,
				pwszOIDDN,
				pwszObjId,
				dwLanguageId,
				&dwType,
				&fObjectExists,
				&fLangIdExists,
				NULL);	// pppwszLdapVal
	    _JumpIfError(hr, error, "dsDumpOIDDisplayNames");
	}
	else 
	{
	    CSASSERT(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwDisposition);
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ALREADY_IN_DS_STORE), // "%ws already in DS store."
		myLoadResourceString(IDS_LOCALIZEDNAME)); // "Localized name"
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    if (NULL != ppwszLdapVal)
    {
	ldap_value_free(ppwszLdapVal);
    }
    if (NULL != pwszOIDCN)
    {
	LocalFree(pwszOIDCN);
    }
    if (NULL != pwszOIDDN)
    {
	LocalFree(pwszOIDDN);
    }
    if (NULL != pwszOIDContainer)
    {
	LocalFree(pwszOIDContainer);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


typedef struct _QUERY_INFO
{
    WCHAR const *pwszInfo;
    DWORD        dwInfo;
} QUERY_INFO;


QUERY_INFO g_rgQueryInfo[] = {
#if 0
    L"HTTP_QUERY_MIME_VERSION-Req",
        HTTP_QUERY_MIME_VERSION | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    L"HTTP_QUERY_CONTENT_TYPE-Req",
        HTTP_QUERY_CONTENT_TYPE | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    L"HTTP_QUERY_CONTENT_TRANSFER_ENCODING-Req",
        HTTP_QUERY_CONTENT_TRANSFER_ENCODING | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    L"HTTP_QUERY_CONTENT_LENGTH-Req",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_REQUEST_HEADERS,
#endif

    L"HTTP_QUERY_MIME_VERSION", HTTP_QUERY_MIME_VERSION,
    L"HTTP_QUERY_CONTENT_TYPE", HTTP_QUERY_CONTENT_TYPE,
    L"HTTP_QUERY_CONTENT_TRANSFER_ENCODING",
        HTTP_QUERY_CONTENT_TRANSFER_ENCODING,
    L"HTTP_QUERY_CONTENT_LENGTH", HTTP_QUERY_CONTENT_LENGTH,
    L"HTTP_QUERY_CONTENT_LENGTH-Num",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,

    L"HTTP_QUERY_VERSION", HTTP_QUERY_VERSION, 
    L"HTTP_QUERY_STATUS_CODE", HTTP_QUERY_STATUS_CODE, 
    L"HTTP_QUERY_STATUS_CODE-Num",
        HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
    L"HTTP_QUERY_STATUS_TEXT", HTTP_QUERY_STATUS_TEXT, 
    L"HTTP_QUERY_RAW_HEADERS", HTTP_QUERY_RAW_HEADERS, 
    L"HTTP_QUERY_RAW_HEADERS_CRLF", HTTP_QUERY_RAW_HEADERS_CRLF, 
    L"HTTP_QUERY_CONTENT_ENCODING", HTTP_QUERY_CONTENT_ENCODING, 
    L"HTTP_QUERY_LOCATION", HTTP_QUERY_LOCATION, 
    L"HTTP_QUERY_ORIG_URI", HTTP_QUERY_ORIG_URI, 
    L"HTTP_QUERY_REQUEST_METHOD", HTTP_QUERY_REQUEST_METHOD, 
    L"HTTP_QUERY_DATE",
        HTTP_QUERY_DATE | HTTP_QUERY_FLAG_SYSTEMTIME,
    L"HTTP_QUERY_EXPIRES",
        HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME,
    L"HTTP_QUERY_LAST_MODIFIED",
        HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME,
};


HRESULT
DisplayQueryInfo(
    IN HINTERNET hInternetFile)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < ARRAYSIZE(g_rgQueryInfo); i++)
    {
	QUERY_INFO *pQuery = &g_rgQueryInfo[i];
        DWORD dwIndex;
        BOOL fFirst;

        fFirst = TRUE;
        dwIndex = 0;
        while (TRUE)
	{
            BYTE rgbBuf[MAX_CACHE_ENTRY_INFO_SIZE];
            DWORD cbBuf;
            DWORD dwThisIndex = dwIndex;
            BOOL fResult;
            DWORD dwValue;
            SYSTEMTIME st;
    
            if (HTTP_QUERY_FLAG_NUMBER & pQuery->dwInfo)
	    {
                cbBuf = sizeof(dwValue);
                fResult = HttpQueryInfo(
				hInternetFile,
				pQuery->dwInfo,
				&dwValue,
				&cbBuf,
				&dwIndex);
            }
	    else
	    if (HTTP_QUERY_FLAG_SYSTEMTIME & pQuery->dwInfo)
	    {
                cbBuf = sizeof(st);
                fResult = HttpQueryInfo(
				hInternetFile,
				pQuery->dwInfo,
				&st,
				&cbBuf,
				&dwIndex);
            }
            else
	    {
		ZeroMemory(rgbBuf, sizeof(rgbBuf));
		cbBuf = sizeof(rgbBuf);

                fResult = HttpQueryInfo(
				hInternetFile,
				pQuery->dwInfo,
				rgbBuf,
				&cbBuf,
				&dwIndex);
	    }
            if (!fResult)
	    {
                hr = myHLastError();
                if (fFirst ||
		    HRESULT_FROM_WIN32(ERROR_HTTP_HEADER_NOT_FOUND) != hr)
		{
		    _PrintErrorStr(hr, "HttpQueryInfo", pQuery->pwszInfo);
		}
		break;
            }

	    if (HTTP_QUERY_FLAG_NUMBER & pQuery->dwInfo)
	    {
                wprintf(
		    L"%ws[%d] = %x (%d)\n",
                    pQuery->pwszInfo,
		    dwThisIndex,
		    dwValue,
		    dwValue);
            }
	    else
	    if (HTTP_QUERY_FLAG_SYSTEMTIME & pQuery->dwInfo)
	    {
                FILETIME ft;

                if (!SystemTimeToFileTime(&st, &ft))
		{
                    hr = myHLastError();
		    _JumpErrorStr(
			    hr,
			    error,
			    "SystemTimeToFileTime",
			    pQuery->pwszInfo);
                }
		else
		{
                    wprintf(L"%ws[%d] =", pQuery->pwszInfo, dwThisIndex);
		    hr = cuDumpFileTime(0, NULL, &ft);
		    wprintf(wszNewLine);
		    _PrintIfError(hr, "cuDumpFileTime");
		}
            }
	    else
	    {
                wprintf(L"%ws[%d] =\n", pQuery->pwszInfo, dwThisIndex);
		DumpHex(0, (BYTE const *) rgbBuf, cbBuf);
            }
            fFirst = FALSE;
            if (dwThisIndex == dwIndex)
	    {
#if 0
                wprintf(
		    L"HttpQueryInfo(%ws) dwIndex not advanced\n",
                    pQuery->pwszInfo);
#endif
                break;
            }
        }
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DisplayCacheEntryInfo(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    DWORD cbCachEntryInfo;
    BYTE rgbCachEntryInfo[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo =
        (INTERNET_CACHE_ENTRY_INFO *) &rgbCachEntryInfo[0];

    cbCachEntryInfo = sizeof(rgbCachEntryInfo);
    if (!GetUrlCacheEntryInfo(pwszURL, pCacheEntryInfo, &cbCachEntryInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetUrlCacheEntryInfo");
    }
    wprintf(
	L"GetUrlCacheEntryInfo: %d %ws\n",
	cbCachEntryInfo,
	myLoadResourceString(IDS_BYTES));

    if (0 != cbCachEntryInfo)
    {
	wprintf(g_wszPad2);
    wprintf(myLoadResourceString(IDS_FORMAT_SOURCE_URL), pCacheEntryInfo->lpszSourceUrlName);
    wprintf(wszNewLine);
        
	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LOCAL_FILENAME), pCacheEntryInfo->lpszLocalFileName);
    wprintf(wszNewLine);


	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_USE_COUNT), pCacheEntryInfo->dwUseCount);
    wprintf(wszNewLine);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_HIT_RATE), pCacheEntryInfo->dwHitRate);
    wprintf(wszNewLine);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_FILE_SIZE), pCacheEntryInfo->dwSizeLow);
    wprintf(wszNewLine);


	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LAST_MOD_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->LastModifiedTime);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_EXPIRE_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->ExpireTime);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LAST_ACCESS_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->LastAccessTime);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LAST_SYNC_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->LastSyncTime);
    }
    hr = S_OK;

error:
    return(hr);
}



typedef struct _DATABLOCK {
    struct _DATABLOCK *pNext;
    DWORD	       cbData;
    BYTE	       abData[1];
} DATABLOCK;


HRESULT
AddDataBlock(
    IN BYTE *pb,
    IN DWORD cb,
    IN OUT DATABLOCK **ppData)
{
    HRESULT hr;
    DATABLOCK *pData = NULL;

    pData = (DATABLOCK *) LocalAlloc(LMEM_FIXED, sizeof(*pData) + cb);
    if (NULL == pData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pData->pNext = *ppData;
    pData->cbData = cb;
    CopyMemory(pData->abData, pb, cb);
    *ppData = pData;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ReadURL(
    HINTERNET hInternetFile)
{
    HRESULT hr;
    BYTE *pb = NULL;
    BYTE *pb2;
    DWORD cb;
    DWORD cbRead;
    DATABLOCK *pData = NULL;
    DATABLOCK *pData2;

    cb = 0;
    if (!InternetQueryDataAvailable(
				hInternetFile,
				&cb,
				0,	// dwFlags
				0))	// dwContext
    {
	hr = myHLastError();
        _PrintError(hr, "InternetQueryDataAvailable");
    }

    cb = 0;
    while (TRUE)
    {
	BYTE ab[4096];

	if (!InternetReadFile(hInternetFile, ab, sizeof(ab), &cbRead))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "InternetReadFile");
	}
	if (0 == cbRead)
	{
	    break;
	}
	hr = AddDataBlock(ab, cbRead, &pData);
	_JumpIfError(hr, error, "AddDataBlock");

	cb += cbRead;
    }

    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == pb)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pb2 = &pb[cb];
    for (pData2 = pData; NULL != pData2; pData2 = pData2->pNext)
    {
	pb2 -= pData2->cbData;
	CSASSERT(pb2 >= pb);
	CopyMemory(pb2, pData2->abData, pData2->cbData);
    }
    CSASSERT(pb2 == pb);

    hr = cuDumpAsnBinary(pb, cb, MAXDWORD);
    if (S_OK != hr)
    {
	_PrintError(hr, "cuDumpAsnBinary");
	DumpHex(0, pb, cb);
    }
    hr = S_OK;

error:
    while (NULL != pData)
    {
	pData2 = pData;
	pData = pData->pNext;
	LocalFree(pData2);
    }
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
verbURLCache(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszDelete,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;

    if (NULL != pwszDelete)
    {
	if (0 != lstrcmpi(L"Delete", pwszDelete))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad delete arg");
	}
	if (!DeleteUrlCacheEntry(pwszURL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "DeleteUrlCacheEntry");
	}
    }
    else
    {
	DWORD dwFlags = g_fForce? INTERNET_FLAG_RELOAD : INTERNET_FLAG_OFFLINE;

	wprintf(
	    L"****  %ws  ****\n",
	    g_fForce? L"ONLINE" : L"OFFLINE");

	hInternetSession = InternetOpen(
			    L"CRL Agent",		  // lpszAgent
			    INTERNET_OPEN_TYPE_PRECONFIG, // dwAccessType
			    NULL,			  // lpszProxy
			    NULL,			  // lpszProxyBypass
			    dwFlags);
	if (NULL == hInternetSession)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "InternetOpen");
	}

	hInternetFile = InternetOpenUrl(
			    hInternetSession,
			    pwszURL,
			    L"Accept: */*\r\n",		// lpszHeaders
			    MAXDWORD,			// dwHeadersLength
			    dwFlags | INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
			    0);				// dwContext
	if (NULL == hInternetFile)
	{
	    hr = myHLastError();
	    _PrintError(GetLastError(), "InternetOpenUrl");
	    _JumpError(hr, error, "InternetOpenUrl");
	}

	if (g_fForce)
	{
	    if (g_fVerbose)
	    {
		hr = DisplayCacheEntryInfo(pwszURL);
		_PrintIfError(hr, "DisplayCacheEntryInfo");
	    }
	}
	else
	{
	    if (g_fVerbose)
	    {
		hr = DisplayQueryInfo(hInternetFile);
		_PrintIfError(hr, "DisplayQueryInfo");
	    }
	}
	hr = ReadURL(hInternetFile);
	_PrintIfError(hr, "ReadURL");

	if (!g_fForce && g_fVerbose)
	{
	    hr = DisplayCacheEntryInfo(pwszURL);
	    _PrintIfError(hr, "DisplayCacheEntryInfo");
	}
    }
    hr = S_OK;

error:
    if (NULL != hInternetFile)
    {
	if (!InternetCloseHandle(hInternetFile))
	{
	    hr2 = myHLastError();
	    _PrintError(hr2, "InternetCloseHandle");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    if (NULL != hInternetSession)
    {
	if (!InternetCloseHandle(hInternetSession))
	{
	    hr2 = myHLastError();
	    _PrintError(hr2, "InternetCloseHandle(Session)");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    return(hr);
}


HRESULT
verbPulse(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HANDLE hEventAE = NULL;

    hEventAE = OpenEvent(
                    EVENT_MODIFY_STATE,
                    FALSE,
                    MACHINE_AUTOENROLLMENT_TRIGGER_EVENT);
    if (NULL == hEventAE)
    {
        hr = myHLastError();
	_JumpError(hr, error, "OpenEvent");
    }
    if (!PulseEvent(hEventAE))
    {
        hr = myHLastError();
	_JumpError(hr, error, "PulseEvent");
    }
    hr = S_OK;

error:
    if (NULL != hEventAE)
    {
        CloseHandle(hEventAE);
    }
    return(hr);
}


// This function gets the group membership for a given machine...

HRESULT
cuGetGroupMembership(
    IN WCHAR const *pwszSamName)
{
    HRESULT hr;
    WCHAR *pwszDomain = NULL;
    WCHAR *pwszMachine = NULL;
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    GROUP_USERS_INFO_0 *pgui0 = NULL;
    DWORD cGroup;
    DWORD cGroupTotal;
    DWORD i;
   
    hr = mySplitConfigString(pwszSamName, &pwszDomain, &pwszMachine);
    _JumpIfError(hr, error, "mySplitConfigString");

    if (NULL == pwszMachine || NULL == wcschr(pwszMachine, L'$'))
    {
        wprintf(myLoadResourceString(IDS_ERROR_CHECK_MACHINE_NAME));
        wprintf(wszNewLine);
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad machine name");
    }
    hr = DsGetDcName(
		NULL,
		pwszDomain,
		NULL,
		NULL,
		DS_RETURN_FLAT_NAME,
		&pDCInfo);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "DsGetDcName");
    }

    hr = NetUserGetGroups(
                pDCInfo->DomainControllerName,
                pwszMachine,
                0,			// level
                (BYTE **) &pgui0,
                MAX_PREFERRED_LENGTH,	// prefmaxlen
                &cGroup,
                &cGroupTotal);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "NetUserGetGroups");
    }

    wprintf(
	L"\n%ws\n",
	myLoadResourceString(IDS_GROUP_LIST_COLON)); // "Group Memberships:"
    for (i = 0; i < cGroup; i++)
    {
        wprintf(L"  %ws\n", pgui0[i].grui0_name);
    }
    hr = S_OK;

error:
    if (NULL != pwszDomain)
    {
        LocalFree(pwszDomain);
    }
    if (NULL != pwszMachine)
    {
        LocalFree(pwszMachine);
    }
    if (NULL != pgui0)
    {
        NetApiBufferFree(pgui0);
    }
    return(hr);
}


#define wszDSSPN		L"servicePrincipalName"
#define wszDSOBJECTCATEGORY	L"ObjectCategory"
#define wszDSSAMACCOUNTNAME	L"sAMAccountName"
#define wszDSUSERACCOUNTCONTROL	L"userAccountControl"

HRESULT
verbMachineInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    LPWSTR pwszDC;
    DWORD dwGetDCFlags = DS_GC_SERVER_REQUIRED |  DS_RETURN_DNS_NAME;
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    DS_NAME_RESULT *pNameResults = NULL;
    ULONG ldaperr;
    WCHAR *pwszError = NULL;
    char *pszFunc = NULL;

    LDAP *pld = NULL;
    LDAPMessage *SearchResult = NULL;
    LDAPMessage *Entry = NULL;
    WCHAR *pwszAttrName = NULL;
    WCHAR **prgVal = NULL;
    WCHAR **prgSPN = NULL;
    WCHAR **prgDNS = NULL;
    berval **Values = NULL;
    BerElement *bElement = NULL;
    BOOL fRediscover;
    HANDLE hDS = NULL;
    WCHAR *apwszAttrName[] = {
	CA_PROP_DNSNAME,
	wszDSSPN,
	wszDSOBJECTCATEGORY,
	wszDSSAMACCOUNTNAME,
	wszDSUSERACCOUNTCONTROL,
	NULL
    };

    WCHAR *ObjectClassFilter = L"objectClass=computer";

    // Get (and check) machine object in DS
    // Check:
    //   1) SPN
    //   2) Group Membership
    //   3) DNSHostName
    //   4) Object Class
    //   5) Object Category

    if (NULL == wcschr(pwszMachine, L'$'))
    {
        wprintf(myLoadResourceString(IDS_ERROR_NO_TRAILING), pwszMachine);
        wprintf(wszNewLine);

        hr = E_INVALIDARG;
        _JumpError(hr, error, "machine name missing $");
    }

    fRediscover = FALSE;
    while (TRUE)
    {
	if (fRediscover)
	{
	   dwGetDCFlags |= DS_FORCE_REDISCOVERY;
	}

	// in case we rediscovered...

	if (NULL != pDCInfo) 
	{
	    NetApiBufferFree(pDCInfo);
	    pDCInfo = NULL;
	}
	if (NULL != pNameResults)
	{    
	    DsFreeNameResult(pNameResults);
	    pNameResults = NULL;
	}
	if (NULL != pld)
	{
	    ldap_unbind(pld);
	    pld = NULL;
	}
	if (NULL != pwszError)
	{
	    LocalFree(pwszError);
	    pwszError = NULL;
	}

	pszFunc = "DsGetDCName";
	hr = DsGetDcName(NULL, NULL, NULL, NULL, dwGetDCFlags, &pDCInfo);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _JumpError(hr, error, pszFunc);
	}
	if (NULL == pDCInfo ||
	    0 == (pDCInfo->Flags & DS_GC_FLAG) ||
	    0 == (pDCInfo->Flags & DS_DNS_CONTROLLER_FLAG) ||
	    NULL == pDCInfo->DomainControllerName)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	    _JumpErrorStr(hr, error, pszFunc, L"pDCInfo");
	}

	//  Modify DC name

	pwszDC = pDCInfo->DomainControllerName;
	while (*pwszDC == L'\\')
	{
	    pwszDC++;
	}

	pszFunc = "DsBind";
	hr = DsBind(pwszDC, NULL, &hDS);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _PrintError(hr, pszFunc);
	    if (!fRediscover)
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, pszFunc);
	}
	
	pszFunc = "DsCrackNames";
	hr = DsCrackNames(
		    hDS,
		    DS_NAME_NO_FLAGS,
		    DS_NT4_ACCOUNT_NAME,
		    DS_FQDN_1779_NAME,
		    1,                        // cNames
		    &pwszMachine,             // rpNames (IN)
		    &pNameResults);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _PrintError(hr, pszFunc);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, pszFunc);
	}

	if (1 > pNameResults->cItems ||
	    DS_NAME_NO_ERROR != pNameResults->rItems[0].status)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	    _JumpErrorStr(hr, error, pszFunc, L"pNameResults");
	}

	// ldap_bind to GC

	pszFunc = "ldap_init";
	pld = ldap_init(pwszDC, LDAP_GC_PORT);
	if (NULL == pld)
	{
	    hr = myHLdapLastError(NULL, &pwszError);
	    _PrintErrorStr(hr, pszFunc, pwszError);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpErrorStr(hr, error, pszFunc, pwszError);
	}

	// do this because we're explicitly setting DC name; see bug# 347563

	pszFunc = "ldap_set_option";
	ldaperr = ldap_set_option(pld, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, &pwszError);
	    _PrintErrorStr(hr, pszFunc, pwszError);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpErrorStr(hr, error, pszFunc, pwszError);
	}
	
	pszFunc = "ldap_bind_s";
	ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, &pwszError);
	    _PrintErrorStr(hr, pszFunc, pwszError);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpErrorStr(hr, error, pszFunc, pwszError);
	}
	break;
    }
    
    pszFunc = "ldap_searh_s";
    ldaperr = ldap_search_s(
                    pld,
                    pNameResults->rItems[0].pName,
                    LDAP_SCOPE_BASE,
                    ObjectClassFilter,
                    apwszAttrName, 
                    FALSE,
                    &SearchResult);
    if (LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pld, ldaperr, &pwszError);
        _JumpErrorStr(hr, error, pszFunc, pwszError);
    }
    
    // should only be 1 entry...

    for (Entry = ldap_first_entry(pld, SearchResult); 
	 NULL != Entry;
	 Entry = ldap_next_entry(pld, Entry))
    {
        for (pwszAttrName = ldap_first_attribute(pld, Entry, &bElement);
	     NULL != pwszAttrName;
	     pwszAttrName = ldap_next_attribute(pld, Entry, bElement))
	{
	    DWORD i;
	    
	    if (NULL != pwszError)
	    {
		LocalFree(pwszError);
		pwszError = NULL;
	    }
            prgVal = ldap_get_values(pld, Entry, pwszAttrName);
            if (NULL == prgVal)
	    {
		pszFunc = "ldap_get_values";
		hr = myHLdapLastError(pld, &pwszError);
		_PrintErrorStr(hr, pszFunc, pwszError);

                wprintf(L"%hs(%ws): %ws\n", pszFunc, pwszAttrName, pwszError);
                continue;
            }
            
            // Display values & store away DNSHostName & SPN values for 
            // comparison.

            //DisplayLdapValues(pwszAttrName, prgVal);
	    wprintf(L"\n%ws:\n", pwszAttrName);
	    for (i = 0; NULL != prgVal[i]; i++)
	    {
		wprintf(L"  %s\n", prgVal[i]);
	    }
            
            if (0 == lstrcmpi(pwszAttrName, CA_PROP_DNSNAME))
	    {
                prgDNS = prgVal;
            }
	    else if (0 == lstrcmpi(pwszAttrName, wszDSSPN))
	    {
                prgSPN = prgVal;
            }
	    else if (NULL != prgVal)
	    {
                ldap_value_free(prgVal);
                prgVal = NULL;
            }
        }
    }

    // There *will* be problems w/SPNs.
    // This should help determine what problems there are.

    if (NULL == prgDNS)
    {
        wprintf(
	    myLoadResourceString(IDS_FORMAT_MISSING_MACHINE_ATTRIBUTE), // "Machine object missing %ws attribute."
            CA_PROP_DNSNAME);
	wprintf(wszNewLine);
    }

    if (NULL == prgSPN)
    {
        wprintf(
	    myLoadResourceString(IDS_FORMAT_MISSING_MACHINE_ATTRIBUTE), // "Machine object missing %ws attribute."
	    wszDSSPN);
	wprintf(wszNewLine);
    }

    // Now let's get the group membership for this machine

    hr = cuGetGroupMembership(pwszMachine);
    _JumpIfError(hr, error, "cuGetGroupMembership");

error:
    if (NULL != prgDNS)
    {
        ldap_value_free(prgDNS);
    }
    if (NULL != prgSPN)
    {
        ldap_value_free(prgSPN);
    }
    if (NULL != SearchResult)
    {
        ldap_msgfree(SearchResult);
    }
    if (NULL != pDCInfo) 
    {
        NetApiBufferFree(pDCInfo);
    }
    if (NULL != hDS)
    {
        DsUnBind(&hDS);
    }
    if (NULL != pNameResults)
    {    
        DsFreeNameResult(pNameResults);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    if (NULL != pwszError)
    {
	if (NULL != pszFunc)
	{
	    wprintf(L"%hs: ", pszFunc);
	}
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\odbc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        odbc.cpp
//
// Contents:    Cert Server Data Base interface implementation for odbc
//
// History:     06-jan-97       larrys created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certdb2.h"
#include "csprop2.h"
//#include "db2.h"
//#include "dbcore.h"
#include "odbc.h"

#define __myFILE__	"odbc.cpp"

HENV    henv =  SQL_NULL_HENV;
HDBC    hdbc =  SQL_NULL_HDBC;

typedef struct _DBENUMHANDLETABLE
{
    LIST_ENTRY    Next;
    HSTMT         hEnum;
    BYTE          Name[MAX_PATH];
    SQLLEN        cbName;
    HANDLE        hToData;
} DBENUMHANDLETABLE, *PDBENUMHANDLETABLE;

LIST_ENTRY g_DBEnumHandleList;

PDBENUMHANDLETABLE GetDBEnumHandle(HANDLE dwHandle);

CRITICAL_SECTION g_DBEnumCriticalSection;
BOOL g_fDBEnumCSInit = FALSE;

/////


STATUS
DBStatus(
    RETCODE rc)
{
    STATUS  s;

    switch (rc)
    {
    case SQL_SUCCESS:
    case SQL_SUCCESS_WITH_INFO:
        s = ERROR_SUCCESS;
	break;

    case SQL_NO_DATA_FOUND:
	s = CERTSRV_E_PROPERTY_EMPTY;
	break;

    case SQL_INVALID_HANDLE:
	s = ERROR_INVALID_HANDLE;
	break;

    case SQL_ERROR:
    default:
        s = GetLastError();
        if (ERROR_SUCCESS == s)
	{
	    s = (DWORD) -1;
	}
	break;
    }
    return(s);
}


/////


void
DBCheck(
    RETCODE rc
    DBGPARM(char const *pszFile)
    DBGPARM(DWORD Line),
    HSTMT hstmt)
{
    if ( rc != SQL_SUCCESS )
    {
        UCHAR   state[SQL_MAX_MESSAGE_LENGTH-1];
        UCHAR   msg  [SQL_MAX_MESSAGE_LENGTH-1];
        SDWORD  native;

        SQLError ( henv, hdbc, hstmt, state, &native, msg, sizeof(msg), NULL );
	if (SQL_SUCCESS_WITH_INFO != rc || 2 < g_fVerbose)
	{
	    wprintf(
		DBGPARM0(L"%hs(%u): ")
		    L"rc=%d, SQLError %hs (%d): %hs\n"
		DBGPARM(pszFile)
		DBGPARM(Line),
		rc,
		state,
		native,
		msg);
	}
    }
}


/////


STATUS odbcInitRequestQueue(
    UCHAR   *dsn,
    UCHAR   *user,
    UCHAR   *pwd
)
{
    RETCODE rc;

    rc = SQLAllocEnv ( &henv );

    if ( rc == SQL_SUCCESS )
    {
        rc = SQLAllocConnect ( henv, &hdbc );

        if ( rc == SQL_SUCCESS )
        {
            rc = SQLConnect ( hdbc, dsn, SQL_NTS, user, SQL_NTS, pwd, SQL_NTS );

            DBCHECKLINE ( rc, SQL_NULL_HSTMT );

            if ( rc == SQL_SUCCESS_WITH_INFO )
            {
                rc = SQL_SUCCESS;
            }

            if ( rc != SQL_SUCCESS )
                SQLFreeConnect ( hdbc );
        }

        if ( rc != SQL_SUCCESS )
            SQLFreeEnv ( henv );
    }

    if ( rc != SQL_SUCCESS )
    {
	wprintf(myLoadResourceString(IDS_RED_CONNECT_FAIL), rc, rc);
	wprintf(wszNewLine);
    }

    return DBStatus ( rc );

}


/////


void odbcFinishRequestQueue(void)
{
    SQLDisconnect ( hdbc );
    SQLFreeConnect ( hdbc );
    SQLFreeEnv ( henv );
}


/////

RETCODE dbGetNameId(
    IN        REQID       ReqId,
    IN        UCHAR      *pszSQL,
    OUT       NAMEID     *pnameid,
    OUT       SQLLEN     *poutlen)
{
    RETCODE    rc;
    HSTMT      hstmt = SQL_NULL_HSTMT;

    rc = SQLAllocStmt(hdbc, &hstmt);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    // bind request-id parameter

    rc = SQLBindParameter(
                       hstmt,
                       1,
                       SQL_PARAM_INPUT,
                       SQL_C_ULONG,
                       SQL_INTEGER,
                       0,
                       0,
                       &ReqId,
                       0,
                       NULL);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    // do query

    rc = SQLExecDirect(
                   hstmt,
                   pszSQL,
                   SQL_NTS);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    // get result value

    rc = SQLBindCol(
                hstmt,
                1,
                SQL_C_ULONG,
                pnameid,
                sizeof(DWORD),
                poutlen);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    rc = SQLFetch(hstmt);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

error:
    if (hstmt != SQL_NULL_HSTMT)
    {
        SQLFreeStmt(
                hstmt,
                SQL_DROP);
    }

    return(rc);

}


/////

RETCODE odbcSPExtensionOrAttributeDB(
    IN DWORD       id,
    IN DBTABLE_RED    *pdtOut,
    IN UCHAR      *pquery,
    IN DWORD       cbInProp,
    IN BYTE const *pbInProp
)
{
    RETCODE        rc;
    HSTMT          hstmt = SQL_NULL_HSTMT;
    SQLLEN         datalen;
    DWORD          cbParam2Prop;
    BYTE const    *pbParam2Prop;
    DWORD          cbParam3Prop;
    BYTE const    *pbParam3Prop;
    SWORD          wCType;
    SWORD          wSqlType;
    BYTE           data[] = {'\0', '\0', '\0', '\0'};
    static UCHAR   updateextension[] = "Update CertificateExtensions SET %ws = ? WHERE ExtensionName = \'%ws\' AND RequestID = ?;";
    static UCHAR   updateattrib[] = "Update RequestAttributes SET AttributeValue = ? WHERE AttributeName = \'%ws\' AND RequestID = ?;";

    rc = SQLAllocStmt(hdbc, &hstmt);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    rc = SQLBindParameter(
                      hstmt,
                      1,
                      SQL_PARAM_INPUT,
                      SQL_C_ULONG,
                      SQL_INTEGER,
                      0,
                      0,
                      &id,
                      0,
                      NULL);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    if (0 == lstrcmpi(wszPROPCERTIFICATEEXTENSIONFLAGS, pdtOut->pwszPropName) ||
        pdtOut->dwTable == TABLE_REQUEST_ATTRIBS)
    {
        cbParam2Prop = cbInProp;
        pbParam2Prop = pbInProp;
        cbParam3Prop = 1;
        pbParam3Prop = data;
    }
    else
    {
        cbParam2Prop = 1;
        pbParam2Prop = data;
        cbParam3Prop = cbInProp;
        pbParam3Prop = pbInProp;
    }

    if (pdtOut->dwTable == TABLE_EXTENSIONS)
    {
        wCType = SQL_C_ULONG;
        wSqlType = SQL_INTEGER;
    }
    else
    {
        wCType = SQL_C_CHAR;
        wSqlType = SQL_VARCHAR;
    }

    datalen = cbParam2Prop;
    rc = SQLBindParameter(
                      hstmt,
                      2,
                      SQL_PARAM_INPUT,
                      wCType,
                      wSqlType,
                      cbParam2Prop,
                      0,
                      (void*)pbParam2Prop,
                      cbParam2Prop,
                      &datalen);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    if (pdtOut->dwTable == TABLE_EXTENSIONS)
    {
        datalen = cbParam3Prop;
        rc = SQLBindParameter(
                          hstmt,
                          3,
                          SQL_PARAM_INPUT,
                          SQL_C_BINARY,
                          SQL_LONGVARBINARY,
                          cbParam3Prop,
                          0,
                          (void*)pbParam3Prop,
                          cbParam3Prop,
                          &datalen);

        if (SQL_SUCCESS != rc)
        {
            goto error;
        }
    }

    rc = SQLExecDirect(
                   hstmt,
                   pquery,
                   SQL_NTS);

    // See if we could insert a new row.
    if (SQL_SUCCESS == rc)
    {
        goto done;
    }

    datalen = cbInProp;

    // Try to do an update of the row instead
    if (pdtOut->dwTable == TABLE_EXTENSIONS)
    {
        sprintf(
            (char *) pquery,
            (char *) updateextension,
            pdtOut->pwszPropNameObjId,
            pdtOut->pwszFieldName);

        if (0 == lstrcmpi(wszPROPCERTIFICATEEXTENSIONFLAGS, pdtOut->pwszPropName))
        {
            rc = SQLBindParameter(
                              hstmt,
                              1,
                              SQL_PARAM_INPUT,
                              SQL_C_ULONG,
                              SQL_INTEGER,
                              cbInProp,
                              0,
                              (void*)pbInProp,
                              cbInProp,
                              &datalen);
        }
        else
        {
            rc = SQLBindParameter(
                              hstmt,
                              1,
                              SQL_PARAM_INPUT,
                              SQL_C_BINARY,
                              SQL_LONGVARBINARY,
                              cbInProp,
                              0,
                              (void*)pbInProp,
                              cbInProp,
                              &datalen);
        }

        if (SQL_SUCCESS != rc)
        {
            goto error;
        }

    }
    else
    {
        sprintf(
            (char *) pquery,
            (char *) updateattrib,
            pdtOut->pwszFieldName);

            rc = SQLBindParameter(
                              hstmt,
                              1,
                              SQL_PARAM_INPUT,
                              SQL_C_CHAR,
                              SQL_VARCHAR,
                              cbInProp,
                              0,
                              (void*)pbInProp,
                              cbInProp,
                              &datalen);

        if (SQL_SUCCESS != rc)
        {
            goto error;
        }
    }

    rc = SQLBindParameter(
                      hstmt,
                      2,
                      SQL_PARAM_INPUT,
                      SQL_C_ULONG,
                      SQL_INTEGER,
                      0,
                      0,
                      &id,
                      0,
                      NULL);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    rc = SQLExecDirect(
                   hstmt,
                   pquery,
                   SQL_NTS);

done:
error:
     // done
    DBCHECKLINE(rc, hstmt);

    if (SQL_NULL_HSTMT != hstmt)
    {
        SQLFreeStmt(hstmt, SQL_DROP);
    }

    return(rc);
}


/////

RETCODE odbcGPDataFromDB(
    IN  REQID    ReqId,
    IN  DWORD    dwTable,
    IN  SWORD    wCType,
    IN  BYTE    *pbData,
    IN  DWORD    cbData,
    IN  UCHAR   *szQuery,
    OUT NAMEID  *pnameid,
    OUT SQLLEN  *poutlen
)
{
    RETCODE rc;
    HSTMT   hstmt;
    SQLLEN  cbnameid;

retry:
    hstmt = SQL_NULL_HSTMT;
    cbnameid = 0;

    rc = SQLAllocStmt (hdbc, &hstmt);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    // bind request-id parameter
    rc = SQLBindParameter(
                      hstmt,
                      1,
                      SQL_PARAM_INPUT,
                      SQL_C_ULONG,
                      SQL_INTEGER,
                      0,
                      0,
                      &ReqId,
                      0,
                      NULL);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    rc = SQLExecDirect(hstmt, szQuery, SQL_NTS);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    // retrieve result

    rc = SQLBindCol(
                hstmt,
                1,
                wCType,
                pbData,
                cbData,
                poutlen);

    if (SQL_SUCCESS == rc &&
        (dwTable == TABLE_SUBJECT_NAME ||
         dwTable == TABLE_ISSUER_NAME))
    {
        rc = SQLBindCol(
                    hstmt,
                    2,
                    SQL_C_ULONG,
                    pnameid,
                    sizeof(pnameid),
                    &cbnameid);
    }

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    rc = SQLFetch(hstmt);

    if (SQL_ERROR == rc)
    {
	RETCODE rc2;
	unsigned char achState[10];
	unsigned char achText[2048];
	SHORT cchText;
	LONG NativeError;

	rc2 = SQLGetDiagRec(
		    SQL_HANDLE_STMT,
		    hstmt,
		    1,
		    achState,
		    &NativeError,
		    achText,
		    ARRAYSIZE(achText),
		    &cchText);
	if (rc2 == SQL_SUCCESS)
	{
#if 0
	    wprintf(
		L"SQLGetDiagRec: cch=%hu, text=%hs, ne=0x%x, state=%.10hs\n",
		cchText,
		achText,
		NativeError,
		achState);
#endif
	    if (SQL_C_ULONG == wCType && 0 == strcmp((char *) achState, "22003"))
	    {
		//wprintf(L"\nNumeric value out of range fetching ULONG\n");

		wCType = SQL_C_LONG;
		if (SQL_NULL_HSTMT != hstmt)
		{
		    SQLFreeStmt(hstmt, SQL_DROP);
		}
		goto retry;
	    }
	}
    }
    if (SQL_NULL_HSTMT != hstmt)
    {
        SQLFreeStmt(hstmt, SQL_DROP);
    }

error:
    return rc;

}



/////

HRESULT
odbcDBEnumSetup(
    IN       REQID      ReqId,
    IN       DWORD      fExtOrAttr,
    OUT      HANDLE    *phEnum)
{
    HRESULT               rc;
    HSTMT                 hstmt = SQL_NULL_HSTMT;
    DWORD                 cbData;
    PDBENUMHANDLETABLE    pDBEnumHandle = NULL;
    UCHAR      szExtensionQuery[] = "SELECT ExtensionName FROM CertificateExtensions WHERE RequestID = ?;";
    UCHAR      szAttributeQuery[] = "SELECT AttributeName FROM RequestAttributes WHERE RequestID = ?;";

    rc = SQLAllocStmt(hdbc, &hstmt);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    // bind request-id parameter
    rc = SQLBindParameter(
                      hstmt,
                      1,
                      SQL_PARAM_INPUT,
                      SQL_C_ULONG,
                      SQL_INTEGER,
                      0,
                      0,
                      &ReqId,
                      0,
                      NULL);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    rc = SQLExecDirect(
                   hstmt,
                   fExtOrAttr ? szAttributeQuery : szExtensionQuery,
                   SQL_NTS);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    // create handle to return
    if ((pDBEnumHandle = (PDBENUMHANDLETABLE) LocalAlloc(LMEM_ZEROINIT,
                                             sizeof(DBENUMHANDLETABLE))) == 0)
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    // can't depend on CryptGenRandom() on other csps

    pDBEnumHandle->hToData = (HANDLE) (ULONG_PTR) rand();
    if (0 == pDBEnumHandle->hToData)
    {
	pDBEnumHandle->hToData = (HANDLE) (ULONG_PTR) 1; // don't be zero
    }

    // retrieve result

    pDBEnumHandle->cbName = 0;

    // Since ExtensionName & AttributeName column in DB is length 50 this
    // should be fine

    cbData = MAX_PATH;

    rc = SQLBindCol(
                hstmt,
                1,
                SQL_C_CHAR,
                pDBEnumHandle->Name,
                cbData,
                &pDBEnumHandle->cbName);

    if (SQL_SUCCESS != rc)
    {
        goto error;
    }

    pDBEnumHandle->hEnum = hstmt;

    *phEnum = (HANDLE) pDBEnumHandle->hToData;

    if(!g_fDBEnumCSInit)
    {
        rc = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        goto error;
        
    }
    EnterCriticalSection(&g_DBEnumCriticalSection);

    InsertTailList(&g_DBEnumHandleList, &pDBEnumHandle->Next);

    LeaveCriticalSection(&g_DBEnumCriticalSection);

    return(rc);

error:
    if (SQL_NULL_HSTMT != hstmt)
    {
        rc = SQLFreeStmt(
                     hstmt,
                     SQL_DROP);
    }
    if (NULL != pDBEnumHandle)
    {
        LocalFree(pDBEnumHandle);
    }

    return(rc);

}


HRESULT
odbcDBEnum(
    IN      HANDLE     hEnum,
    IN OUT  DWORD    *pcb,
    OUT     WCHAR    *pb)
{
    PDBENUMHANDLETABLE    pDBEnumHandle;
    HRESULT rc;

    if (*pcb < MAX_EXTENSION_NAME)
    {
        rc = ERROR_INSUFFICIENT_BUFFER;
        goto error;
    }

    pDBEnumHandle = GetDBEnumHandle(hEnum);

    if (NULL == pDBEnumHandle)
    {
        rc = ERROR_INVALID_HANDLE;
        goto error;
    }

    rc = SQLFetch(pDBEnumHandle->hEnum);

    if (SQL_SUCCESS != rc)
    {
        if (SQL_NO_DATA_FOUND == rc)
        {
            *pcb = 0;
            rc = CERTSRV_E_PROPERTY_EMPTY;
        }
        goto error;
    }

    rc = MultiByteToWideChar(
                         GetACP(),
                         0,
                         (CHAR*)pDBEnumHandle->Name,
                         (int)pDBEnumHandle->cbName,
                         pb,
                         *pcb);

    if (!rc)
    {
        rc = GetLastError();
        goto error;
    }
    else
    {
        rc = ERROR_SUCCESS;
    }

    *pcb = (DWORD)pDBEnumHandle->cbName;

error:
    return(rc);

}


HRESULT
odbcDBEnumClose(
    IN HANDLE    hEnum)
{
    PDBENUMHANDLETABLE    pDBEnumHandle;
    HRESULT               rc;

    if(!g_fDBEnumCSInit)
    {
        rc = HRESULT_FROM_WIN32(ERROR_NOT_READY);
        return rc;
    }

    pDBEnumHandle = GetDBEnumHandle(hEnum);

    if (NULL == pDBEnumHandle)
    {
        rc = ERROR_INVALID_HANDLE;
        return(rc);
    }

    rc = SQLFreeStmt(
                 pDBEnumHandle->hEnum,
                 SQL_DROP);

    EnterCriticalSection(&g_DBEnumCriticalSection);

    RemoveEntryList(&pDBEnumHandle->Next);

    LocalFree(pDBEnumHandle);

    LeaveCriticalSection(&g_DBEnumCriticalSection);

    return(rc);

}

PDBENUMHANDLETABLE
GetDBEnumHandle(HANDLE dwHandle)
{
    PLIST_ENTRY        ListHead;
    PLIST_ENTRY        ListNext;
    PDBENUMHANDLETABLE pDBEnumHandle;

    ListHead = &g_DBEnumHandleList;
    ListNext = ListHead->Flink;

    if(!g_fDBEnumCSInit)
    {
        return NULL;
    }
    EnterCriticalSection(&g_DBEnumCriticalSection);

    while (ListNext != ListHead)
    {
        pDBEnumHandle = CONTAINING_RECORD(ListNext, DBENUMHANDLETABLE, Next);
        if (pDBEnumHandle->hToData == dwHandle)
        {
            LeaveCriticalSection(&g_DBEnumCriticalSection);
            return(pDBEnumHandle);
        }
        ListNext = ListNext->Flink;
    }

    LeaveCriticalSection(&g_DBEnumCriticalSection);

    return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\dump.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dump.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "cscsp.h"
#include "csber.h"

#if DBG
#define wszCERTUTIL	L"(certutil)"
#else
#define wszCERTUTIL	L""
#endif

WCHAR const g_wszCertUtil[] = wszCERTUTIL;

HRESULT
DumpAttributes(
    IN CRYPT_ATTRIBUTE const *rgAttr,
    IN DWORD cAttr,
    IN BOOL fQuiet,
    IN DWORD Type,		// FOT_*
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert,
    OPTIONAL IN OUT CERT_EXTENSIONS **ppExtInfo);


WCHAR const *
wszRDNValueType(
    IN DWORD dwValueType)
{
    WCHAR const *pwsz;

    switch (CERT_RDN_TYPE_MASK & dwValueType)
    {
	case CERT_RDN_ANY_TYPE:
	    pwsz = L"CERT_RDN_ANY_TYPE";
	    break;

	case CERT_RDN_ENCODED_BLOB:
	    pwsz = L"CERT_RDN_ENCODED_BLOB";
	    break;

	case CERT_RDN_OCTET_STRING:
	    pwsz = L"CERT_RDN_OCTET_STRING";
	    break;

	case CERT_RDN_NUMERIC_STRING:
	    pwsz = L"CERT_RDN_NUMERIC_STRING";
	    break;

	case CERT_RDN_PRINTABLE_STRING:
	    pwsz = L"CERT_RDN_PRINTABLE_STRING";
	    break;

	case CERT_RDN_TELETEX_STRING:
	    pwsz = L"CERT_RDN_TELETEX_STRING";
	    break;

	//case CERT_RDN_T61_STRING:
	    //pwsz = L"CERT_RDN_T61_STRING";
	    //break;

	case CERT_RDN_VIDEOTEX_STRING:
	    pwsz = L"CERT_RDN_VIDEOTEX_STRING";
	    break;

	case CERT_RDN_IA5_STRING:
	    pwsz = L"CERT_RDN_IA5_STRING";
	    break;

	case CERT_RDN_GRAPHIC_STRING:
	    pwsz = L"CERT_RDN_GRAPHIC_STRING";
	    break;

	//case CERT_RDN_VISIBLE_STRING:
	    //pwsz = L"CERT_RDN_VISIBLE_STRING";
	    //break;

	case CERT_RDN_ISO646_STRING:
	    pwsz = L"CERT_RDN_ISO646_STRING";
	    break;

	case CERT_RDN_GENERAL_STRING:
	    pwsz = L"CERT_RDN_GENERAL_STRING";
	    break;

	case CERT_RDN_UNIVERSAL_STRING:
	    pwsz = L"CERT_RDN_UNIVERSAL_STRING";
	    break;

	//case CERT_RDN_INT4_STRING:
	    //pwsz = L"CERT_RDN_INT4_STRING";
	    //break;

	//case CERT_RDN_BMP_STRING:
	    //pwsz = L"CERT_RDN_BMP_STRING";
	    //break;

	case CERT_RDN_UNICODE_STRING:
	    pwsz = L"CERT_RDN_UNICODE_STRING";
	    break;

	case CERT_RDN_UTF8_STRING:
	    pwsz = L"CERT_RDN_UTF8_STRING";
	    break;

	default:
	    pwsz = myLoadResourceString(IDS_QUESTIONMARKS); // "???"
	    break;
    }
    return(pwsz);
}


VOID
cuPrintCRLFString(
    IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn)
{
    if (NULL == pwszPrefix)
    {
	pwszPrefix = g_wszEmpty;
    }
    while (L'\0' != *pwszIn)
    {
	DWORD i;
	WCHAR const *pwc;

	pwc = pwszIn++;
	i = wcscspn(pwszIn, L"\r\n");

	wprintf(
	    L"%.1ws%ws%.*ws",
	    pwc,
	    L'\n' == *pwc? pwszPrefix : g_wszEmpty,
	    i,
	    pwszIn);
	pwszIn += i;

	if (L'\r' == *pwszIn)
	{
	    pwszIn++;
	}
    }
}


VOID
cuPrintPossibleObjectIdName(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
	
    if (iswdigit(*pwszObjId))
    {
	hr = myVerifyObjId(pwszObjId);
	if (S_OK == hr)
	{
	    WCHAR const *pwszName = cuGetOIDName(pwszObjId);

	    if (NULL != pwszName && L'\0' != *pwszName)
	    {
		wprintf(L" %ws", pwszName);
	    }
	}
    }
}


WCHAR const *
cuGetOIDNameA(
    IN char const *pszObjId)
{
    HRESULT hr;
    WCHAR const *pwszName1 = g_wszEmpty;
    WCHAR const *pwszName2;
    char *pszT = NULL;
    static WCHAR s_wszName[512];

    pszT = (char *) LocalAlloc(LMEM_FIXED, 1 + strlen(pszObjId) + 1);
    if (NULL == pszT)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    strcpy(&pszT[1], pszObjId);

    *pszT = '+';
    pwszName1 = myGetOIDNameA(pszT);	// Group OID lookup

    *pszT = '-';
    pwszName2 = myGetOIDNameA(pszT);	// Generic OID lookup

    if (0 == lstrcmpi(pwszName1, pwszName2))
    {
	pwszName2 = g_wszEmpty;		// display only one if they're the same
    }
    if (L'\0' == *pwszName1)
    {
	pwszName1 = pwszName2;
	pwszName2 = g_wszEmpty;
    }

    if (L'\0' != *pwszName2 &&
	ARRAYSIZE(s_wszName) > wcslen(pwszName1) + wcslen(pwszName2) + 3)
    {
	wcscpy(s_wszName, pwszName1);
	wcscat(s_wszName, L" " wszLPAREN);
	wcscat(s_wszName, pwszName2);
	wcscat(s_wszName, wszRPAREN);
	pwszName1 = s_wszName;
    }

error:
    if (NULL != pszT)
    {
	LocalFree(pszT);
    }
    return(pwszName1);
}


WCHAR const *
cuGetOIDName(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
    char *pszObjId = NULL;
    WCHAR const *pwszName = g_wszEmpty;

    if (!ConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }
    pwszName = cuGetOIDNameA(pszObjId);

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(pwszName);
}


VOID
cuDumpOIDAndDescriptionA(
    IN char const *pszObjId)
{
    WCHAR const *pwsz;

    wprintf(L"%hs", pszObjId);
    pwsz = cuGetOIDNameA(pszObjId);
    if (NULL != pwsz && L'\0' != *pwsz)
    {
	wprintf(L" %ws", pwsz);
    }
}


VOID
cuDumpOIDAndDescription(
    IN WCHAR const *pwszObjId)
{
    WCHAR const *pwsz;

    wprintf(L"%ws", pwszObjId);
    pwsz = cuGetOIDName(pwszObjId);
    if (NULL != pwsz && L'\0' != *pwsz)
    {
	wprintf(L" %ws", pwsz);
    }
}


HRESULT
cuCertNameToStr(
    IN BOOL fMultiLine,
    IN CERT_NAME_BLOB const *pNameBlob,
    OUT WCHAR **ppwszCertName)
{
    HRESULT hr;
    DWORD Flags = CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_QUOTING_FLAG;

    *ppwszCertName = NULL;
    if (fMultiLine)
    {
	Flags |= CERT_NAME_STR_CRLF_FLAG;
    }
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		pNameBlob,
		Flags,
		ppwszCertName);
    _JumpIfError(hr, error, "myCertNameToStr");

error:
    return(hr);
}


typedef struct _RDNTABLE
{
    CHAR const *pszObjId;
    DWORD       cchMax;
} RDNTABLE;

RDNTABLE const g_RdnTable[] =
{
    { szOID_COUNTRY_NAME,		cchCOUNTRYNAMEMAX },
    { szOID_ORGANIZATION_NAME,		cchORGANIZATIONNAMEMAX },
    { szOID_ORGANIZATIONAL_UNIT_NAME,	cchORGANIZATIONALUNITNAMEMAX },
    { szOID_COMMON_NAME,		cchCOMMONNAMEMAX },
    { szOID_LOCALITY_NAME,		cchLOCALITYMANAMEMAX },
    { szOID_STATE_OR_PROVINCE_NAME,	cchSTATEORPROVINCENAMEMAX },
    { szOID_TITLE,			cchTITLEMAX },
    { szOID_GIVEN_NAME,			cchGIVENNAMEMAX },
    { szOID_INITIALS,			cchINITIALSMAX },
    { szOID_SUR_NAME,			cchSURNAMEMAX },
    { szOID_DOMAIN_COMPONENT,		cchDOMAINCOMPONENTMAX },
    { szOID_RSA_emailAddr,		cchEMAILMAX },
    { szOID_STREET_ADDRESS,		cchSTREETADDRESSMAX },
    { szOID_RSA_unstructName,		cchUNSTRUCTUREDNAMEMAX },
    { szOID_RSA_unstructAddr,		cchUNSTRUCTUREDADDRESSMAX },
    { szOID_DEVICE_SERIAL_NUMBER,	cchDEVICESERIALNUMBERMAX },
    { NULL,				0 },
};


DWORD
cwcRDNMax(
    IN char const *pszObjId)
{
    RDNTABLE const *pRdnTable;
    DWORD cwcMax = MAXDWORD;

    for (pRdnTable = g_RdnTable; NULL != pRdnTable->pszObjId; pRdnTable++)
    {
	if (0 == strcmp(pszObjId, pRdnTable->pszObjId))
	{
	    cwcMax = pRdnTable->cchMax;
	    break;
	}
    }
    return(cwcMax);
}


HRESULT
cuDisplayCertNameValue(
    OPTIONAL IN char const *pszObjId,
    OPTIONAL IN WCHAR const *pwszChoice,
    IN DWORD dwValueType,
    IN CRYPT_DATA_BLOB const *pValueW,
    IN CRYPT_DATA_BLOB const *pValueA)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcMax = MAXDWORD;
    CRYPT_DATA_BLOB ValueUTF8;

    ValueUTF8.pbData = NULL;
    cwc = pValueW->cbData / sizeof(WCHAR);
    if (NULL != pszObjId)
    {
	cwcMax = cwcRDNMax(pszObjId);
    }

    if (CERT_RDN_UTF8_STRING == dwValueType)
    {
	if (myConvertWszToUTF8(
		(char **) &ValueUTF8.pbData,
		(WCHAR const *) pValueW->pbData,
		pValueW->cbData / sizeof(WCHAR)))
	{
	    ValueUTF8.cbData = strlen((CHAR const *) ValueUTF8.pbData);
	    pValueA = &ValueUTF8;
	}
    }

    wprintf(
	L"%ws, %ws = %u",
	wszRDNValueType(dwValueType),
	myLoadResourceString(IDS_LENGTH), // "Length"
	pValueA->cbData);

    if (MAXDWORD != cwcMax || CERT_RDN_OCTET_STRING != dwValueType)
    {
	wprintf(
	    L" " wszLPAREN L"%ws%ws%u",
	    cwc <= cwcMax? g_wszEmpty : myLoadResourceString(IDS_OVERFLOW), // "OVERFLOW:"
	    cwc <= cwcMax? g_wszEmpty : L" ",
	    cwc);
	if (NULL != pszObjId)
	{
	    wprintf(L"/%u", cwcMax);
	}
	wprintf(
	    L" %ws" wszRPAREN,
	    myLoadResourceString(IDS_CHARS)); // "Characters"
    }
    wprintf(wszNewLine);

    wprintf(g_wszPad8);
    if (NULL != pszObjId)
    {
	cuDumpOIDAndDescriptionA(pszObjId);
	wprintf(L"=");
    }
    else if (NULL != pwszChoice)
    {
	wprintf(L"%ws=", pwszChoice);
    }
    if (CERT_RDN_OCTET_STRING != dwValueType)
    {
	wprintf(L"\"%ws\"\n", pValueW->pbData);
    }
    wprintf(wszNewLine);

    DumpHex(
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pValueA->pbData,
	pValueA->cbData);
    hr = S_OK;

//error:
    if (NULL != ValueUTF8.pbData)
    {
	LocalFree(ValueUTF8.pbData);
    }
    return(hr);
}


HRESULT
cuDisplayCertName(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszPad,
    IN CERT_NAME_BLOB const *pNameBlob)
{
    WCHAR *pwszCertName = NULL;
    DWORD i;
    HRESULT hr = S_OK;
    CERT_NAME_INFO *pNameInfoA = NULL;
    CERT_NAME_INFO *pNameInfoW = NULL;
    DWORD cbNameInfo;

    hr = cuCertNameToStr(fMultiLine, pNameBlob, &pwszCertName);
    _JumpIfError(hr, error, "cuCertNameToStr");

    if (NULL != pwszNamePrefix)
    {
	wprintf(pwszNamePrefix);
    }
    wprintf(L"%ws:", pwszName);
    wprintf(fMultiLine? L"\n%ws" : L" ", pwszPad);
    cuPrintCRLFString(pwszPad, pwszCertName);
    wprintf(wszNewLine);

    if (1 < g_fVerbose)
    {
	DumpHex(
	    DH_NOTABPREFIX | 4,
	    pNameBlob->pbData,
	    pNameBlob->cbData);
	wprintf(wszNewLine);
    }

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfoW,
		&cbNameInfo))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfoA,
		&cbNameInfo))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    if (g_fVerbose)
    {
	for (i = 0; i < pNameInfoW->cRDN; i++)
	{
	    CERT_RDN const *prdnA;
	    CERT_RDN const *prdnW;
	    DWORD j;

	    prdnA = &pNameInfoA->rgRDN[i];
	    prdnW = &pNameInfoW->rgRDN[i];

	    for (j = 0; j < prdnW->cRDNAttr; j++)
	    {
		CERT_RDN_ATTR const *prdnaA;
		CERT_RDN_ATTR const *prdnaW;

		prdnaA = &prdnA->rgRDNAttr[j];
		prdnaW = &prdnW->rgRDNAttr[j];

		wprintf(L"    [%u,%u]: ", i, j);
		hr = cuDisplayCertNameValue(
					prdnaW->pszObjId,
					NULL,
					prdnaW->dwValueType,
					&prdnaW->Value,
					&prdnaA->Value);
		_PrintIfError(hr, "cuDisplayCertNameValue");
		wprintf(wszNewLine);
	    }
	}
    }

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    if (NULL != pNameInfoW)
    {
	LocalFree(pNameInfoW);
    }
    if (NULL != pNameInfoA)
    {
	LocalFree(pNameInfoA);
    }
    return(hr);
}


HRESULT
cuDisplayCertNames(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    IN CERT_INFO const *pCertInfo)
{
    HRESULT hr;

    hr = cuDisplayCertName(
			fMultiLine,
			pwszNamePrefix,
			myLoadResourceString(IDS_ISSUER), // "Issuer"
			g_wszPad4,
			&pCertInfo->Issuer);
    _JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

    hr = cuDisplayCertName(
			fMultiLine,
			pwszNamePrefix,
			myLoadResourceString(IDS_SUBJECT), // "Subject"
			g_wszPad4,
			&pCertInfo->Subject);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

error:
    return(hr);
}


#define POLICY_MASK \
  (EXTENSION_POLICY_MASK & ~(EXTENSION_CRITICAL_FLAG | EXTENSION_DISABLE_FLAG))

#define EXTRA_MASK	(~(EXTENSION_POLICY_MASK | EXTENSION_ORIGIN_MASK))

WCHAR const *
cuwszFromExtFlags(
    DWORD ExtFlags)
{
    static WCHAR awc[MAX_PATH];
    WCHAR const *pwszComma;
    WCHAR const *pwszSep = wszLPAREN;
    DWORD msgid;
    WCHAR const *pwszT;

    awc[0] = L'\0';
    pwszComma = myLoadResourceString(IDS_SEPARATOR); // ", "
    if (NULL == pwszComma)
    {
	pwszComma = L", ";
    }
    if (EXTENSION_CRITICAL_FLAG & ExtFlags)
    {
	wcscat(awc, pwszSep);
	pwszSep = pwszComma;
	pwszT = myLoadResourceString(IDS_CRITICAL); // "Critical"
	if (NULL != pwszT)
	{
	    wcscat(awc, pwszT);
	}
    }
    if (~EXTENSION_CRITICAL_FLAG & ExtFlags)
    {
	if (EXTENSION_DISABLE_FLAG & ExtFlags)
	{
	    wcscat(awc, pwszSep);
	    pwszSep = pwszComma;
	    pwszT = myLoadResourceString(IDS_DISABLED); // "Disabled"
	    if (NULL != pwszT)
	    {
		wcscat(awc, pwszT);
	    }
	}
	if (POLICY_MASK & ExtFlags)
	{
	    wcscat(awc, pwszSep);
	    pwszSep = pwszComma;
	    pwszT = myLoadResourceString(IDS_FORMAT_POLICYFLAGS); // "PolicyFlags=%x"
	    if (NULL == pwszT)
	    {
		pwszT = L"PolicyFlags=%x";
	    }
	    wsprintf(&awc[wcslen(awc)], pwszT, POLICY_MASK & ExtFlags);
	}
	switch (EXTENSION_ORIGIN_MASK & ExtFlags)
	{
	    case EXTENSION_ORIGIN_REQUEST:
		msgid = IDS_REQUEST;	// "Request"
		break;

	    case EXTENSION_ORIGIN_POLICY:
		msgid = IDS_POLICY;		// "Policy"
		break;

	    case EXTENSION_ORIGIN_ADMIN:
		msgid = IDS_ADMIN;		// "Admin"
		break;

	    case EXTENSION_ORIGIN_SERVER:
		msgid = IDS_SERVER;		// "Server"
		break;

	    case EXTENSION_ORIGIN_RENEWALCERT:
		msgid = IDS_RENEWALCERT;	// "Renewal Cert"
		break;

	    case EXTENSION_ORIGIN_IMPORTEDCERT:
		msgid = IDS_IMPORTEDCERT;	// "Imported Cert"
		break;

	    case EXTENSION_ORIGIN_PKCS7:
		msgid = IDS_PKCS7ATTRIBUTE;	// "PKCS7 Attribute"
		break;

	    case EXTENSION_ORIGIN_CMC:
		msgid = IDS_CMCATTRIBUTE;	// "CMC Attribute"
		break;

	    default:
		msgid = IDS_UNKNOWN;	// "UNKNOWN"
		break;
	}
	wcscat(awc, pwszSep);
	pwszSep = pwszComma;
	pwszT = myLoadResourceString(IDS_FORMAT_ORIGIN); // "Origin=%ws"
	if (NULL == pwszT)
	{
	    pwszT = L"Origin=%ws";
	}
	wsprintf(&awc[wcslen(awc)], pwszT, myLoadResourceString(msgid));

	if (EXTRA_MASK & ExtFlags)
	{
	    wcscat(awc, pwszSep);
	    pwszT = myLoadResourceString(IDS_FORMAT_UNKNOWN_HEX); // "???=%x"
	    if (NULL == pwszT)
	    {
		pwszT = L"???=%x";
	    }
	    wsprintf(&awc[wcslen(awc)], pwszT, EXTRA_MASK & ExtFlags);
	}
    }
    if (L'\0' != awc[0])
    {
	wcscat(awc, wszRPAREN);
    }
    return(awc);
}


VOID
PrintStringWithPrefix(
    IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn)
{
    while (L'\0' != *pwszIn)
    {
	DWORD i;
	DWORD j;
	WCHAR const *pwszNewLine;

	pwszNewLine = g_wszEmpty;
	j = 0;
	i = wcscspn(pwszIn, L"\n");
	if (L'\n' == pwszIn[i])
	{
	    pwszNewLine = L"\n";
	    j++;
	    if (0 < i && L'\r' == pwszIn[i - 1])
	    {
		i--;
		j++;
	    }
	}
	wprintf(L"%ws%.*ws%ws", pwszPrefix, i, pwszIn, pwszNewLine);
	pwszIn += i + j;
    }
}


WCHAR const *
wszAltNameChoice(
    IN LONG Choice)
{
    WCHAR const *pwsz;

    switch (Choice)
    {
	case CERT_ALT_NAME_OTHER_NAME:
	    pwsz = L"CERT_ALT_NAME_OTHER_NAME";
	    break;

	case CERT_ALT_NAME_RFC822_NAME:
	    pwsz = L"CERT_ALT_NAME_RFC822_NAME";
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    pwsz = L"CERT_ALT_NAME_DNS_NAME";
	    break;

	case CERT_ALT_NAME_X400_ADDRESS:
	    pwsz = L"CERT_ALT_NAME_X400_ADDRESS";
	    break;

	case CERT_ALT_NAME_DIRECTORY_NAME:
	    pwsz = L"CERT_ALT_NAME_DIRECTORY_NAME";
	    break;

	case CERT_ALT_NAME_EDI_PARTY_NAME:
	    pwsz = L"CERT_ALT_NAME_EDI_PARTY_NAME";
	    break;

	case CERT_ALT_NAME_URL:
	    pwsz = L"CERT_ALT_NAME_URL";
	    break;

	case CERT_ALT_NAME_IP_ADDRESS:
	    pwsz = L"CERT_ALT_NAME_IP_ADDRESS";
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    pwsz = L"CERT_ALT_NAME_REGISTERED_ID";
	    break;

	default:
	    pwsz = myLoadResourceString(IDS_QUESTIONMARKS); // "???"
	    break;
    }
    return(pwsz);
}


HRESULT
DumpAltName(
    IN BYTE const *pbExtension,
    IN DWORD cbExtension)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    BSTR strObjId = NULL;
    BSTR strName = NULL;
    ICertEncodeAltName *pAltName = NULL;
    VARIANT varExtension;
    LONG Count;
    LONG Choice;
    LONG i;

    hr = CoCreateInstance(
		    CLSID_CCertEncodeAltName,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertEncodeAltName,
		    (VOID **) &pAltName);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (!ConvertWszToBstr(
		    &strExtension,
		    (WCHAR const *) pbExtension,
		    cbExtension))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;

    hr = pAltName->Decode(strExtension);
    _JumpIfError(hr, error, "Decode");

    hr = pAltName->GetNameCount(&Count);
    _JumpIfError(hr, error, "GetNameCount");

    wprintf(g_wszPad4);
    wprintf(
	myLoadResourceString(IDS_FORMAT_ALTNAMECOUNT), // "AltName: %u entries:"
	Count);
    wprintf(wszNewLine);

    for (i = 0; i < Count; i++)
    {
	BOOL fNameBlob = FALSE;

	hr = pAltName->GetNameChoice(i, &Choice);
	_JumpIfError(hr, error, "GetNameChoice");

	if (NULL != strName)
	{
	    SysFreeString(strName);
	    strName = NULL;
	}
	hr = pAltName->GetName(i, &strName);
	_JumpIfError(hr, error, "GetName");

	myRegisterMemAlloc(strName, -1, CSM_SYSALLOC);

	wprintf(
	    L"    %ws[%u] ",
	    myLoadResourceString(IDS_ALTNAME),	// "AltName"
	    i);
	if (CERT_ALT_NAME_DIRECTORY_NAME == Choice)
	{
	    fNameBlob = TRUE;		// Name is encoded as a blob
	}
	else if (CERT_ALT_NAME_OTHER_NAME == Choice)
	{
	    if (NULL != strObjId)
	    {
		SysFreeString(strObjId);
		strObjId = NULL;
	    }
	    hr = pAltName->GetName(EAN_NAMEOBJECTID | i, &strObjId);
	    _JumpIfError(hr, error, "GetName");

	    myRegisterMemAlloc(strObjId, -1, CSM_SYSALLOC);

	    cuDumpOIDAndDescription(strObjId);
	    wprintf(L": ");

	    if (0 == lstrcmpi(TEXT(szOID_NT_PRINCIPAL_NAME), strObjId))
	    {
		CERT_NAME_VALUE *pNameValueA = NULL;
		CERT_NAME_VALUE *pNameValueW = NULL;
		DWORD cb;

		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_ANY_STRING,
				(BYTE *) strName,
				SysStringByteLen(strName),
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNameValueA,
				&cb))
		{
		    hr = myHLastError();
		    _PrintError(hr, "myDecodeObject");
		    CSASSERT(NULL == pNameValueA);
		}

		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_UNICODE_ANY_STRING,
				(BYTE *) strName,
				SysStringByteLen(strName),
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNameValueW,
				&cb))
		{
		    hr = myHLastError();
		    _PrintError(hr, "myDecodeObject");
		    CSASSERT(NULL == pNameValueW);
		}

		if (NULL != pNameValueA && NULL != pNameValueW)
		{
		    wprintf(L"\n");
		    wprintf(g_wszPad8);
		    hr = cuDisplayCertNameValue(
					NULL,
					wszAltNameChoice(Choice),
					pNameValueW->dwValueType,
					&pNameValueW->Value,
					&pNameValueA->Value);
		    _PrintIfError(hr, "cuDisplayCertNameValue");
		}
		if (NULL != pNameValueA)
		{
		    LocalFree(pNameValueA);
		}
		if (NULL != pNameValueW)
		{
		    LocalFree(pNameValueW);
		}
	    }
	    else
	    {
		// Other Name is often encoded as a name blob; give it a shot.

		fNameBlob = TRUE;
	    }
	}
	else
	{
	    wprintf(L"%ws: '%ws'\n", wszAltNameChoice(Choice), strName);
	}
	if (fNameBlob)
	{
	    CERT_NAME_BLOB Name;

	    Name.pbData = (BYTE *) strName;
	    Name.cbData = SysStringByteLen(strName);

	    hr = cuDisplayCertName(
			    TRUE,
			    NULL,
			    wszAltNameChoice(Choice),
			    g_wszPad8,
			    &Name);
	    _PrintIfError(hr, "cuDisplayCertName(DirectoryName)");
	}
    }

error:
    if (NULL != strObjId)
    {
        SysFreeString(strObjId);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != pAltName)
    {
        pAltName->Release();
    }
    return(hr);
}


#define BLOB_ROUND(cb) \
	(((cb) + sizeof(CRYPT_DATA_BLOB) - 1) / sizeof(CRYPT_DATA_BLOB))

HRESULT
DumpOctetHash(
    IN WCHAR const *pwszPad,
    IN WCHAR const *pwszDescription,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT BYTE *pbOut,
    OPTIONAL IN OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRYPT_DATA_BLOB aBlob[1 + BLOB_ROUND(CBMAX_CRYPT_HASH_LEN)];
    DWORD cb;
    BSTR strHash = NULL;

    cb = sizeof(aBlob);
    if (CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			pbIn,
			cbIn,
			0,
			aBlob,
			&cb))
    {
	if (NULL == pbOut)
	{
	    wprintf(L"%ws%ws:\n", pwszPad, pwszDescription);

	    hr = MultiByteIntegerToBstr(
				TRUE,
				aBlob[0].cbData,
				aBlob[0].pbData,
				&strHash);
	    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

	    wprintf(L"        %ws\n", strHash);
	}
	else
	{
	    if (NULL == pcbOut)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "NULL parm");
	    }
	    cb = *pcbOut;
	    *pcbOut = aBlob[0].cbData;
	    CopyMemory(pbOut, aBlob[0].pbData, min(cb, aBlob[0].cbData));

	    if (cb < aBlob[0].cbData)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		_JumpError(hr, error, "buffer too small");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != strHash)
    {
        SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
DumpHash(
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN DWORD idMessage,
    IN WCHAR const *pwszHashName,
    IN BYTE const *pbHash,
    IN DWORD cbHash)
{
    HRESULT hr;
    BSTR strHash = NULL;

    if (NULL != pbHash)
    {
	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");

	if (NULL != pwszPrefix)
	{
	    wprintf(pwszPrefix);
	}
	if (0 != idMessage)
	{
	    wprintf(myLoadResourceString(idMessage), pwszHashName, strHash);
	}
	else
	{
	    wprintf(strHash);
	}
	wprintf(wszNewLine);

	if (1 < g_fVerbose)
	{
	    DumpHex(DH_NOTABPREFIX | 4, pbHash, cbHash);
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != strHash)
    {
        SysFreeString(strHash);
    }
    return(hr);
}


#define FOT_EXTENSION	0
#define FOT_ATTRIBUTE	1
#define FOT_PROPERTY	2


BOOL
DumpFormattedObject(
    IN char const *pszObjId,
    IN DWORD Type,		// FOT_*
    IN BYTE const *pbObject,
    IN DWORD cbObject)
{
    HRESULT hr;
    BOOL fDisplayed = FALSE;
    WCHAR *pwszFormatted = NULL;
    DWORD cbFormatted;
    CRYPT_DATA_BLOB *pBlobProp = NULL;
    DWORD cbBlobProp;
    WCHAR const *pwszPrefix0 = g_wszPad4;
    WCHAR const *pwszPrefix1 = g_wszPad8;
    WCHAR const *pwszDescriptiveName;

    // format the object using the installed formatting function

    hr = S_OK;
    if (!CryptFormatObject(
		    X509_ASN_ENCODING,
		    0,
		    CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
		    NULL,
		    pszObjId,
		    pbObject,
		    cbObject,
		    NULL,
		    &cbFormatted))
    {
	hr = myHLastError();
	_PrintErrorStr2(hr, pszObjId, L"CryptFormatObject", hr);
	if (S_OK == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
    }

    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr &&
	    CRYPT_E_ASN1_BADTAG != hr)
	{
	    _JumpError(hr, error, "CryptFormatObject");
	}
	if (FOT_PROPERTY == Type)
	{
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pbObject,
			    cbObject,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pBlobProp,
			    &cbBlobProp))
	    {
		hr = myHLastError();
		_PrintError(hr, "myDecodeObject");
	    }
	    else
	    {
		hr = cuDumpFormattedProperty(
				    MAXDWORD,
				    pszObjId,
				    pBlobProp->pbData,
				    pBlobProp->cbData);
		_PrintIfError(hr, "cuDumpFormattedProperty");
		if (S_OK == hr)
		{
		    fDisplayed = TRUE;
		}
	    }
	}
	if (S_OK != hr && !g_fQuiet)
	{
	    PrintStringWithPrefix(
		pwszPrefix0,
		myLoadResourceString(FOT_ATTRIBUTE == Type?
		    IDS_UNKNOWN_ATTRIBUTE : // "Unknown Attribute type"
		    (FOT_EXTENSION == Type?
			IDS_UNKNOWN_EXTENSION : // "Unknown Extension type"
			IDS_UNKNOWN_PROPERTY))); // "Unknown Property"
	    wprintf(wszNewLine);
	}
    }
    else
    {
	pwszFormatted = (WCHAR *) LocalAlloc(LMEM_FIXED, cbFormatted);
	if (NULL == pwszFormatted)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	if (!CryptFormatObject(
			X509_ASN_ENCODING,
			0,
			CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
			NULL,
			pszObjId,
			pbObject,
			cbObject,
			pwszFormatted,
			&cbFormatted))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, pszObjId, L"CryptFormatObject");
	}
	PrintStringWithPrefix(g_fQuiet? g_wszEmpty : pwszPrefix1, pwszFormatted);
	fDisplayed = TRUE;
    }

    if (g_fVerbose)
    {
	if (0 == strcmp(szOID_SUBJECT_ALT_NAME, pszObjId) ||
	    0 == strcmp(szOID_SUBJECT_ALT_NAME2, pszObjId) ||
	    0 == strcmp(szOID_ISSUER_ALT_NAME, pszObjId) ||
	    0 == strcmp(szOID_ISSUER_ALT_NAME2, pszObjId))
	{
	    DumpAltName(pbObject, cbObject);
	}
    }

error:
    if (NULL != pBlobProp)
    {
	LocalFree(pBlobProp);
    }
    if (NULL != pwszFormatted)
    {
	LocalFree(pwszFormatted);
    }
    return(fDisplayed);
}


HRESULT
cuDumpUsage(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN DWORD idMessage,
    IN CTL_USAGE const *pUsage)
{
    HRESULT hr;
    DWORD i;

    if (NULL == pwszPrefix)
    {
	pwszPrefix = L"";
    }
    wprintf(L"%ws", pwszPrefix);
    wprintf(myLoadResourceString(idMessage));
    wprintf(L" %u\n", pUsage->cUsageIdentifier);
    for (i = 0; i < pUsage->cUsageIdentifier; i++)
    {
	wprintf(
	    L"%ws%ws[%d] ",
	    pwszPrefix,
	    g_wszPad2,
	    i);
	cuDumpOIDAndDescriptionA(pUsage->rgpszUsageIdentifier[i]);
	wprintf(wszNewLine);
    }
    hr = S_OK;

//error:
    return(hr);
}


typedef struct _DUMPPROP
{
    DWORD dwPropId;
    WCHAR const *pwszDescription;
} DUMPPROP;

#define _DFPROP(def)		{ (def), L#def }

DUMPPROP s_apwszPropIds[] = {
    _DFPROP(CERT_KEY_PROV_HANDLE_PROP_ID),
    _DFPROP(CERT_KEY_PROV_INFO_PROP_ID),
    _DFPROP(CERT_SHA1_HASH_PROP_ID),
    _DFPROP(CERT_MD5_HASH_PROP_ID),
    _DFPROP(CERT_KEY_CONTEXT_PROP_ID),
    _DFPROP(CERT_KEY_SPEC_PROP_ID),
    _DFPROP(CERT_IE30_RESERVED_PROP_ID),
    _DFPROP(CERT_PUBKEY_HASH_RESERVED_PROP_ID),
    _DFPROP(CERT_ENHKEY_USAGE_PROP_ID),
    _DFPROP(CERT_NEXT_UPDATE_LOCATION_PROP_ID),
    _DFPROP(CERT_FRIENDLY_NAME_PROP_ID),
    _DFPROP(CERT_PVK_FILE_PROP_ID),
    _DFPROP(CERT_DESCRIPTION_PROP_ID),
    _DFPROP(CERT_ACCESS_STATE_PROP_ID),
    _DFPROP(CERT_SIGNATURE_HASH_PROP_ID),
    _DFPROP(CERT_SMART_CARD_DATA_PROP_ID),
    _DFPROP(CERT_EFS_PROP_ID),
    _DFPROP(CERT_FORTEZZA_DATA_PROP_ID),
    _DFPROP(CERT_ARCHIVED_PROP_ID),
    _DFPROP(CERT_KEY_IDENTIFIER_PROP_ID),
    _DFPROP(CERT_AUTO_ENROLL_PROP_ID),
    _DFPROP(CERT_PUBKEY_ALG_PARA_PROP_ID),
    _DFPROP(CERT_CROSS_CERT_DIST_POINTS_PROP_ID),
    _DFPROP(CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID),
    _DFPROP(CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID),
    _DFPROP(CERT_ENROLLMENT_PROP_ID),
    _DFPROP(CERT_DATE_STAMP_PROP_ID),
    _DFPROP(CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID),
    _DFPROP(CERT_SUBJECT_NAME_MD5_HASH_PROP_ID),
    _DFPROP(CERT_EXTENDED_ERROR_INFO_PROP_ID),
};


HRESULT
cuDumpFormattedProperty(
    IN DWORD dwPropId,
    OPTIONAL IN char const *pszObjId,
    IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;
    char szObjId[sizeof(szOID_CERT_PROP_ID_PREFIX) + 20];
    WCHAR const *pwszDescriptiveName;
    BOOL fDisplayed;
    DWORD i;

    CSASSERT(NULL == pszObjId || MAXDWORD == dwPropId);

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (NULL != pszObjId)
    {
	char const *psz;
	
	if (0 != strncmp(
		    szOID_CERT_PROP_ID_PREFIX,
		    pszObjId,
		    ARRAYSIZE(szOID_CERT_PROP_ID_PREFIX) - 1))
	{
	    _JumpError(hr, error, "Not a property ObjId");
	}
	psz = &pszObjId[ARRAYSIZE(szOID_CERT_PROP_ID_PREFIX) - 1];
	dwPropId = atol(psz);
	while ('\0' != *psz)
	{
	    if (!isdigit(*psz))
	    {
		_JumpError(hr, error, "Bad property ObjId suffix");
	    }
	    psz++;
	}
    }

    wprintf(wszNewLine);
    for (i = 0; ; i++)
    {
	if (i >= ARRAYSIZE(s_apwszPropIds))
	{
	    pwszDescriptiveName = myLoadResourceString(IDS_UNKNOWN_PROPERTY); // "Unknown Property"
	    break;
	}
	if (s_apwszPropIds[i].dwPropId == dwPropId)
	{
	    pwszDescriptiveName = s_apwszPropIds[i].pwszDescription;
	    break;
	}
    }
    wprintf(L"  %ws", pwszDescriptiveName);
    if (NULL != pszObjId)
    {
	wprintf(L"(%hs)", pszObjId);
    }
    else
    {
	wprintf(L"(%u)", dwPropId);
    }

    sprintf(szObjId, "%hs%u", szOID_CERT_PROP_ID_PREFIX, dwPropId);
    pwszDescriptiveName = cuGetOIDNameA(szObjId);
    if (NULL != pwszDescriptiveName && L'\0' != *pwszDescriptiveName)
    {
	wprintf(L" %ws", pwszDescriptiveName);
    }
    wprintf(L":\n");
#if 0
    fDisplayed = DumpFormattedObject(szObjId, FOT_PROPERTY, pb, cb);
#else
    fDisplayed = FALSE;
#endif
    if (!fDisplayed)
    {
	if (IS_CERT_HASH_PROP_ID(dwPropId) ||
	    IS_PUBKEY_HASH_PROP_ID(dwPropId) ||
	    IS_CHAIN_HASH_PROP_ID(dwPropId) ||
	    CERT_KEY_IDENTIFIER_PROP_ID == dwPropId)
	{
	    wprintf(g_wszPad4);

	    hr = DumpHash(NULL, 0, g_wszEmpty, pb, cb);
	    _JumpIfError(hr, error, "DumpHash");

	    fDisplayed = TRUE;
	}
	else
	if (CERT_FRIENDLY_NAME_PROP_ID == dwPropId ||
	    CERT_DESCRIPTION_PROP_ID == dwPropId)
	{
	    wprintf(L"%ws%ws\n", g_wszPad4, pb);
	    fDisplayed = TRUE;
	}
	else
	if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId)
	{
	    hr = cuDumpCertKeyProviderInfo(
				    g_wszPad4,
				    NULL,
				    (CRYPT_KEY_PROV_INFO *) pb,
				    NULL);
	    _JumpIfError(hr, error, "cuDumpCertKeyProviderInfo");

	    fDisplayed = TRUE;
	}
	else
	if (CERT_CTL_USAGE_PROP_ID == dwPropId)
	{
	    CTL_USAGE *pUsage;

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_ENHANCED_KEY_USAGE,
			    pb,
			    cb,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pUsage,
			    &cb))
	    {
		hr = myHLastError();
		_PrintError(hr, "myDecodeObject");
	    }
	    else
	    {
		hr = cuDumpUsage(g_wszPad2, IDS_USAGEENTRIES, pUsage);
		_JumpIfError(hr, error, "cuDumpUsage");

		fDisplayed = TRUE;
	    }
	}
	else
	if (CERT_PUBKEY_ALG_PARA_PROP_ID == dwPropId)
	{
	    CERT_DSS_PARAMETERS *pDssParms;

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_DSS_PARAMETERS,
			    pb,
			    cb,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pDssParms,
			    &cb))
	    {
		hr = myHLastError();
		_PrintError(hr, "myDecodeObject");
	    }
	    else
	    {

		wprintf(
		    myLoadResourceString(IDS_FORMAT_DSSKEY_LENGTH), // "DSS Key Length: %u bits"
		    pDssParms->p.cbData * 8);

		wprintf(L"  DSS P:\n");
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 4,
		    pDssParms->p.pbData,
		    pDssParms->p.cbData);

		wprintf(L"  DSS Q:\n");
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 4,
		    pDssParms->q.pbData,
		    pDssParms->q.cbData);

		wprintf(L"  DSS G:\n");
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 4,
		    pDssParms->g.pbData,
		    pDssParms->g.cbData);

		LocalFree(pDssParms);
		fDisplayed = TRUE;
	    }
	}
    }
    if (!fDisplayed || g_fVerbose)
    {
	DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | 4, pb, cb);
    }
    hr = S_OK;

error:
    return(hr);
}


//+-------------------------------------------------------------------------
// cuDecodeObjId -- decode an ASN.1 encoded ObjectId
//
// Construct an ASN.1 encoded PKCS_ATTRIBUTE with an array of empty values,
// to trick CryptDecodeObject into decoding the passed in encoded Object Id.
//--------------------------------------------------------------------------

HRESULT
cuDecodeObjId(
    IN BYTE const *pbData,
    IN DWORD cbData,
    char **ppszObjId)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE *pAttr = NULL;
    BYTE *pbAlloc = NULL;
    DWORD cbAlloc;
    BYTE *pb;
    DWORD cb;

    //DumpHex(DH_NOTABPREFIX | 2, pbData, cbData);
    cbAlloc = 2 + cbData + 2;
    pbAlloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbAlloc);
    if (NULL == pbAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pb = pbAlloc;
    *pb++ = BER_SEQUENCE;		// PKCS_ATTRIBUTE sequence
    CSASSERT(0x7f >= cbData + 2);
    *pb++ = (BYTE ) (cbData + 2);	// overall length
    CopyMemory(pb, pbData, cbData);	// copy encoded Object Id
    pb += cbData;
    *pb++ = BER_SET;			// empty array of attribute values
    *pb = 0;				// zero length array of values

    //DumpHex(DH_NOTABPREFIX | 2, pbAlloc, cbAlloc);

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    pbAlloc,
		    cbAlloc,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pAttr,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    *ppszObjId = (char *) LocalAlloc(LMEM_FIXED, strlen(pAttr->pszObjId) + 1);
    if (NULL == *ppszObjId)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    strcpy(*ppszObjId, pAttr->pszObjId);
    hr = S_OK;

error:
    if (NULL != pbAlloc)
    {
	LocalFree(pbAlloc);
    }
    if (NULL != pAttr)
    {
	LocalFree(pAttr);
    }
    return(hr);
}


// UnicodeDecode()
//
// This function is responsible for decoding unicode crypt data blobs from
// various certificate fields.  The returned WCHAR * must be freed by LocalFree
//
// Params:
//
// pBlob - IN CRYPT_DATA_BLOB to be decoded, expected UNICODE
//
// Returns:
//
// WCHAR * to decoded string, to be freed using LocalFree


HRESULT
UnicodeDecode(
    IN CRYPT_DATA_BLOB const *pBlob,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    CERT_NAME_VALUE *pName = NULL;
    DWORD cb;

    *ppwszOut = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    pBlob->pbData,
		    pBlob->cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pName,
		    &cb))
    {
	CSASSERT(NULL == pName);
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = myDupString((WCHAR const *) pName->Value.pbData, ppwszOut);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    return(hr);
}


BOOL
cuDumpFormattedExtension(
    IN WCHAR const *pwszName,
    IN BYTE const *pbObject,
    IN DWORD cbObject)
{
    HRESULT hr;
    BOOL fDisplayed = FALSE;
    char *pszObjId = NULL;
    BSTR strHash = NULL;
    WCHAR const *pwszDescriptiveName;
    DWORD cb;
    WCHAR const *pwszPad = g_fQuiet? g_wszEmpty : g_wszPad4;

    if (!ConvertWszToSz(&pszObjId, pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }
    pwszDescriptiveName = cuGetOIDName(pwszName);
    if (NULL != pwszDescriptiveName && L'\0' != *pwszDescriptiveName)
    {
	PrintStringWithPrefix(pwszPad, pwszDescriptiveName);
	if (g_fQuiet)
	{
	    wprintf(L": ");
	}
	else
	{
	    wprintf(wszNewLine);
	}
    }
    if (0 == cbObject)
    {
	if (!g_fQuiet)
	{
	    wprintf(
		L"%ws%ws\n",
		g_wszPad8,
		myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
	}
	fDisplayed = TRUE;
    }
    else
    {
	fDisplayed = DumpFormattedObject(
				    pszObjId,
				    FOT_EXTENSION,
				    pbObject,
				    cbObject);
	if (!fDisplayed)
	{
	    if (0 == strcmp(pszObjId, szOID_CERTSRV_CA_VERSION))
	    {
		DWORD NameId;

		cb = sizeof(NameId);
		NameId = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &NameId,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u.%u\n",
			pwszPad,
			myLoadResourceString(IDS_CAVERSION),
			g_wszCertUtil,
			CANAMEIDTOICERT(NameId),
			CANAMEIDTOIKEY(NameId));
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CERTSRV_PREVIOUS_CERT_HASH))
	    {
		hr = DumpOctetHash(
			    pwszPad,
			    // UNDONE: Localize or use new crypt32.dll
			    L"Previous CA Cert Hash" wszCERTUTIL, // myLoadResourceString(IDS_CAVERSION),
			    pbObject,
			    cbObject,
			    NULL,
			    NULL);
		if (S_OK == hr)
		{
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_NUMBER))
	    {
		DWORD CRLNumber;

		cb = sizeof(CRLNumber);
		CRLNumber = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &CRLNumber,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u\n",
			pwszPad,
			// UNDONE: Localize or use new crypt32.dll
			L"CRL Number" wszCERTUTIL, // myLoadResourceString(IDS_CAVERSION),
			g_wszCertUtil,
			CRLNumber);
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_DELTA_CRL_INDICATOR))
	    {
		DWORD CRLNumber;

		cb = sizeof(CRLNumber);
		CRLNumber = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &CRLNumber,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u\n",
			pwszPad,
			// UNDONE: Localize or use new crypt32.dll
			L"Minimum Base CRL Number", // myLoadResourceString(IDS_CAVERSION),
			g_wszCertUtil,
			CRLNumber);
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_VIRTUAL_BASE))
	    {
		DWORD CRLNumber;

		cb = sizeof(CRLNumber);
		CRLNumber = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &CRLNumber,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u\n",
			pwszPad,
			// UNDONE: Localize or use new crypt32.dll
			L"Virtual Base CRL Number", // myLoadResourceString(IDS_CAVERSION),
			g_wszCertUtil,
			CRLNumber);
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_NEXT_PUBLISH) ||
		0 == strcmp(pszObjId, szOID_RSA_signingTime))
	    {
		FILETIME ft;

		cb = sizeof(ft);
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_CHOICE_OF_TIME,
				    pbObject,
				    cbObject,
				    0,
				    &ft,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: ",
			pwszPad,
			// UNDONE: Localize or use new crypt32.dll
			0 == strcmp(pszObjId, szOID_CRL_NEXT_PUBLISH)?
			    L"CRL Next Publish" : // myLoadResourceString(IDS_CAVERSION),
			    L"Signing Time", // myLoadResourceString(IDS_CAVERSION),
			g_wszCertUtil);
		    hr = cuDumpFileTime(0, NULL, &ft);
		    _JumpIfError(hr, error, "cuDumpFileTime");

		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_FRESHEST_CRL))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    // UNDONE: Localize or use new crypt32.dll
		    L"Delta CRL CDP",
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_CRL_DIST_POINTS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_SELF_CDP))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    // UNDONE: Localize or use new crypt32.dll
		    L"CRL Self CDP", // myLoadResourceString(IDS_CAVERSION),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_CRL_DIST_POINTS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_PKIX ".2"))
	    {
		// Exchange policy module intended to use szOID_PKIX_CA_ISSUERS,
		// but the ".48.2" suffix was instead written as ".2".
		//
		// szOID_PKIX_CA_ISSUERS was wrong anyway -- it should have
		// used szOID_AUTHORITY_INFO_ACCESS instead.

		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_EXCHANGEAIA), // "Exchange Authority Information Access"
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_AUTHORITY_INFO_ACCESS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_ISSUER_ALT_NAME))
	    {
		// Exchange policy module overloaded this OID and stored the
		// file version information for expolicy.dll and certsrv.exe.

		typedef struct _CUVER {
		    USHORT usMajor;
		    USHORT usMinor;
		    USHORT usBuild;
		    USHORT usBuildMinor;
		} CUVER;

		CUVER const *pVer;
		CRYPT_INTEGER_BLOB aBlob[1 + BLOB_ROUND(2 * sizeof(*pVer))];

		cb = sizeof(aBlob);
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_MULTI_BYTE_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    aBlob,
				    &cb))
		{
		    if (2 * sizeof(*pVer) == aBlob[0].cbData)
		    {
			wprintf(
			    L"%ws%ws%ws:\n",
			    pwszPad,
			    myLoadResourceString(IDS_EXCHANGEVERSION), // "Exchange Version"
			    g_wszCertUtil);

			pVer = (CUVER const *) aBlob[0].pbData;
			wprintf(
			    L"        expolicy.dll: %u.%u:%u.%u\n",
			    pVer->usMajor,
			    pVer->usMinor,
			    pVer->usBuild,
			    pVer->usBuildMinor);

			pVer++;
			wprintf(
			    L"        certsrv.exe: %u.%u:%u.%u\n",
			    pVer->usMajor,
			    pVer->usMinor,
			    pVer->usBuild,
			    pVer->usBuildMinor);
			fDisplayed = TRUE;
		    }
		}
		else
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptDecodeObject");
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_APPLICATION_CERT_POLICIES))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    // UNDONE: Localize or use new crypt32.dll
		    L"Application Policies", // myLoadResourceString(IDS_CAVERSION),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_CERT_POLICIES),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_APPLICATION_POLICY_MAPPINGS))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    // UNDONE: Localize or use new crypt32.dll
		    L"Application Policy Mappings", // myLoadResourceString(IDS_CAVERSION),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_POLICY_MAPPINGS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_APPLICATION_POLICY_CONSTRAINTS))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    // UNDONE: Localize or use new crypt32.dll
		    L"Application Policy Constraints", // myLoadResourceString(IDS_CAVERSION),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_POLICY_CONSTRAINTS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_POLICY_MAPPINGS))
	    {
		CERT_POLICY_MAPPINGS_INFO *pPolicyMappings = NULL;
		DWORD i;

		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_POLICY_MAPPINGS,
				pbObject,
				cbObject,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pPolicyMappings,
				&cb))
		{
		    hr = myHLastError();
		    CSASSERT(NULL == pPolicyMappings);
		    _JumpIfError(hr, error, "myDecodeObject");
		}

		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    // UNDONE: Localize or use new crypt32.dll
		    L"Policy Mappings", // myLoadResourceString(IDS_CAVERSION),
		    g_wszCertUtil);

		for (i = 0; i < pPolicyMappings->cPolicyMapping; i++)
		{
		    wprintf(g_wszPad4);
            wprintf(myLoadResourceString(IDS_FORMAT_MAP_ARRAY_COLON), i);
		    wprintf(wszNewLine);

		    wprintf(g_wszPad8);
		    wprintf(myLoadResourceString(IDS_ISSUER_DOMAIN_POLICY));

		    cuDumpOIDAndDescriptionA(
			pPolicyMappings->rgPolicyMapping[i].pszIssuerDomainPolicy);
		    wprintf(wszNewLine);

		    wprintf(g_wszPad8);
		    wprintf(myLoadResourceString(IDS_SUBJECT_DOMAIN_POLICY));

		    cuDumpOIDAndDescriptionA(
			pPolicyMappings->rgPolicyMapping[i].pszSubjectDomainPolicy);
		    wprintf(wszNewLine);
		}

		LocalFree(pPolicyMappings);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_POLICY_CONSTRAINTS))
	    {
		CERT_POLICY_CONSTRAINTS_INFO Constraints;

		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_POLICY_CONSTRAINTS,
				    pbObject,
				    cbObject,
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptDecodeObject");
		}
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    // UNDONE: Localize or use new crypt32.dll
		    L"Policy Constraints", // myLoadResourceString(IDS_CAVERSION),
		    g_wszCertUtil);
		if (Constraints.fRequireExplicitPolicy)
		{
		    wprintf(
			L"        dwRequireExplicitPolicySkipCerts: %u\n",
			Constraints.dwRequireExplicitPolicySkipCerts);
		}
		if (Constraints.fInhibitPolicyMapping)
		{
		    wprintf(
			L"        dwInhibitPolicyMappingSkipCerts: %u\n",
			Constraints.dwInhibitPolicyMappingSkipCerts);
		}
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_REASON_CODE_HOLD))
	    {
		char *pszObjIdT;

		hr = cuDecodeObjId(pbObject, cbObject, &pszObjIdT);
		if (S_OK == hr)
		{
		    wprintf(pwszPad);
		    cuDumpOIDAndDescriptionA(pszObjIdT);
		    wprintf(wszNewLine);
		    LocalFree(pszObjIdT);

		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_VERISIGN_ONSITE_JURISDICTION_HASH))
	    {
		CRYPT_DATA_BLOB Value;
		WCHAR *pwsz;

		Value.pbData = const_cast<BYTE *>(pbObject);
		Value.cbData = cbObject;
		hr = UnicodeDecode(&Value, &pwsz);
		if (S_OK == hr)
		{
		    wprintf(L"%ws%ws\n", pwszPad, pwsz);
		    LocalFree(pwsz);
		    fDisplayed = TRUE;
		}
	    }
	}
    }

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(fDisplayed);
}


WCHAR const * const g_apwszFieldNames[] = {
    wszCONFIG_COMMONNAME,
    wszCONFIG_ORGUNIT,
    wszCONFIG_ORGANIZATION,
    wszCONFIG_LOCALITY,
    wszCONFIG_STATE,
    wszCONFIG_COUNTRY,
    wszCONFIG_CONFIG,
    wszCONFIG_EXCHANGECERTIFICATE,
    wszCONFIG_SIGNATURECERTIFICATE,
    wszCONFIG_DESCRIPTION,
    wszCONFIG_SERVER,
    wszCONFIG_AUTHORITY,
    wszCONFIG_SANITIZEDNAME,
    wszCONFIG_SHORTNAME,
    wszCONFIG_SANITIZEDSHORTNAME,
    wszCONFIG_FLAGS,
};
#define CSTRING (sizeof(g_apwszFieldNames)/sizeof(g_apwszFieldNames[0]))

WCHAR const *g_apwszDisplayNames[CSTRING];

LONG g_amsgidDisplayNames[CSTRING] = {
    IDS_CONFIGDISPLAY_COMMONNAME_COLON,
    IDS_CONFIGDISPLAY_ORGUNIT_COLON,
    IDS_CONFIGDISPLAY_ORG_COLON,
    IDS_CONFIGDISPLAY_LOCALITY_COLON,
    IDS_CONFIGDISPLAY_STATE_COLON,
    IDS_CONFIGDISPLAY_COUNTRY_COLON,
    IDS_CONFIGDISPLAY_CONFIG_COLON,
    IDS_CONFIGDISPLAY_EXCHANGECERT_COLON,
    IDS_CONFIGDISPLAY_SIGCERT_COLON,
    IDS_CONFIGDISPLAY_DESCRIPTION_COLON,
    IDS_CONFIGDISPLAY_SERVER_COLON,
    IDS_CONFIGDISPLAY_AUTHORITY_COLON,
    IDS_CONFIGDISPLAY_SANITIZEDNAME_COLON,
    IDS_CONFIGDISPLAY_SHORTNAME_COLON,
    IDS_CONFIGDISPLAY_SANITIZEDSHORTNAME_COLON,
    IDS_CONFIGDISPLAY_FLAGS_COLON,
};


HRESULT
cuConfigDump(VOID)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < CSTRING; i++)
    {
	g_apwszDisplayNames[i] = myLoadResourceString(g_amsgidDisplayNames[i]);
    }

    hr = ConfigDumpSetDisplayNames(
				g_apwszFieldNames,
				g_apwszDisplayNames,
				CSTRING);
    _JumpIfError(hr, error, "ConfigDumpSetDisplayNames");

    hr = ConfigDump(
		g_DispatchFlags,
		myLoadResourceString(IDS_CONFIGDISPLAY_ENTRY), // "Entry"
		myLoadResourceString(IDS_CONFIGDISPLAY_LOCAL), // "(Local)"
		g_pwszDnsName,
		g_pwszOldName);
    _JumpIfError(hr, error, "ConfigDump");

error:
    return(hr);
}


typedef HRESULT (FNDUMP)(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci);

FNDUMP dumpCert, dumpCRL, dumpRequest, dumpCMCRequest, dumpCMCResponse,
    dumpKeyGenRequest, dumpCertSequence, dumpCTL;

typedef struct _ASNFORMATS
{
    char const  *pszFormat;
    FNDUMP      *pfnDump;
    DWORD        idMessage;
    WCHAR const *pwszExtension;
} ASNFORMATS;


ASNFORMATS g_aasn[] = {
    {
	X509_CERT_TO_BE_SIGNED,
	dumpCert,
	IDS_DUMP_CERT,
	L".crt",
    },
    {
	X509_CERT_CRL_TO_BE_SIGNED,
	dumpCRL,
	IDS_DUMP_CRL,
	L".crl",
    },
    {
	X509_CERT_REQUEST_TO_BE_SIGNED,
	dumpRequest,
	IDS_DUMP_REQUEST,
	L".p10",
    },
    {
	CMC_DATA,
	dumpCMCRequest,
	IDS_DUMP_CMC,
	L".cmc",
    },
    {
	CMC_RESPONSE,
	dumpCMCResponse,
	IDS_DUMP_CMCRESPONSE,
	L".res",
    },
    {
	X509_KEYGEN_REQUEST_TO_BE_SIGNED,
	dumpKeyGenRequest,
	IDS_DUMP_KEYGEN,
	L".req",
    },
    {
	PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
	dumpCertSequence,
	IDS_DUMP_CERTSEQ,
	L".seq",
    },
    {
	PKCS_CTL,
	dumpCTL,
	IDS_DUMP_CTL,
	L".stl",
    },
};
#define CASNFORMATS (sizeof(g_aasn)/sizeof(g_aasn[0]))


HRESULT
dumpPKCS7(
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN BYTE const *pbIn,
    IN DWORD cbIn);


typedef struct _DUMPALGID
{
    ALG_ID Algid;
    WCHAR const *pwszDescription;
} DUMPALGID;

#define _DFALGID(algid)		{ (algid), L#algid }


DUMPALGID g_adfAlgids[] =
{
    _DFALGID(CALG_MD2),
    _DFALGID(CALG_MD4),
    _DFALGID(CALG_MD5),
    //_DFALGID(CALG_SHA),	same as CALG_SHA1
    _DFALGID(CALG_SHA1),
    _DFALGID(CALG_MAC),
    _DFALGID(CALG_RSA_SIGN),
    _DFALGID(CALG_DSS_SIGN),
    _DFALGID(CALG_NO_SIGN),
    _DFALGID(CALG_RSA_KEYX),
    _DFALGID(CALG_DES),
    _DFALGID(CALG_3DES_112),
    _DFALGID(CALG_3DES),
    _DFALGID(CALG_DESX),
    _DFALGID(CALG_RC2),
    _DFALGID(CALG_RC4),
    _DFALGID(CALG_SEAL),
    _DFALGID(CALG_DH_SF),
    _DFALGID(CALG_DH_EPHEM),
    _DFALGID(CALG_AGREEDKEY_ANY),
    _DFALGID(CALG_KEA_KEYX),
    _DFALGID(CALG_HUGHES_MD5),
    _DFALGID(CALG_SKIPJACK),
    _DFALGID(CALG_TEK),
    _DFALGID(CALG_CYLINK_MEK),
    _DFALGID(CALG_SSL3_SHAMD5),
    _DFALGID(CALG_SSL3_MASTER),
    _DFALGID(CALG_SCHANNEL_MASTER_HASH),
    _DFALGID(CALG_SCHANNEL_MAC_KEY),
    _DFALGID(CALG_SCHANNEL_ENC_KEY),
    _DFALGID(CALG_PCT1_MASTER),
    _DFALGID(CALG_SSL2_MASTER),
    _DFALGID(CALG_TLS1_MASTER),
    _DFALGID(CALG_RC5),
    _DFALGID(CALG_HMAC),
    _DFALGID(CALG_TLS1PRF),
    _DFALGID(CALG_HASH_REPLACE_OWF),
    _DFALGID(CALG_AES_128),
    _DFALGID(CALG_AES_192),
    _DFALGID(CALG_AES_256),
    _DFALGID(CALG_AES),
};


DUMPALGID g_adfClass[] =
{
    _DFALGID(ALG_CLASS_ANY),
    _DFALGID(ALG_CLASS_SIGNATURE),
    _DFALGID(ALG_CLASS_MSG_ENCRYPT),
    _DFALGID(ALG_CLASS_DATA_ENCRYPT),
    _DFALGID(ALG_CLASS_HASH),
    _DFALGID(ALG_CLASS_KEY_EXCHANGE),
};


DUMPALGID g_adfType[] =
{
    _DFALGID(ALG_TYPE_ANY),
    _DFALGID(ALG_TYPE_DSS),
    _DFALGID(ALG_TYPE_RSA),
    _DFALGID(ALG_TYPE_BLOCK),
    _DFALGID(ALG_TYPE_STREAM),
    _DFALGID(ALG_TYPE_DH),
    _DFALGID(ALG_TYPE_SECURECHANNEL),
};


// Generic sub-ids

DUMPALGID g_adfSubIdAny[] =
{
    _DFALGID(ALG_SID_ANY),
};


// Some DSS sub-ids

DUMPALGID g_adfSubIdDSS[] =
{
    _DFALGID(ALG_SID_DSS_ANY),
    _DFALGID(ALG_SID_DSS_PKCS),
    _DFALGID(ALG_SID_DSS_DMS),
};


// Some RSA sub-ids

DUMPALGID g_adfSubIdRSA[] =
{
    _DFALGID(ALG_SID_RSA_ANY),
    _DFALGID(ALG_SID_RSA_PKCS),
    _DFALGID(ALG_SID_RSA_MSATWORK),
    _DFALGID(ALG_SID_RSA_ENTRUST),
    _DFALGID(ALG_SID_RSA_PGP),
};


// Block cipher sub ids

DUMPALGID g_adfSubIdBlock[] =
{
    // RC2 sub-ids

    _DFALGID(ALG_SID_RC2),

    // DES sub_ids

    _DFALGID(ALG_SID_DES),
    _DFALGID(ALG_SID_3DES),
    _DFALGID(ALG_SID_DESX),
    _DFALGID(ALG_SID_IDEA),
    _DFALGID(ALG_SID_CAST),
    _DFALGID(ALG_SID_SAFERSK64),
    _DFALGID(ALG_SID_SAFERSK128),
    _DFALGID(ALG_SID_3DES_112),
    _DFALGID(ALG_SID_CYLINK_MEK),
    _DFALGID(ALG_SID_RC5),
    _DFALGID(ALG_SID_AES_128),
    _DFALGID(ALG_SID_AES_192),
    _DFALGID(ALG_SID_AES_256),
    _DFALGID(ALG_SID_AES),

    // Fortezza sub-ids

    _DFALGID(ALG_SID_SKIPJACK),
    _DFALGID(ALG_SID_TEK),
};


// Stream cipher sub-ids

DUMPALGID g_adfSubIdStream[] =
{
    _DFALGID(ALG_SID_RC4),
    _DFALGID(ALG_SID_SEAL),
};


// Diffie-Hellman sub-ids

DUMPALGID g_adfSubIdDH[] =
{
    _DFALGID(ALG_SID_DH_SANDF),
    _DFALGID(ALG_SID_DH_EPHEM),
    _DFALGID(ALG_SID_AGREED_KEY_ANY),
    _DFALGID(ALG_SID_KEA),
};


// secure channel sub ids

DUMPALGID g_adfSubIdSecureChannel[] =
{
    _DFALGID(ALG_SID_SSL3_MASTER),
    _DFALGID(ALG_SID_SCHANNEL_MASTER_HASH),
    _DFALGID(ALG_SID_SCHANNEL_MAC_KEY),
    _DFALGID(ALG_SID_PCT1_MASTER),
    _DFALGID(ALG_SID_SSL2_MASTER),
    _DFALGID(ALG_SID_TLS1_MASTER),
    _DFALGID(ALG_SID_SCHANNEL_ENC_KEY),
};


// Hash sub ids

DUMPALGID g_adfSubIdHash[] =
{
    _DFALGID(ALG_SID_MD2),
    _DFALGID(ALG_SID_MD4),
    _DFALGID(ALG_SID_MD5),
    _DFALGID(ALG_SID_SHA1),
    _DFALGID(ALG_SID_MAC),
    _DFALGID(ALG_SID_RIPEMD),
    _DFALGID(ALG_SID_RIPEMD160),
    _DFALGID(ALG_SID_SSL3SHAMD5),
    _DFALGID(ALG_SID_HMAC),
    _DFALGID(ALG_SID_TLS1PRF),
    _DFALGID(ALG_SID_HASH_REPLACE_OWF),
};


#if 0
// KP_MODE
#define CRYPT_MODE_CBCI                 6       // ANSI CBC Interleaved
#define CRYPT_MODE_CFBP                 7       // ANSI CFB Pipelined
#define CRYPT_MODE_OFBP                 8       // ANSI OFB Pipelined
#define CRYPT_MODE_CBCOFM               9       // ANSI CBC + OF Masking
#define CRYPT_MODE_CBCOFMI              10      // ANSI CBC + OFM Interleaved
#endif


typedef struct _DUMPSUBIDMAP
{
    DWORD      dwAlgType;
    DUMPALGID *adfSubId;
    DWORD      cdfSubId;
} DUMPSUBIDMAP;

#define _DFARRAYANDSIZE(adf)	(adf), ARRAYSIZE(adf)


DUMPSUBIDMAP g_adfSubIdMap[] =
{
    { ALG_TYPE_ANY,		_DFARRAYANDSIZE(g_adfSubIdAny) },
    { ALG_TYPE_DSS,		_DFARRAYANDSIZE(g_adfSubIdDSS) },
    { ALG_TYPE_RSA,		_DFARRAYANDSIZE(g_adfSubIdRSA) },
    { ALG_TYPE_BLOCK,		_DFARRAYANDSIZE(g_adfSubIdBlock) },
    { ALG_TYPE_STREAM,		_DFARRAYANDSIZE(g_adfSubIdStream) },
    { ALG_TYPE_DH,		_DFARRAYANDSIZE(g_adfSubIdDH) },
    { ALG_TYPE_SECURECHANNEL,	_DFARRAYANDSIZE(g_adfSubIdSecureChannel) },
};


VOID
cuDumpAlgid(
    IN DWORD Algid)
{
    WCHAR const *pwsz;
    WCHAR const *pwszQuestionMarks;
    DUMPALGID *pda;
    DUMPALGID *pdaSubId;
    DWORD cdaSubId;
    DUMPSUBIDMAP *pdsm;
    DWORD AlgClass;
    DWORD AlgType;
    DWORD AlgSubId;

    pwszQuestionMarks = myLoadResourceString(IDS_QUESTIONMARKS); // "???"

    for (pda = g_adfAlgids; pda < &g_adfAlgids[ARRAYSIZE(g_adfAlgids)]; pda++)
    {
	if (Algid == pda->Algid)
	{
	    wprintf(L"    %ws\n", pda->pwszDescription);
	    break;
	}
    }

    AlgClass = GET_ALG_CLASS(Algid);
    pwsz = pwszQuestionMarks;
    for (pda = g_adfClass; pda < &g_adfClass[ARRAYSIZE(g_adfClass)]; pda++)
    {
	if (AlgClass == pda->Algid)
	{
	    pwsz = pda->pwszDescription;
	    break;
	}
    }
    wprintf(
	L"    %ws: 0x%x(%u) %ws\n",
	myLoadResourceString(IDS_ALGORITHM_CLASS),	// "Algorithm Class"
	AlgClass,
	AlgClass >> 13,
	pwsz);

    AlgType = GET_ALG_TYPE(Algid);
    pwsz = pwszQuestionMarks;
    for (pda = g_adfType; pda < &g_adfType[ARRAYSIZE(g_adfType)]; pda++)
    {
	if (AlgType == pda->Algid)
	{
	    pwsz = pda->pwszDescription;
	    break;
	}
    }
    wprintf(
	L"    %ws: 0x%x(%u) %ws\n",
	myLoadResourceString(IDS_ALGORITHM_TYPE),	// "Algorithm Type"
	AlgType,
	AlgType >> 9,
	pwsz);

    pdaSubId = g_adfSubIdAny;
    cdaSubId = ARRAYSIZE(g_adfSubIdAny);
    for (pdsm = g_adfSubIdMap; pdsm < &g_adfSubIdMap[ARRAYSIZE(g_adfSubIdMap)]; pdsm++)
    {
	if (AlgType == pdsm->dwAlgType)
	{
	    pdaSubId = pdsm->adfSubId;
	    cdaSubId = pdsm->cdfSubId;
	    break;
	}
    }
    if (ALG_CLASS_HASH == AlgClass && pdaSubId == g_adfSubIdAny)
    {
	pdaSubId = g_adfSubIdHash;
	cdaSubId = ARRAYSIZE(g_adfSubIdHash);
    }
    pwsz = pwszQuestionMarks;
    AlgSubId = GET_ALG_SID(Algid);
    for (pda = pdaSubId; pda < &pdaSubId[cdaSubId]; pda++)
    {
	if (AlgSubId == pda->Algid)
	{
	    pwsz = pda->pwszDescription;
	    break;
	}
    }
    wprintf(
	L"    %ws: 0x%x(%u) %ws\n",
	myLoadResourceString(IDS_ALGORITHM_SUBID),	// "Algorithm Sub-id"
	AlgSubId,
	AlgSubId >> 0,
	pwsz);
}


HRESULT
cuDumpPrivateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN BOOL fQuiet)
{
    HRESULT hr;
    PUBLICKEYSTRUC const *pkey = (PUBLICKEYSTRUC const *) pbKey;
    WCHAR const *pwsz;
    WCHAR const *pwszQuestionMarks;

    if (sizeof(*pkey) >= cbKey)
    {
	DumpHex(DH_NOTABPREFIX | 2, pbKey, cbKey);
	hr = CRYPT_E_ASN1_BADTAG;
	_JumpError2(hr, error, "key check", hr);
    }
    if (fQuiet)
    {
	hr = S_OK;
	goto error;
    }
    wprintf(myLoadResourceString(IDS_PRIVATEKEY));
    wprintf(wszNewLine);

    pwszQuestionMarks = myLoadResourceString(IDS_QUESTIONMARKS); // "???"
    pwsz = pwszQuestionMarks;
    switch (pkey->bType)
    {
	case SIMPLEBLOB:	   pwsz = L"SIMPLEBLOB";	   break;
	case PUBLICKEYBLOB:	   pwsz = L"PUBLICKEYBLOB";	   break;
	case PRIVATEKEYBLOB:	   pwsz = L"PRIVATEKEYBLOB";	   break;
	case PLAINTEXTKEYBLOB:	   pwsz = L"PLAINTEXTKEYBLOB";	   break;
	case OPAQUEKEYBLOB:	   pwsz = L"OPAQUEKEYBLOB";	   break;
	case PUBLICKEYBLOBEX:	   pwsz = L"PUBLICKEYBLOBEX";	   break;
	case SYMMETRICWRAPKEYBLOB: pwsz = L"SYMMETRICWRAPKEYBLOB"; break;
    }
    wprintf(L"  %ws\n", pwsz);

    wprintf(g_wszPad2);
    wprintf(
	myLoadResourceString(IDS_FORMAT_VERSION),	// "Version: %u"
	pkey->bVersion);
    wprintf(wszNewLine);

    wprintf(L"  aiKeyAlg: 0x%x\n", pkey->aiKeyAlg);
    cuDumpAlgid(pkey->aiKeyAlg);

    DumpHex(DH_NOTABPREFIX | 2, (BYTE const *) &pkey[1], cbKey - sizeof(*pkey));
    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuDumpPrivateKey(
    IN CERT_CONTEXT const *pCert,
    OPTIONAL OUT BOOL *pfSigningKey,
    OPTIONAL OUT BOOL *pfMatchingKey)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    DWORD dwKeySpec;
    DWORD cb;
    CRYPT_BIT_BLOB PrivateKey;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfo = NULL;

    if (NULL != pfSigningKey)
    {
	*pfSigningKey = FALSE;
    }
    if (NULL != pfMatchingKey)
    {
	*pfMatchingKey = FALSE;
    }
    PrivateKey.pbData = NULL;
    if (!CryptAcquireCertificatePrivateKey(
				    pCert,
				    0,		// dwFlags
				    NULL,	// pvReserved
				    &hProv,
				    &dwKeySpec,
				    NULL))	// pfCallerFreeProv
    {
	hr = myHLastError();
	if (CRYPT_E_NO_KEY_PROPERTY == hr)
	{
	    wprintf(myLoadResourceString(IDS_NO_KEY_PROPERTY)); // "No stored keyset property"
	    wprintf(wszNewLine);
	    hr = S_OK;

	    _JumpError2(
		    CRYPT_E_NO_KEY_PROPERTY,
		    error,
		    "CryptAcquireCertificatePrivateKey",
		    CRYPT_E_NO_KEY_PROPERTY);
	}
	if (NTE_BAD_KEYSET == hr)
	{
	    wprintf(myLoadResourceString(IDS_NO_KEY));	// "Missing stored keyset"
	    wprintf(wszNewLine);
	    hr = S_OK;

	    _JumpError2(
		    NTE_BAD_KEYSET,
		    error,
		    "CryptAcquireCertificatePrivateKey",
		    NTE_BAD_KEYSET);
	}
	_JumpError(hr, error, "CryptAcquireCertificatePrivateKey");
    }
    if (NULL != pfSigningKey)
    {
	*pfSigningKey = AT_SIGNATURE == dwKeySpec;
    }

    if (!CryptGetUserKey(hProv, dwKeySpec, &hKey))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptGetUserKey");
	cuPrintError(IDS_ERR_FORMAT_LOADKEY, hr);
	goto error;
    }
    hr = myCryptExportPrivateKey(
		    hKey,
		    &PrivateKey.pbData,
		    &PrivateKey.cbData);
    if (NTE_BAD_KEY_STATE == hr)
    {
        wprintf(myLoadResourceString(IDS_PRIVATE_KEY_NOT_EXPORTABLE)); // "Private key is NOT exportable"
	wprintf(wszNewLine);
    }
    else
    {
	_JumpIfError(hr, error, "myCryptExportPrivateKey");
    }

    if (!myCryptExportPublicKeyInfo(
				hProv,
				dwKeySpec,
				CERTLIB_USE_LOCALALLOC,
				&pPublicKeyInfo,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    if (!myCertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    CERT_V1 == pCert->pCertInfo->dwVersion,
			    pPublicKeyInfo,
			    &pCert->pCertInfo->SubjectPublicKeyInfo))
    {
	// by design, (my)CertComparePublicKeyInfo doesn't set last error!

	wprintf(myLoadResourceString(IDS_ERR_PUBLICKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match stored keyset"
	wprintf(wszNewLine);
    }
    else
    {
	if (AT_SIGNATURE == dwKeySpec)
	{
	    hr = myValidateKeyForSigning(
				    hProv,
				    &pCert->pCertInfo->SubjectPublicKeyInfo,
				    CALG_SHA1);
	    _PrintIfError(hr, "myValidateKeyForSigning");
	}
	else
	{
	    hr = myValidateKeyForEncrypting(
				    hProv,
				    &pCert->pCertInfo->SubjectPublicKeyInfo,
				    CALG_RC4);
	    _PrintIfError(hr, "myValidateKeyForEncrypting");
	}
	if (S_OK != hr)
	{
	    wprintf(myLoadResourceString(IDS_ERR_PRIVATEKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match private key"
	    wprintf(wszNewLine);
	    hr = S_OK;
	}
	else if (NULL != pfMatchingKey)
	{
	    *pfMatchingKey = TRUE;
	}
	if (!g_fQuiet && NULL != PrivateKey.pbData)
	{
	    wprintf(wszNewLine);
	    hr = cuDumpPrivateKeyBlob(
				PrivateKey.pbData,
				PrivateKey.cbData,
				FALSE);
	    _JumpIfError(hr, error, "cuDumpPrivateKeyBlob");
	}
    }

error:
    if (NULL != PrivateKey.pbData)
    {
	LocalFree(PrivateKey.pbData);
    }
    if (NULL != pPublicKeyInfo)
    {
	LocalFree(pPublicKeyInfo);
    }
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
cuDumpCertKeyProviderInfo(
    IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCert,
    OPTIONAL IN CRYPT_KEY_PROV_INFO *pkpi,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpiT = NULL;
    DWORD i;

    if (NULL != ppkpi)
    {
	*ppkpi = NULL;
    }
    CSASSERT((NULL == pCert) ^ (NULL == pkpi));

    if (NULL != pCert)
    {
	CSASSERT(NULL == pkpi);
	hr = myCertGetKeyProviderInfo(pCert, &pkpiT);
	if (S_OK != hr)
	{
	    _PrintIfError2(hr, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);
	    if (CRYPT_E_NOT_FOUND != hr)
	    {
		_JumpError(hr, error, "myCertGetKeyProviderInfo");
	    }

	    // Ignore missing property if we're just dumping the key provider info

	    wprintf(myLoadResourceString(IDS_NO_KEY_PROVIDER_INFO)); // "No key provider information"
	    wprintf(wszNewLine);
	    CSASSERT(NULL == pkpiT);
	    hr = S_OK;
	    goto error;
	}
	pkpi = pkpiT;
    }
    else
    {
	CSASSERT(NULL != pkpi);
    }
    wprintf(pwszPrefix);
    wprintf(
	myLoadResourceString(IDS_FORMAT_KEY_CONTAINER),
	pkpi->pwszContainerName);
    wprintf(wszNewLine);

    wprintf(pwszPrefix);
    wprintf(
	myLoadResourceString(IDS_FORMAT_PROVIDER_NAME),
	pkpi->pwszProvName);
    wprintf(wszNewLine);

    if (!g_fQuiet)
    {
	wprintf(pwszPrefix);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_PROVIDER_TYPE),
	    pkpi->dwProvType);
	wprintf(wszNewLine);
    }

    if (!g_fQuiet)
    {
	wprintf(pwszPrefix);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_FLAGS),
	    pkpi->dwFlags);
	wprintf(wszNewLine);

	if (NULL != pkpi->rgProvParam)
	{
	    for (i = 0; i < pkpi->cProvParam; i++)
	    {
		wprintf(pwszPrefix);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_PROVPARM),
		    pkpi->rgProvParam[i].dwParam);
		wprintf(wszNewLine);

		DumpHex(
		    DH_MULTIADDRESS | DH_NOTABPREFIX | 4,
		    pkpi->rgProvParam[i].pbData,
		    pkpi->rgProvParam[i].cbData);

		wprintf(pwszPrefix);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_PROVPARMFLAGS),
		    pkpi->rgProvParam[i].dwFlags);
		wprintf(wszNewLine);
	    }
	}
	wprintf(pwszPrefix);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_KEYSPEC),
	    pkpi->dwKeySpec);
	wprintf(wszNewLine);
    }
    if (NULL != pkpiT && NULL != ppkpi)
    {
	*ppkpi = pkpiT;
	pkpiT = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pkpiT)
    {
	LocalFree(pkpiT);
    }
    return(hr);
}


VOID
DumpAlgorithm(
    IN DWORD idMessage,
    IN CRYPT_ALGORITHM_IDENTIFIER const *pAlg)
{
    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    wprintf(g_wszPad4);
    wprintf(myLoadResourceString(IDS_ALG_OID)); // "Algorithm ObjectId"
    wprintf(L": ");
    cuDumpOIDAndDescriptionA(pAlg->pszObjId);
    wprintf(wszNewLine);

    wprintf(g_wszPad4);
    wprintf(myLoadResourceString(IDS_ALG_PARAMETERS_COLON)); // "Algorithm Parameters:"
    if (NULL != pAlg->Parameters.pbData)
    {
	wprintf(wszNewLine);
	DumpHex(
	    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	    pAlg->Parameters.pbData,
	    pAlg->Parameters.cbData);
    }
    else
    {
	wprintf(L" %ws\n", myLoadResourceString(IDS_NULL)); // "NULL"
    }
}


VOID
cuDumpPublicKey(
    IN CERT_PUBLIC_KEY_INFO const *pKey)
{
    DumpAlgorithm(IDS_PUBLICKEY_ALGORITHM, &pKey->Algorithm);

    wprintf(
	myLoadResourceString(IDS_FORMAT_PUBLICKEY_LENGTH), // "Public Key Length: %u bits"
	CertGetPublicKeyLength(
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pKey)));
    wprintf(wszNewLine);

    wprintf(
	myLoadResourceString(IDS_FORMAT_PUBLICKEY_UNUSEDBITS), // "Public Key: UnusedBits=%u"
	pKey->PublicKey.cUnusedBits);

    wprintf(wszNewLine);
    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	pKey->PublicKey.pbData,
	pKey->PublicKey.cbData);
}


VOID
DumpSignature(
    OPTIONAL IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    if (NULL == pcsci)
    {
	wprintf(myLoadResourceString(IDS_NO_SIGNATURE));
	wprintf(wszNewLine);
	goto error;
    }
    if (1 < g_fVerbose)
    {
	DumpHex(
	    DH_NOTABPREFIX | 4,
	    pcsci->ToBeSigned.pbData,
	    pcsci->ToBeSigned.cbData);
    }
    DumpAlgorithm(IDS_SIGNATURE_ALGORITHM, &pcsci->SignatureAlgorithm);

    wprintf(
	myLoadResourceString(IDS_FORMAT_SIGNATURE_UNUSEDBITS), // "Signature: UnusedBits=%u"
	pcsci->Signature.cUnusedBits);
    wprintf(wszNewLine);

    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	pcsci->Signature.pbData,
	pcsci->Signature.cbData);

error:
    ;
}


HRESULT
SaveAsnToFile(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN int imajor,
    IN int ilevel,
    IN DWORD iElement,
    IN WCHAR const *pwszExtension)
{
    HRESULT hr;
    WCHAR awc[MAX_PATH];

    CSASSERT(0 < imajor);
    CSASSERT(0 < ilevel);

    wsprintf(
	awc,
	MAXDWORD == iElement? L"Blob%d_%d" : L"Blob%d_%d_%d",
	imajor - 1,
	ilevel - 1,
	iElement);
    wcscat(awc, pwszExtension);

    if (g_fSplitASN)
    {
	wprintf(L"SaveAsnToFile: %d %d %d: %ws\n", imajor - 1, ilevel - 1, iElement, awc);
	hr = EncodeToFileW(awc, pbIn, cbIn, CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpAsnBlob(
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN BOOL fQuiet,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD iElement)
{
    HRESULT hr;
    HRESULT hr2;
    ASNFORMATS *pasn;
    ASNFORMATS *pasnEnd;
    DWORD cbDecoded;
    BYTE *pbDecoded = NULL;
    HCERTSTORE hStorePFX = NULL;
    CERT_CONTEXT const *pCert = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    CERT_SIGNED_CONTENT_INFO *pcsci = NULL;
    DWORD cbcsci;
    static int s_major = 0;
    static int s_level = 0;
    BOOL fSaved = FALSE;

    if (0 == s_level)
    {
	s_major++;
    }
    s_level++;
    if (1 < s_level)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_DUMP_LEVEL_START), s_level - 1);
	wprintf(wszNewLine);
    }
    if (MAXDWORD != iElement)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_ELEMENT), iElement);
	wprintf(wszNewLine);
    }

    if (1 < g_fVerbose)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_ELEMENT_DUMP)); // "Embedded ASN.1 Element:"
	wprintf(wszNewLine);
	DumpHex(0, pbIn, cbIn);
    }

    pasnEnd = &g_aasn[CASNFORMATS];
    for (pasn = g_aasn; pasn < pasnEnd; pasn++)
    {
	CSASSERT(NULL == pbDecoded);
	if (myDecodeObject(
			X509_ASN_ENCODING,
			pasn->pszFormat,
			pbIn,
			cbIn,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cbDecoded))
	{
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_CERT,
			    pbIn,
			    cbIn,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pcsci,
			    &cbcsci))
	    {
		hr = myHLastError();
		_PrintError3(
			hr,
			"myDecodeObject",
			CRYPT_E_ASN1_BADTAG,
			CRYPT_E_ASN1_EOD);
	    }

	    hr = (*pasn->pfnDump)(
			    pasn->idMessage,
			    pbIn,
			    cbIn,
			    pbDecoded,
			    cbDecoded,
			    pcsci);
	    if (S_OK != hr && dumpCertSequence == pasn->pfnDump)
	    {
		LocalFree(pbDecoded);
		pbDecoded = NULL;
		CSASSERT(NULL == pcsci);
		continue;
	    }
	    hr2 = SaveAsnToFile(
			    pbIn,
			    cbIn,
			    s_major,
			    s_level,
			    iElement,
			    pasn->pwszExtension);
	    _PrintIfError(hr2, "SaveAsnToFile");
	    fSaved = TRUE;
	    _JumpIfError(hr, error, "(*pfnDump)");

	    break;
	}
	hr = myHLastError();
	_PrintError2(hr, "myDecodeObject", hr);
	CSASSERT(S_OK != hr);
    }
    if (pasn >= pasnEnd)
    {
	CRYPT_DATA_BLOB pfx;

	CSASSERT(S_OK != hr);

	pfx.pbData = const_cast<BYTE *>(pbIn);
	pfx.cbData = cbIn;

	if (PFXIsPFXBlob(&pfx))
	{
	    DWORD dwKeySpec;
	    DWORD dwFlags;
	    WCHAR wszPassword[MAX_PATH];
	    WCHAR *pwszPassword;
	    DWORD iCert;

	    pwszPassword = g_pwszPassword;
	    if (NULL == pwszPassword)
	    {
		hr = cuGetPassword(FALSE, wszPassword, ARRAYSIZE(wszPassword));
		_JumpIfError(hr, error, "cuGetPassword");

		pwszPassword = wszPassword;
	    }

	    hStorePFX = myPFXImportCertStore(
					&pfx,
					pwszPassword,
					CRYPT_EXPORTABLE);
	    if (NULL == hStorePFX)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myPFXImportCertStore");
	    }
	    hr = SaveAsnToFile(pbIn, cbIn, s_major, s_level, iElement, L".p12");
	    _PrintIfError(hr, "SaveAsnToFile");
	    fSaved = TRUE;

	    for (iCert = 0; ; iCert++)
	    {
		BOOL fSigningKey;
		BOOL fMatchingKey;
		BOOL fRepaired = FALSE;

		pCert = CertEnumCertificatesInStore(hStorePFX, pCert);
		if (NULL == pCert)
		{
		    break;
		}
		hr = cuDumpAsnBinary(
				pCert->pbCertEncoded,
				pCert->cbCertEncoded,
				iCert);
		_JumpIfError(hr, error, "cuDumpAsnBinary");

		while (TRUE)
		{
		    if (NULL != pkpi)
		    {
			LocalFree(pkpi);
			pkpi = NULL;
		    }
		    hr = cuDumpCertKeyProviderInfo(
					    g_wszPad2,
					    pCert,
					    NULL,
					    &pkpi);
		    if (S_OK != hr)
		    {
			if (CRYPT_E_NOT_FOUND != hr)
			{
			    _JumpError(hr, error, "cuDumpCertKeyProviderInfo");
			}
		    }
		    else
		    if (NULL != pkpi)
		    {
			// NT4 PFXImportCertStore doesn't set machine keyset

			hr = cuDumpPrivateKey(
					pCert,
					&fSigningKey,
					&fMatchingKey);
			_PrintIfError2(
				    hr,
				    "cuDumpPrivateKey",
				    CRYPT_E_NO_KEY_PROPERTY);
			if (S_OK == hr &&
			    !fMatchingKey &&
			    !fRepaired &&
			    0 == (CRYPT_MACHINE_KEYSET & pkpi->dwFlags))
			{
			    LocalFree(pkpi);
			    pkpi = NULL;
			    hr = myRepairCertKeyProviderInfo(pCert, TRUE, NULL);
			    _JumpIfError(hr, error, "myRepairCertKeyProviderInfo");
			    fRepaired = TRUE;
			    continue;
			}
		    }
		    break;
		}
	    }
	    hr = S_OK;
	}
	else
	{
	    hr = dumpPKCS7(hStoreWrapper, pbIn, cbIn);
	    if (S_OK == hr)
	    {
		hr = SaveAsnToFile(
			    pbIn,
			    cbIn,
			    s_major,
			    s_level,
			    iElement,
			    L".p7b");
		_PrintIfError(hr, "SaveAsnToFile");
		fSaved = TRUE;
	    }
	    else
	    {
		hr = cuDumpPrivateKeyBlob(pbIn, cbIn, fQuiet);
		if (S_OK == hr)
		{
		    hr = SaveAsnToFile(
				pbIn,
				cbIn,
				s_major,
				s_level,
				iElement,
				L".key");
		    _PrintIfError(hr, "SaveAsnToFile");
		    fSaved = TRUE;
		}
		else
		{
		    _PrintError2(hr, "dumpPKCS7", CRYPT_E_ASN1_BADTAG);
		    if (!fQuiet)
		    {
			DumpHex(DH_MULTIADDRESS | DH_NOTABPREFIX | 4, pbIn, cbIn);
		    }
		}
		hr = S_OK;
	    }
	}
    }

error:
    if (!fSaved)
    {
	hr2 = SaveAsnToFile(pbIn, cbIn, s_major, s_level, iElement, L".bin");
	_PrintIfError(hr2, "SaveAsnToFile");
    }
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, FALSE);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pcsci)
    {
	LocalFree(pcsci);
    }
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    if (1 < s_level)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_DUMP_LEVEL_END), s_level - 1);
	wprintf(wszNewLine);
    }
    s_level--;
    return(hr);
}


HRESULT
cuDumpAsnBinary(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD iElement)
{
    return(DumpAsnBlob(NULL, FALSE, pbIn, cbIn, iElement));
}


HRESULT
cuDumpExtensionArray(
    IN DWORD idMessage,
    IN DWORD cExtension,
    IN CERT_EXTENSION const *rgExtension)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszName = NULL;
    WCHAR const *pwszExtensionFormat;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(L" %u\n", cExtension);
    }

    pwszExtensionFormat = myLoadResourceString(IDS_FORMAT_EXTENSION); // "%ws: Flags = %x%ws, Length = %x"

    for (i = 0; i < cExtension; i++)
    {
	CERT_EXTENSION const *pce;

	if (NULL != pwszName)
	{
	    LocalFree(pwszName);
	    pwszName = NULL;
	}
	pce = &rgExtension[i];
	if (g_fQuiet &&
	    0 != strcmp(pce->pszObjId, szOID_CERTSRV_CA_VERSION) &&
	    0 != strcmp(pce->pszObjId, szOID_ENROLL_CERTTYPE_EXTENSION) &&
	    0 != strcmp(pce->pszObjId, szOID_CRL_NUMBER) &&
	    0 != strcmp(pce->pszObjId, szOID_CRL_VIRTUAL_BASE) &&
	    0 != strcmp(pce->pszObjId, szOID_DELTA_CRL_INDICATOR))
	{
	    continue;
	}
	if (!ConvertSzToWsz(&pwszName, pce->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}

	if (!g_fQuiet)
	{
	    wprintf(g_wszPad4);
	    wprintf(
		pwszExtensionFormat,
		pwszName,
		pce->fCritical,
		cuwszFromExtFlags(pce->fCritical),
		pce->Value.cbData);
	    wprintf(wszNewLine);
	}
	if (!cuDumpFormattedExtension(
			    pwszName,
			    pce->Value.pbData,
			    pce->Value.cbData) ||
	    g_fVerbose)
	{
	    wprintf(wszNewLine);
	    DumpHex(DH_NOTABPREFIX | 4, pce->Value.pbData, pce->Value.cbData);
	}
	if (!g_fQuiet)
	{
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    return(hr);
}


VOID
cuDumpVersion(
    IN DWORD dwVersion)
{
    wprintf(
	myLoadResourceString(IDS_FORMAT_VERSION), // "Version: %u"
	dwVersion);
    wprintf(wszNewLine);
}


HRESULT
cuDumpCMSSignerInfo(
    IN CMSG_CMS_SIGNER_INFO const *pcsi,
    IN DWORD iElement,
    IN BOOL fQuiet,
    DWORD idVerify,
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert)
{
    HRESULT hr;
    WCHAR const *pwszFmt = MAXDWORD == iElement? L"%ws:\n" : L"%ws[%u]:\n";

    if (!fQuiet || g_fVerbose)
    {
	if (!fQuiet)
	{
	    wprintf(wszNewLine);
	}
	wprintf(
	    pwszFmt,
	    myLoadResourceString(IDS_SIGNER_INFO), // "Signer Info"
	    iElement);
	if (!fQuiet)
	{
	    WCHAR const *pwszVersion = NULL;
	    
	    if (0 != idVerify)
	    {
		wprintf(myLoadResourceString(idVerify));
		wprintf(wszNewLine);
	    }
	    switch (pcsi->dwVersion)
	    {
		case CMSG_SIGNER_INFO_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_SIGNER_INFO_PKCS_1_5_VERSION";
		    break;

		case CMSG_SIGNER_INFO_CMS_VERSION:
		    pwszVersion = L"CMSG_SIGNER_INFO_CMS_VERSION";
		    break;
	    }
	    if (NULL == pwszVersion)
	    {
		cuDumpVersion(pcsi->dwVersion);
	    }
	    else
	    {
		wprintf(L"%ws(%u)\n", pwszVersion, pcsi->dwVersion);
	    }
	}
	switch (pcsi->SignerId.dwIdChoice)
	{
	    case CERT_ID_ISSUER_SERIAL_NUMBER:
		wprintf(
		    L"%ws(%u)\n",
		    L"CERT_ID_ISSUER_SERIAL_NUMBER",
		    pcsi->SignerId.dwIdChoice);
		hr = cuDumpIssuerSerialAndSubject(
			    &pcsi->SignerId.IssuerSerialNumber.Issuer,
			    &pcsi->SignerId.IssuerSerialNumber.SerialNumber,
			    NULL,	// pSubject
			    hStore);
		_JumpIfError(hr, error, "cuDumpIssuerSerialAndSubject(Signer)");

		break;

	    case CERT_ID_KEY_IDENTIFIER:
		wprintf(
		    L"%ws(%u)\n",
		    L"CERT_ID_KEY_IDENTIFIER",
		    pcsi->SignerId.dwIdChoice);
		DumpHex(
		    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
		    pcsi->SignerId.KeyId.pbData,
		    pcsi->SignerId.KeyId.cbData);
		break;

	    case CERT_ID_SHA1_HASH:
		wprintf(
		    L"%ws(%u)\n",
		    L"CERT_ID_SHA1_HASH",
		    pcsi->SignerId.dwIdChoice);
		DumpHex(
		    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
		    pcsi->SignerId.HashId.pbData,
		    pcsi->SignerId.HashId.cbData);
		break;

	    default:
		wprintf(
		    L"%ws(%u)\n",
		    myLoadResourceString(IDS_QUESTIONMARKS), // "???"
		    pcsi->SignerId.dwIdChoice);
		break;
	}
    }

    if (!fQuiet)
    {
	DumpAlgorithm(IDS_HASH_ALGORITHM, &pcsi->HashAlgorithm);
	DumpAlgorithm(IDS_HASH_ENCRYPTION_ALGORITHM, &pcsi->HashEncryptionAlgorithm);
	wprintf(myLoadResourceString(IDS_FORMAT_ENCRYPTEDHASH_COLON)); // "Encrypted Hash:"
	wprintf(wszNewLine);

	DumpHex(
	    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	    pcsi->EncryptedHash.pbData,
	    pcsi->EncryptedHash.cbData);

	wprintf(wszNewLine);
	wprintf(
	    pwszFmt,
	    myLoadResourceString(IDS_DUMP_PKCS7_ATTRIBUTES),
	    iElement);
    }

    if (!fQuiet || NULL != pbHashUserCert)
    {
	hr = DumpAttributes(
			pcsi->AuthAttrs.rgAttr,
			pcsi->AuthAttrs.cAttr,
			fQuiet,
			FOT_ATTRIBUTE,
			hStore,
			pbHashUserCert,
			pcbHashUserCert,
			NULL);
	_JumpIfError(hr, error, "DumpAttributes");
    }

    if (!fQuiet)
    {
	wprintf(wszNewLine);
	wprintf(
	    pwszFmt,
	    myLoadResourceString(IDS_DUMP_PKCS7_UNAUTHATTRIBUTES),
	    iElement);

	hr = DumpAttributes(
			pcsi->UnauthAttrs.rgAttr,
			pcsi->UnauthAttrs.cAttr,
			fQuiet,
			FOT_ATTRIBUTE,
			hStore,
			NULL,
			NULL,
			NULL);
	_JumpIfError(hr, error, "DumpAttributes");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuDumpSignerInfo(
    IN CMSG_SIGNER_INFO const *psi,
    IN DWORD iElement,
    IN BOOL fQuiet,
    DWORD idVerify,
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert)
{
    HRESULT hr;
    CMSG_CMS_SIGNER_INFO csi;

    ZeroMemory(&csi, sizeof(csi));

    csi.dwVersion = psi->dwVersion;
    csi.SignerId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    csi.SignerId.IssuerSerialNumber.Issuer = psi->Issuer;
    csi.SignerId.IssuerSerialNumber.SerialNumber = psi->SerialNumber;
    csi.HashAlgorithm = psi->HashAlgorithm;
    csi.HashEncryptionAlgorithm = psi->HashEncryptionAlgorithm;
    csi.EncryptedHash = psi->EncryptedHash;
    csi.AuthAttrs = psi->AuthAttrs;
    csi.UnauthAttrs = psi->UnauthAttrs;

    hr = cuDumpCMSSignerInfo(
		    &csi,
		    iElement,
		    fQuiet,
		    idVerify,
		    hStore,
		    pbHashUserCert,
		    pcbHashUserCert);
    _JumpIfError(hr, error, "cuDumpCMSSignerInfo");

error:
    return(hr);
}




HRESULT
DumpAttributes(
    IN CRYPT_ATTRIBUTE const *rgAttr,
    IN DWORD cAttr,
    IN BOOL fQuiet,
    IN DWORD Type,		// FOT_*
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert,
    OPTIONAL IN OUT CERT_EXTENSIONS **ppExtInfo)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE const *pAttr;
    CRYPT_ATTRIBUTE const *pAttrEnd;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pNamePair = NULL;
    CERT_EXTENSIONS *pExtInfo = NULL;
    CERT_NAME_VALUE *pNameInfo = NULL;
    DWORD cb;
    DWORD iv;

    if (NULL != ppExtInfo)
    {
	*ppExtInfo = NULL;
    }
    if (!fQuiet && FOT_PROPERTY != Type)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_PKCS7_ATTRIBUTE_COUNT),	// "  %d attributes:"
	    cAttr);
	wprintf(wszNewLine);
    }

    pAttrEnd = &rgAttr[cAttr];
    for (pAttr = rgAttr; pAttr < pAttrEnd; pAttr++)
    {
	WCHAR const *pwszOID = cuGetOIDNameA(pAttr->pszObjId);

	if (!fQuiet && FOT_PROPERTY != Type)
	{
	    wprintf(wszNewLine);
	    wprintf(
		L"  %ws[%u]: %hs%ws%ws%ws\n",
		myLoadResourceString(IDS_ATTRIBUTE),	// "Attribute"
		pAttr - rgAttr,
		pAttr->pszObjId,
		L'\0' != *pwszOID? L" " wszLPAREN : g_wszEmpty,
		pwszOID,
		L'\0' != *pwszOID? wszRPAREN : g_wszEmpty);
	}

	for (iv = 0; iv < pAttr->cValue; iv++)
	{
	    CRYPT_ATTR_BLOB const *pval = &pAttr->rgValue[iv];

	    if (fQuiet)
	    {
		if (0 == strcmp(pAttr->pszObjId, szOID_ARCHIVED_KEY_CERT_HASH))
		{
		    hr = DumpOctetHash(
				g_wszEmpty,
				g_wszEmpty,
				pval->pbData,
				pval->cbData,
				pbHashUserCert,
				pcbHashUserCert);
		    _JumpIfError(hr, error, "DumpOctetHash");
		}
	    }
	    else
	    {
		if (FOT_PROPERTY != Type)
		{
		    wprintf(
			myLoadResourceString(IDS_FORMAT_PKCS7_ATTRIBUTE_VALUE),	// "    Value[%d][%d]:"
			pAttr - rgAttr,
			iv);
		    wprintf(wszNewLine);
		}

		if (!DumpFormattedObject(
				    pAttr->pszObjId,
				    Type,		// FOT_*
				    pval->pbData,
				    pval->cbData))
		{
		    BOOL fDumpHex = FALSE;

		    if (0 == strcmp(pAttr->pszObjId, szOID_ENROLLMENT_NAME_VALUE_PAIR))
		    {
			if (g_fVerbose)
			{
			    DumpHex(0, pval->pbData, pval->cbData);
			}
			if (NULL != pNamePair)
			{
			    LocalFree(pNamePair);
			    pNamePair = NULL;
			}
			if (!myDecodeNameValuePair(
						X509_ASN_ENCODING,
						pval->pbData,
						pval->cbData,
						CERTLIB_USE_LOCALALLOC,
						&pNamePair,
						&cb))
			{
			    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			    _JumpError(hr, error, "myDecodeNameValuePair");

			    // if attribute name & value are both non-empty ...
			}
			wprintf(
			    L"      %ws%ws = %ws\n",
			    pNamePair->pwszName,
			    g_wszCertUtil,
			    pNamePair->pwszValue);
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_CERT_EXTENSIONS) ||
			0 == strcmp(pAttr->pszObjId, szOID_RSA_certExtensions))
		    {
			if (NULL != pNameInfo)
			{
			    LocalFree(pNameInfo);
			    pNameInfo = NULL;
			}
			while (TRUE)
			{
			    if (NULL != pExtInfo)
			    {
				LocalFree(pExtInfo);
				pExtInfo = NULL;
			    }
			    if (myDecodeObject(
					    X509_ASN_ENCODING,
					    X509_EXTENSIONS,
					    pval->pbData,
					    pval->cbData,
					    CERTLIB_USE_LOCALALLOC,
					    (VOID **) &pExtInfo,
					    &cb))
			    {
				break;	// success
			    }
			    hr = myHLastError();

			    // if we already decoded the attribute as a T61
			    // string, or if it's not a PKCS 9.14 attribute,
			    // just hex dump the attribute -- we don't know
			    // what it contains.

			    if (NULL != pNameInfo ||
				0 != strcmp(
					pAttr->pszObjId,
					szOID_RSA_certExtensions))
			    {
				//_JumpError(hr, error, "myDecodeObject");
				_PrintError(hr, "myDecodeObject");
				fDumpHex = TRUE;
				break;
			    }

			    // decode the attribute as a T61 string.  Some
			    // implementations wrap the PKCS 9.14 extension
			    // array in an extra level of encoding as a Teletex
			    // string.

			    if (!myDecodeObject(
					    X509_ASN_ENCODING,
					    X509_ANY_STRING,
					    pval->pbData,
					    pval->cbData,
					    CERTLIB_USE_LOCALALLOC,
					    (VOID **) &pNameInfo,
					    &cb))
			    {
				hr = myHLastError();
				//_JumpError(hr, error, "myDecodeObject");
				_PrintError(hr, "myDecodeObject");
				fDumpHex = TRUE;
				break;
			    }

			    // Now loop again and try to decode the raw name
			    // blob as X509_EXTENSIONS.

			    pval = &pNameInfo->Value;
			    wprintf(myLoadResourceString(IDS_TELETEX_EXTENSIONS)); // "Decoded extra Extension Array encoding layer (Teletex string)"
			    wprintf(wszNewLine);
			}
			if (!fDumpHex)
			{
			    hr = cuDumpExtensionArray(
						IDS_CERTIFICATE_EXTENSIONS,
						pExtInfo->cExtension,
						pExtInfo->rgExtension);
			    _JumpIfError(hr, error, "cuDumpExtensionArray");
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RENEWAL_CERTIFICATE) ||
			0 == strcmp(pAttr->pszObjId, szOID_RSA_SMIMECapabilities))
		    {
			wprintf(myLoadResourceString(
				0 == strcmp(
					pAttr->pszObjId,
					szOID_RENEWAL_CERTIFICATE)?
				IDS_RENEWAL_CERT :	      // "Renewal Certificate:"
				IDS_SMIME_CAPABILITIES)); // "SMIME Capabilities:"
			wprintf(wszNewLine);

			hr = cuDumpAsnBinary(pval->pbData, pval->cbData, MAXDWORD);
			_JumpIfError(hr, error, "cuDumpAsnBinary");
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_contentType))
		    {
			char *pszObjId;

			hr = cuDecodeObjId(pval->pbData, pval->cbData, &pszObjId);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
			else
			{
			    wprintf(g_wszPad4);
			    cuDumpOIDAndDescriptionA(pszObjId);
			    wprintf(wszNewLine);
			    LocalFree(pszObjId);
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_messageDigest))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    L"Message Digest" wszCERTUTIL, // UNDONE: localize
				    pval->pbData,
				    pval->cbData,
				    NULL,
				    NULL);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ARCHIVED_KEY_ATTR))
		    {
			hr = cuDumpAsnBinary(pval->pbData, pval->cbData, MAXDWORD);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ARCHIVED_KEY_CERT_HASH))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    // UNDONE: Localize or use new crypt32.dll
				    L"Archived Key Cert Hash" wszCERTUTIL, // myLoadResourceString(IDS_CAVERSION),
				    pval->pbData,
				    pval->cbData,
				    pbHashUserCert,
				    pcbHashUserCert);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ISSUED_CERT_HASH))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    // UNDONE: Localize or use new crypt32.dll
				    L"Issued Cert Hash" wszCERTUTIL, // myLoadResourceString(IDS_CAVERSION),
				    pval->pbData,
				    pval->cbData,
				    pbHashUserCert,
				    pcbHashUserCert);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ENCRYPTED_KEY_HASH))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    // UNDONE: Localize or use new crypt32.dll
				    L"Encrypted Key Hash" wszCERTUTIL, // myLoadResourceString(IDS_CAVERSION),
				    pval->pbData,
				    pval->cbData,
				    NULL,
				    NULL);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ENROLLMENT_CSP_PROVIDER))
		    {
			CRYPT_CSP_PROVIDER *pccp;

			hr = myDecodeCSPProviderAttribute(
					    pval->pbData,
					    pval->cbData,
					    &pccp);
			if (S_OK == hr)
			{
			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_CSP_PROVIDER_INFO));
			    wprintf(wszNewLine);

			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_FORMAT_KEYSPEC),
				pccp->dwKeySpec);
			    wprintf(wszNewLine);

			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_FORMAT_PROVIDER_NAME),
				NULL == pccp->pwszProviderName?
				    myLoadResourceString(IDS_PROP_EMPTY) :
				    pccp->pwszProviderName);
			    wprintf(wszNewLine);

			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_FORMAT_SIGNATURE_UNUSEDBITS), // "Signature: UnusedBits=%u"
				pccp->Signature.cUnusedBits);
			    wprintf(wszNewLine);

			    DumpHex(
				DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
				pccp->Signature.pbData,
				pccp->Signature.cbData);

			    LocalFree(pccp);
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_signingTime))
		    {
			FILETIME ft;

			cb = sizeof(ft);
			if (CryptDecodeObject(
					    X509_ASN_ENCODING,
					    X509_CHOICE_OF_TIME,
					    pval->pbData,
					    pval->cbData,
					    0,
					    &ft,
					    &cb))
			{
			    wprintf(
				L"%ws%ws%ws: ",
				g_wszPad4,
				// UNDONE: Localize or use new crypt32.dll
				L"Signing Time", // myLoadResourceString(IDS_CAVERSION),
				g_wszCertUtil);

			    hr = cuDumpFileTime(0, NULL, &ft);
			    _JumpIfError(hr, error, "cuDumpFileTime");
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_REQUEST_CLIENT_INFO))
		    {
			CRYPT_REQUEST_CLIENT_INFO *pcrci = NULL;

			hr = myDecodeRequestClientAttribute(
					    pval->pbData,
					    pval->cbData,
					    &pcrci);
			if (S_OK == hr)
			{
			    wprintf(g_wszPad2);
			    cuRegPrintDwordValue(
					    TRUE,
					    wszREQUESTCLIENTID,
					    myLoadResourceString(IDS_CLIENTID),
					    pcrci->dwClientId);
			    wprintf(
				L"%ws%ws %ws\n",
				g_wszPad4,
				myLoadResourceString(IDS_USERCOLON),
				pcrci->pwszUser);

			    wprintf(
				L"%ws%ws %ws\n",
				g_wszPad4,
				myLoadResourceString(IDS_MACHINECOLON),
				pcrci->pwszMachine);

			    wprintf(
				L"%ws%ws %ws\n",
				g_wszPad4,
				myLoadResourceString(IDS_PROCESSCOLON),
				pcrci->pwszProcess);

			    LocalFree(pcrci);
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_counterSign))
		    {
			CMSG_SIGNER_INFO *psi = NULL;

			if (!myDecodeObject(
					X509_ASN_ENCODING,
					PKCS7_SIGNER_INFO,
					pval->pbData,
					pval->cbData,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &psi,
					&cb))
			{
			    CSASSERT(NULL == psi);
			    hr = myHLastError();
			    _PrintError(hr, "myDecodeObject");
			    fDumpHex = TRUE;
			}
			else
			{
			    wprintf(
				L"%ws%ws%ws: ",
				g_wszPad4,
				// UNDONE: Localize or use new crypt32.dll
				L"Counter Signature", // myLoadResourceString(IDS_CAVERSION),
				g_wszCertUtil);

			    hr = cuDumpSignerInfo(
					    psi,
					    MAXDWORD,	// iElement
					    fQuiet,
					    0,
					    hStore,
					    pbHashUserCert,
					    pcbHashUserCert);
			    _PrintIfError(hr, "cuDumpSignerInfo");
			    if (S_OK != hr)
			    {
				fDumpHex = TRUE;
			    }
			}
			if (NULL != psi)
			{
			    LocalFree(psi);
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_challengePwd))
		    {
			CRYPT_DATA_BLOB Value;
			WCHAR *pwsz;

			Value.pbData = pval->pbData;
			Value.cbData = pval->cbData;
			hr = UnicodeDecode(&Value, &pwsz);
			if (S_OK == hr)
			{
			    wprintf(L"%ws%ws\n", g_wszPad4, pwsz);
			    LocalFree(pwsz);
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    {
			fDumpHex = TRUE;
		    }
		    if (fDumpHex)
		    {
			DumpHex(
			    DH_NOTABPREFIX | 4,
			    pval->pbData,
			    pval->cbData);
		    }
		}
	    }
	}
    }
    if (NULL != ppExtInfo)
    {
	*ppExtInfo = pExtInfo;
	pExtInfo = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pNamePair)
    {
	LocalFree(pNamePair);
    }
    if (NULL != pExtInfo)
    {
	LocalFree(pExtInfo);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HRESULT
FindCertStoreIndex(
    IN HCERTSTORE hStore,
    IN CERT_CONTEXT const *pCertSigner,
    OUT DWORD *piElement)
{
    HRESULT hr;
    DWORD iElement;
    CERT_CONTEXT const *pcc = NULL;

    *piElement = -1;
    for (iElement = 0; ; iElement++)
    {
	pcc = CertEnumCertificatesInStore(hStore, pcc);
	if (NULL == pcc)
	{
	    hr = CRYPT_E_NOT_FOUND;
	    _JumpError(hr, error, "CertEnumCertificatesInStore");
	}
	if (pCertSigner->cbCertEncoded == pcc->cbCertEncoded &&
	    0 == memcmp(
		    pCertSigner->pbCertEncoded,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded))
	{
	    break;
	}
    }
    *piElement = iElement;
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
cuDumpIssuerSerialAndSubject(
    IN CERT_NAME_BLOB const *pIssuer,
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    OPTIONAL IN CERT_NAME_BLOB const *pSubject,
    OPTIONAL IN HCERTSTORE hStore)
{
    HRESULT hr;
    BOOL fVerbose = g_fVerbose;
    CERT_ID CertId;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fMultiLine = NULL == pSerialNumber || g_fVerbose;

    if (g_fVerbose)
    {
	g_fVerbose--;
    }
    hr = cuDumpSerial(g_wszPad4, IDS_SERIAL, pSerialNumber);
    _JumpIfError(hr, error, "cuDumpSerial");

    hr = cuDisplayCertName(
		    fMultiLine,
		    g_wszPad4,
		    myLoadResourceString(IDS_ISSUER), // "Issuer"
		    g_wszPad8,
		    pIssuer);
    _JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

    CertId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    CertId.IssuerSerialNumber.Issuer = *pIssuer;
    CertId.IssuerSerialNumber.SerialNumber = *pSerialNumber;

    if (NULL == pSubject && NULL != hStore)
    {
	pcc = CertFindCertificateInStore(
				    hStore,
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    0,			// dwFindFlags
				    CERT_FIND_CERT_ID,
				    &CertId,
				    NULL);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CertFindCertificateInStore", hr);
	}
	else
	{
	    pSubject = &pcc->pCertInfo->Subject;
	}
    }
    if (NULL != pSubject)
    {
	hr = cuDisplayCertName(
			fMultiLine,
			g_wszPad4,
			myLoadResourceString(IDS_SUBJECT), // "Subject"
			g_wszPad8,
			pSubject);
	_JumpIfError(hr, error, "cuDisplayCertName(Issuer)");
    }
    hr = S_OK;

error:
    g_fVerbose = fVerbose;
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
cuDumpSigners(
    IN HCRYPTMSG hMsg,
    IN CHAR const *pszInnerContentObjId,
    IN HCERTSTORE hStore,
    IN DWORD cSigner,
    IN BOOL fContentEmpty,
    IN BOOL fQuiet,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert)
{
    HRESULT hr;
    DWORD i;
    CMSG_CMS_SIGNER_INFO *pcsi = NULL;
    DWORD cb;
    CERT_CONTEXT const *pcc = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD iElement;
    DWORD VerifyState;
    BOOL fVerbose = g_fVerbose;
    CERT_REQUEST_INFO *pRequest = NULL;

    if (!fQuiet)
    {
	if (0 == cSigner)
	{
	    wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_SIGNER));
	    wprintf(wszNewLine);
	}
	else
	{
	    wprintf(
		L"%ws: %d\n",
		myLoadResourceString(IDS_DUMP_PKCS7_SIGNER_COUNT),
		cSigner);
	}
    }
    for (i = 0; i < cSigner; i++)
    {
	DWORD idVerify = 0;
	
	if (NULL != pcsi)
	{
	    LocalFree(pcsi);
	    pcsi = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_CMS_SIGNER_INFO_PARAM,
			    i,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pcsi,
			    &cb);
	_JumpIfError(hr, error, "myCryptMsgGetParam");

	if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
	    (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
	     0 == strcmp(
		    szOID_PKIX_NO_SIGNATURE,
		    pcsi->HashEncryptionAlgorithm.pszObjId)))
	{
	    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cvse;

	    ZeroMemory(&cvse, sizeof(cvse));
	    cvse.cbSize = sizeof(cvse);
	    cvse.dwSignerIndex = i;

	    if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice)
	    {
		if (NULL == pRequest)
		{
		    hr = myGetInnerPKCS10(
				    hMsg,
				    pszInnerContentObjId,
				    &pRequest);
		    _JumpIfError(hr, error, "myGetInnerPKCS10");
		}
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
		cvse.pvSigner = &pRequest->SubjectPublicKeyInfo;
	    }
	    else
	    {
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
	    }

	    if (!CryptMsgControl(
			    hMsg,
			    0,		// dwFlags
			    CMSG_CTRL_VERIFY_SIGNATURE_EX,
			    &cvse))
	    {
		hr = myHLastError();
		_PrintError(hr, "CryptMsgControl");
		cuPrintError(0, hr);
	    }
	    idVerify = CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice?
		IDS_REQUEST_SIGNATUREMATCHES :	// "Signature matches request Public Key"
		IDS_NULL_SIGNATUREMATCHES;	// "NULL signature verifies"
	}
	else
	{
	    DWORD dwFlags;

	    dwFlags = CMSG_USE_SIGNER_INDEX_FLAG;
	    while (TRUE)
	    {
		iElement = i;
		if (CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,		// cSignerStore
				    NULL,	// rghSignerStore
				    dwFlags,
				    &pcc,
				    &iElement))
		{
		    hr = S_OK;
		    break;
		}
		hr = myHLastError();
		_PrintError(hr, "CryptMsgGetAndVerifySigner");

		if (CMSG_SIGNER_ONLY_FLAG & dwFlags)
		{
		    cuPrintError(0, hr);
		    break;
		}
		cuPrintError(
			(fContentEmpty && NTE_BAD_SIGNATURE == hr)?
			    IDS_DETACHED_SIGNATURE : // "Cannot verify detached signature"
			    0,
			    hr);
		dwFlags |= CMSG_SIGNER_ONLY_FLAG;
	    }
	    if (S_OK == hr)
	    {
		idVerify = IDS_SIGNATUREMATCHES; // "Signature matches Public Key"
		hr = FindCertStoreIndex(hStore, pcc, &iElement);
		_JumpIfError(hr, error, "FindCertStoreIndex");

		if (!fQuiet)
		{
		    wprintf(
			L"%ws: %u\n",
			myLoadResourceString(IDS_DUMP_PKCS7_SIGNCERT), // "Signing Certificate Index"
			iElement);
		}
		hr = cuVerifyCertContext(pcc, NULL, NULL, 0, &VerifyState);
		_PrintIfError(hr, "cuVerifyCertContext");

		CertFreeCertificateContext(pcc);
		pcc = NULL;
	    }
	}

	hr = cuDumpCMSSignerInfo(
			pcsi,
			i,
			fQuiet,
			idVerify,
			hStore,
			pbHashUserCert,
			pcbHashUserCert);
	_PrintIfError(hr, "cuDumpCMSSignerInfo");

	cb = sizeof(abHash);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_COMPUTED_HASH_PARAM,
			0,
			abHash,
			&cb))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptMsgGetParam(computed hash)");
	}
	else
	{
	    wprintf(wszNewLine);
	    hr = DumpHash(
		    NULL,
		    IDS_FORMAT_COMPUTED_HASH_COLON,	// "Computed Hash%ws: %ws"
		    g_wszEmpty,
		    abHash,
		    cb);
	    _JumpIfError(hr, error, "DumpHash");
	}
    }
    hr = S_OK;

error:
    if (NULL != pRequest)
    {
	LocalFree(pRequest);
    }
    if (NULL != pcsi)
    {
	LocalFree(pcsi);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
cuDumpRecipients(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStoreWrapper,
    IN DWORD cRecipient,
    IN BOOL fQuiet)
{
    HRESULT hr;
    DWORD i;
    CERT_INFO *pci = NULL;
    DWORD cb;

    if (!fQuiet)
    {
	if (0 == cRecipient)
	{
	    wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_RECIPIENT));
	    wprintf(wszNewLine);
	}
	else
	{
	    wprintf(
		L"%ws: %d\n",
		myLoadResourceString(IDS_DUMP_PKCS7_RECIPIENT_COUNT),
		cRecipient);
	}
    }
    for (i = 0; i < cRecipient; i++)
    {
	if (NULL != pci)
	{
	    LocalFree(pci);
	    pci = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_RECIPIENT_INFO_PARAM,
			    i,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pci,
			    &cb);
	_JumpIfError(hr, error, "myCryptMsgGetParam");

	wprintf(wszNewLine);
	wprintf(
	    L"%ws[%u]:\n",
	    myLoadResourceString(IDS_RECIPIENT_INFO), // "Recipient Info"
	    i);

	hr = cuDumpIssuerSerialAndSubject(
			    &pci->Issuer,
			    &pci->SerialNumber,
			    NULL,	// pSubject
			    hStoreWrapper);
	_JumpIfError(hr, error, "cuDumpIssuerSerialAndSubject(Recipient)");
    }
    hr = S_OK;

error:
    if (NULL != pci)
    {
	LocalFree(pci);
    }
    return(hr);
}


HRESULT
OpenCAXchgMemoryStore(
    OUT HCERTSTORE *phStore)
{
    HRESULT hr;
    WCHAR const *pwszConfig = g_pwszConfig;
    BSTR strConfig = NULL;
    DISPATCHINTERFACE diRequest;
    BSTR strCert = NULL;
    HCERTSTORE hStore = NULL;
    
    if (NULL == pwszConfig)
    {
	hr = ConfigGetConfig(g_DispatchFlags, CC_LOCALACTIVECONFIG, &strConfig);
	_JumpIfError(hr, error, "ConfigGetConfig");

	pwszConfig = strConfig;
    }

    hr = Request_Init(g_DispatchFlags, &diRequest);
    _JumpIfError(hr, error, "Request_Init");

    hr = Request2_GetCAProperty(
			&diRequest,
			pwszConfig,
			CR_PROP_CAXCHGCERT,
			MAXDWORD,		// PropIndex
			PROPTYPE_BINARY,
			CR_OUT_BINARY,
			&strCert);
    _JumpIfError(hr, error, "Request2_GetCAProperty");

    hStore = CertOpenStore(
		    CERT_STORE_PROV_MEMORY,
		    X509_ASN_ENCODING,
		    NULL,
		    0,
		    NULL);
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
		    hStore,
		    X509_ASN_ENCODING,
		    (BYTE *) strCert,
		    SysStringByteLen(strCert),
		    CERT_STORE_ADD_REPLACE_EXISTING,
		    NULL))			// ppCertContext
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    *phStore = hStore;
    hStore = NULL;
    hr = S_OK;

error:
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != strCert)
    {
	SysFreeString(strCert);
    }
    Request_Release(&diRequest);
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);

}


HRESULT
OpenNamedStore(
    IN BOOL fUserStore,
    IN WCHAR const *pwszStoreName,
    OUT HCERTSTORE *phStore)
{
    HRESULT hr;

    *phStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    X509_ASN_ENCODING,
                    NULL,		// hProv
                    CERT_STORE_OPEN_EXISTING_FLAG |
			CERT_STORE_READONLY_FLAG |
			CERT_STORE_ENUM_ARCHIVED_FLAG |
			(fUserStore?
			    CERT_SYSTEM_STORE_CURRENT_USER :
			    CERT_SYSTEM_STORE_LOCAL_MACHINE),
		    pwszStoreName);
    if (NULL == *phStore)
    {
        hr = myHLastError();
        _JumpErrorStr2(
		hr,
		error,
		"CertOpenStore",
		pwszStoreName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuCryptDecryptMessageFromCert(
    IN CERT_CONTEXT const *pcc,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT DWORD *pdwKeySpecFound,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pccStore = NULL;
    CERT_KEY_CONTEXT ckc;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;

    *pdwKeySpecFound = 0;
    hStore = CertOpenStore(
		    CERT_STORE_PROV_MEMORY,
		    X509_ASN_ENCODING,
		    NULL,
		    0,
		    NULL);
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
		    hStore,
		    X509_ASN_ENCODING,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded,
		    CERT_STORE_ADD_REPLACE_EXISTING,
		    &pccStore))			// ppCertContext
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
    _PrintIfError2(hr, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);
    if (S_OK == hr)
    {
	DBGPRINT((
	    DBG_SS_CERTUTILI,
	    "Original KeyProvInfo: container=%ws, type=%x, prov=%ws, KeySpec=%x, f=%x\n",
	    pkpi->pwszContainerName,
	    pkpi->dwProvType,
	    pkpi->pwszProvName,
	    pkpi->dwKeySpec,
	    pkpi->dwFlags));
    }

    if (!CryptAcquireCertificatePrivateKey(
				    pccStore,
				    0,		// dwFlags
				    NULL,	// pvReserved
				    &hProv,
				    &dwKeySpec,
				    NULL))	// pfCallerFreeProv
    {
	hr = myHLastError();
	_PrintError2(
		hr,
		"CryptAcquireCertificatePrivateKey",
		CRYPT_E_NO_KEY_PROPERTY);

	if (!CryptFindCertificateKeyProvInfo(pccStore, 0, NULL))
	{
	    hr = myHLastError();
	    _JumpError2(
		    hr,
		    error,
		    "CryptFindCertificateKeyProvInfo",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	}
	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}

	hr = myCertGetKeyProviderInfo(pccStore, &pkpi);
	_JumpIfError(hr, error, "myCertGetKeyProviderInfo");

	DBGPRINT((
	    DBG_SS_CERTUTILI,
	    "Constructed KeyProvInfo: container=%ws, type=%x, prov=%ws, KeySpec=%x, f=%x\n",
	    pkpi->pwszContainerName,
	    pkpi->dwProvType,
	    pkpi->pwszProvName,
	    pkpi->dwKeySpec,
	    pkpi->dwFlags));
	dwKeySpec = pkpi->dwKeySpec;
	if (!CryptAcquireContext(
			    &hProv,
			    pkpi->pwszContainerName,
			    pkpi->pwszProvName,
			    pkpi->dwProvType,
			    pkpi->dwFlags))
	{
	    hr = myHLastError();
	    _JumpErrorStr(
		    hr,
		    error,
		    "CryptAcquireContext",
		    pkpi->pwszContainerName);
	}
    }
    ZeroMemory(&ckc, sizeof(ckc));
    ckc.cbSize = sizeof(ckc);
    ckc.dwKeySpec = dwKeySpec;
    ckc.hCryptProv = hProv;

    *pdwKeySpecFound = dwKeySpec;

    if (!CertSetCertificateContextProperty(
				    pccStore,
				    CERT_KEY_CONTEXT_PROP_ID,
				    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
				    &ckc))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }

    hr = myCryptDecryptMessage(
			hStore,
			pbIn,
			cbIn,
			CERTLIB_USE_LOCALALLOC,
			ppbDecrypted,
			pcbDecrypted);
    _JumpIfError(hr, error, "myCryptDecryptMessage");

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pccStore)
    {
	CertFreeCertificateContext(pccStore);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


// Attempt to find any one recipient cert with a usable private key in the
// following locations:
//  - the next outer PKCS7 store (hStoreWrapper parameter)
//  - the PKCS7 store (hStorePKCS7 parameter)
//  - the local machine's current CA Exchange cert
//  - the HKLM KRA store
//  - the HKLM MY store
//  - the HKCU MY store

HRESULT
cuDumpEncryptedAsnBinary(
    IN HCRYPTMSG hMsg,
    IN DWORD cRecipient,
    IN DWORD RecipientIndex,
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN HCERTSTORE hStorePKCS7,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BOOL fQuiet,
    OPTIONAL OUT BYTE **ppbDecrypted,
    OPTIONAL OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    HCERTSTORE ahStore[6];
    WCHAR *apwszStore[6];
    DWORD cStore = 0;
    DWORD iRecipient;
    DWORD iStore;
    DWORD cb;
    CERT_INFO *pci = NULL;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fDecrypted = FALSE;
    BYTE *pbDecrypted = NULL;
    DWORD cbDecrypted;
    DWORD dwKeySpecFound;
    BOOL fSignatureKey = FALSE;
    BOOL fExchangeKey = FALSE;

    if (NULL != ppbDecrypted)
    {
	*ppbDecrypted = NULL;
    }
    if (NULL != pcbDecrypted)
    {
	*pcbDecrypted = 0;
    }
    hr = OpenNamedStore(TRUE, wszMY_CERTSTORE, &ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"HKCU MY";
	cStore++;
    }
    hr = OpenNamedStore(FALSE, wszMY_CERTSTORE, &ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"HKLM MY";
	cStore++;
    }
    if (NULL != hStoreWrapper)
    {
	apwszStore[cStore] = L"PKCS7 Wrapper";
	ahStore[cStore++] = hStoreWrapper;
    }
    if (NULL != hStorePKCS7)
    {
	apwszStore[cStore] = L"PKCS7";
	ahStore[cStore++] = hStorePKCS7;
    }
    hr = OpenCAXchgMemoryStore(&ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"CAXchgMemory";
	cStore++;
    }
    hr = OpenNamedStore(FALSE, wszKRA_CERTSTORE, &ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"HKLM KRA";
	cStore++;
    }

    for (iRecipient = 0; !fDecrypted && iRecipient < cRecipient; iRecipient++)
    {
	CERT_ID CertId;

	if (MAXDWORD != RecipientIndex && iRecipient != RecipientIndex)
	{
	    continue;
	}
	if (NULL != pci)
	{
	    LocalFree(pci);
	    pci = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_RECIPIENT_INFO_PARAM,
			    iRecipient,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pci,
			    &cb);
	_JumpIfError(hr, error, "myCryptMsgGetParam");

	CertId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
	CertId.IssuerSerialNumber.Issuer = pci->Issuer;
	CertId.IssuerSerialNumber.SerialNumber = pci->SerialNumber;

	for (iStore = 0; !fDecrypted && iStore < cStore; iStore++)
	{
	    if (NULL != pcc)
	    {
		CertFreeCertificateContext(pcc);
		pcc = NULL;
	    }
	    while (TRUE)
	    {
		pcc = CertFindCertificateInStore(
				    ahStore[iStore],
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    0,			// dwFindFlags
				    CERT_FIND_CERT_ID,
				    &CertId,
				    pcc);
		if (NULL == pcc)
		{
		    hr = myHLastError();
		    _PrintError2(hr, "CertFindCertificateInStore", hr);
		    break;
		}
		DBGPRINT((
		    DBG_SS_CERTUTILI,
		    "Found Recipient[%u] in %ws -- ahStore[%u of %u]:\n",
		    iRecipient,
		    apwszStore[iStore],
		    iStore,
		    cStore));
		if (g_fVerbose)
		{
		    wprintf(wszNewLine);
		    wprintf(
			L"%ws[%u]:\n",
			myLoadResourceString(IDS_RECIPIENT_INFO), // "Recipient Info"
			iRecipient);
		    hr = cuDumpIssuerSerialAndSubject(
					&pci->Issuer,
					&pci->SerialNumber,
					&pcc->pCertInfo->Subject,
					NULL);		// hStore
		    _JumpIfError(hr, error, "cuDumpIssuerSerialAndSubject(Recipient)");
		}

		hr = cuCryptDecryptMessageFromCert(
				pcc,
				pbIn,
				cbIn,
				&dwKeySpecFound,
				&pbDecrypted,
				&cbDecrypted);
		_PrintIfError2(
			hr,
			"cuCryptDecryptMessageFromCert",
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

		if (AT_SIGNATURE == dwKeySpecFound)
		{
		    fSignatureKey = TRUE;
		}
		else if (AT_KEYEXCHANGE == dwKeySpecFound)
		{
		    fExchangeKey = TRUE;
		}
		if (S_OK != hr)
		{
		    continue;
		}
		wprintf(myLoadResourceString(IDS_DUMP_DECRYPTED)); // "Decrypted PKCS7 Content"
		wprintf(wszNewLine);
		hr = DumpAsnBlob(
			    NULL,
			    fQuiet,
			    pbDecrypted,
			    cbDecrypted,
			    MAXDWORD);
		_PrintIfError(hr, "DumpAsnBlob(decrypted content)");
		if (S_OK == hr)
		{
		    fDecrypted = TRUE;
		    if (NULL != ppbDecrypted)
		    {
			*ppbDecrypted = pbDecrypted;
			pbDecrypted = NULL;
		    }
		    if (NULL != pcbDecrypted)
		    {
			*pcbDecrypted = cbDecrypted;
		    }
		}
		break;
	    }
	}
    }
    if (!fDecrypted)
    {
	if (fSignatureKey && !fExchangeKey)
	{
	    wprintf(myLoadResourceString(IDS_SIGNATURE_NOTKEYEXCHANGE)); // "Found AT_SIGNATURE key but no AT_KEYEXCHANGE key"
	    wprintf(wszNewLine);
	}
	hr = CRYPT_E_NO_DECRYPT_CERT;
	_JumpError(hr, error, "No decryption key");
    }
    hr = S_OK;

error:
    if (NULL != pbDecrypted)
    {
	LocalFree(pbDecrypted);
    }
    if (NULL != pci)
    {
	LocalFree(pci);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    for (iStore = 0; iStore < cStore; iStore++)
    {
	if (NULL != ahStore[iStore] &&
	    hStoreWrapper != ahStore[iStore] &&
	    hStorePKCS7 != ahStore[iStore])
	{
	    CertCloseStore(ahStore[iStore], CERT_CLOSE_STORE_CHECK_FLAG);
	}
    }
    return(hr);
}


HRESULT
dumpPKCS7(
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN BYTE const *pbIn,
    IN DWORD cbIn)
{
    HRESULT hr;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCert = NULL;
    CRL_CONTEXT const *pCRL = NULL;
    HCRYPTMSG hMsg = NULL;
    CRYPT_ATTRIBUTES *pAttrib = NULL;
    BOOL fDisplayed;
    DWORD iElement;
    DWORD cSigner;
    DWORD cRecipient;
    DWORD cb;
    DWORD dwMsgType;
    DWORD dwMsgVersion;
    char *pszInnerContentObjId = NULL;
    WCHAR const *pwsz;
    WCHAR const *pwszVersion;
    UINT idsType = IDS_DUMP_PKCS7;

    hr = myDecodePKCS7(
		    pbIn,
		    cbIn,
		    &pbContents,
		    &cbContents,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    &hStore,
		    &hMsg);
    _JumpIfError2(hr, error, "myDecodePKCS7", CRYPT_E_ASN1_BADTAG);

    cb = sizeof(dwMsgVersion);
    if (!CryptMsgGetParam(
		    hMsg,
		    CMSG_VERSION_PARAM,
		    0,
		    &dwMsgVersion,
		    &cb))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptMsgGetParam(version)");
	dwMsgVersion = MAXDWORD;
    }

    pwszVersion = NULL;
    switch (dwMsgType)
    {
	case CMSG_DATA:
	    pwsz = L"CMSG_DATA";
	    break;

	case CMSG_ENVELOPED:
	    pwsz = L"CMSG_ENVELOPED";
	    switch (dwMsgVersion)
	    {
		case CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION";
		    break;

		case CMSG_ENVELOPED_DATA_CMS_VERSION:
		    pwszVersion = L"CMSG_ENVELOPED_DATA_CMS_VERSION";
		    idsType = IDS_DUMP_PKCS7CMS;
		    break;
	    }
	    break;

	case CMSG_HASHED:
	    pwsz = L"CMSG_HASHED";
	    switch (dwMsgVersion)
	    {
		case CMSG_HASHED_DATA_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_HASHED_DATA_PKCS_1_5_VERSION";
		    break;

		case CMSG_HASHED_DATA_CMS_VERSION:
		    pwszVersion = L"CMSG_HASHED_DATA_CMS_VERSION";
		    idsType = IDS_DUMP_PKCS7CMS;
		    break;
	    }
	    break;

	case CMSG_SIGNED:
	    pwsz = L"CMSG_SIGNED";
	    switch (dwMsgVersion)
	    {
		case CMSG_SIGNED_DATA_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_SIGNED_DATA_PKCS_1_5_VERSION";
		    break;

		case CMSG_SIGNED_DATA_CMS_VERSION:
		    pwszVersion = L"CMSG_SIGNED_DATA_CMS_VERSION";
		    idsType = IDS_DUMP_PKCS7CMS;
		    break;
	    }
	    break;

	case CMSG_SIGNED_AND_ENVELOPED:
	    pwsz = L"CMSG_SIGNED_AND_ENVELOPED";
	    break;

	default:
	    pwsz = myLoadResourceString(IDS_QUESTIONMARKS); // "???"
	    break;
    }

    wprintf(myLoadResourceString(idsType));
    wprintf(wszNewLine);

    wprintf(L"  %ws(%u)\n", pwsz, dwMsgType);
    if (NULL != pwszVersion)
    {
	wprintf(L"  %ws(%u)\n", pwszVersion, dwMsgVersion);
    }
    if (NULL != pszInnerContentObjId)
    {
	wprintf(
	    L"  %ws: ",
	    myLoadResourceString(IDS_DUMP_PKCS7_CONTENT_TYPE));
	cuDumpOIDAndDescriptionA(pszInnerContentObjId);
	wprintf(wszNewLine);
    }
    wprintf(wszNewLine);

    if (NULL == pbContents)
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_CONTENT));
	wprintf(wszNewLine);
    }
    else
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_CONTENTS));	// "PKCS7 Message Content:"
	wprintf(wszNewLine);

	fDisplayed = FALSE;
	if (CMSG_ENVELOPED != dwMsgType)
	{
	    hr = DumpAsnBlob(hStore, FALSE, pbContents, cbContents, MAXDWORD);
	    _PrintIfError(hr, "DumpAsnBlob(content)");
	    fDisplayed = TRUE;
	}
	else if (NULL != hMsg && 0 != cRecipient)
	{
	    hr = cuDumpEncryptedAsnBinary(
				    hMsg,
				    cRecipient,
				    MAXDWORD,	// RecipientIndex
				    hStoreWrapper,
				    hStore,
				    pbIn,
				    cbIn,
				    FALSE,
				    NULL,
				    NULL);
	    _PrintIfError(hr, "cuDumpEncryptedAsnBinary");
	    if (S_OK == hr)
	    {
		fDisplayed = TRUE;
	    }
	}
	if (!fDisplayed)
	{
	    DumpHex(0, pbContents, cbContents);
	}
    }
    wprintf(wszNewLine);

    if (NULL != hMsg)
    {
	BYTE abHash[CBMAX_CRYPT_HASH_LEN];

	hr = cuDumpSigners(
		    hMsg,
		    pszInnerContentObjId,
		    hStore,
		    cSigner,
		    NULL == pbContents,	// fContentEmpty
		    FALSE,		// fVerifyOnly
		    NULL,		// pbHashUserCert
		    NULL);		// pcbHashUserCert
	_JumpIfError(hr, error, "cuDumpSigners");

	hr = cuDumpRecipients(hMsg, hStoreWrapper, cRecipient, FALSE);
	_JumpIfError(hr, error, "cuDumpRecipients");

	cb = sizeof(abHash);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_HASH_DATA_PARAM,
			0,
			abHash,
			&cb))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CryptMsgGetParam(stored hash)", CRYPT_E_INVALID_MSG_TYPE);
	}
	else
	{
	    hr = DumpHash(
		    NULL,
		    IDS_FORMAT_STORED_HASH_COLON,	// "Stored Hash%ws: %ws"
		    g_wszEmpty,
		    abHash,
		    cb);
	    _JumpIfError(hr, error, "DumpHash");
	}
	wprintf(wszNewLine);
    }

    fDisplayed = FALSE;
    if (NULL != hStore)
    {
	CSASSERT(NULL == pCert);
	for (iElement = 0; ; iElement++)
	{
	    pCert = CertEnumCertificatesInStore(hStore, pCert);
	    if (NULL == pCert)
	    {
		break;
	    }
	    if (!fDisplayed)
	    {
		wprintf(myLoadResourceString(IDS_DUMP_PKCS7_CERTIFICATES));
		wprintf(wszNewLine);
		fDisplayed = TRUE;
	    }
	    hr = cuDumpAsnBinary(
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded,
			    iElement);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }
    if (!fDisplayed)
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_CERTIFICATES));
	wprintf(wszNewLine);
    }

    fDisplayed = FALSE;
    if (NULL != hStore)
    {
	CSASSERT(NULL == pCRL);
	for (iElement = 0; ; iElement++)
	{
	    pCRL = CertEnumCRLsInStore(hStore, pCRL);
	    if (NULL == pCRL)
	    {
		break;
	    }
	    if (!fDisplayed)
	    {
		wprintf(myLoadResourceString(IDS_DUMP_PKCS7_CRLS));
		wprintf(wszNewLine);
		fDisplayed = TRUE;
	    }
	    hr = cuDumpAsnBinary(
			    pCRL->pbCrlEncoded,
			    pCRL->cbCrlEncoded,
			    iElement);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }
    if (!fDisplayed)
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_CRLS));
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pAttrib)
    {
	LocalFree(pAttrib);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbContents)
    {
	LocalFree(pbContents);
    }
    return(hr);
}


HRESULT
GetVersionStuff(
    IN WCHAR const *pwszFileName,
    OUT DWORD *pdwLangRet,
    OUT VS_FIXEDFILEINFO *pvsRet)
{
    HRESULT hr;
    VOID *pvData = NULL;
    DWORD cbData;
    DWORD dwHandle;
    DWORD *pdwTranslation;
    UINT uLen;
    DWORD dwDefLang = 0x409;
    VS_FIXEDFILEINFO *pvs;

    cbData = GetFileVersionInfoSize(
			    const_cast<WCHAR *>(pwszFileName),
			    &dwHandle);
    if (0 == cbData)
    {
        hr = GetLastError();
        if (S_OK == hr)
	{
	    hr = ERROR_RESOURCE_DATA_NOT_FOUND;
	}
        goto error;
    }

    pvData = LocalAlloc(LMEM_FIXED, cbData);
    if (NULL == pvData)
    {
        hr = GetLastError();
        goto error;
    }

    if (!GetFileVersionInfo(
			const_cast<WCHAR *>(pwszFileName),
			0,
			cbData,
			pvData))
    {
        hr = GetLastError();
        goto error;
    }

    if (!VerQueryValue(pvData, L"\\VarFileInfo\\Translation", (VOID **) &pdwTranslation, &uLen))
    {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    *pdwLangRet = *pdwTranslation;

    if (!VerQueryValue(pvData, L"\\", (VOID **) &pvs, &uLen))
    {
        hr = GetLastError();
        goto error;
    }
    *pvsRet = *pvs;
    hr = S_OK;

error:
    if (NULL != pvData)
    {
        LocalFree(pvData);
    }
    return(hr);
}


HRESULT
FileVersionDump(
    IN WCHAR const *pwszFileName)
{
    HRESULT hr;
    DWORD dwLang;
    VS_FIXEDFILEINFO vs;

    hr = GetVersionStuff(pwszFileName, &dwLang, &vs);
    if (S_OK == hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_LANG), // "%ws: Lang %08x (%d.%d)"
	    pwszFileName,
	    dwLang,
	    HIWORD(dwLang),
	    LOWORD(dwLang));

	wprintf(
	    myLoadResourceString(IDS_FORMAT_FILE), // "  File %d.%d:%d.%d"
	    HIWORD(vs.dwFileVersionMS),
	    LOWORD(vs.dwFileVersionMS),
	    HIWORD(vs.dwFileVersionLS),
	    LOWORD(vs.dwFileVersionLS));

	wprintf(
	    myLoadResourceString(IDS_FORMAT_PRODUCT), // "  Product %d.%d:%d.%d\n"
	    HIWORD(vs.dwProductVersionMS),
	    LOWORD(vs.dwProductVersionMS),
	    HIWORD(vs.dwProductVersionLS),
	    LOWORD(vs.dwProductVersionLS));
    }
    return(hr);
}


#define wszINFKEY_CONTINUE		L"_continue_"

#define szINFSECTION_PASSWORDTOKEN	"Password Token"
#define wszINFSECTION_PASSWORDTOKEN	TEXT(szINFSECTION_PASSWORDTOKEN)
#define wszINFKEY_PROTECTION		L"Protection"
#define wszINFKEY_PROFILEVERSION	L"Profile Version"
#define wszINFKEY_TOKEN			L"Token"
#define wszINFKEY_SALTVALUE		L"SaltValue"
#define wszINFKEY_HASHSIZE		L"HashSize"

#define wszINFSECTION_USERX500NAME	L"User X.500 Name"
#define wszINFKEY_X500NAME		L"X500Name"

#define wszINFSECTION_SMIME		L"S/MIME"
#define wszINFKEY_SIGNINGCERTIFICATE	L"@Signing Certificate"
#define wszINFKEY_SIGNINGKEY		L"@Signing Key"
#define wszINFKEY_PRIVATEKEYS		L"@Private Keys"
#define wszINFKEY_KEYCOUNT		L"KeyCount"
#define wszINFKEY_ISSUINGCERTIFICATES	L"@Issuing Certificates"
#define wszINFKEY_TRUSTLISTCERTIFICATE	L"@Trust List Certificate"

#define wszINFSECTION_FULLCERIFICATEHISTORY L"Full Certificate History"
#define wszINFKEY_SMIME1		L"@SMIME_1"


HRESULT
cuPatchEPFFile(
    IN WCHAR const *pwszfnIn,
    OUT WCHAR **ppwszfnOut)
{
    HRESULT hr;
    char *pszfnIn = NULL;
    char *pszfnOut = NULL;
    FILE *pfIn = NULL;
    FILE *pfOut = NULL;
    char *psz;
    char achLine[1024];
    WCHAR awcTempDir[MAX_PATH];
    WCHAR awcfnOut[MAX_PATH];
    BOOL fDeleteTempFile = FALSE;

    *ppwszfnOut = NULL;
    if (!ConvertWszToSz(&pszfnIn, pwszfnIn, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    pfIn = fopen(pszfnIn, "r");
    if (NULL == pfIn)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "fopen");
    }
    hr = S_FALSE;
    if (NULL == fgets(achLine, ARRAYSIZE(achLine), pfIn))
    {
	goto error;
    }
    psz = strchr(achLine, chLBRACKET);
    if (NULL == psz ||
	NULL == strstr(psz, szINFSECTION_PASSWORDTOKEN) ||
	NULL == strchr(psz, chRBRACKET))
    {
	goto error;
    }

    if (!GetEnvironmentVariable(L"temp", awcTempDir, ARRAYSIZE(awcTempDir)) &&
	!GetEnvironmentVariable(L"tmp", awcTempDir, ARRAYSIZE(awcTempDir)))
    {
	hr = myHLastError();
	_PrintError(hr, "GetEnvironmentVariable");
	wcscpy(awcTempDir, L".");
    }
    if (!GetTempFileName(
		awcTempDir,		// directory name
		L"epf",			// lpPrefixString
		0,			// uUnique
		awcfnOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetTempFileName");
    }
    fDeleteTempFile = TRUE;

    if (!ConvertWszToSz(&pszfnOut, awcfnOut, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    pfOut = fopen(pszfnOut, "w");
    if (NULL == pfOut)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "fopen");
    }

    fputs("[Version]\nSignature=\"$Windows NT$\"\n\n", pfOut);
    fseek(pfIn, 0L, SEEK_SET);

    while (NULL != fgets(achLine, ARRAYSIZE(achLine), pfIn))
    {
	char *pszPrint;
	char *pszToken;
	BOOL fQuote;
	
	psz = strchr(achLine, '\n');
	if (NULL == psz)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Line overflow");
	}
	*psz = '\0';

	fQuote = FALSE;
	pszPrint = achLine;
	pszToken = achLine;
	while (' ' == *pszToken)
	{
	    pszToken++;
	}
	psz = strchr(achLine, '=');
	if (';' != *pszToken && NULL != psz)
	{
	    pszPrint = psz + 1;
	    *psz = '\0';
	    while (' ' == *--psz)
	    {
		*psz = '\0';
	    }
	    fQuote = NULL != strchr(pszToken, ' ');
	    if (fQuote)
	    {
		fputs("\"", pfOut);
	    }
	    fputs(pszToken, pfOut);
	    if (fQuote)
	    {
		fputs("\"", pfOut);
	    }
	    fputs(" = ", pfOut);

	    while (' ' == *pszPrint)
	    {
		pszPrint++;
	    }
	    psz = &pszPrint[strlen(pszPrint)];
	    while (' ' == *--psz)
	    {
		*psz = '\0';
	    }
	    fQuote = '\0' != pszPrint[strcspn(pszPrint, " ,=")];
	}
	if (fQuote)
	{
	    fputs("\"", pfOut);
	}
	fputs(pszPrint, pfOut);
	if (fQuote)
	{
	    fputs("\"", pfOut);
	}
	fputs("\n", pfOut);
    }
    fflush(pfOut);
    if (ferror(pfOut))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "I/O error");
    }

    hr = myDupString(awcfnOut, ppwszfnOut);
    _JumpIfError(hr, error, "myDupString");

    fDeleteTempFile = FALSE;

error:
    if (NULL != pfIn)
    {
	fclose(pfIn);
    }
    if (NULL != pfOut)
    {
	fclose(pfOut);
    }
    if (fDeleteTempFile)
    {
	DeleteFile(awcfnOut);
    }
    if (NULL != pszfnIn)
    {
	LocalFree(pszfnIn);
    }
    if (NULL != pszfnOut)
    {
	LocalFree(pszfnOut);
    }
    return(hr);
}


HRESULT
cuInfDumpNumericKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey)
{
    HRESULT hr;
    DWORD dw;
    
    hr = myInfGetNumericKeyValue(hInf, FALSE, pwszSection, pwszKey, &dw);
    _JumpIfErrorStr(hr, error, "myInfGetNumericKeyValue", pwszKey);

    wprintf(L"\n[%ws] %ws = %u\n", pwszSection, pwszKey, dw);

error:
    return(hr);
}


HRESULT
cuInfDumpStringKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;

    hr = myInfGetKeyValue(hInf, FALSE, pwszSection, pwszKey, &pwszValue);
    _JumpIfErrorStr(hr, error, "myInfGetKeyValue", pwszKey);

    wprintf(L"\n[%ws] %ws = %ws\n", pwszSection, pwszKey, pwszValue);

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
cuInfDumpDNKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    WCHAR *pwszName = NULL;
    CERT_NAME_BLOB Name;

    Name.pbData = NULL;

    hr = myInfGetKeyValue(hInf, FALSE, pwszSection, pwszKey, &pwszValue);
    _JumpIfErrorStr(hr, error, "myInfGetKeyValue", pwszKey);

    wprintf(L"\n[%ws] %ws = %ws\n", pwszSection, pwszKey, pwszValue);

    hr = myCertStrToName(
		X509_ASN_ENCODING,
		pwszValue,		// pszX500
		0,			// CERT_NAME_STR_REVERSE_FLAG
		NULL,			// pvReserved
		&Name.pbData,
		&Name.cbData,
		NULL);			// ppszError
    _JumpIfErrorStr(hr, error, "myCertStrToName", pwszValue);

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&Name,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwszName);
    _JumpIfError(hr, error, "myCertNameToStr");

    wprintf(L"\n[%ws] %ws = %ws\n", pwszSection, pwszKey, pwszName);

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != Name.pbData)
    {
	LocalFree(Name.pbData);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
cuInfDumpHexKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    BYTE *pb = NULL;
    DWORD cb;
    
    hr = myInfGetKeyValue(hInf, FALSE, pwszSection, pwszKey, &pwszValue);
    _JumpIfErrorStr(hr, error, "myInfGetKeyValue", pwszKey);

    wprintf(L"\n[%ws] %ws = %ws\n\n", pwszSection, pwszKey, pwszValue);

    hr = WszToMultiByteInteger(TRUE, pwszValue, &cb, &pb);
    _JumpIfErrorStr(hr, error, "WszToMultiByteInteger", pwszValue);

    DumpHex(0, pb, cb);

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
cuInfDumpBase64KeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    BYTE *pb = NULL;
    DWORD cb;
    
    hr = myInfGetKeyValue(hInf, FALSE, pwszSection, pwszKey, &pwszValue);
    _JumpIfErrorStr(hr, error, "myInfGetKeyValue", pwszKey);

    wprintf(L"\n[%ws] %ws = %ws\n\n", pwszSection, pwszKey, pwszValue);

    hr = myCryptStringToBinary(
			pwszValue,
			0,
			CRYPT_STRING_BASE64,
			&pb,
			&cb,
			NULL,
			NULL);
    _JumpIfError(hr, error, "myCryptStringToBinary");

    DumpHex(0, pb, cb);

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
EPFFileDump(
    IN WCHAR const *pwszFileName)
{
    HRESULT hr;
    WCHAR *pwszTempFile = NULL;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    WCHAR wszPassword[MAX_PATH];

    hr = cuPatchEPFFile(pwszFileName, &pwszTempFile);
    _JumpIfError2(hr, error, "cuPatchEPFFile", S_FALSE);

    hr = cuGetPassword(FALSE, wszPassword, ARRAYSIZE(wszPassword));
    _JumpIfError(hr, error, "cuGetPassword");

    hr = myInfOpenFile(pwszTempFile, &hInf, &ErrorLine);
    _JumpIfError(hr, error, "myInfOpenFile");

    hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_PROTECTION);
    _JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

    hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_PROFILEVERSION);
    _JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

    hr = cuInfDumpHexKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_TOKEN);
    _JumpIfError(hr, error, "cuInfDumpHexKeyValue");

    hr = cuInfDumpBase64KeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_SALTVALUE);
    _JumpIfError(hr, error, "cuInfDumpBase64KeyValue");

    hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_HASHSIZE);
    _JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

    hr = cuInfDumpDNKeyValue(
			hInf,
			wszINFSECTION_USERX500NAME,
			wszINFKEY_X500NAME);
    _JumpIfError(hr, error, "cuInfDumpDNKeyValue");

    hr = cuInfDumpBase64KeyValue(
			hInf,
			wszINFSECTION_SMIME,
			wszINFKEY_SIGNINGCERTIFICATE);
    _JumpIfError(hr, error, "cuInfDumpBase64KeyValue");

    hr = cuInfDumpBase64KeyValue(
			hInf,
			wszINFSECTION_SMIME,
			wszINFKEY_SIGNINGKEY);
    _JumpIfError(hr, error, "cuInfDumpBase64KeyValue");

    hr = cuInfDumpBase64KeyValue(
			hInf,
			wszINFSECTION_SMIME,
			wszINFKEY_PRIVATEKEYS);
    _JumpIfError(hr, error, "cuInfDumpBase64KeyValue");

    hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_SMIME,
			wszINFKEY_KEYCOUNT);
    _JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

    hr = cuInfDumpBase64KeyValue(
			hInf,
			wszINFSECTION_SMIME,
			wszINFKEY_ISSUINGCERTIFICATES);
    _JumpIfError(hr, error, "cuInfDumpBase64KeyValue");

    hr = cuInfDumpBase64KeyValue(
			hInf,
			wszINFSECTION_SMIME,
			wszINFKEY_TRUSTLISTCERTIFICATE);
    _JumpIfError(hr, error, "cuInfDumpBase64KeyValue");

    hr = cuInfDumpBase64KeyValue(
			hInf,
			wszINFSECTION_FULLCERIFICATEHISTORY,
			wszINFKEY_SMIME1);
    _JumpIfError(hr, error, "cuInfDumpBase64KeyValue");

error:
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    if (NULL != pwszTempFile)
    {
	if (!g_fSplitASN)
	{
	    DeleteFile(pwszTempFile);
	}
	LocalFree(pwszTempFile);
    }
    return(hr);
}


HRESULT
cuFileDump(
    IN WCHAR const *pwszfn)
{
    HRESULT hr;
    BYTE *pbIn = NULL;
    DWORD cbIn;

    hr = FileVersionDump(pwszfn);
    if (S_OK == hr)
    {
	goto error;
    }
    hr = EPFFileDump(pwszfn);
    if (S_FALSE != hr)
    {
	_PrintIfError(hr, "EPFFileDump");
	goto error;
    }
    hr = DecodeFileW(pwszfn, &pbIn, &cbIn, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }
    CSASSERT(NULL != pbIn);

    hr = cuDumpAsnBinary(pbIn, cbIn, MAXDWORD);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_CANNOT_DECODE, hr);
	goto error;
    }

error:
    if (NULL != pbIn)
    {
        LocalFree(pbIn);
    }
    return(hr);
}


HRESULT
cuDumpSerial(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN DWORD idMessage,
    IN CRYPT_INTEGER_BLOB const *pSerial)
{
    HRESULT hr;
    BSTR strSerial = NULL;

    hr = MultiByteIntegerToBstr(
			    FALSE,
			    pSerial->cbData,
			    pSerial->pbData,
			    &strSerial);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    if (NULL != pwszPrefix)
    {
	wprintf(pwszPrefix);
    }
    wprintf(myLoadResourceString(idMessage));
    wprintf(L" %ws\n", strSerial);

    if (g_fVerbose)
    {
	DumpHex(
	    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	    pSerial->pbData,
	    pSerial->cbData);
    }

error:
    if (NULL != strSerial)
    {
	SysFreeString(strSerial);
    }
    return(hr);
}


HRESULT
cuDumpFileTimePeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    WCHAR *pwszTimePeriod;
    
    hr = myFileTimePeriodToWszTimePeriod(pftGMT, g_fSeconds, &pwszTimePeriod);
    _JumpIfError(hr, error, "myFileTimePeriodToWszTimePeriod");

    if (NULL == pwszQuote)
    {
	pwszQuote = g_wszEmpty;
    }
    wprintf(L" %ws%ws%ws\n", pwszQuote, pwszTimePeriod, pwszQuote);
    hr = S_OK;

error:
    if (NULL != pwszTimePeriod)
    {
	LocalFree(pwszTimePeriod);
    }
    return(hr);
}


HRESULT
cuDumpFileTime(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    WCHAR *pwszDate = NULL;
    WCHAR const *pwszResource = NULL;

    if (0 != idMessage)
    {
	pwszResource = myLoadResourceString(idMessage);
    }
    if (NULL == pwszResource)
    {
	pwszResource = g_wszEmpty;
    }
    if (NULL == pwszQuote)
    {
	pwszQuote = g_wszEmpty;
    }
    if (0 == pftGMT->dwLowDateTime &&
	0 == pftGMT->dwHighDateTime)
    {
	wprintf(
	    L"%ws %ws\n",
	    pwszResource,
	    myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
    }
    else
    {
	if (g_fGMT)
	{
	    hr = myFileTimeToWszTime(pftGMT, g_fSeconds, &pwszDate);
	    _JumpIfError(hr, error, "myFileTimeToWszTime");
	}
	else
	{
	    hr = myGMTFileTimeToWszLocalTime(pftGMT, g_fSeconds, &pwszDate);
	    _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");
	}
	wprintf(
	    L"%ws %ws%ws%ws%ws%ws\n",
	    pwszResource,
	    pwszQuote,
	    pwszDate,
	    g_fGMT? L" " : g_wszEmpty,
	    g_fGMT? myLoadResourceString(IDS_GMT_SUFFIX) : g_wszEmpty,
	    pwszQuote);
    }
    hr = S_OK;

error:
    if (NULL != pwszDate)
    {
	LocalFree(pwszDate);
    }
    return(hr);
}


HRESULT
cuDumpFileTimeOrPeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    
    if (0 <= (LONG) pftGMT->dwHighDateTime)
    {
	hr = cuDumpFileTime(idMessage, pwszQuote, pftGMT);
	_JumpIfError(hr, error, "cuDumpFileTime");
    }
    else
    {
	hr = cuDumpFileTimePeriod(idMessage, pwszQuote, pftGMT);
	_JumpIfError(hr, error, "cuDumpFileTimePeriod");
    }

error:
    return(hr);
}


HRESULT
cuDumpDate(
    IN DATE const *pDate)
{
    HRESULT hr;
    FILETIME ft;

    if (0.0 == *pDate)
    {
	ft.dwLowDateTime = 0;
	ft.dwHighDateTime = 0;
    }
    else
    {
	hr = myDateToFileTime(pDate, &ft);
	_JumpIfError(hr, error, "myDateToFileTime");
    }
    hr = cuDumpFileTime(0, NULL, &ft);
    _JumpIfError(hr, error, "cuDumpFileTime");

error:
    return(hr);
}


VOID
DumpBlob(
    IN DWORD idMessage,
    IN CRYPT_BIT_BLOB const *pBlob)
{
    if (NULL != pBlob->pbData)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);
	DumpHex(DH_NOTABPREFIX | 4, pBlob->pbData, pBlob->cbData);
    }
}


HRESULT
cuDisplayKeyId(
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN DWORD cExtension,
    OPTIONAL IN CERT_EXTENSION const *rgExtension)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];

    cbHash = sizeof(abHash);
    if (!CryptHashPublicKeyInfo(
			NULL,		// hCryptProv
			CALG_SHA1,
			0,		// dwFlags,
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptHashPublicKeyInfo");
    }
    hr = DumpHash(
	    NULL,
	    IDS_FORMAT_KEYHASH_COLON,	// "Public Key Hash(%ws): %ws"
	    L"sha1",
	    abHash,
	    cbHash);
    _JumpIfError(hr, error, "DumpHash");

    if (0 != cExtension && NULL != rgExtension)
    {
	CERT_EXTENSION const *pExt;
	DWORD cb;
	CRYPT_DATA_BLOB aBlob[1 + BLOB_ROUND(CBMAX_CRYPT_HASH_LEN)];

	pExt = CertFindExtension(
			szOID_SUBJECT_KEY_IDENTIFIER,
			cExtension,
			const_cast<CERT_EXTENSION *>(rgExtension));
	if (NULL != pExt)
	{
	    cb = sizeof(aBlob);
	    if (!CryptDecodeObject(
				X509_ASN_ENCODING,
				X509_OCTET_STRING,
				pExt->Value.pbData,
				pExt->Value.cbData,
				0,
				aBlob,
				&cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptDecodeObject");
	    }
	    if (cbHash != aBlob[0].cbData ||
		0 != memcmp(abHash, aBlob[0].pbData, aBlob[0].cbData))
	    {
		hr = DumpHash(
			NULL,
			IDS_FORMAT_SUBJECTKEYID_COLON, // "Subject Key Id (%ws): %ws"
			myLoadResourceString(IDS_PRECOMPUTED), // "precomputed"
			aBlob[0].pbData,
			aBlob[0].cbData);
		_JumpIfError(hr, error, "DumpHash");
	    }
	}
    }

error:
    return(hr);
}


HRESULT
cuDisplayHash(
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN CRL_CONTEXT const *pCRLContext,
    IN DWORD dwPropId,
    IN WCHAR const *pwszHashName)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    UINT idMsg;

    cbHash = sizeof(abHash);
    if (NULL != pCertContext)
    {
	if (!CertGetCertificateContextProperty(
				    pCertContext,
				    dwPropId,
				    abHash,
				    &cbHash))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}
	idMsg = IDS_FORMAT_CERTHASH_COLON;	// "Cert Hash(%ws): %ws"
    }
    else
    {
	CSASSERT(NULL != pCRLContext);
	if (!CertGetCRLContextProperty(pCRLContext, dwPropId, abHash, &cbHash))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCRLContextProperty");
	}
	idMsg = IDS_FORMAT_CRLHASH_COLON;	// "CRL Hash(%ws): %ws"
    }
    hr = DumpHash(pwszPrefix, idMsg, pwszHashName, abHash, cbHash);
    _JumpIfError(hr, error, "DumpHash");

error:
    return(hr);
}


HRESULT
cuGetCertType(
    IN CERT_INFO const *pCertInfo,
    OPTIONAL OUT WCHAR **ppwszCertTypeNameV1,
    OPTIONAL OUT WCHAR **ppwszDisplayNameV1,
    OPTIONAL OUT WCHAR **ppwszCertTypeObjId,
    OPTIONAL OUT WCHAR **ppwszCertTypeName,
    OPTIONAL OUT WCHAR **ppwszDisplayName)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;
    WCHAR *pwszCertTypeNameV1 = NULL;
    WCHAR *pwszCNV1 = NULL;
    WCHAR *pwszDisplayNameV1 = NULL;
    WCHAR *pwszCertTypeObjId = NULL;
    WCHAR *pwszCN = NULL;
    WCHAR *pwszDisplayName = NULL;
    CERT_TEMPLATE_EXT *pTemplate = NULL;

    if (NULL != ppwszCertTypeNameV1)
    {
	*ppwszCertTypeNameV1 = NULL;
    }
    if (NULL != ppwszDisplayNameV1)
    {
	*ppwszDisplayNameV1 = NULL;
    }
    if (NULL != ppwszCertTypeObjId)
    {
	*ppwszCertTypeObjId = NULL;
    }
    if (NULL != ppwszCertTypeName)
    {
	*ppwszCertTypeName = NULL;
    }
    if (NULL != ppwszDisplayName)
    {
	*ppwszDisplayName = NULL;
    }

    // Look for the V1 cert type extension first

    pExt = CertFindExtension(
		    szOID_ENROLL_CERTTYPE_EXTENSION,
		    pCertInfo->cExtension,
		    pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	hr = UnicodeDecode(&pExt->Value, &pwszCertTypeNameV1);
	_JumpIfError(hr, error, "UnicodeDecode");

	hr = cuGetTemplateNames(
			pwszCertTypeNameV1,
			&pwszCNV1,
			&pwszDisplayNameV1);
	_PrintIfErrorStr2(hr, "cuGetTemplateNames", pwszCertTypeNameV1, hr);
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    _JumpIfErrorStr(hr, error, "cuGetTemplateNames", pwszCertTypeNameV1);
	}
    }

    pExt = CertFindExtension(
		    szOID_CERTIFICATE_TEMPLATE,
		    pCertInfo->cExtension,
		    pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	DWORD cb;

	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERTIFICATE_TEMPLATE,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pTemplate,
			&cb))
	{
	    CSASSERT(NULL == pTemplate);
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
	if (!ConvertSzToWsz(&pwszCertTypeObjId, pTemplate->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}
	hr = cuGetTemplateNames(pwszCertTypeObjId, &pwszCN, &pwszDisplayName);
	_PrintIfErrorStr2(hr, "cuGetTemplateNames", pwszCertTypeObjId, hr);
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    _JumpIfErrorStr(hr, error, "cuGetTemplateNames", pwszCertTypeObjId);
	}

    }
    if (NULL == pwszCertTypeNameV1 && NULL == pwszCertTypeObjId)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError2(hr, error, "CertFindExtension", CRYPT_E_NOT_FOUND);
    }
    if (NULL != ppwszCertTypeNameV1)
    {
	if (NULL != pwszCNV1)
	{
	    *ppwszCertTypeNameV1 = pwszCNV1;
	    pwszCNV1 = NULL;
	}
	else
	{
	    *ppwszCertTypeNameV1 = pwszCertTypeNameV1;
	    pwszCertTypeNameV1 = NULL;
	}
    }
    if (NULL != ppwszDisplayNameV1)
    {
	*ppwszDisplayNameV1 = pwszDisplayNameV1;
	pwszDisplayNameV1 = NULL;
    }
    if (NULL != ppwszCertTypeObjId)
    {
	*ppwszCertTypeObjId = pwszCertTypeObjId;
	pwszCertTypeObjId = NULL;
    }
    if (NULL != ppwszCertTypeName)
    {
	*ppwszCertTypeName = pwszCN;
	pwszCN = NULL;
    }
    if (NULL != ppwszDisplayName)
    {
	*ppwszDisplayName = pwszDisplayName;
	pwszDisplayName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszCertTypeNameV1)
    {
        LocalFree(pwszCertTypeNameV1);
    }
    if (NULL != pwszCNV1)
    {
        LocalFree(pwszCNV1);
    }
    if (NULL != pwszDisplayNameV1)
    {
        LocalFree(pwszDisplayNameV1);
    }
    if (NULL != pwszCertTypeObjId)
    {
        LocalFree(pwszCertTypeObjId);
    }
    if (NULL != pwszCN)
    {
        LocalFree(pwszCN);
    }
    if (NULL != pwszDisplayName)
    {
        LocalFree(pwszDisplayName);
    }
    if (NULL != pTemplate)
    {
        LocalFree(pTemplate);
    }
    return(hr);
}


HRESULT
cuDumpCertType(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN CERT_INFO const *pCertInfo)
{
    HRESULT hr;
    WCHAR *apwsz[6];
    DWORD i;
    DWORD j;
    BOOL fFirst;

    ZeroMemory(&apwsz, sizeof(apwsz));

    hr = cuGetCertType(
		pCertInfo,
		&apwsz[0],		// ppwszCertTypeNameV1
		&apwsz[1],		// ppwszDisplayNameV1
		&apwsz[2],		// ppwszCertTypeObjId
		&apwsz[3],		// ppwszCertTypeName
		&apwsz[4]);		// ppwszDisplayName
    _JumpIfError2(hr, error, "cuGetCertType", CRYPT_E_NOT_FOUND);

    if (NULL != apwsz[2])	// pwszCertTypeObjId
    {
	WCHAR const *pwszFriendlyName;

	pwszFriendlyName = cuGetOIDName(apwsz[2]);
	if (NULL != pwszFriendlyName && L'\0' != *pwszFriendlyName)
	{
	    hr = myDupString(pwszFriendlyName, &apwsz[5]);
	    _JumpIfError(hr, error, "myDupString");
	}
    }

    wprintf(
	L"%ws%ws: ",
	NULL != pwszPrefix? pwszPrefix : L"",
	myLoadResourceString(IDS_TEMPLATE_NAME));	// "Template"

    // Suppress the long, ugly ObjId, unless they really want to see it:

    if (!g_fVerbose &&
	NULL != apwsz[2] &&
	(NULL != apwsz[0] || NULL != apwsz[3]))
    {
	LocalFree(apwsz[2]);
	apwsz[2] = NULL;
    }

    fFirst = TRUE;
    for (i = 0; i < ARRAYSIZE(apwsz); i++)
    {
	if (NULL != apwsz[i])
	{
	    BOOL fDup = FALSE;
	    
	    for (j = 0; j < i; j++)
	    {
		if (NULL != apwsz[j] && 0 == lstrcmp(apwsz[i], apwsz[j]))
		{
		    fDup = TRUE;
		    break;
		}
	    }
	    if (!fDup)
	    {
		if (!fFirst)
		{
		    wprintf(L", ");
		}
		wprintf(L"%ws", apwsz[i]);
		fFirst = FALSE;
	    }
	}
    }
    wprintf(wszNewLine);

error:
    for (i = 0; i < ARRAYSIZE(apwsz); i++)
    {
	if (NULL != apwsz[i])
	{
	    LocalFree(apwsz[i]);
	}
    }
    return(hr);
}


HRESULT
dumpCert(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertContext = NULL;
    CERT_INFO *pCertInfo;
    BOOL fIssuerMatches;
    DWORD id;

    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, pbIn, cbIn);
    if (NULL == pCertContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pCertInfo = pCertContext->pCertInfo;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);

	cuDumpVersion(pCertInfo->dwVersion + 1);
    }

    hr = cuDumpSerial(NULL, IDS_SERIAL, &pCertInfo->SerialNumber);
    _JumpIfError(hr, error, "cuDumpSerial");

    if (!g_fQuiet)
    {
	DumpAlgorithm(IDS_SIGNATURE_ALGORITHM, &pCertInfo->SignatureAlgorithm);

	hr = cuDisplayCertName(
			TRUE,
			NULL,
			myLoadResourceString(IDS_ISSUER), // "Issuer"
			g_wszPad4,
			&pCertInfo->Issuer);
	_JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

	wprintf(wszNewLine);
	hr = cuDumpFileTime(IDS_NOTBEFORE, NULL, &pCertInfo->NotBefore);
	_JumpIfError(hr, error, "cuDumpFileTime");

	hr = cuDumpFileTime(IDS_NOTAFTER, NULL, &pCertInfo->NotAfter);
	_JumpIfError(hr, error, "cuDumpFileTime");

	wprintf(wszNewLine);
    }
    hr = cuDisplayCertName(
		    TRUE,
		    NULL,
		    myLoadResourceString(IDS_SUBJECT), // "Subject"
		    g_wszPad4,
		    &pCertInfo->Subject);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    if (!g_fQuiet)
    {
	wprintf(wszNewLine);
	cuDumpPublicKey(&pCertInfo->SubjectPublicKeyInfo);
	DumpBlob(IDS_ISSUERUNIQUEID, &pCertInfo->IssuerUniqueId);
	DumpBlob(IDS_SUBJECTUNIQUEID, &pCertInfo->SubjectUniqueId);
    }

    hr = cuDumpExtensionArray(
			IDS_CERTIFICATE_EXTENSIONS,
			pCertInfo->cExtension,
			pCertInfo->rgExtension);
    _JumpIfError(hr, error, "cuDumpExtensionArray");

    if (!g_fQuiet)
    {
	DumpSignature(pcsci);
    }

    if (!CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &pCertInfo->Issuer,
			    &pCertInfo->Subject))
    {
	fIssuerMatches = FALSE;
    }
    else
    {
	fIssuerMatches = TRUE;
    }

    hr = cuVerifySignature(pbIn, cbIn, &pCertInfo->SubjectPublicKeyInfo, TRUE);
    if (S_OK != hr)
    {
	if (fIssuerMatches)
	{
	    id = IDS_ERR_FORMAT_ROOT_CERT_BAD_SIG;	// "Possible Root Certificate: Subject matches Issuer, but Signature check fails: %x"
	}
	else
	{
	    id = IDS_NO_ROOT_CERT;	// "Non-root Certificate"
	}
    }
    else
    {
	if (fIssuerMatches)
	{
	    id = IDS_ROOT_CERT;	// "Root Certificate: Subject matches Issuer"
	}
	else
	{
	    id = IDS_NO_ROOT_CERT_GOOD_SIG;	// "Non-root Certificate uses same Public Key as Issuer"
	}
    }
    wprintf(myLoadResourceString(id), hr);
    wprintf(wszNewLine);

    if (!g_fQuiet)
    {
	cuDisplayKeyId(
		&pCertContext->pCertInfo->SubjectPublicKeyInfo,
		pCertContext->pCertInfo->cExtension,
		pCertContext->pCertInfo->rgExtension);
	hr = cuDisplayHash(
			NULL,
			pCertContext,
			NULL,
			CERT_MD5_HASH_PROP_ID,
			L"md5");
	_JumpIfError(hr, error, "cuDisplayHash");
    }
    hr = cuDisplayHash(
		    NULL,
		    pCertContext,
		    NULL,
		    CERT_SHA1_HASH_PROP_ID,
		    L"sha1");
    _JumpIfError(hr, error, "cuDisplayHash");

error:
    if (NULL != pCertContext)
    {
	CertFreeCertificateContext(pCertContext);
    }
    return(hr);
}


HRESULT
dumpCertSequence(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCert;
    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *pSeq;

    pSeq = (CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *) pbDecoded;

    if (0 != strcmp(szOID_NETSCAPE_CERT_SEQUENCE, pSeq->pszObjId))
    {
	hr = CRYPT_E_ASN1_ERROR;
	_JumpError2(hr, error, "not a cert sequence", hr);
    }

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    hr = S_OK;
    for (iCert = 0; iCert < pSeq->cValue; iCert++)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_DUMP_CERT_INDEX),  // "================ Certificate %d ================"
	    iCert);
	wprintf(wszNewLine);

	hr2 = cuDumpAsnBinary(
			pSeq->rgValue[iCert].pbData,
			pSeq->rgValue[iCert].cbData,
			iCert);
	if (S_OK != hr2)
	{
	    cuPrintError(IDS_ERR_FORMAT_CANNOT_DECODE, hr2);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

error:
    return(hr);
}


HRESULT
dumpCRL(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRLContext = NULL;
    CRL_INFO const *pCRLInfo;
    DWORD i;
    CRL_ENTRY *pCRLEntry;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    pCRLContext = CertCreateCRLContext(X509_ASN_ENCODING, pbIn, cbIn);
    if (NULL == pCRLContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCRLContext");
    }
    pCRLInfo = pCRLContext->pCrlInfo;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);

	cuDumpVersion(pCRLInfo->dwVersion + 1);
	DumpAlgorithm(IDS_SIGNATURE_ALGORITHM, &pCRLInfo->SignatureAlgorithm);
    }

    hr = cuDisplayCertName(
		    TRUE,
		    NULL,
		    myLoadResourceString(IDS_ISSUER), // "Issuer"
		    g_wszPad4,
		    &pCRLInfo->Issuer);
    _JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

    if (!g_fQuiet)
    {
	wprintf(wszNewLine);

	hr = cuDumpFileTime(IDS_THISUPDATE, NULL, &pCRLInfo->ThisUpdate);
	_JumpIfError(hr, error, "cuDumpFileTime");

	hr = cuDumpFileTime(IDS_NEXTUPDATE, NULL, &pCRLInfo->NextUpdate);
	_JumpIfError(hr, error, "cuDumpFileTime");

	wprintf(myLoadResourceString(IDS_CRLENTRIES)); // "CRL Entries:"
	wprintf(L" %u\n", pCRLInfo->cCRLEntry);

	for (i = 0; i < pCRLInfo->cCRLEntry; i++)
	{
	    pCRLEntry = &pCRLInfo->rgCRLEntry[i];

	    wprintf(g_wszPad2);
	    hr = cuDumpSerial(NULL, IDS_SERIAL, &pCRLEntry->SerialNumber);
	    _JumpIfError(hr, error, "cuDumpSerial");

	    wprintf(g_wszPad2);
	    hr = cuDumpFileTime(
			IDS_REVOCATIONDATE,
			NULL,
			&pCRLEntry->RevocationDate);
	    _JumpIfError(hr, error, "cuDumpFileTime");

	    if (0 != pCRLEntry->cExtension)
	    {
		wprintf(g_wszPad2);
		hr = cuDumpExtensionArray(
				    IDS_EXTENSIONS,
				    pCRLEntry->cExtension,
				    pCRLEntry->rgExtension);
		_JumpIfError(hr, error, "cuDumpExtensionArray");
	    }
	    wprintf(wszNewLine);
	}
    }
    if (0 != pCRLInfo->cExtension)
    {
	hr = cuDumpExtensionArray(
			    IDS_CRLEXTENSIONS,
			    pCRLInfo->cExtension,
			    pCRLInfo->rgExtension);
	_JumpIfError(hr, error, "cuDumpExtensionArray");
    }
    if (!g_fQuiet)
    {
	DumpSignature(pcsci);
	hr = cuDisplayHash(
			NULL,
			NULL,
			pCRLContext,
			CERT_MD5_HASH_PROP_ID,
			L"md5");
	_JumpIfError(hr, error, "cuDisplayHash");
    }
    hr = cuDisplayHash(
		    NULL,
		    NULL,
		    pCRLContext,
		    CERT_SHA1_HASH_PROP_ID,
		    L"sha1");
    _JumpIfError(hr, error, "cuDisplayHash");

error:
    return(hr);
}


HRESULT
dumpRequest(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CERT_REQUEST_INFO const *pRequest;
    CERT_EXTENSIONS *pExtInfo = NULL;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pRequest = (CERT_REQUEST_INFO const *) pbDecoded;

    cuDumpVersion(pRequest->dwVersion + 1);

    hr = cuDisplayCertName(
		    TRUE,
		    NULL,
		    myLoadResourceString(IDS_SUBJECT), // "Subject"
		    g_wszPad4,
		    &pRequest->Subject);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    wprintf(wszNewLine);
    cuDumpPublicKey(&pRequest->SubjectPublicKeyInfo);

    wprintf(myLoadResourceString(IDS_REQUEST_ATTRIBUTES)); // "Request Attributes:"
    wprintf(L" %u\n", pRequest->cAttribute);

    // Dump attributes and certificate extensions

    hr = DumpAttributes(
		    pRequest->rgAttribute,
		    pRequest->cAttribute,
		    FALSE,
		    FOT_ATTRIBUTE,
		    NULL,	// hStore
		    NULL,
		    NULL,
		    &pExtInfo);
    _JumpIfError(hr, error, "DumpAttributes");

    DumpSignature(pcsci);

    if (NULL != pcsci)
    {
	hr = cuVerifySignature(
			pbIn,
			cbIn,
			&pRequest->SubjectPublicKeyInfo,
			FALSE);
	_JumpIfError(hr, error, "cuVerifySignature");
    }

    hr = cuDisplayKeyId(
		    &pRequest->SubjectPublicKeyInfo,
		    NULL == pExtInfo? 0 : pExtInfo->cExtension,
		    NULL == pExtInfo? NULL : pExtInfo->rgExtension);
    _JumpIfError(hr, error, "cuDisplayKeyId");

    hr = S_OK;

error:
    if (NULL != pExtInfo)
    {
	LocalFree(pExtInfo);
    }
    return(hr);
}


VOID
DumpCMCDataReference(
    IN DWORD dwCmcDataReference,
    IN DWORD cCertReference,
    IN DWORD const *rgdwCertReference)
{
    DWORD i;

    wprintf(
	L"    %ws: %u\n",
	myLoadResourceString(IDS_DATA_REFERENCE),
	dwCmcDataReference);

    for (i = 0; i < cCertReference; i++)
    {
	wprintf(
	    L"    %ws[%u]: %u\n",
	    myLoadResourceString(IDS_CERT_REFERENCE),
	    i,
	    rgdwCertReference[i]);
    }
}


HRESULT
DumpCMCStatus(
    IN CMC_STATUS_INFO const *pcmcStatus)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD i;

    switch (pcmcStatus->dwStatus)
    {
	case CMC_STATUS_SUCCESS:
	    pwsz = L"CMC_STATUS_SUCCESS";
	    break;

	case CMC_STATUS_FAILED:
	    pwsz = L"CMC_STATUS_FAILED";
	    break;

	case CMC_STATUS_PENDING:
	    pwsz = L"CMC_STATUS_PENDING";
	    break;

	case CMC_STATUS_NO_SUPPORT:
	    pwsz = L"CMC_STATUS_NO_SUPPORT";
	    break;

	case CMC_STATUS_CONFIRM_REQUIRED:
	    pwsz = L"CMC_STATUS_CONFIRM_REQUIRED";
	    break;

	default:
	    pwsz = g_wszEmpty;
	    break;
    }
    wprintf(
	L"    %ws: %ws(%u)\n",
	myLoadResourceString(IDS_CMC_STATUS),
	pwsz,
	pcmcStatus->dwStatus);

    for (i = 0; i < pcmcStatus->cBodyList; i++)
    {
	wprintf(
	    L"    %ws[%u]: %u\n",
	    myLoadResourceString(IDS_BODY_REFERENCE),
	    i,
	    pcmcStatus->rgdwBodyList[i]);
    }
    if (NULL != pcmcStatus->pwszStatusString)
    {
	wprintf(
	    L"    %ws: %ws\n",
	    myLoadResourceString(IDS_CMC_STATUSSTRING),
	    pcmcStatus->pwszStatusString);
    }
    switch (pcmcStatus->dwOtherInfoChoice)
    {
	case CMC_OTHER_INFO_NO_CHOICE:
	    pwsz = L"CMC_OTHER_INFO_NO_CHOICE";
	    break;

	case CMC_OTHER_INFO_FAIL_CHOICE:
	    pwsz = L"CMC_OTHER_INFO_FAIL_CHOICE";
	    break;

	case CMC_OTHER_INFO_PEND_CHOICE:
	    pwsz = L"CMC_OTHER_INFO_PEND_CHOICE";
	    break;

	default:
	    pwsz = g_wszEmpty;
	    break;
    }
    wprintf(
	L"    %ws: %ws(%u)\n",
	myLoadResourceString(IDS_CMC_OTHERCHOICE),
	pwsz,
	pcmcStatus->dwOtherInfoChoice);

    switch (pcmcStatus->dwOtherInfoChoice)
    {
	case CMC_OTHER_INFO_FAIL_CHOICE:
	    switch (pcmcStatus->dwFailInfo)
	    {
		case CMC_FAIL_BAD_ALG:
		    pwsz = L"CMC_FAIL_BAD_ALG";
		    break;

		case CMC_FAIL_BAD_MESSAGE_CHECK:
		    pwsz = L"CMC_FAIL_BAD_MESSAGE_CHECK";
		    break;

		case CMC_FAIL_BAD_REQUEST:
		    pwsz = L"CMC_FAIL_BAD_REQUEST";
		    break;

		case CMC_FAIL_BAD_TIME:
		    pwsz = L"CMC_FAIL_BAD_TIME";
		    break;

		case CMC_FAIL_BAD_CERT_ID:
		    pwsz = L"CMC_FAIL_BAD_CERT_ID";
		    break;

		case CMC_FAIL_UNSUPORTED_EXT:
		    pwsz = L"CMC_FAIL_UNSUPORTED_EXT";
		    break;

		case CMC_FAIL_MUST_ARCHIVE_KEYS:
		    pwsz = L"CMC_FAIL_MUST_ARCHIVE_KEYS";
		    break;

		case CMC_FAIL_BAD_IDENTITY:
		    pwsz = L"CMC_FAIL_BAD_IDENTITY";
		    break;

		case CMC_FAIL_POP_REQUIRED:
		    pwsz = L"CMC_FAIL_POP_REQUIRED";
		    break;

		case CMC_FAIL_POP_FAILED:
		    pwsz = L"CMC_FAIL_POP_FAILED";
		    break;

		case CMC_FAIL_NO_KEY_REUSE:
		    pwsz = L"CMC_FAIL_NO_KEY_REUSE";
		    break;

		case CMC_FAIL_INTERNAL_CA_ERROR:
		    pwsz = L"CMC_FAIL_INTERNAL_CA_ERROR";
		    break;

		case CMC_FAIL_TRY_LATER:
		    pwsz = L"CMC_FAIL_TRY_LATER";
		    break;

		default:
		    pwsz = g_wszEmpty;
		    break;
	    }
	    wprintf(
		L"    %ws: %ws(%u)\n",
		myLoadResourceString(IDS_CMC_FAILINFO),
		pwsz,
		pcmcStatus->dwFailInfo);
	    break;

	case CMC_OTHER_INFO_PEND_CHOICE:

	    wprintf(myLoadResourceString(IDS_PENDTOKEN)); //"Pend Token:"
	    DumpHex(
		DH_NOTABPREFIX | 4,
		pcmcStatus->pPendInfo->PendToken.pbData,
		pcmcStatus->pPendInfo->PendToken.cbData);

	    wprintf(g_wszPad4);
	    hr = cuDumpFileTime(
			IDS_PENDTIME,
			NULL,
			&pcmcStatus->pPendInfo->PendTime);
	    _JumpIfError(hr, error, "cuDumpFileTime");

	    break;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpCMCRegInfo(
    IN BYTE const *pbData,
    IN DWORD cbData)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszBuf;
    WCHAR const *pwszName;
    WCHAR const *pwszValue;
    WCHAR *pwszNameAlloc = NULL;
    WCHAR *pwszValueAlloc = NULL;

    if (NULL == pbData || 0 == cbData)
    {
	hr = S_OK;
        goto error;		// silently ignore empty string
    }

    hr = myDecodeCMCRegInfo(pbData, cbData, &pwszDup);
    _JumpIfError(hr, error, "myDecodeCMCRegInfo");

    if (NULL != pwszDup)
    {
	pwszBuf = pwszDup;

	while (TRUE)
	{
	    hr = myParseNextAttribute(&pwszBuf, TRUE, &pwszName, &pwszValue);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfError(hr, error, "myParseNextAttribute");

	    if (NULL != pwszNameAlloc)
	    {
		LocalFree(pwszNameAlloc);
		pwszNameAlloc = NULL;
	    }
	    if (NULL != pwszValueAlloc)
	    {
		LocalFree(pwszValueAlloc);
		pwszValueAlloc = NULL;
	    }
	    hr = myUncanonicalizeURLParm(pwszName, &pwszNameAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    hr = myUncanonicalizeURLParm(pwszValue, &pwszValueAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    wprintf(L"%ws%ws: %ws\n", g_wszPad4, pwszNameAlloc, pwszValueAlloc);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszNameAlloc)
    {
	LocalFree(pwszNameAlloc);
    }
    if (NULL != pwszValueAlloc)
    {
	LocalFree(pwszValueAlloc);
    }
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
DumpTaggedAttributes(
    IN DWORD cTaggedAttribute,
    IN CMC_TAGGED_ATTRIBUTE const *rgTaggedAttribute)
{
    HRESULT hr;
    DWORD i;
    DWORD cb;
    CMC_ADD_EXTENSIONS_INFO *pcmcExt = NULL;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    CMC_STATUS_INFO *pcmcStatus = NULL;

    wprintf(myLoadResourceString(IDS_TAGGED_ATTRIBUTES)); //"Tagged Attributes:"
    wprintf(L" %u\n", cTaggedAttribute);
    wprintf(wszNewLine);

    for (i = 0; i < cTaggedAttribute; i++)
    {
	CMC_TAGGED_ATTRIBUTE const *pTaggedAttribute = &rgTaggedAttribute[i];
	CRYPT_ATTRIBUTE const *pAttribute = &pTaggedAttribute->Attribute;
	DWORD j;

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_BODY_PART_ID)); // "Body Part Id:"
	wprintf(L" %u\n", pTaggedAttribute->dwBodyPartID);

	wprintf(g_wszPad2);
	cuDumpOIDAndDescriptionA(pAttribute->pszObjId);
	wprintf(wszNewLine);

	for (j = 0; j < pAttribute->cValue; j++)
	{
	    BOOL fUnknown = FALSE;

	    wprintf(L"  %ws[%u]:\n", myLoadResourceString(IDS_VALUE), j);

	    if (0 == strcmp(szOID_CMC_ADD_EXTENSIONS, pAttribute->pszObjId))
	    {
		// Decode CMC_ADD_EXTENSIONS_INFO from Attribute Blob

		CSASSERT(NULL == pcmcExt);
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				CMC_ADD_EXTENSIONS,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcmcExt,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		DumpCMCDataReference(
				pcmcExt->dwCmcDataReference,
				pcmcExt->cCertReference,
				pcmcExt->rgdwCertReference);

		wprintf(g_wszPad2);
		hr = cuDumpExtensionArray(
				IDS_EXTENSIONS,
				pcmcExt->cExtension,
				pcmcExt->rgExtension);
		_JumpIfError(hr, error, "cuDumpExtensionArray");

		LocalFree(pcmcExt);
		pcmcExt = NULL;
	    }
	    else
	    if (0 == strcmp(szOID_CMC_ADD_ATTRIBUTES, pAttribute->pszObjId))
	    {
		// Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

		CSASSERT(NULL == pcmcAttrib);
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				CMC_ADD_ATTRIBUTES,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcmcAttrib,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		DumpCMCDataReference(
				pcmcAttrib->dwCmcDataReference,
				pcmcAttrib->cCertReference,
				pcmcAttrib->rgdwCertReference);

		hr = DumpAttributes(
			    pcmcAttrib->rgAttribute,
			    pcmcAttrib->cAttribute,
			    FALSE,
			    FOT_ATTRIBUTE,
			    NULL,	// hStore
			    NULL,
			    NULL,
			    NULL);
		_JumpIfError(hr, error, "DumpAttributes");

		wprintf(wszNewLine);
		LocalFree(pcmcAttrib);
		pcmcAttrib = NULL;
	    }
	    else
	    if (0 == strcmp(szOID_CMC_STATUS_INFO, pAttribute->pszObjId))
	    {
		// Decode CMC_STATUS_INFO from Attribute Blob

		CSASSERT(NULL == pcmcStatus);
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				CMC_STATUS,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcmcStatus,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}

		hr = DumpCMCStatus(pcmcStatus);
		_JumpIfError(hr, error, "DumpStatus");

		wprintf(wszNewLine);
		LocalFree(pcmcStatus);
		pcmcStatus = NULL;
	    }
	    else
	    if (0 == strcmp(szOID_CMC_TRANSACTION_ID, pAttribute->pszObjId))
	    {
		DWORD XactId;

		cb = sizeof(XactId);
		XactId = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pAttribute->rgValue[j].pbData,
				    pAttribute->rgValue[j].cbData,
				    0,
				    &XactId,
				    &cb))
		{
		    wprintf(
			L"%ws%x(%u)\n\n",
			g_wszPad4,
			XactId,
			XactId);
		}
		else
		{
		    fUnknown = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(szOID_CMC_REG_INFO, pAttribute->pszObjId))
	    {
		hr = DumpCMCRegInfo(
			    pAttribute->rgValue[j].pbData,
			    pAttribute->rgValue[j].cbData);
		if (S_OK != hr)
		{
		    fUnknown = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(szOID_CMC_QUERY_PENDING, pAttribute->pszObjId) ||
		0 == strcmp(szOID_CMC_SENDER_NONCE, pAttribute->pszObjId) ||
		0 == strcmp(szOID_CMC_RECIPIENT_NONCE, pAttribute->pszObjId))
	    {
		CRYPT_DATA_BLOB *pBlob;
		DWORD cbBlob;

		if (myDecodeObject(
				X509_ASN_ENCODING,
				X509_OCTET_STRING,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pBlob,
				&cbBlob))
		{
		    DumpHex(
			DH_NOTABPREFIX | 4,
			pBlob->pbData,
			pBlob->cbData);
		    wprintf(wszNewLine);
		    LocalFree(pBlob);
		}
		else
		{
		    fUnknown = TRUE;
		}
	    }
	    else
	    {
		fUnknown = TRUE;
	    }
	    if (fUnknown)
	    {
		wprintf(myLoadResourceString(IDS_UNKNOWN_TAGGED_ATTRIBUTE)); // "UNKNOWN Tagged Attribute"
		wprintf(wszNewLine);
		DumpHex(
		    DH_NOTABPREFIX | 4,
		    pAttribute->rgValue[j].pbData,
		    pAttribute->rgValue[j].cbData);
		wprintf(wszNewLine);
	    }
	}
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    if (NULL != pcmcExt)
    {
	LocalFree(pcmcExt);
    }
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    if (NULL != pcmcStatus)
    {
	LocalFree(pcmcStatus);
    }
    return(hr);
}


HRESULT
DumpTaggedRequests(
    IN DWORD cTaggedRequest,
    IN CMC_TAGGED_REQUEST const *rgTaggedRequest)
{
    HRESULT hr;
    DWORD i;

    wprintf(myLoadResourceString(IDS_TAGGED_REQUESTS)); // "Tagged Requests:"
    wprintf(L" %u\n", cTaggedRequest);

    for (i = 0; i < cTaggedRequest; i++)
    {
	CMC_TAGGED_REQUEST const *pTaggedRequest = &rgTaggedRequest[i];
	CMC_TAGGED_CERT_REQUEST const *pTaggedCertRequest;

	switch (pTaggedRequest->dwTaggedRequestChoice)
	{
	    case CMC_TAGGED_CERT_REQUEST_CHOICE:
		pTaggedCertRequest = pTaggedRequest->pTaggedCertRequest;
		wprintf(L"  CMC_TAGGED_CERT_REQUEST_CHOICE:\n");
		wprintf(g_wszPad2);
		wprintf(myLoadResourceString(IDS_BODY_PART_ID)); // "Body Part Id:"
		wprintf(L" %u\n", pTaggedCertRequest->dwBodyPartID);

		hr = cuDumpAsnBinary(
			    pTaggedCertRequest->SignedCertRequest.pbData,
			    pTaggedCertRequest->SignedCertRequest.cbData,
			    i);
		_JumpIfError(hr, error, "cuDumpAsnBinary");
		break;

	    default:
		wprintf(myLoadResourceString(IDS_UNKNOWN_REQUEST_CHOICE)); // "UNKNOWN Request Choice"
		wprintf(wszNewLine);
		break;
	}
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpTaggedContent(
    IN DWORD cTaggedContentInfo,
    IN CMC_TAGGED_CONTENT_INFO const *rgTaggedContentInfo)
{
    HRESULT hr;
    DWORD i;

    wprintf(myLoadResourceString(IDS_TAGGED_CONTENTINFO)); // "Tagged Content Info:"
    wprintf(L" %u\n", cTaggedContentInfo);

    for (i = 0; i < cTaggedContentInfo; i++)
    {
	CMC_TAGGED_CONTENT_INFO const *pTaggedContentInfo = &rgTaggedContentInfo[i];

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_BODY_PART_ID)); // "Body Part Id:"
	wprintf(L" %u\n", pTaggedContentInfo->dwBodyPartID);

	hr = cuDumpAsnBinary(
		    pTaggedContentInfo->EncodedContentInfo.pbData,
		    pTaggedContentInfo->EncodedContentInfo.cbData,
		    i);
	_JumpIfError(hr, error, "cuDumpAsnBinary");
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpTaggedOther(
    IN DWORD cTaggedOtherMsg,
    IN CMC_TAGGED_OTHER_MSG const *rgTaggedOtherMsg)
{
    HRESULT hr;
    DWORD i;

    wprintf(myLoadResourceString(IDS_TAGGED_OTHERMESSAGES)); // "Tagged Other Messages:"
    wprintf(L" %u\n", cTaggedOtherMsg);

    for (i = 0; i < cTaggedOtherMsg; i++)
    {
	CMC_TAGGED_OTHER_MSG const *pTaggedOtherMsg = &rgTaggedOtherMsg[i];

	wprintf(L"  TaggedOtherMessage[%u]\n", i);
	wprintf(g_wszPad2);
	cuDumpOIDAndDescriptionA(pTaggedOtherMsg->pszObjId);

	wprintf(L"  %ws[%u]:\n", myLoadResourceString(IDS_VALUE), i);
	DumpHex(
	    DH_NOADDRESS | DH_NOTABPREFIX | 4,
	    pTaggedOtherMsg->Value.pbData,
	    pTaggedOtherMsg->Value.cbData);
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
dumpCMCRequest(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CMC_DATA_INFO const *pcmcData;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pcmcData = (CMC_DATA_INFO const *) pbDecoded;

    hr = DumpTaggedAttributes(
			pcmcData->cTaggedAttribute,
			pcmcData->rgTaggedAttribute);
    _JumpIfError(hr, error, "DumpTaggedAttributes");

    hr = DumpTaggedRequests(
			pcmcData->cTaggedRequest,
			pcmcData->rgTaggedRequest);
    _JumpIfError(hr, error, "DumpTaggedRequests");

    hr = DumpTaggedContent(
			pcmcData->cTaggedContentInfo,
			pcmcData->rgTaggedContentInfo);
    _JumpIfError(hr, error, "DumpTaggedContent");

    hr = DumpTaggedOther(
			pcmcData->cTaggedOtherMsg,
			pcmcData->rgTaggedOtherMsg);
    _JumpIfError(hr, error, "DumpTaggedOther");

error:
    return(hr);
}


HRESULT
dumpCMCResponse(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CMC_RESPONSE_INFO const *pcmcResponse;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pcmcResponse = (CMC_RESPONSE_INFO const *) pbDecoded;

    hr = DumpTaggedAttributes(
			pcmcResponse->cTaggedAttribute,
			pcmcResponse->rgTaggedAttribute);
    _JumpIfError(hr, error, "DumpTaggedAttributes");

    hr = DumpTaggedContent(
			pcmcResponse->cTaggedContentInfo,
			pcmcResponse->rgTaggedContentInfo);
    _JumpIfError(hr, error, "DumpTaggedContent");

    hr = DumpTaggedOther(
			pcmcResponse->cTaggedOtherMsg,
			pcmcResponse->rgTaggedOtherMsg);
    _JumpIfError(hr, error, "DumpTaggedOther");

error:
    return(hr);
}


HRESULT
dumpKeyGenRequest(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CERT_KEYGEN_REQUEST_INFO const *pKeyGenRequest;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pKeyGenRequest = (CERT_KEYGEN_REQUEST_INFO const *) pbDecoded;

    cuDumpPublicKey(&pKeyGenRequest->SubjectPublicKeyInfo);

    wprintf(
	myLoadResourceString(IDS_FORMAT_CHALLENGE_STRING), // "ChallengeString: ""%ws"""
	pKeyGenRequest->pwszChallengeString);
    wprintf(wszNewLine);

    DumpSignature(pcsci);

    hr = cuVerifySignature(
		    pbIn,
		    cbIn,
		    &pKeyGenRequest->SubjectPublicKeyInfo,
		    FALSE);
    _JumpIfError(hr, error, "cuVerifySignature");

    hr = S_OK;

error:
    return(hr);
}


HRESULT
dumpCTL(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CTL_INFO const *pCTLInfo;
    CTL_CONTEXT const *pCTLContext = NULL;
    BOOL fIssuerMatches;
    DWORD id;
    DWORD i;

    pCTLInfo = (CTL_INFO const *) pbDecoded;

    //if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);

	cuDumpVersion(pCTLInfo->dwVersion + 1);
    }
    hr = cuDumpUsage(NULL, IDS_USAGEENTRIES, &pCTLInfo->SubjectUsage);
    _JumpIfError(hr, error, "cuDumpUsage");

    if (0 != pCTLInfo->ListIdentifier.cbData)
    {
	hr = cuDumpSerial(NULL, IDS_LISTID, &pCTLInfo->ListIdentifier);
	_JumpIfError(hr, error, "cuDumpSerial");
    }
    if (0 != pCTLInfo->SequenceNumber.cbData)
    {
	hr = cuDumpSerial(NULL, IDS_SEQUENCENO, &pCTLInfo->SequenceNumber);
	_JumpIfError(hr, error, "cuDumpSerial");
    }

    hr = cuDumpFileTime(IDS_THISUPDATE, NULL, &pCTLInfo->ThisUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    hr = cuDumpFileTime(IDS_NEXTUPDATE, NULL, &pCTLInfo->NextUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    DumpAlgorithm(IDS_SUBJECT_ALGORITHM, &pCTLInfo->SubjectAlgorithm);

    wprintf(myLoadResourceString(IDS_CTLENTRIES)); // "CTL Entries:"
    wprintf(L" %u\n", pCTLInfo->cCTLEntry);

    for (i = 0; i < pCTLInfo->cCTLEntry; i++)
    {
	CTL_ENTRY const *pCTLEntry = &pCTLInfo->rgCTLEntry[i];

	wprintf(wszNewLine);

	hr = DumpHash(
		g_wszEmpty,
		IDS_FORMAT_SUBJECTID_COLON,
		g_wszEmpty,
		pCTLEntry->SubjectIdentifier.pbData,
		pCTLEntry->SubjectIdentifier.cbData);
	_JumpIfError(hr, error, "DumpHash");

	hr = DumpAttributes(
			pCTLEntry->rgAttribute,
			pCTLEntry->cAttribute,
			g_fQuiet,
			FOT_PROPERTY,
			NULL,		// hStore
			NULL,		// pbHashUserCert
			NULL,		// pcbHashUserCert
			NULL);		// ppExtInfo
	_JumpIfError(hr, error, "DumpAttributes");
    }
    hr = cuDumpExtensionArray(
		    IDS_EXTENSIONS,
		    pCTLInfo->cExtension,
		    pCTLInfo->rgExtension);
    _JumpIfError(hr, error, "cuDumpExtensionArray");

    hr = S_OK;

error:
    if (NULL != pCTLContext)
    {
	CertFreeCTLContext(pCTLContext);
    }
    return(hr);
}


HRESULT
verbDump(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfn,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    if (NULL == pwszfn)
    {
	hr = cuConfigDump();
	_JumpIfError(hr, error, "cuConfigDump");
    }
    else
    {
	hr = cuFileDump(pwszfn);
	_JumpIfError(hr, error, "cuFileDump");
    }

error:

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\dbcore.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbcore.h
//
// Contents:    Cert Server Core interfaces
//
//---------------------------------------------------------------------------

#ifndef __DBCORE_H__
#define __DBCORE_H__


//+--------------------------------------------------------------------------
// Name properties:

extern WCHAR const g_wszPropDistinguishedName[];
extern WCHAR const g_wszPropRawName[];
extern WCHAR const g_wszPropNameType[];

extern WCHAR const g_wszPropCountry[];
extern WCHAR const g_wszPropOrganization[];
extern WCHAR const g_wszPropOrgUnit[];
extern WCHAR const g_wszPropCommonName[];
extern WCHAR const g_wszPropLocality[];
extern WCHAR const g_wszPropState[];
extern WCHAR const g_wszPropTitle[];
extern WCHAR const g_wszPropGivenName[];
extern WCHAR const g_wszPropInitials[];
extern WCHAR const g_wszPropSurName[];
extern WCHAR const g_wszPropDomainComponent[];
extern WCHAR const g_wszPropEMail[];
extern WCHAR const g_wszPropStreetAddress[];


//+--------------------------------------------------------------------------
// Subject Name properties:

extern WCHAR const g_wszPropSubjectDot[];
extern WCHAR const g_wszPropSubjectDistinguishedName[];
extern WCHAR const g_wszPropSubjectRawName[];
extern WCHAR const g_wszPropSubjectNameType[];
extern WCHAR const g_wszPropSubjectCountry[];
extern WCHAR const g_wszPropSubjectOrganization[];
extern WCHAR const g_wszPropSubjectOrgUnit[];
extern WCHAR const g_wszPropSubjectCommonName[];
extern WCHAR const g_wszPropSubjectLocality[];
extern WCHAR const g_wszPropSubjectState[];
extern WCHAR const g_wszPropSubjectTitle[];
extern WCHAR const g_wszPropSubjectGivenName[];
extern WCHAR const g_wszPropSubjectInitials[];
extern WCHAR const g_wszPropSubjectSurName[];
extern WCHAR const g_wszPropSubjectDomainComponent[];
extern WCHAR const g_wszPropSubjectEMail[];
//extern WCHAR const g_wszPropSubjectStreetAddress[];


//+--------------------------------------------------------------------------
// Request properties:

extern WCHAR const g_wszPropRequestRequestID[];
extern WCHAR const g_wszPropRequestRawRequest[];
extern WCHAR const g_wszPropRequestAttributes[];
extern WCHAR const g_wszPropRequestType[];
extern WCHAR const g_wszPropRequestFlags[];
extern WCHAR const g_wszPropRequestStatus[];
extern WCHAR const g_wszPropRequestStatusCode[];
extern WCHAR const g_wszPropRequestDisposition[];
extern WCHAR const g_wszPropRequestDispositionMessage[];
extern WCHAR const g_wszPropRequestSubmittedWhen[];
extern WCHAR const g_wszPropRequestResolvedWhen[];
extern WCHAR const g_wszPropRequestRevokedWhen[];
extern WCHAR const g_wszPropRequestRevokedEffectiveWhen[];
extern WCHAR const g_wszPropRequestRevokedReason[];
extern WCHAR const g_wszPropRequestSubjectNameID[];
extern WCHAR const g_wszPropRequesterName[];
extern WCHAR const g_wszPropRequesterAddress[];


//+--------------------------------------------------------------------------
// Certificate properties:

extern WCHAR const g_wszPropCertificateRequestID[];
extern WCHAR const g_wszPropRawCertificate[];
extern WCHAR const g_wszPropCertificateType[];
extern WCHAR const g_wszPropCertificateSerialNumber[];
extern WCHAR const g_wszPropCertificateIssuerNameID[];
extern WCHAR const g_wszPropCertificateSubjectNameID[];
extern WCHAR const g_wszPropCertificateNotBeforeDate[];
extern WCHAR const g_wszPropCertificateNotAfterDate[];
extern WCHAR const g_wszPropCertificateRawPublicKey[];
extern WCHAR const g_wszPropCertificatePublicKeyAlgorithm[];
extern WCHAR const g_wszPropCertificateRawPublicKeyAlgorithmParameters[];

#endif // __DBCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\odbc.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        odbc.h
//
// Contents:    Cert Server DB includes
//
// History:     06-JAN-97       larrys created
//
//---------------------------------------------------------------------------

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>

typedef DWORD     REQID;
typedef DWORD     NAMEID;
typedef DWORD     STATUS;

typedef struct _DBTABLE_RED
{
    WCHAR const *pwszPropName;
    WCHAR const *pwszPropNameObjId;
    DWORD        dwFlags;
    DWORD        dwcbMax;	// maximum allowed strlen/wcslen(value string)
    DWORD        dwTable;
    WCHAR const *pwszFieldName;
    SWORD        wCType;
    SWORD        wSqlType;
} DBTABLE_RED, *PDBTABLE_RED;

/////

typedef struct _DUPTABLE
{
    CHAR const  *pszFieldName;
    BOOL         fDup;
    SWORD        wCType;
    SWORD        wSqlType;
    WCHAR const *pwszPropName;
} DUPTABLE;

#define TABLE_SUBJECT_NAME      105
#define TABLE_ISSUER_NAME       106
#define TABLE_REQUESTSUBJECT_NAME 107

#define ADD_TO_ITEMSCLEAN       1
#define ADD_TO_ITEMSDIRTY       2

RETCODE MapPropID(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    OUT DBTABLE_RED *pdtout);

STATUS DBStatus(RETCODE rc);

void DBCheck(
#if DBG_CERTSRV
    DWORD Line,
#endif
    DWORD hr,
    void * extra);

STATUS odbcInitRequestQueue(
    UCHAR   *dsn,
    UCHAR   *user,
    UCHAR   *pwd);
void odbcFinishRequestQueue();


RETCODE odbcSPExtensionOrAttributeDB(DWORD id, DBTABLE_RED *pdtOut, UCHAR *pquery,
                                     DWORD cbInProp, BYTE const *pbInProp);

RETCODE odbcGPDataFromDB(REQID ReqId, DWORD dwTable, SWORD wCType,
                         BYTE *pbData, DWORD cbData, UCHAR *szQuery,
                         NAMEID *pnameid, SQLLEN  *poutlen);

STATUS DBStatus(RETCODE rc);

VOID
DBCheck(
    RETCODE rc
    DBGPARM(char const *pszFile)
    DBGPARM(DWORD Line),
    HSTMT hstmt);

#define ITEMINSERT(l,i) (i).itemPrev = &(l),                        \
                        (i).itemNext = (l).itemNext,                \
                        (l).itemNext = (i).itemNext->itemPrev = &(i)
#define ITEMREMOVE(i)   (i).itemNext->itemPrev = (i).itemPrev,      \
                        (i).itemPrev->itemNext = (i).itemNext

#define CDNTRTABLE (sizeof(db_dntr) / sizeof(db_dntr[0]))


#define DBCHECKLINE(rc, hstmt) \
    DBCheck((rc) DBGPARM(__myFILE__) DBGPARM(__LINE__), (hstmt))

HRESULT odbcDBEnumSetup(REQID ReqId, DWORD fExtOrAttr, HANDLE *phEnum);
HRESULT odbcDBEnum(HANDLE hEnum, DWORD *pcb, WCHAR *pb);
HRESULT odbcDBEnumClose(HANDLE hEnum);
//DWORD odbcDBGetReqIdFromSerialNumber(char *pszSerialNumber, DWORD *ReqId);






extern DBTABLE_RED const db_adtRequests[];
extern DBTABLE_RED const db_adtCertificates[];
extern DBTABLE_RED const db_adtNames[];
extern DBTABLE_RED const db_dtExtensionFlags;
extern DBTABLE_RED const db_dtExtensionValue;
extern DBTABLE_RED const db_attrib;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\info.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       info.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


#include <certca.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmapibuf.h>


#define DC_DELBAD	0x00000001
#define DC_DELALL	0x00000002
#define DC_VERIFY	0x00000004

// If you invoke DSSTORE with DC=mydc,DC=rd,DC=com  DSSTORE calls
// DsGetDcName(NULL, L"mydc", NULL, NULL, DS_RETURN_DNS_NAME, &pDCInfo);
//
// I suspect changing the code to pass L"mydc.rd.com" instead of L"mydc" would
// solve the problem.  I will look into this for the port of the code to
// certutil.exe.
//
// -----Original Message-----
// From: Christophe Lapeyre (Intl Vendor)
// Sent: Tuesday, January 09, 2001 3:30 AM
// To: Certificate Server Discussion Alias
// Subject: DSSTORE error 1355 (DsGetDCName failed)
//
//
// Hi all,
//
// I encountered the following problem with the DSSTORE tool:
//
// DSSTORE DC=mydc,DC=rd,DC=com -display
// DsGetDCName failed! - rc=1355 GLE - 3e5
// DsGetDCName failed! - rc=1355 GLE - 3e5
//
// Nltest /dsgetdc:mydc.rd.com just run ok.
//
// My Netbios domain name is different from my DNS domain name.
//
//
//
// There is a preview Kb article numbered Q280122, but I haven't been able to
// find a fix for this.




HRESULT
ExtractCertSubject(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwType,
    IN DWORD dwFlags,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcBuf;
    WCHAR *pwszOut = NULL;

    *ppwszOut = NULL;
    cwcBuf = 0;
    while (TRUE)
    {
	cwc = CertGetNameString(
			pcc,
			dwType,
			dwFlags,
			NULL,		// pvTypePara
			pwszOut,
			cwcBuf);
	if (1 == cwc)
	{
	    hr = CRYPT_E_NOT_FOUND;
	    _JumpError(hr, error, "CertGetNameString");
	}
	if (NULL != pwszOut)
	{
	    break;
	}
	pwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	cwcBuf = cwc;
    }
    *ppwszOut = pwszOut;
    pwszOut = NULL;
    hr = S_OK;

error:
    if (NULL != pwszOut)
    {
	LocalFree(pwszOut);
    }
    return(hr);
}


HRESULT
myCertGetEnhancedKeyUsage(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwFlags,
    OUT CERT_ENHKEY_USAGE **ppUsage,
    OUT DWORD *pcbUsage)
{
    HRESULT hr;
    CERT_ENHKEY_USAGE *pUsage = NULL;
    DWORD cb;

    *ppUsage = NULL;

    while (TRUE)
    {
	if (!CertGetEnhancedKeyUsage(pcc, dwFlags, pUsage, &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetEnhancedKeyUsage");
	}
	if (NULL != pUsage)
	{
	    *pcbUsage = cb;
	    *ppUsage = pUsage;
	    pUsage = NULL;
	    break;
	}
	pUsage = (CERT_ENHKEY_USAGE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pUsage)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    if (NULL != pUsage)
    {
	LocalFree(pUsage);
    }
    return(hr);
}


HRESULT
CheckForKDCCertificate(
    IN WCHAR const *pwszDC,
    IN DWORD dwFlags)
{
    HRESULT hr;
    HCERTSTORE hStoreRemote = NULL;
    WCHAR wszStorePath[512];
    WCHAR *apwszCertType[2] = { NULL, NULL };
    DWORD cCert = 0;
    DWORD dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    CERT_CONTEXT const *pcc = NULL;
    CERT_CONTEXT const *pccPrev = NULL;
    BOOL fDelete;
    BOOL fNewLine;
    DWORD i;
    DWORD j;
    CERT_ENHKEY_USAGE *pUsage = NULL;
    DWORD cbUsage;
    static WCHAR *s_apwszKDCTemplates[] = {
	wszCERTTYPE_DC_AUTH,
	wszCERTTYPE_DS_EMAIL_REPLICATION,
	wszCERTTYPE_DC,
    };

    // If not doing delete operations, open "ReadOnly"

    if (0 == ((DC_DELALL | DC_DELBAD) & dwFlags))
    {
        dwOpenFlags |= CERT_STORE_READONLY_FLAG;
    }

    swprintf(wszStorePath, L"\\\\%ws\\" wszMY_CERTSTORE, pwszDC);
    hStoreRemote = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM_W,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    NULL,
			    dwOpenFlags,
			    (VOID *) wszStorePath);
    if (NULL == hStoreRemote)
    {
        hr = myHLastError();
        _JumpError2(hr, error, "CertOpenStore", E_ACCESSDENIED);
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_KDCCERTS), // "** KDC Certificates for DC %ws"
	pwszDC);
    wprintf(wszNewLine);


    // Look for KDC certs

    fNewLine = FALSE;
    while (TRUE)
    {
        BOOL fKDCCert;

	for (i = 0; i < ARRAYSIZE(apwszCertType); i++)
	{
	    if (NULL != apwszCertType[i])
	    {
		LocalFree(apwszCertType[i]);
		apwszCertType[i] = NULL;
	    }
	}

	pcc = CertEnumCertificatesInStore(hStoreRemote, pccPrev);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CertEnumCertificatesInStore", CRYPT_E_NOT_FOUND);
	    break;
	}
        pccPrev = pcc;

        fKDCCert = FALSE;
	hr = cuGetCertType(
		    pcc->pCertInfo,
		    &apwszCertType[0],	// ppwszCertTypeNameV1
		    NULL,		// ppwszDisplayNameV1
		    NULL,		// ppwszCertTypeObjId
		    &apwszCertType[1],	// ppwszCertTypeName
		    NULL);		// ppwszDisplayName
	if (S_OK != hr)
	{
	    _PrintError(hr, "cuGetCertType");
	}
	else
	{
	    for (i = 0; i < ARRAYSIZE(apwszCertType); i++)
	    {
		if (NULL != apwszCertType[i])
		{
		    for (j = 0; j < ARRAYSIZE(s_apwszKDCTemplates); j++)
		    {
			if (0 == lstrcmpi(
				    apwszCertType[i],
				    s_apwszKDCTemplates[j]))
			{
			    fKDCCert = TRUE;
			}
		    }
		}
	    }
	}
	if (!fKDCCert)
	{
	    WCHAR const *pwsz = apwszCertType[0];
	    
	    if (NULL == apwszCertType[0])
	    {
		pwsz = apwszCertType[1];
	    }
	    if (g_fVerbose)
	    {
		    wprintf(myLoadResourceString(IDS_FORMAT_CERT_TYPE_NOT_DC), pwsz);
		    wprintf(wszNewLine);
	    }
	}

        fKDCCert = FALSE;
	hr = myCertGetEnhancedKeyUsage(
				pcc,
				CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
				&pUsage,
				&cbUsage);
	if (S_OK != hr)
	{
	    _PrintError(hr, "myCertGetEnhancedKeyUsage");
	}
	else
	{
	    for (i = 0; i < pUsage->cUsageIdentifier; i++)
	    {
		if (0 == strcmp(
			    szOID_KP_SMARTCARD_LOGON,
			    pUsage->rgpszUsageIdentifier[i]))
		{
		    fKDCCert = TRUE;
		    break;
		}
	    }
	}
	if (!fKDCCert)
	{
	    if (g_fVerbose)
	    {
		    wprintf(myLoadResourceString(IDS_FORMAT_CERT_USAGE_MISSING), L"szOID_KP_SMARTCARD_LOGON");
		    wprintf(wszNewLine);
	    }
	    if (!g_fForce || fDelete)
	    {
		continue;
	    }
	}

        // Cert passed test, dump issuer and subject

	hr = cuDumpSerial(g_wszPad2, IDS_SERIAL, &pcc->pCertInfo->SerialNumber);
	_PrintIfError(hr, "cuDumpSerial");

	hr = cuDisplayCertNames(FALSE, g_wszPad2, pcc->pCertInfo);
	_PrintIfError(hr, "cuDisplayCertNames");

	hr = cuDumpCertType(g_wszPad2, pcc->pCertInfo);
	_PrintIfError(hr, "cuDumpCertType");

	wprintf(wszNewLine);

        cCert++;

        // perform operations on certificatess

	fDelete = 0 != (DC_DELALL & dwFlags);
        if ((DC_VERIFY | DC_DELBAD) & dwFlags)
	{
	    char *apszUsage[] =
	    {
		szOID_PKIX_KP_SERVER_AUTH,
		szOID_KP_SMARTCARD_LOGON,
	    };
	    DWORD VerifyState;

	    hr = cuVerifyCertContext(
				pcc,
				NULL,
				apszUsage,		// apszPolicies
				ARRAYSIZE(apszUsage),	// cPolicies
				&VerifyState);
	    if (S_OK != hr)
	    {
		_PrintError(hr, "cuVerifyCertContext");
		if (CRYPT_E_REVOCATION_OFFLINE != hr)
		{
		    fDelete = 0 != (DC_DELBAD & dwFlags);
		}
	    }
        }
	if (fDelete)
	{
            CERT_CONTEXT const *pccDel;

            pccDel = CertDuplicateCertificateContext(pcc);
            if (!CertDeleteCertificateFromStore(pccDel))
	    {
                hr = myHLastError();
                wprintf(myLoadResourceString(IDS_FORMAT_DELETE_CERT_FROM_STORE_FAILED), hr);
		        wprintf(wszNewLine);
            }
	    else
	    {
                wprintf(myLoadResourceString(IDS_FORMAT_DELETE_DC_CERT));
		        wprintf(wszNewLine);
            }
        }
    }

    swprintf(wszStorePath, myLoadResourceString(IDS_FORMAT_KDC_PATH), cCert, pwszDC);
    wprintf(wszStorePath);
    wprintf(wszNewLine);
    if (0 == cCert)
    {
        wprintf(myLoadResourceString(IDS_NO_KDC_MY_STORE));
	wprintf(wszNewLine);
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "cCert");
    }
    hr = S_OK;

error:
    if (NULL != pUsage)
    {
	LocalFree(pUsage);
    }
    for (i = 0; i < ARRAYSIZE(apwszCertType); i++)
    {
	if (NULL != apwszCertType[i])
	{
	    LocalFree(apwszCertType[i]);
	}
    }
    if (NULL != hStoreRemote)
    {
        CertCloseStore(hStoreRemote, 0);
    }
    return(hr);
}


// This function queries the access token specified by the hToken parameter,
// and returns an allocated copy of the TokenUser information on success.
//
// The access token specified by hToken must be opened for TOKEN_QUERY access.
//
// On success, the return value is TRUE.  The caller is responsible for freeing
// the resultant UserSid via LocalFree.
//
// On failure, the caller does not need to free any buffer.

HRESULT
GetTokenUserSid(
    IN HANDLE hToken,		// token to query
    IN OUT PSID *ppUserSid)	// resultant user sid
{
    HRESULT hr;
    BYTE FastBuffer[256];
    BYTE *SlowBuffer = NULL;
    TOKEN_USER *ptgUser;
    DWORD cbBuffer;
    DWORD cbSid;

    *ppUserSid = NULL;

    // try querying based on a fast stack based buffer first.

    ptgUser = (TOKEN_USER *) FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    if (!GetTokenInformation(
			hToken,		// identifies access token
			TokenUser,	// TokenUser info type
			ptgUser,	// retrieved info buffer
			cbBuffer,	// size of buffer passed-in
			&cbBuffer))	// required buffer size
    {
	hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    _JumpError(hr, error, "GetTokenInformation");
	}

	// try again with the specified buffer size

	SlowBuffer = (BYTE *) LocalAlloc(LMEM_FIXED, cbBuffer);
	if (NULL == SlowBuffer)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	ptgUser = (TOKEN_USER *) SlowBuffer;

	if (!GetTokenInformation(
			    hToken,		// identifies access token
			    TokenUser,	// TokenUser info type
			    ptgUser,	// retrieved info buffer
			    cbBuffer,	// size of buffer passed-in
			    &cbBuffer))	// required buffer size
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetTokenInformation");
	}
    }

    // if we got the token info, copy the relevant element for the caller.

    cbSid = GetLengthSid(ptgUser->User.Sid);
    *ppUserSid = LocalAlloc(LMEM_FIXED, cbSid);
    if (NULL == *ppUserSid)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CopySid(cbSid, *ppUserSid, ptgUser->User.Sid))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CopySid");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
        if (NULL != *ppUserSid)
	{
            LocalFree(*ppUserSid);
            *ppUserSid = NULL;
        }
    }
    if (NULL != SlowBuffer)
    {
        LocalFree(SlowBuffer);
    }
    return(hr);
}


// This routine obtains a domain controller computer name associated with
// the account related to the hToken access token.
//
// hToken should be opened for TOKEN_QUERY access.
// pwszDomain should be of size (UNCLEN+1)

HRESULT
GetDomainControllers(
    OPTIONAL IN WCHAR const *pwszDomain,
    IN HANDLE hToken,
    OUT DS_DOMAIN_CONTROLLER_INFO_1 **ppDCInfoOut,
    OUT DWORD *pcDC)
{
    HRESULT hr;
    PSID pSidUser = NULL;   // sid of client user.
    WCHAR wszUserName[UNLEN + 1];
    DWORD cwcUserName;
    WCHAR wszDomainName[DNLEN + 1]; // domain we want a controller for.
    DWORD cwcDomainName;
    SID_NAME_USE snu;
    DOMAIN_CONTROLLER_INFO *pDomainInfo = NULL;
    DS_DOMAIN_CONTROLLER_INFO_1 *pDcInfo = NULL;
    HANDLE hDS = INVALID_HANDLE_VALUE;
    BOOL fSuccess = FALSE;

    *ppDCInfoOut = NULL;
    if (NULL == pwszDomain)
    {
        // first, get the user sid associated with the specified access token.

        hr = GetTokenUserSid(hToken, &pSidUser);
        _JumpIfError(hr, error, "GetTokenUserSid");

        // next, lookup the domain name associated with the specified account.

	cwcUserName = ARRAYSIZE(wszUserName);
	cwcDomainName = ARRAYSIZE(wszDomainName);
        if (!LookupAccountSid(
			NULL,
			pSidUser,
			wszUserName,
			&cwcUserName,
			wszDomainName,
			&cwcDomainName,
			&snu))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "LookupAccountSid");
        }
    }
    else
    {
        wcscpy(wszDomainName, pwszDomain);
    }

    hr = DsGetDcName(
		NULL,
		wszDomainName,
		NULL,
		NULL,
		DS_RETURN_DNS_NAME,
		&pDomainInfo);
    _JumpIfError(hr, error, "DsGetDcName");

    // Get a handle to the DS on that machine

    hr = DsBind(pDomainInfo->DomainControllerName, NULL, &hDS);
    _JumpIfError(hr, error, "DsBind");

    // Use the handle to enumerate all of the DCs

    hr = DsGetDomainControllerInfo(
			    hDS,
			    pDomainInfo->DomainName,
			    1,		// info level
			    pcDC,
			    (VOID **) ppDCInfoOut);
    _JumpIfError(hr, error, "DsGetDomainControllerInfo");

error:
    if (INVALID_HANDLE_VALUE != hDS)
    {
        DsUnBind(&hDS);
    }
    if (NULL != pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);
    }
    if (NULL != pSidUser)
    {
        LocalFree(pSidUser);
    }
    return(hr);
}


HRESULT
OpenRemoteEnterpriseRoot(
    IN WCHAR const *pwszDC)
{
    HRESULT hr;
    HCERTSTORE hStoreRemote = NULL;
    WCHAR wszStorePath[512];
    DWORD cCert = 0;
    CERT_CONTEXT const *pcc = NULL;
    CERT_CONTEXT const *pccPrev;

    swprintf(wszStorePath, L"\\\\%ws\\" wszROOT_CERTSTORE, pwszDC);
    hStoreRemote = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			NULL,
			CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
			    CERT_STORE_READONLY_FLAG,
			(VOID *) wszStorePath);
    if (NULL == hStoreRemote)
    {
        hr = myHLastError();
        _JumpError2(hr, error, "CertOpenStore", E_ACCESSDENIED);
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_DCROOTCERTS), // "** Enterprise Root Certificates for DC %ws"
	pwszDC);
    wprintf(wszNewLine);

    // Dump issuer of enterprise roots.

    pccPrev = NULL;
    while (TRUE)
    {
	pcc = CertEnumCertificatesInStore(hStoreRemote, pccPrev);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CertEnumCertificatesInStore", CRYPT_E_NOT_FOUND);
	    break;
	}

	hr = cuDumpSerial(g_wszPad2, IDS_SERIAL, &pcc->pCertInfo->SerialNumber);
	_PrintIfError(hr, "cuDumpSerial");

	hr = cuDisplayCertNames(FALSE, g_wszPad2, pcc->pCertInfo);
	_PrintIfError(hr, "cuDisplayCertNames");

	hr = cuDumpCertType(g_wszPad2, pcc->pCertInfo);
	_PrintIfError2(hr, "cuDumpCertType", CRYPT_E_NOT_FOUND);

	hr = cuDisplayHash(
		    g_wszPad2,
		    pcc,
		    NULL,
		    CERT_SHA1_HASH_PROP_ID,
		    L"sha1");
	_PrintIfError(hr, "cuDisplayHash");

	wprintf(wszNewLine);
        cCert++;
        pccPrev = pcc;
    }
    if (0 == cCert)
    {
        wprintf(myLoadResourceString(IDS_NO_KDC_ENT_STORE));
	    wprintf(wszNewLine);
	    hr = CRYPT_E_NOT_FOUND;
    }
    hr = S_OK;

error:
    if (NULL != hStoreRemote)
    {
        CertCloseStore(hStoreRemote, 0);
    }
    return(hr);
}


HRESULT
verbDCInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hrSave;
    HANDLE hToken = NULL;
    DS_DOMAIN_CONTROLLER_INFO_1 *pDcInfo = NULL;
    DWORD cDC = 0;
    DWORD dwFlags;
    DWORD i;
    WCHAR *pwszDomain = NULL;

    dwFlags = 0;
    if (NULL != pwszFlags)
    {
	if (0 == lstrcmpi(L"DeleteAll", pwszFlags))
	{
	    dwFlags = DC_DELALL;
	}
	else
	if (0 == lstrcmpi(L"DeleteBad", pwszFlags))
	{
	    dwFlags = DC_DELBAD | DC_VERIFY;
	}
	else
	if (0 == lstrcmpi(L"Verify", pwszFlags))
	{
	    dwFlags = DC_VERIFY;
	}
	else
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad Flags");
	}
    }

    // Grovel the process token for user identity.  Used in determining
    // target domain

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken))
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenProcessToken");
    }

    // Use DS APIs to get all of the DCs in our domain

    hr = GetDomainControllers(pwszDomain, hToken, &pDcInfo, &cDC);
    _JumpIfError(hr, error, "GetDomainControllers");

    for (i = 0; i < cDC; i++)
    {
        wprintf(L"%u: %ws\n", i, pDcInfo[i].NetbiosName);
    }
    hrSave = S_OK;
    for (i = 0; i < cDC; i++)
    {
        WCHAR wszBuffer[512];

	wprintf(wszNewLine);
        wprintf(
	    myLoadResourceString(IDS_FORMAT_TESTINGDC), // "*** Testing DC[%u]: %ws"
	    i,
	    pDcInfo[i].NetbiosName);
	wprintf(wszNewLine);

        // Is DC available ?

        wsprintf(wszBuffer, L"\\\\%ws\\netlogon", pDcInfo[i].NetbiosName);

        if (MAXDWORD == GetFileAttributes(wszBuffer))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "GetFileAttributes", hr);
	    cuPrintError(IDS_DCUNAVAILABLE, hr);
	    if (S_OK == hrSave)
	    {
		hrSave = hr;
	    }
            continue;
        }

        // Open the enterprise root store, and make sure it's got the
        // NTDEV ROOT CERTIFICATE (subject #defined above)

        hr = OpenRemoteEnterpriseRoot(pDcInfo[i].NetbiosName);
	if (S_OK != hr)
	{
	    _PrintError2(hr, "OpenRemoteEnterpriseRoot", hr);
	    cuPrintError(IDS_REMOTEENTROOT, hr);
	    if (S_OK == hrSave)
	    {
		hrSave = hr;
	    }
	}

        // Make sure the machine has a *valid* KDC certificate

        hr = CheckForKDCCertificate(
				pDcInfo[i].NetbiosName,
				dwFlags);
	if (S_OK != hr)
	{
	    _PrintError2(hr, "CheckForKDCCertificate", hr);
	    cuPrintError(IDS_REMOTEKDCCERT, hr);
	    if (S_OK == hrSave)
	    {
		hrSave = hr;
	    }
	}
    }
    wprintf(wszNewLine);
    hr = hrSave;
    _JumpIfError2(hr, error, "verbDCInfo", hr);

error:
    if (NULL != pDcInfo)
    {
       DsFreeDomainControllerInfo(1, cDC, pDcInfo);
    }
    return(hr);
}


//
// Check for autoenrolled certificate
//

HRESULT
CheckForAutoenrolledCertificate(
    IN WCHAR const *pwszDC)
{
    HRESULT hr;
    HCERTSTORE hRemoteStore = NULL;
    WCHAR wszStorePath[512];
    DWORD dwEnrollPropId = CERT_AUTO_ENROLL_PROP_ID;
    DWORD cCert;
    DWORD cCertArchived;
    DWORD dwArchiveBit;
    CERT_CONTEXT const *pcc;

    swprintf(wszStorePath, L"\\\\%ws\\" wszMY_CERTSTORE, pwszDC);

    hRemoteStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			NULL,
			CERT_STORE_READONLY_FLAG |
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_ENUM_ARCHIVED_FLAG,
			(VOID *) wszStorePath);
    if (NULL == hRemoteStore)
    {
        hr = myHLastError();
        wprintf(myLoadResourceString(IDS_FORMAT_OPEN_REMOTE_MY_FAILED), hr);
		wprintf(wszNewLine);
        goto error;
    }

    cCert = 0;
    cCertArchived = 0;
    pcc = NULL;
    while (TRUE)
    {
	pcc = CertFindCertificateInStore(
				    hRemoteStore,
				    X509_ASN_ENCODING,
				    0,
				    CERT_FIND_PROPERTY,
				    &dwEnrollPropId,
				    pcc);
	if (NULL == pcc)
	{
	    break;
	}

        // Cert passed test, dump issuer and subject

        cCert++;

        if (!CertGetCertificateContextProperty(
					pcc,
					CERT_ARCHIVED_PROP_ID,
					NULL,
					&dwArchiveBit))
	{
            hr = myHLastError();
            if (hr != CRYPT_E_NOT_FOUND)
	    {
                wprintf(myLoadResourceString(IDS_FORMAT_ERROR_GET_ARCHIVE_PROP), hr);
		        wprintf(wszNewLine);
            }
        }
	else
	{
            wprintf(myLoadResourceString(IDS_LIST_ARCHIVED_CERT));
		    wprintf(wszNewLine);
            cCertArchived++;
        }

	hr = cuDumpSerial(g_wszPad2, IDS_SERIAL, &pcc->pCertInfo->SerialNumber);
	_PrintIfError(hr, "cuDumpSerial");

	hr = cuDisplayCertNames(FALSE, g_wszPad2, pcc->pCertInfo);
	_PrintIfError(hr, "cuDisplayCertNames");

	hr = cuDumpCertType(g_wszPad2, pcc->pCertInfo);
	_PrintIfError2(hr, "cuDumpCertType", CRYPT_E_NOT_FOUND);
    }
    if (0 == cCert)
    {
        wprintf(myLoadResourceString(IDS_NO_AUTOENROLLED_CERT));
		wprintf(wszNewLine);
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "no AE certs");
    }
    wprintf(
	L"%i Machine certs (%i archived) for %ws\n",
	cCert,
	cCertArchived,
	pwszDC);
    hr = S_OK;

error:
    if (NULL != hRemoteStore)
    {
        CertCloseStore(hRemoteStore, 0);
    }
    return(hr);
}


HRESULT
CheckForAutoenrollmentObject(
    IN WCHAR const *pwszDC)
{
    HRESULT hr;
    HCERTSTORE hRemoteStore = NULL;
    WCHAR wszStorePath[512];
    DWORD cAE;
    CTL_CONTEXT const *pCTL;

    swprintf(wszStorePath, L"\\\\%ws\\" wszACRS_CERTSTORE, pwszDC);

    hRemoteStore = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    NULL,
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
				CERT_STORE_READONLY_FLAG,
			    (VOID *) wszStorePath);
    if (NULL == hRemoteStore)
    {
        hr = myHLastError();
        wprintf(myLoadResourceString(IDS_FORMAT_OPEN_STORE_REMOTE_ENT_FAILED), hr);
		wprintf(wszNewLine);
        goto error;
    }

    // Dump issuer of enterprise roots.

    cAE = 0;
    pCTL = NULL;
    while (TRUE)
    {
	pCTL = CertEnumCTLsInStore(hRemoteStore, pCTL);
	if (NULL == pCTL)
	{
	    break;
	}
        wprintf(
	    L"Autoenrollment Object:\n%ws\n",
            pCTL->pCtlInfo->ListIdentifier.pbData);

        cAE++;
    }
    if (0 == cAE)
    {
        wprintf(myLoadResourceString(IDS_NO_AUTOENROLL_OBJECT));
        wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    if (NULL != hRemoteStore)
    {
        CertCloseStore(hRemoteStore, 0);
    }
    return(hr);
}


//
// This function takes a Marc Jacobs supplied text file (results from SSOLogon
// scripts) and runs through entmon for each machine in the list
//

HRESULT
verbEntInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszSamMachine,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hrSave;
    WCHAR *pwszDomain = NULL;
    WCHAR *pwszMachine = NULL;
    WCHAR *pwszMachineName = NULL;


    hr = mySplitConfigString(pwszSamMachine, &pwszDomain, &pwszMachine);
    _JumpIfError(hr, error, "mySplitConfigString");

    if (NULL == pwszMachine || NULL == wcschr(pwszMachine, L'$'))
    {
        wprintf(myLoadResourceString(IDS_ERROR_CHECK_MACHINE_NAME));
        wprintf(wszNewLine);
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad machine name");
    }

    // knock off trailing $
    hr = myDupString(pwszMachine, &pwszMachineName);
    _JumpIfError(hr, error, "myDupString");

    pwszMachineName[wcslen(pwszMachineName)-1] = L'\0';

    // assume for now that we're only interested in opening remote root store

    wprintf(myLoadResourceString(IDS_FORMAT_MACHINE_LIST), pwszMachine);
    wprintf(wszNewLine);


    // Cert store functions, if first fails, bail.

    hrSave = S_OK;
    hr = OpenRemoteEnterpriseRoot(pwszMachineName);
    if (S_OK != hr)
    {
	cuPrintError(IDS_REMOTEENTROOT, hr);
	_PrintError2(hr, "OpenRemoteEnterpriseRoot", hr);
	hrSave = hr;
    }
    else
    {
	hr = CheckForAutoenrollmentObject(pwszMachineName);
	_PrintIfError(hr, "CheckForAutoenrollmentObject");
	hrSave = hr;

	hr = CheckForAutoenrolledCertificate(pwszMachineName);
	_PrintIfError(hr, "CheckForAutoenrolledCertificate");
	if (S_OK == hrSave)
	{
	    hrSave = hr;
	}
    }
    hr = cuGetGroupMembership(pwszSamMachine);
    _PrintIfError(hr, "cuGetGroupMembership");
    if (S_OK == hrSave)
    {
	hrSave = hr;
    }
    hr = hrSave;
    _JumpIfError2(hr, error, "RunEntmon", hr);

    wprintf(wszNewLine);

error:
    if (NULL != pwszDomain)
    {
	LocalFree(pwszDomain);
    }
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    if (NULL != pwszMachineName)
    {
	LocalFree(pwszMachineName);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <setupapi.h>
#include <ocmanage.h>
#include "certsrvd.h"
#include "cscsp.h"
#include "initcert.h"
#include "csprop.h"


DWORD
cuFileSize(
    IN WCHAR const *pwszfn)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;

    if (!GetFileAttributesEx(pwszfn, GetFileExInfoStandard, &fad))
    {
	fad.nFileSizeLow = 0;
    }
    return(fad.nFileSizeLow);
}


HRESULT
verbHexTranslate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszfnOut,
    IN OPTIONAL IN WCHAR const *pwszType,
    IN WCHAR const *pwszArg4)
{
    BYTE *pbIn = NULL;
    DWORD cbIn;
    HRESULT hr;
    BOOL fEncode = g_wszEncodeHex == pwszOption;
    DWORD dwEncodeFlags;

    // Read in and decode the file.

    hr = DecodeFileW(
		pwszfnIn,
		&pbIn,
		&cbIn,
		fEncode? CRYPT_STRING_BINARY : CRYPT_STRING_HEX_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }
    CSASSERT(NULL != pbIn && 0 != cbIn);

    wprintf(
	myLoadResourceString(IDS_FORMAT_INPUT_LENGTH), // "Input Length = %d"
	cuFileSize(pwszfnIn));
    wprintf(wszNewLine);

    // Write encoded certificate to file

    dwEncodeFlags = CRYPT_STRING_BINARY;
    if (fEncode)
    {
	dwEncodeFlags = CRYPT_STRING_HEXASCIIADDR;
	if (NULL != pwszType)
	{
	    BOOL fValid;
	    
	    dwEncodeFlags = myWtoI(pwszType, &fValid);
	    if (!fValid)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad encoding type");
	    }
	}
	dwEncodeFlags |= g_CryptEncodeFlags;
    }

    hr = EncodeToFileW(pwszfnOut, pbIn, cbIn, dwEncodeFlags | g_EncodeFlags);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	goto error;
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_OUTPUT_LENGTH), // "Output Length = %d"
	cuFileSize(pwszfnOut));
    wprintf(wszNewLine);

error:
    if (NULL != pbIn)
    {
	LocalFree(pbIn);
    }
    return(hr);
}


// If a CRL, return CRYPT_STRING_BASE64X509CRLHEADER.
// If a cert or an empty PKCS7 with at least one cert, return
// CRYPT_STRING_BASE64HEADER.
// Otherwise, return CRYPT_STRING_BASE64REQUESTHEADER

HRESULT
GetBase64EncodeFlags(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT DWORD *pdwEncodeFlags)
{
    HRESULT hr;

    *pdwEncodeFlags = CRYPT_STRING_BASE64HEADER;

    // Try as a Cert:

    {
	CERT_CONTEXT const *pCertContext;

	pCertContext = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbIn,
					cbIn);
	if (NULL != pCertContext)
	{
	    CertFreeCertificateContext(pCertContext);
	    goto error;
	}
    }

    // Try as a CRL:

    {
	CRL_CONTEXT const *pCRLContext;

	pCRLContext = CertCreateCRLContext(X509_ASN_ENCODING, pbIn, cbIn);
	if (NULL != pCRLContext)
	{
	    CertFreeCRLContext(pCRLContext);
	    *pdwEncodeFlags = CRYPT_STRING_BASE64X509CRLHEADER;
	    goto error;
	}
    }

    // Try as a PKCS10, KeyGen or CMC request

    {
	BYTE *pbDecoded;
	DWORD cbDecoded;
	DWORD i;
	char const *rgpszStructType[] = {
	    X509_CERT_REQUEST_TO_BE_SIGNED,
	    X509_KEYGEN_REQUEST_TO_BE_SIGNED,
	    CMC_DATA,
	};

	for (i = 0; i < ARRAYSIZE(rgpszStructType); i++)
	{
	    if (myDecodeObject(
			X509_ASN_ENCODING,
			rgpszStructType[i],
			pbIn,
			cbIn,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cbDecoded))
	    {
		LocalFree(pbDecoded);
		*pdwEncodeFlags = CRYPT_STRING_BASE64REQUESTHEADER;
		goto error;
	    }
	}
    }

    // Recurse on the PKCS7 to examine the innermost content

    {
	BYTE *pbContents;
	DWORD cbContents;
	DWORD dwMsgType;
	DWORD cRecipient;

	hr = myDecodePKCS7(
			pbIn,
			cbIn,
			&pbContents,
			&cbContents,
			&dwMsgType,
			NULL,
			NULL,
			&cRecipient,
			NULL,
			NULL);
	if (S_OK == hr)
	{
	    if (CMSG_SIGNED == dwMsgType &&
		NULL != pbContents &&
		0 != cbContents &&
		0 == cRecipient)
	    {
		DWORD dwEncodeFlags;

		hr = GetBase64EncodeFlags(
				pbContents,
				cbContents,
				pdwEncodeFlags);
		_JumpIfError(hr, error, "GetBase64EncodeFlags");

	    }
	}
    }

error:
    hr = S_OK;
    return(hr);
}


HRESULT
verbBase64Translate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    BYTE *pbIn = NULL;
    DWORD cbIn;
    HRESULT hr;
    BOOL fEncode = g_wszEncode == pwszOption;
    DWORD dwEncodeFlags;

    // Read in and decode the file.

    hr = DecodeFileW(
		pwszfnIn,
		&pbIn,
		&cbIn,
		fEncode? CRYPT_STRING_BINARY : CRYPT_STRING_BASE64_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }
    CSASSERT(NULL != pbIn && 0 != cbIn);

    dwEncodeFlags = CRYPT_STRING_BINARY;
    if (fEncode)
    {
	hr = GetBase64EncodeFlags(pbIn, cbIn, &dwEncodeFlags);
        _JumpIfError(hr, error, "GetBase64EncodeFlags");

	dwEncodeFlags |= g_CryptEncodeFlags;
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_INPUT_LENGTH), // "Input Length = %d"
	cuFileSize(pwszfnIn));
    wprintf(wszNewLine);

    // Write encoded certificate to file

    hr = EncodeToFileW(
		pwszfnOut,
		pbIn,
		cbIn,
		dwEncodeFlags | g_EncodeFlags);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	goto error;
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_OUTPUT_LENGTH), // "Output Length = %d"
	cuFileSize(pwszfnOut));
    wprintf(wszNewLine);

error:
    if (NULL != pbIn)
    {
	LocalFree(pbIn);
    }
    return(hr);
}


HRESULT
TestCSP(
    IN WCHAR const *pwszProvName,
    IN DWORD const dwProvType,
    OPTIONAL WCHAR const *pwszKeyContainer)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    DWORD dwFlags = 0;

    if (NULL == pwszKeyContainer)
    {
	dwFlags |= CRYPT_VERIFYCONTEXT;
    }
    if (g_fCryptSilent)
    {
        dwFlags |= CRYPT_SILENT;
    }

    wprintf(
	L"CryptAcquireContext(%ws, %ws, %d, 0x%x)\n",
	NULL == pwszKeyContainer? L"Verify" : pwszKeyContainer,
	pwszProvName,
	dwProvType,
	dwFlags);

    if (!myCertSrvCryptAcquireContext(
                &hProv,
                pwszKeyContainer,
                pwszProvName,
                dwProvType,
                dwFlags,
                !g_fUserRegistry))	// fMachineKeyset
    {
        hr = myHLastError();

	cuPrintError(0, hr);
        _JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
    }
    wprintf(L"%ws\n", myLoadResourceString(IDS_PASS)); // "Pass"
    hr = S_OK;

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;
}


HRESULT
EnumAndTestCSP(
    IN BOOL const fTest)
{
    HRESULT hr;
    DWORD i;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;
    BOOL fFirst = TRUE;
    
    for (i = 0; ; i++)
    {
	hr = myEnumProviders(i, NULL, 0, &dwProvType, &pwszProvName);
	if (S_OK != hr)
	{
	    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr)
	    {
		// no more providers under type, terminate loop
		break;
	    }

	    // invalid csp entry, skip it

	    wprintf(L"Failed to enum CSP at (%ld)\n", i);
	}
	else
	{
	    if (!fFirst)
	    {
		wprintf(wszNewLine);
	    }
	    fFirst = FALSE;
	    wprintf(L"Provider Name: %ws\n", pwszProvName);
	    wprintf(L"Provider Type: %d\n", dwProvType);
	    if (fTest)
	    {
		hr = TestCSP(pwszProvName, dwProvType, NULL);
	    }
	    LocalFree(pwszProvName);
	    pwszProvName = NULL;
	}
    }
    hr = S_OK;

//error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
verbCSPDump(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    return EnumAndTestCSP(FALSE);
}


HRESULT
verbCSPTest(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszProvName,
    IN WCHAR const *pwszKeyContainer,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD   dwProvType;

    if (NULL != pwszProvName)
    {
        // get prov type
        hr = csiGetProviderTypeFromProviderName(pwszProvName, &dwProvType);
        _JumpIfError(hr, error, "GetProviderTypeFromProviderName");

        hr = TestCSP(pwszProvName, dwProvType, pwszKeyContainer);
	_JumpIfError(hr, error, "TestCSP");
    }
    else
    {
        hr = EnumAndTestCSP(TRUE);
	_JumpIfError(hr, error, "EnumAndTestCSP");
    }

error:
    return(hr);
}


UINT enumCATypeRscMap[] =
{
    IDS_ENTERPRISE_ROOT,    // ENUM_ENTERPRISE_ROOT = 0
    IDS_ENTERPRISE_SUB,     // ENUM_ENTERPRISE_SUBCA = 1
    IDS_CATYPE_UNKNOWN,     // ENUM_UNUSED2 = 2
    IDS_STANDALONE_ROOT,    // ENUM_STANDALONE_ROOTCA = 3
    IDS_STANDALONE_SUB,     // ENUM_STANDALONE_SUBCA = 4
    // ENUM_UNKNOWN_CA = 5
};


typedef struct _CAINFOTABLE
{
    WCHAR const *pwszCmdLineName;
    LONG         lPropId;
    LONG         lPropType;
    UINT         ids;
    DWORD        dwGetCert;
    DWORD        Flags;
    WCHAR const *pwszRegName;
} CAINFOTABLE;

#define CAITF_FLAGSARG		0x00000001
#define CAITF_INDEXARGMAXDWORD	0x00000002	// default index is MAXDWORD
#define CAITF_INDEXARGZERO	0x00000004	// default index is 0
#define CAITF_INDEXARGREQUIRED	0x00000008	// index required
#define CAITF_SIGCERTCOUNT	0x00000010	// cCASigCert elements
#define CAITF_XCHGCERTCOUNT	0x00000020	// cCAXchgCert elements
#define CAITF_KRACERTCOUNT	0x00000040	// cCAXchgCert elements
#define CAITF_EXITCOUNT		0x00000080	// exit mod count elements
#define CAITF_ASN		0x00000100	// contains dumpable ASN object
#define CAITF_DEFAULT		0x00000200	// default (unnamed) set
#define CAITF_SKIPINVALIDARG	0x00000400	// skip if bad CRL state
#define CAITF_SKIP		0x00000800	// skip when enumerating all
#define CAITF_OPTIONAL		0x00001000	// not always available

#define CAITF_INDEXARG (CAITF_INDEXARGMAXDWORD | \
			CAITF_INDEXARGZERO | \
			CAITF_INDEXARGREQUIRED)

WCHAR const g_wszCAInfoCRL[] = L"crl";
WCHAR const g_wszCAInfoCert[] = L"cert";
WCHAR const g_wszCAInfoCertChain[] = L"certchain";
WCHAR const g_wszCAInfoName[] = L"name";
WCHAR const g_wszCAInfoSanitizedName[] = L"sanitizedname";

#define GETCERT_UNSUPPORTED	MAXDWORD // not supported by old ICertRequest

CAINFOTABLE g_aCAInfoTable[] = 
{
    {
	L"file",
	CR_PROP_FILEVERSION,
	PROPTYPE_STRING,
	IDS_PROP_FILEVERSION,
	GETCERT_FILEVERSION,
	0,
	NULL,
    },
    {
	L"product",
	CR_PROP_PRODUCTVERSION,
	PROPTYPE_STRING,
	IDS_PROP_PRODUCTVERSION,
	GETCERT_PRODUCTVERSION,
	0,
	NULL,
    },
    {
	L"exitcount",
	CR_PROP_EXITCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_EXITCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"exit",
	CR_PROP_EXITDESCRIPTION,
	PROPTYPE_STRING,
	IDS_PROP_EXITDESCRIPTION,
	GETCERT_EXITVERSIONBYINDEX,
	CAITF_INDEXARGZERO | CAITF_EXITCOUNT,
	NULL,
    },
    {
	L"policy",
	CR_PROP_POLICYDESCRIPTION,
	PROPTYPE_STRING,
	IDS_PROP_POLICYDESCRIPTION,
	GETCERT_POLICYVERSION,
	0,
	NULL,
    },
    {
	g_wszCAInfoName,
	CR_PROP_CANAME,
	PROPTYPE_STRING,
	IDS_PROP_CANAME,
	GETCERT_CANAME,
	CAITF_DEFAULT,
	NULL,
    },
    {
	g_wszCAInfoSanitizedName,
	CR_PROP_SANITIZEDCANAME,
	PROPTYPE_STRING,
	IDS_PROP_SANITIZEDCANAME,
	GETCERT_SANITIZEDCANAME,
	0,
	NULL,
    },
    {
	L"sharedfolder",
	CR_PROP_SHAREDFOLDER,
	PROPTYPE_STRING,
	IDS_PROP_SHAREDFOLDER,
	GETCERT_SHAREDFOLDER,
	0,
	NULL,
    },
    {
	L"error1",
	CR_PROP_NONE,		// separate method call in ICertRequest2
	PROPTYPE_STRING,
	IDS_FORMAT_MESSAGE_TEXT, // "Error message text: %ws"
	GETCERT_ERRORTEXT1,
	CAITF_FLAGSARG | CAITF_SKIP,
	NULL,
    },
    {
	L"error2",
	CR_PROP_NONE,		// separate method call in ICertRequest2
	PROPTYPE_STRING,
	IDS_FORMAT_MESSAGE_TEXT, // "Error message text: %ws"
	GETCERT_ERRORTEXT2,
	CAITF_FLAGSARG | CAITF_SKIP,
	NULL,
    },
    {
	L"type",
	CR_PROP_CATYPE,
	PROPTYPE_LONG,
	IDS_PROP_CATYPE,
	GETCERT_CATYPE,
	CAITF_DEFAULT,
	wszPROPCATYPE,
    },
    {
	L"info",
	CR_PROP_NONE,		// not supported by ICertRequest2
	PROPTYPE_BINARY,
	IDS_PROP_CAINFO,
	GETCERT_CAINFO,
	0,
	NULL,
    },
    {
	L"parent",
	CR_PROP_PARENTCA,
	PROPTYPE_STRING,
	IDS_PROP_PARENTCA,
	GETCERT_PARENTCONFIG,
	CAITF_OPTIONAL,
	NULL,
    },
    {
	L"certcount",
	CR_PROP_CASIGCERTCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_CASIGCERTCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"xchgcount",
	CR_PROP_CAXCHGCERTCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_CAXCHGCERTCOUNT,
	GETCERT_UNSUPPORTED,
	0,
	NULL,
    },
    {
	L"kracount",
	CR_PROP_KRACERTCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_KRACERTCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"kraused",
	CR_PROP_KRACERTUSEDCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_KRACERTUSEDCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"propidmax",
	CR_PROP_CAPROPIDMAX,
	PROPTYPE_LONG,
	IDS_PROP_CAPROPIDMAX,
	GETCERT_UNSUPPORTED,
	0,
	NULL,
    },
// Cert and CRL state:
    {
	L"certstate",
	CR_PROP_CACERTSTATE,
	PROPTYPE_LONG,
	IDS_PROP_CACERTSTATE,
	GETCERT_CACERTSTATEBYINDEX,
	CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
    {
	L"certstatuscode",
	CR_PROP_CACERTSTATUSCODE,
	PROPTYPE_LONG,
	IDS_PROP_CACERSTATUSCODE,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
    {
	L"crlstate",
	CR_PROP_CRLSTATE,
	PROPTYPE_LONG,
	IDS_PROP_CRLSTATE,
	GETCERT_CRLSTATEBYINDEX,
	CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
// Signature certs:
    {
	g_wszCAInfoCert, // L"cert"
	CR_PROP_CASIGCERT,
	PROPTYPE_BINARY,
	IDS_PROP_CASIGCERT,
	GETCERT_CACERTBYINDEX,	// GETCERT_CASIGCERT handled by code hack
	CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	g_wszCAInfoCertChain, // L"certchain"
	CR_PROP_CASIGCERTCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CASIGCERTCHAIN,
	GETCERT_CACERTBYINDEX | GETCERT_CHAIN,	// GETCERT_CASIGCERT | GETCERT_CHAIN handled by code hack
	CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"certcrlchain",
	CR_PROP_CASIGCERTCRLCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CASIGCERTCRLCHAIN,
	GETCERT_CACERTBYINDEX | GETCERT_CHAIN | GETCERT_CRLS,
	CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
// Exchange certs:
    {
	L"xchg",
	CR_PROP_CAXCHGCERT,
	PROPTYPE_BINARY,
	IDS_PROP_CAXCHGCERT,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_XCHGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"xchgchain",
	CR_PROP_CAXCHGCERTCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CAXCHGCERTCHAIN,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_XCHGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"xchgcrlchain",
	CR_PROP_CAXCHGCERTCRLCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CAXCHGCERTCRLCHAIN,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_XCHGCERTCOUNT | CAITF_ASN,
	NULL,
    },
// KRA certs:
    {
	L"kra",
	CR_PROP_KRACERT,
	PROPTYPE_BINARY,
	IDS_PROP_KRACERT,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_KRACERTCOUNT | CAITF_ASN,
	NULL,
    },
// CRLs:
    {
	g_wszCAInfoCRL, // L"CRL"
	CR_PROP_BASECRL,
	PROPTYPE_BINARY,
	IDS_PROP_BASECRL,
	GETCERT_CRLBYINDEX,	// GETCERT_CURRENTCRL handled by code hack
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"deltacrl",
	CR_PROP_DELTACRL,
	PROPTYPE_BINARY,
	IDS_PROP_DELTACRL,
	GETCERT_UNSUPPORTED,
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"crlstatus",
	CR_PROP_BASECRLPUBLISHSTATUS,
	PROPTYPE_LONG,
	IDS_PROP_BASECRLPUBLISHSTATUS,
	GETCERT_UNSUPPORTED,
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT | CAITF_OPTIONAL,
	wszPROPCRLPUBLISHFLAGS,
    },
    {
	L"deltacrlstatus",
	CR_PROP_DELTACRLPUBLISHSTATUS,
	PROPTYPE_LONG,
	IDS_PROP_DELTACRLPUBLISHSTATUS,
	GETCERT_UNSUPPORTED,
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT | CAITF_OPTIONAL,
	wszPROPCRLPUBLISHFLAGS,
    },
    {
	L"dns",
	CR_PROP_DNSNAME,
	PROPTYPE_STRING,
	IDS_PROP_DNSNAME,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT | CAITF_OPTIONAL,
	NULL,
    },
    {
	L"role",
	CR_PROP_ROLESEPARATIONENABLED,
	PROPTYPE_LONG,
	IDS_PROP_ROLESEPARATIONENABLED,
	GETCERT_UNSUPPORTED,
	CAITF_OPTIONAL | CAITF_SKIP,
	NULL,
    },
    {
	L"ads",
	CR_PROP_ADVANCEDSERVER,
	PROPTYPE_LONG,
	IDS_PROP_ADVANCEDSERVER,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT | CAITF_OPTIONAL,
	NULL,
    },
    {
	L"templates",
	CR_PROP_TEMPLATES,
	PROPTYPE_STRING,
	IDS_PROP_TEMPLATES,
	GETCERT_UNSUPPORTED,
	CAITF_OPTIONAL,
	NULL,
    },
    {
	NULL,
    },
};


typedef HRESULT (FNPROP_INIT)(
    IN DWORD Flags,
    IN OUT DISPATCHINTERFACE *pdiProp);

typedef VOID (FNPROP_RELEASE)(
    IN OUT DISPATCHINTERFACE *pdiProp);

typedef HRESULT (FNPROP2_GETCAPROPERTY)(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);

typedef HRESULT (FNPROP2_GETCAPROPERTYFLAGS)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags);

typedef HRESULT (FNPROP2_GETCAPROPERTYDISPLAYNAME)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName);


FNPROP_INIT *g_pfnProp_Init;
FNPROP_RELEASE *g_pfnProp_Release;
FNPROP2_GETCAPROPERTY *g_pfnProp2_GetCAProperty;
FNPROP2_GETCAPROPERTYFLAGS *g_pfnProp2_GetCAPropertyFlags;
FNPROP2_GETCAPROPERTYDISPLAYNAME *g_pfnProp2_GetCAPropertyDisplayName;


VOID
InitPropFunctionPointers(VOID)
{
    if (g_fAdminInterface)
    {
	g_pfnProp_Init = Admin_Init;
	g_pfnProp_Release = Admin_Release;
	g_pfnProp2_GetCAProperty = Admin2_GetCAProperty;
	g_pfnProp2_GetCAPropertyFlags = Admin2_GetCAPropertyFlags;
	g_pfnProp2_GetCAPropertyDisplayName = Admin2_GetCAPropertyDisplayName;
    }
    else
    {
	g_pfnProp_Init = Request_Init;
	g_pfnProp_Release = Request_Release;
	g_pfnProp2_GetCAProperty = Request2_GetCAProperty;
	g_pfnProp2_GetCAPropertyFlags = Request2_GetCAPropertyFlags;
	g_pfnProp2_GetCAPropertyDisplayName = Request2_GetCAPropertyDisplayName;
    }
}


VOID
cuCAInfoUsage(VOID)
{
    CAINFOTABLE const *pcait;
    UINT id;

    wprintf(wszNewLine);
    wprintf(L"    %ws\n", myLoadResourceString(IDS_CAINFO_USAGEHEADERCOLON)); // "InfoName argument values:"

    for (pcait = g_aCAInfoTable; NULL != pcait->pwszCmdLineName; pcait++)
    {
	id = 0;
	wprintf(L"\t%ws", pcait->pwszCmdLineName);
	if (CAITF_FLAGSARG & pcait->Flags)
	{
	    id = IDS_CAINFO_USAGEERROR;
	}
	if (CAITF_INDEXARG & pcait->Flags)
	{
	    id = IDS_CAINFO_USAGEINDEX;
	}
	if (0 != id)
	{
	    wprintf(L" %ws", myLoadResourceString(id));
	}
	wprintf(L" -- %ws", myLoadResourceString(pcait->ids));
	wprintf(wszNewLine);
    }
}


BOOL
cuParseDecimal(
    IN OUT WCHAR const **ppwc,
    IN OUT DWORD *pcwc,
    OUT DWORD *pdw)
{
    BOOL fFound = FALSE;
    WCHAR const *pwc = *ppwc;
    DWORD cwc = *pcwc;
    DWORD dw = 0;

    while (0 != cwc && iswdigit(*pwc))
    {
	dw = (10 * dw) + *pwc++ - L'0';
	cwc--;
	fFound = TRUE;
    }
    if (fFound && 0 != cwc && L',' == *pwc)
    {
	pwc++;
	cwc--;
    }
    *ppwc = pwc;
    *pcwc = cwc;
    *pdw = dw;
    return(fFound);
}


UINT enumDispositionResourceMap[] =
{
    IDS_CADISP_INCOMPLETE,	// CA_DISP_INCOMPLETE = 0
    IDS_CADISP_ERROR,		// CA_DISP_ERROR = 1
    //IDS_CADISP_ERROR_CRL,	// CA_DISP_ERROR = 1
    IDS_CADISP_REVOKED,		// CA_DISP_REVOKED = 2
    IDS_CADISP_VALID,		// CA_DISP_VALID = 3
    IDS_CADISP_EXPIRED,		// CA_DISP_INVALID = 4
    IDS_CADISP_UNDERSUBMISSION,	// CA_DISP_UNDER_SUBMISSION = 5
    //IDS_CADISP_UNKNOWN,	// ???
};


VOID
DisplayCAState(
    IN LONG lPropId,
    IN DWORD Index,
    IN DWORD State)
{
    UINT id;

    CSASSERT(CR_PROP_CACERTSTATE == lPropId || CR_PROP_CRLSTATE == lPropId);

    id = IDS_CADISP_UNKNOWN;
    if (ARRAYSIZE(enumDispositionResourceMap) > State)
    {
	id = enumDispositionResourceMap[State];
	if (IDS_CADISP_ERROR == id && CR_PROP_CRLSTATE == lPropId)
	{
	    id = IDS_CADISP_ERROR_CRL;	// "Error: No CRL for this Cert"
	}
    }
    wprintf(L" -- %ws", myLoadResourceString(id));	// "Valid", etc.
    wprintf(wszNewLine);
}


VOID
DisplayCAType(
    IN LONG CAType)
{
    UINT uid;

    if (CAType > ARRAYSIZE(enumCATypeRscMap))
    {
	uid = IDS_CATYPE_UNKNOWN;
    }
    else
    {
	uid = enumCATypeRscMap[CAType];
    }
    wprintf(myLoadResourceString(uid), CAType);
    wprintf(wszNewLine);
}


//+-------------------------------------------------------------------------
// cuGetCAInfoPropertyByIndex -- display one CA Property for one index value.
//
//--------------------------------------------------------------------------

HRESULT
cuGetCAInfoPropertyByIndex(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN LONG const *pPropIndex,
    IN CAINFOTABLE const *pcait,
    IN OUT DISPATCHINTERFACE *pdiProp,
    IN BOOL fV1)
{
    HRESULT hr;
    BYTE *pbBinary = NULL;
    DWORD cbBinary;
    DWORD dwGetCertType;
    DWORD Format;
    DWORD Index = 0;
    DWORD IndexV1 = 0;
    LONG longValue;
    BSTR strValue = NULL;
    BOOL fVerbose = FALSE;
    BOOL fVerboseOld = g_fVerbose;
    BOOL fDisplayed = FALSE;

    if (g_fVerbose)
    {
	g_fVerbose--;
	fVerbose = TRUE;
    }

    dwGetCertType = pcait->dwGetCert;

    if ((CAITF_INDEXARG | CAITF_FLAGSARG) & pcait->Flags)
    {
	if (NULL == pPropIndex)
	{
	    if ((CAITF_INDEXARGREQUIRED | CAITF_FLAGSARG) & pcait->Flags)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "missing numeric arg");
	    }
	    if (CAITF_INDEXARGMAXDWORD & pcait->Flags)
	    {
		Index = MAXDWORD;
	    }
	    switch (pcait->lPropId)
	    {
		case CR_PROP_BASECRL:
		    dwGetCertType = GETCERT_CURRENTCRL;
		    break;

		case CR_PROP_CASIGCERT:
		    dwGetCertType = GETCERT_CASIGCERT;
		    break;

		case CR_PROP_CASIGCERTCHAIN:
		    dwGetCertType = GETCERT_CASIGCERT | GETCERT_CHAIN;
		    break;
	    }
	}
	else
	{
	    Index = *pPropIndex;
	    IndexV1 = Index;
	}

	if (0 == (CAITF_FLAGSARG & pcait->Flags))
	{
	    if (GETCERT_INDEXVALUEMASK < IndexV1)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "index too large");
	    }
	    CSASSERT(
		0 == IndexV1 ||
		GETCERT_UNSUPPORTED == dwGetCertType ||
		0 == (GETCERT_INDEXVALUEMASK & dwGetCertType));
	}
    }
    else
    {
	if (NULL != pPropIndex)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "too many args");
	}
    }

    if (!fV1)
    {
	if (CR_PROP_NONE != pcait->lPropId)
	{
	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    pcait->lPropId,
			    Index,
			    pcait->lPropType,
			    PROPTYPE_BINARY == pcait->lPropType?
				CV_OUT_BASE64HEADER : CV_OUT_BINARY,
			    PROPTYPE_LONG == pcait->lPropType?
				(VOID *) &longValue : (VOID *) &strValue);
	    if (E_NOTIMPL != hr)
	    {
		_JumpIfError2(hr, error, "g_pfnProp2_GetCAProperty", hr);
	    }
	    else
	    {
		fV1 = TRUE;
	    }
	}
	else
	{
	    fV1 = TRUE;
	}
    }
    if (fV1)
    {
	DWORD FlagsV1;

	if (g_fAdminInterface || GETCERT_UNSUPPORTED == dwGetCertType)
	{
	    hr = E_NOTIMPL;
	    _JumpIfError(hr, error, "ICertRequest2 required");
	}
	if (CAITF_FLAGSARG & pcait->Flags)
	{
	    FlagsV1 = IndexV1;
	    IndexV1 = 0;
	}
	else
	{
	    FlagsV1 = (CAITF_ASN & pcait->Flags)?
			CR_OUT_BASE64HEADER : CR_OUT_BINARY;
	    if (g_wszCAChain == pwszOption)
	    {
		FlagsV1 |= CR_OUT_CHAIN;
	    }
	}

	hr = Request_GetCACertificate(
			    pdiProp,
			    dwGetCertType | IndexV1, // fExchangeCertificate
			    g_pwszConfig,
			    FlagsV1,
			    &strValue);
	_JumpIfError2(
		hr,
		error,
		"Request_GetCACertificate",
		(CAITF_OPTIONAL & pcait->Flags)?
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);

	// Build up a nice debug print:

	if (fVerbose)
	{
	    WCHAR wszArg[20];

	    switch (dwGetCertType)
	    {
		case GETCERT_CASIGCERT:
		    wcscpy(wszArg, L"SignatureCert");
		    break;

		case GETCERT_CAXCHGCERT:
		    wcscpy(wszArg, L"ExchangeCert");
		    break;

		case GETCERT_CACERTBYINDEX:
		case GETCERT_CRLBYINDEX:
		case GETCERT_CACERTSTATEBYINDEX:
		case GETCERT_CRLSTATEBYINDEX:
		case GETCERT_EXITVERSIONBYINDEX:
		    swprintf(
			wszArg,
			L"\"%c%c.%d\"",
			((char *) &dwGetCertType)[3],
			((char *) &dwGetCertType)[2],
			Index);
		    break;

		default:
		    swprintf(
			wszArg,
			L"\"%c%c%c%c\"",
			((char *) &dwGetCertType)[3],
			((char *) &dwGetCertType)[2],
			((char *) &dwGetCertType)[1],
			((char *) &dwGetCertType)[0]);
		    break;
	    }
	    wprintf(L"GetCACertificate(%ws):\n%ws\n", wszArg, strValue);
	}

	if (PROPTYPE_LONG == pcait->lPropType)
	{
	    DWORD cwc = wcslen(strValue);
	    WCHAR const *pwc = strValue;

	    if (!cuParseDecimal(&pwc, &cwc, (DWORD *) &longValue))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpErrorStr(hr, error, "bad decimal number", strValue);
	    }
	}
    }

    // At this point:
    //   if PROPTYPE_LONG, the value is in longValue,
    //   if PROPTYPE_STRING, the value is in strValue
    //   if PROPTYPE_BINARY, the base64-encoded string is in strValue

    if ((CAITF_ASN & pcait->Flags))
    {
	hr = myCryptStringToBinary(
		    strValue,
		    0,
		    CRYPT_STRING_BASE64HEADER,
		    &pbBinary,
		    &cbBinary,
		    NULL,
		    NULL);
	_JumpIfError(hr, error, "myCryptStringToBinary");

	if (fVerbose)
	{
	    hr = cuDumpAsnBinary(pbBinary, cbBinary, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }

    switch (pcait->lPropId)
    {
	case CR_PROP_NONE:
	{
	    switch (dwGetCertType)
	    {
		case GETCERT_ERRORTEXT1:
		case GETCERT_ERRORTEXT2:
		    wprintf(
		    myLoadResourceString(IDS_FORMAT_MESSAGE_TEXT), // "Error message text: %ws"
		    L"");
		    wprintf(L"%ws\n", strValue);
		    fDisplayed = TRUE;
		    break;

		// prettyprint CA Type/CA Info

		case GETCERT_CAINFO:
		{
		    DWORD cwc = wcslen(strValue);
		    WCHAR const *pwc = strValue;
		    CAINFO CAInfo;
		    
		    if (cuParseDecimal(&pwc, &cwc, (DWORD *) &CAInfo.CAType))
		    {
			if (NULL != pwszInfoName &&
			    0 != lstrcmp(L"*", pwszInfoName))
			{
			    DisplayCAType(CAInfo.CAType);
			}
			if (cuParseDecimal(&pwc, &cwc, &CAInfo.cCASignatureCerts))
			{
			    wprintf(
				myLoadResourceString(IDS_FORMAT_CCACERTS),
				CAInfo.cCASignatureCerts);
			    wprintf(wszNewLine);
			}
		    }
		    fDisplayed = TRUE;
		    break;
		}
	    }
	    break;
	}
    }
    if (!fDisplayed)
    {
	wprintf(L"%ws", myLoadResourceString(pcait->ids));
	if (NULL != pPropIndex)
	{
	    wprintf(L"[%d]", *pPropIndex);
	}
	if (PROPTYPE_LONG == pcait->lPropType)
	{
	    if (0 > longValue || 9 < longValue)
	    {
		wprintf(L": 0x%x (%d)", longValue, longValue);
	    }
	    else
	    {
		wprintf(L": %x", longValue);
	    }
	    switch (pcait->lPropId)
	    {
		// prettyprint Cert/CRL State

		case CR_PROP_CACERTSTATE:
		case CR_PROP_CRLSTATE:
		    DisplayCAState(pcait->lPropId, Index, longValue);
		    break;

		case CR_PROP_CATYPE:
		    wprintf(L" -- ");
		    DisplayCAType(longValue);
		    break;

		default:
		    wprintf(wszNewLine);
		    break;
	    }
	    if (NULL != pcait->pwszRegName)
	    {
		cuRegPrintDwordValue(
				FALSE,
				pcait->pwszRegName,
				pcait->pwszRegName,
				longValue);
	    }
	}
	else
	{
	    wprintf(L":%ws", (CAITF_ASN & pcait->Flags)? L"\n" : L" ");
	    cuPrintCRLFString(NULL, strValue);
	    wprintf(wszNewLine);
	}
    }

    if (NULL != pwszfnOut && NULL != pbBinary)
    {
	hr = EncodeToFileW(
		    pwszfnOut,
		    pbBinary,
		    cbBinary,
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	if (S_OK != hr)
	{
	    _PrintError(hr, "EncodeToFileW");
	    cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	    goto error;
	}
    }

error:
    g_fVerbose = fVerboseOld;
    if (NULL != pbBinary)
    {
	LocalFree(pbBinary);
    }
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
GetCACounts(
    IN OUT DISPATCHINTERFACE *pdiProp,
    IN OUT BOOL *pfV1,
    OUT LONG *pcCASigCerts,
    OUT LONG *pcCAXchgCerts,
    OUT LONG *pcKRACerts,
    OUT LONG *pcExitMods,
    OUT LONG *plPropIdMax)
{
    HRESULT hr;
    BSTR strValue = NULL;

    if (!*pfV1)
    {
	hr = (*g_pfnProp2_GetCAProperty)(
			pdiProp,
			g_pwszConfig,
			CR_PROP_CASIGCERTCOUNT,
			0,
			PROPTYPE_LONG,
			CV_OUT_BINARY,
			pcCASigCerts);
	if (RPC_E_VERSION_MISMATCH != hr)
	{
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_CAXCHGCERTCOUNT,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    pcCAXchgCerts);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_KRACERTCOUNT,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    pcKRACerts);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_EXITCOUNT,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    pcExitMods);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_CAPROPIDMAX,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    plPropIdMax);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");
	}
	else
	{
	    *pfV1 = TRUE;
	}
    }
    if (*pfV1)
    {
	WCHAR const *pwc;
	DWORD cwc;
	
	if (g_fAdminInterface)
	{
	    hr = E_NOTIMPL;
	    _JumpIfError(hr, error, "ICertRequest required");
	}
	hr = Request_GetCACertificate(
			    pdiProp,
			    GETCERT_CAINFO, // fExchangeCertificate
			    g_pwszConfig,
			    CR_OUT_BINARY,
			    &strValue);
	_JumpIfError(hr, error, "Request_GetCACertificate");

	pwc = wcschr(strValue, L',');
	if (NULL == pwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "bad CAInfo string", strValue);
	}

	pwc++;
	cwc = wcslen(pwc);

	if (!cuParseDecimal(&pwc, &cwc, (DWORD *) pcCASigCerts))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "bad CAInfo cert count", strValue);
	}
	*pcCAXchgCerts = 0;
	*pcExitMods = 1;
	*plPropIdMax = 0;
    }
    if (1 < g_fVerbose)
    {
	wprintf(
	    L"GetCACounts(): cCASigCerts = %d, cCAXchgCerts = %d, cKRACerts = %d\n",
	    *pcCASigCerts,
	    *pcCAXchgCerts,
	    *pcKRACerts);
    }

error:
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// cuGetCAInfoProperty -- display one CA Property.
//
// If an index is specifed, display the property only for that index.
// Otherwse, display the property for all valid indexes.
//
//--------------------------------------------------------------------------

HRESULT
cuGetCAInfoProperty(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber,
    IN CAINFOTABLE const *pcait,
    IN LONG cCASigCerts,
    IN LONG cCAXchgCerts,
    IN LONG cKRACerts,
    IN LONG cExitMods,
    IN OUT DISPATCHINTERFACE *pdiProp,
    IN BOOL fV1)
{
    HRESULT hr;
    HRESULT hr2 = S_OK;
    LONG CmdLineIndex;
    LONG PropIndex;
    LONG *pPropIndex = NULL;
    LONG Count = 1;

    // Determine indexed property Count.
    // Non-indexed property Count is always 1.
    
    switch (
	(CAITF_EXITCOUNT | CAITF_SIGCERTCOUNT | CAITF_XCHGCERTCOUNT | CAITF_KRACERTCOUNT) &
	pcait->Flags)
    {
	case CAITF_EXITCOUNT:
	    Count = cExitMods;
	    pPropIndex = &PropIndex;
	    break;
	    
	case CAITF_SIGCERTCOUNT:
	    Count = cCASigCerts;
	    pPropIndex = &PropIndex;
	    break;
	    
	case CAITF_XCHGCERTCOUNT:
	    Count = cCAXchgCerts;
	    pPropIndex = &PropIndex;
	    break;
	    
	case CAITF_KRACERTCOUNT:
	    Count = cKRACerts;
	    pPropIndex = &PropIndex;
	    break;
    }
    if (NULL != pwszNumber)
    {
	hr = cuGetSignedLong(pwszNumber, &CmdLineIndex);
	_JumpIfErrorStr(hr, error, "Value not a number", pwszNumber);

	if (MAXDWORD == CmdLineIndex)
	{
	    CmdLineIndex = Count - 1;
	}
	Count = 1;
	pPropIndex = &CmdLineIndex;
    }

    for (PropIndex = 0; PropIndex < Count; PropIndex++)
    {
	if (1 < g_fVerbose)
	{
	    wprintf(
		NULL == pPropIndex?
		    L"cuGetCAInfoProperty(%ws): %ws:\n" :
		    L"cuGetCAInfoProperty(%ws): %ws[%u]:\n",
		pcait->pwszCmdLineName,
		pcait->pwszCmdLineName,
		NULL == pPropIndex? -1 : *pPropIndex);
	}

	hr = cuGetCAInfoPropertyByIndex(
			pwszOption,
			pwszfnOut,
			pwszInfoName,
			pPropIndex,
			pcait,
			pdiProp,
			fV1);
	if (E_INVALIDARG == hr &&
	    1 < Count &&
	    (CAITF_SKIPINVALIDARG & pcait->Flags))
	{
	    _PrintIfError2(hr, "cuGetCAInfoPropertyByIndex", hr);
	    hr = S_OK;
	}
	_PrintIfError2(
		    hr,
		    "cuGetCAInfoPropertyByIndex",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	if (S_OK == hr2)
	{
	    hr2 = hr;		// Save first error
	}
    }
    hr = hr2;

error:
    return(hr);
}


//+-------------------------------------------------------------------------
// cuGetCAInfo -- display one or more CA Properties.
//
// If indexed property counts will be needed, fetch them first, so we know
// how many of each indexed property to fetch.
//
// If pwszInfoName is NULL, display the default set of properties.
// If pwszInfoName is L"*", display all properties.
// Otherwise, display only the specified property.
//
//--------------------------------------------------------------------------

HRESULT
cuGetCAInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber)
{
    HRESULT hr;
    HRESULT hr2 = S_OK;
    DISPATCHINTERFACE diProp;
    BOOL fV1 = g_fV1Interface;
    BOOL fMustRelease = FALSE;
    BOOL fMultiple = FALSE;
    LONG cCASigCerts = 0;
    LONG cCAXchgCerts = 0;
    LONG cKRACerts = 0;
    LONG cExitMods = 0;
    LONG lPropIdMax;
    CAINFOTABLE const *pcait;

    InitPropFunctionPointers();

    hr = (*g_pfnProp_Init)(g_DispatchFlags, &diProp);
    _JumpIfError(hr, error, "g_pfnProp_Init");

    fMustRelease = TRUE;

    if (NULL == pwszInfoName ||
	(0 != lstrcmpi(g_wszCAInfoName, pwszInfoName) &&
	 0 != lstrcmpi(g_wszCAInfoSanitizedName, pwszInfoName)))
    {
	hr = GetCACounts(
		    &diProp,
		    &fV1,
		    &cCASigCerts,
		    &cCAXchgCerts,
		    &cKRACerts,
		    &cExitMods,
		    &lPropIdMax);
	_JumpIfError(hr, error, "GetCACounts");
    }

    if (NULL == pwszInfoName || 0 == lstrcmp(L"*", pwszInfoName))
    {
	CSASSERT(NULL == pwszfnOut);
	if (NULL != pwszNumber)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "too many args");
	}
	fMultiple = TRUE;	// loop displaying default or all entries
    }

    for (pcait = g_aCAInfoTable; ; pcait++)
    {
	if (NULL == pcait->pwszCmdLineName)
	{
	    if (!fMultiple)
	    {
		hr = E_INVALIDARG;
		_JumpErrorStr(hr, error, "bad command line name", pwszInfoName);
	    }
	    break;
	}
	if (fMultiple)
	{
	    if (NULL == pwszInfoName)
	    {
		if (0 == (CAITF_DEFAULT & pcait->Flags))
		{
		    continue;
		}
	    }
	    else
	    {
		if (CAITF_SKIP & pcait->Flags)
		{
		    continue;
		}
	    }
	    if (fV1)
	    {
		if (GETCERT_UNSUPPORTED == pcait->dwGetCert)
		{
		    continue;
		}
	    }
	    else
	    {
		if (CR_PROP_NONE == pcait->lPropId)
		{
		    continue;
		}
	    }
	}
	else
	{
	    if (0 != lstrcmpi(pcait->pwszCmdLineName, pwszInfoName))
	    {
		continue;
	    }
	}
	hr = cuGetCAInfoProperty(
			pwszOption,
			pwszfnOut,
			pwszInfoName,
			pwszNumber,
			pcait,
			cCASigCerts,
			cCAXchgCerts,
			cKRACerts,
			cExitMods,
			&diProp,
			fV1);
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
	    (CAITF_OPTIONAL & pcait->Flags) &&
	    fMultiple)
	{
	    _PrintError2(hr, "cuGetCAInfoProperty", hr);
	    hr = S_OK;
	}
	_PrintIfError(hr, "cuGetCAInfoProperty");
	if (S_OK == hr2)
	{
	    hr2 = hr;		// Save first error
	}
	if (!fMultiple)
	{
	    break;
	}
    }
    hr = hr2;

error:
    if (fMustRelease)
    {
	(*g_pfnProp_Release)(&diProp);
    }
    return(hr);
}


HRESULT
verbGetCACertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnCert,
    OPTIONAL IN WCHAR const *pwszIndex,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    if (NULL == pwszIndex)
    {
	pwszIndex = L"-1";
    }
    hr = cuGetCAInfo(
		pwszOption,
		pwszfnCert,
		g_wszCACert == pwszOption?
		    g_wszCAInfoCert : g_wszCAInfoCertChain,
		pwszIndex);
    _JumpIfError(hr, error, "cuGetCAInfo");

error:
    return(hr);
}


HRESULT
verbGetCAInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = cuGetCAInfo(pwszOption, NULL, pwszInfoName, pwszNumber);
    _JumpIfError(hr, error, "cuGetCAInfo");

error:
    return(hr);
}


HRESULT
verbGetCAPropInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2 = S_OK;
    DISPATCHINTERFACE diProp;
    BOOL fV1 = g_fV1Interface;
    BOOL fMustRelease = FALSE;
    LONG cCASigCerts;
    LONG cCAXchgCerts;
    LONG cKRACerts;
    LONG cExitMods;
    LONG lPropIdMax;
    LONG lPropId;
    BSTR strDisplayName = NULL;

    InitPropFunctionPointers();

    hr = (*g_pfnProp_Init)(g_DispatchFlags, &diProp);
    _JumpIfError(hr, error, "g_pfnProp_Init");

    fMustRelease = TRUE;

    hr = GetCACounts(
		&diProp,
		&fV1,
		&cCASigCerts,
		&cCAXchgCerts,
		&cKRACerts,
		&cExitMods,
		&lPropIdMax);
    _JumpIfError(hr, error, "GetCACounts");

    for (lPropId = 1; lPropId <= lPropIdMax; lPropId++)
    {
	LONG lPropFlags;
	
	// don't use the display name twice!
	
	if (NULL != strDisplayName)
	{
	    SysFreeString(strDisplayName);
	    strDisplayName = NULL;
	}
	hr = (*g_pfnProp2_GetCAPropertyFlags)(
				    &diProp,
				    g_pwszConfig,
				    lPropId,
				    &lPropFlags);
	_PrintIfError(hr, "g_pfnProp2_GetCAPropertyFlags");
	if (S_OK == hr)
	{
	    hr = (*g_pfnProp2_GetCAPropertyDisplayName)(
					&diProp,
					g_pwszConfig,
					lPropId,
					&strDisplayName);
	    _PrintIfError(hr, "g_pfnProp2_GetCAPropertyDisplayName");

	    wprintf(L"%3d: ", lPropId);
	    cuPrintSchemaEntry(
			NULL,	// pwszName
			NULL != strDisplayName? strDisplayName : g_wszEmpty,
			lPropFlags,
			0);		// cbMax
	}
    }

error:
    if (fMustRelease)
    {
	(*g_pfnProp_Release)(&diProp);
    }
    if (NULL != strDisplayName)
    {
	SysFreeString(strDisplayName);
    }
    return(hr);
}


HRESULT
verbGetConfig(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    wprintf(
	myLoadResourceString(IDS_FORMAT_CONFIG_STRING), // "Config String: ""%ws"""
	g_pwszConfig);
    wprintf(wszNewLine);
    return(S_OK);
}


HRESULT
verbGetConfig2(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    ICertGetConfig *pConfig = NULL;
    BSTR strConfig = NULL;
    LONG Flags;

    hr = CoCreateInstance(
                CLSID_CCertGetConfig,
                NULL,               // pUnkOuter
                CLSCTX_INPROC_SERVER,
                IID_ICertGetConfig,
                (VOID **) &pConfig);
    _JumpIfError(hr, error, "CoCreateInstance");

    Flags = CC_LOCALCONFIG;
    if (NULL != pwszFlags)
    {
	hr = cuGetLong(pwszFlags, &Flags);
	_JumpIfError(hr, error, "Flags must be a number");
    }

    hr = pConfig->GetConfig(Flags, &strConfig);
    _JumpIfError(hr, error, "GetConfig");

    wprintf(
	myLoadResourceString(IDS_FORMAT_ICERTCONFIG_CONFIG_STRING), // "ICertGetConfig Config String: ""%ws"""
	strConfig);
    wprintf(wszNewLine);

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != pConfig)
    {
	pConfig->Release();
    }
    return(hr);
}


HRESULT
verbGetConfig3(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    LONG count;
    DISPATCHINTERFACE diConfig;
    BOOL fRelease = FALSE;
    BSTR strConfig = NULL;
    LONG Flags;
    
    hr = Config_Init(g_DispatchFlags, &diConfig);
    _JumpIfError(hr, error, "Config_Init");

    fRelease = TRUE;

    hr = Config_Reset(&diConfig, 0, &count);
    _JumpIfError(hr, error, "Config_Reset");

    Flags = CC_UIPICKCONFIG;
    if (NULL != pwszFlags)
    {
	hr = cuGetLong(pwszFlags, &Flags);
	_JumpIfError(hr, error, "Flags must be a number");
    }

    hr = Config_GetConfig(&diConfig, Flags, &strConfig);
    _JumpIfError(hr, error, "Config_GetConfig");

    hr = ConfigDumpEntry(&diConfig, NULL, -1, NULL);
    _JumpIfError(hr, error, "ConfigDumpEntry");

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (fRelease)
    {
	Config_Release(&diConfig);
    }
    return(hr);
}


HRESULT
verbErrorDump(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszErrorCode,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hrDump;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszError = NULL;
    
    hr = cuGetSignedLong(pwszErrorCode, &hrDump);
    _JumpIfError(hr, error, "bad numeric operand");

    wprintf(
	L"%ws -- %u (%d)\n",
	myHResultToString(awchr, hrDump),
	hrDump,
	hrDump);

    pwszError = myGetErrorMessageText(hrDump, g_fVerbose);
    wprintf(
	myLoadResourceString(IDS_FORMAT_MESSAGE_TEXT), // "Error message text: %ws"
	pwszError);
    wprintf(wszNewLine);
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
        LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hr);
}


HRESULT
RequestCACertificateAndComplete(
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszParentMachine,
    OPTIONAL IN WCHAR const *pwszParentCA,
    OPTIONAL IN WCHAR const *pwszfnCACert,
    OPTIONAL OUT WCHAR **ppwszRequestFile)
{
    HRESULT hr;
    WCHAR *pwszCAName = NULL;
    WCHAR *pwszFinalCAName;

    pwszFinalCAName = wcschr(g_pwszConfig, L'\\');
    if (NULL != pwszFinalCAName)
    {
        pwszFinalCAName++;
    }
    else
    {
        hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGACTIVE, &pwszCAName);
        _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGACTIVE);

        pwszFinalCAName = pwszCAName;
    }
    if (g_fForce)
    {
	Flags |= CSRF_OVERWRITE;
	Flags |= CSRF_UNATTENDED;
    }

    hr = CertServerRequestCACertificateAndComplete(
				g_hInstance,		// hInstance
			        NULL,			// hwnd
			        Flags,			// Flags
				pwszFinalCAName,	// pwszCAName
			        pwszParentMachine,	// pwszParentMachine
			        pwszParentCA,		// pwszParentCA
				pwszfnCACert,		// pwszCAChainFile
				ppwszRequestFile);	// ppwszRequestFile
    _JumpIfError(hr, error, "CertServerRequestCACertificateAndComplete");

error:
    if (NULL != pwszCAName)
    {
        LocalFree(pwszCAName);
    }
    return(hr);
}


HRESULT
verbInstallCACert(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnCACert,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = RequestCACertificateAndComplete(
				CSRF_INSTALLCACERT,
			        NULL,		// pwszParentMachine
			        NULL,		// pwszParentCA
				pwszfnCACert,	// pwszfnCACert
				NULL);		// ppwszRequestFile
    _JumpIfError(hr, error, "RequestCACertificateAndComplete");

error:
    return(hr);
}


HRESULT
verbRenewCACert(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszReuseKeys,
    IN WCHAR const *pwszParentConfig,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Flags = CSRF_RENEWCACERT | CSRF_NEWKEYS;
    WCHAR *pwszParentMachine = NULL;
    WCHAR *pwszParentCA = NULL;
    WCHAR *pwszRequestFile = NULL;

    if (NULL != pwszReuseKeys)
    {
	if (0 == lstrcmpi(pwszReuseKeys, L"ReuseKeys"))
	{
	    Flags &= ~CSRF_NEWKEYS;
	}
	else if (NULL == pwszParentConfig)
	{
	    pwszParentConfig = pwszReuseKeys;
	}
	if (NULL != pwszParentConfig)
	{
	    hr = mySplitConfigString(
			    pwszParentConfig,
			    &pwszParentMachine,
			    &pwszParentCA);
	    _JumpIfErrorStr(hr, error, "mySplitConfigString", pwszParentConfig);
	}
    }

    hr = RequestCACertificateAndComplete(
			        Flags,			// Flags
			        pwszParentMachine,	// pwszParentMachine
			        pwszParentCA,		// pwszParentCA
				NULL,			// pwszfnCACert
				&pwszRequestFile);	// ppwszRequestFile
    _JumpIfError(hr, error, "RequestCACertificateAndComplete");

    if (NULL != pwszRequestFile)
    {
	wprintf(
	    L"%ws %ws\n",
	    myLoadResourceString(IDS_REQUEST_FILE_COLON),
	    pwszRequestFile);
    }

error:
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszParentMachine)
    {
        LocalFree(pwszParentMachine);
    }
    if (NULL != pwszParentCA)
    {
        LocalFree(pwszParentCA);
    }
    return(hr);
}


VOID
cuPrintVRootDisposition(
    IN DWORD idmsg,
    IN DWORD Disposition)
{
    DWORD idDisp = 0;
    
    switch (Disposition)
    {
	case VFD_CREATED:      idDisp = IDS_VROOTDISP_CREATED;      break;
	case VFD_DELETED:      idDisp = IDS_VROOTDISP_DELETED;      break;
	case VFD_EXISTS:       idDisp = IDS_VROOTDISP_EXISTS;       break;
	case VFD_NOTFOUND:     idDisp = IDS_VROOTDISP_NOTFOUND;     break;
	case VFD_CREATEERROR:  idDisp = IDS_VROOTDISP_CREATEERROR;  break;
	case VFD_DELETEERROR:  idDisp = IDS_VROOTDISP_DELETERROR;   break;
	case VFD_NOTSUPPORTED: idDisp = IDS_VROOTDISP_NOTSUPPORTED; break;
    }
    if (0 != idDisp)
    {
	wprintf(myLoadResourceString(idmsg), myLoadResourceString(idDisp));
	wprintf(wszNewLine);
    }
}


HRESULT
verbCreateVRoots(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszDelete,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD VRootDisposition = 0;
    DWORD ShareDisposition = 0;
    DWORD Flags;

    WCHAR* pwszPath = NULL;
    ENUM_CATYPES CAType = ENUM_UNKNOWN_CA;
    DWORD cb = sizeof(ENUM_CATYPES);
    DWORD dwType;
    HKEY hkey = NULL;

    hr = myRegOpenRelativeKey(
			NULL,
			L"ca",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,           // ppwszName
			&hkey);
    if (S_OK == hr)
    {
	cb = sizeof(CAType);
	hr = RegQueryValueEx(
			 hkey,
			 wszREGCATYPE,
			 0,
			 &dwType,
			 (BYTE *) &CAType,
			 &cb);
	_JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGCATYPE);
    }
    else
    {
	hr = myRegOpenRelativeKey(
			NULL,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,           // ppwszName
			&hkey);
	_JumpIfError(hr, error, "myRegOpenRelativeKey");

	cb = sizeof(CAType);
	hr = RegQueryValueEx(
			 hkey,
			 wszREGWEBCLIENTCATYPE,
			 0,
			 &dwType,
			 (BYTE *) &CAType,
			 &cb);
	_JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGWEBCLIENTCATYPE);
    }

    if (0 != lstrcmpi(pwszDelete, L"delete"))
    {
	Flags = VFF_CREATEVROOTS | VFF_CREATEFILESHARES | VFF_CLEARREGFLAGIFOK;
    }
    else
    {
	Flags = VFF_DELETEVROOTS | VFF_DELETEFILESHARES;
    }

    hr = myModifyVirtualRootsAndFileShares(
				    Flags,
                                    CAType,
                                    FALSE,     // synchronous -- blocking call
				    INFINITE,  // will block for good
				    &VRootDisposition,
				    &ShareDisposition);
    cuPrintVRootDisposition(IDS_FORMAT_VROOT, VRootDisposition);
    cuPrintVRootDisposition(IDS_FORMAT_FILESHARE, ShareDisposition);
    _JumpIfError(hr, error, "myModifyVirtualRootsAndFileShares");

error:
    if (pwszPath)
       LocalFree(pwszPath);
    if (hkey)
       RegCloseKey(hkey);

    return(hr);
}


HRESULT
cuPingCertSrv(
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    WCHAR *pwszzCANames = NULL;
    DWORD dwServerVersion;
    WCHAR wszVersion[12];

    wprintf(
	myLoadResourceString(IDS_FORMAT_CONNECTING), // "Connecting to %ws"
	pwszConfig);

    hr = myPingCertSrv(
		pwszConfig,
		NULL,
		&pwszzCANames,
		NULL,
		NULL,
		&dwServerVersion,
                NULL);
    wprintf(wszNewLine);
    if (S_OK != hr)
    {
	cuPrintErrorAndString(
		    NULL,
		    IDS_FORMAT_SERVER_DEAD, // "Server could not be reached: %ws"
		    hr,
		    NULL);
    }
    _JumpIfError(hr, error, "Ping");

    if (1 == dwServerVersion)
    {
	wszVersion[0] = L'\0';
    }
    else
    {
	swprintf(wszVersion, L"%u", dwServerVersion);
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_SERVER_ALIVE), // "Server ""%ws"" ICertRequest%ws interface is alive"
	pwszzCANames,		// Assume only one CA Name for now
	wszVersion);

error:
    wprintf(wszNewLine);
    if (NULL != pwszzCANames)
    {
	LocalFree(pwszzCANames);
    }
    return(hr);
}


HRESULT
verbPing(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = cuPingCertSrv(g_pwszConfig);
    _JumpIfError(hr, error, "cuPingCertSrv");

error:
    return(hr);
}


HRESULT
OpenAdminServer(
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OUT DWORD *pdwServerVersion,
    OUT ICertAdminD2 **ppICertAdminD)
{
    HRESULT hr;

    *pdwServerVersion = 0;
    hr = myOpenAdminDComConnection(
			g_pwszConfig,
			ppwszAuthority,
			NULL,
			pdwServerVersion,
			ppICertAdminD);
    _JumpIfError(hr, error, "myOpenDComConnection");

    CSASSERT(0 != *pdwServerVersion);

error:
    return(hr);
}


VOID
CloseAdminServer(
    IN OUT ICertAdminD2 **ppICertAdminD)
{
    myCloseDComConnection((IUnknown **) ppICertAdminD, NULL);
}


HRESULT
verbPingAdmin(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    ICertAdminD2 *pICertAdminD = NULL;
    WCHAR const *pwszAuthority;
    WCHAR wszVersion[12];
    DWORD dwServerVersion = 0;

    wprintf(
	myLoadResourceString(IDS_FORMAT_CONNECTING), // "Connecting to %ws"
	g_pwszConfig);

    hr = OpenAdminServer(&pwszAuthority, &dwServerVersion, &pICertAdminD);
    _JumpIfError(hr, error, "OpenAdminServer");

    CSASSERT(0 != dwServerVersion);

    if (1 == dwServerVersion)
    {
	wszVersion[0] = L'\0';
    }
    else
    {
	swprintf(wszVersion, L"%u", dwServerVersion);
    }
    if (2 <= dwServerVersion)
    {
	hr = pICertAdminD->Ping2(pwszAuthority);
	_JumpIfError(hr, error, "Ping2");
    }
    else
    {
	hr = pICertAdminD->Ping(pwszAuthority);
	_JumpIfError(hr, error, "Ping");
    }

    wprintf(wszNewLine);
    wprintf(
	myLoadResourceString(IDS_ADMIN_INTERFACE_ALIVE), // "Server ICertAdmin%ws interface is alive"
	wszVersion);

error:
    wprintf(wszNewLine);
    if (NULL != pICertAdminD)
    {
	CloseAdminServer(&pICertAdminD);
    }
    return(hr);
}


HRESULT
verbGetMapiInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszProfileName = NULL;
    WCHAR *pwszLogonName = NULL;
    WCHAR *pwszPassword = NULL;
    DWORD cwc;

    hr = myGetMapiInfo(NULL, &pwszProfileName, &pwszLogonName, &pwszPassword);
    _JumpIfError2(
	    hr,
	    error,
	    "myGetMapiInfo",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    wprintf(L"\"%ws\" \"%ws\" \"", pwszProfileName, pwszLogonName);
    for (cwc = wcslen(pwszPassword); cwc != 0; cwc--)
    {
	wprintf(L"*");
    }
    wprintf(L"\"\n");
    hr = S_OK;

error:
    if (NULL != pwszProfileName)
    {
	LocalFree(pwszProfileName);
    }
    if (NULL != pwszLogonName)
    {
	LocalFree(pwszLogonName);
    }
    if (NULL != pwszPassword)
    {
	cwc = wcslen(pwszPassword);
	ZeroMemory(pwszPassword, cwc * sizeof(WCHAR));
	LocalFree(pwszPassword);
    }
    return(hr);
}


HRESULT
verbSetMapiInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszProfileName,
    IN WCHAR const *pwszLogonName,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR wszPassword[MAX_PATH];

    verbGetMapiInfo(pwszOption, NULL, NULL, NULL, NULL);

    if (NULL != pwszLogonName && 0 == wcscmp(L"*", pwszLogonName))
    {
	pwszLogonName = NULL;
    }
    if (NULL == pwszLogonName)
    {
	pwszLogonName = pwszProfileName;
    }
    if (NULL == pwszPassword || 0 == wcscmp(L"*", pwszPassword))
    {
	hr = cuGetPassword(TRUE, wszPassword, ARRAYSIZE(wszPassword));
	_JumpIfError(hr, error, "cuGetPassword");

	pwszPassword = wszPassword;
    }
    hr = mySaveMapiInfo(NULL, pwszProfileName, pwszLogonName, pwszPassword);
    _JumpIfError(hr, error, "mySaveMapiInfo");

    hr = verbGetMapiInfo(pwszOption, NULL, NULL, NULL, NULL);
    _JumpIfError(hr, error, "verbGetMapiInfo");

error:
    return(hr);
}


HRESULT
verbGetCertFromUI(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszObjId,
    IN WCHAR const *pwszCNArg,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR const *apwszArgs[2];
    char *pszObjId = NULL;
    WCHAR const *pwszCommonName = NULL;
    CERT_CONTEXT const *pCert = NULL;
    BOOL fKRA = FALSE;
    BOOL fERA = FALSE;
    DWORD i;

    if (NULL != pwszObjId)
    {
	hr = S_FALSE;
	if (iswdigit(*pwszObjId))
	{
	    hr = myVerifyObjId(pwszObjId);
	    if (S_OK == hr)
	    {
		if (!myConvertWszToSz(&pszObjId, pwszObjId, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "myConvertWszToSz");
		}
		cuDumpOIDAndDescriptionA(pszObjId);
		wprintf(wszNewLine);
	    }
	}
	if (S_OK != hr)
	{
	    if (0 == lstrcmpi(L"KRA", pwszObjId))
	    {
		fKRA = TRUE;
	    }
	    else if (0 == lstrcmpi(L"ERA", pwszObjId))
	    {
		fERA = TRUE;
	    }
	    else
	    {
		pwszCommonName = pwszObjId;
	    }
	}
    }
    if (NULL != pwszCNArg)
    {
	if (NULL != pwszCommonName)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad arg");
	}
	pwszCommonName = pwszCNArg;
    }

    if (fKRA)
    {
	hr = myGetKRACertificateFromPicker(
				g_hInstance,
				NULL,		// hwndParent
				IDS_GETCERT_TITLE,
				IDS_GETCERT_SUBTITLE_KRA,
				pwszCommonName,
                                TRUE,		// is DS available?
				g_fCryptSilent,
				&pCert);
	_JumpIfError(hr, error, "myGetKRACertificateFromPicker");
    }
    else if (fERA)
    {
	hr = myGetERACertificateFromPicker(
				g_hInstance,
				NULL,		// hwndParent
				IDS_GETCERT_TITLE,
				IDS_GETCERT_SUBTITLE_ERA,
				pwszCommonName,
				g_fCryptSilent,
				&pCert);
	_JumpIfError(hr, error, "myGetERACertificateFromPicker");
    }
    else
    {
	hr = myGetCertificateFromPicker(
				g_hInstance,
				NULL,		// hwndParent
				IDS_GETCERT_TITLE,
				NULL != pszObjId?
				    IDS_GETCERT_SUBTITLE_OBJID :
				    IDS_GETCERT_SUBTITLE,

				// dwFlags: HKLM+HKCU My store
				CUCS_MYSTORE |
				    CUCS_CASTORE |
				    CUCS_KRASTORE |
				    CUCS_ROOTSTORE |

				    CUCS_MACHINESTORE |
				    CUCS_USERSTORE |
				    CUCS_DSSTORE |
				    (g_fCryptSilent? CUCS_SILENT : 0),
				pwszCommonName,
				0,
				NULL,
				NULL != pszObjId? 1 : 0,	// cpszObjId
				NULL != pszObjId? &pszObjId : NULL,
				&pCert);
	_JumpIfError(hr, error, "myGetCertificateFromPicker");
    }

    if (NULL != pCert)
    {
        hr = cuDumpAsnBinary(
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			MAXDWORD);
        _JumpIfError(hr, error, "cuDumpAsnBinary(cert)");
    }

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != pszObjId)
    {
        LocalFree(pszObjId);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"certut"

#include <windows.h>
#include <stdlib.h>
#include <wincrypt.h>

#include "certsrv.h"

#include "certlib.h"
#include "csdisp.h"

#include "certutil.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\services\ca\tools\certut\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_APP                         		201
#define IDI_PRODUCT                     		202

#define IDS_DUMP_DESCRIPTION				301
#define IDS_GETCONFIG_DESCRIPTION			302
#define IDS_GETCONFIG2_DESCRIPTION			303
#define IDS_CAVERSION					304
#define IDS_DECODEHEX_DESCRIPTION			305
#define IDS_DECODE_DESCRIPTION				306
#define IDS_ENCODE_DESCRIPTION				307
#define IDS_DENY_DESCRIPTION				308
#define IDS_RESUBMIT_DESCRIPTION			309
#define IDS_REVOKE_DESCRIPTION				310
#define IDS_CRL_DESCRIPTION				311
#define IDS_GETCRL_DESCRIPTION				312
#define IDS_ISVALID_DESCRIPTION				313
#define IDS_SETATTRIBUTES_DESCRIPTION			314
#define IDS_SETEXTENSION_DESCRIPTION			315
#define IDS_CACERT_DESCRIPTION				316
#define IDS_CACHAIN_DESCRIPTION				317
#define IDS_IMPORTKMS_USAGEARGS				318
#define IDS_IMPORTKMS_DESCRIPTION			319
#define IDS_DB_DESCRIPTION				320
#define IDS_VERIFYKEYS_DESCRIPTION			321
#define IDS_VERIFY_DESCRIPTION				322
#define IDS_7F_DESCRIPTION				323
#define IDS_USAGE_DESCRIPTION				324
#define IDS_VERBOSE_DESCRIPTION				325
#define IDS_IDISPATCH_DESCRIPTION			326
#define IDS_REVERSE_DESCRIPTION				327
#define IDS_OPTIONS_USAGEARGS				328
#define IDS_CRL_REASON_UNRECOGNIZED			329
#define IDS_INFILEOUTFILE_USAGEARGS			330
#define IDS_SCHEMA_COLUMNHEADERS 			331
#define IDS_SCHEMA_COLUMNUNDERLINE			332
#define IDS_DENY_USAGEARGS				333
#define IDS_RESUBMIT_USAGEARGS				334
#define IDS_REVOKE_USAGEARGS				335
#define IDS_CRL_USAGEARGS				336
#define IDS_GETCRL_USAGEARGS				337
#define IDS_ISVALID_USAGEARGS				338
#define IDS_SETATTRIBUTES_USAGEARGS			339
#define IDS_SETEXTENSION_USAGEARGS			340
#define IDS_CACERT_USAGEARGS				341
#define IDS_CACHAIN_USAGEARGS				342
#define IDS_VERIFYKEYS_USAGEARGS			343
#define IDS_VERIFY_USAGEARGS				344
#define IDS_7F_USAGEARGS				345
#define IDS_ERR_NOMEMORY				346
#define IDS_FORMAT_USAGE_MISSINGNAMEDARG		347
#define IDS_FORMAT_USAGE_UNKNOWNARG			348
#define IDS_FORMAT_USAGE_MULTIPLEVERBARGS		349
#define IDS_USAGE_MISSINGARG				350
#define IDS_USAGE_TOOMANYARGS				351
#define IDS_USAGE_INTERNALVERBTABLEERROR		352
#define IDS_FORMAT_USAGE_EXTRAOPTION			353
#define IDS_USAGE_HEADER				354
#define IDS_USAGE_OPTIONS				355
#define IDS_USAGE_VERBS					356
#define IDS_OIDNAME_ARGDESCRIPTION			357
#define IDS_INDEXED					358
#define IDS_FORMAT_INPUT_LENGTH				359
#define IDS_NO_KEYAUTHORITYSERIAL			360
#define IDS_FORMAT_OUTPUT_LENGTH			361
#define IDS_ERR_FORMAT_DECODEFILE			362
#define IDS_ERR_FORMAT_ENCODETOFILE			363
#define IDS_ISSUER					364
#define IDS_SUBJECT					365
#define IDS_ERR_FORMAT_ISSUER_NOT_KEYAUTHORITY		366
#define IDS_ISSUER_IS_KEYAUTHORITY			367
#define IDS_NO_KEYAUTHORITY				368
#define IDS_SERIAL_NOT_KEYAUTHORITY			369
#define IDS_SERIAL_IS_KEYAUTHORITY			370
#define IDS_ISSUERNAME					371
#define IDS_KEYAUTHORITYNAME				372
#define IDS_KEYID					373
#define IDS_KEYAUTHORITYSERIAL				374
#define IDS_CASERIAL					375
#define IDS_PROCESSCOLON				376
#define IDS_TCAINFO_USAGEARGS				377
#define IDS_ERR_FORMAT_LOADKEYS				378
#define IDS_ERR_FORMAT_LOADCACERT			379
#define IDS_ERR_PUBLICKEY_MISMATCH			380
#define IDS_CONTAINER_PUBLIC_KEY			381
#define IDS_CERT_PUBLIC_KEY				382
#define IDS_FORMAT_KEY_IS_VERIFY			383
#define IDS_FORMAT_KEY_NOT_VERIFY			384
#define IDS_FORMAT_IS_REVOKED				385
#define IDS_ERR_FORMAT_VERIFY_REVSTATUS			386
#define IDS_CANNOT_CHECK_REVSTATUS			387
#define IDS_REVSTATUS_OK				388
#define IDS_FORMAT_LOADTESTCERT				389
#define IDS_FORMAT_LOADCACERT				390
#define IDS_CERT					391
#define IDS_CA						392
#define IDS_CERT_SERIAL					393
#define IDS_ROOT_SERIAL					394
#define IDS_FORMAT_CA_NOT_ROOT				395
#define IDS_FORMAT_CA_SUBJECT_NOT_ISSUER		396
#define IDS_CA_SUBJECT_IS_ISSUER			397
#define IDS_FORMAT_CERTVERIFYSUBJECTCERTIFICATECONTEXT_FLAGS	398
#define IDS_ERR_FORMAT_VALIDATION			399
#define IDS_ERR_CA_SIG_NOT_ISSUER			400
#define IDS_ERR_EXPIRED					401
#define IDS_CURRENT_SIG_OK				402
#define IDS_CRL_DIST_POINTS				403
#define IDS_NETSCAPE_REVOCATION_URL			404
#define IDS_NO_REVCHECKEXTENSION			405
#define IDS_FORMAT_IS_VERIFY				406
#define IDS_FORMAT_NOT_VERIFY				407
#define IDS_FORMAT_REVCHECK_SKIPPED			408
#define IDS_FORMAT_REVCHECK_PASS			409
#define IDS_FORMAT_REVCHECK_REVOKED			410
#define IDS_FORMAT_REVCHECK_FAIL			411
#define IDS_SIGNATUREMATCHES				412
#define IDS_CRLENTRIES					413
#define IDS_CERTCOLON					414
#define IDS_QUESTIONMARKS				415
#define IDS_FORMAT_SUSPECT_LENGTH			416
#define IDS_FORMAT_FIELD				417
#define IDS_FORMAT_OID					418
#define IDS_FORMAT_EXTENSION_OID			419
#define IDS_ERR_FORMAT_NO_SIGNATUREMATCHES		420
#define IDS_ERR_FORMAT_CANNOT_DECODE			421
#define IDS_ALG_OID					422
#define IDS_ALG_PARAMETERS_COLON			423
#define IDS_NULL					424
#define IDS_FORMAT_PUBLICKEY_UNUSEDBITS			425
#define IDS_FORMAT_CHALLENGE_STRING			426
#define IDS_FORMAT_CONFIG_STRING			427
#define IDS_FORMAT_ICERTCONFIG_CONFIG_STRING		428
#define IDS_FORMAT_PENDING_REQUESTID			429
#define IDS_CERT_ISSUED					430
#define IDS_CERT_NOT_ISSUED_DISPOSITION			431
#define IDS_CERT_DISPOSITION_INVALID			432
#define IDS_CERT_DISPOSITION_VALID			433
#define IDS_CERT_DISPOSITION_REVOKED			434
#define IDS_PROPTYPE_DATE				435
#define IDS_PROPTYPE_LONG				436
#define IDS_PROPTYPE_STRING				437
#define IDS_PROPTYPE_BINARY				438
#define IDS_SCHEMA_COLON				439
#define IDS_FORMAT_ROWID				440
#define IDS_FORMAT_OPENING_DB				441
#define IDS_PROP_EMPTY					442
#define IDS_FORMAT_ERROR				443
#define IDS_SEPARATOR					444
#define IDS_REQTYPE_ANY					445
#define IDS_REQTYPE_PKCS10				446
#define IDS_REQTYPE_KEYGEN				447
#define IDS_REQTYPE_PKCS7				448
#define IDS_REQTYPE_UNKNOWN				449
#define IDS_REQFLAGS_FORCETELETEX			450
#define IDS_REQFLAGS_RENEWAL				451
#define IDS_CRITICAL					452
#define IDS_DISABLED					453
#define IDS_FORMAT_POLICYFLAGS				454
#define IDS_REQUEST					455
#define IDS_POLICY					45