 InterfaceName,
                FALSE
                );

            DebugDump(SERINITDEV,("Called IoSetDeviceInterfaceState(FALSE) . \n"));

            RtlFreeUnicodeString(
                InterfaceName
                );

            InterfaceName->Buffer = NULL;
        }

    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\open.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    serscan.c

Abstract:

    This module contains the code for a serial imaging devices driver
    Open and Create routines

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif

NTSTATUS
SerScanCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a create requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.
    !STATUS_SUCCESS - Failure.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;
    PIO_STACK_LOCATION  IrpSp;
    PFILE_OBJECT        FileObject;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // From the FileObject determine what mode we are running in.
    //
    // If FileObject->DeviceObject == DeviceObject, the user opened our device
    // and we will process each of the callbacks (Filter mode).
    //
    // If FileObject->DeviceObject != DeviceObject, the user opened PORTx
    // and we will get out of the way (PassThrough mode).
    //

    IrpSp      = IoGetCurrentIrpStackLocation (Irp);
    FileObject = IrpSp->FileObject;

    // ASSERT (FileObject == NULL);

    //
    // Are the DeviceObjects equal...
    //
    Extension->PassThrough = !(FileObject->DeviceObject == DeviceObject);

    //
    // Call down to the parent and wait on the CreateOpen IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [CreateOpen] After CallParent Status = %x\n",
              Status));

    //
    // WORKWORK:  If we are in filter mode, we'll connect here...
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
SerScanClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent and wait on the Close IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Close] After CallParent Status = %x\n",
              Status));

    //
    // WORKWORK:  If we are in filter mode we need to disconnect here...
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\serscan.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name :

    serscan.h

Abstract:

    Type definitions and data for the serial imaging driver.

Author:


Revision History:

--*/

#include "wdm.h"
//#include <ntddk.h>
#include <ntddser.h>

#if DBG
#define SERALWAYS             ((ULONG)0x00000000)
#define SERCONFIG             ((ULONG)0x00000001)
#define SERUNLOAD             ((ULONG)0x00000002)
#define SERINITDEV            ((ULONG)0x00000004)
#define SERIRPPATH            ((ULONG)0x00000008)
#define SERSTARTER            ((ULONG)0x00000010)
#define SERPUSHER             ((ULONG)0x00000020)
#define SERERRORS             ((ULONG)0x00000040)
#define SERTHREAD             ((ULONG)0x00000080)
#define SERDEFERED            ((ULONG)0x00000100)

extern ULONG SerScanDebugLevel;

#define DebugDump(LEVEL,STRING) \
        do { \
            ULONG _level = (LEVEL); \
            if ((_level == SERALWAYS)||(SerScanDebugLevel & _level)) { \
                DbgPrint ("SERSCAN.SYS:"); \
                DbgPrint STRING; \
            } \
        } while (0)

//
// macro for doing INT 3 (or non-x86 equivalent)
//

#if _X86_
#define DEBUG_BREAKPOINT() _asm int 3;
#else
#define DEBUG_BREAKPOINT() DbgBreakPoint()
#endif

#else
#define DEBUG_BREAKPOINT()
#define DebugDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'SerC')
#endif

//
// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
//
#define SERSCAN_LINK_NAME L"SERSCAN"

//
// This is the  class name.
//
#define SERSCAN_NT_SUFFIX L"serscan"


#define SERIAL_DATA_OFFSET 0
#define SERIAL_STATUS_OFFSET 1
#define SERIAL_CONTROL_OFFSET 2
#define SERIAL_REGISTER_SPAN 3

typedef struct _DEVICE_EXTENSION {

    //
    // Points to the device object that contains
    // this device extension.
    //
    PDEVICE_OBJECT DeviceObject;

    //
    //
    //
    PDEVICE_OBJECT Pdo;

    //
    // Points to the lower in stack  device object that this device is
    // connected to.
    //
    PDEVICE_OBJECT LowerDevice;

    //
    // To connect to lower object when opening
    //
    PDEVICE_OBJECT   AttachedDeviceObject;
    PFILE_OBJECT     AttachedFileObject;

    //
    //
    //
    PVOID          SerclassContext;
    ULONG          HardwareCapabilities;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time.  If we didn't create it, we won't try
    // to distroy it when we unload.
    //
    BOOLEAN         CreatedSymbolicLink;

    //
    // This points to the symbolic link name that was
    // linked to the actual nt device name.
    //
    UNICODE_STRING  SymbolicLinkName;

    //
    // This points to the class name used to create the
    // device and the symbolic link.  We carry this
    // around for a short while...
    UNICODE_STRING  ClassName;

    //
    //
    //
    UNICODE_STRING  InterfaceNameString;


    //
    // This tells us whether we are in a passthrough
    // or filtering mode.
    BOOLEAN         PassThrough;

    //
    // Number of opens on this device
    //
    ULONG          OpenCount;
    //
    // Access control
    //
    // ERESOURCE       Resource;
    FAST_MUTEX      Mutex;

    KSPIN_LOCK      SpinLock;

    //
    // Life span control
    //
    LONG            ReferenceCount;
    BOOLEAN         Removing;

    KEVENT          RemoveEvent;
    KEVENT          PdoStartEvent;

    //KEVENT          PendingIoEvent;
    //ULONG           PendingIoCount;

    DEVICE_POWER_STATE  SystemPowerStateMap[PowerSystemMaximum];

    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Bit Definitions in the status register.
//

#define SER_STATUS_NOT_ERROR   0x08  //not error on device
#define SER_STATUS_SLCT        0x10  //device is selected (on-line)
#define SER_STATUS_PE          0x20  //paper empty
#define SER_STATUS_NOT_ACK     0x40  //not acknowledge (data transfer was not ok)
#define SER_STATUS_NOT_BUSY    0x80  //operation in progress

//
//  Bit Definitions in the control register.
//

#define SER_CONTROL_STROBE      0x01 //to read or write data
#define SER_CONTROL_AUTOFD      0x02 //to autofeed continuous form paper
#define SER_CONTROL_NOT_INIT    0x04 //begin an initialization routine
#define SER_CONTROL_SLIN        0x08 //to select the device
#define SER_CONTROL_IRQ_ENB     0x10 //to enable interrupts
#define SER_CONTROL_DIR         0x20 //direction = read
#define SER_CONTROL_WR_CONTROL  0xc0 //the 2 highest bits of the control
                                     // register must be 1
#define StoreData(RegisterBase,DataByte)                            \
{                                                                   \
    PUCHAR _Address = RegisterBase;                                 \
    UCHAR _Control;                                                 \
    _Control = GetControl(_Address);                                \
    ASSERT(!(_Control & SER_CONTROL_STROBE));                       \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(SER_CONTROL_STROBE | SER_CONTROL_DIR)) \
        );                                                          \
    WRITE_PORT_UCHAR(                                               \
        _Address+SERIAL_DATA_OFFSET,                              \
        (UCHAR)DataByte                                             \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)((_Control | SER_CONTROL_STROBE) & ~SER_CONTROL_DIR) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(SER_CONTROL_STROBE | SER_CONTROL_DIR)) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)_Control                                             \
        );                                                          \
}

#define GetControl(RegisterBase) \
    (READ_PORT_UCHAR((RegisterBase)+SERIAL_CONTROL_OFFSET))

#define StoreControl(RegisterBase,ControlByte)  \
{                                               \
    WRITE_PORT_UCHAR(                           \
        (RegisterBase)+SERIAL_CONTROL_OFFSET, \
        (UCHAR)ControlByte                      \
        );                                      \
}

#define GetStatus(RegisterBase) \
    (READ_PORT_UCHAR((RegisterBase)+SERIAL_STATUS_OFFSET))


//
// Macros
//

//
// Prototypes
//
NTSTATUS
SerScanCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
SerScanPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID
SerScanUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
SerScanHandleSymbolicLink(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );

NTSTATUS
SerScanPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
SerScanAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
SerScanPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

BOOLEAN
SerScanMakeNames(
    IN  ULONG           SerialPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
SerScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

NTSTATUS
SerScanSynchCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          Event
    );

NTSTATUS
SerScanCompleteIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

#define WAIT        1
#define NO_WAIT     0

NTSTATUS
SerScanCallParent(
    IN PDEVICE_EXTENSION        Extension,
    IN PIRP                     Irp,
    IN BOOLEAN                  Wait,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine
    );

NTSTATUS
SerScanQueueIORequest(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP              Irp
    );

VOID
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    );

LONG
SSDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    );

NTSTATUS
WaitForLowerDriverToCompleteIrp(
   PDEVICE_OBJECT    TargetDeviceObject,
   PIRP              Irp,
   PKEVENT           Event
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     WIA kernel mode driver
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=serscan
TARGETTYPE=DRIVER
TARGETPATH=$(OBJ_DIR)

SOURCES=..\serscan.c   \
        ..\util.c      \
        ..\pnppwr.c    \
        ..\open.c      \
        ..\rdwr.c      \
        ..\ioctl.c     \
        ..\serlog.mc   \
        ..\serscan.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\chicago\serlog.h ===
#ifndef _SERLOG_
#define _SERLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SER_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough memory was available to allocate internal storage needed for the device %1.
//
#define SER_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0040001L)

//
// MessageId: SER_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %1.
//
#define SER_NO_SYMLINK_CREATED           ((NTSTATUS)0x80040002L)

//
// MessageId: SER_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %1.
//
#define SER_NO_DEVICE_MAP_CREATED        ((NTSTATUS)0x80040003L)

//
// MessageId: SER_CANT_FIND_PORT_DRIVER
//
// MessageText:
//
//  Unable to get device object pointer for port object.
//
#define SER_CANT_FIND_PORT_DRIVER        ((NTSTATUS)0xC0040004L)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\util.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the code for a serial imaging devices driver
    miscellaneous utility functions


Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif



NTSTATUS
SerScanSynchCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PKEVENT          Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp          - Irp that just completed

    Event        - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    KeSetEvent((PKEVENT) Event, 0, FALSE);

    return (STATUS_MORE_PROCESSING_REQUIRED);

}

NTSTATUS
SerScanCompleteIrp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp          - Irp that just completed

    Event        - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{

    NTSTATUS    Status;

    //
    // WORKWORK  Do any post IO processing here...
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending (Irp);
    }

    Status = Irp->IoStatus.Status;

    return (Status);

}

NTSTATUS
SerScanCallParent(
    IN PDEVICE_EXTENSION        Extension,
    IN PIRP                     pIrp,
    IN BOOLEAN                  Wait,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine
    )

/*++

Routine Description:

    This routine will call the next driver in the WDM chain

Arguments:

    Extension    - Device Extension.

    Irp          - Irp to call parent with.

Return Value:

    NTSTATUS.

--*/

{
    PIO_STACK_LOCATION              pIrpStack;
    PIO_STACK_LOCATION              pNextIrpStack;
    KEVENT                          Event;
    PVOID                           Context;
    NTSTATUS                        Status;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    Context = NULL;

    //
    // Prepare to call down to the parent with the I/O Request...
    //

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);
    pNextIrpStack->MajorFunction = pIrpStack->MajorFunction;
    pNextIrpStack->MinorFunction = pIrpStack->MinorFunction;

    RtlCopyMemory(&pNextIrpStack->Parameters,
                  &pIrpStack->Parameters,
                  sizeof(pIrpStack->Parameters.Others));

    if (Wait) {

        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        CompletionRoutine = SerScanSynchCompletionRoutine;
        Context = (PVOID)&Event;

    }

    IoSetCompletionRoutine(
        pIrp,
        CompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call down to our parent
    //

    Status = IoCallDriver(Extension->LowerDevice, pIrp);

    if (Wait && Status == STATUS_PENDING) {

        //
        // Still pending, wait for the IRP to complete
        //

        KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE, NULL);

        Status = pIrp->IoStatus.Status;

    }

    return Status;
}



VOID
SerScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                            device.

    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.

    P1,P2               - Supplies the physical addresses for the controller
                            ports involved with the error if they are available
                            and puts them through as dump data.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                            has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;

    if (ARGUMENT_PRESENT(DeviceObject)) {

        ObjectToUse = DeviceObject;

    } else {

        ObjectToUse = DriverObject;

    }

    DumpToAllocate = 0;

    if (P1.LowPart != 0 || P1.HighPart != 0) {
        DumpToAllocate = (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    if (P2.LowPart != 0 || P2.HighPart != 0) {
        DumpToAllocate += (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));

    if (!ErrorLogEntry) {
        return;
    }

    ErrorLogEntry->ErrorCode         = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber    = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount        = RetryCount;
    ErrorLogEntry->UniqueErrorValue  = UniqueErrorValue;
    ErrorLogEntry->FinalStatus       = FinalStatus;
    ErrorLogEntry->DumpDataSize      = DumpToAllocate;

    if (DumpToAllocate) {

        RtlCopyMemory(ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

        if (DumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(((PUCHAR) ErrorLogEntry->DumpData) +
                          sizeof(PHYSICAL_ADDRESS), &P2,
                          sizeof(PHYSICAL_ADDRESS));
        }
    }

    IoWriteErrorLogEntry(ErrorLogEntry);
}


NTSTATUS
SerScanPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/
{

    PDEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT    AttachedDevice=Extension->AttachedDeviceObject;

    if (AttachedDevice != NULL) {

        //IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSkipCurrentIrpStackLocation(Irp);

        return IoCallDriver(
                   AttachedDevice,
                   Irp
                   );
    } else {

        Irp->IoStatus.Status = STATUS_PORT_DISCONNECTED;
        Irp->IoStatus.Information=0L;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );

        return STATUS_PORT_DISCONNECTED;

    }

}



VOID
RemoveReferenceAndCompleteRequest(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    NTSTATUS          StatusToReturn
    )

{

    PDEVICE_EXTENSION    Extension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&Extension->ReferenceCount);

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //

        KeSetEvent(
            &Extension->RemoveEvent,
            0,
            FALSE
            );

    }

    Irp->IoStatus.Status = StatusToReturn;

    IoCompleteRequest(
        Irp,
        IO_SERIAL_INCREMENT
        );

    return;


}

NTSTATUS
CheckStateAndAddReference(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
{

    PDEVICE_EXTENSION    Extension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL                OldIrql;

    InterlockedIncrement(&Extension->ReferenceCount);

    if (Extension->Removing) {
        //
        //  driver not accepting requests already
        //
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (irpSp->MajorFunction == IRP_MJ_POWER) {

            PoStartNextPowerIrp(Irp);
        }

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_UNSUCCESSFUL
            );

        return STATUS_UNSUCCESSFUL;

    }

    //InterlockedIncrement(&Extension->PendingIoCount);

    return STATUS_SUCCESS;

}

VOID
RemoveReference(
    PDEVICE_OBJECT    DeviceObject
    )

{
    PDEVICE_EXTENSION    Extension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&Extension->ReferenceCount);

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        KeSetEvent(
            &Extension->RemoveEvent,
            0,
            FALSE
            );

    }

    return;

}


NTSTATUS
WaitForLowerDriverToCompleteIrp(
   PDEVICE_OBJECT    TargetDeviceObject,
   PIRP              Irp,
   PKEVENT           Event
   )
{
    NTSTATUS         Status;

    KeResetEvent(Event);

    IoSetCompletionRoutine(
                 Irp,
                 SerScanSynchCompletionRoutine,
                 Event,
                 TRUE,
                 TRUE,
                 TRUE
                 );

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

         KeWaitForSingleObject(
             Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );
    }

    return Irp->IoStatus.Status;

}

#ifdef DEAD_CODE

VOID
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

    Performs interlocked increment of pending i/o counter.

Arguments:

    Device Object

Return Value:

    None

--*/
{

    PDEVICE_EXTENSION               Extension;

    Extension = (PDEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);

    InterlockedIncrement(&Extension -> PendingIoCount);
}


LONG
SSDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

    Performs interlocked decrement of i/o counter and when it eaches zero
    initiates device object destruction

Arguments:

    Device Object

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION           Extension;
    LONG                        ioCount;

    Extension = (PDEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);

    ioCount = InterlockedDecrement(&Extension -> PendingIoCount);

    if (0 == ioCount) {
        KeSetEvent(&Extension -> PendingIoEvent,1,FALSE);
    }

    return ioCount;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\debug.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.c

Abstract:

    Common code for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//
// Includes
//

#include "stddef.h"
#include "wdm.h"
#include "debug.h"

//
// Globals
//

ULONG   DebugTraceLevel = MIN_TRACE | DEBUG_FLAG_DISABLE;
// ULONG  DebugTraceLevel = MAX_TRACE | DEBUG_FLAG_DISABLE | TRACE_PROC_ENTER | TRACE_PROC_LEAVE;
LONG    AllocateCount = 0;
ULONG   DebugDumpMax    = MAX_DUMPSIZE;

PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("MyAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  NAME_POOLTAG);

#if DBG
    if(NULL == pvRet){
        DebugTrace(TRACE_ERROR,("MyAllocatePool: ERROR!! Cannot allocate pool.\n"));
    } else {
        if(++AllocateCount > MAXNUM_POOL){
            DebugTrace(TRACE_WARNING,("MyAllocatePool: WARNING!! Allocate called %dtimes more than Free\n", MAXNUM_POOL));
        }
        DebugTrace(TRACE_STATUS,("MyAllocatePool: Count = %d\n", AllocateCount));
    }
#endif // DBG

    DebugTrace(TRACE_PROC_LEAVE,("MyAllocatePool: Leaving.. pvRet = %x\n", pvRet));
    return pvRet;
}


VOID
MyFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

#if DBG
    {
        ULONG ulTag;
    
        ulTag = *((PULONG)pvAddress-1);
//        if( (NAME_POOLTAG == ulTag) || (DebugTraceLevel & TRACE_IGNORE_TAG) ){
        if(NAME_POOLTAG == ulTag){
            if(--AllocateCount < 0){
                DebugTrace(TRACE_WARNING,("MyFreePool: Warning!! Free called more than Allocate.\n"));
            }
        } else {
            DebugTrace(TRACE_WARNING,("MyFreePool: WARNING!! tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ));
        }
    }
#endif

    ExFreePool(pvAddress);

    DebugTrace(TRACE_PROC_LEAVE,("MyFreePool: Leaving.. Return = NONE\n"));
}


#if DBG
VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
)
/*++

Routine Description:

    Read DebugTraceLevel key from driver's registry if exists.

Arguments:

    pRegistryPath   -   pointer to a unicode string representing the path
                        to driver-specific key in the registry

Return Value:

    none.

--*/
{

    HANDLE                          hDriverRegistry;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  unicodeKeyName;
    ULONG                           DataSize;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    NTSTATUS                        Status;
    
    DebugTrace(TRACE_PROC_ENTER,("MyDebugInit: Enter... \n"));
    
    //
    // Initialize local variables.
    //
    
    Status          = STATUS_SUCCESS;
    hDriverRegistry = NULL;
    pValueInfo      = NULL;
    DataSize        = 0;

    //
    // Initialize object attribute and open registry key.
    //
    
    RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
    InitializeObjectAttributes(&ObjectAttributes,
                               pRegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    Status = ZwOpenKey(&hDriverRegistry,
                       KEY_READ,
                       &ObjectAttributes);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! Can't open driver registry key.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Read "DebugTraceLevel" key.
    //

    DebugTrace(TRACE_CRITICAL,("MyDebugInit: Query %wZ\\%ws.\n", pRegistryPath, REG_DEBUGLEVEL));

    //
    // Query required size.
    //
    
    RtlInitUnicodeString(&unicodeKeyName, REG_DEBUGLEVEL);
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if( (Status != STATUS_BUFFER_OVERFLOW)
     && (Status != STATUS_BUFFER_TOO_SMALL)
     && (Status != STATUS_SUCCESS) )
    {
        if(Status == STATUS_OBJECT_NAME_NOT_FOUND){
            DebugTrace(TRACE_STATUS,("MyDebugInit: DebugTraceLevel doesn't exist. Use default(0x%x).\n", DebugTraceLevel));
        } else {
            DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        }
        goto MyDebugInit_return;
    }
    
    //
    // Check size of data.
    //
    
    if (MAX_TEMPBUF < DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! DataSize (0x%x) is too big.\n", DataSize));
        goto MyDebugInit_return;
    }

    if (0 == DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! Cannot retrieve required data size.\n"));
        goto MyDebugInit_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pValueInfo = MyAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pValueInfo){
        DebugTrace(TRACE_CRITICAL, ("MyDebugInit: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto MyDebugInit_return;
    }
    RtlZeroMemory(pValueInfo, DataSize+2);

    //
    // Query specified value.
    //
    
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pValueInfo,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! ZwQueryValueKey failed.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Set DebugTraceLevel.
    //
    
    DebugTraceLevel = *((PULONG)pValueInfo->Data);
    DebugTrace(TRACE_CRITICAL, ("MyDebugInit: Reg-key found. DebugTraceLevel=0x%x.\n", *((PULONG)pValueInfo->Data)));

MyDebugInit_return:

    //
    // Clean up.
    //
    
    if(pValueInfo){
        MyFreePool(pValueInfo);
    }
    
    if(NULL != hDriverRegistry){
        ZwClose(hDriverRegistry);
    }

    DebugTrace(TRACE_PROC_LEAVE,("MyDebugInit: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;
}

VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
)
{
    NTSTATUS    Status;
    ULONG       ulCounter;
    ULONG       ulMaxSize;

    //
    // Check the flag first.
    //

    if(bRead){
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_READ)){
            return;
        }
    } else { // if(bRead)
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_WRITE)){
            return;
        }
    } // if(bRead)

    DebugTrace(TRACE_PROC_ENTER,("MyDebugDump: Enter... \n"));
        
    //
    // Initialize local.
    //
        
    Status          = STATUS_SUCCESS;
    ulCounter       = 0;
    ulMaxSize       = DebugDumpMax;
    
    //
    // Check the arguments.
    //
        
    if(NULL == pDumpBuffer){
        DebugTrace(TRACE_WARNING,("MyDebugDump: WARNING!! pDumpBuffer = NULL \n"));
        Status = STATUS_INVALID_PARAMETER_1;
        goto MyDumpMemory_return;
    }

    if(0 == dwSize){
        DebugTrace(TRACE_STATUS,("MyDebugDump: WARNING!! dwSize = 0 \n"));
        Status = STATUS_INVALID_PARAMETER_2;
        goto MyDumpMemory_return;
    }

    if(bRead){
        DebugTrace(TRACE_ERROR,("MyDebugDump: Received buffer. Size=0x%x.\n", dwSize));
    } else {
        DebugTrace(TRACE_ERROR,("MyDebugDump: Passing buffer. Size=0x%x.\n", dwSize));
    }

/*
    //
    // Probe the buffer.
    //

    try {
        ProbeForRead(pDumpBuffer,
                     dwSize,
                     sizeof(UCHAR));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DebugTrace(TRACE_ERROR,("MyDebugDump: Buffer pointer (0x%x) is invalid. Status=0x%x\n", pDumpBuffer, Status));
        goto MyDumpMemory_return;
    } // except
*/
    //
    // Max dump size = 1k;
    //
    
    ulMaxSize = min(ulMaxSize , dwSize);

    //
    // Dump the buffer.
    //
    
    for(ulCounter = 0; ulCounter < ulMaxSize; ulCounter++){
        if(0 == (ulCounter & 0xfF)){
            DbgPrint("\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("           +0 +1 +2 +3 +4 +5 +6 +7   +8 +9 +a +b +c +d +e +f\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("------------------------------------------------------------\n");
        }

        if(0 == (ulCounter & 0xf)){
            DbgPrint(NAME_DRIVER);
            DbgPrint("%p :", pDumpBuffer+ulCounter);
        }

        DbgPrint(" %02x", *(pDumpBuffer+ulCounter));

        if(0x7 == (ulCounter & 0xf)){
            DbgPrint(" -");
        }

        if(0xf == (ulCounter & 0xf)){
            DbgPrint("\n");
        }
    }

    DbgPrint("\n");
    DbgPrint(NAME_DRIVER);
    DbgPrint("------------------------------------------------------------\n\n");

MyDumpMemory_return:
    DebugTrace(TRACE_PROC_LEAVE,("MyDebugDump: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;

} // MyDumpMemory(

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\winnt\serlog.h ===
#ifndef _SERLOG_
#define _SERLOG_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SER_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Not enough memory was available to allocate internal storage needed for the device %1.
//
#define SER_INSUFFICIENT_RESOURCES       ((NTSTATUS)0xC0040001L)

//
// MessageId: SER_NO_SYMLINK_CREATED
//
// MessageText:
//
//  Unable to create the symbolic link for %1.
//
#define SER_NO_SYMLINK_CREATED           ((NTSTATUS)0x80040002L)

//
// MessageId: SER_NO_DEVICE_MAP_CREATED
//
// MessageText:
//
//  Unable to create the device map entry for %1.
//
#define SER_NO_DEVICE_MAP_CREATED        ((NTSTATUS)0x80040003L)

//
// MessageId: SER_CANT_FIND_PORT_DRIVER
//
// MessageText:
//
//  Unable to get device object pointer for port object.
//
#define SER_CANT_FIND_PORT_DRIVER        ((NTSTATUS)0xC0040004L)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\ocrw.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ocrw.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "usbscan.h"
#include "usbd_api.h"
#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USOpen)
#pragma alloc_text(PAGE, USClose)
#pragma alloc_text(PAGE, USFlush)
#pragma alloc_text(PAGE, USRead)
#pragma alloc_text(PAGE, USWrite)
#pragma alloc_text(PAGE, USGetPipeIndexToUse)
#pragma alloc_text(PAGE, USTransfer)
#endif

NTSTATUS
USOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

    This routine is called to establish a connection to the device
    class driver. It does no more than return STATUS_SUCCESS.

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                        Status;
    PUSBSCAN_DEVICE_EXTENSION       pde;
    PFILE_OBJECT                    fileObject;
    PUSBSCAN_FILE_CONTEXT           pFileContext;
    PIO_STACK_LOCATION              irpStack;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    ULONG                           nameLen, ix;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USOpen: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USOpen: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    //
    // Increment I/O processing counter.
    //
    
    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde         = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    irpStack    = IoGetCurrentIrpStackLocation (pIrp);
    fileObject  = irpStack->FileObject;
    pValueInfo  = NULL;

    Status      = STATUS_SUCCESS;

    //
    // Initialize file context.
    //
    
    fileObject->FsContext = NULL;
    
    //
    // Check if it's accepting requests.
    //
    
    if (FALSE == pde -> AcceptingRequests) {
        DebugTrace(TRACE_WARNING,("USOpen: WARNING!! Device isn't accepting request.\n"));
        Status = STATUS_DELETE_PENDING;
        goto USOpen_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USOpen: WARNING!! Device is suspended.\n"));
        Status = STATUS_DELETE_PENDING;
        goto USOpen_return;
    }

    //
    // Allocate file context buffer.
    //

    pFileContext = USAllocatePool(NonPagedPool, sizeof(USBSCAN_FILE_CONTEXT));
    if(NULL == pFileContext){
        DebugTrace(TRACE_CRITICAL,("USOpen: ERROR!! Can't allocate file context\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USOpen_return;
    }
    RtlZeroMemory(pFileContext, sizeof(USBSCAN_FILE_CONTEXT));
    
    //
    // Set allocated buffer to the context.
    //

    fileObject->FsContext = pFileContext;

    //
    // Check the length of CreateFile name to see if pipe is specified by prefix.
    //
    
    nameLen     = fileObject->FileName.Length;
    DebugTrace(TRACE_STATUS,("USOpen: CreateFile name=%ws, Length=%d.\n", fileObject->FileName.Buffer, nameLen));

    if (0 == nameLen) {

        //
        // Use default pipe
        //
        
        pFileContext->PipeIndex = -1;

    } else {

        //
        // Pipe number must be '\' + one digit , like '\0'.
        // length would be 4.
        //

        if( (4 != nameLen)
         || (fileObject->FileName.Buffer[1] < (WCHAR) '0')
         || (fileObject->FileName.Buffer[1] > (WCHAR) '9') )
        {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid CreateFile Name\n"));
            Status = STATUS_INVALID_PARAMETER;
        } else {
            pFileContext->PipeIndex = (LONG)(fileObject->FileName.Buffer[1] - (WCHAR) '0');

            //
            // Check if pipe index is lower than maximum
            //

            if(pFileContext->PipeIndex > (LONG)pde->NumberOfPipes){
                DebugTrace(TRACE_ERROR,("USOpen: ERROR!! Invalid pipe index(0x%x). Use default.\n", pFileContext->PipeIndex));
                pFileContext->PipeIndex = -1;
                Status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    // Read default timeout value from registry. If not exist, then set default.
    //
    
    // Timeout for Read.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_READ,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutRead = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(1) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_READ;
        }
    } else {
        pFileContext->TimeoutRead = USBSCAN_TIMEOUT_READ;
    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Read timeout=0x%xsec.\n", pFileContext->TimeoutRead));

    // Timeout for Write.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_WRITE,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutWrite = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(2) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_WRITE;
        }
    } else {
        pFileContext->TimeoutWrite = USBSCAN_TIMEOUT_WRITE;

    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Write timeout=0x%xsec.\n", pFileContext->TimeoutWrite));

    // Timeout for Event.
    Status = UsbScanReadDeviceRegistry(pde,
                                       USBSCAN_REG_TIMEOUT_EVENT,
                                       &pValueInfo);
    if(NT_SUCCESS(Status)){
        if(NULL != pValueInfo){
            pFileContext->TimeoutEvent = *((PULONG)pValueInfo->Data);
            USFreePool(pValueInfo);
            pValueInfo = NULL;
        } else {
            DebugTrace(TRACE_ERROR,("USOpen: ERROR!! UsbScanReadDeviceRegistry(3) succeeded but pValueInfo is NULL.\n"));
            pFileContext->TimeoutRead = USBSCAN_TIMEOUT_EVENT;
        }
    } else {
        pFileContext->TimeoutEvent = USBSCAN_TIMEOUT_EVENT;
    }
    DebugTrace(TRACE_STATUS,("USOpen: Default Event timeout=0x%xsec.\n", pFileContext->TimeoutEvent));
    
    //
    // Return successfully.
    //
    
    Status      = STATUS_SUCCESS;

USOpen_return:

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USOpen: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USOpen()

NTSTATUS
USFlush(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Close request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                   Status;
    PUSBSCAN_DEVICE_EXTENSION  pde;
    ULONG                      i;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USFlush: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USFlush: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USFlush: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount( pDeviceObject );

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status = STATUS_SUCCESS;
    for(i = 0; i < pde->NumberOfPipes; i++){
        if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
         && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
        {
            DebugTrace(TRACE_STATUS,("USFlush: Flushing Buffer[%d].\n",i));

            if (pde->ReadPipeBuffer[i].RemainingData > 0) {
                    DebugTrace(TRACE_STATUS,("USFlush: Buffer[%d] 0x%p -> 0x%p.\n",
                                                    i,
                                                    pde->ReadPipeBuffer[i].pBuffer,
                                                    pde->ReadPipeBuffer[i].pStartBuffer));
                    pde->ReadPipeBuffer[i].pBuffer = pde->ReadPipeBuffer[i].pStartBuffer;
                    pde->ReadPipeBuffer[i].RemainingData = 0;
            }
        }
    }

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USFlush: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USFlush()


NTSTATUS
USClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Close request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    PIO_STACK_LOCATION          pIrpStack;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USClose: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USClose: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USClose: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Free context buffer.
    //
    
    ASSERT(NULL != pFileContext);
    USFreePool(pFileContext);
    pFileContext = NULL;

    //
    // Complete.
    //
    
    Status      = STATUS_SUCCESS;

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USClose: Leaving.. Status = %x.\n", Status));
    return Status;

} // end USClose()


NTSTATUS
USRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Read request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       Timeout;
    PULONG                      pTimeout;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER,("USRead: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USRead: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USRead: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    ASSERT(pIrp -> MdlAddress);

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Check if it's accepting requests.
    //
    
    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_ERROR,("USRead: ERROR!! Read issued after device stopped/removed!\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USRead_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USRead: WARNING!! Device is suspended.\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USRead_return;
    }

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Copy timeout value for Read from file context.
    //
    
    Timeout = pFileContext->TimeoutRead;
    
    //
    // If timeout value is 0, then never timeout.
    //
    
    if(0 == Timeout){
        pTimeout = NULL;
    } else {
        DebugTrace(TRACE_STATUS,("USRead: Timeout is set to 0x%x sec.\n", Timeout));
        pTimeout = &Timeout;
    }

    //
    // Call worker funciton.
    //
    
    Status = USTransfer(pDeviceObject,
                        pIrp,
                        pde -> IndexBulkIn,
                        NULL,
                        pIrp -> MdlAddress,
                        pIrpStack -> Parameters.Read.Length,
                        pTimeout);
    //
    // IRP should be completed in USTransfer or its completion routine.
    //

USRead_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USRead: Leaving.. Status = %x.\n", Status));
    return Status;
}


NTSTATUS
USWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Write request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       Timeout;
    PULONG                      pTimeout;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USWrite: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USWrite: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USWrite: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount( pDeviceObject );

    //
    // Initialize locals.
    //
    
    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Check if it's accepting requests.
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_ERROR,("USWrite: ERROR!! Write issued after device stopped/removed!\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USWrite_return;
    }

    //
    // Check device power state.
    //
    
    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USWrite: WARNING!! Device is suspended.\n"));
        Status = STATUS_FILE_CLOSED;
        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        goto USWrite_return;
    }

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    //
    // Copy timeout value for Write from file context.
    //
    
    Timeout = pFileContext->TimeoutWrite;
    
    //
    // If timeout value is 0, then never timeout.
    //
    
    if(0 == Timeout){
        pTimeout = NULL;
    } else {
        DebugTrace(TRACE_STATUS,("USWrite: Timeout is set to 0x%x sec.\n", Timeout));
        pTimeout = &Timeout;
    }

    //
    // Call worker funciton.
    //

#if DBG
{
    PUCHAR  pDumpBuf = NULL;

    if (NULL != pIrp -> MdlAddress) {
        pIrp -> MdlAddress -> MdlFlags |= MDL_MAPPING_CAN_FAIL;
        pDumpBuf = MmGetSystemAddressForMdl(pIrp -> MdlAddress);
    }

    if(NULL != pDumpBuf){
        MyDumpMemory(pDumpBuf,
                     pIrpStack -> Parameters.Write.Length,
                     FALSE);
    }
}
#endif // DBG



    Status = USTransfer(pDeviceObject,
                        pIrp,
                        pde -> IndexBulkOut,
                        NULL,
                        pIrp -> MdlAddress,
                        pIrpStack -> Parameters.Write.Length,
                        pTimeout);

    //
    // IRP should be completed in USTransfer or its completion routine.
    //
    
USWrite_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USWrite: Leaving.. Status = %x.\n", Status));
    return Status;
}


NTSTATUS
USTransfer(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN ULONG            Index,
    IN PVOID            pBuffer,        //  Either pBuffer or pMdl
    IN PMDL             pMdl,           //  must be passed in.
    IN ULONG            TransferSize,
    IN PULONG           pTimeout
)
/*++

Routine Description:

Arguments:
    pDeviceObject   - Device object for a device.
    pOrigianlIrp    - Original IRP to Read/Write.

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pNextIrpStack;
    PTRANSFER_CONTEXT           pTransferContext;
    PURB                        pUrb;
    PUSBSCAN_PACKETS            pPackets;
    ULONG                       siz = 0;
    ULONG                       MaxPacketSize;
    ULONG                       MaxTransferSize;
    ULONG                       PipeIndex;
    BOOLEAN                     fNextReadBlocked;
    BOOLEAN                     fBulkIn;
    BOOLEAN                     fNeedCompletion;
    
    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USTransfer: Enter..\n"));

    //
    // Initialize status etc..
    //
    
    Status = STATUS_SUCCESS;
    fNeedCompletion = TRUE;

    pde                 = NULL;
    pNextIrpStack       = NULL;
    pTransferContext    = NULL;
    pUrb                = NULL;
    pPackets            = NULL;;

    //
    // Check the arguments.
    //

    if( (NULL == pIrp)
     || (   (NULL == pBuffer)
         && (NULL == pMdl)  
         && (0 != TransferSize) )
     || (Index > MAX_NUM_PIPES) )
    {
        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Invalid argment.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto USTransfer_return;
    }

    //
    // Initialize status etc..
    //
    
    pIrp -> IoStatus.Information = 0;
    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);

    //
    // Pickup PipeIndex to use
    //

    PipeIndex = USGetPipeIndexToUse(pDeviceObject,
                                    pIrp,
                                    Index);

    DebugTrace(TRACE_STATUS,("USTransfer: Transfer [pipe %d] called. size = %d, pBuffer = 0x%p, Mdl = 0x%p \n",
                               PipeIndex,
                               TransferSize,
                               pBuffer,
                               pMdl
                    ));

    MaxTransferSize = pde -> PipeInfo[PipeIndex].MaximumTransferSize;
    MaxPacketSize   = pde -> PipeInfo[PipeIndex].MaximumPacketSize;

    fBulkIn = ((pde->PipeInfo[PipeIndex].PipeType == UsbdPipeTypeBulk)
                && (pde->PipeInfo[PipeIndex].EndpointAddress & BULKIN_FLAG));

#if DBG
    if (TransferSize > MaxTransferSize) {
        DebugTrace(TRACE_STATUS,("USTransfer: Transfer > max transfer size.\n"));
    }
#endif

    ASSERT(PipeIndex <= MAX_NUM_PIPES);

    fNextReadBlocked = FALSE;

    if (fBulkIn) {

        //
        // Get exclusive access to each read buffer by using event
        //

        DebugTrace(TRACE_STATUS,("USTransfer: Waiting for Sync event for Pipe %d...\n", PipeIndex));

        if(NULL != pTimeout){
            LARGE_INTEGER  Timeout;
            
            Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(*pTimeout));
            Status = KeWaitForSingleObject(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, Executive, KernelMode, FALSE, &Timeout);
        } else {
            Status = KeWaitForSingleObject(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, Executive, KernelMode, FALSE, 0);
        }
        
        if(STATUS_SUCCESS != Status){
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
            DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! KeWaitForSingleObject() failed. Status=0x%x.\n", Status));
            if(STATUS_TIMEOUT == Status){
                Status = STATUS_IO_TIMEOUT;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
            goto USTransfer_return;
        } // if(STATUS_SUCCESS != Status)

        DebugTrace(TRACE_STATUS,("USTransfer: Get access to Pipe %d !!\n", PipeIndex));

        fNextReadBlocked = TRUE;

        //
        // If there is remaining data in the read pipe buffer, copy it into the irp transfer buffer.
        // Update the irp transfer pointer, number of bytes left to transfer, the read pipe buffer pointer
        // and the remaining number of bytes left in the read pipe buffer.
        //

        if (pde -> ReadPipeBuffer[PipeIndex].RemainingData > 0) {
            DebugTrace(TRACE_STATUS,("USTransfer: Copying %d buffered bytes into irp\n",
                                        pde -> ReadPipeBuffer[PipeIndex].RemainingData));
            siz = min(pde -> ReadPipeBuffer[PipeIndex].RemainingData, TransferSize);
            if (NULL == pBuffer) {

                //
                // There's no buffer. Try to use Mdl instead.
                //

                if(NULL == pMdl){

                    //
                    // Error: Both Buffer and Mdl are NULL.
                    //

                    Status = STATUS_INVALID_PARAMETER;
                    KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                    DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Both Buffer&Mdl=NULL.\n"));
                    goto USTransfer_return;

                } else {
                    pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                    pBuffer = MmGetSystemAddressForMdl(pMdl);
                    if(NULL == pBuffer){
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! MmGetSystemAddressForMdl failed.\n"));
                        goto USTransfer_return;
                    }
                    
                    pMdl = NULL;
                }
            }
            ASSERT(siz > 0);
            ASSERT(pBuffer);
            ASSERT(pde -> ReadPipeBuffer[PipeIndex].pBuffer);
            RtlCopyMemory(pBuffer,pde -> ReadPipeBuffer[PipeIndex].pBuffer, siz);
            pde -> ReadPipeBuffer[PipeIndex].pBuffer += siz;
            pde -> ReadPipeBuffer[PipeIndex].RemainingData -= siz;
            ASSERT((LONG)pde -> ReadPipeBuffer[PipeIndex].RemainingData >= 0);
            if (0 == pde -> ReadPipeBuffer[PipeIndex].RemainingData) {
                DebugTrace(TRACE_STATUS,("USTransfer: read buffer emptied.\n"));
                pde -> ReadPipeBuffer[PipeIndex].pBuffer = pde -> ReadPipeBuffer[PipeIndex].pStartBuffer;
            }
            (PUCHAR)(pBuffer) += siz;
            TransferSize -= siz;
            ASSERT((LONG)TransferSize >= 0);

            // If the read irp was completely satisfied from data in the read buffer, then
            // unblock the next pending read and return success.

            if (0 == TransferSize) {
                pIrp -> IoStatus.Information = siz;
                Status = STATUS_SUCCESS;
                KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                DebugTrace(TRACE_STATUS,("USTransfer: Irp satisfied from ReadBuffer.\n"));
                goto USTransfer_return;
            }
        } // if (pde -> ReadPipeBuffer[PipeIndex].RemainingData > 0)

        //
        // If this read is an integer number of usb packets, it will not affect
        // the state of the read buffer.  Unblock the next waiting read in this case.
        //

        if (0 == TransferSize % MaxPacketSize) {
            DebugTrace(MAX_TRACE,("USTransfer: Unblocking next read.\n"));
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
            fNextReadBlocked = FALSE;
        }
    } // if (fBulkIn) 

    //
    // Allocate and initialize Transfer Context
    //

    pTransferContext = USAllocatePool(NonPagedPool, sizeof(TRANSFER_CONTEXT));
    if (NULL == pTransferContext) {
        DebugTrace(TRACE_CRITICAL,("USTransfer: ERROR!! cannot allocated Transfer Context\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        if (fNextReadBlocked) {
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
        }
        goto USTransfer_return;
    }
    RtlZeroMemory(pTransferContext, sizeof(TRANSFER_CONTEXT));

    //
    // Allocate and initialize URB
    //

    pUrb = USAllocatePool(NonPagedPool, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USTransfer: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        if (fNextReadBlocked) {
            KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
        }
        goto USTransfer_return;
    }
    RtlZeroMemory(pUrb, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));

    ASSERT(pUrb);
    ASSERT(pTransferContext);

    pTransferContext -> fDestinedForReadBuffer  = FALSE;
    pTransferContext -> fNextReadBlocked        = fNextReadBlocked;
    pTransferContext -> RemainingTransferLength = TransferSize;
    pTransferContext -> ChunkSize               = TransferSize;
    pTransferContext -> PipeIndex               = PipeIndex;
    pTransferContext -> pTransferBuffer         = pBuffer;
    pTransferContext -> pTransferMdl            = pMdl;
    pTransferContext -> NBytesTransferred       = siz;
    pTransferContext -> pUrb                    = pUrb;
    pTransferContext -> pThisIrp                = pIrp;
    pTransferContext -> pDeviceObject           = pDeviceObject;

    //
    // IF the transfer is > MaxTransferSize, OR
    // IF the transfer is not a multiple of a USB packet AND it is a read transfer THEN
    //   Check if we have been passed an MDL.  If so, we need to turn it into a pointer so
    //     that we can advance it when the transfer is broken up into smaller transfers.
    //

    if( (pTransferContext -> ChunkSize > MaxTransferSize) 
     || ( (0 != pTransferContext -> ChunkSize % MaxPacketSize) 
       && (fBulkIn) ) )
    {
        if (NULL == pTransferContext -> pTransferBuffer) {
            DebugTrace(TRACE_STATUS,("USTransfer: Converting MDL to buffer pointer.\n"));
            ASSERT(pTransferContext -> pTransferMdl);
            pTransferContext -> pTransferMdl ->MdlFlags |= MDL_MAPPING_CAN_FAIL;

            pTransferContext -> pTransferBuffer = MmGetSystemAddressForMdl(pTransferContext -> pTransferMdl);
            pTransferContext -> pTransferMdl = NULL;
            ASSERT(pTransferContext -> pTransferBuffer);
            if(NULL == pTransferContext -> pTransferBuffer){
                Status = STATUS_INSUFFICIENT_RESOURCES;
                if (fNextReadBlocked) {
                    KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
                }
                goto USTransfer_return;
            }
        }
    }

    //
    // If chunksize is bigger than MaxTransferSize, then set it to MaxTransferSize.  The
    // transfer completion routine will issue additional transfers until the total size has
    // been transferred.
    //

    if (pTransferContext -> ChunkSize > MaxTransferSize) {
        pTransferContext -> ChunkSize = MaxTransferSize;
    }

    if (fBulkIn) {

        //
        // If this read is smaller than a USB packet, then issue a request for a
        // whole usb packet and make sure it goes into the read buffer first.
        //

        if (pTransferContext -> ChunkSize < MaxPacketSize) {
            DebugTrace(TRACE_STATUS,("USTransfer: Request is < packet size - transferring whole packet into read buffer.\n"));
            pTransferContext -> fDestinedForReadBuffer = TRUE;
            pTransferContext -> pOriginalTransferBuffer = pTransferContext -> pTransferBuffer;  // save off original transfer ptr.
            pTransferContext -> pTransferBuffer = pde -> ReadPipeBuffer[PipeIndex].pBuffer;
            pTransferContext -> ChunkSize = MaxPacketSize;
        }

        //
        // Truncate the size of the read to an integer number of packets.  If necessary,
        // the completion routine will handle any fractional remaining packets (with the read buffer).
        //

        pTransferContext -> ChunkSize = (pTransferContext -> ChunkSize / MaxPacketSize) * MaxPacketSize;
    }

//    ASSERT(pTransferContext -> RemainingTransferLength);
//    ASSERT((pTransferContext -> pTransferBuffer) || (pTransferContext -> pTransferMdl));
    ASSERT(pTransferContext -> pUrb);

    //
    // Initialize URB
    //

    UsbBuildInterruptOrBulkTransferRequest(pUrb,
                                           sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                                           pde ->PipeInfo[PipeIndex].PipeHandle,
                                           pTransferContext -> pTransferBuffer,
                                           pTransferContext -> pTransferMdl,
                                           pTransferContext -> ChunkSize,
                                           USBD_SHORT_TRANSFER_OK,
                                           NULL);

    //
    // Setup stack location for lower driver
    //

    pNextIrpStack -> MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    pNextIrpStack -> MinorFunction = 0;
    pNextIrpStack -> Parameters.DeviceIoControl.IoControlCode = (ULONG)IOCTL_INTERNAL_USB_SUBMIT_URB;
    pNextIrpStack -> Parameters.Others.Argument1 = pUrb;

    if(NULL != pTimeout){
        pTransferContext -> Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(*pTimeout));

        //
        // Initialize timer and DPC.
        //

        KeInitializeTimer(&(pTransferContext->Timer));
        KeInitializeDpc(&(pTransferContext->TimerDpc),
                        (PKDEFERRED_ROUTINE)USTimerDpc,
                        (PVOID)pIrp);
        //
        // Enqueue timer object for timeout.
        //
        
        DebugTrace(TRACE_STATUS,("USTransfer: Set timeout(0x%x x 100n sec).\n", -(pTransferContext -> Timeout.QuadPart)));
        if(KeSetTimer(&(pTransferContext->Timer),
                      pTransferContext -> Timeout,
                      &(pTransferContext->TimerDpc)))
        {
            DebugTrace(TRACE_ERROR,("USTransfer: Timer object already exist.\n"));
        }
        
    } else {
        DebugTrace(TRACE_STATUS,("USTransfer: No timeout for this IRP.\n"));
    }

    //
    // Increment processing I/O count, will be decremented in completion.
    //

    USIncrementIoCount( pDeviceObject );

    //
    // Mark pending to IRP.
    //
    
    IoMarkIrpPending(pIrp);

    //
    // Set Completion Routine.
    //
    
    IoSetCompletionRoutine(pIrp,
                           USTransferComplete,
                           pTransferContext,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down.
    //

    fNeedCompletion = FALSE;
    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
    if(STATUS_PENDING != Status){
        DebugTrace(TRACE_ERROR,("USTransfer: ERROR!! Lower driver returned 0x%x.\n", Status));
    }

    //
    // Must return STATUS_PENDING.
    //

    Status = STATUS_PENDING;

USTransfer_return:

    if(fNeedCompletion){
        DebugTrace(TRACE_STATUS,("USTransfer: Completeing IRP now.\n"));
        
        //
        // Error or data satisfied from buffer.
        //
        
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        if(NULL != pUrb){
            USFreePool(pUrb);
        }
        if(NULL != pTransferContext){
            USFreePool(pTransferContext);
        }
    }
    
    DebugTrace(TRACE_PROC_LEAVE,("USTransfer: Leaving.. Status = 0x%x.\n", Status));
    return Status;
}

NTSTATUS
USTransferComplete(
    IN PDEVICE_OBJECT       pPassedDeviceObject,
    IN PIRP                 pIrp,
    IN PTRANSFER_CONTEXT    pTransferContext
)
/*++

Routine Description:

Arguments:
    pPassedDeviceObject - Device object for a device.
    pIrp                - Read/write request packet
    pTransferContext    - context info for transfer

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PDEVICE_OBJECT              pDeviceObject;
    PURB                        pUrb;
    ULONG                       CompletedTransferLength;
    NTSTATUS                    CompletedTransferStatus;
    ULONG                       MaxPacketSize;
    BOOLEAN                     fShortTransfer = FALSE;
    BOOLEAN                     fBulkIn;
    ULONG                       PipeIndex;

    DebugTrace(TRACE_PROC_ENTER,("USTransferComplete: Enter.. - called. irp = 0x%p\n",pIrp));

    ASSERT(pIrp);
    ASSERT(pTransferContext);

    Status = pIrp -> IoStatus.Status;
    pIrp -> IoStatus.Information = 0;

    if(NULL == pPassedDeviceObject){
        pDeviceObject = pTransferContext->pDeviceObject;
    } else {
        pDeviceObject = pPassedDeviceObject;
    }

    pIrpStack     = IoGetCurrentIrpStackLocation(pIrp);
    pNextIrpStack = IoGetNextIrpStackLocation(pIrp);

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    PipeIndex = pTransferContext -> PipeIndex;
    MaxPacketSize =  pde -> PipeInfo[PipeIndex].MaximumPacketSize;

    fBulkIn = ((pde->PipeInfo[PipeIndex].PipeType == UsbdPipeTypeBulk)
            && (pde->PipeInfo[PipeIndex].EndpointAddress & BULKIN_FLAG));

    pUrb = pTransferContext -> pUrb;
    CompletedTransferLength = pUrb -> UrbBulkOrInterruptTransfer.TransferBufferLength;
    CompletedTransferStatus = pUrb -> UrbBulkOrInterruptTransfer.Hdr.Status;

    if( (STATUS_SUCCESS == CompletedTransferStatus) 
     && (STATUS_SUCCESS == Status) )
    {

        if (CompletedTransferLength < pTransferContext -> ChunkSize) {
            DebugTrace(TRACE_STATUS,("USTransferComplete: Short transfer received. Length = %d, ChunkSize = %d\n",
                                       CompletedTransferLength, pTransferContext -> ChunkSize));
            fShortTransfer = TRUE;
        }

        //
        // If this transfer went into the read buffer, then this should be the final read
        // of either a multipart larger read, or a single very small read (< single usb packet).
        // In either case, we need to copy the appropriate amount of data into the user's irp, update the
        // read buffer variables, and complete the user's irp.
        //

        if (pTransferContext -> fDestinedForReadBuffer) {
            DebugTrace(TRACE_STATUS,("USTransferComplete: Read transfer completed. size = %d\n", CompletedTransferLength));
            ASSERT(CompletedTransferLength <= MaxPacketSize);
            ASSERT(pTransferContext -> pOriginalTransferBuffer);
            ASSERT(pTransferContext -> pTransferBuffer);
            ASSERT(pde -> ReadPipeBuffer[PipeIndex].pBuffer == pTransferContext -> pTransferBuffer);
            ASSERT(pTransferContext -> RemainingTransferLength < MaxPacketSize);

            pde -> ReadPipeBuffer[PipeIndex].RemainingData = CompletedTransferLength;
            CompletedTransferLength = min(pTransferContext -> RemainingTransferLength,
                                 pde -> ReadPipeBuffer[PipeIndex].RemainingData);
            ASSERT(CompletedTransferLength < MaxPacketSize);
            RtlCopyMemory(pTransferContext -> pOriginalTransferBuffer,
                          pde -> ReadPipeBuffer[PipeIndex].pBuffer,
                          CompletedTransferLength);
            pde -> ReadPipeBuffer[PipeIndex].pBuffer += CompletedTransferLength;
            pde -> ReadPipeBuffer[PipeIndex].RemainingData -= CompletedTransferLength;

            if (0 == pde -> ReadPipeBuffer[PipeIndex].RemainingData) {
                DebugTrace(TRACE_STATUS,("USTransferComplete: Read buffer emptied.\n"));
                pde -> ReadPipeBuffer[PipeIndex].pBuffer = pde -> ReadPipeBuffer[PipeIndex].pStartBuffer;
            }
            pTransferContext -> pTransferBuffer = pTransferContext -> pOriginalTransferBuffer;
        }

        //
        // Update the number of bytes transferred, remaining bytes to transfer
        // and advance the transfer buffer pointer appropriately.
        //

        pTransferContext -> NBytesTransferred += CompletedTransferLength;
        if (pTransferContext -> pTransferBuffer) {
            pTransferContext -> pTransferBuffer += CompletedTransferLength;
        }
        pTransferContext -> RemainingTransferLength -= CompletedTransferLength;

        //
        // If there is still data to transfer and the previous transfer was NOT a
        // short transfer, then issue another request to move the next chunk of data.
        //

        if (pTransferContext -> RemainingTransferLength > 0) {
            if (!fShortTransfer) {

                DebugTrace(TRACE_STATUS,("USTransferComplete: Queuing next chunk. RemainingSize = %d, pBuffer = 0x%p\n",
                                           pTransferContext -> RemainingTransferLength,
                                           pTransferContext -> pTransferBuffer
                                          ));

                if (pTransferContext -> RemainingTransferLength < pTransferContext -> ChunkSize) {
                    pTransferContext -> ChunkSize = pTransferContext -> RemainingTransferLength;
                }

                //
                // Reinitialize URB
                //
                // If the next transfer is < than 1 packet, change it's destination to be
                // the read buffer.  When this transfer completes, the appropriate amount of data will be
                // copied out of the read buffer and into the user's irp.  Left over data in the read buffer
                // will be available for subsequent reads.
                //

                if (fBulkIn) {
                    if (pTransferContext -> ChunkSize < MaxPacketSize) {
                        pTransferContext -> fDestinedForReadBuffer = TRUE;
                        pTransferContext -> pOriginalTransferBuffer = pTransferContext -> pTransferBuffer;
                        pTransferContext -> pTransferBuffer = pde -> ReadPipeBuffer[PipeIndex].pBuffer;
                        pTransferContext -> ChunkSize = MaxPacketSize;
                    }
                    pTransferContext -> ChunkSize = (pTransferContext -> ChunkSize / MaxPacketSize) * MaxPacketSize;
                }

                ASSERT(pTransferContext -> ChunkSize >= MaxPacketSize);
                ASSERT(0 == pTransferContext -> ChunkSize % MaxPacketSize);
                UsbBuildInterruptOrBulkTransferRequest(pUrb,
                    sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER),
                    pde -> PipeInfo[PipeIndex].PipeHandle,
                    pTransferContext -> pTransferBuffer,
                    NULL,
                    pTransferContext -> ChunkSize,
                    USBD_SHORT_TRANSFER_OK,
                    NULL);
                IoSetCompletionRoutine(pIrp,
                                       USTransferComplete,
                                       pTransferContext,
                                       TRUE,
                                       TRUE,
                                       FALSE);

                //
                // Setup stack location for lower driver
                //

                pNextIrpStack -> MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
                pNextIrpStack -> MinorFunction = 0;
                pNextIrpStack -> Parameters.DeviceIoControl.IoControlCode = (ULONG)IOCTL_INTERNAL_USB_SUBMIT_URB;
                pNextIrpStack -> Parameters.Others.Argument1 = pUrb;

                IoCallDriver(pde -> pStackDeviceObject, pIrp);
                Status = STATUS_MORE_PROCESSING_REQUIRED;
                goto USTransferComplete_return;

            } // if (!fShortTransfer) 
        } // if (pTransferContext -> RemainingTransferLength > 0)

        DebugTrace(TRACE_STATUS,("USTransferComplete: Completing transfer request. nbytes transferred = %d, irp = 0x%p\n",
                                   pTransferContext -> NBytesTransferred, pIrp));

        pIrp -> IoStatus.Information = pTransferContext -> NBytesTransferred;

#if DBG
        {
            PUCHAR  pDumpBuf = NULL;

            if(NULL != pTransferContext -> pTransferBuffer){
                pDumpBuf = pTransferContext -> pTransferBuffer;
            } else if (NULL != pTransferContext -> pTransferMdl) {
                pTransferContext -> pTransferMdl ->MdlFlags |= MDL_MAPPING_CAN_FAIL;
                pDumpBuf = MmGetSystemAddressForMdl(pTransferContext -> pTransferMdl);
            }

            if(NULL != pDumpBuf){
                MyDumpMemory(pDumpBuf,
                             pTransferContext -> NBytesTransferred,
                             TRUE);
            }
        }
#endif // DBG

    } else {

        DebugTrace(TRACE_ERROR,("USTransferComplete: ERROR!! Transfer error. USB status = 0x%X, status = 0x%X\n",
                                    CompletedTransferStatus, 
                                    Status));
        if (USBD_STATUS_CANCELED == CompletedTransferStatus) {
            Status = STATUS_CANCELLED;
        }
    }

    //
    // Running here means IRP is completed.
    //

    pIrp -> IoStatus.Status = Status;

    if (pTransferContext -> fNextReadBlocked) {
        KeSetEvent(&pde -> ReadPipeBuffer[PipeIndex].ReadSyncEvent, 1, FALSE);
    }

    //
    // Dequeue timer object if exist.
    //

    if( (0 != pTransferContext -> Timeout.QuadPart)
     && (!KeReadStateTimer(&(pTransferContext->Timer))) )
    {
        KeCancelTimer(&(pTransferContext->Timer));
    }

    //
    // Clean-up
    //

    if(pTransferContext->pUrb){
        USFreePool(pTransferContext->pUrb);
    }
    USDecrementIoCount(pTransferContext->pDeviceObject);
    USFreePool(pTransferContext);

USTransferComplete_return:
    DebugTrace(TRACE_PROC_LEAVE,("USTransferComplete: Leaving.. Status=%x.\n", Status));
    return Status;
}


ULONG
USGetPipeIndexToUse(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN ULONG                PipeIndex
)
/*++

Routine Description:

Arguments:
    pDeviceObject    - Device object for a device.
    pIrp             - request packet
    PipeIndex        - Default pipe to use

Return Value:
    ULONG - PipeIndex to use

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    LONG                        StoredIndex;
    ULONG                       IndexToUse;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USGetPipeIndexToUse: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    pIrpStack       = IoGetCurrentIrpStackLocation (pIrp);
    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    ASSERT(NULL != pFileContext);

    StoredIndex     = pFileContext->PipeIndex;

    if( (StoredIndex >= 0) && (StoredIndex < MAX_NUM_PIPES) ){
        if(pde->PipeInfo[PipeIndex].PipeType == pde->PipeInfo[StoredIndex].PipeType){
            IndexToUse = (ULONG)StoredIndex;
        } else {
            IndexToUse = PipeIndex;
        }
    } else {
        if(-1 != StoredIndex){
            DebugTrace(TRACE_WARNING,("USGetPipeIndexToUse: WARINING!! Specified pipe index(0x%X) is incorrect. Using default." ,StoredIndex));
        }
        IndexToUse = PipeIndex;
    }
    DebugTrace(TRACE_PROC_LEAVE,("USGetPipeIndexToUse: Leaving.. passed=%d, returning=%d.\n",PipeIndex, IndexToUse));
    return IndexToUse;
}

VOID
USTimerDpc(
    IN PKDPC    pDpc,
    IN PVOID    pIrp,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
/*++

Routine Description:

DPC callback routine for timer.

Arguments:
    pDpc            -   Pointer to DPC object.
    pIrp            -   Passed context.
    SystemArgument1 -   system reserved.
    SystemArgument2 -   system reserved.

Return Value:
    VOID

--*/
{
    DebugTrace(TRACE_WARNING,("USTimerDpc: IRP(0x%x) timeout.\n", pIrp));
    IoCancelIrp((PIRP)pIrp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.h

Abstract:

    Prototypes and definitions for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifndef __MYDEBUG__
#define __MYDEBUG__

//
// Driver specific difinition
//


#define NAME_DRIVER             "USBscan.SYs: "    // Prefix of output message. (Should be driver name)
#define NAME_POOLTAG            'UITS'              // Pool tag for this driver.
#define MAXNUM_POOL             100                 // Maximum number of pool. (# of alloc - # of free)
#define MAX_DUMPSIZE            1024                // Maximum bytes to dump.

//
// Defines
//

#define REG_DEBUGLEVEL          L"DebugTraceLevel"
#define MAX_TEMPBUF             256

// Bit mask for trace level and flags
#define BITMASK_TRACE_LEVEL     0x0000000f
#define BITMASK_TRACE_FLAG      0x00000ff0
#define BITMASK_DEBUG_FLAG      0x0000f000

// Basic trace level 
#define NO_TRACE                0                   // Shows nothing.
#define MIN_TRACE               1                   // Shows only error or warning.
#define MAX_TRACE               2                   // Shows progress and status.
#define ULTRA_TRACE             3                   // Shows progress and status in retail.
#define NEVER_TRACE             4                   // Never show this unless specific bit is set.

// Trace flag to enable specific message spew. (1=on)
#define TRACE_FLAG_PROC          0x10                // Show message when entering process.(1=on)
#define TRACE_FLAG_RET           0x20                // Show message when leaving process.(1=on)
#define TRACE_FLAG_DUMP_READ     0x40                // Show user buffer when read.
#define TRACE_FLAG_DUMP_WRITE    0x80                // Show user buffer when write.

// Conbination of trace level and flag.
#define TRACE_PROC_ENTER        ULTRA_TRACE | TRACE_FLAG_PROC     // Entering procedure.
#define TRACE_PROC_LEAVE        ULTRA_TRACE | TRACE_FLAG_RET      // Leaving procedure.
#define TRACE_CRITICAL          MIN_TRACE                         // Critical error. Spew always.
#define TRACE_ERROR             MIN_TRACE                         // Error.
#define TRACE_WARNING           MIN_TRACE                         // Possible wrong behavior.
//#define TRACE_DUMP_DATA         NEVER_TRACE | TRACE_FLAG_DUMP     // Dump transaction data.
#define TRACE_DEVICE_DATA       MAX_TRACE                         // Show device data.
#define TRACE_STATUS            MAX_TRACE                         // Show status.

// Debug flag to enable/disable  DEBUG_BREAKPOINT()
#define DEBUG_FLAG_DISABLE      0x1000                          // Disable DEBUG_BREAK. (1=disable)
#define DEBUG_PROC_BREAK        0x2000                          // Stop at the beginning of each procedure.


//
// Macro
//

#if DBG

 //
 // Macro for debug output
 //
 // Note: If trace level is higher than DebugTraceLevel or specific bit is set, 
 //       debug message will be shown.
 //

extern ULONG DebugTraceLevel;
 #define DebugTrace(_t_, _x_) {                                                                 \
            if ( ((DebugTraceLevel & BITMASK_TRACE_LEVEL) >= (_t_ & BITMASK_TRACE_LEVEL )) ||   \
                 (DebugTraceLevel & BITMASK_TRACE_FLAG & (_t_)) ) {                             \
                DbgPrint(NAME_DRIVER);                                                          \
                DbgPrint _x_ ;                                                                  \
            }                                                                                   \
            if( (DebugTraceLevel & DEBUG_PROC_BREAK & (_t_)) &&                                 \
                (DebugTraceLevel & TRACE_FLAG_PROC) )  {                                        \
                DEBUG_BREAKPOINT();                                                             \
            }                                                                                   \
          }

 //
 // Macro for BreakPoint
 //

 #define DEBUG_BREAKPOINT() {                                              \
           if (DebugTraceLevel & DEBUG_FLAG_DISABLE) {                     \
               DbgPrint(NAME_DRIVER);                                      \
               DbgPrint("*** Hit DEBUG_BREAKPOINT ***\n");                 \
           } else {                                                        \
               DbgBreakPoint();                                            \
           }                                                               \
         }

#else    // DBG
 #define DEBUG_BREAKPOINT()
 #define DebugTrace(_t_, _x_)
#endif   // DBG


//
// Prototypes
//


PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
);

VOID
MyFreePool(
    IN PVOID     pvAddress
);

VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
);


VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
);

#endif //  __MYDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\ioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ioctl.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include <stddef.h>
#include <wdm.h>
#include <usbscan.h>
#include "usbd_api.h"
#include "private.h"
//#include "missdef.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USDeviceControl)
#pragma alloc_text(PAGE, USReadWriteRegisters)
#pragma alloc_text(PAGE, USCancelPipe)
#pragma alloc_text(PAGE, USAbortResetPipe)
#endif

#ifdef _WIN64
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif // _WIN64

NTSTATUS
USDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
)
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp          - DEVICE IOCTL irp

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    PFILE_OBJECT                fileObject;
    PUSBSCAN_FILE_CONTEXT       pFileContext;
    ULONG                       IoControlCode;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    NTSTATUS                    Status;
    PDRV_VERSION                pVersion;
    PDEVICE_DESCRIPTOR          pDesc;
    PUSBSCAN_GET_DESCRIPTOR     pGetDesc;
    PUSBSCAN_PIPE_CONFIGURATION pPipeConfig;
    PVOID                       pBuffer;

    IO_BLOCK                    LocalIoBlock;
    IO_BLOCK_EX                 LocalIoBlockEx;
    PIO_BLOCK                   pIoBlock;
    PIO_BLOCK_EX                pIoBlockEx;

    ULONG                       InLength;
    ULONG                       OutLength;
    BOOLEAN                     fRead = FALSE;
    BOOLEAN                     fAbort = TRUE;
    ULONG                       i;
    PURB                        pUrb;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USDeviceControl: Enter...\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USDeviceControl: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    //
    // Indicates I/O processing increase.
    //

    USIncrementIoCount( pDeviceObject );

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    if (FALSE == pde -> AcceptingRequests) {
        DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! IOCTL issued after device stopped/removed!\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Status = Status;
        pIrp -> IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        goto USDeviceControl_return;
    }

    //
    // Check device power state.
    //

    if (PowerDeviceD0 != pde -> CurrentDevicePowerState) {
        DebugTrace(TRACE_WARNING,("USDeviceControl: WARNING!! Device is suspended.\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Status = Status;
        pIrp -> IoStatus.Information = 0;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        goto USDeviceControl_return;
    }


    pIrpStack       = IoGetCurrentIrpStackLocation( pIrp );
    pNextIrpStack   = IoGetNextIrpStackLocation( pIrp );
    IoControlCode   = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

    InLength        = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutLength       = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    pBuffer         = pIrp -> AssociatedIrp.SystemBuffer;

    fileObject      = pIrpStack->FileObject;
    pFileContext    = fileObject->FsContext;

    DebugTrace(TRACE_STATUS,("USDeviceControl: Control code 0x%x = ", IoControlCode));

    switch (IoControlCode) {

        case IOCTL_GET_VERSION:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_VERSION\n"));

            if (OutLength < sizeof(DRV_VERSION) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Buffer(0x%x) too small(<0x%x)\n", OutLength, sizeof(DRV_VERSION)));
                DEBUG_BREAKPOINT();
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pVersion            = (PDRV_VERSION)pBuffer;
            pVersion->major     = 1;
            pVersion->minor     = 0;
            pVersion->internal  = 0;

            pIrp -> IoStatus.Information = sizeof(DRV_VERSION);

            Status = STATUS_SUCCESS;
            break;

        case IOCTL_CANCEL_IO:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_CANCEL_IO\n"));
            fAbort = TRUE;

            //
            // Falling through to the next case, this is intentional. We want to reset pipe when
            // cancel requested
            //

        case IOCTL_RESET_PIPE:
            if(IOCTL_RESET_PIPE == IoControlCode){
                DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_RESET_PIPE\n"));
                fAbort = FALSE;
            }

            //
            // Validate buffer size
            //

            if (InLength < sizeof(PIPE_TYPE) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Pipe type buffer (0x%x bytes) too small\n" ,InLength));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            Status = USCancelPipe(pDeviceObject,
                                  pIrp,
                                  *(PIPE_TYPE*)pBuffer,
                                  fAbort);
            break;

        case IOCTL_WAIT_ON_DEVICE_EVENT:
        {
            ULONG   Index;
            ULONG   Timeout;
            PULONG  pTimeout;


            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_WAIT_ON_DEVICE_EVENT\n"));

            Index = USGetPipeIndexToUse(pDeviceObject,
                                        pIrp,
                                        pde -> IndexInterrupt);

            if (OutLength < pde -> PipeInfo[Index].MaximumPacketSize) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! User buffer(0x%x) too small(<)\n"
                                        , OutLength
                                        , pde -> PipeInfo[Index].MaximumPacketSize));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy timeout value from file context.
            //

            Timeout = pFileContext->TimeoutEvent;

            //
            // If timeout value is 0, then never timeout.
            //

            if(0 == Timeout){
                pTimeout = NULL;
            } else {
                DebugTrace(TRACE_STATUS,("USDeviceControl: Timeout is set to 0x%x sec.\n", Timeout));
                pTimeout = &Timeout;
            }

            Status = USTransfer(pDeviceObject,
                                pIrp,
                                Index,
                                pIrp -> AssociatedIrp.SystemBuffer,
                                NULL,
                                pde  -> PipeInfo[Index].MaximumPacketSize,
                                pTimeout);

            //
            // IRP should be completed in USTransfer or its completion routine.
            //

            goto USDeviceControl_return;
        }

        case IOCTL_READ_REGISTERS:
            fRead = TRUE;
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_READ_REGISTERS\n"));

        case IOCTL_WRITE_REGISTERS:{

            if (IOCTL_WRITE_REGISTERS == IoControlCode) {
                DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_WRITE_REGISTERS\n"));
                fRead = FALSE;
            }
#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_32    pIoBlock32;

                if (InLength < sizeof(IO_BLOCK_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlock32  = (PIO_BLOCK_32)pBuffer;
                pIoBlock    = &LocalIoBlock;

                pIoBlock -> uOffset = pIoBlock32 -> uOffset;
                pIoBlock -> uLength = pIoBlock32 -> uLength;
                pIoBlock -> pbyData = pIoBlock32 -> pbyData;
                pIoBlock -> uIndex  = pIoBlock32 -> uIndex;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input buffer size(0x%x<0x%x)\n"
                                        , InLength,
                                        sizeof(IO_BLOCK)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }
            pIoBlock = (PIO_BLOCK)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if(TRUE == fRead){

                //
                // Check the size of Output buffer.
                //

                if (OutLength < pIoBlock -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) too small(<0x%x)\n"
                                            , OutLength
                                            , pIoBlock -> uLength));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                } // if (OutLength < pIoBlock -> uLength)
            } // if(TRUE == fRead)

            pIrp -> IoStatus.Information = pIoBlock -> uLength;

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. If call is made from
            // user-mode , we need to validate that given pointer is readable.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlock->pbyData,
                                 pIoBlock -> uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: Read/Write registers  buffer pointer is invalid\n"));
                    DEBUG_BREAKPOINT();

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USReadWriteRegisters(pDeviceObject,
                                          pIoBlock,
                                          fRead,
                                          InLength);
            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USReadWriteRegisters failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }
            break;
        } // case IOCTL_WRITE_REGISTERS:
        case IOCTL_GET_CHANNEL_ALIGN_RQST:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_CHANNEL_ALIGN_REQUEST\n"));

            if (OutLength < sizeof(CHANNEL_INFO) ) {

                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Buffer(0x%x) too small(<0x%x)\n"
                                        , OutLength
                                        ,sizeof(CHANNEL_INFO)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlock = (PIO_BLOCK)pBuffer;
            RtlZeroMemory((PCHANNEL_INFO)pIoBlock, sizeof(CHANNEL_INFO));

            for (i = 0; i < pde -> NumberOfPipes; i++) {

                //
                // Have to check which pipe to use
                //

                ULONG Index;
                Index = USGetPipeIndexToUse(pDeviceObject,
                                            pIrp,
                                            i);
                switch (pde -> PipeInfo[Index].PipeType) {
                    case USB_ENDPOINT_TYPE_INTERRUPT:
                        ((PCHANNEL_INFO)pIoBlock)->EventChannelSize = pde -> PipeInfo[Index].MaximumPacketSize;
                        break;
                    case USB_ENDPOINT_TYPE_BULK:
                        if (pde -> pEndpointDescriptor[Index].bEndpointAddress & BULKIN_FLAG) {
                            ((PCHANNEL_INFO)pIoBlock) -> uReadDataAlignment  = pde -> PipeInfo[Index].MaximumPacketSize;
                        } else {
                            ((PCHANNEL_INFO)pIoBlock) -> uWriteDataAlignment = pde -> PipeInfo[Index].MaximumPacketSize;
                        }
                        break;
                }
            }
            pIrp -> IoStatus.Information = sizeof(CHANNEL_INFO);
            Status = STATUS_SUCCESS;
            break;

        case IOCTL_GET_DEVICE_DESCRIPTOR:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_DEVICE_DESCRIPTOR\n"));

            if (OutLength < sizeof(DEVICE_DESCRIPTOR)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) is too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(DEVICE_DESCRIPTOR)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            pDesc = (PDEVICE_DESCRIPTOR)pBuffer;
            pDesc -> usVendorId   = pde -> pDeviceDescriptor -> idVendor;
            pDesc -> usProductId  = pde -> pDeviceDescriptor -> idProduct;
            pDesc -> usBcdDevice  = pde -> pDeviceDescriptor -> bcdDevice;

            DebugTrace(TRACE_STATUS,("USDeviceControl: Vendor ID:%d\n", pDesc -> usVendorId));
            DebugTrace(TRACE_STATUS,("USDeviceControl: Product ID:%d\n", pDesc -> usProductId));
            DebugTrace(TRACE_STATUS,("USDeviceControl: BcdDevice:%d\n", pDesc -> usBcdDevice));

            pIrp -> IoStatus.Information = sizeof(DEVICE_DESCRIPTOR);
            Status = STATUS_SUCCESS;
            break;


        case IOCTL_GET_USB_DESCRIPTOR:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_USB_DESCRIPTOR\n"));

            if (OutLength < sizeof(USBSCAN_GET_DESCRIPTOR)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Out buffer(0x%x) is too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(USBSCAN_GET_DESCRIPTOR)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            pGetDesc = (PUSBSCAN_GET_DESCRIPTOR)pBuffer;
            pUrb = USAllocatePool(NonPagedPool,
                                  sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
            if (NULL == pUrb) {
                DebugTrace(TRACE_CRITICAL,("USDeviceControl: ERROR!! Can't allocate control descriptor URB.\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

#ifdef DEBUG
            switch(pGetDesc -> DescriptorType){
                case USB_DEVICE_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_DEVICE_DESCRIPTOR_TYPE\n"));
                    break;
                case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_CONFIGURATION_DESCRIPTOR_TYPE\n"));
                    break;
                case USB_STRING_DESCRIPTOR_TYPE:
                    DebugTrace(TRACE_STATUS,("USDeviceControl: USB_STRING_DESCRIPTOR_TYPE\n"));
                    break;
                default:
                    DebugTrace(TRACE_WARNING,("USDeviceControl: WARNING!! 0x%x = Undefined.\n", pGetDesc -> DescriptorType));
                    Status = STATUS_INVALID_PARAMETER_3;

                    USFreePool(pUrb);
                    pUrb = NULL;
                    pIrp -> IoStatus.Information = 0;
                    goto USDeviceControl_return;
            }
            DebugTrace(TRACE_STATUS, ("USDeviceControl: Index         :%d\n",pGetDesc -> Index));
            DebugTrace(TRACE_STATUS, ("USDeviceControl: LanguageID    :%d\n", pGetDesc -> LanguageId));
#endif //DEBUG

            UsbBuildGetDescriptorRequest(pUrb,
                                         (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         pGetDesc -> DescriptorType,
                                         pGetDesc -> Index,
                                         pGetDesc -> LanguageId,
                                         pBuffer,
                                         NULL,
                                         OutLength,
                                         NULL);

            Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
#ifdef DEBUG
            if ( (STATUS_SUCCESS == Status)
//           &&  (USB_DEVICE_DESCRIPTOR_TYPE == pGetDesc -> DescriptorType)
            )
            {
                PUSB_DEVICE_DESCRIPTOR pDeviceDescriptor;
                pDeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)pBuffer;
                DebugTrace(TRACE_STATUS,("USDeviceControl: Device Descriptor = %x, len %x\n",
                                           pDeviceDescriptor,
                                           pUrb->UrbControlDescriptorRequest.TransferBufferLength));

                DebugTrace(TRACE_STATUS,("USDeviceControl: USBSCAN Device Descriptor:\n"));
                DebugTrace(TRACE_STATUS,("USDeviceControl: -------------------------\n"));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bLength            %d\n",   pDeviceDescriptor->bLength));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDescriptorType    0x%x\n", pDeviceDescriptor->bDescriptorType));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bcdUSB             0x%x\n", pDeviceDescriptor->bcdUSB));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceClass       0x%x\n", pDeviceDescriptor->bDeviceClass));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceSubClass    0x%x\n", pDeviceDescriptor->bDeviceSubClass));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bDeviceProtocol    0x%x\n", pDeviceDescriptor->bDeviceProtocol));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bMaxPacketSize0    0x%x\n", pDeviceDescriptor->bMaxPacketSize0));
                DebugTrace(TRACE_STATUS,("USDeviceControl: idVendor           0x%x\n", pDeviceDescriptor->idVendor));
                DebugTrace(TRACE_STATUS,("USDeviceControl: idProduct          0x%x\n", pDeviceDescriptor->idProduct));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bcdDevice          0x%x\n", pDeviceDescriptor->bcdDevice));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iManufacturer      0x%x\n", pDeviceDescriptor->iManufacturer));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iProduct           0x%x\n", pDeviceDescriptor->iProduct));
                DebugTrace(TRACE_STATUS,("USDeviceControl: iSerialNumber      0x%x\n", pDeviceDescriptor->iSerialNumber));
                DebugTrace(TRACE_STATUS,("USDeviceControl: bNumConfigurations 0x%x\n", pDeviceDescriptor->bNumConfigurations));

            } else {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR! Status = %d\n", Status));
            }

#endif //DEBUG

            USFreePool(pUrb);
            pUrb = NULL;
            pIrp -> IoStatus.Information = ((PUSB_DEVICE_DESCRIPTOR)pBuffer)->bLength;
            break;

        case IOCTL_SEND_USB_REQUEST:
        {

            //
            // Generic pass-through mechanism for USB vendor requests.
            //

            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SEND_USB_REQUEST\n"));

            //
            // Validate length parameters.
            //

#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_EX_32 pIoBlockEx32;

                if (InLength < sizeof(IO_BLOCK_EX_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_EX_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlockEx32    = (PIO_BLOCK_EX_32)pBuffer;
                pIoBlockEx      = &LocalIoBlockEx;

                pIoBlockEx -> uOffset               = pIoBlockEx32 -> uOffset;
                pIoBlockEx -> uLength               = pIoBlockEx32 -> uLength;
                pIoBlockEx -> pbyData               = pIoBlockEx32 -> pbyData;
                pIoBlockEx -> uIndex                = pIoBlockEx32 -> uIndex;
                pIoBlockEx -> bRequest              = pIoBlockEx32 -> bRequest;
                pIoBlockEx -> bmRequestType         = pIoBlockEx32 -> bmRequestType;
                pIoBlockEx -> fTransferDirectionIn  = pIoBlockEx32 -> fTransferDirectionIn;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK_EX) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! I/O buffer(0x%x) too small(<0x%x)\n"
                                        , InLength
                                        , sizeof(IO_BLOCK_EX)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlockEx = (PIO_BLOCK_EX)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if (pIoBlockEx->fTransferDirectionIn) {

                //
                // Check output buffer length is valid.
                //

                if (OutLength < pIoBlockEx -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! OutLength too small\n"));
                    DEBUG_BREAKPOINT();
                    Status = STATUS_INVALID_PARAMETER;
                    pIrp -> IoStatus.Information = 0;
                    break;
                }
                pIrp -> IoStatus.Information = pIoBlockEx -> uLength;

            } else {

                //
                // No output to the caller.
                //

                pIrp -> IoStatus.Information = 0;
            }

            //
            // Validate user buffer.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlockEx->pbyData,
                                 pIoBlockEx->uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: User buffer pointer is invalid\n"));

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USPassThruUSBRequest(pDeviceObject,
                                          (PIO_BLOCK_EX)pBuffer,
                                          InLength,
                                          OutLength
                                          );

            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USPassThruUSBRequest failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }

            break;

        } // case IOCTL_SEND_USB_REQUEST:
        
        case IOCTL_SEND_USB_REQUEST_PTP:
        {

            //
            // Generic pass-through mechanism for USB vendor requests.
            //

            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SEND_USB_REQUEST_PTP\n"));

            //
            // Validate length parameters.
            //

#ifdef _WIN64
            
            if(IoIs32bitProcess(pIrp)){
                PIO_BLOCK_EX_32 pIoBlockEx32;

                if (InLength < sizeof(IO_BLOCK_EX_32) ) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input 32bit buffer size(0x%x<0x%x)\n"
                                            , InLength,
                                            sizeof(IO_BLOCK_EX_32)));
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                // Copy all parameters from 32bit structure.
                //
                
                pIoBlockEx32    = (PIO_BLOCK_EX_32)pBuffer;
                pIoBlockEx      = &LocalIoBlockEx;

                pIoBlockEx -> uOffset               = pIoBlockEx32 -> uOffset;
                pIoBlockEx -> uLength               = pIoBlockEx32 -> uLength;
                pIoBlockEx -> pbyData               = pIoBlockEx32 -> pbyData;
                pIoBlockEx -> uIndex                = pIoBlockEx32 -> uIndex;
                pIoBlockEx -> bRequest              = pIoBlockEx32 -> bRequest;
                pIoBlockEx -> bmRequestType         = pIoBlockEx32 -> bmRequestType;
                pIoBlockEx -> fTransferDirectionIn  = pIoBlockEx32 -> fTransferDirectionIn;

            } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (InLength < sizeof(IO_BLOCK_EX) ) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! I/O buffer(0x%x) too small(<0x%x)\n"
                                        , InLength
                                        , sizeof(IO_BLOCK_EX)));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            pIoBlockEx = (PIO_BLOCK_EX)pBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64 

            if (pIoBlockEx->fTransferDirectionIn) {

                //
                // Check output buffer length is valid.
                //

                if (OutLength < pIoBlockEx -> uLength) {
                    DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! OutLength too small\n"));
                    DEBUG_BREAKPOINT();
                    Status = STATUS_INVALID_PARAMETER;
                    pIrp -> IoStatus.Information = 0;
                    break;
                }
                pIrp -> IoStatus.Information = pIoBlockEx -> uLength;

            } else {

                //
                // No output to the caller.
                //

                pIrp -> IoStatus.Information = 0;
            }

            //
            // Validate user buffer.
            //

            if (pIrp->RequestorMode != KernelMode) {

                try {
                    ProbeForRead(pIoBlockEx->pbyData,
                                 pIoBlockEx->uLength,
                                 sizeof(UCHAR));

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    DebugTrace(TRACE_ERROR,("USDeviceControl: User buffer pointer is invalid\n"));

                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    break;
                } // except
            } // !kernelmode

            //
            // Now go to worker function
            //

            Status = USPassThruUSBRequestPTP(pDeviceObject,
                                             (PIO_BLOCK_EX)pBuffer,
                                             InLength,
                                             OutLength);

            if (STATUS_SUCCESS != Status) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! USPassThruUSBRequestPTP failed\n"));
                DEBUG_BREAKPOINT();
                pIrp -> IoStatus.Information = 0;
            }

            break;

        } // case IOCTL_SEND_USB_REQUEST_PTP:

        case IOCTL_GET_PIPE_CONFIGURATION:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_GET_PIPE_CONFIGURATION\n"));

            //
            // Check output buffer length
            //

            if (OutLength < sizeof(USBSCAN_PIPE_CONFIGURATION)) {
                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! GetPipeConfig buffer(0x%x) too small(<0x%x)\n"
                                        , OutLength
                                        , sizeof(USBSCAN_PIPE_CONFIGURATION)));
                Status = STATUS_INVALID_PARAMETER_6;
                break;
            }

            //
            // Copy Pipe configuration to user buffer.
            //

            pPipeConfig = (PUSBSCAN_PIPE_CONFIGURATION)pBuffer;
            RtlZeroMemory(pPipeConfig, sizeof(USBSCAN_PIPE_CONFIGURATION));

            pPipeConfig->NumberOfPipes = pde->NumberOfPipes;
            for(i=0; i < pPipeConfig->NumberOfPipes; i++){
                pPipeConfig->PipeInfo[i].MaximumPacketSize = pde->PipeInfo[i].MaximumPacketSize;
                pPipeConfig->PipeInfo[i].EndpointAddress = pde->PipeInfo[i].EndpointAddress;
                pPipeConfig->PipeInfo[i].Interval = pde->PipeInfo[i].Interval;
                pPipeConfig->PipeInfo[i].PipeType = pde->PipeInfo[i].PipeType;
            }

            pIrp -> IoStatus.Information = sizeof(USBSCAN_PIPE_CONFIGURATION);
            Status = STATUS_SUCCESS;
            break;


        case IOCTL_SET_TIMEOUT:
            DebugTrace(TRACE_STATUS,("USDeviceControl: IOCTL_SET_TIMEOUT\n"));

            //
            // Make sure input buffer size is big enough.
            //

            if(sizeof(USBSCAN_TIMEOUT) > InLength){

                //
                // Incorrect Input buffer size.
                //

                DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Invalid input buffer size\n"));
                Status = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Copy timeout value.
            //

            pFileContext -> TimeoutRead     = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutRead;
            pFileContext -> TimeoutWrite    = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutWrite;
            pFileContext -> TimeoutEvent    = ((PUSBSCAN_TIMEOUT)pBuffer) -> TimeoutEvent;

            pIrp -> IoStatus.Information = 0;

            Status = STATUS_SUCCESS;
            break;

        default:
            DebugTrace(TRACE_ERROR,("USDeviceControl: ERROR!! Unsupported IOCTL\n"));
            Status = STATUS_NOT_SUPPORTED;
            break;
    }


    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

USDeviceControl_return:
    USDecrementIoCount(pDeviceObject);
    DebugTrace(TRACE_PROC_LEAVE,("USDeviceControl: Leaving.. Status = 0x%x\n", Status));
    return Status;


} // end USDeviceControl()



NTSTATUS
USReadWriteRegisters(
   IN   PDEVICE_OBJECT  pDeviceObject,
   IN   PIO_BLOCK       pIoBlock,
   IN   BOOLEAN         fRead,
   IN   ULONG           IoBlockSize
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    UCHAR                       Request;
    PVOID                       pBuffer = NULL;
    //USHORT                      uIndex;
    unsigned                   uIndex;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USReadWriteRegisters: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Allocate URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USReadWriteRegisters: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USReadWriteRegisters_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    Request  = REGISTER_AREA;
    if (pIoBlock -> uLength > 1) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: ULength > 1, turning on automatic increment\n"));
        Request |= OPCODE_SEQ_TRANSFER;           // automatic address increment after the read
    } else {
        Request |= OPCODE_SINGLE_ADDR_TRANSFER;   // no address increment after the read
    }

    //
    // Reading registers will read into pIoBlock itself.
    //

    pBuffer = pIoBlock;

    //
    // If we are writing registers, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!fRead) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: Write request, allocating non-paged reg buffer, len = %d\n",pIoBlock->uLength));
        pBuffer = USAllocatePool(NonPagedPool, pIoBlock->uLength);
        if (NULL == pBuffer) {
            DebugTrace(TRACE_CRITICAL,("USReadWriteRegisters: ERROR!! cannot allocate write reg buffer\n"));
            DEBUG_BREAKPOINT();
            USFreePool(pUrb);
            pUrb = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto USReadWriteRegisters_return;
        }

        //
        // Caller gives us a pointer, embedded into IOCTL buffer. We need to
        // validate that given pointer is readable.
        //

        try{
            RtlCopyMemory(pBuffer,
                          pIoBlock->pbyData,
                          pIoBlock->uLength);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Caller buffer is not valid, or worse..
            //

            DebugTrace(TRACE_ERROR,("USReadWriteRegisters: ERROR!! Copying caller buffer failed.\n"));
            DEBUG_BREAKPOINT();
            Status = GetExceptionCode();

            //
            // Clear allocated pool
            //

            USFreePool(pUrb);
            USFreePool(pBuffer);
            pUrb = NULL;
            pBuffer = NULL;

            goto USReadWriteRegisters_return;
        }

    }

    //
    // If the IoBlock is new style (Intel has added a uIndex field to the end of it),
    // then make sure we pass the corrected uIndex value to usbd.
    //

    uIndex = 0;
    if (IoBlockSize == sizeof(IO_BLOCK)) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: New (intel) style IoBlock -- setting uIndex to pIoBlock -> uIndex\n"));
        uIndex = pIoBlock -> uIndex;
    }


    UsbBuildVendorClassSpecificCommand(pUrb,
                                       fRead ? USBD_TRANSFER_DIRECTION_IN : 0,
                                       pIoBlock->uLength,
                                       pBuffer,
                                       NULL,
                                       fRead ? 0xc0 : 0x40,
                                       Request,
                                       (SHORT)pIoBlock->uOffset,
                                       (USHORT)uIndex);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

    if (!fRead) {
        DebugTrace(TRACE_STATUS,("USReadWriteRegisters: freeing temp reg buffer\n"));
        USFreePool(pBuffer);
        pBuffer = NULL;
    }

    USFreePool(pUrb);
    pUrb = NULL;

USReadWriteRegisters_return:
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("USReadWriteRegisters: ERROR!! Still had unfreed pointer. Free it...\n"));

        if(pUrb){
            USFreePool(pUrb);
        }
        if( (pBuffer)
         && (!fRead ) )
        {
            USFreePool(pBuffer);
        }
    }
    DebugTrace(TRACE_PROC_LEAVE,("USReadWriteRegisters: Leaving.. Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USCancelPipe(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN PIPE_TYPE        PipeType,
    IN BOOLEAN          fAbort          // TRUE = Abort, FALSE = Reset
)
/*++

Routine Description:

    Cansel URB or reset pipe. If PipeType is PIPE_ALL, it applies to every pipes a device has.
    If not, it applies to only one default pipe even if a device supports multipul same type of pipes.

Arguments:
    pDeviceObject   -   Pointer to Device Object
    pIrp            -   Can be NULL if PipeType is ALL_PIPE
    PipeType        -   Specifies type of pipe
    fAbort          -   Specifies type of operation

Return Value:

    Returns status
--*/
{
    NTSTATUS                    Status, temp;
    PUSBSCAN_DEVICE_EXTENSION   pde;

    PAGED_CODE();

//    DebugTrace(TRACE_PROC_ENTER,("USCancelPipe: Enter.. - "));

    Status = STATUS_SUCCESS;
    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    switch (PipeType) {

        case EVENT_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: EVENT_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexInterrupt) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! Interrupt pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }

            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexInterrupt),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("Event Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case READ_DATA_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: READ_DATA_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexBulkIn) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! bulk-in pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexBulkIn),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("USCancelPipe: Read Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case WRITE_DATA_PIPE:

            DebugTrace(TRACE_STATUS,("USCancelPipe: WRITE_DATA_PIPE\n"));

            if(NULL == pIrp){
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! pIrp not valid\n"));
                break;
            }

            if (-1 == pde -> IndexBulkOut) {
                DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! bulk-out pipe not valid\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            Status = USAbortResetPipe(pDeviceObject,
                                      USGetPipeIndexToUse(pDeviceObject, pIrp, pde -> IndexBulkOut),
                                      fAbort);
            DebugTrace(TRACE_STATUS,("Write Pipe aborted/reset, Status = 0x%x\n",Status));
            break;

        case ALL_PIPE:
        {
            ULONG i;

            DebugTrace(TRACE_STATUS,("USCancelPipe: ALL_PIPE\n"));

            for(i=0; i < pde -> NumberOfPipes; i++){
                temp = USAbortResetPipe(pDeviceObject, i, fAbort);
                // DebugTrace(TRACE_STATUS,("USCancelPipe: pipe[%d] aborted/reset, Status = 0x%x\n", i, temp));
                if(STATUS_SUCCESS != temp){
                    Status = temp;
                }
            }
            break;
        }

        default:

            DebugTrace(TRACE_ERROR,("USCancelPipe: ERROR!! INVALID_PIPE\n"));

            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    DebugTrace(TRACE_PROC_LEAVE,("USCancelPipe: Leaving.. Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USAbortResetPipe(
    IN PDEVICE_OBJECT pDeviceObject,
    IN ULONG uIndex,
    IN BOOLEAN fAbort       // TRUE = Abort, FALSE = Reset
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    NTSTATUS                    StatusReset = STATUS_SUCCESS;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USAbortResetPipe: Enter... \n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pUrb = NULL;

    //
    // Allocate URB
    //

    siz = sizeof(struct _URB_PIPE_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USAbortResetPipe_return;
    }
    RtlZeroMemory(pUrb, siz);

    if (fAbort) {

        DebugTrace(TRACE_STATUS,("USAbortResetPipe: Aborting pipe[%d]\n", uIndex));

        //
        // Issue abort pipe call to USBD.
        //

        UsbBuildAbortPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != Status) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! Abort pipe failed. Status = 0x%x\n",Status));
            goto USAbortResetPipe_return;
        }

        UsbBuildResetPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        StatusReset = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != StatusReset) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! resetting pipe. Status = 0x%x\n",StatusReset));
            goto USAbortResetPipe_return;
        }


    } else {

        DebugTrace(TRACE_STATUS,("Reseting pipe[%d]\n", uIndex));

        //
        // Issue reset pipe call to USBD.
        //

        UsbBuildResetPipeRequest(pUrb,
                                 siz,
                                 pde -> PipeInfo[uIndex].PipeHandle);

        Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

        if (STATUS_SUCCESS != Status) {
            DebugTrace(TRACE_ERROR,("USAbortResetPipe: ERROR!! Reset pipe failed. Status = 0x%x\n",Status));
            goto USAbortResetPipe_return;
        }
    }

USAbortResetPipe_return:
    //
    // Clean up.
    //

    if(pUrb){
        USFreePool(pUrb);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USAbortResetPipe: Leaving.. Status = 0x%x\n", Status));
    return Status;
}

NTSTATUS
USPassThruUSBRequest(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
)
/*++

Routine Description:

    Implements generic pass-thru for vendor request to USBD

Arguments:

    pDeviceObject   -   Device object
    pIoBlockEx      -   Pointer to I/O block as described in USBSCAN.H, passed from user mode client
    InLength        -   In length from IRP
    OutLength       -   Out length from IRP

Return Value:

    NTSTATUS type

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    PVOID                       pBuffer;
    BOOLEAN                     fDirectionIn;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPassThruUSBRequest: Enter..\n"));

    //
    // Initialize local variable.
    //

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status  = STATUS_SUCCESS;
    pUrb    = NULL;
    pBuffer = NULL;
    fDirectionIn = TRUE;

    //
    // Allocate memory for URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPassThruUSBRequest_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    pBuffer = pIoBlockEx;

    //
    // If we are writing data, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!pIoBlockEx->fTransferDirectionIn) {

        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Write request, allocating non-paged buffer, len = %d\n",pIoBlockEx->uLength));

        fDirectionIn = FALSE;

        if ( pIoBlockEx->uLength ) {

            pBuffer = USAllocatePool(NonPagedPool, pIoBlockEx->uLength);
            if (NULL == pBuffer) {

                DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocate write buffer"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto USPassThruUSBRequest_return;
            }

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. We need to
            // validate that given pointer is readable.
            //

            try{
                RtlCopyMemory(pBuffer,
                              pIoBlockEx->pbyData,
                              pIoBlockEx->uLength);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Caller buffer is not valid, or worse..
                //

                DebugTrace(TRACE_ERROR,("USPassThruUSBRequest: ERROR!! Copying caller buffer failed.\n"));
                DEBUG_BREAKPOINT();
                Status = GetExceptionCode();

                goto USPassThruUSBRequest_return;
            }


        } else {

            //
            // Zero length buffer used for Write , IHV claim that's useful.
            //

            pBuffer = NULL;
        } // if ( pIoBlockEx->uLength )
    }

    UsbBuildVendorClassSpecificCommand(pUrb,
                                       pIoBlockEx->fTransferDirectionIn ? USBD_TRANSFER_DIRECTION_IN : 0,
                                       pIoBlockEx->uLength,
                                       pBuffer,
                                       NULL,
                                       pIoBlockEx->bmRequestType,
                                       pIoBlockEx->bRequest,
                                       (SHORT)pIoBlockEx->uOffset,
                                       (USHORT)pIoBlockEx -> uIndex
                                       );

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

USPassThruUSBRequest_return:

    //
    // Clean up.
    //

    if(NULL != pUrb){
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free USB Request Block.\n"));
            USFreePool(pUrb);
        }

    if( (!fDirectionIn)
     && (NULL != pBuffer) )
    {
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free temp buffer.\n"));
            USFreePool(pBuffer);
        }

    DebugTrace(TRACE_PROC_LEAVE,("USPassThruUSBRequest: Leaving.. Status = 0x%x\n", Status));
    return Status;

}

NTSTATUS
USPassThruUSBRequestPTP(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
)
/*++

Routine Description:

    Implements generic pass-thru for vendor request to USBD

Arguments:

    pDeviceObject   -   Device object
    pIoBlockEx      -   Pointer to I/O block as described in USBSCAN.H, passed from user mode client
    InLength        -   In length from IRP
    OutLength       -   Out length from IRP

Return Value:

    NTSTATUS type

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PURB                        pUrb;
    ULONG                       siz;
    PVOID                       pBuffer;
    BOOLEAN                     fDirectionIn;
    USHORT                      usUsbFunction;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPassThruUSBRequest: Enter..\n"));

    //
    // Initialize local variable.
    //

    pde             = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    Status          = STATUS_SUCCESS;
    pUrb            = NULL;
    pBuffer         = NULL;
    fDirectionIn    = TRUE;
    usUsbFunction   = 0;

    //
    // Allocate memory for URB
    //

    siz = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPassThruUSBRequest_return;
    }

    RtlZeroMemory(pUrb, siz);

    //
    // Setup URB
    //

    pBuffer = pIoBlockEx;

    //
    // If we are writing data, then we need to make a copy of the
    // register block into a non-paged block of memory before handing it off
    // to usbd.
    //

    if (!pIoBlockEx->fTransferDirectionIn) {

        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Write request, allocating non-paged buffer, len = %d\n",pIoBlockEx->uLength));

        fDirectionIn = FALSE;

        if ( pIoBlockEx->uLength ) {

            pBuffer = USAllocatePool(NonPagedPool, pIoBlockEx->uLength);
            if (NULL == pBuffer) {

                DebugTrace(TRACE_CRITICAL,("USPassThruUSBRequest: ERROR!! cannot allocate write buffer"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto USPassThruUSBRequest_return;
            }

            //
            // Caller gives us a pointer, embedded into IOCTL buffer. We need to
            // validate that given pointer is readable.
            //

            try{
                RtlCopyMemory(pBuffer,
                              pIoBlockEx->pbyData,
                              pIoBlockEx->uLength);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Caller buffer is not valid, or worse..
                //

                DebugTrace(TRACE_ERROR,("USPassThruUSBRequest: ERROR!! Copying caller buffer failed.\n"));
                DEBUG_BREAKPOINT();
                Status = GetExceptionCode();

                goto USPassThruUSBRequest_return;
            }


        } else {

            //
            // Zero length buffer used for Write , IHV claim that's useful.
            //

            pBuffer = NULL;
        } // if ( pIoBlockEx->uLength )
    }

    //
    // Set proper USB funtion depends on bmRequestType.
    //
    
    if(0xa1 == pIoBlockEx->bmRequestType){          // USB_PTPREQUEST_TYPE_IN: Class/Interface Device to Host.
        usUsbFunction = URB_FUNCTION_CLASS_INTERFACE;
    } else if(0x21 == pIoBlockEx->bmRequestType){   // USB_PTPREQUEST_TYPE_OUT: Class/Interface Host to Device.
        usUsbFunction = URB_FUNCTION_CLASS_INTERFACE;
    } else {                                        // Default.
        usUsbFunction = URB_FUNCTION_VENDOR_DEVICE;
    }

    UsbBuildVendorClassSpecificCommandPTP(usUsbFunction,
                                          pUrb,
                                          pIoBlockEx->fTransferDirectionIn ? USBD_TRANSFER_DIRECTION_IN : 0,
                                          pIoBlockEx->uLength,
                                          pBuffer,
                                          NULL,
                                          pIoBlockEx->bmRequestType,
                                          pIoBlockEx->bRequest,
                                          (SHORT)pIoBlockEx->uOffset,
                                          (USHORT)pIoBlockEx -> uIndex);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

USPassThruUSBRequest_return:

    //
    // Clean up.
    //

    if(NULL != pUrb){
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free USB Request Block.\n"));
            USFreePool(pUrb);
        }

    if( (!fDirectionIn)
     && (NULL != pBuffer) )
    {
        DebugTrace(TRACE_STATUS,("USPassThruUSBRequest: Free temp buffer.\n"));
            USFreePool(pBuffer);
        }

    DebugTrace(TRACE_PROC_LEAVE,("USPassThruUSBRequest: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // USPassThruUSBRequestPTP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     StillImage kernel mode driver
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=usbscan
TARGETTYPE=DRIVER
TARGETPATH=$(OBJ_DIR)

TARGETLIBS=$(DDK_LIB_PATH)\usbd.lib

SOURCES= ..\usbscan.c \
         ..\ocrw.c  \
         ..\ioctl.c \
         ..\power.c \
         ..\usbscan.rc \
         ..\debug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\power.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    power.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "usbscan.h"
#include "usbd_api.h"
#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USPower)
#endif


NTSTATUS
USPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
/*++

Routine Description:
    Process the Power IRPs sent to the PDO for this device.

Arguments:
    pDeviceObject - pointer to the functional device object (FDO) for this device.
    pIrp          - pointer to an I/O Request Packet

Return Value:
    NT status code

--*/
{
    NTSTATUS                        Status;
    PUSBSCAN_DEVICE_EXTENSION       pde;
    PIO_STACK_LOCATION              pIrpStack;
    BOOLEAN                         hookIt = FALSE;
    POWER_STATE                     powerState;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPower: Enter... \n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USPower: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USPower: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    USIncrementIoCount(pDeviceObject);

    pde       = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    Status    = STATUS_SUCCESS;

    switch (pIrpStack -> MinorFunction) {
        case IRP_MN_SET_POWER:
            DebugTrace(TRACE_STATUS,("USPower: IRP_MN_SET_POWER\n"));

            switch (pIrpStack -> Parameters.Power.Type) {
                case SystemPowerState:
                    DebugTrace(TRACE_STATUS,("USPower: SystemPowerState\n"));

                    //
                    // find the device power state equivalent to the given system state
                    //

                    DebugTrace(TRACE_STATUS,("USPower: Set Power, SystemPowerState (%d)\n",
                                               pIrpStack -> Parameters.Power.State.SystemState));
                    if (pIrpStack -> Parameters.Power.State.SystemState == PowerSystemWorking) {
                        powerState.DeviceState = PowerDeviceD0;

                    } else if (/* pde ->EnabledForWakeup */ FALSE) {

                        DebugTrace(TRACE_STATUS,("USPower: USBSCAN always enabled for wakeup\n"));
                        powerState.DeviceState = pde ->
                            DeviceCapabilities.DeviceState[pIrpStack->Parameters.Power.State.SystemState];

                    } else {

                        //
                        // wakeup not enabled, just go in to the 'OFF' state.
                        //

                        powerState.DeviceState = PowerDeviceD3;

                    } //irpStack->Parameters.Power.State.SystemState

                    //
                    // are we already in this state?
                    //

                    if (powerState.DeviceState != pde -> CurrentDevicePowerState) {

                        //
                        // No, request that we be put into this state
                        //

                        DebugTrace(TRACE_STATUS,("USPower: Requesting powerstate %d\n",
                            powerState.DeviceState));

                        IoMarkIrpPending(pIrp);
                        pde -> pPowerIrp = pIrp;
                        Status = PoRequestPowerIrp(pde -> pPhysicalDeviceObject,
                            IRP_MN_SET_POWER,
                            powerState,
                            USPoRequestCompletion,
                            pDeviceObject,
                            NULL);

                        if (!NT_SUCCESS(Status)) {

                            //
                            // Allocation failed, we must complete the IRP
                            // ourselves.
                            //
                            PoStartNextPowerIrp(pIrp);
                            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                            USDecrementIoCount(pDeviceObject);
                        }

                        //
                        // We marked the IRP pending, so we must return
                        // STATUS_PENDING (our caller will examine
                        // Irp->IoStatus.Status)
                        //
                        Status = STATUS_PENDING;

                    } else {

                        //
                        // Yes, just pass it on
                        //

                        IoCopyCurrentIrpStackLocationToNext(pIrp);
                        PoStartNextPowerIrp(pIrp);
                        Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
                        USDecrementIoCount(pDeviceObject);
                    }
                    break;

                case DevicePowerState:
                    DebugTrace(TRACE_STATUS,("USPower: DevicePowerState\n"));

                    Status = USSetDevicePowerState(pDeviceObject,
                        pIrpStack -> Parameters.Power.State.DeviceState,
                        &hookIt);

                    IoCopyCurrentIrpStackLocationToNext(pIrp);

                    if (hookIt) {
                        DebugTrace(TRACE_STATUS,("USPower: Set PowerIrp Completion Routine\n"));
                        IoSetCompletionRoutine(pIrp,
                                               USPowerIrpComplete,
                                               // always pass FDO to completion routine
                                               pDeviceObject,
                                               hookIt,
                                               hookIt,
                                               hookIt);
                    }
                    PoStartNextPowerIrp(pIrp);
                    Status = PoCallDriver(pde ->pStackDeviceObject, pIrp);
                    if (!hookIt) {
                        USDecrementIoCount(pDeviceObject);
                    }
                    break;

            } /* case irpStack->Parameters.Power.Type */
            break; /* IRP_MN_SET_POWER */


        case IRP_MN_QUERY_POWER:
            DebugTrace(TRACE_STATUS,("USPower: IRP_MN_QUERY_POWER\n"));
            IoCopyCurrentIrpStackLocationToNext(pIrp);
            PoStartNextPowerIrp(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            USDecrementIoCount(pDeviceObject);

            break; /* IRP_MN_QUERY_POWER */

        default:
            DebugTrace(TRACE_STATUS,("USPower: Unknown power message (%x)\n",pIrpStack->MinorFunction));
            IoCopyCurrentIrpStackLocationToNext(pIrp);
            PoStartNextPowerIrp(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            USDecrementIoCount(pDeviceObject);

    } /* pIrpStack -> MinorFunction */


    DebugTrace(TRACE_PROC_LEAVE,("USPower: Leaving... Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USPoRequestCompletion(
    IN PDEVICE_OBJECT       pPdo,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PDEVICE_OBJECT       pDeviceObject,                      
    IN PIO_STATUS_BLOCK     pIoStatus
    )
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

Return Value:
    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    Status;    
    PUSBSCAN_DEVICE_EXTENSION   pde;                    
    PIRP                        pIrp;

    DebugTrace(TRACE_PROC_ENTER,("USPoRequestCompletion: Enter...\n"));    
  
    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;    
    pIrp   = pde -> pPowerIrp;
    Status = pIoStatus -> Status;

    IoCopyCurrentIrpStackLocationToNext(pIrp);      
    PoStartNextPowerIrp(pIrp);
    PoCallDriver(pde -> pStackDeviceObject, pIrp);   
    USDecrementIoCount(pDeviceObject);                 

    DebugTrace(TRACE_PROC_LEAVE,("USPoRequestCompletion: Leaving... Status = 0x%x\n", Status));
    return Status;
}


USPowerIrpComplete(
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

Return Value:
    The function value is the final status from the operation.

--*/
{
    NTSTATUS                    Status;    
    PUSBSCAN_DEVICE_EXTENSION   pde;                    
    PIO_STACK_LOCATION          pIrpStack;    

    DebugTrace(TRACE_PROC_ENTER,("USPowerIrpComplete: Enter...\n"));    
  
    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status = STATUS_SUCCESS;

    if (pIrp -> PendingReturned) {
        IoMarkIrpPending(pIrp);
    }

    pIrpStack = IoGetCurrentIrpStackLocation (pIrp);

    ASSERT(pIrpStack -> MajorFunction == IRP_MJ_POWER);
    ASSERT(pIrpStack -> MinorFunction == IRP_MN_SET_POWER);
    ASSERT(pIrpStack -> Parameters.Power.Type == DevicePowerState);
    ASSERT(pIrpStack -> Parameters.Power.State.DeviceState == PowerDeviceD0);

    pde -> AcceptingRequests = TRUE;
    pde -> CurrentDevicePowerState = PowerDeviceD0;

    pIrp -> IoStatus.Status = Status;
    USDecrementIoCount(pDeviceObject); 

    DebugTrace(TRACE_PROC_LEAVE,("USPowerIrpComplete: Leaving... Status = 0x%x\n", Status));
    return Status;
}


NTSTATUS
USSetDevicePowerState(
    IN PDEVICE_OBJECT pDeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN pHookIt
    )
/*++

Routine Description:

Arguments:
    pDeviceObject - Pointer to the device object for the class device.
    DeviceState - Device specific power state to set the device in to.

Return Value:

--*/
{
    NTSTATUS                    Status;    
    PUSBSCAN_DEVICE_EXTENSION   pde;                    

    DebugTrace(TRACE_PROC_ENTER,("USSetDevicePowerState: Enter...\n"));    
  
    pde    = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status = STATUS_SUCCESS;

    switch (DeviceState) {
    case PowerDeviceD3:

//        ASSERT(pde -> AcceptingRequests);
//        pde -> AcceptingRequests = FALSE;

//        USCancelPipe(pDeviceObject, ALL_PIPE, TRUE);
        
//        pde -> CurrentDevicePowerState = DeviceState;
//        break;

    case PowerDeviceD1:
    case PowerDeviceD2:
#if DBG    
        if (DeviceState) {
            DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD3 (OFF)\n"));                 
        } else {
            DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD1/D2 (SUSPEND)\n"));      
        }
#endif   
        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);
        //
        // power states D1,D2 translate to USB suspend
        // D3 transltes to OFF

        pde -> CurrentDevicePowerState = DeviceState;
        break;

    case PowerDeviceD0:
        DebugTrace(TRACE_STATUS,("USSetDevicePowerState: PowerDeviceD0 (ON)\n"));

        //
        // finish the rest in the completion routine
        //

        *pHookIt = TRUE;

        // pass on to PDO
        
        break;

    default:

        DebugTrace(TRACE_WARNING,("USSetDevicePowerState: Bogus DeviceState = %x\n", DeviceState));
    }

    DebugTrace(TRACE_PROC_LEAVE,("USSetDevicePowerState: Leaving... Status = 0x%x\n", Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\usbd_api.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    usbd_api.h

Abstract:
Function prototype and definition used to build USB request.

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "usbdi.h"
#include "usbdlib.h"


#define OPCODE_SEQ_TRANSFER             0x00    // 00000000b
#define OPCODE_SINGLE_ADDR_TRANSFER     0x08    // 00001000b
#define REGISTER_AREA                   0x04
#define BLOCK                           TRUE
#define DONT_BLOCK                      FALSE

//
// Macros for building URB requests
//

#define UsbBuildSetFeatureDeviceRequest(        \
urb,                                            \
length,                                         \
link,                                           \
featureSelector,                                \
index) {                                        \
       (urb)->UrbHeader.Function =  URB_FUNCTION_SET_FEATURE_TO_DEVICE;     \
       (urb)->UrbHeader.Length = (length);                                  \
       (urb)->UrbControlFeatureRequest.UrbLink = (link);                    \
       (urb)->UrbControlFeatureRequest.FeatureSelector = (featureSelector); \
       (urb)->UrbControlFeatureRequest.Index = (index);                     \
}

#define UsbBuildAbortPipeRequest(               \
urb,                                            \
length,                                         \
handle) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;    \
        (urb)->UrbHeader.Length = (USHORT)length;               \
        (urb)->UrbPipeRequest.PipeHandle = handle;              \
}

#define UsbBuildResetPipeRequest(               \
urb,                                            \
length,                                         \
handle) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;    \
        (urb)->UrbHeader.Length = (USHORT)length;               \
        (urb)->UrbPipeRequest.PipeHandle = handle;              \
}

#define UsbBuildVendorClassSpecificCommand(     \
urb,                                            \
transferFlags,                                  \
bufLength,                                      \
transferBuf,                                    \
transferMdl,                                    \
requestType,                                    \
request,                                        \
value,                                          \
index ) {                                       \
        (urb)->UrbHeader.Function = URB_FUNCTION_VENDOR_DEVICE;                         \
        (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);  \
        (urb)->UrbControlVendorClassRequest.TransferFlags = transferFlags;              \
        (urb)->UrbControlVendorClassRequest.TransferBufferLength = bufLength;           \
        (urb)->UrbControlVendorClassRequest.TransferBuffer = transferBuf;               \
        (urb)->UrbControlVendorClassRequest.TransferBufferMDL = transferMdl;            \
        (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = requestType;      \
        (urb)->UrbControlVendorClassRequest.Request = request;                          \
        (urb)->UrbControlVendorClassRequest.Value = value;                              \
        (urb)->UrbControlVendorClassRequest.Index = index;                              \
}

#define UsbBuildVendorClassSpecificCommandPTP(  \
command,                                        \
urb,                                            \
transferFlags,                                  \
bufLength,                                      \
transferBuf,                                    \
transferMdl,                                    \
requestType,                                    \
request,                                        \
value,                                          \
index ) {                                       \
        (urb)->UrbHeader.Function = command;                                            \
        (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);  \
        (urb)->UrbControlVendorClassRequest.TransferFlags = transferFlags;              \
        (urb)->UrbControlVendorClassRequest.TransferBufferLength = bufLength;           \
        (urb)->UrbControlVendorClassRequest.TransferBuffer = transferBuf;               \
        (urb)->UrbControlVendorClassRequest.TransferBufferMDL = transferMdl;            \
        (urb)->UrbControlVendorClassRequest.RequestTypeReservedBits = requestType;      \
        (urb)->UrbControlVendorClassRequest.Request = request;                          \
        (urb)->UrbControlVendorClassRequest.Value = value;                              \
        (urb)->UrbControlVendorClassRequest.Index = index;                              \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\private.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Prototypes and definitions for the usb scanner device driver.

Author:

Environment:

    kernel mode only

Notes:

Revision History:
--*/

//
// Includes
//

#include "debug.h"

//
// Defines
//

#ifndef max
 #define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
 #define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#ifndef ARRAYSIZE
 #define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

#define TAG_USBSCAN             0x55495453                  // "STIU"
#define TAG_USBD                0x44425355                  // "USBD"

#define USBSCAN_OBJECTNAME_A    "\\\\.\\Usbscan"
#define USBSCAN_OBJECTNAME_W    L"\\\\.\\Usbscan"
#define USBSCAN_REG_CREATEFILE  L"CreateFileName"

#define USBSCAN_TIMEOUT_READ    120                         // 120 sec
#define USBSCAN_TIMEOUT_WRITE   120                         // 120 sec
#define USBSCAN_TIMEOUT_EVENT   0                           // no timeout
#define USBSCAN_TIMEOUT_OTHER   120                         // 120 sec

#define USBSCAN_REG_TIMEOUT_READ    L"TimeoutRead"
#define USBSCAN_REG_TIMEOUT_WRITE   L"TimeoutWrite"
#define USBSCAN_REG_TIMEOUT_EVENT   L"TimeoutEvent"

#define USBSCAN_MAX_CREATEFILENAME  64                      // 64 characters

//
// Private IOCTL to workaround #446466 (Whistler)
//

#define IOCTL_SEND_USB_REQUEST_PTP  CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+20,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Pipe buffer structure for the read pipe only.
//

typedef struct _PIPEBUFFER {
    PUCHAR  pStartBuffer;
    PUCHAR  pBuffer;
    PUCHAR  pNextByte;
    ULONG   RemainingData;
    KEVENT  ReadSyncEvent;
} PIPEBUFFER, *PPIPEBUFFER;


//
// Device Extension
//

typedef struct _USBSCAN_DEVICE_EXTENSION {

    PDEVICE_OBJECT                  pStackDeviceObject;
    PDEVICE_OBJECT                  pPhysicalDeviceObject;
    ULONG                           DeviceInstance;
    UNICODE_STRING                  DeviceName;
    UNICODE_STRING                  SymbolicLinkName;
    KEVENT                          PendingIoEvent;
    ULONG                           PendingIoCount;
    BOOLEAN                         AcceptingRequests;
    BOOLEAN                         Stopped;

    //
    // USB descriptors from the device
    //

    PUSB_DEVICE_DESCRIPTOR          pDeviceDescriptor;
    PUSB_CONFIGURATION_DESCRIPTOR   pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR       pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR        pEndpointDescriptor;

    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;
    USBD_PIPE_INFORMATION           PipeInfo[MAX_NUM_PIPES];
    ULONG                           NumberOfPipes;
    ULONG                           IndexBulkIn;
    ULONG                           IndexBulkOut;
    ULONG                           IndexInterrupt;

    //
    // Name of the device interface
    //
    UNICODE_STRING  InterfaceNameString;

    //
    // Read pipe buffer
    //

    PIPEBUFFER                      ReadPipeBuffer[MAX_NUM_PIPES];

    //
    // Power management variables
    //

    PIRP                            pPowerIrp;
    DEVICE_CAPABILITIES             DeviceCapabilities;
    DEVICE_POWER_STATE              CurrentDevicePowerState;

} USBSCAN_DEVICE_EXTENSION, *PUSBSCAN_DEVICE_EXTENSION;

typedef struct _TRANSFER_CONTEXT {
    ULONG               RemainingTransferLength;
    ULONG               ChunkSize;
    ULONG               NBytesTransferred;
    PUCHAR              pTransferBuffer;
    PUCHAR              pOriginalTransferBuffer;
    PMDL                pTransferMdl;
    ULONG               PipeIndex;
    PURB                pUrb;
    BOOLEAN             fDestinedForReadBuffer;
    BOOLEAN             fNextReadBlocked;
    PIRP                pThisIrp;
    PDEVICE_OBJECT      pDeviceObject;
    LARGE_INTEGER       Timeout;
    KDPC                TimerDpc;
    KTIMER              Timer;
} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;

typedef struct _USBSCAN_FILE_CONTEXT {
    LONG            PipeIndex;
    ULONG           TimeoutRead;
    ULONG           TimeoutWrite;
    ULONG           TimeoutEvent;
} USBSCAN_FILE_CONTEXT, *PUSBSCAN_FILE_CONTEXT;

typedef struct _USBSCAN_PACKTES {
    PIRP    pIrp;
    ULONG   TimeoutCounter;
    BOOLEAN bCompleted;
    LIST_ENTRY  PacketsEntry;
} USBSCAN_PACKETS, *PUSBSCAN_PACKETS;

#ifdef _WIN64
typedef struct _IO_BLOCK_32 {
    IN      unsigned            uOffset;
    IN      unsigned            uLength;
    IN OUT  CHAR * POINTER_32   pbyData;
    IN      unsigned            uIndex;
} IO_BLOCK_32, *PIO_BLOCK_32;

typedef struct _IO_BLOCK_EX_32 {
    IN      unsigned            uOffset;
    IN      unsigned            uLength;
    IN OUT  CHAR * POINTER_32   pbyData;
    IN      unsigned            uIndex;
    IN      UCHAR               bRequest;               // Specific request
    IN      UCHAR               bmRequestType;          // Bitmap - charateristics of request
    IN      UCHAR               fTransferDirectionIn;   // TRUE - Device-->Host; FALSE - Host-->Device
} IO_BLOCK_EX_32, *PIO_BLOCK_EX_32;
#endif // _WIN64

//
// prototypes
//

NTSTATUS                                // in usbscan.c
DriverEntry(
        IN PDRIVER_OBJECT  DriverObject,
        IN PUNICODE_STRING RegistryPath
);

VOID                                    // in usbscan.c
USUnload(
        IN PDRIVER_OBJECT DriverObject
);

VOID                                    // in usbscan.c
USIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
);

LONG                                    // in usbscan.c
USDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
USDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp,
    IN PVOID          Context
);

NTSTATUS                                // in usbscan.c
USCreateSymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
);

NTSTATUS                                // in usbscan.c
USDestroySymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
);

NTSTATUS                                // in usbscan.c
USPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
);

NTSTATUS                                // in usbscan.c
USPnpAddDevice(
    IN PDRIVER_OBJECT     pDriverObject,
    IN OUT PDEVICE_OBJECT pPhysicalDeviceObject
);

NTSTATUS                                // in usbscan.c
USGetUSBDeviceDescriptor(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
USBSCAN_CallUSBD(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PURB pUrb
);

NTSTATUS                                // in usbscan.c
USConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
USUnConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in usbscan.c
UsbScanReadDeviceRegistry(
    IN  PUSBSCAN_DEVICE_EXTENSION   pExtension,
    IN  PCWSTR                      pKeyName,
    OUT PVOID                       *ppvData
    );

NTSTATUS                                // in usbscan.c
UsbScanWriteDeviceRegistry(
    IN PUSBSCAN_DEVICE_EXTENSION    pExtension,
    IN PCWSTR                       pKeyName,
    IN ULONG                        Type,
    IN PVOID                        pvData,
    IN ULONG                        DataSize
    );

PURB
USCreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor,
    IN OUT PUSHORT                      Siz
    );

#ifdef ORIGINAL_POOLTRACK
PVOID                                   // in usbscan.c
USAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
    );

VOID                                    // in usbscan.c
USFreePool(
    IN PVOID     pvAddress
    );

#else       // ORIGINAL_POOLTRACK
 #define USAllocatePool(a, b)   ExAllocatePoolWithTag(a, b, NAME_POOLTAG)
 #define USFreePool(a)          ExFreePool(a)
#endif      // ORIGINAL_POOLTRACK

NTSTATUS                                // in ioctl.c
USDeviceControl(
        IN PDEVICE_OBJECT pDeviceObject,
        IN PIRP pIrp
    );

NTSTATUS                                // in ioctl.c
USReadWriteRegisters(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIO_BLOCK      pIoBlock,
    IN BOOLEAN        fRead,
    IN ULONG          IoBlockSize
    );

NTSTATUS                               // in ioctl.c
USPassThruUSBRequest(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
    );

NTSTATUS                               // in ioctl.c
USPassThruUSBRequestPTP(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIO_BLOCK_EX     pIoBlockEx,
    IN ULONG            InLength,
    IN ULONG            OutLength
    );


NTSTATUS                                // in ioctl.c
USCancelPipe(
        IN PDEVICE_OBJECT   pDeviceObject,
        IN PIRP             pIrp,
        IN PIPE_TYPE        PipeType,
        IN BOOLEAN          fAbort
    );

NTSTATUS                                // in ioctl.c
USAbortResetPipe(
        IN PDEVICE_OBJECT pDeviceObject,
        IN ULONG uIndex,
    IN BOOLEAN fAbort
    );

NTSTATUS                                // in ocrw.c
USOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USFlush(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS                                // in ocrw.c
USTransfer(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp,
    IN ULONG            PipeIndex,
    IN PVOID            pBuffer,
    IN PMDL             pMdl,
    IN ULONG            TransferSize,
    IN PULONG           pTimeout
    );

NTSTATUS                                // in ocrw.c
USTransferComplete(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PTRANSFER_CONTEXT    pTransferContext
    );

VOID                                    // in ocrw.c
USCancelIrp(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

NTSTATUS                                // in ocrw.c
USEnqueueIrp(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PUSBSCAN_PACKETS     pPackets
    );

PUSBSCAN_PACKETS                        // in ocrw.c
USDequeueIrp(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

VOID                                    // in ocrw.c
USWaitThread(
    IN PVOID pTransferContext
    );

ULONG
USGetPipeIndexToUse(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN ULONG                PipeIndex
    );

VOID
USTimerDpc(
    IN PKDPC    pDpc,
    IN PVOID    pIrp,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );


NTSTATUS                                // in power.c
USPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );


NTSTATUS                                // in power.c
USPoRequestCompletion(
    IN PDEVICE_OBJECT       pPdo,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIO_STATUS_BLOCK     pIoStatus
    );

USPowerIrpComplete(                     // in power.c
    IN PDEVICE_OBJECT pPdo,
    IN PIRP           pIrp,
    IN PDEVICE_OBJECT pDeviceObject
);

NTSTATUS                                // in power.c
USSetDevicePowerState(
    IN PDEVICE_OBJECT pDeviceObject,
    IN DEVICE_POWER_STATE DeviceState,
    IN PBOOLEAN pHookIt
);

NTSTATUS
USCallNextDriverSynch(
    IN  PUSBSCAN_DEVICE_EXTENSION  pde,
    IN  PIRP              pIrp
    );


NTSTATUS
UsbScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );



VOID
UsbScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\cab\winnt5\makefile.inc ===
TARGET_EXE=obj\$(TARGET_DIRECTORY)\wiasetup.exe

!if "$(PASS0ONLY)"=="1"
$(TARGET_EXE): $(_NTTREE)\wiaservc.dll
    copy wiant50.sed obj
    echo SourceFiles0=$(_NTTREE)\ >> obj\wiant50.sed
    copy obj\wiant50.sed $(_NTTREE)
    iexpress /Q /N $(_NTTREE)\wiant50.sed
    move wiasetup.exe obj\$(TARGET_DIRECTORY)
    #copy obj\$(TARGET_DIRECTORY)\wiasetup.exe $(_NTTREE)
!else
$(TARGET_CAB):
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\usbscan\usbscan.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    usbscan.c

Abstract:

Author:

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include <wdm.h>
#include <stdio.h>
#include <usbscan.h>
#include <usbd_api.h>
#include "private.h"

#include <initguid.h>
#include <devguid.h>
#include <wiaintfc.h>


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, USPnpAddDevice)
#pragma alloc_text(PAGE, USPnp)
#pragma alloc_text(PAGE, USCreateSymbolicLink)
#pragma alloc_text(PAGE, USDestroySymbolicLink)
#pragma alloc_text(PAGE, USGetUSBDeviceDescriptor)
#pragma alloc_text(PAGE, USConfigureDevice)
#pragma alloc_text(PAGE, USUnConfigureDevice)
#pragma alloc_text(PAGE, USUnload)
#endif

// Globals

ULONG NextDeviceInstance = 0;

#if DBG
ULONG USBSCAN_DebugTraceLevel = MIN_TRACE;
ULONG USBSCAN_PnPTest = 0;
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath
)
{
/*++

   Routine Description:
   Installable driver initialization entry point.
   This is where the driver is called when the driver is being loaded
   by the I/O system.

   Arguments:
   DriverObject - pointer to the driver object
   RegistryPath - pointer to a unicode string representing the path
   to driver-specific key in the registry

   Return Value:
   STATUS_SUCCESS       if successful,
   STATUS_UNSUCCESSFUL  otherwise

   -- */

    NTSTATUS    Status;
    
    PAGED_CODE();

    DebugTrace((MIN_TRACE | TRACE_FLAG_PROC),("DriverEntry called. Driver reg=%wZ\n",pRegistryPath));

    //
    // Initialize local.
    //

    Status = STATUS_SUCCESS;

    //
    // Check arguments.
    //
    
    if( (NULL == pDriverObject)
     || (NULL == pRegistryPath) )
    {
        DebugTrace(TRACE_ERROR,("DriverEntry: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto DriverEntry_return;
    }

#if DBG
    MyDebugInit(pRegistryPath);
#endif // DBG

    pDriverObject -> MajorFunction[IRP_MJ_READ]            = USRead;
    pDriverObject -> MajorFunction[IRP_MJ_WRITE]           = USWrite;
    pDriverObject -> MajorFunction[IRP_MJ_DEVICE_CONTROL]  = USDeviceControl;
    pDriverObject -> MajorFunction[IRP_MJ_CREATE]          = USOpen;
    pDriverObject -> MajorFunction[IRP_MJ_CLOSE]           = USClose;
    pDriverObject -> MajorFunction[IRP_MJ_PNP_POWER]       = USPnp;
    pDriverObject -> MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = USFlush;
    pDriverObject -> MajorFunction[IRP_MJ_POWER]           = USPower;
    pDriverObject -> MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = USPnp;
    pDriverObject -> DriverExtension -> AddDevice          = USPnpAddDevice;
    pDriverObject -> DriverUnload                          = USUnload;

DriverEntry_return:

    return Status;
}

NTSTATUS
USPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN OUT PDEVICE_OBJECT pPhysicalDeviceObject
)

/*++

Routine Description:

    This routine is called to create a new instance of the device.

Arguments:

    pDriverObject - pointer to the driver object for this instance of SS
    pPhysicalDeviceObject - pointer to the device object that represents the scanner
    on the scsi bus.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UCHAR                       aName[64];
    ANSI_STRING                 ansiName;
    UNICODE_STRING              uName;
    PDEVICE_OBJECT              pDeviceObject = NULL;
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPnpAddDevice: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDriverObject)
     || (NULL == pPhysicalDeviceObject) )
    {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USPnpAddDevice: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    //
    // Create the Functional Device Object (FDO) for this device.
    //

    _snprintf(aName, ARRAYSIZE(aName), "\\Device\\Usbscan%d",NextDeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);

    //
    // Show device object name.
    //

    DebugTrace(TRACE_STATUS,("USPnpAddDevice: Create device object %s\n", aName));

    //
    // Allocates Unicode string.
    //

    Status = RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USPnpAddDevice: ERROR!! Can't alloc buffer for Unicode\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USPnpAddDevice_return;
    }

    //
    // Create device object for this scanner.
    //

    Status = IoCreateDevice(pDriverObject,
                            sizeof(USBSCAN_DEVICE_EXTENSION),
                            &uName,
                            FILE_DEVICE_SCANNER,
                            0,
                            FALSE,
                            &pDeviceObject);

    if (!NT_SUCCESS(Status)) {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Can't create device object\n"));
        DEBUG_BREAKPOINT();
        goto USPnpAddDevice_return;
    }

    //
    // Device object was successfully created.
    // Free Unicode string used for device creation.
    //

    RtlFreeUnicodeString(&uName);
    uName.Buffer = NULL;

    //
    // Initialize Device Extension.
    //

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    RtlZeroMemory(pde, sizeof(USBSCAN_DEVICE_EXTENSION));

    //
    // Initialize PendingIoEvent.  Set the number of pending i/o requests for this device to 1.
    // When this number falls to zero, it is okay to remove, or stop the device.
    //

    pde -> PendingIoCount = 0;
    pde -> Stopped = FALSE;
    KeInitializeEvent(&pde -> PendingIoEvent, NotificationEvent, FALSE);

    //
    // Indicate that IRPs should include MDLs.
    //

    pDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // indicate our power code is pagable
    //

    pDeviceObject->Flags |= DO_POWER_PAGABLE;

    //
    // Attach our new FDO to the PDO (Physical Device Object).
    //

    pde -> pStackDeviceObject = IoAttachDeviceToDeviceStack(pDeviceObject,
                                                            pPhysicalDeviceObject);
    if (NULL == pde -> pStackDeviceObject) {
        DebugTrace(TRACE_ERROR,("USPnpAddDevice: ERROR!! Cannot attach FDO to PDO.\n"));
        DEBUG_BREAKPOINT();
        IoDeleteDevice( pDeviceObject );
        Status = STATUS_NOT_SUPPORTED;
        goto USPnpAddDevice_return;
    }

    //
    // Remember the PDO in our device extension.
    //

    pde -> pPhysicalDeviceObject = pPhysicalDeviceObject;

    //
    // Remember the DeviceInstance number.
    //

    pde -> DeviceInstance = NextDeviceInstance;

    //
    // Handle exporting interface
    //

    Status = UsbScanHandleInterface(
        pPhysicalDeviceObject,
        &pde->InterfaceNameString,
        TRUE
        );

    //
    // Each time AddDevice gets called, we advance the global DeviceInstance variable.
    //

    NextDeviceInstance++;

    //
    // Set initial device power state as online.
    //

    pde -> CurrentDevicePowerState = PowerDeviceD0;

    //
    // Finish initializing.
    //

    pDeviceObject -> Flags &= ~DO_DEVICE_INITIALIZING;

USPnpAddDevice_return:

    if(NULL != uName.Buffer){
        RtlFreeUnicodeString(&uName);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USPnpAddDevice: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // end USAddDevice()


NTSTATUS USPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
)
/*++

Routine Description:

    This routine handles all PNP irps.

Arguments:

    pDeviceObject - represents a scanner device
    pIrp - PNP irp

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIO_STACK_LOCATION          pIrpStack;
    KEVENT                      event;
    PDEVICE_CAPABILITIES        pCaps;
    LONG                        bTemp;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USPnp: Enter..\n"));

    //
    // Check arguments.
    //

    if( (NULL == pDeviceObject)
     || (NULL == pDeviceObject->DeviceExtension)
     || (NULL == pIrp) )
    {
        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Invalid parameter passed.\n"));
        Status = STATUS_INVALID_PARAMETER;
        DebugTrace(TRACE_PROC_LEAVE,("USPnp: Leaving.. Status = %x.\n", Status));
        return Status;
    }

    pde = (PUSBSCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Status = pIrp -> IoStatus.Status;

//  DbgPrint("USPnP: Major=0x%x, Minor=0x%x\n",
//           pIrpStack -> MajorFunction,
//           pIrpStack->MinorFunction);

    switch (pIrpStack -> MajorFunction) {

        case IRP_MJ_SYSTEM_CONTROL:
            DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_SYSTEM_CONTROL\n"));

            //
            // Simply passing down the IRP.
            //

            DebugTrace(TRACE_STATUS,("USPnp: Simply passing down the IRP\n"));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            break;

        case IRP_MJ_PNP:
            DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_PNP\n"));
            switch (pIrpStack->MinorFunction) {

                case IRP_MN_QUERY_CAPABILITIES:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_QUERY_CAPS\n"));

                    //
                    // Call downlevel driver first to fill capabilities structure
                    // Then add our specific capabilities
                    //

                    DebugTrace(TRACE_STATUS,("USPnp: Call down to get capabilities\n"));

                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    Status = USCallNextDriverSynch(pde, pIrp);

                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Call down failed. Status=0x%x\n", Status));
                        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                        goto USPnP_return;
                    }

                    //
                    // Set SurpriseRemoval OK
                    //

                    pCaps = pIrpStack -> Parameters.DeviceCapabilities.Capabilities;
                    pCaps->SurpriseRemovalOK = TRUE;
                    pCaps->Removable = TRUE;

                    //
                    // Set returning status.
                    //

                    Status = STATUS_SUCCESS;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    goto USPnP_return;

                    break;


                case IRP_MN_START_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MJ_START_DEVICE\n"));

                    pde -> Stopped = FALSE;
                    USIncrementIoCount(pDeviceObject);

                    //
                    // First, let the port driver start the device.
                    //

                    Status = USCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){

                        //
                        // Lower layer failed to start device.
                        //

                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Lower layer failed to start device. Status=0x%x\n", Status));
                        break;
                    }

                    //
                    // The port driver has started the device.  It is time for
                    // us to do some initialization and create symbolic links
                    // for the device.
                    //
                    // Get the device descriptor and save it in our
                    // device extension.
                    //

                    Status = USGetUSBDeviceDescriptor(pDeviceObject);
                    if(!NT_SUCCESS(Status)){

                        //
                        // GetDescriptor failed.
                        //

                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Cannot get DeviceDescriptor.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Configure the device.
                    //

                    Status = USConfigureDevice(pDeviceObject);
#if DBG
                    //DEBUG_BREAKPOINT();
                    if (USBSCAN_PnPTest) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
#endif

                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR,("USPnp: ERROR!! Can't configure the device.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Create the symbolic link for this device.
                    //

                    Status = USCreateSymbolicLink( pde );
#if DBG
                    //DEBUG_BREAKPOINT();
                    if (USBSCAN_PnPTest) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
#endif
                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR, ("USPnp: ERROR!! Can't create symbolic link.\n"));
                        DEBUG_BREAKPOINT();
                        break;
                    }

                    //
                    // Initialize the synchronize read event.  This event is used the serialze
                    // i/o requests to the read pipe if the request size is NOT a usb packet multiple.
                    //

                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
                             && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
                            {
                                DebugTrace(TRACE_STATUS,("USPnp: Initializing event for Pipe[%d]\n", i));
                                KeInitializeEvent(&pde -> ReadPipeBuffer[i].ReadSyncEvent, SynchronizationEvent, TRUE);
                            }
                        }
                    }

                    //
                    // Indicate device is now ready.
                    //

                    pde -> AcceptingRequests = TRUE;

                    //
                    // Set return status.
                    //

                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    goto USPnP_return;

                case IRP_MN_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_REMOVE_DEVICE\n"));

                    //
                    // Prohivit further request.
                    //

                    bTemp = (LONG)InterlockedExchange((PULONG)&(pde -> AcceptingRequests),
                                                      (LONG)FALSE );

                    //
                    // Wait for any io requests pending in our driver to
                    // complete before proceeding the remove.
                    //

                    if (!pde -> Stopped ) {
                        USDecrementIoCount(pDeviceObject);
                    }

                    KeWaitForSingleObject(&pde -> PendingIoEvent,
                                          Suspended,
                                          KernelMode,
                                          FALSE,NULL);

                    //
                    // Is this device stopped/removed before?
                    //

                    if (bTemp) {

                        //
                        // Delete symbolic link.
                        //

                        USDestroySymbolicLink( pde );

                        //
                        // Abort all pipes.
                        //

                        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);
                    }

                    //
                    // Disable device interface.
                    //

                    UsbScanHandleInterface(pde->pPhysicalDeviceObject,
                                           &pde->InterfaceNameString,
                                           FALSE);

                    //
                    // Forward remove message to lower driver.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

                    //
                    // Free allocated memory.
                    //

                    if (pde -> pDeviceDescriptor) {
                        USFreePool(pde -> pDeviceDescriptor);
                        pde -> pDeviceDescriptor = NULL;
                    }

                    if (pde -> pConfigurationDescriptor) {
                        USFreePool(pde -> pConfigurationDescriptor);
                        pde -> pConfigurationDescriptor = NULL;
                    }

                    //
                    // Free allocated buffer(s)
                    //
                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if(pde->ReadPipeBuffer[i].pStartBuffer){
                                USFreePool(pde->ReadPipeBuffer[i].pStartBuffer);
                                pde->ReadPipeBuffer[i].pStartBuffer = NULL;
                                pde->ReadPipeBuffer[i].pBuffer = NULL;
                            }
                        }
                    }

                    //
                    // Detatch device object from stack.
                    //

                    IoDetachDevice(pde -> pStackDeviceObject);

                    //
                    // Delete device object
                    //

                    IoDeleteDevice (pDeviceObject);
                    pDeviceObject = NULL;

                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_REMOVE_DEVICE complete\n"));
                    goto USPnP_return;

                case IRP_MN_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_STOP_DEVICE\n"));

                    //
                    // Indicate device is stopped.
                    //

                    pde -> Stopped = TRUE;

                    if (pde -> AcceptingRequests) {

                        //
                        // No more requests are allowed.
                        //

                        pde -> AcceptingRequests = FALSE;

                        //
                        // Delete symbolic link.
                        //

                        USDestroySymbolicLink( pde );

                        //
                        // Abort all pipes.
                        //

                        USCancelPipe(pDeviceObject, NULL, ALL_PIPE, TRUE);

                        //
                        // Set device into unconfigured state.
                        //

                        USUnConfigureDevice(pDeviceObject);

                    } //(pde -> AcceptingRequests)

#ifndef _CHICAGO_
                    //
                    // Disable device interface.
                    //

                    if (pde->InterfaceNameString.Buffer != NULL) {
                        IoSetDeviceInterfaceState(&pde->InterfaceNameString,FALSE);
                    }
#endif // _CHICAGO_

                    //
                    // Let the port driver stop the device.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

                    //
                    // wait for any io requests pending in our driver to
                    // complete before finishing the remove
                    //

                    USDecrementIoCount(pDeviceObject);
                    KeWaitForSingleObject(&pde -> PendingIoEvent, Suspended, KernelMode,
                                          FALSE,NULL);

                    ASSERT(pde -> pDeviceDescriptor);
                    ASSERT(pde -> pConfigurationDescriptor);

                    if (pde -> pDeviceDescriptor) {
                        USFreePool(pde -> pDeviceDescriptor);
                        pde -> pDeviceDescriptor = NULL;
                    }

                    if (pde -> pConfigurationDescriptor) {
                        USFreePool(pde -> pConfigurationDescriptor);
                        pde -> pConfigurationDescriptor = NULL;
                    }

                    //
                    // Free allocated buffer(s)
                    //
                    {
                        ULONG i;
                        for(i = 0; i < pde->NumberOfPipes; i++){
                            if(pde->ReadPipeBuffer[i].pBuffer){
                                USFreePool(pde->ReadPipeBuffer[i].pBuffer);
                                pde->ReadPipeBuffer[i].pBuffer = NULL;
                            }
                        }
                    }

                    goto USPnP_return;

                case IRP_MN_QUERY_INTERFACE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_INTERFACE\n"));
                    break;

                case IRP_MN_QUERY_RESOURCES:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_RESOURCES\n"));
                    break;

                case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n"));
                    break;

                case IRP_MN_QUERY_DEVICE_TEXT:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_DEVICE_TEXT\n"));
                    break;

//                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
//                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_LEGACY_BUS_INFORMATION\n"));
//                    break;

                case IRP_MN_QUERY_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_STOP_DEVICE\n"));
                    break;

                case IRP_MN_QUERY_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_REMOVE_DEVICE\n"));
                    break;

                case IRP_MN_CANCEL_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_CANCEL_STOP_DEVICE\n"));
                    break;

                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
                    break;

                case IRP_MN_QUERY_DEVICE_RELATIONS:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_QUERY_DEVICE_RELATIONS\n"));
                    break;

                case IRP_MN_SURPRISE_REMOVAL:
                    DebugTrace(TRACE_STATUS,("USPnp: IRP_MN_SURPRISE_REMOVAL\n"));

                    //
                    // Indicate interface is stopped
                    //

                    UsbScanHandleInterface(pde->pPhysicalDeviceObject,
                                           &pde->InterfaceNameString,
                                           FALSE);

                    break;

                default:
                    DebugTrace(TRACE_STATUS,("USPnp: Minor PNP message. MinorFunction = 0x%x\n",pIrpStack->MinorFunction));
                    break;

            } /* case MinorFunction, MajorFunction == IRP_MJ_PNP_POWER  */

            //
            // Passing down IRP
            //

            IoCopyCurrentIrpStackLocationToNext(pIrp);
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

            DebugTrace(TRACE_STATUS,("USPnp: Passed Pnp Irp down,  status = %x\n", Status));

            if(!NT_SUCCESS(Status)){
                DebugTrace(TRACE_WARNING,("USPnp: WARNING!! IRP Status failed,  status = %x\n", Status));
                // DEBUG_BREAKPOINT();
            }
            break; // IRP_MJ_PNP

        default:
            DebugTrace(TRACE_STATUS,("USPnp: Major PNP IOCTL not handled\n"));
            Status = STATUS_INVALID_PARAMETER;
            pIrp -> IoStatus.Status = Status;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );
            goto USPnP_return;

    } /* case MajorFunction */


USPnP_return:
    DebugTrace(TRACE_PROC_LEAVE,("USPnP: Leaving.. Status = 0x%x\n", Status));
    return Status;

} // end USPnp()



NTSTATUS
USCreateSymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
)
/*++

Routine Description:
    This routine create the symbolic link for the device.

Arguments:
    pde - pointer to device extension

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    ANSI_STRING                   ansiName;
    CHAR                          aName[64];
    HANDLE                        hSwKey;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USCreateSymbolicLink: Enter..\n"));


    //
    // Initialize
    //

    Status = STATUS_SUCCESS;
    RtlZeroMemory(&uName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&uName2, sizeof(UNICODE_STRING));
    RtlZeroMemory(&ansiName, sizeof(ANSI_STRING));
    hSwKey = NULL;


    //
    // Create the symbolic link for this device.
    //

    _snprintf(aName, ARRAYSIZE(aName), "\\Device\\Usbscan%d",pde -> DeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);

    Status = RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    _snprintf(aName, ARRAYSIZE(aName), "\\DosDevices\\Usbscan%d",pde -> DeviceInstance);
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);

    Status = RtlAnsiStringToUnicodeString(&(pde -> SymbolicLinkName), &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    //
    // Create Sympolic link.
    //

    Status = IoCreateSymbolicLink( &(pde -> SymbolicLinkName), &uName );

    RtlFreeUnicodeString( &uName );
    uName.Buffer = NULL;

    if (STATUS_SUCCESS != Status ) {
        DebugTrace(TRACE_ERROR,("USCreateSymbolicLink: ERROR!! Cannot create symbolic link.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_NOT_SUPPORTED;
        goto USCreateSymbolicLink_return;
    }

    //
    // Now, stuff the symbolic link into the CreateFileName key so that STI can find the device.
    //

    IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                             PLUGPLAY_REGKEY_DRIVER, KEY_WRITE, &hSwKey);

    //
    // Create CreateFile name. ("\\.\UsbscanX")
    //

    RtlInitUnicodeString(&uName,USBSCAN_REG_CREATEFILE);    // L"CreateFileName"
    _snprintf(aName, ARRAYSIZE(aName), "%s%d", USBSCAN_OBJECTNAME_A, pde -> DeviceInstance); // "\\\\.\\Usbscan%d"
    aName[ARRAYSIZE(aName)-1] = '\0';
    RtlInitAnsiString(&ansiName, aName);
    Status = RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USCreateSymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USCreateSymbolicLink_return;
    }

    //
    // Set CreateFile name to the registry.
    //

    ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);

    //
    // uName is not allocated. Just zero it.
    //

    RtlZeroMemory(&uName, sizeof(UNICODE_STRING));

USCreateSymbolicLink_return:

    if(NULL != hSwKey){
        ZwClose(hSwKey);
    }

    if(NULL != uName.Buffer){
        RtlFreeUnicodeString( &uName );
    }

    if(NULL != uName2.Buffer){
        RtlFreeUnicodeString( &uName2 );
    }

    DebugTrace(TRACE_PROC_LEAVE,("USCreateSymbolicLink: Leaving.. Status = 0x%x\n", Status));
    return Status;

}  // end USCreateSymbolicLink()


NTSTATUS
USDestroySymbolicLink(
    PUSBSCAN_DEVICE_EXTENSION  pde
)
/*++

Routine Description:
    This routine removes the symbolic link for the device.

Arguments:
    pde - pointer to device extension

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    UNICODE_STRING                uNumber;
    ANSI_STRING                   ansiName;
    CHAR                          aName[64];
    HANDLE                        hSwKey;
    WCHAR                         wsCreateFileName[USBSCAN_MAX_CREATEFILENAME];
    ULONG                         ulBufLength, ulRetLength;
    NTSTATUS                      Status;
    PVOID                         pvNumber;
    ULONG                         ulNumber;
    const WCHAR                   wcsObjectName[] = USBSCAN_OBJECTNAME_W;   // L"\\\\.\\Usbscan"
    ULONG                         uiObjectNameLen = wcslen(wcsObjectName) * sizeof(WCHAR) ;

    PAGED_CODE();


    DebugTrace(TRACE_PROC_ENTER,("USDestroySymbolicLink: Enter..\n"));

    //
    // Delete the symbolic link to this device.
    //

    IoDeleteSymbolicLink( &(pde -> SymbolicLinkName) );

    //
    // Remove the CreateFile name from the s/w key, if it's created by this device object.
    //

    Status = IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                                      PLUGPLAY_REGKEY_DRIVER,
                                      KEY_ALL_ACCESS,
                                      &hSwKey);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! IoOpenDeviceRegistryKey Failed\n"));
        DEBUG_BREAKPOINT();
        goto USDestroySymbolicLink_return;
    }

    RtlInitUnicodeString(&uName,USBSCAN_REG_CREATEFILE); // L"CreateFileName"
    memset(aName, 0, sizeof(aName));
    RtlInitAnsiString(&ansiName, aName);
    Status = RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_CRITICAL,("USDestroySymbolicLink: ERROR!! Cannot allocate buffer for Unicode srting\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USDestroySymbolicLink_return;
    }

    //
    // Check if this CreateFile name is created by this device object.
    //

    //
    // Query CreateFile name from the registry.
    //

    ulBufLength = sizeof(wsCreateFileName);
    Status = ZwQueryValueKey(hSwKey,
                             &uName,
                             KeyValuePartialInformation,
                             (PVOID)wsCreateFileName,
                             ulBufLength,
                             &ulRetLength);
    if(STATUS_SUCCESS != Status){
        DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! Cannot query registry.\n"));
        RtlFreeUnicodeString( &uName2 );
        uName2.Buffer = NULL;
        goto USDestroySymbolicLink_return;
    }

    //
    // Make sure the buffer is NULL terminated.
    //

    wsCreateFileName[ARRAYSIZE(wsCreateFileName)-1] = L'\0';

    if (NULL != wsCreateFileName){
        DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: CreateFileName=%ws, DeviceInstance=%d.\n",
                                    ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->Data,
                                    pde -> DeviceInstance));

        //
        // Get instance number of CreteFile name.
        //

        pvNumber = wcsstr((const wchar_t *)((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->Data, wcsObjectName);
        if(NULL != pvNumber){

            //
            //  Move pointer forward. (sizeof(L"\\\\.\\Usbscan") == 22)
            //

//            if( ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->DataLength > sizeof(wcsObjectName) ){
//              (PCHAR)pvNumber += sizeof(wcsObjectName);

            if( ((PKEY_VALUE_PARTIAL_INFORMATION)wsCreateFileName)->DataLength > uiObjectNameLen ){
                (PCHAR)pvNumber += uiObjectNameLen;
            } else {
                DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! CreateFile name too short.\n"));
                RtlFreeUnicodeString( &uName2 );
                uName2.Buffer = NULL;
                ZwClose(hSwKey);
                goto USDestroySymbolicLink_return;
            }

            //
            // Translate X of UsbscanX to integer.
            //

            RtlInitUnicodeString(&uNumber, pvNumber);
            Status = RtlUnicodeStringToInteger(&uNumber,
                                               10,
                                               &ulNumber);
            if(STATUS_SUCCESS != Status){
                DebugTrace(TRACE_ERROR,("USDestroySymbolicLink: ERROR!! RtlUnicodeStringToInteger failed.\n"));
                RtlFreeUnicodeString( &uName2 );
                uName2.Buffer = NULL;
                ZwClose(hSwKey);
                goto USDestroySymbolicLink_return;
            }

            //
            // See if this CreateFile name is made by this instance.
            //

            if(ulNumber == pde -> DeviceInstance){

                //
                // Delete CreateFile name in the registry.
                //

                DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: Deleting %ws%d\n",
                                            wcsObjectName,
                                            ulNumber));
                ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);
            } else {

                //
                // CreateFile name is created by other instance.
                //

                DebugTrace(TRACE_STATUS,("USDestroySymbolicLink: CreateFile name is created by other instance.\n"));
            }
        } else { // (NULL != pvNumber)

            //
            // "Usbscan" was not found in CreateFile name.
            //

            DebugTrace(TRACE_WARNING,("USDestroySymbolicLink: WARNING!! Didn't find \"Usbscan\" in CreateFileName\n"));
        }
    } else { // (NULL != wsCreateFileName)

        //
        // Query CreateFile name returned NULL.
        //

        DebugTrace(TRACE_WARNING,("USDestroySymbolicLink: WARNING!! CreateFileName=NULL\n"));
    }

    //
    // Free allocated memory.
    //

    RtlFreeUnicodeString( &uName2 );

    //
    // Close registry.
    //

    ZwClose(hSwKey);


USDestroySymbolicLink_return:

    //
    // Free allocated string buffer in DeviceObject.
    //

    RtlFreeUnicodeString( &(pde -> SymbolicLinkName) );

    DebugTrace(TRACE_PROC_LEAVE,("USDestroySymbolicLink: Leaving.. Status = 0x%x\n",Status));
    return Status;

} // end USDestroySymbolicLink()


NTSTATUS
USGetUSBDeviceDescriptor(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:
   Retrieves the USB device descriptor and stores it in the device
   extension. This descriptor contains product info and
   endpoint 0 (default pipe) info.

Arguments:
    pDeviceObject - pointer to device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    PUSBSCAN_DEVICE_EXTENSION   pde;
    NTSTATUS                    Status;
    PUSB_DEVICE_DESCRIPTOR      pDeviceDescriptor;
    PURB                        pUrb;
    ULONG                       siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USGetUSBDeviceDescriptor: Enter..\n"));

    pde = pDeviceObject->DeviceExtension;

    //
    // Allocate pool for URB.
    //

    pUrb = USAllocatePool(NonPagedPool,
                          sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USGetUSBDeviceDescriptor: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USGetUSBDeviceDescriptor_return;
    }

    //
    // Allocate pool for Descriptor.
    //

    siz = sizeof(USB_DEVICE_DESCRIPTOR);
    pDeviceDescriptor = USAllocatePool(NonPagedPool, siz);

    if (NULL == pDeviceDescriptor) {
        DebugTrace(TRACE_CRITICAL,("USGetUSBDeviceDescriptor: ERROR!! cannot allocated device descriptor\n"));
        DEBUG_BREAKPOINT();
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USGetUSBDeviceDescriptor_return;
    }

    //
    // Do Macro to set parameter for GetDescriptor to URB.
    //

    UsbBuildGetDescriptorRequest(pUrb,
                                 (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 pDeviceDescriptor,
                                 NULL,
                                 siz,
                                 NULL);

    //
    // Call down.
    //

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

#if DBG
    //DEBUG_BREAKPOINT();
    if (USBSCAN_PnPTest) {
        Status = STATUS_UNSUCCESSFUL;
    }
#endif

    if (STATUS_SUCCESS == Status) {

        //
        // Show device descriptor.
        //

        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: Device Descriptor = %x, len %x\n",
                                   pDeviceDescriptor,
                                   pUrb->UrbControlDescriptorRequest.TransferBufferLength));

        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: USBSCAN Device Descriptor:\n"));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: -------------------------\n"));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bLength            %d\n",   pDeviceDescriptor -> bLength));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDescriptorType    0x%x\n", pDeviceDescriptor -> bDescriptorType));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bcdUSB             0x%x\n", pDeviceDescriptor -> bcdUSB));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceClass       0x%x\n", pDeviceDescriptor -> bDeviceClass));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceSubClass    0x%x\n", pDeviceDescriptor -> bDeviceSubClass));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bDeviceProtocol    0x%x\n", pDeviceDescriptor -> bDeviceProtocol));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bMaxPacketSize0    0x%x\n", pDeviceDescriptor -> bMaxPacketSize0));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: idVendor           0x%x\n", pDeviceDescriptor -> idVendor));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: idProduct          0x%x\n", pDeviceDescriptor -> idProduct));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bcdDevice          0x%x\n", pDeviceDescriptor -> bcdDevice));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iManufacturer      0x%x\n", pDeviceDescriptor -> iManufacturer));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iProduct           0x%x\n", pDeviceDescriptor -> iProduct));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: iSerialNumber      0x%x\n", pDeviceDescriptor -> iSerialNumber));
        DebugTrace(TRACE_DEVICE_DATA,("USGetUSBDeviceDescriptor: bNumConfigurations 0x%x\n", pDeviceDescriptor -> bNumConfigurations));

        //
        // Save pointer to device descriptor in our device extension
        //

        pde -> pDeviceDescriptor = pDeviceDescriptor;

    } else { // (STATUS_SUCCESS == Status)

        //
        // Error returned from lower driver.
        //

        DebugTrace(TRACE_ERROR,("USGetUSBDeviceDescriptor: ERROR!! Cannot get device descriptor. (%x)\n", Status));
        USFreePool(pDeviceDescriptor);
        pDeviceDescriptor = NULL;
    } // (STATUS_SUCCESS == Status)

    USFreePool(pUrb);
    pUrb = NULL;

USGetUSBDeviceDescriptor_return:

    DebugTrace(TRACE_PROC_LEAVE,("USGetUSBDeviceDescriptor: Leaving.. Status = 0x%x\n", Status));
    return Status;
} // end USGetUSBDeviceDescriptor()



NTSTATUS
USDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
)
/*++

Routine Description:
    This routine is called when the port driver completes an IRP.

Arguments:

    pDeviceObject - Pointer to the device object for the class device.
    pIrp - Irp completed.
    Context - Driver defined context.

Return Value:
    The function value is the final status from the operation.

--*/
{
    PKEVENT pEvent = Context;

    DebugTrace(TRACE_PROC_ENTER,("USDeferIrpCompletion: Enter..\n"));
    KeSetEvent(pEvent, 1, FALSE);
    DebugTrace(TRACE_PROC_LEAVE,("USDeferIrpCompletion: Leaving.. Status = STATUS_MORE_PROCESSING_REQUIRED\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;

} // end USDeferIrpCompletion()


VOID
USIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBSCAN_DEVICE_EXTENSION  pde;

    DebugTrace(TRACE_PROC_ENTER,("USIncrementIoCount: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    ASSERT((LONG)pde -> PendingIoCount >= 0);
    InterlockedIncrement(&pde -> PendingIoCount);

    DebugTrace(TRACE_PROC_LEAVE,("USIncrementIoCount: Leaving.. IoCount=0x%x, Status=VOID\n", pde -> PendingIoCount));

} // end USIncrementIoCount()


LONG
USDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PUSBSCAN_DEVICE_EXTENSION  pde;
    LONG                        ioCount;

    DebugTrace(TRACE_PROC_ENTER,("USDecrementIoCount: Enter..\n"));

    pde = (PUSBSCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    ASSERT(pde ->PendingIoCount >= 1);

    ioCount = InterlockedDecrement(&pde -> PendingIoCount);

    if (0 == ioCount) {
        KeSetEvent(&pde -> PendingIoEvent,
                   1,
                   FALSE);
    }

    DebugTrace(TRACE_PROC_LEAVE,("USDecrementIoCount: Leaving.. IoCount(=Ret)=0x%x\n", ioCount));
    return ioCount;
} // end USDecrementIoCount()


NTSTATUS
USBSCAN_CallUSBD(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PURB pUrb
)
/*++

Routine Description:
    Passes a URB to the USBD class driver

Arguments:
    pDeviceObject - pointer to the device object
    pUrb - pointer to Urb request block

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                    Status;
    PUSBSCAN_DEVICE_EXTENSION   pde;
    PIRP                        pIrp;
    KEVENT                      eventTimeout;
    IO_STATUS_BLOCK             ioStatus;
    PIO_STACK_LOCATION          pNextStack;
    LARGE_INTEGER               Timeout;
    KEVENT                      eventSync;

    DebugTrace(TRACE_PROC_ENTER,("USBSCAN_CallUSBD: Enter..\n"));

    pde = pDeviceObject -> DeviceExtension;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&eventTimeout, NotificationEvent, FALSE);
    KeInitializeEvent(&eventSync, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                pde -> pStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &eventTimeout,
                &ioStatus);

    if(NULL == pIrp){
        DebugTrace(TRACE_CRITICAL,("USBSCAN_CallUSBD: ERROR!! cannot allocated IRP\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USBSCAN_CallUSBD_return;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    pNextStack = IoGetNextIrpStackLocation(pIrp);
    ASSERT(pNextStack != NULL);

    //
    // pass the URB to the USB driver stack
    //

    pNextStack -> Parameters.Others.Argument1 = pUrb;

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           USDeferIrpCompletion,
                           &eventSync,
                           TRUE,
                           TRUE,
                           TRUE);

    DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: calling USBD\n"));

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: return from IoCallDriver USBD %x\n", Status));

    if (Status == STATUS_PENDING) {
        DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Wait for single object\n"));

        //
        // Set timeout in case bad device not responding.
        //

        Timeout = RtlConvertLongToLargeInteger(-10*1000*1000*(USBSCAN_TIMEOUT_OTHER));
        Status = KeWaitForSingleObject(
                       &eventSync,
                       Suspended,
                       KernelMode,
                       FALSE,
                       &Timeout);
        if(STATUS_TIMEOUT == Status){

            NTSTATUS    LocalStatus;

            DebugTrace(TRACE_ERROR,("USBSCAN_CallUSBD: ERROR!! call timeout. Now canceling IRP...\n"));

            //
            // Cancel IRP.
            //

            IoCancelIrp(pIrp);

            //
            // Make sure the IRP gets completed.
            //

            LocalStatus = KeWaitForSingleObject(&eventSync,
                                                Suspended,
                                                KernelMode,
                                                FALSE,
                                                NULL);

            DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Canceled status = 0x%x.\n", LocalStatus));

            //
            // Set proper state in IRP.
            //
            
            Status = STATUS_IO_TIMEOUT;
            pIrp->IoStatus.Status = Status;

        } else {
            DebugTrace(TRACE_STATUS,("USBSCAN_CallUSBD: Wait for single object, returned 0x%x\n", Status));
        }
    } // if (Status == STATUS_PENDING)

    //
    // Free the IRP.
    //

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

USBSCAN_CallUSBD_return:
    DebugTrace(TRACE_PROC_LEAVE, ("USBSCAN_CallUSBD: Leaving.. URB Status = 0x%x, Status = 0x%x\n",
                                 pUrb -> UrbHeader.Status,
                                 Status));
    return Status;

} // end USBSCAN_CallUSBD()


NTSTATUS
USConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:
    Initializes a given instance of the device on the USB and selects the
    configuration.

Arguments:
    pDeviceObject - pointer to the device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{

    NTSTATUS                      Status;
    PUSBSCAN_DEVICE_EXTENSION     pde;
    PURB                          pUrb;
    ULONG                         siz;
    PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR     pInterfaceDescriptor;
    PUSB_ENDPOINT_DESCRIPTOR      pEndpointDescriptor;
    PUSB_COMMON_DESCRIPTOR        pCommonDescriptor;
    PUSBD_INTERFACE_INFORMATION   pInterface;
    UCHAR                         AlternateSetting;
    UCHAR                         InterfaceNumber;
    USHORT                        length;
    ULONG                         i;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USConfigureDevice: Enter..\n"));

    //
    // Initialize local variable.
    //

    pConfigurationDescriptor    = NULL;
    pInterfaceDescriptor        = NULL;
    pEndpointDescriptor         = NULL;
    pCommonDescriptor           = NULL;
    pInterface                  = NULL;
    pUrb                        = NULL;

    siz                 = 0;
    AlternateSetting    = 0;
    InterfaceNumber     = 0;
    length              = 0;

    pde = pDeviceObject -> DeviceExtension;
    Status = STATUS_UNSUCCESSFUL;

    //
    // First configure the device
    //

    pUrb = USAllocatePool(NonPagedPool,
                          sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate control descriptor URB.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);


get_config_descriptor_retry:

    pConfigurationDescriptor = USAllocatePool(NonPagedPool, siz);
    if (NULL == pConfigurationDescriptor) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate configuration descriptor.\n"));
        DEBUG_BREAKPOINT();

        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Initialize buffers by 0
    //

    RtlZeroMemory(pConfigurationDescriptor, siz);
    RtlZeroMemory(pUrb, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    UsbBuildGetDescriptorRequest(pUrb,
                                 (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 pConfigurationDescriptor,
                                 NULL,
                                 siz,
                                 NULL);

    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);

    DebugTrace(TRACE_STATUS,("USConfigureDevice: URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE Status = %x\n", Status));
    DebugTrace(TRACE_STATUS,("USConfigureDevice: Configuration Descriptor = %x, len = %x\n",
                               pConfigurationDescriptor,
                               pUrb -> UrbControlDescriptorRequest.TransferBufferLength));


    //
    // if we got some data see if it was enough.
    //
    // NOTE: we may get an error in URB because of buffer overrun
    //

    if ( (pUrb -> UrbControlDescriptorRequest.TransferBufferLength > 0) &&
         (pConfigurationDescriptor -> wTotalLength > siz)) {

        DebugTrace(TRACE_WARNING,("USConfigureDevice: WARNING!! Data is incomplete. Fetch descriptor again...\n"));

        siz = pConfigurationDescriptor -> wTotalLength;
        USFreePool(pConfigurationDescriptor);
        pConfigurationDescriptor = NULL;
        goto get_config_descriptor_retry;
    }

    USFreePool(pUrb);
    pUrb = NULL;

    //
    // We have the configuration descriptor for the configuration
    // we want.  Save it in our device extension.
    //

    pde -> pConfigurationDescriptor = pConfigurationDescriptor;

    //
    // Now we issue the select configuration command to get
    // the pipes associated with this configuration.
    //

    pUrb = USCreateConfigurationRequest(pConfigurationDescriptor, &length);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't allocate select configuration urb.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Get the Interface descriptors.
    //

    pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(pConfigurationDescriptor,
                                                               pConfigurationDescriptor,
                                                               -1,
                                                               0,
                                                               -1,
                                                               -1,
                                                               -1);

    if(NULL == pInterfaceDescriptor){
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't get Interface descriptor.\n"));
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_UNSUCCESSFUL;
        goto USConfigureDevice_return;
    }

    //
    // Get the Endpoint descriptors.
    //

    pCommonDescriptor = USBD_ParseDescriptors(pConfigurationDescriptor,
                                              pConfigurationDescriptor->wTotalLength,
                                              pInterfaceDescriptor,
                                              USB_ENDPOINT_DESCRIPTOR_TYPE);
    if(NULL == pCommonDescriptor){
        DebugTrace(TRACE_CRITICAL,("USConfigureDevice: ERROR!! Can't get Endpoint descriptor.\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto USConfigureDevice_return;
    }

    ASSERT(USB_ENDPOINT_DESCRIPTOR_TYPE == pCommonDescriptor->bDescriptorType);
    pEndpointDescriptor = (PUSB_ENDPOINT_DESCRIPTOR)pCommonDescriptor;

    //
    // save these pointers is our device extension.
    //

    pde -> pInterfaceDescriptor = pInterfaceDescriptor;
    pde -> pEndpointDescriptor  = pEndpointDescriptor;

    //
    // Set the max transfer size for each BULK endpoint to 64K.
    // Also, search through the set of endpoints and find the pipe index for our
    // bulk-in, interrupt, and optionally bulk-out pipes.
    //

    pde -> IndexBulkIn    = -1;
    pde -> IndexBulkOut   = -1;
    pde -> IndexInterrupt = -1;

    pInterface = &(pUrb -> UrbSelectConfiguration.Interface);

    for (i=0; i < pInterfaceDescriptor -> bNumEndpoints; i++) {

        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: End point[%d] descriptor\n", i));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bLength          : 0x%X\n", pEndpointDescriptor[i].bLength));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bDescriptorType  : 0x%X\n", pEndpointDescriptor[i].bDescriptorType));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bEndpointAddress : 0x%X\n", pEndpointDescriptor[i].bEndpointAddress));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bmAttributes     : 0x%X\n", pEndpointDescriptor[i].bmAttributes));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: wMaxPacketSize   : 0x%X\n", pEndpointDescriptor[i].wMaxPacketSize));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: bInterval        : 0x%X\n", pEndpointDescriptor[i].bInterval));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: \n"));

        if (USB_ENDPOINT_TYPE_BULK == pEndpointDescriptor[i].bmAttributes) {
            pInterface -> Pipes[i].MaximumTransferSize = 64*1024;
            if (pEndpointDescriptor[i].bEndpointAddress & BULKIN_FLAG) {    // if input endpoint
                pde -> IndexBulkIn = i;
            } else {
                pde -> IndexBulkOut = i;
            }
        } else if (USB_ENDPOINT_TYPE_INTERRUPT == pEndpointDescriptor[i].bmAttributes) {
            pde -> IndexInterrupt = i;
        }
    }

    //
    // Select the default configuration.
    //

    UsbBuildSelectConfigurationRequest(pUrb, length, pConfigurationDescriptor);
    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
    if (STATUS_SUCCESS != Status) {
        DebugTrace(TRACE_ERROR,("USConfigureDevice: ERROR!! Selecting default configuration. Status = %x\n", Status));

        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_IO_DEVICE_ERROR;
        goto USConfigureDevice_return;
    }

    //
    // Save the configuration handle in our device extension.
    //

    pde -> ConfigurationHandle = pUrb -> UrbSelectConfiguration.ConfigurationHandle;

    //
    // Insure that this device won't overflow our PipeInfo structure.
    //

    if (pInterfaceDescriptor -> bNumEndpoints > MAX_NUM_PIPES) {
        DebugTrace(TRACE_ERROR,("USConfigureDevice: ERROR!! Too many endpoints for this driver! # endpoints = %d\n",
                                    pInterfaceDescriptor -> bNumEndpoints));
//        DEBUG_BREAKPOINT();
        USFreePool(pUrb);
        pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USConfigureDevice_return;
    }

    //
    // Save pipe configurations in our device extension
    //

    pde -> NumberOfPipes = pInterfaceDescriptor -> bNumEndpoints;

    for (i=0; i < pInterfaceDescriptor -> bNumEndpoints; i++) {
        pde -> PipeInfo[i] = pInterface -> Pipes[i];

        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: Pipe[%d] information\n", i));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: MaximumPacketSize : 0x%X\n", pde -> PipeInfo[i].MaximumPacketSize));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: EndpointAddress   : 0x%X\n", pde -> PipeInfo[i].EndpointAddress));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: Interval          : 0x%X\n", pde -> PipeInfo[i].Interval));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: PipeType          : 0x%X\n", pde -> PipeInfo[i].PipeType));
        DebugTrace(TRACE_DEVICE_DATA,("USConfigureDevice: PipeHandle        : 0x%X\n", pde -> PipeInfo[i].PipeHandle));

        //
        // Initialize the read pipe buffer if type is Bulk-In.
        //

        if( (pde->PipeInfo[i].PipeType == UsbdPipeTypeBulk)
         && (pde->PipeInfo[i].EndpointAddress & BULKIN_FLAG) )
        {

            DebugTrace(TRACE_STATUS,("USConfigureDevice: Alocates buffer for Pipe[%d]\n", i));

            pde -> ReadPipeBuffer[i].RemainingData = 0;
            pde -> ReadPipeBuffer[i].pBuffer = USAllocatePool(NonPagedPool, 2 * (pde -> PipeInfo[i].MaximumPacketSize));
            if (NULL == pde -> ReadPipeBuffer[i].pBuffer) {
                DebugTrace(TRACE_CRITICAL,("USConfigureDevice: Cannot allocate bulk-in buffer.\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                USFreePool(pUrb);
                pUrb = NULL;
                goto USConfigureDevice_return;
            }
            pde -> ReadPipeBuffer[i].pStartBuffer = pde -> ReadPipeBuffer[i].pBuffer;
        } else {
            pde -> ReadPipeBuffer[i].pBuffer = NULL;
        }
    }

    USFreePool(pUrb);
    pUrb = NULL;

USConfigureDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,("USConfigureDevice: Leaving.. Status = %x\n", Status));
    return Status;
}


NTSTATUS
USUnConfigureDevice(
    IN PDEVICE_OBJECT pDeviceObject
)
/*++

Routine Description:

Arguments:
    pDeviceObject - pointer to the device object

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    PURB                          pUrb;
    ULONG                         siz;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("USUnConfigureDevice: Enter..\n"));

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    pUrb = USAllocatePool(NonPagedPool, siz);
    if (NULL == pUrb) {
        DebugTrace(TRACE_CRITICAL,("USUnConfigureDevice: ERROR!! cannot allocated URB\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto USUnConfigureDevice_return;
    }
    RtlZeroMemory(pUrb, siz);

    //
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.
    //

    UsbBuildSelectConfigurationRequest(pUrb, (USHORT)siz, NULL);
    Status = USBSCAN_CallUSBD(pDeviceObject, pUrb);
    DebugTrace(TRACE_STATUS,("USUnConfigureDevice: Device Configuration Closed status = %x usb status = %x.\n",
                               Status, pUrb->UrbHeader.Status));

    USFreePool(pUrb);
    pUrb = NULL;

USUnConfigureDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,("USUnConfigureDevice: Leaving.. Status = %x\n", Status));
    return Status;
}


VOID
USUnload(
    IN PDRIVER_OBJECT pDriverObject
)
/*++

   Routine Description:
   Unload routine. The routine is called when the driver is unloaded.
   Release every resource allocated in relation with the driver object.

   Arguments:
   pDriverObject - pointer to the driver object

   Return Value:
   None

   -- */
{
    PAGED_CODE();
    
    if(NULL == pDriverObject){
        DebugTrace(TRACE_ERROR,("UsbScanUnload: ERROR!! pDriverObject is NULL\n"));
    } // if(NULL == pDriverObject)

    DebugTrace((MIN_TRACE | TRACE_FLAG_PROC),("UsbScanUnload(0x%X);\n", pDriverObject));

} // end USUnload()


NTSTATUS
USCallNextDriverSynch(
    IN PUSBSCAN_DEVICE_EXTENSION  pde,
    IN PIRP              pIrp
)
/*++

Routine Description:

    Calls lower driver and waits for result

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    KEVENT          Event;
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS        Status;

    DebugTrace(TRACE_PROC_ENTER,("USCallNextDriverSynch: Enter..\n"));

    IrpStack = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Copy IRP stack to the next.
    //

    IoCopyCurrentIrpStackLocationToNext(pIrp);

    //
    // Initialize synchronizing event.
    //

    KeInitializeEvent(&Event,
                      SynchronizationEvent,
                      FALSE);

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           USDeferIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down
    //

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    if (Status == STATUS_PENDING) {

        //
        // Waiting for the completion.
        //

        DebugTrace(TRACE_STATUS,("USCallNextDriverSynch: STATUS_PENDING. Wait for event.\n"));
        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        Status = pIrp -> IoStatus.Status;
    }

    //
    // Return
    //

    DebugTrace(TRACE_PROC_LEAVE,("USCallNextDriverSynch: Leaving.. Status = %x\n", Status));
    return (Status);
}

NTSTATUS
UsbScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - Supplies the device object.

Return Value:

    None.

--*/
{

    NTSTATUS           Status;

    DebugTrace(TRACE_PROC_ENTER,("UsbScanHandleInterface: Enter..\n"));

    Status = STATUS_SUCCESS;

#ifndef _CHICAGO_

    if (Create) {

        Status=IoRegisterDeviceInterface(
            DeviceObject,
            &GUID_DEVINTERFACE_IMAGE,
            NULL,
            InterfaceName
            );
        DebugTrace(TRACE_STATUS,("Called IoRegisterDeviceInterface . Returned=0x%X\n",Status));

        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

            DebugTrace(TRACE_STATUS,("Called IoSetDeviceInterfaceState(TRUE) . \n"));
        }
    } else {

        if (InterfaceName->Buffer != NULL) {

            Status = IoSetDeviceInterfaceState(
                        InterfaceName,
                        FALSE
                        );

            RtlFreeUnicodeString(
                InterfaceName
                );

            InterfaceName->Buffer = NULL;
        }
    }

#endif // !_CHICAGO_

    DebugTrace(TRACE_PROC_LEAVE,("IoRegisterDeviceInterface: Leaving... Status=0x%X\n",Status));
    return Status;

}

NTSTATUS
UsbScanReadDeviceRegistry(
    IN  PUSBSCAN_DEVICE_EXTENSION   pExtension,
    IN  PCWSTR                      pKeyName,
    OUT PVOID                       *ppvData
    )
/*++

Routine Description:

    This routine open registry for this device and query a value specified
    by key name. This routine allocate non-paged memory and return its pointer.
    Caller must free returned pointer.

Arguments:

    pExtension  - pointer to device extension
    pKeyName    - pointer to a wide string specify key name
    ppvData     - pointer to the queried data pointer allocated by this routine

Return Value:
    STATUS_SUCCESS              - if success,
    STATUS_INVALID_PARAMETER    - if passed argument is invalid,

--*/

{
    NTSTATUS                        Status;
    HANDLE                          hRegKey;
    PVOID                           pvBuffer;
    ULONG                           DataSize;
    PVOID                           pvRetData;
    UNICODE_STRING                  unicodeKeyName;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER, ("UsbScanReadDeviceRegistry: Entering...\n"));

    //
    // Initialize status
    //

    Status = STATUS_SUCCESS;

    hRegKey = NULL;
    pvBuffer = NULL;
    pvRetData = NULL;
    DataSize = 0;

    //
    // Check the arguments
    //

    if( (NULL == pExtension)
     || (NULL == pKeyName)
     || (NULL == ppvData) )
    {
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! Invalid argument.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Open device registry.
    //

    Status = IoOpenDeviceRegistryKey(pExtension->pPhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ,
                                     &hRegKey);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! IoOpenDeviceRegistryKey failed.\n"));
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Query required size.
    //

    RtlInitUnicodeString(&unicodeKeyName, pKeyName);
    Status = ZwQueryValueKey(hRegKey,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if(0 == DataSize){
        if(STATUS_OBJECT_NAME_NOT_FOUND == Status){
            DebugTrace(TRACE_STATUS, ("UsbScanReadDeviceRegistry: Reg-key \"%wZ\" doesn't exist.\n", &unicodeKeyName));
        } else {
            DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! Cannot retrieve reqired data size of %wZ. Status=0x%x\n",
                                     &unicodeKeyName ,
                                     Status));
        }
        goto UsbScanReadDeviceRegistry_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pvBuffer = USAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pvBuffer){
        DebugTrace(TRACE_CRITICAL, ("UsbScanReadDeviceRegistry: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto UsbScanReadDeviceRegistry_return;
    }
    RtlZeroMemory(pvBuffer, DataSize+sizeof(WCHAR));

    //
    // Query specified value.
    //

    DebugTrace(TRACE_STATUS, ("UsbScanReadDeviceRegistry: Query \"%wZ\".\n", &unicodeKeyName));
    Status = ZwQueryValueKey(hRegKey,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pvBuffer,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanReadDeviceRegistry: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        goto UsbScanReadDeviceRegistry_return;
    }

UsbScanReadDeviceRegistry_return:
    if(!NT_SUCCESS(Status)){

        //
        // This routine failed.
        //

        if(pvRetData){
            USFreePool(pvRetData);
        }
        *ppvData = NULL;
    } else {

        //
        // This routine succeeded.
        //

        *ppvData = pvBuffer;
    }

    //
    // Clean-up.
    //

    if(hRegKey){
        ZwClose(hRegKey);
    }
    DebugTrace(TRACE_PROC_LEAVE, ("UsbScanReadDeviceRegistry: Leaving... Status=0x%x\n", Status));
    return Status;
}


NTSTATUS
UsbScanWriteDeviceRegistry(
    IN PUSBSCAN_DEVICE_EXTENSION    pExtension,
    IN PCWSTR                       pKeyName,
    IN ULONG                        Type,
    IN PVOID                        pvData,
    IN ULONG                        DataSize
    )
/*++

Routine Description:

    This routine open registry for this device and set a value specified
    by key name.

Arguments:

    pExtension  - pointer to device extension
    pKeyName    - pointer to a wide string specify key name
    Type        - specifies the type of data to be written
    pvData      - pointer to a caller allocated buffer containing data
    DataSize    - specifies the size in bytes of the data buffer

Return Value:
    STATUS_SUCCESS              - if success,
    STATUS_INVALID_PARAMETER    - if passed argument is invalid,

--*/

{
    NTSTATUS                        Status;
    HANDLE                          hRegKey;
    UNICODE_STRING                  unicodeKeyName;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER, ("UsbScanWriteDeviceRegistry: Entering...\n"));

    //
    // Initialize status
    //

    Status = STATUS_SUCCESS;

    hRegKey = NULL;

    //
    // Check the arguments
    //

    if( (NULL == pExtension)
     || (NULL == pKeyName)
     || (NULL == pvData)
     || (0 == DataSize) )
    {
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! Invalid argument.\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto UsbScanWriteDeviceRegistry_return;
    }

    //
    // Open device registry.
    //

    Status = IoOpenDeviceRegistryKey(pExtension->pPhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_ALL_ACCESS,
                                     &hRegKey);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! IoOpenDeviceRegistryKey failed.\n"));
        goto UsbScanWriteDeviceRegistry_return;
    }

    //
    // Set specified value.
    //

    RtlInitUnicodeString(&unicodeKeyName, pKeyName);
    DebugTrace(TRACE_STATUS, ("UsbScanWriteDeviceRegistry: Setting \"%wZ\".\n", &unicodeKeyName));
    Status = ZwSetValueKey(hRegKey,
                           &unicodeKeyName,
                           0,
                           Type,
                           pvData,
                           DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("UsbScanWriteDeviceRegistry: ERROR!! ZwSetValueKey failed. Status = 0x%x\n", Status));
        goto UsbScanWriteDeviceRegistry_return;
    }

UsbScanWriteDeviceRegistry_return:

    //
    // Clean-up.
    //

    if(hRegKey){
        ZwClose(hRegKey);
    }
    DebugTrace(TRACE_PROC_LEAVE, ("UsbScanWriteDeviceRegistry: Leaving... Status=0x%x\n", Status));
    return Status;
} // UsbScanWriteDeviceRegistry()

PURB
USCreateConfigurationRequest(
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor,
    IN OUT PUSHORT                      Siz
    )
/*++

Routine Description:

Arguments:

Return Value:

    Pointer to initailized select_configuration urb.

--*/
{
    PURB urb = NULL;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY interfaceList, tmp;
    LONG numberOfInterfaces, interfaceNumber, i;

    PAGED_CODE();
    DebugTrace(TRACE_PROC_ENTER, ("USCreateConfigurationRequest: Entering...\n"));

    //
    // build a request structure and call the new api
    //

    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;

    tmp = interfaceList = USAllocatePool(PagedPool, sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces+1));

    //
    // just grab the first alt setting we find for each interface
    //

    i = interfaceNumber = 0;

    while (i< numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                                                  ConfigurationDescriptor,
                                                                  -1,
                                                                  0, // assume alt setting zero here
                                                                  -1,
                                                                  -1,
                                                                  -1);

        ASSERT(interfaceDescriptor != NULL);

        if (interfaceDescriptor) {
            interfaceList->InterfaceDescriptor =
                interfaceDescriptor;
            interfaceList++;
            i++;
        } else {
            // could not find the requested interface descriptor
            // bail, we will prorblay crash somewhere in the
            // client driver.

            goto USCreateConfigurationRequest_return;
        }

        interfaceNumber++;
    }

    //
    // terminate the list
    //
    interfaceList->InterfaceDescriptor = NULL;

    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

USCreateConfigurationRequest_return:

    ExFreePool(tmp);

    if (urb) {
        *Siz = urb->UrbHeader.Length;
    }

    DebugTrace(TRACE_PROC_LEAVE, ("USCreateConfigurationRequest: Leaving... Ret=0x%x\n", urb));
    return urb;

} // USCreateConfigurationRequest()

VOID
UsbScanLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                            device.

    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                            has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;

    if (ARGUMENT_PRESENT(DeviceObject)) {

        ObjectToUse = DeviceObject;

    } else {

        ObjectToUse = DriverObject;

    }

    DumpToAllocate = 0;

    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));

    if (!ErrorLogEntry) {
        return;
    }

    ErrorLogEntry->ErrorCode         = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber    = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount        = RetryCount;
    ErrorLogEntry->UniqueErrorValue  = UniqueErrorValue;
    ErrorLogEntry->FinalStatus       = FinalStatus;
    ErrorLogEntry->DumpDataSize      = DumpToAllocate;

    if (DumpToAllocate) {

        // If needed - add more to parameter list and move memory here
        //RtlCopyMemory(ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

    }

    IoWriteErrorLogEntry(ErrorLogEntry);

}



#ifdef ORIGINAL_POOLTRACK

int NumberOfAllocate = 0;

PVOID
USAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("USAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  TAG_USBSCAN);

    NumberOfAllocate++;
    DebugTrace(TRACE_PROC_LEAVE,("USAllocatePool: Leaving.. pvRet = %x, Count=%d\n", pvRet, NumberOfAllocate));
    return pvRet;

}


VOID
USFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    ULONG ulTag;

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

    ulTag = *((PULONG)pvAddress-1);

    if( (TAG_USBSCAN == ulTag) || (TAG_USBD == ulTag) ){
        DebugTrace(TRACE_STATUS,("USFreePool: Free memory. tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ))
    } else {
        DebugTrace(TRACE_WARNING,("USFreePool: WARNING!! Free memory. tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ))
    }

    ExFreePool(pvAddress);

    NumberOfAllocate--;
    DebugTrace(TRACE_PROC_LEAVE,("USFreePool: Leaving.. Status = VOID, Count=%d\n", NumberOfAllocate));
}

#endif   // ORIGINAL_POOLTRACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\cab\win98\makefile.inc ===
TARGET_EXE=obj\$(TARGET_DIRECTORY)\wiasetup.exe

!if "$(PASS0ONLY)"=="1"
$(TARGET_EXE): $(_NTTREE)\wiaservc.dll
    copy wiawin98.sed obj
    echo SourceFiles0=$(_NTTREE)\ >> obj\wiawin98.sed
    copy obj\wiawin98.sed $(_NTTREE)
    iexpress /Q /N $(_NTTREE)\wiawin98.sed
    move wiasetup.exe obj\$(TARGET_DIRECTORY)
    #copy obj\$(TARGET_DIRECTORY)\wiasetup.exe $(_NTTREE)
!else
$(TARGET_CAB):
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\cistr.h ===
/******************************************************************************

  Header File:  string.h

  This defines our locally-owned version of a string class.  I swear this has
  to be the 5th or 6h time I've done one, but each time someone else owns the
  code, so here we go again...

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  01-08-97  Bob Kjelgaard
  01-30-97  Bob Kjelgaard   Added features to aid port extraction for plug and play.
  07-05-97  Tim Wells       Ported to NT

******************************************************************************/

#if !defined(COSMIC_STRINGS)

#define COSMIC_STRINGS

class CString {

    LPTSTR   m_lpstr;

public:

    void Empty() {

        if (m_lpstr) {

            delete m_lpstr;
        }

        m_lpstr = NULL;
    }

    CString() {

        m_lpstr = NULL;

    }

    ~CString() {

        Empty();
    }

    CString(LPCTSTR lpstrRef);
    CString(const CString& csRef);

    BOOL IsEmpty() const { return !m_lpstr || !*m_lpstr; }

    const CString&  operator =(const CString& csRef);
    const CString&  operator =(LPCTSTR lpstrRef);

    operator LPCTSTR() const { return m_lpstr; }
    operator LPTSTR() { return m_lpstr; }

    void GetContents(HWND hwnd);             //  Get Window Text

    void FromTable(unsigned uid);            //  Load from resource

    void Load(ATOM at, BOOL bGlobal = TRUE); //  Load from atom

    void Load(HINF    hInf = INVALID_HANDLE_VALUE, 
              LPCTSTR lpstrSection = NULL, 
              LPCTSTR lpstrKeyword = NULL,
              DWORD   dwFieldIndex = 1,
              LPCTSTR lpstrDefault = NULL);

    void Load(HKEY hk, LPCTSTR lpstrKeyword);

    void MakeSystemPath (LPCTSTR lpstrFilename);

    void Store(HKEY hk, LPCTSTR lpstrKey, LPCTSTR lpstrType = NULL);

    DWORD Decode();

    friend CString  operator + (const CString& cs1, const CString& cs2);
    friend CString  operator + (const CString& cs1, LPCTSTR lpstr2);
    friend CString  operator + (LPCTSTR lpstr1,const CString& cs2);
};

class CStringArray {

    unsigned    m_ucItems, m_ucMax, m_uGrowBy;

    CString     *m_pcsContents, m_csEmpty;

public:

    CStringArray(unsigned m_uGrowby = 10);

    ~CStringArray();

    void        CStringArray::Cleanup();
    
    unsigned    Count() const { return m_ucItems; }

    void        Add(LPCTSTR lpstr);

    CString&    operator[](unsigned u);

    //  Split a string into an array, using a defined separator

    void        Tokenize(LPTSTR lpstr, TCHAR cSeparator);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\device.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       device.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Class to handle device un/installation for WIA class installer.
*
*******************************************************************************/

#ifndef _DEVICE_H_
#define _DEVICE_H_

//
// Include
//

#include "sti_ci.h"
#include "exports.h"

//
// Define
//

#ifndef StiDeviceTypeStreamingVideo
 #define StiDeviceTypeStreamingVideo 3
#endif

typedef BOOL (CALLBACK FAR * DEVNODESELCALLBACK)(LPTSTR szPortName, HDEVINFO *phDevInfo, PSP_DEVINFO_DATA pspDevInfoData);


//
// Class
//

class CDevice {

    //  Mutex for unique DeviceID/FriendlName creation.

    HANDLE              m_hMutex;

//    // These members are set in constructor.
//    HDEVINFO            m_hDevInfo;
//    PSP_DEVINFO_DATA    m_pspDevInfoData;

    CString             m_csInf;                // INF filename.
    CString             m_csInstallSection;     // INF section name.

    // These members are set during installation process.
    CString             m_csPort;               // Port name.
    DEVNODESELCALLBACK  m_pfnDevnodeSelCallback;// Callback for devnode selection.
    
    HKEY                m_hkInterfaceRegistry;  // RegKey to created interface.

    CString             m_csWiaSection;         // WIA Section nane.
    CString             m_csSubClass;           // Subclass.
    CString             m_csConnection;         // Connection type.
    CString             m_csVendor;             // Vendor name.
    CString             m_csFriendlyName;       // Friendly name.
    CString             m_csPdoDescription;     // Device Desc. of Devnode..
    CString             m_csDriverDescription;  // Driver Description.
    CString             m_csUninstallSection;   // UninstallSection.
    CString             m_csPropPages;          // VendorPropertyPage.
    CString             m_csVendorSetup;        // Vendor setup extention.
    CString             m_csDataSection;        // DeviceDataSection name.
    CString             m_csEventSection;       // EventSection name.
    CString             m_csIcmProfile;         // ICM Profile.
    CString             m_csUSDClass;           // USD Class GUID.
    CString             m_csDeviceID;           // Unique device ID.
    CString             m_csSymbolicLink;       // Symbolic link to the PDO.
    CString             m_csPortSelect;         // Indicate needs of port selection page..

    CStringArray        m_csaAllNames;          // Array to keep all device FriendlyName.
    CStringArray        m_csaAllId;             // Array to keep all device ID.

    DWORD               m_dwCapabilities;       // Capabilities.
    DWORD               m_dwDeviceType;         // DeviceType.
    DWORD               m_dwDeviceSubType;      // DeviceSubType.
    DWORD               m_dwNumberOfWiaDevice;  // Number of WIA device.
    DWORD               m_dwNumberOfStiDevice;  // Number of STI device.
    DWORD               m_dwInterfaceIndex;     // Index of interface.

    BOOL                m_bVideoDevice;         // Flag to indicate video device.
    BOOL                m_bIsPnP;               // Flag to indicate PnP device.
    BOOL                m_bDefaultDevice;       // 
    BOOL                m_bInfProceeded;        // Flag to indicate INF is proceeded.
    BOOL                m_bInterfaceOnly;       // Flag to indicate Interface-onle device.
    BOOL                m_bIsMigration;         // Flag to indicate migration.

    PPARAM_LIST         m_pExtraDeviceData;     // DeviceData migrated from Win9x.

    BOOL    GetInfInforamtion();
    VOID    ProcessEventsSection(HINF hInf, HKEY hkDrv);
    VOID    ProcessDataSection(HINF hInf, HKEY hkDrv);
    VOID    ProcessICMProfiles();
    VOID    ProcessVendorSetupExtension();
    VOID    ProcessVideoDevice(HKEY hkDrv);
    BOOL    HandleFilesInstallation();
    BOOL    IsInterfaceOnlyDevice(){ return m_bInterfaceOnly; };
    BOOL    IsPnpDevice(){ return m_bIsPnP; };
    BOOL    IsFeatureInstallation(){ return ( m_bIsPnP && m_bInterfaceOnly); };
    BOOL    CreateDeviceInterfaceAndInstall();
    BOOL    IsMigration(){return m_bIsMigration;};

public:

    // These members are set in constructor. These really should be in private.
    HDEVINFO            m_hDevInfo;
    PSP_DEVINFO_DATA    m_pspDevInfoData;

    CDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pspDevInfoSet, BOOL bIsPnP);
    CDevice(HDEVINFO hDevInfo, DWORD dwDeviceIndex);
    CDevice(PDEVICE_INFO pMigratingDevice);
    CDevice::~CDevice();

    BOOL    CollectNames();
    BOOL    IsDefault() const { return m_bDefaultDevice; }
    VOID    Default(BOOL bNew) { m_bDefaultDevice = bNew; }
    DWORD   GetCapabilities(){ return m_dwCapabilities; };
    LPTSTR  GetConnection(){ return m_csConnection; };
    LPTSTR  GetFriendlyName(){ return m_csFriendlyName; };
    VOID    SetPort (LPTSTR szPortName);
    VOID    SetDevnodeSelectCallback (DEVNODESELCALLBACK pfnDevnodeSelCallback);
    VOID    SetFriendlyName(LPTSTR szFriendlyName);

    BOOL    IsDeviceIdUnique(LPTSTR  szDeviceId);
    BOOL    IsFriendlyNameUnique(LPTSTR  szFriendlyName);
    BOOL    IsSameDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pspDevInfoSet);
    BOOL    NameDefaultUniqueName();
    BOOL    GenerateUniqueDeviceId();
    BOOL    Install();
    DWORD   Remove(PSP_REMOVEDEVICE_PARAMS lprdp);
    BOOL    PreInstall();
    BOOL    PostInstall(BOOL   bSucceeded);
    BOOL    PreprocessInf();
    BOOL    UpdateDeviceRegistry();
    DWORD   GetPortSelectMode(VOID);
    DWORD   AcquireInstallerMutex(DWORD dwTimeout);
    VOID    ReleaseInstallerMutex();

};


//
// Prototype
//

// from device.cpp
VOID
GetDeviceCount(
    DWORD   *pdwWiaCount,
    DWORD   *pdwStiCount
    );

BOOL
ExecCommandLine(
    LPTSTR  szCommandLine
    );

// from service.cpp
DWORD
WINAPI
StiServiceRemove(
    VOID
    );

DWORD
WINAPI
StiServiceInstall(
    BOOL    UseLocalSystem,
    BOOL    DemandStart,
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    );

BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    );

BOOL
StartWiaService(
    VOID
    );

BOOL
StopWiaService(
    VOID
    );

//PSP_FILE_CALLBACK StiInstallCallback;
//PSP_FILE_CALLBACK StiUninstallCallback;

UINT
CALLBACK
StiInstallCallback (
    PVOID    Context,
    UINT     Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    );

UINT
CALLBACK
StiUninstallCallback (
    PVOID    Context,
    UINT     Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    );

HANDLE
GetDeviceInterfaceIndex(
    LPSTR   pszLocalName,
    DWORD   *pdwIndex
    );

PPARAM_LIST
MigrateDeviceData(
    HKEY        hkDeviceData,
    PPARAM_LIST pExtraDeviceData,
    LPSTR       pszKeyName
    );

#endif // _DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.h

Abstract:

    Prototypes and definitions for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    user mode only

Notes:

Revision History:

--*/

#ifndef __MYDEBUG__
#define __MYDEBUG__

//
// Include custom debug header.
//
#include <windows.h>
#include <coredbg.h>
//
// Driver specific definition
//


#define NAME_DRIVER             TEXT("STI_CI.DLL: ")    // Prefix of output message. (Should be driver name)
#define REGVAL_DEBUGLEVEL       TEXT("STICIDebugLevel") // Debug trace level for this binary.

//
// Defines
//

#define MAX_TEMPBUF             256


// Bit mask for trace level and flags
#define BITMASK_TRACE_LEVEL     0x0000000f
#define BITMASK_TRACE_FLAG      0x00000ff0
#define BITMASK_DEBUG_FLAG      0x0000f000

// Basic trace level 
#define NO_TRACE                0                   // Shows nothing.
#define MIN_TRACE               1                   // Shows only error or warning.
#define MAX_TRACE               2                   // Shows progress and status.
#define ULTRA_TRACE             3                   // Shows progress and status in retail.
#define NEVER_TRACE             4                   // Never show this unless specific bit is set.

// Trace flag to enable specific message spew. (1=on)
#define TRACE_FLAG_PROC          0x010              // Show message when entering process.(1=on)
#define TRACE_FLAG_RET           0x020              // Show message when leaving process.(1=on)
#define TRACE_FLAG_DUMP          0x040              // Show transaction data dump.
#define TRACE_IGNORE_TAG         0x080              // Disable tag check (1=disabled).
#define TRACE_MESSAGEBOX         0x100              // Show MessageBox instead of debug spew.

// Conbination of trace level and flag.
#define TRACE_PROC_ENTER        ULTRA_TRACE | TRACE_FLAG_PROC     // Entering procedure.
#define TRACE_PROC_LEAVE        ULTRA_TRACE | TRACE_FLAG_RET      // Leaving procedure.
#define TRACE_CRITICAL          MIN_TRACE                         // Critical error. Spew always.
#define TRACE_ERROR             MIN_TRACE                         // Error.
#define TRACE_WARNING           MIN_TRACE                         // Possible wrong behavior.
#define TRACE_DUMP_DATA         NEVER_TRACE | TRACE_FLAG_DUMP     // Dump transaction data.
#define TRACE_DEVICE_DATA       MAX_TRACE                         // Show device data.
#define TRACE_STATUS            MAX_TRACE                         // Show status.

// Debug flag to enable/disable  DEBUG_BREAKPOINT()
#define DEBUG_FLAG_DISABLE      0x1000                          // Disable DEBUG_BREAK. (1=disable)
#define DEBUG_PROC_BREAK        0x2000                          // Stop at the beginning of each procedure.



//
// Prototypes
//


VOID
MyDebugInit(
    VOID
    );

void __cdecl
DbgPrint(
    LPSTR lpstrMessage,
    ...
    );

void __cdecl
DbgPrint(
    LPWSTR lpstrMessage,
    ...
    );

//
// Macro
//

 #define DebugTrace(_t_, _x_) {                                                                 \
            if((TRACE_ERROR & BITMASK_TRACE_LEVEL) == (_t_ & BITMASK_TRACE_LEVEL )){            \
                DBG_ERR(_x_);                                                                   \
            } else if((TRACE_WARNING & BITMASK_TRACE_LEVEL) == (_t_ & BITMASK_TRACE_LEVEL )){   \
                DBG_WRN(_x_);                                                                   \
            } else if((TRACE_STATUS & BITMASK_TRACE_LEVEL) == (_t_ & BITMASK_TRACE_LEVEL )){    \
                DBG_TRC(_x_);                                                                   \
            } else if( (_t_ & TRACE_FLAG_PROC) || (_t_ & TRACE_FLAG_RET )){                     \
                DBG_TRC(_x_);                                                                   \
            }                                                                                   \
        }

#if DBG

 //
 // Macro for BreakPoint
 //

 #define DEBUG_BREAKPOINT() {                                              \
           if (DebugTraceLevel & DEBUG_FLAG_DISABLE) {                     \
               DbgPrint(NAME_DRIVER);                                      \
               DbgPrint("*** Hit DEBUG_BREAKPOINT ***\r\n");                 \
           } else {                                                        \
               DebugBreak();                                               \
           }                                                               \
         }

#else   // DBG

 #define DEBUG_BREAKPOINT() 

#endif  // DBG



//
// Original debug macro.
//

#if ORIGINAL_DEBUG
#if DBG

 //
 // Macro for debug output
 //
 // Note: If trace level is higher than DebugTraceLevel or specific bit is set, 
 //       debug message will be shown.
 //

 #define DebugTrace(_t_, _x_) {                                                                 \
            if ( ((DebugTraceLevel & BITMASK_TRACE_LEVEL) >= (_t_ & BITMASK_TRACE_LEVEL )) ||   \
                 (DebugTraceLevel & BITMASK_TRACE_FLAG & (_t_)) ) {                             \
                DbgPrint(NAME_DRIVER);                                                          \
                DbgPrint _x_ ;                                                                  \
            }                                                                                   \
            if( (DebugTraceLevel & DEBUG_PROC_BREAK & (_t_)) &&                                 \
                (DebugTraceLevel & TRACE_FLAG_PROC) )  {                                        \
                DEBUG_BREAKPOINT();                                                             \
            }                                                                                   \
          }


#else    // DBG
 #define DebugTrace(_t_, _x_)   
#endif   // DBG
#endif  // ORIGINAL_DEBUG

//
// Obsolete
//

#define Report(_x_)  

#endif //  __MYDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\debug.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.c

Abstract:

    Common code for debugging.

Author:

    Keisuke Tsuchida (KeisukeT)

Environment:

   uesr mode only

Notes:

Revision History:

--*/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Includes
//
#include "stddef.h"
#include "debug.h"
#include <stiregi.h>

//
// Globals
//

ULONG   DebugTraceLevel = MIN_TRACE | DEBUG_FLAG_DISABLE;
//ULONG  DebugTraceLevel = MAX_TRACE | DEBUG_FLAG_DISABLE | TRACE_PROC_ENTER | TRACE_PROC_LEAVE;

TCHAR   acErrorBuffer[MAX_TEMPBUF];


//
// Function
//


VOID
MyDebugInit()
/*++

Routine Description:

    Read DebugTraceLevel key from registry if exists.

Arguments:

    none.

Return Value:

    none.

--*/
{

    HKEY            hkRegistry;
    LONG            Err;
    DWORD           dwType;
    DWORD           dwSize;
    ULONG           ulBuffer;

    DebugTrace(TRACE_PROC_ENTER,("MyDebugInit: Enter... \r\n"));

    //
    // Initialize local variables.
    //

    hkRegistry      = NULL;
    Err             = 0;
    dwSize          = sizeof(ulBuffer);

    //
    // Open registry key.
    //

    Err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_STICONTROL_W,
                     &hkRegistry);
    if(ERROR_SUCCESS != Err){
        DebugTrace(TRACE_STATUS,("MyDebugInit: Can't open %ws. Err=0x%x.\r\n", REGSTR_PATH_STICONTROL_W, Err));
        goto MyDebugInit_return;
    }

    Err = RegQueryValueEx(hkRegistry,
                          REGVAL_DEBUGLEVEL,
                          NULL,
                          &dwType,
                          (LPBYTE)&ulBuffer,
                          &dwSize);
    if(ERROR_SUCCESS != Err){
        DebugTrace(TRACE_STATUS,("MyDebugInit: Can't get %ws\\%ws value. Err=0x%x.\r\n", REGSTR_PATH_STICONTROL_W, REGVAL_DEBUGLEVEL, Err));
        goto MyDebugInit_return;
    }

    DebugTraceLevel = ulBuffer;
    DebugTrace(TRACE_CRITICAL, ("MyDebugInit: Reg-key found. DebugTraceLevel=0x%x.\r\n", DebugTraceLevel));

MyDebugInit_return:

    //
    // Clean up.
    //

    if(NULL != hkRegistry){
        RegCloseKey(hkRegistry);
    }

    DebugTrace(TRACE_PROC_LEAVE,("MyDebugInit: Leaving... Ret=VOID.\r\n"));
    return;
}

void __cdecl
DbgPrint(
    LPSTR lpstrMessage,
    ...
    )
{

    va_list list;

    va_start(list,lpstrMessage);

    wvsprintfA((LPSTR)acErrorBuffer, lpstrMessage, list);

    if(DebugTraceLevel & TRACE_MESSAGEBOX){
        MessageBoxA(NULL, (LPSTR)acErrorBuffer, "", MB_OK);
    }
#if DBG
    OutputDebugStringA((LPCSTR)acErrorBuffer);
#endif // DBG

    va_end(list);
}

void __cdecl
DbgPrint(
    LPWSTR lpstrMessage,
    ...
    )
{

    va_list list;

    va_start(list,lpstrMessage);

    wvsprintfW(acErrorBuffer, lpstrMessage, list);

    if(DebugTraceLevel & TRACE_MESSAGEBOX){
        MessageBoxW(NULL, acErrorBuffer, L"", MB_OK);
    }
#if DBG
    OutputDebugStringW(acErrorBuffer);
#endif // DBG

    va_end(list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\entry.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Entry.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Co/Installer/DLL entry point.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "sti_ci.h"
#include <setupapi.h>

#include "firstpg.h"
#include "portsel.h"
#include "nameit.h"
#include "finalpg.h"
#include "prevpg.h"
#include "device.h"
#include "stiregi.h"

#include "userdbg.h"

//
// Global
//

HINSTANCE       g_hDllInstance  = NULL;

//
// Function
//

extern "C"
BOOL
APIENTRY
DllMain(
    IN  HINSTANCE   hDll,
    IN  ULONG       ulReason,
    IN  LPVOID      lpReserved
    )
/*++

Routine Description:

    DllMain

    Entrypoint when this DLL is loaded.

Arguments:

    IN  HINSTANCE   hDll        Handle to this DLL instance.
    IN  ULONG       ulReason    The reason this entry is called.
    IN  LPVOID      lpReserved

Return Value:

    TRUE always.

Side effects:

    None

--*/
{

    if (ulReason == DLL_PROCESS_ATTACH) {

        //
        // Initialize globals.
        //

        g_hDllInstance = hDll;

        //
        // Initialize Fusion
        //
        SHFusionInitializeFromModuleID( hDll, 123 );

        DisableThreadLibraryCalls(hDll);
        InitCommonControls();

        DBG_INIT(g_hDllInstance);
//        MyDebugInit();

    }
    else if (ulReason == DLL_PROCESS_DETACH) {
        //
        // Shutdown Fusion
        //
        SHFusionUninitialize();
    }

    return TRUE;
} // DllMain ()


extern "C"
DWORD
APIENTRY
ClassInstall (
    IN  DI_FUNCTION         diFunction,
    IN  HDEVINFO            hDevInfo,
    IN  PSP_DEVINFO_DATA    pDevInfoData
    )
/*++

Routine Description:

    ClassInstall

    Entrypoint of WIA class installer.

Arguments:

    IN  DI_FUNCTION         diFunction      Function to perform.
    IN  HDEVINFO            hDevInfo,       Handle to Device Information.
    IN  PSP_DEVINFO_DATA    pDevInfoData    Pointer to Device Data.

Return Value:

    NO_ERROR            -   Operation succeeded.
    ERROR_DI_DO_DEFAULT -   Operation succeeded, or failed but let it continue.
    Other               -   Operation failed and unable to continue.

Side effects:

    None

--*/
{
    DWORD                   dwReturn;
    DWORD                   dwError;
    DWORD                   dwSize;
    SP_INSTALLWIZARD_DATA   InstallWizardData;
    SP_DEVINSTALL_PARAMS    spDevInstallParams;
    BOOL                    fCleanupContext;
    PINSTALLER_CONTEXT      pInstallerContext;

    DebugTrace(TRACE_PROC_ENTER,(("ClassInstall: Enter... \r\n")));
    DebugTrace(TRACE_STATUS,(("ClassInstall: Processing %ws message.\r\n"), DifDebug[diFunction].DifString));

    //
    // Initialize locals.
    //

    dwReturn            = ERROR_DI_DO_DEFAULT;
    dwError             = ERROR_SUCCESS;
    dwSize              = 0;
    fCleanupContext     = FALSE;
    pInstallerContext   = NULL;

    memset(&InstallWizardData, 0, sizeof(InstallWizardData));
    memset(&spDevInstallParams, 0, sizeof(spDevInstallParams));

    //
    // Dispatch requests.
    //

    switch(diFunction){

        case DIF_INSTALLWIZARD:
        {

            fCleanupContext = TRUE;

            //
            // Get install parameter(s).
            //

            InstallWizardData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            if(!SetupDiGetClassInstallParams(hDevInfo,
                                             pDevInfoData,
                                             &InstallWizardData.ClassInstallHeader,
                                             sizeof(InstallWizardData),
                                             NULL) )
            {
                dwError = GetLastError();
//                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed. Err=0x%x. dwSize=0x%x\n"), dwError, dwSize));
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed. Err=0x%x\n"), dwError));

                dwReturn    = ERROR_DI_DONT_INSTALL;
                goto ClassInstall_return;
            }

            //
            // Check if operation is correct.
            //

            if (InstallWizardData.ClassInstallHeader.InstallFunction != diFunction) {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! InstallHeader.InstallFunction is incorrect..\r\n")));

                dwReturn    = ERROR_DI_DONT_INSTALL;
                goto ClassInstall_return;
            }

            //
            // Check if we still have enough room to add pages.
            //

            if( (MAX_INSTALLWIZARD_DYNAPAGES - NUM_WIA_PAGES) < InstallWizardData.NumDynamicPages ){
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! No room for WIA installer pages.\r\n")));

                dwReturn    = ERROR_DI_DONT_INSTALL;
                goto ClassInstall_return;
            }

            //
            // Allocate context structure.
            //

            if(NULL == InstallWizardData.PrivateData){
                pInstallerContext = new INSTALLER_CONTEXT;
                if(NULL == pInstallerContext){
                    DebugTrace(TRACE_WARNING,(("ClassInstall: ERROR!! Insufficient memory.\r\n")));

                    dwReturn    = ERROR_DI_DONT_INSTALL;
                    goto ClassInstall_return;
                }
                InstallWizardData.PrivateData = (DWORD_PTR)pInstallerContext;
                memset((PBYTE)pInstallerContext, 0, sizeof(INSTALLER_CONTEXT));
            } else {
                DebugTrace(TRACE_WARNING,(("ClassInstall: WARNING!! Installer context already exists.\r\n")));
            }

            //
            // See who invoked installer.
            //

            pInstallerContext->bShowFirstPage           = InstallWizardData.PrivateFlags & SCIW_PRIV_SHOW_FIRST;
            pInstallerContext->bCalledFromControlPanal  = InstallWizardData.PrivateFlags & SCIW_PRIV_CALLED_FROMCPL;

            //
            // Save device info set.
            //

            pInstallerContext->hDevInfo         = hDevInfo;

            //
            // Save wizard windows handle.
            //

            pInstallerContext->hwndWizard       = InstallWizardData.hwndWizardDlg;

            //
            // Create/Initialize all wizard pages and a device class object.
            //

            CFirstPage *tempFistPage            = new CFirstPage(pInstallerContext);
            CPrevSelectPage *tempPrevSelectPage = new CPrevSelectPage(pInstallerContext);
            CPortSelectPage *tempPortSelectPage = new CPortSelectPage(pInstallerContext);
            CNameDevicePage *tempNameDevicePage = new CNameDevicePage(pInstallerContext);
            CInstallPage *tempInstallPage       = new CInstallPage(pInstallerContext);

            if( (NULL == tempFistPage)
             || (NULL == tempPrevSelectPage)
             || (NULL == tempPortSelectPage)
             || (NULL == tempNameDevicePage)
             || (NULL == tempInstallPage) )
            {
                DebugTrace(TRACE_WARNING,(("ClassInstall: ERROR!! Insufficient memory.\r\n")));

                dwReturn    = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

            //
            // Save created to context.
            //

            pInstallerContext->pFirstPage       = (PVOID) tempFistPage;
            pInstallerContext->pPrevSelectPage  = (PVOID) tempPrevSelectPage;
            pInstallerContext->pPortSelectPage  = (PVOID) tempPortSelectPage;
            pInstallerContext->pNameDevicePage  = (PVOID) tempNameDevicePage;
            pInstallerContext->pFinalPage       = (PVOID) tempInstallPage;

            //
            // Add created pages.
            //

            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempFistPage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempPrevSelectPage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempPortSelectPage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempNameDevicePage->Handle();
            InstallWizardData.DynamicPages[InstallWizardData.NumDynamicPages++] = tempInstallPage->Handle();

            //
            // Indicate "pages are added".
            //

            InstallWizardData.DynamicPageFlags |= DYNAWIZ_FLAG_PAGESADDED;

            //
            // Set the parameters back.
            //

            SetupDiSetClassInstallParams (hDevInfo,
                                          pDevInfoData,
                                          &InstallWizardData.ClassInstallHeader,
                                          sizeof(InstallWizardData));

            fCleanupContext = FALSE;
            dwReturn    = NO_ERROR;
            goto ClassInstall_return;
            break;

        } // case DIF_INSTALLWIZARD:


        case DIF_DESTROYWIZARDDATA:
        {

            //
            // Get install parameter(s).
            //

            InstallWizardData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            if(!SetupDiGetClassInstallParams(hDevInfo,
                                             pDevInfoData,
                                             &InstallWizardData.ClassInstallHeader,
                                             sizeof(InstallWizardData),
                                             &dwSize) )
            {
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed. Err=0x%x\n"), dwError));

                dwReturn    = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

//            //
//            // Check if operation is correct.
//            //
//
//            if (InstallWizardData.ClassInstallHeader.InstallFunction != diFunction) {
//                DebugTrace(TRACE_WARNING,(("ClassInstall: ERROR!! InstallHeader.InstallFunction is incorrect..\r\n")));
//
//                dwReturn    = ERROR_DI_DO_DEFAULT;
//                goto ClassInstall_return;
//            }

            //
            // Free all allocated resources.
            //

            fCleanupContext = TRUE;
            pInstallerContext = (PINSTALLER_CONTEXT)InstallWizardData.PrivateData;
            InstallWizardData.PrivateData = NULL;

            dwReturn    = NO_ERROR;
            goto ClassInstall_return;
            break;

        } // case DIF_DESTROYWIZARDDATA:

        case DIF_INSTALLDEVICE:
        {
            BOOL    bSucceeded;
            BOOL    bIsPnp;

            //
            // Sanity check of DevInfoSet and DevInfoData.
            //

            if( (NULL == pDevInfoData)
             || (!IS_VALID_HANDLE(hDevInfo)) )
            {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Wrong Infoset(0x%x) or instance(0x%x). Unable to continue.\r\n"),pDevInfoData,hDevInfo));

                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

            //
            // Get device install parameters.
            //

            spDevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                              pDevInfoData,
                                              &spDevInstallParams))
            {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetDeviceInstallParams failed Err=0x%x.\r\n"), GetLastError()));
            }

            if(spDevInstallParams.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL){

                //
                // Installing NULL driver. Let default handler handle it.
                //

                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            } // if(spDevInstallParams.FlagsEx & DI_FLAGSEX_SETFAILEDINSTALL)

            //
            // See if it's root-enumerated or not.
            //

            if(IsDeviceRootEnumerated(hDevInfo, pDevInfoData)){
                bIsPnp = FALSE;
            } else {
                bIsPnp = TRUE;
            }

            //
            // Create CDevice class.
            //
            //
            // Start the WIA service.  We start it here so that it will be running when we finish, so
            // it will receive the PnP device arrival notification.
            // Notice we don't change the startup-type here - this will be done later if the device
            // installation was successful.
            //

            StartWiaService();

            CDevice cdThis(hDevInfo, pDevInfoData, bIsPnp);

            //
            // Let it create unique FriendlyName.
            //

            bSucceeded = cdThis.NameDefaultUniqueName();
            if(bSucceeded){

                //
                // Do pre-installation process.
                //

                bSucceeded = cdThis.PreInstall();
                if(bSucceeded){

                    //
                    // Do actual installation.
                    //

                    bSucceeded = cdThis.Install();
                    if(!bSucceeded){
                        dwReturn = ERROR_DI_DONT_INSTALL;
                        DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Installation failed in CDevice class.\r\n")));
                    }
                } else {
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! PreInstall failed in CDevice class.\r\n")));
                }
            } else {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! NameDefaultUniqueName failed in CDevice class.\r\n")));
                dwReturn = ERROR_DI_DONT_INSTALL;
            }

            if(bSucceeded){

                //
                // So far, installation is working fine. Do final touch.
                //

                bSucceeded = cdThis.PostInstall(TRUE);
                if(!bSucceeded){
                    dwReturn = ERROR_DI_DONT_INSTALL;
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! PostInstall failed in CDevice class.\r\n")));
                }

                //
                // Installation succeeded.
                //

                dwReturn = NO_ERROR;

            } else {

                //
                // There's an error during installation. Revert.
                //

                cdThis.PostInstall(FALSE);
                dwReturn = ERROR_DI_DONT_INSTALL;
                DebugTrace(TRACE_ERROR,(("ClassInstall: Reverting installation...\r\n")));
            }

            goto ClassInstall_return;
            break;
        } // case DIF_INSTALLDEVICE:

        case DIF_REMOVE:
        {

            SP_REMOVEDEVICE_PARAMS   rdp;

            //
            // Check if operation is correct.
            //

            memset (&rdp, 0, sizeof(SP_REMOVEDEVICE_PARAMS));
            rdp.ClassInstallHeader.cbSize = sizeof (SP_CLASSINSTALL_HEADER);
            if (!SetupDiGetClassInstallParams (hDevInfo,
                                               pDevInfoData,
                                               &rdp.ClassInstallHeader,
                                               sizeof(SP_REMOVEDEVICE_PARAMS),
                                               NULL))
            {
                DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetClassInstallParams failed Err=0x%x.\r\n"), GetLastError()));

                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            } // if (!SetupDiGetClassInstallParams ()

            if (rdp.ClassInstallHeader.InstallFunction != DIF_REMOVE) {
                dwReturn = ERROR_DI_DO_DEFAULT;
                goto ClassInstall_return;
            }

            //
            // Create CDevice object.
            //

            CDevice cdThis(hDevInfo, pDevInfoData, TRUE);

            //
            // Remove the device.
            //

            dwReturn = cdThis.Remove(&rdp);

            goto ClassInstall_return;
            break;
        } // case DIF_REMOVE:

        case DIF_SELECTBESTCOMPATDRV:
        {
            SP_DRVINSTALL_PARAMS    spDriverInstallParams;
            SP_DRVINFO_DATA         spDriverInfoData;
            PSP_DRVINFO_DETAIL_DATA pspDriverInfoDetailData;
            DWORD                   dwLastError;
            DWORD                   dwSize;
            DWORD                   Idx;


            //
            // Get driver info.
            //

            memset(&spDriverInfoData, 0, sizeof(spDriverInfoData));
            spDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
            for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData); Idx++){

                //
                // Get driver install params.
                //

                memset(&spDriverInstallParams, 0, sizeof(spDriverInstallParams));
                spDriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
                if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams)){
                    DebugTrace(TRACE_ERROR,("ClassInstall: ERROR!! SetupDiGetDriverInstallParams() failed LastError=0x%x.\r\n", GetLastError()));

                    dwReturn = ERROR_DI_DO_DEFAULT;
                    goto ClassInstall_return;
                } // if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams))

                //
                // Get buffer size required for driver derail data.
                //

                dwSize = 0;
                SetupDiGetDriverInfoDetail(hDevInfo,
                                           pDevInfoData,
                                           &spDriverInfoData,
                                           NULL,
                                           0,
                                           &dwSize);
                dwLastError = GetLastError();
                if(ERROR_INSUFFICIENT_BUFFER != dwLastError){
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! SetupDiGetDriverInfoDetail() doesn't return required size.Er=0x%x\r\n"),dwLastError));

                    dwReturn = ERROR_DI_DO_DEFAULT;
                    goto ClassInstall_return;
                } // if(ERROR_INSUFFICIENT_BUFFER != dwLastError)

                //
                // Allocate required size of buffer for driver detailed data.
                //

                pspDriverInfoDetailData   = (PSP_DRVINFO_DETAIL_DATA)new char[dwSize];
                if(NULL == pspDriverInfoDetailData){
                    DebugTrace(TRACE_ERROR,(("ClassInstall: ERROR!! Unable to allocate driver detailed info buffer.\r\n")));

                    dwReturn = ERROR_DI_DO_DEFAULT;
                    goto ClassInstall_return;
                } // if(NULL == pspDriverInfoDetailData)

                //
                // Initialize allocated buffer.
                //

                memset(pspDriverInfoDetailData, 0, dwSize);
                pspDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

                //
                // Get detailed data of selected device driver.
                //

                if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                               pDevInfoData,
                                               &spDriverInfoData,
                                               pspDriverInfoDetailData,
                                               dwSize,
                                               NULL) )
                {
                    DebugTrace(TRACE_ERROR,("ClassInstall: ERROR!! SetupDiGetDriverInfoDetail() failed LastError=0x%x.\r\n", GetLastError()));

                    delete pspDriverInfoDetailData;
                    continue;
                } // if(NULL == pspDriverInfoDetailData)

                //
                // See if INF filename is valid.
                //

                if(NULL == pspDriverInfoDetailData->InfFileName){
                    DebugTrace(TRACE_ERROR,("ClassInstall: ERROR!! SetupDiGetDriverInfoDetail() returned invalid INF name.\r\n"));

                    delete pspDriverInfoDetailData;
                    continue;
                } // if(NULL == pspDriverInfoDetailData->InfFileName)

                //
                // If it's Inbox driver, set DNF_BASIC_DRIVER.
                //

                if( IsWindowsFile(pspDriverInfoDetailData->InfFileName)
                 && IsProviderMs(pspDriverInfoDetailData->InfFileName ) )
                {

                    //
                    // This is inbox INF. set DNF_BASIC_DRIVER.
                    //

                    spDriverInstallParams.Flags |= DNF_BASIC_DRIVER;
                    SetupDiSetDriverInstallParams(hDevInfo,
                                                  pDevInfoData,
                                                  &spDriverInfoData,
                                                  &spDriverInstallParams);
                } // if(IsWindowsFilw() && IsProviderMs())

                //
                // Clean up.
                //

                delete pspDriverInfoDetailData;

            } // for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData), Idx++)

            goto ClassInstall_return;
            break;
        } // case DIF_SELECTBESTCOMPATDRV:


//        case DIF_ENABLECLASS:
//        case DIF_FIRSTTIMESETUP:
        default:
            break;

    } // switch(diFunction)


ClassInstall_return:


    if(fCleanupContext){
        if(NULL != pInstallerContext){


            if(NULL != pInstallerContext->pFirstPage){
                delete (CFirstPage *)(pInstallerContext->pFirstPage);
            }
            if(NULL != pInstallerContext->pPrevSelectPage){
                delete (CPrevSelectPage *)(pInstallerContext->pPrevSelectPage);
            }
            if(NULL != pInstallerContext->pPortSelectPage){
                delete (CPortSelectPage *)(pInstallerContext->pPortSelectPage);
            }
            if(NULL != pInstallerContext->pNameDevicePage){
                delete (CNameDevicePage *)(pInstallerContext->pNameDevicePage);
            }
            if(NULL != pInstallerContext->pFinalPage){
                delete (CInstallPage *)(pInstallerContext->pFinalPage);
            }

            //
            // Removed this delete call for the pDevice pointer. The Wizard pages
            // delete this memory when a user presses "cancel" or closes the Wizard
            // dialog.
            //
            // COOPP - 01-18-2001. Quick fix to BUG #284981 Heap Corruption
            //
            // Note for future: As discussed with KeisukeT, a better design would be
            // adding a shared pInstallerContext pointer in the BASE class of the
            // Wizard pages.  This would allow this routine to remain enabled as a
            // "catch-all" case. (Catching the case if the Wizard dialogs did not free
            // the memory first)
            //
            // if(NULL != pInstallerContext->pDevice){
            //    delete pInstallerContext->pDevice;
            //}
            //

            delete pInstallerContext;
        } // if(NULL != pInstallerContext)
    }

    DebugTrace(TRACE_PROC_LEAVE,(("ClassInstall: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;
} // ClassInstall()


extern "C"
DWORD
APIENTRY
CoinstallerEntry(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    )
/*++

Routine Description:

    CoinstallerEntry

    Entrypoint of WIA class coinstaller.

Arguments:

    IN  DI_FUNCTION                     diFunction,             Function to perform.
    IN  HDEVINFO                        hDevInfo,               Handle to Device Information.
    IN  PSP_DEVINFO_DATA                pDevInfoData,           Pointer to Device Data.
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext     Context data for coinstaller.

Return Value:

    NO_ERROR                            -   Operation succeeded.
    ERROR_DI_POSTPROCESSING_REQUIRED    -   Need post processing after installation has done.

Side effects:

    None

--*/
{
    DWORD   dwReturn;

    DebugTrace(TRACE_PROC_ENTER,(("CoinstallerEntry: Enter... \r\n")));

    //
    // Initialize local.
    //

    dwReturn = NO_ERROR;

    //
    // Do Pre/Post process.
    //

    if(pCoinstallerContext->PostProcessing){

        //
        // Do post-process.
        //

        dwReturn = CoinstallerPostProcess(diFunction,
                                          hDevInfo,
                                          pDevInfoData,
                                          pCoinstallerContext);
    } else {

        //
        // Do pre-process.
        //

        dwReturn = CoinstallerPreProcess(diFunction,
                                         hDevInfo,
                                         pDevInfoData,
                                         pCoinstallerContext);
    } // if(pCoinstallerContext->PostProcessing)

// CoinstallerEntry_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CoinstallerEntry: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;

} // CoinstallerEntry()



DWORD
APIENTRY
CoinstallerPreProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    )
{
    DWORD   dwReturn;

    DebugTrace(TRACE_PROC_ENTER,(("CoinstallerPreProcess: Enter... \r\n")));
    DebugTrace(TRACE_STATUS,(("CoinstallerPreProcess: Processing %ws message.\r\n"), DifDebug[diFunction].DifString));

    //
    // Initialize local.
    //

    dwReturn = NO_ERROR;

    //
    // Dispatch requests.
    //

    switch(diFunction){

        case DIF_INSTALLDEVICE:
        {
            BOOL    bSucceeded;

            //
            // Initialize private data.
            //

            if(NULL != pCoinstallerContext->PrivateData){
                DebugTrace(TRACE_WARNING,(("CoinstallerPreProcess: WARNING!! Private has value other than NULL.\r\n")));
            }
            pCoinstallerContext->PrivateData = NULL;

            //
            // Create CDevice class.
            //

            CDevice *pDevice = new CDevice(hDevInfo, pDevInfoData, TRUE);
            if(NULL == pDevice){
                DebugTrace(TRACE_ERROR,(("CoinstallerPreProcess: ERROR!! Insufficient memory.\r\n")));
                dwReturn = NO_ERROR;
                goto CoinstallerPreProcess_return;
            } // if(NULL == pDevice)

            //
            // Let it create unique FriendlyName.
            //

            bSucceeded = pDevice->NameDefaultUniqueName();
            if(bSucceeded){

                //
                // Do pre-installation process.
                //

                bSucceeded = pDevice->PreInstall();
                if(!bSucceeded){
                    DebugTrace(TRACE_ERROR,(("CoinstallerPreProcess: ERROR!! Pre-Installation failed in CDevice class.\r\n")));
                    delete pDevice;

                    dwReturn = NO_ERROR;
                    goto CoinstallerPreProcess_return;
                }
            } else {
                DebugTrace(TRACE_ERROR,(("CoinstallerPreProcess: ERROR!! NameDefaultUniqueName failed in CDevice class.\r\n")));
                delete pDevice;

                dwReturn = NO_ERROR;
                goto CoinstallerPreProcess_return;
            }

            //
            // Post-installation have to free allocated object.
            //

            pCoinstallerContext->PrivateData = (PVOID)pDevice;
            dwReturn = ERROR_DI_POSTPROCESSING_REQUIRED;

            goto CoinstallerPreProcess_return;
            break;
        } // case DIF_INSTALLDEVICE:

        default:
            break;
    } // switch(diFunction)

CoinstallerPreProcess_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CoinstallerPreProcess: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;
} // CoinstallerPreProcess()


DWORD
APIENTRY
CoinstallerPostProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    )
{
    DWORD   dwReturn;

    DebugTrace(TRACE_PROC_ENTER,(("CoinstallerPostProcess: Enter... \r\n")));
    DebugTrace(TRACE_STATUS,(("CoinstallerPostProcess: Processing %ws message.\r\n"), DifDebug[diFunction].DifString));

    //
    // Initialize local.
    //

    dwReturn = NO_ERROR;

    //
    // Dispatch requests.
    //

    switch(diFunction){

        case DIF_INSTALLDEVICE:
        {
            BOOL    bSucceeded;
            CDevice *pDevice;

            if(NO_ERROR == pCoinstallerContext->InstallResult){
                bSucceeded = TRUE;
            } else {
                bSucceeded = FALSE;
            }
            //
            // Get pointer to the CDevice class created in pre-process.
            //

            pDevice = (CDevice *)pCoinstallerContext->PrivateData;

            //
            // Do post-installation process.
            //

            pDevice->PostInstall(bSucceeded);

            //
            // Delete CDevice object.
            //

            delete pDevice;
            pCoinstallerContext->PrivateData = NULL;

            dwReturn = NO_ERROR;
            goto CoinstallerPostProcess_return;
            break;
        } // case DIF_INSTALLDEVICE:

        default:
            break;
    } // switch(diFunction)

CoinstallerPostProcess_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CoinstallerPostProcess: Leaving... Ret=0x%x.\r\n"), dwReturn));
    return dwReturn;
} // CoinstallerPostProcess(
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\exports.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Exports.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Exported functions.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"
#include "exports.h"
#include "device.h"
#include "portsel.h"

#include <devguid.h>
#include <stdio.h>
#include <shlobj.h>
#include <objbase.h>
#include <icm.h>
#include <stiregi.h>
#include <stisvc.h>
#include <wia.h>
#include <wiapriv.h>

//
// Global
//

extern  HINSTANCE   g_hDllInstance;

//
// Function
//


DLLEXPORT
HANDLE
WINAPI
WiaAddDevice(
    VOID
    )
{
    TCHAR           CommandLine[MAX_COMMANDLINE];

    //
    // On NT, const string can't be the argument.
    //

    lstrcpy(CommandLine, STR_ADD_DEVICE);
    return WiaInstallerProcess(CommandLine);
}

DLLEXPORT
BOOL
WINAPI
WiaRemoveDevice(
    PSTI_DEVICE_INFORMATION pStiDeviceInformation
    )
{
    if(NULL == pStiDeviceInformation){
        DebugTrace(TRACE_ERROR,(("WiaRemoveDevice: ERROR!! Invalid argument.\r\n")));
        return FALSE;
    } // if(NULL == pStiDeviceInformation)

    return (RemoveDevice(NULL, g_hDllInstance, pStiDeviceInformation->szDeviceInternalName, 0));
} // WiaRemoveDevice(

HANDLE
WiaInstallerProcess(
    LPTSTR   lpCommandLine
    )
{
    BOOL                bRet = FALSE;
    HANDLE              hProcess = NULL;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO         SetupInfo = {sizeof SetupInfo, NULL, NULL, NULL, 0, 0,
                                    0, 0, 0, 0, 0, STARTF_FORCEONFEEDBACK,
                                    SW_SHOWNORMAL, 0, NULL, NULL, NULL, NULL};

    //
    // Create install wizard process.
    //



    DebugTrace(TRACE_STATUS,(("WiaInstallerProcess: Executing \"%ws\".\r\n"), lpCommandLine));
    bRet = CreateProcess(NULL,
                        lpCommandLine,
                        NULL,
                        NULL,
                        FALSE,
                        NORMAL_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &SetupInfo,
                        &ProcessInfo);

    if(bRet){
        DebugTrace(TRACE_STATUS,(("WiaInstallerProcess: Installer process successfully created.\r\n")));
        CloseHandle(ProcessInfo.hThread);
        hProcess = ProcessInfo.hProcess;
    } else {
        DebugTrace(TRACE_ERROR,(("WiaInstallerProcess: ERROR!! Unable to create a process. Err=0x%x.\r\n"), GetLastError()));
        hProcess = NULL;
    }

    return hProcess;
}

DLLEXPORT
BOOL
WINAPI
CreateWiaShortcut(
    VOID
    )
{

    HRESULT     hres;
    IShellLink  *psl;
    LONG        err;
    HKEY        khWindowsCurrentVersion;
    DWORD       dwType;
    DWORD       dwSize;

    TCHAR       pszSystemPath[MAX_PATH];        //  path to system32 folder.
    TCHAR       pszShortcutPath[MAX_PATH];      //  path to creating shortcut.
    TCHAR       pszProgramPath[MAX_PATH];       //  path to ProgramFiles folder.
    TCHAR       pszAccessoriesPath[MAX_PATH];   //  path to Accessories folder.
    TCHAR       pszWizardPath[MAX_PATH];        //  path to wiaacmgr.exe.
    TCHAR       pszSticiPath[MAX_PATH];         //  path to sti_ci.dll.

    TCHAR       pszWizardName[MAX_PATH];        //  Menu name ofcreating shortcut.
    TCHAR       pszWizardLinkName[MAX_PATH];    //  filename ofcreating shortcut.
    TCHAR       pszWizardDesc[MAX_PATH];        //  description of creating shortcut.
    TCHAR       pszAccessoriesName[MAX_PATH];   //  localized "Accessories" folder name.

    BOOL        bRet;

    //
    // Init locals.
    //

    bRet    = FALSE;
    psl     = NULL;
    err     = 0;
    khWindowsCurrentVersion = NULL;

    //
    // Get path to the "ProgramFiles" folder.
    //

    hres = SHGetFolderPath(NULL,
                           CSIDL_COMMON_PROGRAMS | CSIDL_FLAG_CREATE,
                           NULL,
                           0,
                           pszProgramPath);
    if(!SUCCEEDED(hres)){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Can't get ProgramFiles folder.\r\n")));
        bRet = FALSE;
        goto CreateWiaShortcut_return;

    }

    //
    // Get localized "Accessoies" folder name from reistry.
    //

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_WINDOWS_CURRENTVERSION,
                     &khWindowsCurrentVersion);
    if(ERROR_SUCCESS != err){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Can't open Windows\\CurrentVersion.Err=0x%x \r\n"), err));
        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    dwSize = sizeof(pszAccessoriesName);
    err = RegQueryValueEx(khWindowsCurrentVersion,
                          REGSTR_VAL_ACCESSORIES_NAME,
                          NULL,
                          &dwType,
                          (LPBYTE)pszAccessoriesName,
                          &dwSize);
    if(err){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Can't get %ws value.Err=0x%x\r\n"), REGSTR_VAL_ACCESSORIES_NAME, err));

        //
        // Unable to get "Accessories" name from registry. Let's take it from resource.
        //

        if( (NULL == g_hDllInstance)
         || (0 == LoadString(g_hDllInstance, LocalAccessoriesFolderName, pszAccessoriesName, MAX_PATH)) )
        {
            bRet = FALSE;
            goto CreateWiaShortcut_return;
        } // if(0 == LoadString(g_hDllInstance, AccessoriesFolderName, pszAccessoriesName, MAX_PATH))
    } // if(err)

    //
    // Load localizable string from resource.
    //

    if(NULL != g_hDllInstance){
        LoadString(g_hDllInstance, WiaWizardName, pszWizardName, MAX_PATH);
    } else {
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! No DLL instance\r\n")));

        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    //
    // Get System path.
    //

    if( 0== GetSystemDirectory(pszSystemPath, MAX_PATH)){
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! GetSystemDirectory failed. Err=0x%x\r\n"), GetLastError()));

        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    //
    // Create shortcut/program name.
    //


    wsprintf(pszAccessoriesPath, TEXT("%ws\\%ws"), pszProgramPath, pszAccessoriesName);
    wsprintf(pszWizardLinkName, TEXT("%ws.lnk"), WIAWIZARDCHORCUTNAME);
    wsprintf(pszShortcutPath, TEXT("%ws\\%ws"), pszAccessoriesPath, pszWizardLinkName);
    wsprintf(pszWizardPath, TEXT("%ws\\%ws"), pszSystemPath, WIAACMGR_PATH);
    wsprintf(pszSticiPath, TEXT("%ws\\%ws"), pszSystemPath, WIAINSTALLERFILENAME);
    wsprintf(pszWizardDesc, TEXT("@%ws,-%d"), pszSticiPath, WiaWizardDescription);


    //
    // Create an IShellLink object and get a pointer to the IShellLink
    // interface (returned from CoCreateInstance).
    //

    hres = CoInitialize(NULL);
    if(!SUCCEEDED(hres)){
        DebugTrace(TRACE_ERROR,(("CoInitialize failed. hres=0x%x\r\n"), hres));
        bRet = FALSE;
        goto CreateWiaShortcut_return;
    }

    hres = CoCreateInstance(CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID *)&psl);
    if (SUCCEEDED(hres)){

       IPersistFile *ppf;

       //
       // Query IShellLink for the IPersistFile interface for
       // saving the shortcut in persistent storage.
       //

       hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
       if (SUCCEEDED(hres)){

            // Set the path to the shortcut target.
            hres = psl->SetPath(pszWizardPath);

            if (SUCCEEDED(hres)){
                // Set the argument to the shortcut target.
                hres = psl->SetArguments(WIAACMGR_ARG);

                if (SUCCEEDED(hres)){
                    // Set the description of the shortcut.

                    hres = psl->SetDescription(pszWizardDesc);

                    if (SUCCEEDED(hres)){
                        // Save the shortcut via the IPersistFile::Save member function.
                        hres = ppf->Save(pszShortcutPath, TRUE);

                        if (SUCCEEDED(hres)){
                            
                            //
                            // Shortcut created. Set MUI name.
                            //
                            
                            hres = SHSetLocalizedName(pszShortcutPath, pszSticiPath, WiaWizardName);
                            if (SUCCEEDED(hres)){
                            
                                //
                                // Operation succeeded.
                                //

                                bRet = TRUE;
                            } else {
                                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SHSetLocalizedName failed. hRes=0x%x\r\n"), hres));
                            }
                        } else {
                            DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! Save failed. hRes=0x%x\r\n"), hres));
                        }
                    } else {
                        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SetDescription failed. hRes=0x%x\r\n"), hres));
                    }
                } else {
                    DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SetArguments failed. hRes=0x%x\r\n"), hres));
                }
            } else {
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! SetPath failed. hRes=0x%x\r\n"), hres));
            }

            // Release the pointer to IPersistFile.
            ppf->Release();
        } else {
            DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! QueryInterface(IID_IPersistFile) failed.\r\n")));
        }

        // Release the pointer to IShellLink.
        psl->Release();

        CoUninitialize();

    } else { // if (SUCCEEDED(hres))
        DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: ERROR!! CoCreateInstance(IID_IShellLink) failed.\r\n")));

        switch(hres){

            case REGDB_E_CLASSNOTREG :
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: REGDB_E_CLASSNOTREG.\r\n")));
                break;
            case CLASS_E_NOAGGREGATION  :
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: CLASS_E_NOAGGREGATION.\r\n")));
                break;
            case E_NOINTERFACE :
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: E_NOINTERFACE.\r\n")));
                break;

            default:
                DebugTrace(TRACE_ERROR,(("CreateWiaShortcut: default.(hres=0x%x).\r\n hres=0x%x"), hres));
                break;
        }

        bRet = FALSE;
        goto CreateWiaShortcut_return;
    } // if (SUCCEEDED(hres))

CreateWiaShortcut_return:

    if(FALSE == bRet){
        CString csCmdLine;

        //
        // Try it again after next reboot.
        //

        csCmdLine.MakeSystemPath(STI_CI32_ENTRY_WIZMANU);
        csCmdLine = TEXT(" ") + csCmdLine;
        csCmdLine = RUNDLL32 + csCmdLine;

        SetRunonceKey(REGSTR_VAL_WIZMENU, csCmdLine);
    } // if(FALSE == bRet)

    //
    // Clean up
    //

    if(NULL != khWindowsCurrentVersion){
        RegCloseKey(khWindowsCurrentVersion);
    }

    return bRet;
}

DLLEXPORT
BOOL
WINAPI
DeleteWiaShortcut(
    VOID
    )
{

    HRESULT     hres;
    IShellLink  *psl;
    LONG        err;
    HKEY        khWindowsCurrentVersion;
    DWORD       dwType;
    DWORD       dwSize;

    TCHAR       pszSystemPath[MAX_PATH];
    TCHAR       pszShortcutPath[MAX_PATH];
    TCHAR       pszAccessoriesName[MAX_PATH];   //  localized "Accessories" folder name.
    TCHAR       pszProgramPath[MAX_PATH];       //  path to ProgramFiles folder.

    BOOL        bRet;



    //
    // Init locals.
    //

    bRet    = FALSE;
    psl     = NULL;
    err     = 0;
    khWindowsCurrentVersion = NULL;

    //
    // Get path to the "ProgramFiles" folder.
    //

    hres = SHGetFolderPath(NULL,
                           CSIDL_COMMON_PROGRAMS | CSIDL_FLAG_CREATE,
                           NULL,
                           0,
                           pszProgramPath);
    if(!SUCCEEDED(hres)){
        DebugTrace(TRACE_ERROR,(("DeleteWiaShortcut: ERROR!! Can't get ProgramFiles folder.\r\n"), hres));

        bRet = FALSE;
        goto DeleteWiaShortcut_return;

    }

    //
    // Get localized "Accessoies" folder name from reistry.
    //

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_WINDOWS_CURRENTVERSION,
                     &khWindowsCurrentVersion);
    if(err){
        DebugTrace(TRACE_ERROR,(("DeleteWiaShortcut: ERROR!! Can't open Windows\\CurrentVersion key.Err=0x%x\r\n"), err));

        bRet = FALSE;
        goto DeleteWiaShortcut_return;
    }

    dwSize = sizeof(pszAccessoriesName);
    err = RegQueryValueEx(khWindowsCurrentVersion,
                          REGSTR_VAL_ACCESSORIES_NAME,
                          NULL,
                          &dwType,
                          (LPBYTE)pszAccessoriesName,
                          &dwSize);
    if(err){
        DebugTrace(TRACE_ERROR,(("DeleteWiaShortcut: ERROR!! Can't get %ws value.Err=0x%x\r\n"), REGSTR_VAL_ACCESSORIES_NAME, err));

        //
        // Unable to get "Accessories" name from registry. Let's take it from resource.
        //

        if( (NULL == g_hDllInstance)
         || (0 == LoadString(g_hDllInstance, LocalAccessoriesFolderName, pszAccessoriesName, MAX_PATH)) )
        {
            bRet = FALSE;
            goto DeleteWiaShortcut_return;
        } // if(0 == LoadString(g_hDllInstance, AccessoriesFolderName, pszAccessoriesName, MAX_PATH))
    }

    //
    // Create shortcut/program name.
    //

    wsprintf(pszShortcutPath, TEXT("%ws\\%ws\\%ws.lnk"), pszProgramPath, pszAccessoriesName, WIAWIZARDCHORCUTNAME);

    if(!DeleteFile((LPCTSTR)pszShortcutPath)){
        DebugTrace(TRACE_ERROR,(("ERROR!! DeleteFile failed. Err=0x%x\r\n"), GetLastError()));

        bRet = FALSE;
        goto DeleteWiaShortcut_return;
    }

    //
    // Operation succeeded.
    //

    bRet = TRUE;

DeleteWiaShortcut_return:

    //
    // Clean up
    //

    if(NULL != khWindowsCurrentVersion){
        RegCloseKey(khWindowsCurrentVersion);
    }

    return bRet;
}

DLLEXPORT
VOID
CALLBACK
WiaCreateWizardMenu(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    )
{
    CreateWiaShortcut();
}

DLLEXPORT
VOID
CALLBACK
AddDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPSTR       lpszCmdLine,
    int         nCmdShow
    )
{

    HANDLE                  hDevInfo;
    HWND                    hDlg;
    GUID                    Guid;
    SP_DEVINFO_DATA         spDevInfoData;
    SP_INSTALLWIZARD_DATA   InstallWizard;
    SP_DEVINSTALL_PARAMS    spDevInstallParams;
    TCHAR                   ClassName[LINE_LEN];
    DWORD                   err;
    DWORD                   dwRequired;
    HANDLE                  hMutex;

    CString                 csTitle;
    CString                 csSubTitle;
    CString                 csInstruction;
    CString                 csListLabel;

    DebugTrace(TRACE_PROC_ENTER,(("AddDevice: Enter...\r\n")));

    //
    // Initialize locals.
    //

    hDevInfo    = INVALID_HANDLE_VALUE;
    hDlg        = hWnd;
    Guid        = GUID_DEVCLASS_IMAGE;
    err         = ERROR_SUCCESS;
    dwRequired  = 0;
    hMutex      = NULL;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&InstallWizard, 0, sizeof(InstallWizard));
    memset(&spDevInstallParams, 0, sizeof(spDevInstallParams));
    memset(ClassName, 0, sizeof(ClassName));

    //
    // Acquire Mutex.
    //

    CInstallerMutex CMutex(&hMutex, WIAINSTALLWIZMUTEX, 0);
    if(!CMutex.Succeeded()){

        HWND    hwndAnotherWizard;
        CString csWindowTitle;

        hwndAnotherWizard = NULL;

        //
        // Other instance is running. Just activate that window and quit.
        //

        csWindowTitle.FromTable (MessageTitle);
        hwndAnotherWizard = FindWindow(NULL, (LPTSTR)csWindowTitle);
        if(NULL != hwndAnotherWizard){
            if(!SetForegroundWindow(hwndAnotherWizard)){
                DebugTrace(TRACE_ERROR, ("AddDevice: ERROR!! SetForegroundWindow() failed. Err=0x%x.\r\n", GetLastError()));
            } // if(!SetForegroundWindow(hwndAnotherWizard))
        } else { // if(NULL != hwndAnotherWizard)

            //
            // Mutex acquisition was failed but didn't find Window.
            // Continue.
            //

            DebugTrace(TRACE_WARNING, ("AddDevice: WARNING!! Mutex acquisition was failed but didn't find Window.\r\n"));
        } // else (NULL != hwndAnotherWizard)

        goto AddDevice_Err;
    } // if(!CMutex.Succeeded())

    //
    // Create Device Information Set from guid.
    //

    hDevInfo = SetupDiCreateDeviceInfoList(&Guid, hDlg);

    if (hDevInfo == INVALID_HANDLE_VALUE) {
        err=GetLastError();
        goto AddDevice_Err;
    }

//    //
//    // Get class install parameter.
//    //
//
//    if(!SetupDiGetClassInstallParams(hDevInfo,
//                                     NULL,
//                                     &spSelectDeviceParams.ClassInstallHeader,
//                                     sizeof(spSelectDeviceParams),
//                                     &dwRequired)){
//        err=GetLastError();
//        goto AddDevice_Err;
//    }


    //
    // Get class name from Guid.
    //

    if(!SetupDiClassNameFromGuid(&Guid,
                                 ClassName,
                                 sizeof(ClassName)/sizeof(TCHAR),
                                 NULL
                                 )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Create a new device information element to install
    //

    spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if(!SetupDiCreateDeviceInfo(hDevInfo,
                                ClassName,
                                &Guid,
                                NULL,
                                hDlg,
                                DICD_GENERATE_ID,
                                &spDevInfoData
                                )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Set new element as selected device
    //

    if(!SetupDiSetSelectedDevice(hDevInfo,
                                &spDevInfoData
                                )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Get device install parameters
    //

    spDevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,
                                      &spDevInfoData,
                                      &spDevInstallParams
                                      )){
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Set device install parameters
    //

    spDevInstallParams.Flags |= DI_SHOWOEM ;
    spDevInstallParams.Flags |= DI_USECI_SELECTSTRINGS;

    spDevInstallParams.hwndParent = hDlg;

    if(!SetupDiSetDeviceInstallParams(hDevInfo,
                                      &spDevInfoData,
                                      &spDevInstallParams
                                      )){
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Set class install parameter.
    //

    InstallWizard.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
    InstallWizard.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    InstallWizard.hwndWizardDlg =  hDlg;

    //
    // TRUE = Show first page
    //

    InstallWizard.PrivateFlags =   SCIW_PRIV_CALLED_FROMCPL | SCIW_PRIV_SHOW_FIRST;

    if(!SetupDiSetClassInstallParams(hDevInfo,
                                     &spDevInfoData,
                                     &InstallWizard.ClassInstallHeader,
                                     sizeof(SP_INSTALLWIZARD_DATA)
                                     ))
    {
        err=GetLastError();
        goto AddDevice_Err;
    }


    //
    // Call class installer to retrieve wizard pages
    //

    if(!SetupDiCallClassInstaller(DIF_INSTALLWIZARD,
                                  hDevInfo,
                                  &spDevInfoData
                                  )){
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Get result from class installer
    //

    if(!SetupDiGetClassInstallParams(hDevInfo,
                                     &spDevInfoData,
                                     &InstallWizard.ClassInstallHeader,
                                     sizeof(SP_INSTALLWIZARD_DATA),
                                     NULL
                                     ))
    {
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Prepare UI parameters to be used by DevSelect page,
    //

    csTitle.FromTable(SelDevTitle);
    csSubTitle.FromTable(SelDevSubTitle);
    csInstruction.FromTable(SelDevInstructions);
    csListLabel.FromTable(SelDevListLabel);

    if(!SetSelectDevTitleAndInstructions(hDevInfo,
                                         &spDevInfoData,
                                         (LPTSTR)csTitle,
                                         (LPTSTR)csSubTitle,
                                         (LPTSTR)csInstruction,
                                         (LPTSTR)csListLabel))
    {
        err=GetLastError();
        goto AddDevice_Err;
    }

    //
    // Get device selection page
    //

    InstallWizard.DynamicPageFlags =  DYNAWIZ_FLAG_PAGESADDED;
    InstallWizard.DynamicPages[InstallWizard.NumDynamicPages++] = SetupDiGetWizardPage(hDevInfo,
                                                                                       &spDevInfoData,
                                                                                       &InstallWizard,
                                                                                       SPWPT_SELECTDEVICE,
                                                                                       0);

    //
    // Create installer property sheet
    //

    {
        PROPSHEETHEADER PropSheetHeader;
        DWORD   Pages;
        HPROPSHEETPAGE SelectDevicePage;


        PropSheetHeader.dwSize = sizeof(PropSheetHeader);
        PropSheetHeader.dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_STRETCHWATERMARK | PSH_WATERMARK | PSH_HEADER;
        PropSheetHeader.pszbmWatermark = MAKEINTRESOURCE(WizardBitmap);
        PropSheetHeader.pszbmHeader = MAKEINTRESOURCE(IDB_BANNERBMP);
        PropSheetHeader.hwndParent = hDlg;
        PropSheetHeader.hInstance = g_hDllInstance;
        PropSheetHeader.pszIcon = NULL;            //MAKEINTRESOURCE(IDI_NEWDEVICEICON);
        PropSheetHeader.pszCaption = MAKEINTRESOURCE(MessageTitle);
        PropSheetHeader.nStartPage = 0;
        PropSheetHeader.nPages = InstallWizard.NumDynamicPages;
        PropSheetHeader.phpage = InstallWizard.DynamicPages;
        PropSheetHeader.pfnCallback = iHdwWizardDlgCallback;

        if(PropertySheet(&PropSheetHeader) < 0){
            err=GetLastError();
        }

    }

AddDevice_Err:

    //
    // Free allocated memory
    //

    if(IS_VALID_HANDLE(hDevInfo)){


        //
        // Set install parameter.
        //

        InstallWizard.ClassInstallHeader.InstallFunction = DIF_DESTROYWIZARDDATA;
        InstallWizard.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        if(!SetupDiSetClassInstallParams(hDevInfo,
                                         &spDevInfoData,
                                         &InstallWizard.ClassInstallHeader,
                                         sizeof(SP_INSTALLWIZARD_DATA)) )
        {
            DebugTrace(TRACE_ERROR,(("AddDevice: ERROR!! SetupDiSetClassInstallParams() failed with active hDevInfo.\r\n")));
        }

        //
        // Let isntaller free context data.
        //

        SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA,
                                  hDevInfo,
                                  &spDevInfoData
                                  );

        //
        // Destroy infoset.
        //
        
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("AddDevice: Leaving... Ret=VOID.\r\n")));
    return;
}


BOOL
CALLBACK
RemoveDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    )
{

    HANDLE                  hDevInfo;
    SP_DEVINFO_DATA         spDevInfoData;
    SP_REMOVEDEVICE_PARAMS  spRemoveDeviceParams;
    BOOL                    bStatus;
    BOOL                    bIsInterfaceOnly;
    DWORD                   err;
    DWORD                   dwDeviceIndex;
    TCHAR                   szTemp[MAX_FRIENDLYNAME+1];

    DebugTrace(TRACE_PROC_ENTER,(("RemoveDevice: Enter...\r\n")));

    //
    // Initialize local.
    //

    hDevInfo            = INVALID_HANDLE_VALUE;
    bStatus             = FALSE;
    err                 = ERROR_SUCCESS;
    bIsInterfaceOnly    = FALSE;
    dwDeviceIndex       = INVALID_DEVICE_INDEX;

    memset (&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
    memset((void *)&spRemoveDeviceParams, 0, sizeof(SP_REMOVEDEVICE_PARAMS));

    //
    // Check the argument.
    //

    if(NULL == lpszCmdLine){
        DebugTrace(TRACE_ERROR,(("RemoveDevice: ERROR!! Invalid argumet.\r\n")));
        goto RemoveDevice_Err;
    } // if(NULL == lpszCmdLine)

    lstrcpy(szTemp, lpszCmdLine);
    DebugTrace(TRACE_STATUS,(("RemoveDevice: Removing \"%ws\".\r\n"), szTemp));

    //
    // Get removing device element.
    //

    hDevInfo = SelectDevInfoFromDeviceId(szTemp);

    if(INVALID_HANDLE_VALUE != hDevInfo){
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        SetupDiGetSelectedDevice(hDevInfo, &spDevInfoData);
    } else {

        //
        // See if it's "Interface-only" device.
        //

        hDevInfo = GetDeviceInterfaceIndex(szTemp, &dwDeviceIndex);
        if( (INVALID_HANDLE_VALUE == hDevInfo)
         || (INVALID_DEVICE_INDEX == dwDeviceIndex) )
        {
            DebugTrace(TRACE_ERROR,(("RemoveDevice: ERROR!! Can't find \"%ws\".\r\n"), szTemp));
            goto RemoveDevice_Err;
        }

        //
        // This is "Interface-only" device.
        //

        bIsInterfaceOnly = TRUE;

    } // if(INVALID_HANDLE_VALUE != hDevInfo)

    if(bIsInterfaceOnly){
        DebugTrace(TRACE_STATUS,(("RemoveDevice: Uninstalling interface-only device.\r\n")));

        //
        // Uninstalling "Interface-only" device.
        //

        CDevice cdThis(hDevInfo, dwDeviceIndex);
        bStatus = (NO_ERROR == cdThis.Remove(NULL));

    } else { // if(bIsInterfaceOnly)
        DebugTrace(TRACE_STATUS,(("RemoveDevice: Uninstalling a device w/ devnode.\r\n")));

        //
        // Uninstalling device w/ devnode.
        //

        if(!SetupDiSetSelectedDevice(hDevInfo,
                                    &spDevInfoData
                                    )){
            err=GetLastError();
            goto RemoveDevice_Err;
        }

        //
        // Call class installer to remove selected device.
        //

        spRemoveDeviceParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
        spRemoveDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        spRemoveDeviceParams.Scope = DI_REMOVEDEVICE_GLOBAL;

        if(!SetupDiSetClassInstallParams(hDevInfo,
                                         &spDevInfoData,
                                         &spRemoveDeviceParams.ClassInstallHeader,
                                         sizeof(SP_REMOVEDEVICE_PARAMS)
                                         )){
            err=GetLastError();
            goto RemoveDevice_Err;
        }

        if(!SetupDiCallClassInstaller(DIF_REMOVE,
                                      hDevInfo,
                                      &spDevInfoData
                                      )){
            err=GetLastError();
            goto RemoveDevice_Err;
        }

        //
        // Removal succeeded.
        //

        bStatus = TRUE;

    } // if(bIsInterfaceOnly)

RemoveDevice_Err:

    if(IS_VALID_HANDLE(hDevInfo)){
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    DebugTrace(TRACE_PROC_LEAVE,(("RemoveDevice... Ret=0x%x Err=0x%x.\r\n"), bStatus, err));
    return bStatus;
} // RemoveDevice()

DLLEXPORT
VOID
CALLBACK
InstallWiaService(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    )
{
    DWORD   dwError;
    DWORD   dwStiCount;
    DWORD   dwWiaCount;

    DebugTrace(TRACE_PROC_ENTER,(("InstallWiaService: Enter...\r\n")));

    //
    // Remove old service entry.
    //

    GetDeviceCount(&dwWiaCount, &dwStiCount);
    /*  DEAD_CODE - Don't remove service!
    dwError = StiServiceRemove();
    if(NOERROR != dwError){
        DebugTrace(TRACE_ERROR,(("InstallWiaService: ERROR!! Unable to remove old service entry. Err=0x%x\n"), dwError));
    } // if(NOERROR != dwError)
    */

    //
    // Install WIA service.  This will install only if the service failed to install during processing of STI.INF, else
    // it will simply change the StartType.
    //

    dwError = StiServiceInstall(TRUE,
                                (0 == dwStiCount),  // TRUE = on demand
                                NULL,
                                NULL);
    if(NOERROR != dwError){
        DebugTrace(TRACE_ERROR,(("InstallWiaService: ERROR!! Unable to install service. Err=0x%x\n"), dwError));
    } // if(NOERROR != dwError)

    //
    // Register WIA DLLs.
    //

    ExecCommandLine(TEXT("regsvr32.exe /s wiaservc.dll"));
    ExecCommandLine(TEXT("regsvr32.exe /s sti.dll"));
    ExecCommandLine(TEXT("regsvr32.exe /s wiascr.dll"));
    ExecCommandLine(TEXT("regsvr32.exe /s wiashext.dll"));
    ExecCommandLine(TEXT("regsvr32.exe /s camocx.dll"));
    ExecCommandLine(TEXT("regsvr32.exe /s wiadefui.dll"));
    ExecCommandLine(TEXT("wiaacmgr.exe /RegServer"));
    ExecCommandLine(TEXT("regsvr32.exe /s wiavusd.dll"));
    ExecCommandLine(TEXT("regsvr32.exe /s wiasf.ax"));
    ExecCommandLine(TEXT("rundll32.exe  sti.dll,MigrateRegisteredSTIAppsForWIAEvents %%l"));

    DebugTrace(TRACE_PROC_LEAVE,(("InstallWiaService: Leaving... Ret=VOID.\r\n")));

} // InstallWiaService()


HANDLE
SelectDevInfoFromFriendlyName(
    LPTSTR  pszLocalName
    )
{
    TCHAR                   szTemp[MAX_FRIENDLYNAME+1];
    HANDLE                  hDevInfo;
    GUID                    Guid;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;
    BOOL                    bFound;
    HKEY                    hKeyDevice;
    ULONG                   cbData;
    LONG                    lResult;

    DebugTrace(TRACE_PROC_ENTER,(("SelectDevInfoFromFriendlyName: Enter...\r\n")));

    //
    // Initialize local.
    //

    hDevInfo    = INVALID_HANDLE_VALUE;
    Guid        = GUID_DEVCLASS_IMAGE;
//    Guid      = KSCATEGORY_CAPTURE;
    Idx         = 0;
    cbData      = 0;
    bFound      = FALSE;
    hKeyDevice  = NULL;
    lResult     = ERROR_SUCCESS;

    memset(szTemp, 0, sizeof(szTemp));
    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Check argument.
    //

    if(NULL == pszLocalName){
        DebugTrace(TRACE_ERROR,(("SelectDevInfoFromFriendlyName: Invalid arbument.\r\n")));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto SelectDevInfoFromFriendlyName_return;
    }

    //
    // Get device info set of specified class.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("SelectDevInfoFromFriendlyName: SetupDiGetClassDevs failed. Err=0x%x\r\n"), GetLastError()));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto SelectDevInfoFromFriendlyName_return;
    }

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        DebugTrace(TRACE_STATUS,(("SelectDevInfoFromFriendlyName: Checking Device(0x%x)\r\n"), Idx));
        hKeyDevice = SetupDiOpenDevRegKey (hDevInfo,
                                           &spDevInfoData,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ);

        if (hKeyDevice != INVALID_HANDLE_VALUE) {

            //
            // Is FriendlyName == pszLocalName?
            //

            cbData = sizeof(szTemp);
            lResult = RegQueryValueEx(hKeyDevice,
                                      REGSTR_VAL_FRIENDLY_NAME,
                                      NULL,
                                      NULL,
                                      (LPBYTE)szTemp,
                                      &cbData);
            if(ERROR_SUCCESS == lResult){

                if(_tcsicmp((LPCTSTR)pszLocalName, (LPCTSTR)szTemp) != 0) {

                    //
                    // Doesn't match, skip this one.
                    //

                    RegCloseKey(hKeyDevice);
                    continue;
                }
            } else {
                DebugTrace(TRACE_ERROR,(("SelectDevInfoFromFriendlyName: can't get FriendlyName. Err=0x%x\r\n"), GetLastError()));
                RegCloseKey(hKeyDevice);
                continue;
            }

            //
            // Found the target!
            //

            bFound = TRUE;
            RegCloseKey(hKeyDevice);
            break;
        } else {
            DebugTrace(TRACE_ERROR,(("SelectDevInfoFromFriendlyName: Invalid handle.\r\n"), GetLastError()));
        } // if (hKeyDevice != INVALID_HANDLE_VALUE)

    } //for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

SelectDevInfoFromFriendlyName_return:

    if(!bFound){

        //
        // FriendleName is not found.
        //

        if (IS_VALID_HANDLE(hDevInfo)) {
            SetupDiDestroyDeviceInfoList(hDevInfo);
            hDevInfo = INVALID_HANDLE_VALUE;
        }
    } else {

        //
        // Device found. Select found device.
        //

        SetupDiSetSelectedDevice(hDevInfo, &spDevInfoData);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("SelectDevInfoFromFriendlyName: Leaving... Ret=0x%x\r\n"), hDevInfo));

    return hDevInfo;
} // SelectDevInfoFromFriendlyName()

HANDLE
SelectDevInfoFromDeviceId(
    LPTSTR  pszDeviceId
    )
{
    TCHAR                   szTemp[MAX_DEVICE_ID];
    HANDLE                  hDevInfo;
    GUID                    Guid;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;
    BOOL                    bFound;
    HKEY                    hKeyDevice;
    ULONG                   cbData;
    LONG                    lResult;

    DebugTrace(TRACE_PROC_ENTER,(("SelectDevInfoFromDeviceId: Enter...\r\n")));

    //
    // Initialize local.
    //

    hDevInfo    = INVALID_HANDLE_VALUE;
    Guid        = GUID_DEVCLASS_IMAGE;
//    Guid      = KSCATEGORY_CAPTURE;
    Idx         = 0;
    cbData      = 0;
    bFound      = FALSE;
    hKeyDevice  = NULL;
    lResult     = ERROR_SUCCESS;

    memset(szTemp, 0, sizeof(szTemp));
    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Check argument.
    //

    if(NULL == pszDeviceId){
        DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: Invalid arbument.\r\n")));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto SelectDevInfoFromDeviceId_return;
    }

    //
    // Get device info set of specified class.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: SetupDiGetClassDevs failed. Err=0x%x\r\n"), GetLastError()));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto SelectDevInfoFromDeviceId_return;
    }

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        DebugTrace(TRACE_STATUS,(("SelectDevInfoFromDeviceId: Checking Device(0x%x)\r\n"), Idx));
        hKeyDevice = SetupDiOpenDevRegKey (hDevInfo,
                                           &spDevInfoData,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ);

        if (hKeyDevice != INVALID_HANDLE_VALUE) {

            //
            // Is DeviceId == pszDeviceId?
            //

            cbData = sizeof(szTemp);
            lResult = RegQueryValueEx(hKeyDevice,
                                      REGSTR_VAL_DEVICE_ID,
                                      NULL,
                                      NULL,
                                      (LPBYTE)szTemp,
                                      &cbData);
            if(ERROR_SUCCESS == lResult){

                if(_tcsicmp((LPCTSTR)pszDeviceId, (LPCTSTR)szTemp) != 0) {

                    //
                    // Doesn't match, skip this one.
                    //

                    RegCloseKey(hKeyDevice);
                    continue;
                }
            } else {
                DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: can't get DeviceId. Err=0x%x\r\n"), GetLastError()));
                RegCloseKey(hKeyDevice);
                continue;
            }

            //
            // Found the target!
            //

            bFound = TRUE;
            RegCloseKey(hKeyDevice);
            break;
        } else {
            DebugTrace(TRACE_ERROR,(("SelectDevInfoFromDeviceId: Invalid handle.\r\n"), GetLastError()));
        } // if (hKeyDevice != INVALID_HANDLE_VALUE)

    } //for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

SelectDevInfoFromDeviceId_return:

    if(!bFound){

        //
        // FriendleName is not found.
        //

        if (IS_VALID_HANDLE(hDevInfo)) {
            SetupDiDestroyDeviceInfoList(hDevInfo);
            hDevInfo = INVALID_HANDLE_VALUE;
        }
    } else {

        //
        // Device found. Select found device.
        //

        SetupDiSetSelectedDevice(hDevInfo, &spDevInfoData);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("SelectDevInfoFromDeviceId: Leaving... Ret=0x%x\r\n"), hDevInfo));

    return hDevInfo;
} // SelectDevInfoFromDeviceId()




HANDLE
GetDeviceInterfaceIndex(
    LPTSTR  pszDeviceId,
    DWORD   *pdwIndex
    )
{
    TCHAR                       szTemp[MAX_DEVICE_ID];
    HANDLE                      hDevInfo;
    GUID                        Guid;
    DWORD                       Idx;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    BOOL                        bFound;
    HKEY                        hKeyInterface;
    ULONG                       cbData;
    LONG                        lResult;

    DebugTrace(TRACE_PROC_ENTER,(("GetDeviceInterfaceIndex: Enter... DeviceId=%ws\r\n"), pszDeviceId));

    //
    // Initialize local.
    //

    hDevInfo        = INVALID_HANDLE_VALUE;
    Guid            = GUID_DEVCLASS_IMAGE;
    Idx             = 0;
    cbData          = 0;
    bFound          = FALSE;
    hKeyInterface   = NULL;
    lResult         = ERROR_SUCCESS;

    memset(szTemp, 0, sizeof(szTemp));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // Check argument.
    //

    if(NULL == pszDeviceId){
        DebugTrace(TRACE_ERROR,(("GetDeviceInterfaceIndex: Invalid arbument.\r\n")));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto GetDeviceInterfaceIndex_return;
    }

    //
    // Get device info set of specified class interface.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid,
                                    NULL,
                                    NULL,
                                    DIGCF_DEVICEINTERFACE | DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetDeviceInterfaceIndex: SetupDiGetClassDevs failed. Err=0x%x\r\n"), GetLastError()));

        hDevInfo = INVALID_HANDLE_VALUE;
        goto GetDeviceInterfaceIndex_return;
    }

    spDevInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);
    for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++) {

        DebugTrace(TRACE_STATUS,(("GetDeviceInterfaceIndex: Checking Interface(0x%x)\r\n"), Idx));
        hKeyInterface = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                           &spDevInterfaceData,
                                                           0,
                                                           KEY_ALL_ACCESS);
        if (INVALID_HANDLE_VALUE != hKeyInterface) {

            //
            // Is FriendlyName == pszLocalName?
            //

            cbData = sizeof(szTemp);
            lResult = RegQueryValueEx(hKeyInterface,
                                      REGSTR_VAL_DEVICE_ID,
                                      NULL,
                                      NULL,
                                      (LPBYTE)szTemp,
                                      &cbData);
            if(ERROR_SUCCESS == lResult){

                if(_tcsicmp((LPCTSTR)pszDeviceId, (LPCTSTR)szTemp) == 0) {

                    //
                    // Found the target!
                    //

                    bFound = TRUE;
                    RegCloseKey(hKeyInterface);
                    break;
                }
            } else { // if(ERROR_SUCCESS == lResult)
                DebugTrace(TRACE_STATUS,(("GetDeviceInterfaceIndex: can't get DeviceID. Err=0x%x\r\n"), GetLastError()));
            } // if(ERROR_SUCCESS == lResult)

            RegCloseKey(hKeyInterface);
            hKeyInterface = NULL;
        } else { // if (hKeyDevice != INVALID_HANDLE_VALUE)
            DWORD Err;
            Err = GetLastError();
            DebugTrace(TRACE_ERROR,(("GetDeviceInterfaceIndex: Invalid handle. Err=0x%x.\r\n"), Err));
        } // if (hKeyDevice != INVALID_HANDLE_VALUE)

    } //for (Idx = 0; SetupDiEnumDeviceInterface (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++)

GetDeviceInterfaceIndex_return:

    if(FALSE == bFound){
        if (IS_VALID_HANDLE(hDevInfo)) {
            SetupDiDestroyDeviceInfoList(hDevInfo);
            hDevInfo = INVALID_HANDLE_VALUE;
        }

        *pdwIndex = INVALID_DEVICE_INDEX;

    } else {

        //
        // Interface found.
        //

        *pdwIndex = Idx;
    }

    DebugTrace(TRACE_PROC_LEAVE,(("GetDeviceInterfaceIndex: Leaving... Ret=0x%x\r\n"), hDevInfo));

    return hDevInfo;
} // GetDeviceInterfaceIndex()





INT CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        break;

    case PSCB_PRECREATE:
        if( lParam ){

            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~DS_CONTEXTHELP;
        }
        break;
    }

    return FALSE;
}

BOOL
SetSelectDevTitleAndInstructions(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData,
    LPCTSTR             pszTitle,
    LPCTSTR             pszSubTitle,
    LPCTSTR             pszInstn,
    LPCTSTR             pszListLabel
    )
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{
    SP_SELECTDEVICE_PARAMS  SelectDevParams;
    BOOL                    fRet;

    memset((void *)&SelectDevParams, 0, sizeof(SelectDevParams));

    if ( pszTitle && (lstrlen(pszTitle) + 1 > MAX_TITLE_LEN ) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszSubTitle && (lstrlen(pszSubTitle) + 1 > MAX_SUBTITLE_LEN )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszInstn && (lstrlen(pszInstn) + 1 > MAX_INSTRUCTION_LEN )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( pszListLabel && (lstrlen(pszListLabel) + 1 > MAX_LABEL_LEN )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    SelectDevParams.ClassInstallHeader.cbSize
                                 = sizeof(SelectDevParams.ClassInstallHeader);

    if ( !SetupDiGetClassInstallParams(hDevInfo,
                                       pspDevInfoData,
                                       &SelectDevParams.ClassInstallHeader,
                                       sizeof(SelectDevParams),
                                       NULL) ) {
        DWORD   dwErr = GetLastError();

        if (ERROR_NO_CLASSINSTALL_PARAMS != dwErr ) {
            return FALSE;
        }
    }

    if ( pszTitle )
        lstrcpy(SelectDevParams.Title, pszTitle);

    if ( pszSubTitle )
        lstrcpy(SelectDevParams.SubTitle, pszSubTitle);

    if ( pszInstn )
        lstrcpy(SelectDevParams.Instructions, pszInstn);

    if ( pszListLabel )
        lstrcpy(SelectDevParams.ListLabel, pszListLabel);

    SelectDevParams.ClassInstallHeader.InstallFunction = DIF_SELECTDEVICE;
    fRet =  SetupDiSetClassInstallParams(hDevInfo,
                                         pspDevInfoData,
                                         &SelectDevParams.ClassInstallHeader,
                                         sizeof(SelectDevParams));

    return fRet;

}

DLLEXPORT
BOOL
WINAPI
WiaDeviceEnum(
    VOID
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;
    UINT            uiRetry = 10;

    DebugTrace(TRACE_PROC_ENTER,(("WiaDeviceEnum: Enter... \r\n")));

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugTrace(TRACE_ERROR,(("WiaDeviceEnum: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Open WIA service.
    //

    hService = OpenService(
        hSvcMgr,
        STI_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugTrace(TRACE_ERROR,(("WiaDeviceEnum: ERROR!! OpenService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Inform WIA service to refresh its device list.
    //

    rVal = ControlService(hService,
                          STI_SERVICE_CONTROL_REFRESH,
                         &ServiceStatus);
    if (!rVal) {
        DebugTrace(TRACE_ERROR,(("WiaDeviceEnum: ERROR!! ControlService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    DebugTrace(TRACE_PROC_LEAVE,(("WiaDeviceEnum: Leaving... Ret=0x%x\n"), rVal));
    return rVal;

} // WiaDeviceEnum()



DLLEXPORT
PWIA_PORTLIST
WINAPI
WiaCreatePortList(
    LPWSTR  szDeviceId
    )
{

    PWIA_PORTLIST   pReturn;
    GUID            PortGuid;
    HDEVINFO        hPortDevInfo = NULL;
    DWORD           Idx;
    DWORD           dwRequired;
    DWORD           dwNumberOfPorts;
    DWORD           dwSize;
    CStringArray    csaPortName;
    TCHAR           szPortName[MAX_DESCRIPTION];
    TCHAR           szPortFriendlyName[MAX_DESCRIPTION];

    BOOL            bIsSerial;
    BOOL            bIsParallel;
    BOOL            bIsAutoCapable;
    BOOL            bIsPortSelectable;
    //
    // Initialize local.
    //

    Idx                     = 0;
    hPortDevInfo            = NULL;
    pReturn                 = NULL;
    dwSize                  = 0;
    dwRequired              = 0;
    dwNumberOfPorts         = 0;

    bIsSerial               = TRUE;
    bIsParallel             = TRUE;
    bIsAutoCapable          = FALSE;
    bIsPortSelectable       = TRUE;

    memset(szPortName, 0, sizeof(szPortName));
    memset(szPortFriendlyName, 0, sizeof(szPortFriendlyName));

    //
    // Convert from WCHAR to TCHAR
    //
    #ifndef UNICODE

    #pragma message("Not optimal conversion - reimplement if running on nonUNICODE system")

    TCHAR      szDeviceIdConverted[STI_MAX_INTERNAL_NAME_LENGTH+1];

    szDeviceIdConverted[0] = TEXT('\0');
    MultiByteToWideChar(CP_ACP,
                        0,
                        szDeviceIdConverted, -1,
                        szDeviceId, sizeof(szDeviceId));

    #else
    // On UNICODE system use the same buffer
    #define szDeviceIdConverted szDeviceId
    #endif

    if(!CheckPortForDevice(szDeviceIdConverted, &bIsSerial, &bIsParallel, &bIsAutoCapable, &bIsPortSelectable)){
        DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! Unable to get port info for device.\r\n")));

        pReturn = NULL;
        goto WiaGetPortList_return;
    }

    if(bIsAutoCapable){
        dwNumberOfPorts++;
        csaPortName.Add(AUTO);
    }

    //
    // Enumerate all Port class devices if "PortSelect=NO" is not specified.
    //

    if(bIsPortSelectable){

        //
        // Get GUID of port device.
        //

        if(!SetupDiClassGuidsFromName (PORTS, &PortGuid, sizeof(GUID), &dwRequired)){
            DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! SetupDiClassGuidsFromName Failed. Err=0x%lX\r\n"), GetLastError()));

            pReturn = NULL;
            goto WiaGetPortList_return;
        } // if(!SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired))

        //
        // Get device info set of port devices.
        //

        hPortDevInfo = SetupDiGetClassDevs (&PortGuid,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT | DIGCF_PROFILE);
        if (hPortDevInfo == INVALID_HANDLE_VALUE) {
            DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! SetupDiGetClassDevs Failed. Err=0x%lX\r\n"), GetLastError()));

            pReturn = NULL;
            goto WiaGetPortList_return;
        }

        //
        // Process all of device element listed in device info set.
        //

        for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++){

            //
            // Add valid Port CreateFile/Friendly Name to array.
            //

            if(0 == lstrlen(szPortName)){
                DebugTrace(TRACE_ERROR,(("WiaGetPortList: ERROR!! Invalid Port/Friendly Name.\r\n")));

                szPortName[0] = TEXT('\0');
                continue;
            }

            DebugTrace(TRACE_STATUS,(("WiaGetPortList: Found Port %d: %ws.\r\n"), Idx, szPortName));

            //
            // Check it's port type.
            //

            if(_tcsstr((const TCHAR *)szPortName, TEXT("LPT"))){
                if(!bIsParallel){
                    szPortName[0] = TEXT('\0');
                    continue;
                }
            }

            if(_tcsstr((const TCHAR *)szPortName, TEXT("COM"))){
                if(!bIsSerial){
                    szPortName[0] = TEXT('\0');
                    continue;
                }
            }

            dwNumberOfPorts++;
            csaPortName.Add(szPortName);

            szPortName[0]           = TEXT('\0');

        } // for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++)
    } // if(bIsPortSelectable)

    if(0 != dwNumberOfPorts){

        //
        // Allocate memory for returning structure.
        //

        dwSize = sizeof(DWORD) + sizeof(LPTSTR)*dwNumberOfPorts;
        pReturn = (PWIA_PORTLIST)new BYTE[dwSize];
        if(NULL == pReturn){
            goto WiaGetPortList_return;
        }
        memset(pReturn, 0, dwSize);

        //
        // Fill in the info.
        //

        pReturn->dwNumberOfPorts = dwNumberOfPorts;
        for(Idx = 0; Idx < dwNumberOfPorts; Idx++){
            pReturn->szPortName[Idx] = (LPTSTR)new BYTE[lstrlen(csaPortName[Idx])*sizeof(TCHAR)+sizeof(TEXT('\0'))];
            if(NULL != pReturn->szPortName[Idx]){
                lstrcpy(pReturn->szPortName[Idx], csaPortName[Idx]);
            } else {
                WiaDestroyPortList(pReturn);
                pReturn = NULL;
                break;
            } // if(NULL != pReturn->szPortName[Idx])
        } // for(Idx = 0; Idx < dwNumberOfPorts; Idx++)
    } // if(0 != dwNumberOfPorts)

WiaGetPortList_return:

    //
    // Cleanup
    //
    if ( IS_VALID_HANDLE(hPortDevInfo) ) {
        SetupDiDestroyDeviceInfoList(hPortDevInfo);
    }

    return pReturn;

} // WiaCreatePortList()

DLLEXPORT
VOID
WINAPI
WiaDestroyPortList(
    PWIA_PORTLIST   pWiaPortList
    )
{
    DWORD   Idx;

    if(NULL == pWiaPortList){
        return;
    } // if(NULL == pWiaPortList)

    for(Idx = 0; Idx < pWiaPortList->dwNumberOfPorts; Idx++){
        if(NULL != pWiaPortList->szPortName[Idx]){
            delete pWiaPortList->szPortName[Idx];
        } // if(NULL != pWiaPortList->szPortName[Idx])
    } // for(Idx = 0; Idx < pWiaPortList; Idx++)

    delete pWiaPortList;

    return;

} // WiaDestroyPortList()


BOOL
CheckPortForDevice(
    LPTSTR  szDeviceId,
    BOOL    *pbIsSerial,
    BOOL    *pbIsParallel,
    BOOL    *pbIsAutoCapable,
    BOOL    *pbIsPortSelectable
    )
{

    GUID            WiaGuid;
    HDEVINFO        hWiaDevInfo;
    DWORD           dwCapability;
    SP_DEVINFO_DATA spDevInfoData;
    CString         csConnection;
    CString         csPortSelect;
    DWORD           dwDeviceIndex;
    HKEY            hkDevice;
    BOOL            bCapabilityAcquired;
    BOOL            bRet;

    BOOL            bIsSerial;
    BOOL            bIsParallel;
    BOOL            bIsAutoCapable;
    BOOL            bIsPortSelectable;
    DWORD           dwIsPnp;


    //
    // Initialize locals.
    //

    dwCapability            = 0;
    dwIsPnp                 = 0;
    hWiaDevInfo             = INVALID_HANDLE_VALUE;
    dwDeviceIndex           = INVALID_DEVICE_INDEX;
    WiaGuid                 = GUID_DEVCLASS_IMAGE;

    bRet                    = FALSE;
    bCapabilityAcquired     = FALSE;

    bIsSerial               = TRUE;
    bIsParallel             = TRUE;
    bIsAutoCapable          = FALSE;
    bIsPortSelectable       = TRUE;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Get specified device property.
    //

    hWiaDevInfo = SelectDevInfoFromDeviceId(szDeviceId);

    if(INVALID_HANDLE_VALUE != hWiaDevInfo){
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        SetupDiGetSelectedDevice(hWiaDevInfo, &spDevInfoData);

        hkDevice = SetupDiOpenDevRegKey(hWiaDevInfo,
                                        &spDevInfoData,
                                        DICS_FLAG_GLOBAL,
                                        0,
                                        DIREG_DRV,
                                        KEY_READ);

        if(INVALID_HANDLE_VALUE != hkDevice){
            csConnection.Load(hkDevice, CONNECTION);
            csPortSelect.Load(hkDevice, PORTSELECT);
            GetDwordFromRegistry(hkDevice, ISPNP, &dwIsPnp);

            if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability)){

                bCapabilityAcquired = TRUE;

            } // if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability))

            RegCloseKey(hkDevice);
            hkDevice = (HKEY)INVALID_HANDLE_VALUE;

        } // if(INVALID_HANDLE_VALUE != hkDevice)

        SetupDiDestroyDeviceInfoList(hWiaDevInfo);
        hWiaDevInfo = INVALID_HANDLE_VALUE;

    } else { // if(INVALID_HANDLE_VALUE != hDevInfo)

        SP_DEVICE_INTERFACE_DATA    spDeviceInterfaceData;

        //
        // See if it's "Interface-only" device.
        //

        hWiaDevInfo = GetDeviceInterfaceIndex(szDeviceId, &dwDeviceIndex);
        if( (INVALID_HANDLE_VALUE == hWiaDevInfo)
         || (INVALID_DEVICE_INDEX == dwDeviceIndex) )
        {
            DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! Can't find \"%ws\".\r\n"), szDeviceId));
            bRet = FALSE;
            goto CheckPortForDevice_return;
        }

        spDeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        if(!SetupDiEnumDeviceInterfaces(hWiaDevInfo, NULL, &WiaGuid, dwDeviceIndex, &spDeviceInterfaceData)){
            DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! SetupDiEnumDeviceInterfaces() failed. Err=0x%x.\r\n"), GetLastError()));
            bRet = FALSE;
            goto CheckPortForDevice_return;
        }

        hkDevice = SetupDiOpenDeviceInterfaceRegKey(hWiaDevInfo, &spDeviceInterfaceData, 0, KEY_READ);
        if(INVALID_HANDLE_VALUE == hkDevice){
            DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! SetupDiOpenDeviceInterfaceRegKey() failed. Err=0x%x.\r\n"), GetLastError()));
            bRet = FALSE;
            goto CheckPortForDevice_return;
        }

        csConnection.Load(hkDevice, CONNECTION);
        csPortSelect.Load(hkDevice, PORTSELECT);
        GetDwordFromRegistry(hkDevice, ISPNP, &dwIsPnp);
        if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability)){

            bCapabilityAcquired = TRUE;

        } // if(GetDwordFromRegistry(hkDevice, CAPABILITIES, &dwCapability))

        RegCloseKey(hkDevice);
        hkDevice = (HKEY)INVALID_HANDLE_VALUE;

    } // else (INVALID_HANDLE_VALUE != hDevInfo)

    //
    // Check what port should be shown.
    //

    if(0 != dwIsPnp){
        //
        // This is PnP device. No port should be available.
        //

        bRet                    = FALSE;
        goto CheckPortForDevice_return;
    }

    if(bCapabilityAcquired){

        if(csConnection.IsEmpty()){
            bIsSerial   = TRUE;
            bIsParallel = TRUE;
        } else {
            if(0 == _tcsicmp((LPTSTR)csConnection, SERIAL)){
                bIsSerial   = TRUE;
                bIsParallel = FALSE;
            }
            if(0 == _tcsicmp((LPTSTR)csConnection, PARALLEL)){
                bIsSerial   = FALSE;
                bIsParallel = TRUE;
            }
        }

        if(dwCapability & STI_GENCAP_AUTO_PORTSELECT){
            bIsAutoCapable = TRUE;
        } else {
            bIsAutoCapable = FALSE;
        }

        if(0 == lstrcmpi((LPTSTR)csPortSelect, NO)){
            bIsPortSelectable = FALSE;
        } else {// if(0 == lstrcmpi(csPortSelect, NO))
            bIsPortSelectable = TRUE;
        }
    } else {
        DebugTrace(TRACE_ERROR,(("CheckPortForDevice: ERROR!! Unable to acquire info from registry.\r\n")));
        bRet = FALSE;
        goto CheckPortForDevice_return;
    }

    //
    // Operation succeeded.
    //

    bRet = TRUE;

CheckPortForDevice_return:

    if(IS_VALID_HANDLE(hWiaDevInfo)){
        SetupDiDestroyDeviceInfoList(hWiaDevInfo);
    }

    if(bRet){
        *pbIsSerial         = bIsSerial;
        *pbIsParallel       = bIsParallel;
        *pbIsAutoCapable    = bIsAutoCapable;
        *pbIsPortSelectable = bIsPortSelectable;
    }

    return bRet;

} // CheckPortForDevice()

DLLEXPORT
BOOL
WINAPI
MigrateDevice(
    PDEVICE_INFO    pMigratingDevice
    )
{
    BOOL    bSucceeded;

    //
    // Initialize local.
    //

    bSucceeded  = TRUE;

    //
    // Create Device class object.
    //

    CDevice cdThis(pMigratingDevice);

    //
    // Set default devnode selector.
    //

    cdThis.SetDevnodeSelectCallback((DEVNODESELCALLBACK)GetDevinfoFromPortName);

    //
    // Generate FriendlyName.
    //

    cdThis.NameDefaultUniqueName();

    //
    // Install(migrate) the device.
    //

    bSucceeded = cdThis.PreInstall();
    if(bSucceeded){
        bSucceeded = cdThis.Install();
    }

    //
    // Do final touch. Clean up if failed, or finish installation.
    //

    cdThis.PostInstall(bSucceeded);

    return bSucceeded;
} // MigrateDevice()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\exports.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Exports..h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*  Header file for class installer exports.
*
*******************************************************************************/


#ifndef _EXPORTS_H_
#define _EXPORTS_H_

//
// Include
//

#include <sti.h>

//
// Define
//

#define STR_ADD_DEVICE      TEXT("rundll32.exe sti_ci.dll,AddDevice")
#define STR_REMOVE          TEXT("rundll32.exe sti_ci.dll,RemoveDevice ")

#define REGKEY_WINDOWS_CURRENTVERSION   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_VAL_ACCESSORIES_NAME     TEXT("SM_AccessoriesName")

#define WIA_DEVKEYLIST_INITIAL_SIZE     1024

//
// Typedef
//

typedef struct _WIA_DEVKEYLIST {

    DWORD   dwNumberOfDevices;
    HKEY    hkDeviceRegistry[1];

} WIA_DEVKEYLIST, *PWIA_DEVKEYLIST;

typedef struct _WIA_PORTLIST {

    DWORD   dwNumberOfPorts;
    LPWSTR  szPortName[1];

} WIA_PORTLIST, *PWIA_PORTLIST;

typedef PWIA_DEVKEYLIST (CALLBACK FAR * WIAENUMDEVICEREGISTRY)(BOOL bEnumActiveOnly);

//
// Prototype
//

HANDLE
WiaInstallerProcess(
    LPTSTR   lpCommandLine
    );

INT
CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    );


BOOL
SetSelectDevTitleAndInstructions(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData,
    LPCTSTR             pszTitle,
    LPCTSTR             pszSubTitle,
    LPCTSTR             pszInstn,
    LPCTSTR             pszListLabel
    );

DLLEXPORT
HANDLE
WINAPI
WiaAddDevice(
    VOID
    );

DLLEXPORT
BOOL
WINAPI
WiaRemoveDevice(
    PSTI_DEVICE_INFORMATION pStiDeviceInformation
    );

DLLEXPORT
BOOL
WINAPI
CreateWiaShortcut(
    VOID
    );

DLLEXPORT
BOOL
WINAPI
DeleteWiaShortcut(
    VOID
    );

HANDLE
SelectDevInfoFromFriendlyName(
    LPTSTR  pszLocalName
    );

HANDLE
SelectDevInfoFromDeviceId(
    LPTSTR  pszDeviceId
    );

DLLEXPORT
VOID
CALLBACK
WiaCreateWizardMenu(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPSTR       lpszCmdLine,
    int         nCmdShow
    );

DLLEXPORT
VOID
CALLBACK
AddDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPSTR       lpszCmdLine,
    int         nCmdShow
    );

BOOL
CALLBACK
RemoveDevice(
    HWND        hWnd,
    HINSTANCE   hInst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    );

INT CALLBACK
iHdwWizardDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    );

BOOL
SetSelectDevTitleAndInstructions(
    HDEVINFO    hDevInfo,
    LPCTSTR     pszTitle,
    LPCTSTR     pszSubTitle,
    LPCTSTR     pszInstn
    );

HANDLE
GetDeviceInterfaceIndex(
    LPTSTR  pszLocalName,
    DWORD   *pdwIndex
    );

DLLEXPORT
BOOL
WINAPI
WiaDeviceEnum(
    VOID
    );


DLLEXPORT
PWIA_PORTLIST
WINAPI
WiaCreatePortList(
    VOID
    );

DLLEXPORT
VOID
WINAPI
WiaDestroyPortList(
    PWIA_PORTLIST   pWiaPortList
    );

BOOL
CheckPortForDevice(
    LPTSTR  szDeviceId,
    BOOL    *pbIsSerial,
    BOOL    *pbIsParallel,
    BOOL    *pbIsAutoCapable,
    BOOL    *pbIsPortSelectable
    );

DLLEXPORT
BOOL
WINAPI
MigrateDevice(
    PDEVICE_INFO    pMigratingDevice
    );


#endif // _EXPORTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\device.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Device.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Device class for WIA class installer.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

#define INITGUID

#include "device.h"

#include "sti.h"
#include "stiregi.h"

#include <stisvc.h>
#include <devguid.h>
#include <regstr.h>
#include <icm.h>
#include <ks.h>


//
// Parsinc character used to separate field type from value in registry data section
//

#define     FIELD_DELIMETER     TEXT(',')


BOOL
CDevice::CollectNames(
    VOID
    )
{

    BOOL                        bRet;
    HANDLE                      hDevInfo;
    GUID                        Guid;
    DWORD                       dwRequired;
    DWORD                       Idx;
    SP_DEVINFO_DATA             spDevInfoData;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    TCHAR                       szTempBuffer[MAX_DESCRIPTION];
    HKEY                        hKeyInterface;
    HKEY                        hKeyDevice;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::CollectNames: Enter...\r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    hDevInfo        = INVALID_HANDLE_VALUE;
    Guid            = GUID_DEVCLASS_IMAGE;
    dwRequired      = 0;
    Idx             = 0;
    hKeyInterface   = (HKEY)INVALID_HANDLE_VALUE;
    hKeyDevice      = (HKEY)INVALID_HANDLE_VALUE;

    memset(szTempBuffer, 0, sizeof(szTempBuffer));
    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // Reset device name/ID array.
    //

    m_csaAllNames.Cleanup();
    m_csaAllId.Cleanup();

    //
    //  Get all of installed WIA "devnode" device info set.
    //

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! SetupDiGetClassDevs (devnodes) fails. Err=0x%x\n"), GetLastError()));

        bRet = FALSE;
        goto CollectNames_return;
    }

    //
    // Enum WIA devnode device friendly name and add them to array.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Looking for DevNodes.\r\n")));

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        //
        // Open device registry key.
        //

        hKeyDevice = SetupDiOpenDevRegKey(hDevInfo,
                                          &spDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ);

        if (INVALID_HANDLE_VALUE != hKeyDevice) {

            //
            // Get FriendlyName.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyDevice,
                                REGSTR_VAL_FRIENDLY_NAME,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // FriendlyName is found in this device regisgry. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device name.\r\n"), szTempBuffer));
                    m_csaAllNames.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid FriendleName (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get FriendlyName. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Get DeviceID.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyDevice,
                                REGSTR_VAL_DEVICE_ID,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // DeviceID is found in this device regisgry. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device ID.\r\n"), szTempBuffer));
                    m_csaAllId.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid DeviceID (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get DeviceID. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Close regkey and continue.
            //

            RegCloseKey(hKeyDevice);
            hKeyInterface = (HKEY)INVALID_HANDLE_VALUE;
            szTempBuffer[0] = TEXT('\0');

        } else { // if (hKeyDevice != INVALID_HANDLE_VALUE)
            DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Unable to open Device(%d) RegKey. Err=0x%x\r\n"), Idx, GetLastError()));
        } // if (hKeyDevice != INVALID_HANDLE_VALUE)

    } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

    //
    // Free "devnode" device info set.
    //

    SetupDiDestroyDeviceInfoList(hDevInfo);
    hDevInfo = INVALID_HANDLE_VALUE;

    //
    // Enum WIA interface-only device friendly name and add them to array.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Looking for Interfaces.\r\n")));

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! SetupDiGetClassDevs (inferfase) fails. Err=0x%x\n"), GetLastError()));

        bRet = FALSE;
        goto CollectNames_return;
    }

    spDevInterfaceData.cbSize = sizeof (spDevInterfaceData);
    for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++) {

        hKeyInterface = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                         &spDevInterfaceData,
                                                         0,
                                                         KEY_READ);
        if (hKeyInterface != INVALID_HANDLE_VALUE) {

            //
            // Get FriendlyName.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyInterface,
                                REGSTR_VAL_FRIENDLY_NAME,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // FriendlyName is found in this interface. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device name (interface).\r\n"), szTempBuffer));
                    m_csaAllNames.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid FriendleName (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get FriendlyName. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Get DeviceID.
            //

            dwRequired = (sizeof(szTempBuffer)-sizeof(TEXT('\0')));
            if (RegQueryValueEx(hKeyInterface,
                                REGSTR_VAL_DEVICE_ID,
                                NULL,
                                NULL,
                                (LPBYTE)szTempBuffer,
                                &dwRequired) == ERROR_SUCCESS)
            {

                //
                // DeviceID is found in this interface. Add to the list if valid.
                //

                if(0 != lstrlen(szTempBuffer)) {
                    DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Found %ws as installed device ID (interface).\r\n"), szTempBuffer));
                    m_csaAllId.Add((LPCTSTR)szTempBuffer);
                } else { // if(0 != lstrlen(szTempBuffer))
                    DebugTrace(TRACE_ERROR,(("CDevice::CollectNames: ERROR!! Invalid DeviceID (length=0).\r\n")));
                } // if(0 != lstrlen(szTempBuffer))

            } else { // if (RegQueryValueEx()
                DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: can't get DeviceID. Err=0x%x\r\n"), GetLastError()));
            } // if (RegQueryValueEx()

            //
            // Close registry key and continue.
            //

            RegCloseKey(hKeyInterface);
            hKeyInterface = (HKEY)INVALID_HANDLE_VALUE;
            szTempBuffer[0] = TEXT('\0');

        } else { // if (hKeyInterface != INVALID_HANDLE_VALUE)
            DebugTrace(TRACE_STATUS,(("CDevice::CollectNames: Unable to open Interface(%d) RegKey. Err=0x%x\r\n"), Idx, GetLastError()));
        } // if (hKeyInterface != INVALID_HANDLE_VALUE)
    } // for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++)

    //
    // Operation succeeded.
    //

    bRet = TRUE;

CollectNames_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDevInfo){
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    if(INVALID_HANDLE_VALUE != hKeyInterface){
        RegCloseKey(hKeyInterface);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::CollectNames: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::CollectNames()


// For a device w/ devnode.
CDevice::CDevice(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData,
    BOOL                bIsPnP
    )
{
    HKEY    hkDevice;
    
    //
    // Initizlize local.
    //

    hkDevice    = (HKEY)INVALID_HANDLE_VALUE;

    //
    // Initialize member.
    //

    m_hMutex                = (HANDLE)NULL;
    m_hDevInfo              = hDevInfo;
    m_pspDevInfoData        = pspDevInfoData;

    m_bIsPnP                = bIsPnP;
    m_bDefaultDevice        = FALSE;
    m_bVideoDevice          = FALSE;
    m_bInfProceeded         = FALSE;
    m_bInterfaceOnly        = FALSE;
    m_bIsMigration          = FALSE;

    m_hkInterfaceRegistry   = (HKEY)INVALID_HANDLE_VALUE;

    m_dwCapabilities        = 0;
    m_dwInterfaceIndex      = INVALID_DEVICE_INDEX;

    m_pfnDevnodeSelCallback = (DEVNODESELCALLBACK) NULL;
    m_pExtraDeviceData      = NULL;

    m_csFriendlyName.Empty();
    m_csInf.Empty();
    m_csInstallSection.Empty();
    m_csDriverDescription.Empty();
    m_csPort.Empty();
    m_csDeviceID.Empty();
    
    //
    // In case of upgrade, use original FriendlyName.
    //

    hkDevice = SetupDiOpenDevRegKey(m_hDevInfo,
                                    m_pspDevInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_READ);
    if(INVALID_HANDLE_VALUE != hkDevice){

        //
        // Device registry found. Read its FriendlyName.
        //

        m_csDriverDescription.Load(hkDevice, FRIENDLYNAME);
        m_csDeviceID.Load(hkDevice, REGSTR_VAL_DEVICE_ID);
        m_csFriendlyName.Load(hkDevice, FRIENDLYNAME);

        RegCloseKey(hkDevice);
        hkDevice = (HKEY)INVALID_HANDLE_VALUE;

    } // if(INVALID_HANDLE_VALUE != hkDevice)

    //
    // Get the number of installed devices.
    //

    GetDeviceCount(&m_dwNumberOfWiaDevice, &m_dwNumberOfStiDevice);

} // CDevice::CDevice()

// For a interface-only device.
CDevice::CDevice(
    HDEVINFO            hDevInfo,
    DWORD               dwDeviceIndex
    )
{
    //
    // Initialize member.
    //

    m_hMutex                = (HANDLE)NULL;
    m_hDevInfo              = hDevInfo;
    m_pspDevInfoData        = NULL;

    m_bIsPnP                = FALSE;
    m_bDefaultDevice        = FALSE;
    m_bVideoDevice          = FALSE;
    m_bInfProceeded         = FALSE;
    m_bInterfaceOnly        = TRUE;
    m_bIsMigration          = FALSE;

    m_hkInterfaceRegistry   = (HKEY)INVALID_HANDLE_VALUE;

    m_dwCapabilities        = 0;
    m_dwInterfaceIndex      = dwDeviceIndex;

    m_pfnDevnodeSelCallback = (DEVNODESELCALLBACK) NULL;
    m_pExtraDeviceData      = NULL;

    m_csFriendlyName.Empty();
    m_csInf.Empty();
    m_csInstallSection.Empty();
    m_csDriverDescription.Empty();
    m_csPort.Empty();
    m_csDeviceID.Empty();

    //
    // Get the number of installed devices.
    //

    GetDeviceCount(&m_dwNumberOfWiaDevice, &m_dwNumberOfStiDevice);

} // CDevice::CDevice()

// For a interface-only device.
CDevice::CDevice(
    PDEVICE_INFO        pMigratingDevice
    )
{
    TCHAR   StringBuffer[MAX_PATH+1];
    TCHAR   WindowsDir[MAX_PATH+1];

    //
    // Initialize local.
    //

    memset(StringBuffer, 0, sizeof(StringBuffer));
    memset(WindowsDir, 0, sizeof(WindowsDir));

    //
    // Initialize member.
    //

    m_hMutex                = (HANDLE)NULL;
    m_hDevInfo              = NULL;
    m_pspDevInfoData        = NULL;

    m_bIsPnP                = FALSE;
    m_bDefaultDevice        = FALSE;
    m_bVideoDevice          = FALSE;
    m_bInfProceeded         = FALSE;
    m_bInterfaceOnly        = TRUE;
    m_bIsMigration          = TRUE;

    m_hkInterfaceRegistry   = (HKEY)INVALID_HANDLE_VALUE;

    m_dwCapabilities        = 0;
    m_dwInterfaceIndex      = INVALID_DEVICE_INDEX;

    m_pfnDevnodeSelCallback = (DEVNODESELCALLBACK) NULL;

    //
    // Copy migration data.
    //

    AtoT(StringBuffer, pMigratingDevice->pszInfPath);
    m_csInf                 = StringBuffer;
    if(0 != GetWindowsDirectory(WindowsDir, MAX_PATH)){
        _sntprintf(StringBuffer, ARRAYSIZE(StringBuffer)-1, TEXT("%ws\\inf\\%ws"), WindowsDir, (LPTSTR)m_csInf);
        m_csInf                 = StringBuffer;
    } // if(0 != GetWindowsDirectory(WindowsDir, MAX_PATH))

    AtoT(StringBuffer, pMigratingDevice->pszInfSection);
    m_csInstallSection      = StringBuffer;
    AtoT(StringBuffer, pMigratingDevice->pszFriendlyName);
    m_csDriverDescription   = StringBuffer;
    AtoT(StringBuffer, pMigratingDevice->pszFriendlyName);
    m_csFriendlyName        = StringBuffer;
    AtoT(StringBuffer, pMigratingDevice->pszCreateFileName);
    m_csPort                = StringBuffer;
    m_pExtraDeviceData      = pMigratingDevice->pDeviceDataParam;
    m_csDeviceID.Empty();

    //
    // Get the number of installed devices.
    //

    GetDeviceCount(&m_dwNumberOfWiaDevice, &m_dwNumberOfStiDevice);

} // CDevice::CDevice()

CDevice::~CDevice(
    )
{
    HKEY    hkNameStore;

    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        
        //
        // Delete FriendlyName and DeviceId in name store.
        //

        RegDeleteKey(hkNameStore, m_csFriendlyName);
        RegDeleteKey(hkNameStore, m_csDeviceID);
        RegCloseKey(hkNameStore);

    } // if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))

    //
    // Make sure Mutex is released.
    //
    
    ReleaseInstallerMutex();

} // CDevice::~CDevice()

BOOL
CDevice::IsSameDevice(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoSet
    )
{
    BOOL                bRet;
    SP_DRVINFO_DATA     spDrvInfoData;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::IsSameDevice: Enter...\r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;

    memset(&spDrvInfoData, 0, sizeof(spDrvInfoData));

    //
    // Get default FriendlyName. It's used to check if it's same device or not.
    //

    spDrvInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver (hDevInfo, pspDevInfoSet, &spDrvInfoData)){

        bRet    = FALSE;
        goto IsSameDevice_return;
    } // if (SetupDiGetSelectedDriver (m_hDevInfo, m_pspDevInfoData, &spDevInfoData))

    //
    // See if it has same description of current device. (TRUE=same)
    //

    bRet = (0 == lstrcmp((LPCTSTR)spDrvInfoData.Description, (LPCTSTR)m_csPdoDescription));

IsSameDevice_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::IsSameDevice: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::IsSameDevice()

BOOL
CDevice::IsFriendlyNameUnique(
    LPTSTR  szFriendlyName
    )
    //
    //  Note:
    //  Before calling this function, caller has to make sure mutex is acquired.
    //
{
    BOOL    bRet;
    DWORD   Idx;
    DWORD   dwNumberOfName;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::IsFriendlyNameUnique: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    Idx             = 0;
    dwNumberOfName  = m_csaAllNames.Count();

    //
    // If given name is same as generated one, it's unique.
    //

    if(0 == lstrcmp(szFriendlyName, (LPTSTR)(m_csFriendlyName))){
        bRet = TRUE;
        goto IsFriendlyNameUnique_return;
    } // if(0 == lstrcmp(szFriendlyName, (LPTSTR)(m_csFriendlyName)))

    //
    // Check any existing name matches given name.
    //

    for (Idx = 0; Idx < dwNumberOfName; Idx++) {

        DebugTrace(TRACE_STATUS,(("CDevice::IsFriendlyNameUnique: Name compare %ws and %ws.\r\n"),m_csaAllNames[Idx], szFriendlyName));

        if (0 == lstrcmpi(m_csaAllNames[Idx], szFriendlyName)){
            bRet = FALSE;
            goto IsFriendlyNameUnique_return;
        }
    } // for (Idx = 0; Idx < dwNumberOfName; Idx)

    //
    // Look in name store.
    //

    if(IsNameAlreadyStored(szFriendlyName)){
        bRet = FALSE;
        goto IsFriendlyNameUnique_return;
    } // if(IsNameAlreadyStored(szFriendlyName))

    //
    // This device name is unique.
    //

    bRet = TRUE;

IsFriendlyNameUnique_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::IsFriendlyNameUnique: Leaving... Ret=0x%x\n"), bRet));
    return bRet;

} // CDevice::IsFriendlyNameUnique()


BOOL
CDevice::IsDeviceIdUnique(
    LPTSTR  szDeviceId
    )
{
    BOOL    bRet;
    DWORD   Idx;
    DWORD   dwNumberOfId;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::IsDeviceIdUnique: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    Idx             = 0;
    dwNumberOfId  = m_csaAllId.Count();

    //
    // If given ID is same as generated one, it's unique.
    //

    if(0 == lstrcmp(szDeviceId, (LPTSTR)(m_csDeviceID))){
        bRet = TRUE;
        goto IsDeviceIdUnique_return;
    } // if(0 == lstrcmp(szFriendlyName, (LPTSTR)(m_csFriendlyName)))

    //
    // Check any existing name matches given name.
    //

    for (Idx = 0; Idx < dwNumberOfId; Idx++) {

        DebugTrace(TRACE_STATUS,(("CDevice::IsDeviceIdUnique: DeviceId compare %ws and %ws.\r\n"),m_csaAllId[Idx], szDeviceId));

        if (0 == lstrcmpi(m_csaAllId[Idx], szDeviceId)){
            bRet = FALSE;
            goto IsDeviceIdUnique_return;
        } // if (0 == lstrcmpi(m_csaAllId[Idx], szFriendlyName))
    } // for (Idx = 0; Idx < dwNumberOfName; Idx)

    //
    // Look in name store.
    //

    if(IsNameAlreadyStored(szDeviceId)){
        bRet = FALSE;
        goto IsDeviceIdUnique_return;
    } // if(IsNameAlreadyStored(szFriendlyName))

    //
    // This device name is unique.
    //

    bRet = TRUE;

IsDeviceIdUnique_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::IsDeviceIdUnique: Leaving... Ret=0x%x\n"), bRet));
    return bRet;

} // CDevice::IsDeviceIdUnique()

BOOL
CDevice::NameDefaultUniqueName(
    VOID
    )
{
    SP_DRVINFO_DATA     spDrvInfoData;
    TCHAR               szFriendly[MAX_DESCRIPTION];
    TCHAR               szDescription[MAX_DESCRIPTION];
    UINT                i;
    BOOL                bRet;
    HKEY                hkNameStore;
    DWORD               dwError;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::NameDefaultUniqueName: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet        = FALSE;
    hkNameStore = (HKEY)INVALID_HANDLE_VALUE;

    memset(szFriendly, 0, sizeof(szFriendly));
    memset(szDescription, 0, sizeof(szDescription));
    memset(&spDrvInfoData, 0, sizeof(spDrvInfoData));

    //
    // Acquire mutex to make sure not duplicating FriendlyName/DeviceId.
    //

    dwError = AcquireInstallerMutex(MAX_MUTEXTIMEOUT);
    if(ERROR_SUCCESS != dwError){  // it must be done at least in 60 sec.

        if(WAIT_ABANDONED == dwError){
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Mutex abandoned. Continue...\r\n"));
        } else if(WAIT_TIMEOUT == dwError){
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to acquire mutex in 60 sec. Bail out.\r\n"));
            bRet    = FALSE;
            goto NameDefaultUniqueName_return;
        } // else if(WAIT_TIMEOUT == dwError)
    } // if(ERROR_SUCCESS != AcquireInstallerMutex(60000))

    //
    // Get all installed WIA device friendly name.
    //

    CollectNames();

    //
    // Generate unique device ID.
    //

    if(m_csDeviceID.IsEmpty()){
        GenerateUniqueDeviceId();
    } // if(m_csDeviceID.IsEmpty())

    if(m_csFriendlyName.IsEmpty()){

        //
        // Get default FriendlyName. It's used to check if it's same device or not.
        //

        spDrvInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
        if (!SetupDiGetSelectedDriver (m_hDevInfo, m_pspDevInfoData, &spDrvInfoData)){

            bRet    = FALSE;
            goto NameDefaultUniqueName_return;
        } // if (SetupDiGetSelectedDriver (m_hDevInfo, m_pspDevInfoData, &spDevInfoData))

        //
        // Copy default Device description. (= default FriendlyName)
        // Also set Vnedor name.
        //

        m_csVendor      = (LPCTSTR)spDrvInfoData.MfgName;
        m_csPdoDescription = (LPCTSTR)spDrvInfoData.Description;

        //
        // Find unique name for this device.
        //

        if(m_csDriverDescription.IsEmpty()){
            lstrcpyn(szDescription, m_csPdoDescription, ARRAYSIZE(szDescription)-1);
            m_csDriverDescription = szDescription;
        } else {
            lstrcpyn(szDescription, m_csDriverDescription, ARRAYSIZE(szDescription)-1);
        }

        lstrcpyn(szFriendly, szDescription, ARRAYSIZE(szFriendly)-1);
        for (i = 2; !IsFriendlyNameUnique(szFriendly); i++) {
            _sntprintf(szFriendly, ARRAYSIZE(szFriendly)-1, TEXT("%ws #%d"), szDescription, i);
        }

        //
        // Set created FriendlyName.
        //

        m_csFriendlyName = szFriendly;

    } // if(m_csFriendlyName.IsEmpty())

    //
    // Save FriendlyName and DeviceId in registry. It'll be deleted when installation is completed.
    //
    
    if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        HKEY    hkTemp;

        hkTemp = (HKEY)INVALID_HANDLE_VALUE;

        //
        // Create FriendlyName key.
        //

        if(ERROR_SUCCESS == RegCreateKey(hkNameStore, (LPTSTR)m_csFriendlyName, &hkTemp)){
            RegCloseKey(hkTemp);
            hkTemp = (HKEY)INVALID_HANDLE_VALUE;
        } else {
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to create %s key.\r\n", (LPTSTR)m_csFriendlyName));
        } // if(ERROR_SUCCESS != RegCreateKey(hkNameStore, (LPTSTR)m_csFriendlyName, &hkTemp))

        //
        // Create DeviceId key.
        //

        if(ERROR_SUCCESS == RegCreateKey(hkNameStore, (LPTSTR)m_csDeviceID, &hkTemp)){
            RegCloseKey(hkTemp);
            hkTemp = (HKEY)INVALID_HANDLE_VALUE;
        } else {
            DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to create %s key.\r\n", (LPTSTR)m_csDeviceID));
        } // if(ERROR_SUCCESS != RegCreateKey(hkNameStore, (LPTSTR)m_csFriendlyName, &hkTemp))

        RegCloseKey(hkNameStore);

    } else { // if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))
        DebugTrace(TRACE_ERROR,("CDevice::NameDefaultUniqueName: ERROR!! Unable to create NameStore key.\r\n"));
    } // else(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))
    
    //
    // Operation succeeded.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::NameDefaultUniqueName: Device default name=%ws.\r\n"), (LPTSTR)m_csFriendlyName));
    bRet = TRUE;

NameDefaultUniqueName_return:

    //
    // Release mutex. ReleaseInstallerMutex() will handle invalid handle also, so we can call anyway.
    //

    ReleaseInstallerMutex();

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::NameDefaultUniqueName: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::NameDefaultUniqueName()


BOOL
CDevice::GenerateUniqueDeviceId(
    VOID
    )
{
    DWORD               Idx;
    BOOL                bRet;
    TCHAR               szDeviceId[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::GenerateUniqueDeviceId: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;
    memset(szDeviceId, 0, sizeof(szDeviceId));

    //
    // Find unique name for this device.
    //

    _sntprintf(szDeviceId, ARRAYSIZE(szDeviceId)-1, TEXT("%ws\\%04d"), WIA_GUIDSTRING, 0);

    for (Idx = 1; !IsDeviceIdUnique(szDeviceId); Idx++) {
        _sntprintf(szDeviceId, ARRAYSIZE(szDeviceId)-1, TEXT("%ws\\%04d"), WIA_GUIDSTRING, Idx);
    }

    //
    // Set created hardwareId.
    //

    m_csDeviceID = szDeviceId;

    //
    // Operation succeeded.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::GenerateUniqueDeviceId: DeviceID=%ws.\r\n"), (LPTSTR)m_csDeviceID));
    bRet = TRUE;

// GenerateUniqueDeviceId_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::GenerateUniqueDeviceId: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::GenerateUniqueDeviceId()


BOOL
CDevice::Install(
    )
/*++

Routine Description:

    Worker function for DIF_INSTALL setup message

Arguments:

    none

Return Value:

    TRUE - successful
    FALSE - non successful

--*/
{

    BOOL    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::Install: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;

    //
    // Class installer only handles file copy.
    //

    if(IsMigration()){
        CreateDeviceInterfaceAndInstall();
    } else { // if(IsMigration())
        if ( !HandleFilesInstallation()){
            DebugTrace(TRACE_ERROR, (("CDevice::Install: HandleFilesInstallation Failed. Err=0x%x"), GetLastError()));

            bRet    = FALSE;
            goto Install_return;
        } // if ( !HandleFilesInstallation())
    } // else(IsMigration())

    //
    // We are successfully finished
    //

    bRet = TRUE;

Install_return:

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::Install: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
}

DWORD
CDevice::Remove(
    PSP_REMOVEDEVICE_PARAMS lprdp
    )
/*++

Routine Description:

    Remove

    method which is called when device is being removed

Arguments:

Return Value:

Side effects:

--*/
{

    CString                     csUninstallSection;
    CString                     csInf;
    CString                     csSubClass;
    DWORD                       dwCapabilities;
    PVOID                       pvContext;
    HKEY                        hkDrv;
    HKEY                        hkRun;
    GUID                        Guid;
    BOOL                        bIsServiceStopped;
    BOOL                        bIsSti;

    BOOL                        bSetParamRet;
    PSP_FILE_CALLBACK           SavedCallback;

    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
    SP_DEVINSTALL_PARAMS        DeviceInstallParams;
    DWORD                       dwReturn;
    LPTSTR                      pSec;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::Remove: Enter... \r\n")));

    //
    // Initialize local.
    //

    pvContext       = NULL;
    hkDrv           = NULL;
    hkRun           = NULL;

    bSetParamRet    = FALSE;
    SavedCallback   = NULL;
    dwReturn        = NO_ERROR;
    Guid            = GUID_DEVCLASS_IMAGE;

    bIsServiceStopped   = FALSE;
    bIsSti              = FALSE;

    memset(&DeviceInstallParams, 0, sizeof(DeviceInstallParams));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // NT setup inconsistently set this bit , disable for now
    //

    #if SETUP_PROBLEM
    if (!(lprdp->Scope & DI_REMOVEDEVICE_GLOBAL)) {

        goto Remove_return;
    }
    #endif

    //
    // The name of the uninstall section was stored during installation
    //

    if(IsInterfaceOnlyDevice()){

        DebugTrace(TRACE_STATUS,(("CDevice::Remove: This is Interface-only device.\r\n")));

        //
        // Get interface from index.
        //

        spDevInterfaceData.cbSize = sizeof(spDevInterfaceData);
        if(!SetupDiEnumDeviceInterfaces(m_hDevInfo, NULL, &Guid, m_dwInterfaceIndex, &spDevInterfaceData)){
            DebugTrace(TRACE_ERROR,(("CDevice::Remove: SetupDiEnumDeviceInterfaces() failed. Err=0x%x \r\n"), GetLastError()));

            dwReturn  = ERROR_NO_DEFAULT_DEVICE_INTERFACE;
            goto Remove_return;
        }

        //
        // Create interface reg-key.
        //

        hkDrv = SetupDiOpenDeviceInterfaceRegKey(m_hDevInfo,
                                                 &spDevInterfaceData,
                                                 0,
                                                 KEY_READ);
    } else { // if(IsInterfaceOnlyDevice())

        DebugTrace(TRACE_STATUS,(("CDevice::Remove: This is devnode device.\r\n")));

        hkDrv = SetupDiOpenDevRegKey(m_hDevInfo,
                                     m_pspDevInfoData,
                                     DICS_FLAG_GLOBAL,
                                     0,
                                     DIREG_DRV,
                                     KEY_READ);
    } // if(IsInterfaceOnlyDevice())

    if (hkDrv == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::Remove: Invalid device/interface regkey handle. Err=0x%x \r\n"), GetLastError()));

        dwReturn  = ERROR_KEY_DOES_NOT_EXIST;
        goto Remove_return;
    }

    //
    // Retrieve the name of the .INF File
    //

    csUninstallSection.Load (hkDrv, UNINSTALLSECTION);
    csInf.Load (hkDrv, INFPATH);
    csSubClass.Load(hkDrv, SUBCLASS);
    GetDwordFromRegistry(hkDrv, CAPABILITIES, &dwCapabilities);

    //
    // See if we need STI/WIA specific operation.
    //

    if( (!csSubClass.IsEmpty())
     && (0 == MyStrCmpi(csSubClass, STILL_IMAGE)) )
    {
        
        //
        // This is STI/WIA device.
        //
        
        bIsSti = TRUE;
        
        //
        // Delete "Scanner and Camera Wizard" menu.
        //

        if( (dwCapabilities & STI_GENCAP_WIA)
         && (m_dwNumberOfWiaDevice <= 1) )
        {
            DeleteWiaShortcut();

            //
            // remove following key for performance improvement.
            //

            if(ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, REGKEY_WIASHEXT)){
                DebugTrace(TRACE_ERROR,(("CDevice::Remove: RegDeleteKey() failed. Err=0x%x. \r\n"), GetLastError()));
            } // if(ERROR_SUCCESS != RegDeleteKey(HKEY_LOCAL_MACHINE, REGKEY_WIASHEXT))

        } // if( (dwCapabilities & STI_GENCAP_WIA)

        //
        // If this is the last STI/WIA device, set WIA service as Manual.
        //

        if(m_dwNumberOfStiDevice <= 1){

            HKEY    hkeyTemp;

            DebugTrace(TRACE_STATUS,(("CDevice::Remove: Last WIA device being removed. Set WIA service as MANUAL.\r\n")));

            //
            // No more still image devices -- change service to Manual start
            //

//            StopWiaService();
            SetServiceStart(STI_SERVICE_NAME, SERVICE_DEMAND_START);
            bIsServiceStopped   = TRUE;

            //
            //
            // Also remove shell's flag about WIA device presence, this should be portable
            // to NT
            //
            if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun) == 0) {
                RegDeleteValue (hkRun, REGSTR_VAL_WIA_PRESENT);
                RegCloseKey(hkRun);
                hkRun = NULL;
            } // if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun) == 0)

        } // if(m_dwNumberOfStiDevice <= 1)
    } // if (m_dwNumberOfDevice <= 1)

    //
    // Operaion succeeded.
    //

    dwReturn = NO_ERROR;

Remove_return:

    if(IsInterfaceOnlyDevice()){

        //
        // Delete interface resigtry key.
        //

        if(!SetupDiDeleteDeviceInterfaceRegKey(m_hDevInfo, &spDevInterfaceData, 0)){
            DebugTrace(TRACE_ERROR,(("CDevice::Remove: SetupDiDeleteDeviceInterfaceRegKey failed. Err=0x%x \r\n"), GetLastError()));
        } // if(!SetupDiDeleteDeviceInterfaceRegKey(m_hDevInfo, &spDevInterfaceData, 0))

        //
        // Remove the interface.
        //

        if(!SetupDiRemoveDeviceInterface(m_hDevInfo, &spDevInterfaceData)){
            DebugTrace(TRACE_ERROR,(("CDevice::Remove: SetupDiRemoveDeviceInterface failed. Err=0x%x \r\n"), GetLastError()));
        } // if(!SetupDiRemoveDeviceInterface(m_hDevInfo, &spDevInterfaceData))

    } else { // if(IsInterfaceOnlyDevice())

        //
        // Delete device resigtry key.
        //

        SetupDiDeleteDevRegKey (m_hDevInfo, m_pspDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_BOTH);

        if(NO_ERROR == dwReturn){

            //
            // Remove the device node anyway.
            //

            if(!SetupDiRemoveDevice(m_hDevInfo, m_pspDevInfoData)){
                DebugTrace(TRACE_ERROR,(("CDevice::Remove: SetupDiRemoveDevice failed. Err=0x%x \r\n"), GetLastError()));

                    //
                    // Failed to remove device instance from system. Let default installer do that.
                    //

                    dwReturn  = ERROR_DI_DO_DEFAULT;
            } // if(!SetupDiRemoveDevice(m_hDevInfo, m_pspDevInfoData))
        } // if(ERROR_DI_DO_DEFAULT != dwReturn)
    } // else (IsInterfaceOnlyDevice())

    //
    // Notify WIA service device removal
    //

    if(bIsSti){
        WiaDeviceEnum();
    } // if(TRUE == bIsSti)

    //
    // Clean up.
    //

    if(IS_VALID_HANDLE(hkDrv)){
        RegCloseKey (hkDrv);
        hkDrv = NULL;
    }

    if(IS_VALID_HANDLE(hkRun)){
        RegCloseKey (hkRun);
        hkRun = NULL;
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::Remove: Leaving... Ret=0x%x\n"), dwReturn));
    return dwReturn;
}



BOOL
CDevice::PreprocessInf(
    VOID
    )
{

    BOOL    bRet;
    HINF    hInf;

    CString csCapabilities;
    CString csDeviceType;
    CString csDeviceSubType;
    CString csDriverDescription;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::PreprocessInf: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;
    hInf    = INVALID_HANDLE_VALUE;

    //
    // Check if INF has already been proceeded.
    //

    if(m_bInfProceeded){
        DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: INF is already processed. \r\n")));
        bRet    = TRUE;
        goto ProcessInf_return;
    }

    //
    // Get Inf file/section name.
    //
    
    if( m_csInf.IsEmpty() || m_csInstallSection.IsEmpty()){
        GetInfInforamtion();
    } // if( m_csInf.IsEmpty() || m_csInstallSection.IsEmpty())

    //
    // Open INF file.
    //

    hInf = SetupOpenInfFile(m_csInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if(!IS_VALID_HANDLE(hInf)){
        DebugTrace(TRACE_ERROR, (("CDevice::PreprocessInf: Unable to open INF(%ws). Error = 0x%x.\r\n"),m_csInf, GetLastError()));

        bRet = FALSE;
        goto ProcessInf_return;
    } // if(!IS_VALID_HANDLE(hInf))
    
    //
    // Check if WiaSection entry exists.
    //

    m_csWiaSection.Load (hInf, m_csInstallSection, WIASECTION);
    if(!m_csWiaSection.IsEmpty()){
        DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: WiaSection exists. Acquire all informaiton from WiaSection..\r\n")));

        //
        // Install interface from WiaSection for MFP device.
        //

        m_csInstallSection  = m_csWiaSection;
        m_bInterfaceOnly    = TRUE;

    } // if(!m_csWiaSection.IsEmpty())

    //
    // Get all information required for installation from inf file.
    //

    m_csSubClass.Load (hInf, m_csInstallSection, SUBCLASS);
    m_csUSDClass.Load (hInf, m_csInstallSection, USDCLASS);
    m_csEventSection.Load (hInf, m_csInstallSection, EVENTS);
    m_csConnection.Load (hInf, m_csInstallSection, CONNECTION);
    m_csIcmProfile.Load (hInf, m_csInstallSection, ICMPROFILES);
    m_csPropPages.Load (hInf, m_csInstallSection, PROPERTYPAGES);
    m_csDataSection.Load (hInf, m_csInstallSection, DEVICESECTION);
    m_csUninstallSection.Load (hInf, m_csInstallSection, UNINSTALLSECTION);
    m_csPortSelect.Load (hInf, m_csInstallSection, PORTSELECT);

    if(!IsMigration()){
        csDriverDescription.Load(hInf, m_csInstallSection, DESCRIPTION);
        if(!csDriverDescription.IsEmpty()){
            m_csDriverDescription = csDriverDescription;
            if(TRUE != NameDefaultUniqueName()){
                
                //
                // Unable to generate FriendlyName.
                //
            
                bRet = FALSE;
                goto ProcessInf_return;
            } // if(TRUE != NameDefaultUniqueName())
        } // if(!m_csDriverDescription.IsEmpty())
    } // if(!IsMigration())
    csCapabilities.Load (hInf, m_csInstallSection, CAPABILITIES);
    csDeviceType.Load (hInf, m_csInstallSection, DEVICETYPE);
    csDeviceSubType.Load (hInf, m_csInstallSection, DEVICESUBTYPE);

    m_dwCapabilities = csCapabilities.Decode();
    m_dwDeviceType = csDeviceType.Decode();
    m_dwDeviceSubType = csDeviceSubType.Decode();

    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: --------------- INF parameters --------------- \r\n")));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: Description      : %ws\n"), (LPTSTR)m_csDriverDescription));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: SubClass         : %ws\n"), (LPTSTR)m_csSubClass));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: USDClass         : %ws\n"), (LPTSTR)m_csUSDClass));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: EventSection     : %ws\n"), (LPTSTR)m_csEventSection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: Connection       : %ws\n"), (LPTSTR)m_csConnection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: IcmProfile       : %ws\n"), (LPTSTR)m_csIcmProfile));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: PropPages        : %ws\n"), (LPTSTR)m_csPropPages));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: DataSection      : %ws\n"), (LPTSTR)m_csDataSection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: UninstallSection : %ws\n"), (LPTSTR)m_csUninstallSection));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: Capabilities     : 0x%x\n"), m_dwCapabilities));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: DeviceType       : 0x%x\n"), m_dwDeviceType));
    DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: DeviceSubType    : 0x%x\n"), m_dwDeviceSubType));

    //
    // Set video device flag if applicable.
    //

    if(StiDeviceTypeStreamingVideo == m_dwDeviceType){
        DebugTrace(TRACE_STATUS,(("CDevice::PreprocessInf: This is video device.\r\n")));
        m_bVideoDevice = TRUE;
    } else {
        m_bVideoDevice = FALSE;
    }

    //
    // Operation succeeded.
    //

    bRet            = TRUE;
    m_bInfProceeded = TRUE;

ProcessInf_return:

    if(IS_VALID_HANDLE(hInf)){
        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;
    } // if(IS_VALID_HANDLE(hInf))

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::PreprocessInf: Leaving... Ret=0x%x \r\n"), bRet));
    return bRet;
} // CDevice::PreprocessInf()

BOOL
CDevice::PreInstall(
    VOID
    )
{
    BOOL                                bRet;
    HKEY                                hkDrv;
    GUID                                Guid;
    HDEVINFO                            hDevInfo;
    SP_DEVINFO_DATA                     spDevInfoData;
    SP_DEVICE_INTERFACE_DATA            spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;
    BOOL                                bUseDefaultDevInfoSet;
    DWORD                               dwRequiredSize;



    DebugTrace(TRACE_PROC_ENTER,(("CDevice::PreInstall: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet                        = FALSE;

    //
    // Get all INF parameter.
    //

    if(!PreprocessInf()){
        DebugTrace(TRACE_ERROR,(("CDevice::PreInstall: ERROR!! Unable to process INF.\r\n")));

        bRet    = FALSE;
        goto PreInstall_return;
    }

/**************************************
    if(!IsInterfaceOnlyDevice()){

        //
        // Register device if it's getting manually installed and not "interface-only" device..
        //

        if(!IsPnpDevice()){
            if (!SetupDiRegisterDeviceInfo(m_hDevInfo, m_pspDevInfoData, 0, NULL, NULL, NULL)) {
                DebugTrace(TRACE_ERROR,(("CDevice::PreInstall: SetupDiRegisterDeviceInfo failed. Err=0x%x.\r\n"),GetLastError()));

                bRet = FALSE;
                goto PreInstall_return;
            }
        } // if(!IsPnpDevice())
    } // if(IsInterfaceOnlyDevice())

**************************************/

    //
    // Clean up.
    //

    //
    // Operation succeeded.
    //

    bRet = TRUE;

PreInstall_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::PreInstall: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
}


BOOL
CDevice::PostInstall(
    BOOL    bSucceeded
    )
{
    BOOL    bRet;
    HKEY    hkRun;
    HKEY    hkDrv;
    DWORD   dwFlagPresent;
    CString csInfFilename;
    CString csInfSection;
    GUID    Guid;
    HKEY    hkNameStore;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::PostInstall: Enter... \r\n")));


    //
    // Initialize local.
    //

    bRet            = FALSE;
    hkRun           = NULL;
    dwFlagPresent   = 1;
    Guid            = GUID_DEVCLASS_IMAGE;
    hkNameStore     = (HKEY)INVALID_HANDLE_VALUE;

    if(IsFeatureInstallation()){

        //
        // This is a "feature" added to other class devnode and being installed by co-isntaller.
        // Need to do actual installation here only for "feature", manual installed device would
        // be installed through wizard. (final.cpp)
        //

        bRet = Install();
        if(FALSE == bRet){
            DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: device interface registry key creation failed. \r\n")));
            bSucceeded = FALSE;
        } //if(FALSE == bRet)

    } // if(IsFeatureInstallation())

    if(!bSucceeded){

        HDEVINFO                    hDevInfo;
        SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;
        DWORD                       dwIndex;

        //
        // Installation failed. Do clean up.
        //

        DebugTrace(TRACE_STATUS,(("CDevice::PostInstall: Installation failed. Do clean up.\r\n")));

        //
        // Delete craeted interface if any.
        //

        if(IsInterfaceOnlyDevice()){
            hDevInfo = GetDeviceInterfaceIndex(m_csDeviceID, &dwIndex);
            if(IS_VALID_HANDLE(hDevInfo)){
                spDevInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);
                if(SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &Guid, dwIndex, &spDevInterfaceData)){

                    //
                    // Created Interface is found. Delete it...
                    //

                    DebugTrace(TRACE_STATUS,(("CDevice::PostInstall: Deleting created interface for %ws.\r\n"), (LPTSTR)m_csFriendlyName));

                    if(!SetupDiRemoveDeviceInterface(hDevInfo, &spDevInterfaceData)){
                        DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! Unable to delete interface for %ws. Err=0x%x\n"), m_csFriendlyName, GetLastError()));
                    }
                } // if(SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &Guid, dwIndex, &spDevInterfaceData))

                //
                // Destroy created DevInfoSet.
                //

                SetupDiDestroyDeviceInfoList(hDevInfo);
            } // if(NULL != hDevInfo)
        } // if(IsInterfaceOnlyDevice())

        bRet = TRUE;
        goto PostInstall_return;

    } // if(!bSucceeded)

    //
    // Save all Inf parameters to registry.
    //

    if(!UpdateDeviceRegistry()){
        DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! UpdateDeviceRegistry() failed. \r\n")));
    }

    //
    // Do WIA/STI device only process.
    //

    if( (!m_csSubClass.IsEmpty())
     && (0 == MyStrCmpi(m_csSubClass, STILL_IMAGE)) )
    {

        HKEY    hkeyTemp;

        //
        // Change service to AUTO start.
        //

        SetServiceStart(STI_SERVICE_NAME, SERVICE_AUTO_START);

        //
        // Start WIA service.
        //

        if(!StartWiaService()){
//            DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! Unable to start WIA service.\r\n")));
        }

        //
        // Create "Scanner and Camera Wizard" menu if WIA.
        //

        if(m_dwCapabilities & STI_GENCAP_WIA){

            CreateWiaShortcut();

            //
            // Add following value upon device arrival for performance improvement.
            //

            if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_WIASHEXT, &hkeyTemp)) {
                RegSetValue (hkeyTemp,
                             NULL,
                             REG_SZ,
                             REGSTR_VAL_WIASHEXT,
                             lstrlen(REGSTR_VAL_WIASHEXT) * sizeof(TCHAR));
                RegCloseKey(hkeyTemp);
                hkeyTemp = NULL;
            } else {
                DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! RegOpenKey(WIASHEXT) failed. Err=0x%x \r\n"), GetLastError()));
            } // if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun))
        } // if(m_dwCapabilities & STI_GENCAP_WIA)

        //
        // Also add shell's flag about WIA device presence, this should be portable
        // to NT
        //

        if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun)) {
            RegDeleteValue (hkRun, REGSTR_VAL_WIA_PRESENT);
            RegSetValueEx (hkRun,
                           REGSTR_VAL_WIA_PRESENT,
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwFlagPresent,
                           sizeof(DWORD));
        } else {
            DebugTrace(TRACE_ERROR,(("CDevice::PostInstall: ERROR!! RegOpenKey() failed. Err=0x%x \r\n"), GetLastError()));
        } // if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SOFT_STI, &hkRun))

        //
        // Notify WIA service device arrival
        //
    
        WiaDeviceEnum();
    } // if(!lstrcmpi(m_csSubClass, STILL_IMAGE))

    //
    // ICM support
    //

    ProcessICMProfiles();

    //
    // Register interface name of Videoo device.
    //

    bRet = TRUE;

PostInstall_return:

    //
    // Clean up.
    //

    if(NULL != hkRun){
        RegCloseKey(hkRun);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::PostInstall: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CDevice::PostInstall()


BOOL
CDevice::HandleFilesInstallation(
    VOID
    )
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{

    BOOL                                bRet;
    BOOL                                bSetParamRet;
    PSP_FILE_CALLBACK                   pSavedCallback;
    PVOID                               pvContext;
    SP_DEVINSTALL_PARAMS                spDeviceInstallParams;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::HandleFilesInstallation: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet                        = FALSE;
    bSetParamRet                = FALSE;
    pvContext                   = NULL;
    pSavedCallback              = NULL;

    memset(&spDeviceInstallParams, 0, sizeof(spDeviceInstallParams));

    //
    // Get device install parameter.
    //

    spDeviceInstallParams.cbSize = sizeof (SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams (m_hDevInfo, m_pspDevInfoData, &spDeviceInstallParams)) {
        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupDiGetDeviceInstallParams() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    }

    //
    // Modify device installation parameters to have custom callback
    //

    pvContext = SetupInitDefaultQueueCallbackEx(NULL,
                                                (HWND)((spDeviceInstallParams.Flags & DI_QUIETINSTALL) ?INVALID_HANDLE_VALUE : NULL),
                                                0,
                                                0,
                                                NULL);
    if(NULL == pvContext){

        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupInitDefaultQueueCallbackEx() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    } // if(NULL == pvContext)

    pSavedCallback = spDeviceInstallParams.InstallMsgHandler;
    spDeviceInstallParams.InstallMsgHandler = StiInstallCallback;
    spDeviceInstallParams.InstallMsgHandlerContext = pvContext;

    bSetParamRet = SetupDiSetDeviceInstallParams (m_hDevInfo,
                                                  m_pspDevInfoData,
                                                  &spDeviceInstallParams);

    if(FALSE == bSetParamRet){
        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupDiSetDeviceInstallParams() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    } // if(FALSE == bSetParamRet)

    //
    // Let the default installer do its job.
    //

    if(IsInterfaceOnlyDevice()){
        bRet = CreateDeviceInterfaceAndInstall();
    } else {
        bRet = SetupDiInstallDevice(m_hDevInfo, m_pspDevInfoData);
    }
    if(FALSE == bRet){
        DebugTrace(TRACE_ERROR,(("CDevice::HandleFilesInstallation: ERROR!! SetupDiInstallDevice() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto HandleFilesInstallation_return;
    } // if(FALSE == bSetParamRet)

    //
    // Terminate defaule queue callback
    //

    SetupTermDefaultQueueCallback(pvContext);

    //
    // Cleanup.
    //

    if (bSetParamRet) {
        spDeviceInstallParams.InstallMsgHandler = pSavedCallback;
        SetupDiSetDeviceInstallParams (m_hDevInfo, m_pspDevInfoData, &spDeviceInstallParams);
    }

HandleFilesInstallation_return:

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::HandleFilesInstallation: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;

} // CDevice::HandleFilesInstallation()


BOOL
CDevice::UpdateDeviceRegistry(
    VOID
    )
{
    BOOL    bRet;
    HKEY    hkDrv;
    DWORD   dwConnectionType;
    HINF    hInf;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::UpdateDeviceRegistry: Enter... \r\n")));

    //
    // Initialize Local.
    //

    bRet                = FALSE;
    hkDrv               = NULL;
    dwConnectionType    = STI_HW_CONFIG_UNKNOWN;

    //
    // Open INF.
    //

    hInf = SetupOpenInfFile(m_csInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR, (("CDevice::UpdateDeviceRegistry: Unable to open INF(%ws). Error = 0x%x.\r\n"),m_csInf, GetLastError()));

        bRet = FALSE;
        goto UpdateDeviceRegistry_return;
    } // if (hInf == INVALID_HANDLE_VALUE)

    //
    // Create device registry key.
    //

    if(IsInterfaceOnlyDevice()){

        DebugTrace(TRACE_STATUS,(("CDevice::UpdateDeviceRegistry: This is Interface-only device.\r\n")));

        //
        // Create interface reg-key.
        //

        hkDrv = m_hkInterfaceRegistry;

    } else { // if(IsInterfaceOnlyDevice())

        DebugTrace(TRACE_STATUS,(("CDevice::UpdateDeviceRegistry: This is devnode device.\r\n")));

        hkDrv = SetupDiCreateDevRegKey(m_hDevInfo,
                                       m_pspDevInfoData,
                                       DICS_FLAG_GLOBAL,
                                       0,
                                       DIREG_DRV,
                                       NULL,
                                       NULL);
    } // if(IsInterfaceOnlyDevice())
    if(hkDrv == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::UpdateDeviceRegistry: ERROR!! SetupDiCreateDevRegKey() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto UpdateDeviceRegistry_return;
    } //if(hkDrv == INVALID_HANDLE_VALUE)

    //
    // Save INF parameters to registry.
    //

    if(m_csPort.IsEmpty()){
        if(m_bInterfaceOnly){

            //
            // If PortName doesn't exist for interface-only device, then use symbolic link as CraeteFile name.
            //

            m_csSymbolicLink.Store(hkDrv, CREATEFILENAME);
        } //if(m_bInterfaceOnly)
    } else { // if(m_csPort.IsEmpty())
        m_csPort.Store(hkDrv, CREATEFILENAME);
    } // if(m_csPort.IsEmpty())

    m_csSubClass.Store(hkDrv, SUBCLASS);
    m_csUSDClass.Store(hkDrv, USDCLASS);
    m_csVendor.Store(hkDrv, VENDOR);
    m_csFriendlyName.Store(hkDrv, FRIENDLYNAME);
    m_csUninstallSection.Store(hkDrv, UNINSTALLSECTION);
    m_csPropPages.Store(hkDrv, PROPERTYPAGES);
    m_csIcmProfile.Store(hkDrv, ICMPROFILES);
    m_csDeviceID.Store(hkDrv, REGSTR_VAL_DEVICE_ID);
    m_csPortSelect.Store (hkDrv, PORTSELECT);


    if(IsInterfaceOnlyDevice()){
        m_csInf.Store(hkDrv, INFPATH);
        m_csInstallSection.Store(hkDrv, INFSECTION);
        m_csDriverDescription.Store(hkDrv, DRIVERDESC);
    } // if(IsInterfaceOnlyDevice())

    //
    // Save DWORD values.
    //

    RegSetValueEx(hkDrv,
                  CAPABILITIES,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_dwCapabilities,
                  sizeof(m_dwCapabilities));

    RegSetValueEx(hkDrv,
                  DEVICETYPE,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_dwDeviceType,
                  sizeof(m_dwDeviceType));

    RegSetValueEx(hkDrv,
                  DEVICESUBTYPE,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_dwDeviceSubType,
                  sizeof(m_dwDeviceSubType));

    RegSetValueEx(hkDrv,
                  ISPNP,
                  0,
                  REG_DWORD,
                  (LPBYTE) &m_bIsPnP,
                  sizeof(m_bIsPnP));

    //
    // Set HardwareConfig. (= Connection)
    //

    if(!m_csConnection.IsEmpty()){

        m_csConnection.Store (hkDrv, CONNECTION);

        if(_tcsicmp(m_csConnection, SERIAL) == 0 ){
            dwConnectionType = STI_HW_CONFIG_SERIAL;
        }
        else if(_tcsicmp(m_csConnection, PARALLEL) == 0 ){
            dwConnectionType = STI_HW_CONFIG_PARALLEL;
        }

        if (dwConnectionType != STI_HW_CONFIG_UNKNOWN) {
            RegSetValueEx(hkDrv,
                          REGSTR_VAL_HARDWARE,
                          0,
                          REG_DWORD,
                          (LPBYTE) &dwConnectionType,
                          sizeof(dwConnectionType));
        }
    } // if(!m_csConneciton.IsEmpty())

    //
    // Process DeviceData section.
    //

    ProcessDataSection(hInf, hkDrv);

    //
    // Process Event section.
    //

    ProcessEventsSection(hInf, hkDrv);

    //
    // Create registry key for video key if applicable.
    //

    ProcessVideoDevice(hkDrv);

    //
    // Operation succeeded.
    //

    bRet = TRUE;

UpdateDeviceRegistry_return:

    //
    // Cleanup.
    //

    if(hkDrv != INVALID_HANDLE_VALUE){
        RegCloseKey(hkDrv);
        m_hkInterfaceRegistry = NULL;
    }

    if(hInf != INVALID_HANDLE_VALUE){
        SetupCloseInfFile(hInf);
    }


    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::UpdateDeviceRegistry: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CDevice::UpdateDeviceRegistry()


VOID
CDevice::ProcessVideoDevice(
    HKEY        hkDrv
    )
{

    GUID                                Guid;
    HKEY                                hkDeviceData;
    TCHAR                               Buffer[1024];
    SP_DEVICE_INTERFACE_DATA            spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetail;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessVideoDevice: Enter... \r\n")));

    //
    // Initialize local.
    //

     Guid                   = KSCATEGORY_CAPTURE;
     pspDevInterfaceDetail  = NULL;
     hkDeviceData           = NULL;

     memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));
     memset(Buffer, 0, sizeof(Buffer));

    //
    // This is only for video devices.
    //

    if (!m_bVideoDevice) {
        DebugTrace(TRACE_STATUS,(("CDevice::ProcessVideoDevice: This is not a video device. Do nothing.\r\n")));
        goto ProcessVideoDevice_return;
    }

    //
    // Use "AUTO" as dummy CreatFile name for Video devices.
    //

    RegSetValueEx( hkDrv,
                   CREATEFILENAME,
                   0,
                   REG_SZ,
                   (LPBYTE)AUTO,
                   (lstrlen(AUTO)+1)*sizeof(TCHAR)
                  );

    //
    // Get device interface data of installing Video device.
    //

    spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    if (!SetupDiEnumDeviceInterfaces (m_hDevInfo,
                                      m_pspDevInfoData,
                                      &Guid,
                                      0,
                                      &spDevInterfaceData
                                      ) )
    {
        DebugTrace(TRACE_ERROR,(("ProcessVideoDevice: ERROR!!SetupDiEnumDeviceInterfaces failed. Err=0x%x \r\n"), GetLastError()));
        goto ProcessVideoDevice_return;
    }

    //
    // Get detailed data of acquired interface.
    //

    pspDevInterfaceDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA)Buffer;
    pspDevInterfaceDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
    if (!SetupDiGetDeviceInterfaceDetail (m_hDevInfo,
                                          &spDevInterfaceData,
                                          pspDevInterfaceDetail,
                                          sizeof(Buffer) - sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA),
                                          NULL,
                                          NULL) )
    {
        DebugTrace(TRACE_ERROR,(("ProcessVideoDevice: ERROR!!SetupDiGetDeviceInterfaceDetail failed. Err=0x%x \r\n"), GetLastError()));
        goto ProcessVideoDevice_return;
    }

    //
    // We got the device path, now write it to registry
    //

    if (ERROR_SUCCESS != RegOpenKey(hkDrv, DEVICESECTION, &hkDeviceData)) {
        DebugTrace(TRACE_ERROR,(("ProcessVideoDevice: ERROR!! Unable to open DeviceData key. Err=0x%x \r\n"), GetLastError()));
        goto ProcessVideoDevice_return;
    }

    RegSetValueEx(hkDeviceData,
                  VIDEO_PATH_ID,
                  0,
                  REG_SZ,
                  (LPBYTE)pspDevInterfaceDetail->DevicePath,
                  (lstrlen(pspDevInterfaceDetail->DevicePath)+1)*sizeof(TCHAR) );

ProcessVideoDevice_return:

    //
    // Cleanup.
    //

    if(NULL != hkDeviceData){
        RegCloseKey(hkDeviceData);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::ProcessVideoDevice: Leaving... Ret=VOID.\r\n")));
    return;
} // CDevice::ProcessVideoDevice()


VOID
CDevice::ProcessEventsSection(
    HINF        hInf,
    HKEY        hkDrv
    )
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{

    CString csFriendlyName;
    CString csRegisteredApp;
    CString csGuid;

    HKEY    hkEvents;
    HKEY    hkEventPod;

    INFCONTEXT InfContext;
    UINT    uiLineIndex = 0;

    BOOL    fRet = TRUE;
    BOOL    fLooping = TRUE;

    TCHAR   pKeyName[LINE_LEN ];
    TCHAR   pField [MAX_INF_STRING_LENGTH];
    TCHAR   pTypeField[LINE_LEN];

    DWORD   dwKeySize = LINE_LEN;
    DWORD   dwFieldSize = MAX_INF_STRING_LENGTH;

    DWORD   dwError = 0;
    DWORD   dwFieldIndex = 0;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessEventsSection: Enter... \r\n")));

    if (!m_csEventSection.IsEmpty()) {

        // First create device data subkey
        dwError = RegCreateKey(hkDrv, EVENTS, &hkEvents);

        if ( NOERROR == dwError ) {

            fLooping = SetupFindFirstLine(hInf,
                                      (LPCTSTR) m_csEventSection,
                                      NULL,
                                      &InfContext
                                      );
            while (fLooping) {


                ::ZeroMemory(pKeyName, sizeof(pKeyName));
                ::ZeroMemory(pField, sizeof(pField));
                ::ZeroMemory(pTypeField, sizeof(pTypeField) );


                // Get key name as zero-based indexed field
                dwFieldIndex = 0;
                dwKeySize = sizeof(pKeyName) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pKeyName,
                                           dwKeySize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet) {
                    // Didn't get key name - move to the next
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get key name. Error=0x%x. \r\n"), dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                // Get friendly name  field
                dwFieldIndex = 1;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get name - move to the next
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get field [%d]. Error=0x%x. \r\n"), dwFieldIndex, dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                csFriendlyName = pField;

                // Get GUID field
                dwFieldIndex = 2;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get GUID - move to the next line
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get field [%d]. Error=0x%x. \r\n"), dwFieldIndex, dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                csGuid = pField;

                // Get registered app  field
                dwFieldIndex = 3;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           3,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (fRet ) {
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Failed to get field [%d]. Error=0x%x. \r\n"), dwFieldIndex, dwError));
                    csRegisteredApp = pField;
                }
                else {
                    // Didn't get key type - use widlcard by default
                    csRegisteredApp = TEXT("*");
                }

                // Now only if we have all needed values - save to the registry
                if (RegCreateKey(hkEvents, pKeyName, &hkEventPod) == NO_ERROR) {

                    // Event friendly name  store as default value
                    csFriendlyName.Store (hkEventPod, TEXT(""));

                    csGuid.Store (hkEventPod, SZ_GUID);

                    csRegisteredApp.Store (hkEventPod, LAUNCH_APP);

                    RegCloseKey (hkEventPod);
                } else {
                    // Couldn't create event key - bad
                    DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Unable to create RegKey. Error=0x%x.\r\n"), GetLastError()));
                }

                // Move to the next line finally
                fLooping = SetupFindNextLine(&InfContext,&InfContext);
            }

            RegCloseKey (hkEvents);

        } else {
            DebugTrace(TRACE_ERROR,(("CDevice::ProcessEventsSection: ERROR!! Unable to create event RegKey. Error=0x%x.\r\n"), GetLastError()));
        }
    }
// ProcessEventsSection_return:

    //
    // Cleanup.
    //

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::ProcessEventsSection: Leaving... Ret=VOID.\r\n")));
    return;
} // CDevice::ProcessEventsSection()

VOID
CDevice::ProcessDataSection(
    HINF        hInf,
    HKEY        hkDrv
)
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{
    CString     csTempValue;
    HKEY        hkDeviceData;

    INFCONTEXT  InfContext;

    UINT        uiLineIndex = 0;

    BOOL        fRet = TRUE;
    BOOL        fLooping = TRUE;

    TCHAR       pKeyName[LINE_LEN ];
    TCHAR       pField [MAX_INF_STRING_LENGTH];
    TCHAR       pTypeField[LINE_LEN];

    // Sizes are in characters
    DWORD       dwKeySize = LINE_LEN;
    DWORD       dwFieldSize = MAX_INF_STRING_LENGTH;

    DWORD       dwError = 0;
    DWORD       dwFieldIndex = 0;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessDataSection: Enter... \r\n")));

    if (!m_csDataSection.IsEmpty()) {

        // First create device data subkey
        dwError = RegCreateKey(hkDrv, DEVICESECTION, &hkDeviceData);

        if ( NOERROR == dwError ) {

            // Seek to the first line of the section
            fLooping = SetupFindFirstLine(hInf,
                                      (LPCTSTR) m_csDataSection,
                                      NULL,
                                      &InfContext);

            while (fLooping) {

                dwKeySize = sizeof(pKeyName) / sizeof(TCHAR);

                ::ZeroMemory(pKeyName, sizeof(pKeyName));
                ::ZeroMemory(pField, sizeof(pField));
                ::ZeroMemory(pTypeField, sizeof(pTypeField) );


                dwFieldIndex = 0;

                // Get key name as zero-indexed field
                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pKeyName,
                                           dwKeySize,
                                           &dwKeySize);

                dwError = ::GetLastError();
                if (!fRet) {
                    // Didn't get key name - move to the next
                    DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: Failed to get key name. Error = 0x%x.\r\n"),dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                // Get value field
                dwFieldIndex = 1;
                dwFieldSize = sizeof(pField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get key name - move to the next
                    DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: Failed to get field [%d]. Error = 0x%x.\r\n"),dwFieldIndex, dwError));
                    fLooping = SetupFindNextLine(&InfContext,&InfContext);
                    continue;
                }

                csTempValue = pField;
                // Get value field
                *pTypeField = TEXT('\0');
                dwFieldIndex = 2;
                dwFieldSize = sizeof(pTypeField) / sizeof(TCHAR);

                fRet = SetupGetStringField(&InfContext,
                                           dwFieldIndex,
                                           pTypeField,
                                           dwFieldSize,
                                           NULL);

                dwError = ::GetLastError();
                if (!fRet ) {
                    // Didn't get key type - assume string
                    *pTypeField = TEXT('\0');
                }

                // Now we have both type and value - save it in the registry
                csTempValue.Store (hkDeviceData, pKeyName,pTypeField );

                // Move to the next line finally
                fLooping = SetupFindNextLine(&InfContext,&InfContext);
            }

            //
            // Process migrating DeviceData section.
            //

            MigrateDeviceData(hkDeviceData, m_pExtraDeviceData, "");

            // Now clean up
            RegCloseKey (hkDeviceData);

        } else { // if ( NOERROR == dwError )
            DebugTrace(TRACE_ERROR, (("CDevice::ProcessDataSection: ERROR!! Unable to create DataSection RegKey. Error = 0x%x.\r\n"), dwError));
        } // if ( NOERROR == dwError )

    } // if (!m_csDataSection.IsEmpty())

// ProcessDataSection_return:

    //
    // Cleanup.
    //

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::ProcessDataSection: Leaving... Ret=VOID.\r\n")));
    return;
} // CDevice::ProcessDataSection()

VOID
CDevice::ProcessICMProfiles(
    VOID
)
/*++

Routine Description:

Arguments:

Return Value:

Side effects:

--*/
{

    DWORD           Idx;
    CStringArray    csaICMProfiles;
    TCHAR           szAnsiName[STI_MAX_INTERNAL_NAME_LENGTH];

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::ProcessICMProfiles: Enter... \r\n")));

    //
    // Initialize Local.
    //

    Idx = 0;

    memset(szAnsiName, 0, sizeof(szAnsiName));

    //
    // If section doesn't exist, just return.
    //

    if(m_csIcmProfile.IsEmpty()){
        goto ProcessICMProfiles_return;
    }

    //
    // Split a line to each token.
    //

    csaICMProfiles.Tokenize ((LPTSTR)m_csIcmProfile, FIELD_DELIMETER);

    //
    // Process all ICM profiles.
    //

    while ((LPTSTR)csaICMProfiles[Idx] != NULL) {

        DebugTrace(TRACE_STATUS,(("ProcessICMProfiles: Installing ICM profile%d(%ws) for %ws.\r\n"), Idx, (LPTSTR)csaICMProfiles[Idx], (LPTSTR)m_csDeviceID));

        //
        // Install color profile.
        //

        if (!InstallColorProfile (NULL, csaICMProfiles[Idx])) {
            DebugTrace(TRACE_ERROR,(("ProcessICMProfiles: ERROR!! InstallColorProfile failed. Err=0x%x \r\n"), GetLastError()));
        } // if (!InstallColorProfile (NULL, csaICMProfiles[Idx]))

        //
        // Register color profile with installing device.
        //

        if (!AssociateColorProfileWithDevice (NULL, csaICMProfiles[Idx], (LPTSTR)m_csDeviceID)) {
                    DebugTrace(TRACE_ERROR,(("ProcessICMProfiles: ERROR!! AssociateColorProfileWithDevice failed. Err=0x%x \r\n"), GetLastError()));        }

        //
        // Process next device.
        //

        Idx++;

    } // while ((LPTSTR)csaICMProfiles[Idx] != NULL)

ProcessICMProfiles_return:
    return;

} // CDevice::ProcessICMProfiles()


BOOL
CDevice::GetInfInforamtion(
    VOID
    )
{
    BOOL                    bRet;

    HINF                    hInf;
    SP_DRVINFO_DATA         DriverInfoData;
    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData;
    TCHAR                   szInfSectionName[MAX_DESCRIPTION];
    DWORD                   dwSize;
    DWORD                   dwLastError;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::GetInfInforamtion: Enter... \r\n")));

    //
    // Initialize locals.
    //

    dwSize                  = 0;
    bRet                    = FALSE;
    hInf                    = INVALID_HANDLE_VALUE;
    dwLastError             = ERROR_SUCCESS;
    pDriverInfoDetailData   = NULL;

    memset (szInfSectionName, 0, sizeof(szInfSectionName));
    memset (&DriverInfoData, 0, sizeof(SP_DRVINFO_DATA));

    //
    // Get selected device driver information.
    //

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(m_hDevInfo, m_pspDevInfoData, &DriverInfoData)) {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetSelectedDriver Failed. Err=0x%x\r\n"), GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // See required buffer size for driver detailed data.
    //

    SetupDiGetDriverInfoDetail(m_hDevInfo,
                               m_pspDevInfoData,
                               &DriverInfoData,
                               NULL,
                               0,
                               &dwSize);
    dwLastError = GetLastError();
    if(ERROR_INSUFFICIENT_BUFFER != dwLastError){
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetDriverInfoDetail doesn't return required size.Er=0x%x\r\n"),dwLastError));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Allocate required size of buffer for driver detailed data.
    //

    pDriverInfoDetailData   = (PSP_DRVINFO_DETAIL_DATA)new char[dwSize];
    if(NULL == pDriverInfoDetailData){
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! Unable to allocate driver detailed info buffer.\r\n")));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Initialize allocated buffer.
    //

    memset(pDriverInfoDetailData, 0, dwSize);
    pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    //
    // Get detailed data of selected device driver.
    //

    if(!SetupDiGetDriverInfoDetail(m_hDevInfo,
                                   m_pspDevInfoData,
                                   &DriverInfoData,
                                   pDriverInfoDetailData,
                                   dwSize,
                                   NULL) )
    {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetDriverInfoDetail Failed.Er=0x%x\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Open INF file of selected driver.
    //

    hInf = SetupOpenInfFile(pDriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);
    if (hInf == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupOpenInfFile Failed.Er=0x%x\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Get actual INF section name to be installed.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          pDriverInfoDetailData->SectionName,
                                          szInfSectionName,
                                          sizeof(szInfSectionName)/sizeof(TCHAR),
                                          NULL,
                                          NULL) )
    {
        DebugTrace(TRACE_ERROR,(("CDevice::GetInfInforamtion: ERROR!! SetupDiGetActualSectionToInstall Failed.Er=0x%x\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtion_return;
    }

    //
    // Set Inf section/file name.
    //

    m_csInf             = pDriverInfoDetailData->InfFileName;
    m_csInstallSection  = szInfSectionName;

    DebugTrace(TRACE_STATUS,(("CDevice::GetInfInforamtion: INF Filename    : %ws\n"),(LPTSTR)m_csInf));
    DebugTrace(TRACE_STATUS,(("CDevice::GetInfInforamtion: INF Section name: %ws\n"),(LPTSTR)m_csInstallSection));

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetInfInforamtion_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hInf){
        SetupCloseInfFile(hInf);
    }

    if(NULL != pDriverInfoDetailData){
        delete[] pDriverInfoDetailData;
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::GetInfInforamtion: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // CDevice::GetInfInforamtion()


VOID
CDevice::SetPort(
    LPTSTR              szPortName
    )
{
    DebugTrace(TRACE_STATUS,(("CDevice::SetPort: Current Portname=%ws\n"), szPortName));

    //
    // Set PortName.
    //

    m_csPort = szPortName;

} // CDevice::SetPort()

VOID    
CDevice::SetFriendlyName(
    LPTSTR szFriendlyName
    )
    //
    //  Note:
    //  Before calling this function, caller has to make sure mutex is acquired.
    //
{
    HKEY    hkNameStore;

    //
    // Mutex must have been acquired before this call.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::SetFriendlyName: Current CreateFileName=%ws\n"), szFriendlyName));

    //
    // Delete stored entry, create new one.
    //

    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        HKEY    hkTemp;

        hkTemp = (HKEY)INVALID_HANDLE_VALUE;
        
        //
        // Delete FriendlyName and DeviceId in name store.
        //

        RegDeleteKey(hkNameStore, m_csFriendlyName);
        if(ERROR_SUCCESS == RegCreateKey(hkNameStore, szFriendlyName, &hkTemp)){
            RegCloseKey(hkTemp);
        } // if(ERROR_SUCCESS == RegCreateKey(hkNameStore, szFriendlyName, &hkTemp))
        RegCloseKey(hkNameStore);
    } // if(ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))

    //
    // Set PortName.
    //

    m_csFriendlyName = szFriendlyName;

} // CDevice::SetPort()

VOID
CDevice::SetDevnodeSelectCallback(
    DEVNODESELCALLBACK  pfnDevnodeSelCallback
    )
{
    DebugTrace(TRACE_STATUS,(("CDevice::SetDevnodeSelectCallback: Current PortselCallback=0x%x\n"), pfnDevnodeSelCallback));

    //
    // Set SetPortselCallBack.
    //

    m_pfnDevnodeSelCallback = pfnDevnodeSelCallback;

    //
    // This is "interface-only" device.
    //

    m_bInterfaceOnly        = TRUE;

} // CDevice::SetDevnodeSelectCallback()

BOOL
CDevice::CreateDeviceInterfaceAndInstall(
    VOID
    )
{
    BOOL                                bRet;
    HKEY                                hkDrv;
    GUID                                Guid;
    HDEVINFO                            hDevInfo;
    SP_DEVINFO_DATA                     spDevInfoData;
    SP_DEVICE_INTERFACE_DATA            spDevInterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pspDevInterfaceDetailData;
    HINF                                hInf;
    BOOL                                bUseDefaultDevInfoSet;
    DWORD                               dwRequiredSize;

    DebugTrace(TRACE_PROC_ENTER,(("CDevice::CreateDeviceInterfaceAndInstall: Enter....\r\n")));

    //
    // Initialize local.
    //

    bRet                        = FALSE;
    hInf                        = INVALID_HANDLE_VALUE;
    hDevInfo                    = INVALID_HANDLE_VALUE;
    Guid                        = GUID_DEVCLASS_IMAGE;
    bUseDefaultDevInfoSet       = TRUE;
    dwRequiredSize              = 0;
    pspDevInterfaceDetailData   = NULL;

    //
    // Get devnode to create interface on.
    //

    if(NULL != m_pfnDevnodeSelCallback){
        if( (FALSE == m_pfnDevnodeSelCallback(m_csPort, &hDevInfo, &spDevInfoData))
         || (INVALID_HANDLE_VALUE == hDevInfo) )
        {
            DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: m_pfnDevnodeSelCallback failed. Err=0x%x.\r\n"),GetLastError()));

            bRet = FALSE;
            goto CreateDeviceInterfaceAndInstall_return;
        }

        //
        // Devnode selector functions.
        //

        bUseDefaultDevInfoSet = FALSE;

    } else { // if(NULL != m_pfnDevnodeSelCallback)

        //
        // Use default device info set if available.
        //

        if( (INVALID_HANDLE_VALUE == m_hDevInfo)
         || (NULL == m_pspDevInfoData) )
        {
            DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: Invalid Device info and no m_pfnDevnodeSelCallback.\r\n")));

            bRet = FALSE;
            goto CreateDeviceInterfaceAndInstall_return;
        } else {
            hDevInfo = m_hDevInfo;
            spDevInfoData = *m_pspDevInfoData;
        }
    } // if(NULL != m_pfnDevnodeSelCallback)

    //
    // Create Interface (SoftDevice). Use FriendlyName ad ref-string.
    //

    DebugTrace(TRACE_STATUS,(("CDevice::CreateDeviceInterfaceAndInstall: Creating interface for %ws.\r\n"), (LPTSTR)m_csFriendlyName));

    spDevInterfaceData.cbSize = sizeof(spDevInterfaceData);
    if(!SetupDiCreateDeviceInterface(hDevInfo,
                                     &spDevInfoData,
                                     &Guid,
                                     m_csFriendlyName,
                                     0,
                                     &spDevInterfaceData))
    {
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupDiCreateInterface failed. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    }

    //
    // Get symbolic link of created interface.
    //

    SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                    &spDevInterfaceData,
                                    NULL,
                                    0,
                                    &dwRequiredSize,
                                    NULL);
    if(0 == dwRequiredSize){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: Unable to get required size for InterfaceDetailedData. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(0 == dwRequiredSize)

    pspDevInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)new BYTE[dwRequiredSize];
    if(NULL == pspDevInterfaceDetailData){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: Unable to allocate buffer.\r\n")));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(NULL == pspDevInterfaceDetailData)

    pspDevInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
    if(!SetupDiGetDeviceInterfaceDetail(hDevInfo,
                                        &spDevInterfaceData,
                                        pspDevInterfaceDetailData,
                                        dwRequiredSize,
                                        &dwRequiredSize,
                                        NULL))
    {
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupDiGetDeviceInterfaceDetail() failed. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;

    } // if(!SetupDiGetDeviceInterfaceDetail(

    m_csSymbolicLink = pspDevInterfaceDetailData->DevicePath;

    //
    // Open INF file handle for registry creation.
    //

    hInf = SetupOpenInfFile(m_csInf,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if(INVALID_HANDLE_VALUE == hInf){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupOpenInfFile failed. Err=0x%x.\r\n"),GetLastError()));

        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(INVALID_HANDLE_VALUE == hInf)

     if(!SetupOpenAppendInfFile(NULL, hInf, NULL)){
        DebugTrace(TRACE_WARNING,(("CDevice::CreateDeviceInterfaceAndInstall: SetupOpenAppendInfFile() failed. Err=0x%x.\r\n"),GetLastError()));
     } // if(!SetupOpenAppendInfFile(NULL, hInf, NULL))

    //
    // Create Interface Registry and keep its handle, it's hard to find it later.
    //

    m_hkInterfaceRegistry = SetupDiCreateDeviceInterfaceRegKey(hDevInfo,
                                                               &spDevInterfaceData,
                                                               0,
                                                               KEY_ALL_ACCESS,
//                                                               NULL,
//                                                               NULL);
                                                               hInf,
                                                               (LPCTSTR)m_csInstallSection);
    if(INVALID_HANDLE_VALUE == m_hkInterfaceRegistry){
        DebugTrace(TRACE_ERROR,(("CDevice::CreateDeviceInterfaceAndInstall: SetupDiCreateDeviceInterfaceRegKey failed. Err=0x%x.\r\n"),GetLastError()));
        bRet = FALSE;
        goto CreateDeviceInterfaceAndInstall_return;
    } // if(INVALID_HANDLE_VALUE == m_hkInterfaceRegistry)

    //
    // Operation succeeded.
    //

    bRet = TRUE;

CreateDeviceInterfaceAndInstall_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDevInfo){
        if(FALSE == bUseDefaultDevInfoSet){

            //
            // Destroy created DevInfoSet.
            //

            SetupDiDestroyDeviceInfoList(hDevInfo);
        } // if(FALSE == bUseDefaultDevInfoSet)
    } // if(INVALID_HANDLE_VALUE != hDevInfo)

    if(INVALID_HANDLE_VALUE != hInf){
        SetupCloseInfFile(hInf);
    } // if(INVALID_HANDLE_VALUE != hInf)

    if(NULL != pspDevInterfaceDetailData){
        delete[] pspDevInterfaceDetailData;
    } // if(NULL != pspDevInterfaceDetailData)

    DebugTrace(TRACE_PROC_LEAVE,(("CDevice::CreateDeviceInterfaceAndInstall: Leaving... Ret=0x%x.\r\n"), bRet));

    return bRet;
} // CDevice::CreateDeviceInterfaceAndInstall()

DWORD
CDevice::GetPortSelectMode(
    VOID
    )
{
    DWORD    dwRet;
    
    //
    // Initialize local.
    //

    dwRet    = PORTSELMODE_NORMAL;
    
    //
    // Make sure INF is processed.
    //

    if(!PreprocessInf()){
        DebugTrace(TRACE_ERROR,(("CDevice::GetPortSelectMode: ERROR!! Unable to process INF.\r\n")));

        dwRet = PORTSELMODE_NORMAL;
        goto GetPortSelectMode_return;
    }

    //
    // If "PortSelect" is empty, use default.
    //

    if(m_csPortSelect.IsEmpty()){
        dwRet = PORTSELMODE_NORMAL;
        goto GetPortSelectMode_return;
    } // if(m_csPortSelect.IsEmpty())

    //
    // See if "PortSelect" directive is "no".
    //

    if(0 == MyStrCmpi(m_csPortSelect, NO)){

        //
        // Port Selection page should be skipped.
        //
        
        dwRet = PORTSELMODE_SKIP;
    } else if(0 == MyStrCmpi(m_csPortSelect, MESSAGE1)){

        //
        // System supplied message should be shown.
        //

        dwRet = PORTSELMODE_MESSAGE1;
    } else {

        //
        // Unsupported PortSel option.
        //
        
        dwRet = PORTSELMODE_NORMAL;
    }

GetPortSelectMode_return:

    return dwRet;
} // CDevice::GetPortSelectMode()

DWORD
CDevice::AcquireInstallerMutex(
    DWORD   dwTimeout
    )
{
    DWORD   dwReturn;
    
    //
    // Initialize local.
    //
    
    dwReturn    = ERROR_SUCCESS;
    
    if(NULL != m_hMutex){

        //
        // Mutex is already acquired.
        //
        
        DebugTrace(TRACE_WARNING,("WARNING!! AcquireInstallerMutex: Mutex acquired twice.\r\n"));
        dwReturn = ERROR_SUCCESS;
        goto AcquireInstallerMutex_return;

    } // if(INVALID_HANDLE_VALUE != m_hMutex)

    //
    // Acquire Mutex.
    //

    m_hMutex = CreateMutex(NULL, FALSE, WIAINSTALLERMUTEX);
    dwReturn = GetLastError();

    if(NULL == m_hMutex){

        //
        // CreteMutex() failed.
        //

        DebugTrace(TRACE_ERROR,("ERROR!! AcquireInstallerMutex: CraeteMutex() failed. Err=0x%x.\r\n", dwReturn));
        goto AcquireInstallerMutex_return;

    } // if(NULL == hMutex)

    //
    // Wait until ownership is acquired.
    //

    dwReturn = WaitForSingleObject(m_hMutex, dwTimeout);
    switch(dwReturn){
        case WAIT_ABANDONED:
            DebugTrace(TRACE_ERROR, ("CDevice::AcquireInstallerMutex: ERROR!! Wait abandoned.\r\n"));
            break;

        case WAIT_OBJECT_0:
            DebugTrace(TRACE_STATUS, ("CDevice::AcquireInstallerMutex: Mutex acquired.\r\n"));
            dwReturn = ERROR_SUCCESS;
            break;

        case WAIT_TIMEOUT:
            DebugTrace(TRACE_WARNING, ("CDevice::AcquireInstallerMutex: WARNING!! Mutex acquisition timeout.\r\n"));
            break;

        default:
            DebugTrace(TRACE_ERROR, ("CDevice::AcquireInstallerMutex: ERROR!! Unexpected error from WaitForSingleObjecct(). Err=0x%x.\r\n", dwReturn));
            break;
    } // switch(dwReturn)

AcquireInstallerMutex_return:

    DebugTrace(TRACE_PROC_LEAVE,("CDevice::AcquireInstallerMutex: Leaving... Ret=0x%x\n", dwReturn));
    return  dwReturn;

} // CDevice::AcquireInstallerMutex()

VOID
CDevice::ReleaseInstallerMutex(
    )
{
    if(NULL != m_hMutex){

        if(!ReleaseMutex(m_hMutex)){
            DebugTrace(TRACE_ERROR, ("CDevice::ReleaseInstallerMutex: ERROR!! Releasing mutex which not owned..\r\n"));
        } // if(!ReleaseMutex(m_hMutex))

        CloseHandle(m_hMutex);
        m_hMutex = NULL;
        DebugTrace(TRACE_STATUS, ("CDevice::ReleaseInstallerMutex: Mutex released.\r\n"));
    } // if(NULL != m_hMutex)
} // CDevice::ReleaseInstallerMutex()




UINT
CALLBACK
StiInstallCallback (
    PVOID    Context,
    UINT     Notification,
    UINT_PTR Param1,
    UINT_PTR Param2
    )

/*++

Routine Description:

    StiInstallCallback

    Callback routine used when calling SetupAPI file copying/installation functions

Arguments:

    Context -  our context
    Notification - notification message

Return Value:

    SetupAPI return code

Side effects:

    None

--*/
{

    UINT        uRet = FILEOP_COPY;

    DebugTrace(TRACE_PROC_ENTER,(("StiInstallCallback: Enter... \r\n")));

    //
    // Initialize local.
    //

    uRet = FILEOP_COPY;

    //
    // Dispatch notification code.
    //

    switch(Notification){

        case SPFILENOTIFY_ENDCOPY:
        {
            PFILEPATHS   pFilePathInfo;
            HKEY        hKey;
            DWORD       dwDisposition;
            DWORD       dwRefCount;
            DWORD       dwType;
            UINT        uSize;
            LONG        Status;

            uSize = sizeof(dwRefCount);
            pFilePathInfo = (PFILEPATHS)Param1;

            DebugTrace(TRACE_STATUS,(("StiInstallCallback:ENDCOPY FileTarget  %ws\r\n"), pFilePathInfo->Target));

            //
            // Open HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\SharedDlls
            //

            Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                    REGSTR_PATH_SHAREDDLL,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    &dwDisposition);
            if(ERROR_SUCCESS != Status)
            {
                DebugTrace(TRACE_ERROR,(("StiInstallCallback: RegCreateKeyEx failed. Err=0x%x\r\n"), Status));
                break;
            }

            //
            // Retrieve reference count of this file
            //

            Status = RegQueryValueEx(hKey,
                                     pFilePathInfo->Target,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)&dwRefCount,
                                     (LPDWORD)&uSize);
            if(ERROR_SUCCESS != Status)
            {
                //
                // Value for this file hasn't been created, or error
                //

                DebugTrace(TRACE_ERROR,(("StiInstallCallback: Value for Ref-count doesn't exist\r\n")));
                dwRefCount = 0;
            }

            //
            // Increment reference count and set value
            //

            dwRefCount++;
            uSize = sizeof(dwRefCount);
            Status = RegSetValueEx(hKey,
                                   pFilePathInfo->Target,
                                   NULL,
                                   REG_DWORD,
                                   (CONST BYTE *)&dwRefCount,
                                   uSize);
            if(ERROR_SUCCESS != Status)
            {
                DebugTrace(TRACE_ERROR,(("StiInstallCallback: RegSetValueEx. Err=0x%x.\r\n"), Status));
            }

            DebugTrace(TRACE_STATUS,(("StiInstallCallback: ref-count of %ws is now 0x%x.\r\n"), pFilePathInfo->Target, dwRefCount));

            //
            // Close Registry key
            //

            RegCloseKey(hKey);

            Report(( TEXT("StiInstallCallback:%ws copied.\r\n"), pFilePathInfo->Target));
        } // case SPFILENOTIFY_ENDCOPY

        default:
            ;
    }

    uRet = SetupDefaultQueueCallback(Context,
                                    Notification,
                                    Param1,
                                    Param2);

    DebugTrace(TRACE_PROC_LEAVE,(("StiInstallCallback: Leaving... Ret=0x%x\n"), uRet));
    return uRet;
}

VOID
GetDeviceCount(
    DWORD   *pdwWiaCount,
    DWORD   *pdwStiCount
    )
/*++

Routine Description:

    GetDeviceCount

    Verifes if there is at least one STI device installed in a system

Arguments:

    bWia    - TRUE: Count WIA device

Return Value:

    Number of WIA device
    FALSE

--*/
{
    DWORD                       dwWiaCount;
    DWORD                       dwStiCount;
    BOOL                        fRet;
    CString                     csSubClass;
    DWORD                       dwCapabilities;
    GUID                        Guid;
    UINT                        Idx;
    DWORD                       dwRequired;
    DWORD                       dwError;
    HKEY                        hkThis;
    HKEY                        hkRun;
    HANDLE                      hDevInfo;
    SP_DEVINFO_DATA             spDevInfoData;
    SP_DEVICE_INTERFACE_DATA    spDevInterfaceData;

    DebugTrace(TRACE_PROC_ENTER,(("GetDeviceCount: Enter... \r\n")));

    //
    // Initialize local.
    //

    dwWiaCount      = 0;
    dwStiCount      = 0;
    fRet            = FALSE;
    Idx             = 0;
    dwRequired      = 0;
    dwError         = 0;
    hkThis          = NULL;
    hkRun           = NULL;
    hDevInfo        = NULL;
    dwCapabilities  = 0;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&spDevInterfaceData, 0, sizeof(spDevInterfaceData));

    //
    // Get WIA class guid.
    //

    SetupDiClassGuidsFromName (CLASSNAME, &Guid, sizeof(GUID), &dwRequired);

    //
    // Get device info set of all WIA devices (devnode).
    //

    hDevInfo = SetupDiGetClassDevs (&Guid,
                                    NULL,
                                    NULL,
                                    DIGCF_PROFILE
                                    );

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

        for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

           #if DEBUG
           CHAR   szDevDriver[STI_MAX_INTERNAL_NAME_LENGTH];
           ULONG       cbData;

           fRet = SetupDiGetDeviceRegistryProperty (hDevInfo,
                                                    &spDevInfoData,
                                                    SPDRP_DRIVER,
                                                    NULL,
                                                    (UCHAR *)szDevDriver, sizeof (szDevDriver),
                                                   &cbData);
            DebugTrace(TRACE_STATUS,(("GetDeviceCount: Checking device No%d(%ws)\r\n"), Idx, szDevDriver));
           #endif

           //
           // Verify device is not being removed
           //
           spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
           spDevInterfaceData.InterfaceClassGuid = GUID_DEVCLASS_IMAGE;

           fRet = SetupDiEnumDeviceInterfaces (hDevInfo,
                                               NULL,
                                               &Guid,
                                               Idx,
                                               &spDevInterfaceData);

           dwError = GetLastError();

           if (fRet) {
               if (spDevInterfaceData.Flags & SPINT_REMOVED) {
                   continue;
               }
           }

            hkThis = SetupDiOpenDevRegKey(hDevInfo,
                                          &spDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ );

            if (hkThis != INVALID_HANDLE_VALUE) {

                csSubClass.Load(hkThis, SUBCLASS);
                GetDwordFromRegistry(hkThis, CAPABILITIES, &dwCapabilities);

DebugTrace(TRACE_STATUS,(("GetDeviceCount: Capabilities=0x%x\n"), dwCapabilities));


                RegCloseKey(hkThis);

                if( (!csSubClass.IsEmpty())
                 && (0 == MyStrCmpi(csSubClass, STILL_IMAGE)) )
                {

                    //
                    // STI device found. Increse the counter.
                    //

                    dwStiCount++;

                    if(dwCapabilities & STI_GENCAP_WIA){

                        //
                        // WIA device found.
                        //

                            dwWiaCount++;

                    } // if(dwCapabilities & STI_GENCAP_WIA){

                } // if (!csSubClass.IsEmpty() && !lstrcmpi(csSubClass, STILL_IMAGE))
            } // if (hkThis != INVALID_HANDLE_VALUE)
        } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

        SetupDiDestroyDeviceInfoList(hDevInfo);
    } else {
        DebugTrace(TRACE_ERROR,(("GetDeviceCount: ERROR!! Unable to get device info set.\r\n")));
    } // if (hDevInfo != INVALID_HANDLE_VALUE)


    //
    // Get device info set of all WIA devices (interface).
    //

    hDevInfo = SetupDiGetClassDevs (&Guid,
                                    NULL,
                                    NULL,
                                    DIGCF_PROFILE |
                                    DIGCF_DEVICEINTERFACE
                                    );

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        spDevInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        for (Idx = 0; SetupDiEnumDeviceInterfaces (hDevInfo, NULL, &Guid, Idx, &spDevInterfaceData); Idx++) {

            DebugTrace(TRACE_STATUS,(("GetDeviceCount: Checking interface No%d.\r\n"), Idx));

            //
            // Verify device is not being removed
            //

            if (spDevInterfaceData.Flags & SPINT_REMOVED) {
                continue;
            }

            hkThis = SetupDiOpenDeviceInterfaceRegKey(hDevInfo,
                                                      &spDevInterfaceData,
                                                      0,
                                                      KEY_READ );

            if (hkThis != INVALID_HANDLE_VALUE) {
                csSubClass.Load(hkThis, SUBCLASS);
                GetDwordFromRegistry(hkThis, CAPABILITIES, &dwCapabilities);
                RegCloseKey(hkThis);

                if( (!csSubClass.IsEmpty())
                 && (0 == MyStrCmpi(csSubClass, STILL_IMAGE)) )
                {

                    //
                    // STI device found. Increse the counter.
                    //

                    dwStiCount++;

                    if(dwCapabilities & STI_GENCAP_WIA){

                        //
                        // WIA device found.
                        //

                            dwWiaCount++;

                    } // if(dwCapabilities & STI_GENCAP_WIA){
                } // if (!csSubClass.IsEmpty() && !lstrcmpi(csSubClass, STILL_IMAGE))
            } // if (hkThis != INVALID_HANDLE_VALUE)
        } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)

        SetupDiDestroyDeviceInfoList(hDevInfo);
    } else { // if (hDevInfo != INVALID_HANDLE_VALUE)
        DebugTrace(TRACE_ERROR,(("GetDeviceCount: ERROR!! Unable to get device info set.\r\n")));
    } // if (hDevInfo != INVALID_HANDLE_VALUE)

    //
    // Copy the result.
    //

    *pdwWiaCount = dwWiaCount;
    *pdwStiCount = dwStiCount;

    DebugTrace(TRACE_PROC_LEAVE,(("GetDeviceCount: Leaving... STI=0x%x, WIA=0x%x.\r\n"), dwStiCount, dwWiaCount));
    return;
} // GetDeviceCount()



BOOL
ExecCommandLine(
    LPTSTR  szCommandLine
    )
{
    BOOL                bRet;
    CString             csCommandLine;
    PROCESS_INFORMATION pi;
    STARTUPINFO         si  = {
                   sizeof(si),              // cb
                   NULL,                    // lpReserved;
                   NULL,                    // lpDesktop;
                   NULL,                    // lpTitle;
                   0,                       // dwX;
                   0,                       // dwY;
                   0,                       // dwXSize;
                   0,                       // dwYSize;
                   0,                       // dwXCountChars;
                   0,                       // dwYCountChars;
                   0,                       // dwFillAttribute;
                   STARTF_FORCEONFEEDBACK,  // dwFlags;
                   SW_SHOWNORMAL,           // wShowWindow;
                   0,                       // cbReserved2;
                   NULL,                    // lpReserved2;
                   NULL,                    // hStdInput;
                   NULL,                    // hStdOutput;
                   NULL                     // hStdError;
                   };

    csCommandLine = szCommandLine;
    bRet = CreateProcess(NULL,                  // Application name
                         (LPTSTR)csCommandLine, // Command line
                         NULL,                  // Process attributes
                         NULL,                  // Thread attributes
                         FALSE,                 // Handle inheritance
                         NORMAL_PRIORITY_CLASS, // Creation flags
                         NULL,                  // Environment
                         NULL,                  // Current directory
                         &si,
                         &pi);

    if (bRet) {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    } else {
        DebugTrace(TRACE_ERROR,(("ExecCommandLine: CreateProcess failed. Err=0x%x.\r\n"), GetLastError()));
    }

    return bRet;
}


PPARAM_LIST
MigrateDeviceData(
    HKEY        hkDeviceData,
    PPARAM_LIST pExtraDeviceData,
    LPSTR       pszKeyName
    )
{

    BOOL        bDone;
    PPARAM_LIST pCurrent;
    PPARAM_LIST pReturn;
    DWORD       dwType;
    DWORD       dwSize;
    PCHAR       pOrginalBuffer;
    CHAR        pCopyBuffer[MAX_PATH*3];
    CHAR        pDataBuffer[MAX_PATH];
    DWORD       Idx;

    //
    // Initialize local.
    //

    bDone       = FALSE;
    pCurrent    = pExtraDeviceData;
    pReturn     = NULL;
    
    //
    // Loop until it gets "END".
    //

    while(!bDone){

        if(NULL == pCurrent){
            
            //
            // Hit the end of list.
            //
            
            bDone = TRUE;
            pReturn =NULL;
            continue;

        } // if(NULL == pTemp)
        
        //
        // If "KeyName = END" is found, return.
        //

        if( (CSTR_EQUAL == CompareStringA(LOCALE_INVARIANT,NORM_IGNORECASE, pCurrent->pParam1, -1,pszKeyName,-1))
         && (CSTR_EQUAL == CompareStringA(LOCALE_INVARIANT,NORM_IGNORECASE, pCurrent->pParam2, -1,NAME_END_A,-1)) )
        {
            bDone   = TRUE;
            pReturn = (PPARAM_LIST)pCurrent->pNext;
            continue;
        }

        //
        // If 2nd parameter is "BEGIN", create subkey and call this function recursively.
        //

        if(CSTR_EQUAL == CompareStringA(LOCALE_INVARIANT,NORM_IGNORECASE, pCurrent->pParam2, -1,NAME_BEGIN_A,-1)){
            HKEY    hkSubKey;
            LONG    lError;
            
            lError = RegCreateKeyA(hkDeviceData, pCurrent->pParam1, &hkSubKey);
            if(ERROR_SUCCESS != lError){
                
                //
                // Unable to create subkey.
                //

                DebugTrace(TRACE_ERROR,(("MigrateDeviceData: ERROR!! Unable to create subkey..\r\n")));
                pReturn = NULL;
                goto MigrateDeviceData_return;
            } // if(ERROR_SUCCESS != lError)
            
            pCurrent = MigrateDeviceData(hkSubKey, (PPARAM_LIST)pCurrent->pNext, pCurrent->pParam1);
            RegCloseKey(hkSubKey);
            continue;
        } // if(0 == lstrcmpiA(pCurrent->pParam2, NAME_BEGIN_A))

        //
        // This is a set of value and data.
        //

        lstrcpyA(pCopyBuffer, pCurrent->pParam2);
        pOrginalBuffer = pCopyBuffer;
        
        //
        // Get key type.
        //

        pOrginalBuffer[8] = '\0';
        dwType = DecodeHexA(pOrginalBuffer);

        //
        // Get data.
        //
        
        Idx = 0;
        pOrginalBuffer+=9;

        while('\0' != *pOrginalBuffer){
            if('\0' != pOrginalBuffer[2]){
                pOrginalBuffer[2] = '\0';
                pDataBuffer[Idx++] = (CHAR)DecodeHexA(pOrginalBuffer);
                pOrginalBuffer+=3;
            } else {
                pDataBuffer[Idx++] = (CHAR)DecodeHexA(pOrginalBuffer);
                break;
            }
        } // while('\0' != pCurrent->pParam2[Idx])

        //
        // Create this value.
        //

        RegSetValueExA(hkDeviceData,
                      pCurrent->pParam1,
                      0,
                      dwType,
                      (PBYTE)pDataBuffer,
                      Idx);

        //
        // Process next line.
        //

        pCurrent = (PPARAM_LIST)pCurrent->pNext;

    } // while(!bDone)

MigrateDeviceData_return:
    return pReturn;
} // MigrateDeviceData()


DWORD   
DecodeHexA(
    LPSTR   lpstr
    ) 
{

    DWORD   dwReturn;

    //
    // Initialize local.
    //
    
    dwReturn = 0;

    if(NULL == lpstr){
        dwReturn = 0;
        goto DecodeHexA_return;
    } // if(NULL == lpstr)
    
    //
    // Skip spaces.
    //

    for (LPSTR  lpstrThis = lpstr;
        *lpstrThis && *lpstrThis == TEXT(' ');
        lpstrThis++)
        ;

    while   (*lpstrThis) {
        switch  (*lpstrThis) {
            case    '0':
            case    '1':
            case    '2':
            case    '3':
            case    '4':
            case    '5':
            case    '6':
            case    '7':
            case    '8':
            case    '9':
                dwReturn <<= 4;
                dwReturn += ((*lpstrThis) - '0');
                break;
            case    'a':
            case    'b':
            case    'c':
            case    'd':
            case    'e':
            case    'f':
                dwReturn <<= 4;
                dwReturn += 10 + (*lpstrThis - 'a');
                break;
            case    'A':
            case    'B':
            case    'C':
            case    'D':
            case    'E':
            case    'F':
                dwReturn <<= 4;
                dwReturn += 10 + (*lpstrThis - 'A');
                break;

            default:
                return  dwReturn;
        }
        lpstrThis++;
    } // while   (*lpstrThis) 

DecodeHexA_return:
    return  dwReturn;
} // DWORD   CString::DecodeHex() 

BOOL
IsNameAlreadyStored(
    LPTSTR  szName
    )
{
    BOOL    bRet;
    HKEY    hkNameStore;

    DebugTrace(TRACE_PROC_ENTER,(("IsNameAlreadyStored: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    hkNameStore = (HKEY)INVALID_HANDLE_VALUE;

    //
    // Open name store regkey.
    //

    if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore)){
        HKEY    hkTemp;
        
        hkTemp  = (HKEY)INVALID_HANDLE_VALUE;

        //
        // See if specified name exists in name store.
        //

        if(ERROR_SUCCESS == RegOpenKey(hkNameStore, szName, &hkTemp)){

            //
            // Specified name already exists in name store.
            //
            
            bRet = TRUE;
            RegCloseKey(hkTemp);

        } // if(ERROR_SUCCESS == RegOpenKey(hkNameStore, szName, &hkTemp))

        RegCloseKey(hkNameStore);
        
    } // if(ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_INSTALL_NAMESTORE, &hkNameStore))

// IsNameAlreadyStored_return:
    DebugTrace(TRACE_PROC_LEAVE,(("IsNameAlreadyStored: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
} // IsFriendlyNameUnique()









#if DEAD_CODE

#ifdef USE_STIMON
//
// For the time being always load and start the monitor
//
HKEY hkRun;

if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

    CString csCmdLine;
    csCmdLine.MakeSystemPath(MONITOR_NAME);
    csCmdLine.Store (hkRun, REGSTR_VAL_MONITOR);

    Report(( TEXT("Monitor Command Line %ws\r\n"), (LPCTSTR)csCmdLine));

    // Launch it...
    WinExec(csCmdLine, SW_SHOWNOACTIVATE);
    RegCloseKey(hkRun);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\finalpg.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Finalpg.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Header file for final page of WIA class installer.
*
*******************************************************************************/

#ifndef _FINALPG_H_
#define _FINALPG_H_

//
// Include
//

#include "wizpage.h"
#include "device.h"

//
// Typedef
//

typedef BOOL (CALLBACK FAR * INSTALLSELECTEDDRIVER)(HWND hwndParent, HDEVINFO hDeviceInfo, LPCWSTR DisplayName, BOOL Backup, PDWORD pReboot);

//
// Class
//

class CInstallPage : public CInstallWizardPage {

    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.

public:

    CInstallPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CInstallPage() {}

    virtual BOOL    OnInit();
    virtual BOOL    OnNotify(LPNMHDR lpnmh);
};

#endif // _FINALPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\firstpg.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Firstpg.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   First page of WIA class installer.
*
*******************************************************************************/

#ifndef _FIRSTPG_H_
#define _FIRSTPG_H_

//
// Include
//

#include    "wizpage.h"

//
// Extern
//

extern HINSTANCE g_hDllInstance;

//
// Class
//

class CFirstPage : public CInstallWizardPage 
{

    BOOL        m_bShowThisPage;
    
public:

    CFirstPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CFirstPage() {}

    virtual BOOL    OnInit();
    virtual BOOL    OnNotify(LPNMHDR lpnmh);
};

#endif // _FIRSTPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\finalpg.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Final.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Final page of WIA class installer.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "finalpg.h"

//
// Function
//

CInstallPage::CInstallPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, EmeraldCity)
{

    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = NameTheDevice;
    m_uNextPage     = 0;

    //
    // Initialize member.
    //

    m_pInstallerContext = pInstallerContext;

} // CInstallPage::CInstallPage()

BOOL
CInstallPage::OnInit()
{
    HFONT    hFont;

    //
    // Set font of title.
    //

    hFont = GetIntroFont(m_hwndWizard);

    if( hFont ){
        HWND hwndControl = GetDlgItem(m_hwnd, CompleteMessage);

        if( hwndControl ){
            SetWindowFont(hwndControl, hFont, TRUE);
        } // if( hwndControl )
    } // if( hFont )

    return  TRUE;
}


BOOL
CInstallPage::OnNotify(
    LPNMHDR lpnmh
    )
{

    if (lpnmh->code == PSN_WIZFINISH){

        BOOL    bSucceeded;

        if(NULL == m_pCDevice){
            goto OnNotify_return;
        }
        
        //
        // Register the device element.
        //

        bSucceeded = SetupDiRegisterDeviceInfo(m_pCDevice->m_hDevInfo, 
                                               m_pCDevice->m_pspDevInfoData,
                                               0,
                                               NULL,
                                               NULL,
                                               NULL);
        if(FALSE == bSucceeded){
            DebugTrace(TRACE_ERROR,(("CInstallPage::OnNotify: ERROR!! SetupDiRegisterDeviceInfo() failed. Err=0x%x.\r\n"), GetLastError()));
            goto OnNotify_return;
        } // if(FALSE == bSucceeded)

        //
        // Do device installation.
        //
        
        {

            INSTALLSELECTEDDRIVER   pfnInstallSelectedDriver;
            HMODULE                 hNewDevDll;
            DWORD                   dwReboot;
            
            //
            // Device/Driver must be selected at this point.
            //

            //
            // Load newdev.dll
            //
            
            hNewDevDll = LoadLibrary(NEWDEVDLL);
            if(NULL != hNewDevDll){

                pfnInstallSelectedDriver = (INSTALLSELECTEDDRIVER)GetProcAddress(hNewDevDll, "InstallSelectedDriver");
                if(NULL != pfnInstallSelectedDriver){
                    
                    //
                    // Call install function in newdev.dll
                    //
                    
                    dwReboot = 0;
                    bSucceeded = pfnInstallSelectedDriver(NULL, m_pCDevice->m_hDevInfo, NULL, TRUE, NULL);

                } else { // if(NULL != pfnInstallSelectedDriver)
                    DebugTrace(TRACE_ERROR,(("CInstallPage::OnNotify: ERROR!! Unable to get the address of InstallSelectedDriver. Err=0x%x.\r\n"), GetLastError()));
                    FreeLibrary(hNewDevDll);
                    goto OnNotify_return;
                } // if(NULL == pfnInstallSelectedDriver)
            
                FreeLibrary(hNewDevDll);

            } else { 
                DebugTrace(TRACE_ERROR,(("CInstallPage::OnNotify: ERROR!! Unable to load newdev.dll. Err=0x%x.\r\n"), GetLastError()));
                goto OnNotify_return;
            } // if(NULL == hNewDevDll)
        }

        //
        // Do post-installation if succeeded, to make sure about the portname and FriendlyName.
        //

        if(bSucceeded){
            m_pCDevice->PostInstall(TRUE);
        }

        //
        // Free device object anyway.
        //

        delete m_pCDevice;
        m_pCDevice = NULL;
        m_pInstallerContext->pDevice = NULL;

    } // if (lpnmh->code == PSN_WIZFINISH)

    if (lpnmh->code == PSN_SETACTIVE){

        //
        // Get CDevice object from context.
        //

        m_pCDevice = (CDevice *)m_pInstallerContext->pDevice;
    } // if (lpnmh->code == PSN_SETACTIVE)

OnNotify_return:
    return  FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\firstpg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Firstpg.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   First page of WIA class installer.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "firstpg.h"


//
// Function
//

CFirstPage::CFirstPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, IDD_DYNAWIZ_FIRSTPAGE)
{

    //
    // Set link to previous/next page.
    //

    m_uPreviousPage = 0;
    m_uNextPage     = IDD_DYNAWIZ_SELECTDEV_PAGE;

    //
    // See if this page shuld be skipped.
    //

    m_bShowThisPage = pInstallerContext->bShowFirstPage;

}


BOOL
CFirstPage::OnInit()
{
    HFONT   hFont;
    HICON   hIcon;

    //
    // Initialize locals.
    //

    hFont   = NULL;
    hIcon   = NULL;

    //
    // Change icon if it's invoked from S&C folder.
    //

    if(m_bShowThisPage){
        hIcon = ::LoadIcon(g_hDllInstance, MAKEINTRESOURCE(ImageIcon));
        if(NULL != hIcon){
            SendMessage(m_hwndWizard, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
            SendMessage(m_hwndWizard, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        } // if(NULL != hIcon)
    } // if(m_bShowThisPage)

    //
    // Enable "NEXT" button, disable "Back" button.
    //

    SendMessage(m_hwndWizard, PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);

    //
    // Set font of title.
    //

    hFont = GetIntroFont(m_hwndWizard);

    if( hFont ){
        HWND hwndControl = GetDlgItem(m_hwnd, WelcomeMessage);

        if( hwndControl ){
            SetWindowFont(hwndControl, hFont, TRUE);
        } // if( hwndControl )
    } // if( hFont )

    return  TRUE;
}

//
//  This page is a NOP...return -1 to activate the Next or Previous page.
//

BOOL
CFirstPage::OnNotify(
    LPNMHDR lpnmh
    )
{

    if (lpnmh->code == PSN_SETACTIVE) {

        TCHAR   szTitle[MAX_PATH] = {TEXT('\0')};

        //
        // Set Window title.
        //

        if(0 != ::LoadString(g_hDllInstance, MessageTitle, szTitle, MAX_PATH)){
            PropSheet_SetTitle(m_hwndWizard ,0 , szTitle);
        } // if(0 != ::LoadString(m_DllHandle, 0, szTitle, MAX_PATH)

        if(!m_bShowThisPage){

                //
                // Jump to device seleciton page.
                //

                SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, IDD_DYNAWIZ_SELECTDEV_PAGE);
                return TRUE;

        } // if(!m_bShowThisPage)
    } // if (lpnmh->code == PSN_SETACTIVE)

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\nameit.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Nameit.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Header file for a page to name a device.
*
*******************************************************************************/

#ifndef _NAMEIT_H_
#define _NAMEIT_H_

//
// Include
//

#include    "wizpage.h"
#include    "device.h"

//
// Class
//

class CNameDevicePage : public CInstallWizardPage {

    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.

    public:

    CNameDevicePage(PINSTALLER_CONTEXT pInstallerContext);
    ~CNameDevicePage();

    virtual BOOL    OnNotify(LPNMHDR lpnmh);
};

#endif // _NAMEIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\nameit.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Nameit.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Device naming page of WIA class installer.
*
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "nameit.h"

//
// Function
//

CNameDevicePage::CNameDevicePage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, NameTheDevice)
{

    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = IDD_DYNAWIZ_SELECT_NEXTPAGE;
    m_uNextPage     = EmeraldCity;

    //
    // Initialize member.
    //

    m_pInstallerContext = pInstallerContext;

}

CNameDevicePage::~CNameDevicePage() {

} // CNameDevicePage()


BOOL
CNameDevicePage::OnNotify(
    LPNMHDR lpnmh
    )
{
    BOOL    bRet;
    DWORD   dwMessageId;

    DebugTrace(TRACE_PROC_ENTER,(("CNameDevicePage::OnNotify: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet        = FALSE;
    dwMessageId = 0;

    //
    // Dispatch message.
    //

    switch(lpnmh->code){

        case PSN_KILLACTIVE:
        {
            CString csFriendlyName;

            DebugTrace(TRACE_STATUS,(("CNameDevicePage::OnNotify: PSN_KILLACTIVE.\r\n")));

            //
            // Dialog is about to disappear. Set FriendlyName.
            //

            if(NULL == m_pCDevice){
                DebugTrace(TRACE_WARNING,(("CNameDevicePage::OnNotify: WARNING!! CDevice doesn't exist.\r\n")));

                bRet = FALSE;
                goto OnNotify_return;
            }

            //
            // Get FriendlyName from text box.
            //

            csFriendlyName.GetContents(GetDlgItem(m_hwnd, DeviceFriendlyName));

            //
            // Check the FriendlyName only when user push 'NEXT'.
            //

            if(m_bNextButtonPushed){

                DWORD   dwLength;

                //
                // Check length.
                //

                dwLength = lstrlen((LPCTSTR)csFriendlyName);

                if(0 == dwLength){
                    dwMessageId = NoDeviceName;
                }

                if(dwLength > MAX_FRIENDLYNAME){
                    dwMessageId = DeviceNameTooLong;
                }

                //
                // Check if it's unique.
                //

                if(!csFriendlyName.IsEmpty()){

                    //
                    // Acquire mutex to access name store.
                    //

                    if(ERROR_SUCCESS != m_pCDevice->AcquireInstallerMutex(MAX_MUTEXTIMEOUT)){  // it must be done at least in 60 sec.
                        DebugTrace(TRACE_ERROR,("CNameDevicePage::OnNotify: ERROR!! Unable to acquire mutex in 60 sec.\r\n"));
                    } // if(ERROR_SUCCESS != AcquireInstallerMutex(60000))

                    //
                    // Refresh current device list.
                    //
                    
                    m_pCDevice->CollectNames();
                    
                    //
                    // See if Friendly is unique.
                    //

                    if(!(m_pCDevice->IsFriendlyNameUnique((LPTSTR)csFriendlyName))){
                        dwMessageId = DuplicateDeviceName;
                    } // if(!(m_pCDevice->IsFriendlyNameUnique((LPTSTR)csFriendlyName)))

                } // if(!csFriendlyName.IsEmpty())

                //
                // If FriendlyName is invalid, show error MessageBox.
                //

                if(0 != dwMessageId){

                    //
                    // Select text box.
                    //

                    SendDlgItemMessage(m_hwnd,
                                       DeviceFriendlyName,
                                       EM_SETSEL,
                                       0,
                                       MAKELPARAM(0, -1));
                    SetFocus(GetDlgItem(m_hwnd, DeviceFriendlyName));

                    //
                    // Show error message box.
                    //

                    ShowInstallerMessage(dwMessageId);

                    //
                    // Don't leave this page.
                    //

                    SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, TRUE);
                    bRet = TRUE;
                    goto OnNotify_return;
                } else { // if(0 != dwMessageId)

                    //
                    // Set FriendlyName.
                    //

                    m_pCDevice->SetFriendlyName((LPTSTR)csFriendlyName);
                } //  // if(0 != dwMessageId)
            } //  else (m_bNextButtonPushed)

            //
            // Release mutex.
            //

            m_pCDevice->ReleaseInstallerMutex();

            //
            // Reset pCDevice. 
            //

            m_pCDevice = NULL;

            bRet = TRUE;
            goto OnNotify_return;
        } // case PSN_KILLACTIVE

        case PSN_SETACTIVE:
        {
            DebugTrace(TRACE_STATUS,(("CNameDevicePage::OnNotify: PSN_SETACTIVE.\r\n")));

            //
            // Get current CDevice object;
            //

            m_pCDevice = (CDevice *)m_pInstallerContext->pDevice;
            if(NULL == m_pCDevice){
                DebugTrace(TRACE_ERROR, (("CNameDevicePage::OnNotify: ERROR!! CDevice is not created.\r\n")));
            }

            //
            // Show current friendly name.
            //

            SetDlgItemText(m_hwnd, DeviceFriendlyName, m_pCDevice->GetFriendlyName());

            //
            // Limit the text upto MAX_FRIENDLYNAME. (=64)
            //

            SendDlgItemMessage(m_hwnd, DeviceFriendlyName, EM_LIMITTEXT, MAX_FRIENDLYNAME, 0);

            //
            // If "PortSelect = no", then set previous page to device selection page.
            //
            
            if(PORTSELMODE_NORMAL != m_pCDevice->GetPortSelectMode())
            {
                m_uPreviousPage = IDD_DYNAWIZ_SELECTDEV_PAGE;
            } else {
                m_uPreviousPage = IDD_DYNAWIZ_SELECT_NEXTPAGE;
            }

            goto OnNotify_return;
        } // case PSN_SETACTIVE:
    } // switch(lpnmh->code)

OnNotify_return:

    //
    // Release mutex. ReleaseInstallerMutex() will handle invalid handle also, so we can call anyway.
    //

    if(NULL != m_pCDevice){
        m_pCDevice->ReleaseInstallerMutex();
    } // if(NULL != m_pCDevice)

    DebugTrace(TRACE_PROC_LEAVE,(("CNameDevicePage::OnNotify: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CNameDevicePage::OnNotify()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\portsel.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Portsel.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   port selection page of WIA class installer.
*
*   1. Create CDevice object of selected device.
*   2. Process INF of selected device thru CDevice.
*   3. Get all Port's CreatFile name and Friendly name, store locally.
*   4. Handle Port selection UI and set CreateFile name thru CDevice.
*   5. Delele CDevice object if user re-select another device.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "portsel.h"
#include <sti.h>
#include <setupapi.h>

//
// Extern
//

extern HINSTANCE    g_hDllInstance;

//
// Function
//

CPortSelectPage::CPortSelectPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, IDD_DYNAWIZ_SELECT_NEXTPAGE)
{
    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = IDD_DYNAWIZ_SELECTDEV_PAGE;
    m_uNextPage     = NameTheDevice;

    //
    // Initialize member.
    //

    m_hDevInfo          = pInstallerContext->hDevInfo;
    m_pspDevInfoData    = &(pInstallerContext->spDevInfoData);
    m_pInstallerContext = pInstallerContext;

    m_bPortEnumerated   = FALSE;
    m_dwNumberOfPort    = 0;

    m_dwCapabilities    = 0;
    m_csConnection      = BOTH;

}

CPortSelectPage::~CPortSelectPage()
{

} // CPortSelectPage::CPortSelectPage(PINSTALLER_CONTEXT pInstallerContext)

BOOL
CPortSelectPage::OnCommand(
    WORD wItem,
    WORD wNotifyCode,
    HWND hwndItem
    )
{

    LRESULT                 lResult;
    BOOL                    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::OnCommand: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;
    lResult = 0;

    //
    // Dispatch message.
    //

    switch (wNotifyCode) {

        case LBN_SELCHANGE: {

            int ItemData = (int) SendMessage(hwndItem, LB_GETCURSEL, 0, 0);

            //
            // Check the existance of CDevice.
            //

            if(NULL == m_pCDevice){
                DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnCommand: CDevice doesn't exist yet.\r\n")));

                bRet = TRUE;
                goto OnCommand_return;
            }

            if (ItemData >= 0) {

                LONG    lPortIndex;

                lPortIndex = (LONG)SendMessage(hwndItem, LB_GETITEMDATA, ItemData, 0);

                if(ID_AUTO == lPortIndex){

                    //
                    // This is "AUTO" port.
                    //

                    m_pCDevice->SetPort(AUTO);
                    DebugTrace(TRACE_STATUS,(("CPortSelectPage::OnCommand: Setting portname to %ws.\r\n"), AUTO));

                } else if (lPortIndex >= 0 ) {

                    //
                    // Set port name.
                    //

                    m_pCDevice->SetPort(m_csaPortName[lPortIndex]);
                    DebugTrace(TRACE_STATUS,(("CPortSelectPage::OnCommand: Setting portname to %ws.\r\n"), m_csaPortName[lPortIndex]));

                } else { // if (lPortIndex >= 0 )

                    //
                    // Shouldn't come here, id < -1. Use AUTO.
                    //

                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnCommand: Got improper id(0x%x). Use AUTO.\r\n"), lPortIndex));
                    m_pCDevice->SetPort(AUTO);
                } // if (lPortIndex >= 0 )

                bRet = TRUE;
                goto OnCommand_return;

            } // if (ItemData >= 0)
        } // case LBN_SELCHANGE:
    } // switch (wNotifyCode)

OnCommand_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::OnCommand: Leaving... Ret=0x%x.\r\n"), bRet));
    return  bRet;

}

BOOL
CPortSelectPage::OnNotify(
    LPNMHDR lpnmh
    )
{
    DWORD                   Idx;
    DWORD                   dwPortSelectMode;
    BOOL                    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::OnNotify: Enter... \r\n")));

    //
    // Initialize locals.
    //

    Idx                 = 0;
    dwPortSelectMode    = 0;
    bRet                = FALSE;

    if (lpnmh->code == PSN_SETACTIVE) {

        DebugTrace(TRACE_STATUS,(("CPortSelectPage::OnNotify: PSN_SETACTIVE.\r\n")));

        //
        // Create CDevice object.
        //

        if(!CreateCDeviceObject()){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to create CDeviceobject.\r\n")));

            bRet = FALSE;
            goto OnNotify_return;
        }

        //
        // See if need to show port selection page.
        //

        dwPortSelectMode = m_pCDevice->GetPortSelectMode();
        switch(dwPortSelectMode){

            case PORTSELMODE_NORMAL:
            {
                //
                // Set proper message.
                //

                if(!SetDialogText(PortSelectMessage0)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to set dialog text.\r\n")));
                } // if(!SetDialogText(PortSelectMessage0)
                    

                //
                // Make all cotrol visible.
                //

                if(!ShowControl(TRUE)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Port listbox can't be visible.\r\n")));
                } // ShowControl(TRUE)

                //
                // Enumerate all Ports.
                //

                if(!EnumPort()){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to enumerate ports.\r\n")));

                    bRet = FALSE;
                    goto OnNotify_return;
                }

                //
                // Update port list.
                //

                UpdatePortList();

                //
                // Focus the first item.
                //

                SendDlgItemMessage(m_hwnd,
                                   LocalPortList,
                                   LB_SETCURSEL,
                                   0,
                                   0);

                //
                // Store the current selection.
                //

                Idx = (DWORD)SendDlgItemMessage(m_hwnd,
                                                LocalPortList,
                                                LB_GETITEMDATA,
                                                0,
                                                0);
                if(ID_AUTO == Idx){
                    m_pCDevice->SetPort(AUTO);
                } else {
                    m_pCDevice->SetPort(m_csaPortName[Idx]);
                }

                //
                // Let the default handler do its job.
                //

                bRet = FALSE;
                goto OnNotify_return;
            } // case PORTSELMODE_NORMAL:

            case PORTSELMODE_SKIP:
            {
                //
                // "PortSelect = no" specified. Set port to "AUTO" and skip to the next page.
                //

                m_pCDevice->SetPort(AUTO);
                SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, m_uNextPage);
                bRet =  TRUE;
                goto OnNotify_return;
            } // case PORTSELMODE_SKIP:
            
            case PORTSELMODE_MESSAGE1:{

                //
                // Set proper message.
                //

                if(!SetDialogText(PortSelectMessage1)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Unable to set dialog text.\r\n")));
                } // if(!SetDialogText(PortSelectMessage0)
                    

                //
                // Make all cotrol invisible.
                //

                if(!ShowControl(FALSE)){
                    DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! Port listbox can't be invisible.\r\n")));
                } // if(!ShowControl(FALSE))

                //
                // Set port name.
                //

                m_pCDevice->SetPort(AUTO);

                bRet = FALSE;
                goto OnNotify_return;

            } // case PORTSELMODE_MESSAGE1:
            
            default:
                DebugTrace(TRACE_ERROR,(("CPortSelectPage::OnNotify: ERROR!! undefined PortSelect mode(0x%x).\r\n"), dwPortSelectMode));

                bRet = FALSE;
                goto OnNotify_return;
        } // switch(m_pCDevice->GetPortSelectMode())
    } // if (lpnmh->code == PSN_SETACTIVE)

    if (lpnmh->code == PSN_KILLACTIVE){

        if(!m_bNextButtonPushed){

            //
            // It's getting back to DeviceSelection page. Delete craeted CDevice object.
            //
            
            delete m_pCDevice;

            m_pCDevice                      = NULL;
            m_pInstallerContext->pDevice    = NULL;
        } // if(!m_bNextButtonPushed)
    } // if (lpnmh->code == PSN_KILLACTIVE)

OnNotify_return:

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::OnNotify: Leaving... Ret=0x%x.\r\n"), bRet));
    return  bRet;
}

VOID
CPortSelectPage::UpdatePortList(
    VOID
    )
{

    DWORD   Idx;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::UpdatePortList: Enter... \r\n")));

    //
    // Initialize local.
    //

    Idx = 0;

    //
    // Reset port list.
    //

    SendDlgItemMessage(m_hwnd,
                       LocalPortList,
                       LB_RESETCONTENT,
                       0,
                       0);

    //
    // Add "AUTO" port if capable.
    //

    if(m_dwCapabilities & STI_GENCAP_AUTO_PORTSELECT){

        TCHAR szTemp[MAX_DESCRIPTION];

        //
        // Load localized "Automatic Port Select" from resource.
        //

        LoadString(g_hDllInstance,
                   AutoPortSelect,
                   (TCHAR *)szTemp,
                   sizeof(szTemp) / sizeof(TCHAR));

        //
        // Add to the list with special index number. (ID_AUTO = -1)
        //

        AddItemToPortList(szTemp, ID_AUTO);

    } // if(dwCapabilities & STI_GENCAP_AUTO_PORTSELECT)

    //
    // Add all port FriendlyName to the list.
    //

    for(Idx = 0; Idx < m_dwNumberOfPort; Idx++){
        AddItemToPortList(m_csaPortFriendlyName[Idx], Idx);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::UpdatePortList: Leaving... Ret=VOID.\r\n")));
} // CPortSelectPage::UpdatePortList()


VOID
CPortSelectPage::AddItemToPortList(
    LPTSTR  szPortFriendlyName,
    DWORD   Idx
    )
{

    LRESULT         lResult;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::AddItemToPortList: Enter... \r\n")));

    //
    // Initialize local.
    //

    lResult = LB_ERR;

    //
    // See if we can add this item to list. It depends on its ConnectionType.
    //

    if(_tcsstr((const TCHAR *)szPortFriendlyName, TEXT("COM"))) {

        //
        // This is Communications Port.
        //

        if(_tcsicmp(m_csConnection, PARALLEL)){
            lResult = SendDlgItemMessage(m_hwnd,
                                         LocalPortList,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM)szPortFriendlyName);
        } else {
            lResult = LB_ERR;
        }
    } else if(_tcsstr((const TCHAR *)szPortFriendlyName, TEXT("LPT"))){

        //
        // This is Printer Port.
        //

        if(_tcsicmp(m_csConnection, SERIAL)){
            lResult = SendDlgItemMessage(m_hwnd,
                                         LocalPortList,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM)szPortFriendlyName);
        } else {
            lResult = LB_ERR;
        }
    } else {

        //
        // This is Unknown port. Add to the list anyway.
        //

        lResult = SendDlgItemMessage(m_hwnd,
                                     LocalPortList,
                                     LB_ADDSTRING,
                                     0,
                                     (LPARAM)szPortFriendlyName);
    }

    //
    // If it has proper capability, add the item to the list.
    //

    if (lResult != LB_ERR) {
        SendDlgItemMessage(m_hwnd,
                           LocalPortList,
                           LB_SETITEMDATA,
                           lResult,
                           (LPARAM)Idx);
    } // if (lResult != LB_ERR)

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::AddItemToPortList: Leaving... Ret=VOID.\r\n")));

} // CPortSelectPage::AddItemToPortList()


BOOL
CPortSelectPage::EnumPort(
    VOID
    )
{

    BOOL        bRet;
    GUID        Guid;
    DWORD       dwRequired;
    HDEVINFO    hPortDevInfo;
    DWORD       Idx;
    TCHAR       szPortName[MAX_DESCRIPTION];
    TCHAR       szPortFriendlyName[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::EnumPort: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    dwRequired      = 0;
    Idx             = 0;
    hPortDevInfo    = NULL;

    memset(szPortName, 0, sizeof(szPortName));
    memset(szPortFriendlyName, 0, sizeof(szPortFriendlyName));

    //
    // If it's already enumerated, just return success.
    //

    if(m_bPortEnumerated){
        bRet = TRUE;
        goto EnumPort_return;
    }

    //
    // Initialize Port CreateFile/Friendly Name string array.
    //

    m_dwNumberOfPort = 0;
    m_csaPortName.Cleanup();
    m_csaPortFriendlyName.Cleanup();

    //
    // Get GUID of port device.
    //

    if(!SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired)){
        DebugTrace(TRACE_ERROR,(("CPortSelectPage::EnumPort: ERROR!! SetupDiClassGuidsFromName Failed. Err=0x%lX\r\n"), GetLastError()));

        bRet = FALSE;
        goto EnumPort_return;
    }

    //
    // Get device info set of port devices.
    //

    hPortDevInfo = SetupDiGetClassDevs (&Guid,
                                       NULL,
                                       NULL,
                                       DIGCF_PRESENT | DIGCF_PROFILE);
    if (hPortDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("CPortSelectPage::EnumPort: ERROR!! SetupDiGetClassDevs Failed. Err=0x%lX\r\n"), GetLastError()));

        bRet = FALSE;
        goto EnumPort_return;
    }

    //
    // Process all of device element listed in device info set.
    //

    for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++){

        //
        // Add valid Port CreateFile/Friendly Name to array.
        //

        if( (0 == lstrlen(szPortName))
         || (0 == lstrlen(szPortFriendlyName)) )
        {
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::EnumPort: ERROR!! Invalid Port/Friendly Name.\r\n")));

            szPortName[0]           = TEXT('\0');
            szPortFriendlyName[0]   = TEXT('\0');
            continue;
        }

        DebugTrace(TRACE_STATUS,(("CPortSelectPage::EnumPort: Found Port %d: %ws(%ws).\r\n"), Idx, szPortName, szPortFriendlyName));

        m_dwNumberOfPort++;
        m_csaPortName.Add(szPortName);
        m_csaPortFriendlyName.Add(szPortFriendlyName);

        szPortName[0]           = TEXT('\0');
        szPortFriendlyName[0]   = TEXT('\0');

    } // for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++)

    //
    // Operation succeeded.
    //

    bRet                = TRUE;
    m_bPortEnumerated   = TRUE;

EnumPort_return:

    //
    // Cleanup
    //

    if(NULL != hPortDevInfo){
        SetupDiDestroyDeviceInfoList(hPortDevInfo);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::EnumPort: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;

} // CPortSelectPage::EnumPort()

BOOL
CPortSelectPage::CreateCDeviceObject(
    VOID
    )
{
    BOOL    bRet;

    DebugTrace(TRACE_PROC_ENTER,(("CPortSelectPage::CreateCDeviceObject: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet    = FALSE;

    //
    // If CDevice already exists, see if we can reuse it.
    //

    if(NULL != m_pCDevice){
        SP_DEVINFO_DATA spDevInfoData;

        memset(&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        if(!SetupDiGetSelectedDevice(m_hDevInfo, &spDevInfoData)){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Can't get selected device element. Err=0x%x\n"), GetLastError()));

            bRet = FALSE;
            goto CreateCDeviceObject_return;
        }

        if(!(m_pCDevice->IsSameDevice(m_hDevInfo, &spDevInfoData))){

            //
            // User changed selected device. Delete the object.
            //

            delete m_pCDevice;

            m_pCDevice                      = NULL;
            m_pInstallerContext->pDevice    = NULL;
            m_csConnection                  = BOTH;
            m_dwCapabilities                = NULL;

        } // if(!(m_pCDevice->IsSameDevice(m_hDevInfo, &spDevInfoData)))
    } // if(NULL != m_pCDevice)

    //
    // Create CDevice object here if it doesn't exist.
    //

    if(NULL == m_pCDevice){

        //
        // Get selected device.
        //

        memset(m_pspDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
        m_pspDevInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
        if(!SetupDiGetSelectedDevice(m_hDevInfo, m_pspDevInfoData)){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Can't get selected device element. Err=0x%x\n"), GetLastError()));

            bRet = FALSE;
            goto CreateCDeviceObject_return;
        }

        //
        // Create CDevice object for installing device.
        //

        m_pCDevice = new CDevice(m_hDevInfo, m_pspDevInfoData, FALSE);
        if(NULL == m_pCDevice){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Can't create CDevice object.\r\n")));

            bRet = FALSE;
            goto CreateCDeviceObject_return;
        } // if(NULL == m_pCDevice)

        //
        // Name default unique name.
        //

        if(!m_pCDevice->NameDefaultUniqueName()){
                DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Unable to get default name.\r\n")));
        }

        //
        // Pre-process INF.
        //

        if(!m_pCDevice->PreprocessInf()){
            DebugTrace(TRACE_ERROR,(("CPortSelectPage::CreateCDeviceObject: ERROR!! Unable to process INF.\r\n")));
        }

        //
        // Save created CDevice object into installer context.
        //

        m_pInstallerContext->pDevice = (PVOID)m_pCDevice;

        //
        // Get ConnectionType/Capabilities.
        //

        m_dwCapabilities    = m_pCDevice->GetCapabilities();
        m_csConnection      = m_pCDevice->GetConnection();
        if(m_csConnection.IsEmpty()){
            m_csConnection = BOTH;
        } // if(m_csConnection.IsEmpty())

    } // if(NULL == m_pCDevice)

    //
    // Operation succeeded.
    //

    bRet    = TRUE;

CreateCDeviceObject_return:
    DebugTrace(TRACE_PROC_LEAVE,(("CPortSelectPage::CreateCDeviceObject: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CPortSelectPage::CreateCDeviceObject()

BOOL
CPortSelectPage::SetDialogText(
    UINT uiMessageId
    )
{
    BOOL    bRet;
    TCHAR   szStringBuffer[MAX_STRING_LENGTH];
    HWND    hwndMessage;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    hwndMessage = (HWND)NULL;

    memset(szStringBuffer, 0, sizeof(szStringBuffer));

    //
    // Load message string.
    //

    if(0 == LoadString(g_hDllInstance,
                       uiMessageId,
                       szStringBuffer,
                       sizeof(szStringBuffer)/sizeof(TCHAR)))
    {
        //
        // Unable to load specified string.
        //

        bRet = FALSE;
        goto SetDialogText_return;

    } // if(0 == LoadString()

    //
    // Get window handle the control
    //

    hwndMessage = GetDlgItem(m_hwnd, IDC_PORTSEL_MESSAGE);

    //
    // Set loaded string to the dialog.
    //

    SetWindowText(hwndMessage, (LPCTSTR)szStringBuffer);

    bRet = TRUE;

SetDialogText_return:

    return bRet;

} // CPortSelectPage::SetDialogText()

BOOL
CPortSelectPage::ShowControl(
    BOOL    bShow
    )
{
    BOOL    bRet;
    HWND    hwndString;
    HWND    hwndListBox;
    int     nCmdShow;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    hwndString  = (HWND)NULL;
    hwndListBox = (HWND)NULL;

    if(bShow){
        nCmdShow = SW_SHOW;
    } else {
        nCmdShow = SW_HIDE;
    }

    //
    // Get window handle the control
    //

    hwndString  = GetDlgItem(m_hwnd, IDC_PORTSEL_AVAILABLEPORTS);
    hwndListBox = GetDlgItem(m_hwnd, LocalPortList);

    //
    // Make them in/visible.
    //

    if(NULL != hwndString){
        ShowWindow(hwndString, nCmdShow);
    } // if(NULL != hwndString)

    if(NULL != hwndListBox){
        ShowWindow(hwndListBox, nCmdShow);
    } // if(NULL != hwndListBox)

    bRet = TRUE;

// ShowControl_return:

    return bRet;
} // CPortSelectPage::ShowControl()





BOOL
GetDevinfoFromPortName(
    LPTSTR              szPortName,
    HDEVINFO            *phDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData
    )
{
    BOOL            bRet;
    BOOL            bFound;
    HDEVINFO        hPortDevInfo;
    SP_DEVINFO_DATA spDevInfoData;
    GUID            Guid;
    DWORD           dwRequired;
    DWORD           Idx;
    TCHAR           szTempPortName[MAX_DESCRIPTION];
    TCHAR           szPortFriendlyName[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("GetDevinfoFromPortName: Enter... \r\n")));

    //
    // Initialize local.
    //

    bRet            = FALSE;
    bFound          = FALSE;
    hPortDevInfo    = INVALID_HANDLE_VALUE;
    dwRequired      = 0;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));
    memset(&szTempPortName, 0, sizeof(szTempPortName));
    memset(&szPortFriendlyName, 0, sizeof(szPortFriendlyName));

    //
    // Get GUID of port device.
    //

    if(!SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired)){
        DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: ERROR!! SetupDiClassGuidsFromName Failed. Err=0x%lX\r\n"), GetLastError()));

        goto GetDevinfoFromPortName_return;
    }

    //
    // Get device info set of port devices.
    //

    hPortDevInfo = SetupDiGetClassDevs (&Guid,
                                        NULL,
                                        NULL,
                                        DIGCF_PRESENT | DIGCF_PROFILE);
    if (hPortDevInfo == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: ERROR!! SetupDiGetClassDevs Failed. Err=0x%lX\r\n"), GetLastError()));

        goto GetDevinfoFromPortName_return;
    }

    //
    // If portname is AUTO, use the first port no matter what it is.
    //

    if(0 == _tcsicmp(szPortName, AUTO)){

        DebugTrace(TRACE_STATUS,(("GetDevinfoFromPortName: Portname is AUTO. The first port found will be returned,\r\n")));

        Idx = 0;
        bFound = TRUE;
        goto GetDevinfoFromPortName_return;
    } // if(0 == _tcsicmp(szPortName, AUTO))

    //
    // Enum all ports and find specified port.
    //

    for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szTempPortName, szPortFriendlyName); Idx++){

        //
        // Find specified portname..
        //

        if( (0 == lstrlen(szTempPortName))
         || (0 == lstrlen(szPortFriendlyName)) )
        {
            DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: ERROR!! Invalid Port/Friendly Name.\r\n")));

            szTempPortName[0]       = TEXT('\0');
            szPortFriendlyName[0]   = TEXT('\0');
            continue;
        }

        DebugTrace(TRACE_STATUS,(("GetDevinfoFromPortName: Found Port %d: %ws(%ws). Comparing w/ %ws\r\n"), Idx, szTempPortName, szPortFriendlyName, szPortName));

        if(0 == _tcsicmp(szPortName, szTempPortName)){

            //
            // Specified portname found.
            //

            bFound = TRUE;
            break;
        }

        szTempPortName[0]       = TEXT('\0');
        szPortFriendlyName[0]   = TEXT('\0');

    } // for(Idx = 0; GetPortNamesFromIndex(hPortDevInfo, Idx, szPortName, szPortFriendlyName); Idx++)

GetDevinfoFromPortName_return:

    if(FALSE == bFound){
        if(INVALID_HANDLE_VALUE != hPortDevInfo){
            SetupDiDestroyDeviceInfoList(hPortDevInfo);
        }

        *phDevInfo = NULL;
    } else {
        *phDevInfo = hPortDevInfo;
        pspDevInfoData->cbSize = sizeof (SP_DEVINFO_DATA);
        if(!SetupDiEnumDeviceInfo(hPortDevInfo, Idx, pspDevInfoData)){
            DebugTrace(TRACE_ERROR,(("GetDevinfoFromPortName: Unable to get specified devnode. Err=0x%x\n"), GetLastError()));
        } //if(!SetupDiEnumDeviceInfo(hDevInfo, Idx, pspDevInfoData))

    } // if(FALSE == bFound)

    bRet = bFound;
    DebugTrace(TRACE_PROC_LEAVE,(("GetDevinfoFromPortName: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // GetDevinfoFromPortName()



BOOL
GetPortNamesFromIndex(
    HDEVINFO    hPortDevInfo,
    DWORD       dwPortIndex,
    LPTSTR      szPortName,
    LPTSTR      szPortFriendlyName
    )
{
    HKEY            hkPort;
    SP_DEVINFO_DATA spDevInfoData;
    DWORD           dwSize;
    BOOL            bRet;

    DebugTrace(TRACE_PROC_ENTER,(("GetPortNamesFromIndex: Enter... \r\n")));

    //
    // Initialize local.
    //

    hkPort  = NULL;
    dwSize  = 0;
    bRet    = TRUE;

    memset(&spDevInfoData, 0, sizeof(spDevInfoData));

    //
    // Get specified device info data.
    //

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    if (!SetupDiEnumDeviceInfo (hPortDevInfo, dwPortIndex, &spDevInfoData)) {
        DWORD dwError;

        dwError = GetLastError();
        if(ERROR_NO_MORE_ITEMS == dwError){
            DebugTrace(TRACE_STATUS,(("GetPortNamesFromIndex: Hits end of enumeration. Index=0x%x.\r\n"), dwPortIndex));
        } else {
            DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: ERROR!! SetupDiEnumDeviceInfo() failed. Err=0x%x\n"), dwError));
        }

        bRet = FALSE;
        goto GetPortNamesFromIndex_return;
    }

    //
    // Open port device registry.
    //

    hkPort = SetupDiOpenDevRegKey (hPortDevInfo,
                                   &spDevInfoData,
                                   DICS_FLAG_GLOBAL,
                                   0,
                                   DIREG_DEV, KEY_READ);
    if (hkPort == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: SetupDiOpenDevRegKey() failed.Err=0x%x\n"), GetLastError()));

        goto GetPortNamesFromIndex_return;
    }

    //
    // Get portname from device key.
    //

    if(!GetStringFromRegistry(hkPort, PORTNAME, szPortName)){
        DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: Can't get portname from registry.\r\n")));

        goto GetPortNamesFromIndex_return;
    }

    //
    // Get port FriendlyName from registry.
    //

    if (!SetupDiGetDeviceRegistryProperty (hPortDevInfo,
                                           &spDevInfoData,
                                           SPDRP_FRIENDLYNAME,
                                           NULL,
                                           (LPBYTE)szPortFriendlyName,
                                           MAX_DESCRIPTION,
                                           NULL) )
    {
        DebugTrace(TRACE_ERROR,(("GetPortNamesFromIndex: SetupDiGetDeviceRegistryProperty() failed. Err=0x%x\n"), GetLastError()));

        goto GetPortNamesFromIndex_return;
    } // if (SetupDiGetDeviceRegistryProperty())

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetPortNamesFromIndex_return:

    //
    // Clean up.
    //

    if(NULL != hkPort){
        RegCloseKey(hkPort);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("GetPortNamesFromIndex: Leaving... Ret=0x%x.\r\n"), bRet));
    return bRet;
} // CPortSelectPage::GetPortNamesFromIndex()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\portsel.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Portsel.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Port selection page of WIA class installer.
*
*******************************************************************************/

#ifndef _PORTSEL_H_
#define _PORTSEL_H_

//
// Include
//

#include "wizpage.h"
#include "device.h"

//
// Class
//

class   CPortSelectPage : public CInstallWizardPage 
{

    HDEVINFO            m_hDevInfo;             // Device info set of installing device.
    PSP_DEVINFO_DATA    m_pspDevInfoData;       // Pointer to Device element structure.

    BOOL                m_bPortEnumerated;      // Inidicate if ports are already enumed.
    DWORD               m_dwNumberOfPort;       // Number of port.
    CStringArray        m_csaPortName;          // All port CreateFile name on the system.
    CStringArray        m_csaPortFriendlyName;  // All port Friendly name on the system.
    
    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.
    
    CString             m_csConnection;         // Connection type of installing device.
    DWORD               m_dwCapabilities;       // Capabilities of installing device.

    BOOL    CreateCDeviceObject();
    BOOL    EnumPort();
    VOID    UpdatePortList();
    
    VOID
    AddItemToPortList(
        LPTSTR  szPortFriendlyName,
        DWORD   Idx
        );

    BOOL
    SetDialogText(
        UINT uiMessageId
        );

    BOOL
    ShowControl(
        BOOL    bShow
        );

public:

    CPortSelectPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CPortSelectPage();

    virtual BOOL OnCommand(WORD wItem, WORD wNotifyCode, HWND hwndItem);
    virtual BOOL OnNotify(LPNMHDR lpnmh);

};

BOOL
GetPortNamesFromIndex(
    HDEVINFO    hPortDevInfo,
    DWORD       dwPortIndex,
    LPTSTR      szPortName,
    LPTSTR      szPortFriendlyName
    );

BOOL
GetDevinfoFromPortName(
    LPTSTR              szPortName,
    HDEVINFO            *phDevInfo,
    PSP_DEVINFO_DATA    pspDevInfoData
    );

#endif // _PORTSEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\precomp.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       precomp.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        8 Sep, 2000
*
*  DESCRIPTION:
*   Precompiled header
*
*
*******************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <commctrl.h>
#include <assert.h>
#include <objbase.h>
#include <setupapi.h>
#include <shfusion.h>
#include <shlobj.h>
#include <stdio.h>
#include <tchar.h>

//
// Make sure this is included last, so it can redefine the necessary stuff
//
#include <shfusion.h>

#endif // __PRECOMP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\resource.h ===
/******************************************************************************

  Header File:  Resource.H

  Resource IDs used in the Class Installer

  Range 100-999     Control IDs
  Range 1000-1999   Icon, bitmap, and Dialog IDs
  Range 1-32767     String IDs

  Copyright (c) 1996, 1997 by Microsoft Corporation.  All Rights Reserved

  Change History:

  12-12-1996    Bob Kjelgaard   Created it

******************************************************************************/

//  Control IDs
#define IDC_STATIC                      -1
#define LocalPortList                   100
#define ConfigureButton                 101
#define DeviceFriendlyName              102
#define YesButton                       103
#define NoButton                        104
#define IDC_SCNAME                      105
#define IDC_PORTSEL_AVAILABLEPORTS      106
#define IDC_PORTSEL_MESSAGE             107


//  Icon, bitmap, Dialog IDs
#define ImageIcon                       1000
#define WizardBitmap                    1001
#define WizardBitmap2                   1002
// From Win2k CPL.

#define IDB_BANNERBMP                   1010
#define IDB_WATERMARK                   1011

#define NameTheDevice                   5002
#define EmeraldCity                     5003

//  String IDs

#define MessageTitle                    1
#define InstallationSuccessful          2
#define InstallationFailed              3
#define SelectionInstructions           4
#define ListTitle                       5
#define DuplicateDeviceName             6
#define CannotConfigurePort             7
#define AutoPortSelect                  8
#define HeaderTitle                     9
#define SubHeaderTitle                 10
#define WiaWizardName                  11
#define AccessoriesFolderName          12
#define WiaWizardDescription           13
#define DeviceNameTooLong              14
#define NoDeviceName                   15
#define WiaServiceDescription          16
#define WiaServiceName                 17
#define HeaderForPortsel               18
#define HeaderForNameIt                19

#define WelcomeMessage                 20
#define CompleteMessage                21
#define LocalAccessoriesFolderName     22

#define SelDevTitle                    23
#define SelDevSubTitle                 24
#define SelDevInstructions             25
#define SelDevListLabel                26

#define PortSelectMessage0             27
#define PortSelectMessage1             28

#define IDS_TITLEFONTNAME              50
#define IDS_TITLEFONTSIZE              51
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\prevpg.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Prevpg.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Dummy page for the case user push BACK button in device selection page.
*
*******************************************************************************/

#ifndef _PREVPG_H_
#define _PREVPG_H_

//
// Include
//

#include    "wizpage.h"

//
// Class
//

class CPrevSelectPage : public CInstallWizardPage {

    PINSTALLER_CONTEXT  m_pInstallerContext;    // Installer context.

public:

    CPrevSelectPage(PINSTALLER_CONTEXT pInstallerContext);
    ~CPrevSelectPage() {};

    virtual BOOL OnNotify(LPNMHDR lpnmh);
};

#endif // _PREVPG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\prevpg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Prevpg.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Dummy page for the case user push BACK button in device selection page.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

#include "prevpg.h"

CPrevSelectPage::CPrevSelectPage(PINSTALLER_CONTEXT pInstallerContext) :
    CInstallWizardPage(pInstallerContext, IDD_DYNAWIZ_SELECT_PREVPAGE)
{

    //
    // Set link to previous/next page. This page should show up.
    //

    m_uPreviousPage = 0;
    m_uNextPage     = 0;

    //
    // Initialize member.
    //

    m_pInstallerContext = pInstallerContext;
}

BOOL
CPrevSelectPage::OnNotify(
    LPNMHDR lpnmh
    )
{
    BOOL bRet;

    if(lpnmh->code == PSN_SETACTIVE) {

        LONG_PTR    lNextPage;

        //
        // User clicked BACK button in devlce selection page. Just skip to First
        // page or Class selection page if it's invoked from Hardware Wizard.
        //

        if(m_pInstallerContext->bCalledFromControlPanal){

            //
            // Called from Control Panel. Goto first page.
            //

            lNextPage = IDD_DYNAWIZ_FIRSTPAGE;
        } else {

            //
            // Called from hardware wizard. Goto Class selection page.
            //

            lNextPage = IDD_DYNAWIZ_SELECTCLASS_PAGE;
        } // if(m_pInstallerContext->bCalledFromControlPanal)

        //
        // Skip to next page.
        //

        SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, lNextPage);

        //
        // Default handler isn't needed.
        //

        bRet =  TRUE;
        goto OnNotify_return;

    } // if(lpnmh->code == PSN_SETACTIVE)

    //
    // Let default handler do its job.
    //

    bRet = FALSE;

OnNotify_return:
    return bRet;
} // CPrevSelectPage::OnNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\service.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    This file provides access to the service control
    manager for starting, stopping, adding, and removing
    services.

Environment:

    WIN32 User Mode

Author:

    Vlad Sadovsky (vlads) 17-Apr-1998

--*/


//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"
#include "device.h"

#include <regstr.h>

#include <sti.h>
#include <stiregi.h>
#include <stilib.h>
#include <stidebug.h>
#include <stiapi.h>
#include <stisvc.h>

#include <eventlog.h>

//
// Extern
//

extern  HINSTANCE   g_hDllInstance;


//
// Prototype
//

DWORD
SetServiceSecurity(
    LPTSTR AccountName
    );

DLLEXPORT
VOID
CALLBACK
InstallWiaService(
    HWND        hwnd,
    HINSTANCE   hinst,
    LPTSTR      lpszCmdLine,
    int         nCmdShow
    );

//
// Function
//

DWORD
WINAPI
StiServiceInstall(
    BOOL    UseLocalSystem,
    BOOL    DemandStart,
    LPTSTR  lpszUserName,
    LPTSTR  lpszUserPassword
    )
/*++

Routine Description:

    Service installation function.
    Calls SCM to install STI service, which is running in user security context

Arguments:

Return Value:

    None.

--*/
{

    DWORD       dwError = NOERROR;

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    SERVICE_DESCRIPTION ServiceDescroption;
    TCHAR               szServiceDesc[MAX_PATH];
    TCHAR               szServiceName[MAX_PATH];


    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            dwError = GetLastError();
            __leave;
        }

        //
        // If service already exists change startup type, else CreateService.
        // NOTE: The service should already be installed - if it isn't, we're 
        // patching it here because it MUST be installed in order to use WIA.
        //

        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (hService) {

            //
            //  Change the service config parameters.  Note: we're only changing StartType
            //

            if (!ChangeServiceConfig(hService,          // handle to WIA service
                                     SERVICE_NO_CHANGE, // Don't change ServiceType
                                     DemandStart ? SERVICE_DEMAND_START : SERVICE_AUTO_START,   // Change StartType
                                     SERVICE_NO_CHANGE, // Don't change ErrorControl
                                     NULL,              // Don't change BinaryPathName
                                     NULL,              // Don't change LoadOrderGroup
                                     NULL,              // Don't change TagId
                                     NULL,              // Don't change Dependencies
                                     NULL,              // Don't change ServiceStartName
                                     NULL,              // Don't change Password
                                     NULL)) {           // Don't change DisplayName
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("StiServiceInstall: ChangeServiceConfig() failed. Err=0x%x.\r\n"), dwError));
                __leave;
            } // if (!ChangeServiceConfig(...))

        } else {
            //
            // If use local system - set security
            //

            if (!UseLocalSystem) {
                #ifdef LATER
                dwError = SetServiceSecurity( lpszUserName );
                if (dwError) {
                    dwError = ERROR_SERVICE_LOGON_FAILED ;
                    __leave;
                }
                #endif
            }

            //
            // Load service name.
            //

            if(0 == LoadString(g_hDllInstance, WiaServiceName, szServiceName, MAX_PATH)){
                dwError = GetLastError();
                __leave;
            } // if(0 != LoadString(g_hDllInstance, WiaServiceName, szServiceName, MAX_PATH))

            hService = CreateService(
                                    hSCM,
                                    STI_SERVICE_NAME,
                                    szServiceName,
                                    SERVICE_ALL_ACCESS,
                                    STI_SVC_SERVICE_TYPE,
                                    DemandStart ? SERVICE_DEMAND_START : SERVICE_AUTO_START,
                                    SERVICE_ERROR_NORMAL,
                                    STI_IMAGE_NAME_SVCHOST,
                                    NULL,
                                    NULL,
                                    STI_SVC_DEPENDENCIES, //STI_SERVICE_DEPENDENCY,
                                    UseLocalSystem ? NULL : lpszUserName,
                                    UseLocalSystem ? NULL : lpszUserPassword
                                    );

            if (!hService) {
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("StiServiceInstall: CreateService() failed. Err=0x%x.\r\n"), dwError));
                __leave;
            }

            //
            // Load service description.
            //

            if(0 != LoadString(g_hDllInstance, WiaServiceDescription, szServiceDesc, MAX_PATH)){

                //
                // Change service description.
                //

                ServiceDescroption.lpDescription = (LPTSTR)szServiceDesc;
                ChangeServiceConfig2(hService,
                                     SERVICE_CONFIG_DESCRIPTION,
                                     (LPVOID)&ServiceDescroption);
            } // if(0 != LoadString(g_hDllInstance, WiaServiceDescription, szServiceDesc, MAX_PATH))
        }

        //
        // Add registry settings for event logging
        //

        RegisterStiEventSources();

        //
        // Start service if AUTO_START.
        //

        if(FALSE == DemandStart){
            if(!StartService(hService,0,(LPCTSTR *)NULL)){
                dwError = GetLastError();
            } // if(!StartService(hService,0,(LPCTSTR *)NULL))
        } // if(FALSE == DemandStart)
    }
    __finally {
        //
        // Close service handle.
        //

        if (NULL != hService) {
            CloseServiceHandle(hService);
        } // if(NULL != hService)

        if(NULL != hSCM){
            CloseServiceHandle( hSCM );
        } // if(NULL != hSCM)
    }

    return dwError;

} //StiServiceInstall


DWORD
WINAPI
StiServiceRemove(
    VOID
    )

/*++

Routine Description:

    Service removal function.  This function calls SCM to remove the STI  service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success

--*/

{
    DWORD       dwError = NOERROR;

    SC_HANDLE   hSCM = NULL;
    SC_HANDLE   hService = NULL;

    SERVICE_STATUS  ServiceStatus;
    UINT        uiRetry = 10;

    HKEY        hkRun;

    __try  {

        hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

        if (!hSCM) {
            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: OpenSCManager() failed. Err=0x%x.\r\n"), dwError));
            __leave;
        }

        hService = OpenService(
                            hSCM,
                            STI_SERVICE_NAME,
                            SERVICE_ALL_ACCESS
                            );
        if (!hService) {
            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: OpenService() failed. Err=0x%x.\r\n"), dwError));
            __leave;
        }


        //
        // Stop service first
        //

        if (ControlService( hService, SERVICE_CONTROL_STOP, &ServiceStatus )) {

            //
            // Wait a little
            //

            Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

            ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

            while( QueryServiceStatus( hService, &ServiceStatus ) &&
                  (SERVICE_STOP_PENDING ==  ServiceStatus.dwCurrentState)) {
                Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
                if (!uiRetry--) {
                    break;
                }
            }

            if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                dwError = GetLastError();
                DebugTrace(TRACE_ERROR,(("StiServiceRemove: Unable to stop service. Err=0x%x.\r\n"), dwError));
                if(ServiceStatus.dwCurrentState != ERROR_SERVICE_NOT_ACTIVE) {
                    __leave;
                } // if(ServiceStatus.dwCurrentState != ERROR_SERVICE_NOT_ACTIVE)
            } // if (ServiceStatus.dwCurrentState != SERVICE_STOPPED)

        } else { // if (ControlService( hService, SERVICE_CONTROL_STOP, &ServiceStatus ))

            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: ControlService() failed. Err=0x%x.\r\n"), dwError));

            //
            // If service hasn't been started yet, just ignore.
            //

            if(ERROR_SERVICE_NOT_ACTIVE != dwError){
                __leave;
            }
        }

        if (!DeleteService( hService )) {
            dwError = GetLastError();
            DebugTrace(TRACE_ERROR,(("StiServiceRemove: DeleteService() failed. Err=0x%x.\r\n"), dwError));
            __leave;
        } else {
            dwError = NOERROR;
        }
    }
    __finally {
        if(NULL != hService){
            CloseServiceHandle( hService );
        }
        if(NULL != hSCM){
            CloseServiceHandle( hSCM );
        }
    } // __finally

    //
    // Leftovers from Win9x - remove STI monitor from Run section
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, &hkRun) == NO_ERROR) {

        RegDeleteValue (hkRun, REGSTR_VAL_MONITOR);
        RegCloseKey(hkRun);
    }

    return dwError;

} // StiServiceRemove


BOOL
SetServiceDependency(
    LPTSTR ServiceName,
    LPTSTR DependentServiceName
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,               // handle to service
        SERVICE_NO_CHANGE,      // type of service
        SERVICE_NO_CHANGE,      // when to start service
        SERVICE_NO_CHANGE,      // severity if service fails to start
        NULL,                   // pointer to service binary file name
        NULL,                   // pointer to load ordering group name
        NULL,                   // pointer to variable to get tag identifier
        DependentServiceName,   // pointer to array of dependency names
        NULL,                   // pointer to account name of service
        NULL,                   // pointer to password for service account
        NULL                    // pointer to display name
        )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    return rVal;
}


BOOL
SetServiceStart(
    LPTSTR ServiceName,
    DWORD StartType
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        StartType,                       // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        NULL,                            // pointer to account name of service
        NULL,                            // pointer to password for service account
        NULL                             // pointer to display name
        ))
    {
        goto exit;
    }

    rVal = TRUE;

exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    return rVal;
}

BOOL
StartWiaService(
    VOID
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;
    UINT            uiRetry = 40;       // start time is much larger than stop time.
                                        // Setting 40 sec just to be safe.




    DebugTrace(TRACE_PROC_ENTER,(("StartWiaService: Enter... \r\n")));

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Open WIA service.
    //

    hService = OpenService(
        hSvcMgr,
        STI_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! OpenService failed, re-creating Service Entry (Err=0x%x)\n"), GetLastError()));

        //
        //  Attempt to re-install service
        //

        InstallWiaService(NULL,
                          NULL,
                          NULL,
                          0);
        Sleep(3000);

        //
        //  Try to open it again
        //
        hService = OpenService(
            hSvcMgr,
            STI_SERVICE_NAME,
            SERVICE_ALL_ACCESS
            );

        if (!hService) {
            DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! OpenService failed for the second time.  Err=0x%x\n"), GetLastError()));
            goto exit;
        }
    }

    rVal = StartService(hService,
                        0,
                        (LPCTSTR *)NULL);
    if(!rVal){
        DebugTrace(TRACE_STATUS,(("StartWiaService: ERROR!! StartService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Wait for WIA service to really start.
    //

    Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;

    while( QueryServiceStatus( hService, &ServiceStatus ) &&
          (SERVICE_START_PENDING ==  ServiceStatus.dwCurrentState)) {
        Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
        if (!uiRetry--) {
            break;
        }
    }

    if (ServiceStatus.dwCurrentState != SERVICE_RUNNING) {
        DebugTrace(TRACE_ERROR,(("StartWiaService: ERROR!! Hit timeout to start service. Err=0x%x\n"), GetLastError()));
    }


exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    DebugTrace(TRACE_PROC_LEAVE,(("StartWiaService: Leaving... Ret=0x%x\n"), rVal));
    return rVal;
}


BOOL
StopWiaService(
    VOID
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;
    UINT            uiRetry = 10;

    DebugTrace(TRACE_PROC_ENTER,(("StopWiaService: Enter... \r\n")));

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Open WIA service.
    //

    hService = OpenService(
        hSvcMgr,
        STI_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! OpenService failed. Err=0x%x\n"), GetLastError()));
        goto exit;
    }

    //
    // Stop WIA service.
    //

    rVal = ControlService(hService,
                         SERVICE_CONTROL_STOP,
                         &ServiceStatus);
    if(!rVal){
        DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! ControlService failed. Err=0x%x\n"), GetLastError()));
    } else {

        //
        // Wait for WIA service really stops.
        //

        Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );

        ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;

        while( QueryServiceStatus( hService, &ServiceStatus ) &&
              (SERVICE_STOP_PENDING ==  ServiceStatus.dwCurrentState)) {
            Sleep( STI_STOP_FOR_REMOVE_TIMEOUT );
            if (!uiRetry--) {
                break;
            }
        }

        if (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
            DebugTrace(TRACE_ERROR,(("StopWiaService: ERROR!! Hit timeout to stop service. Err=0x%x\n"), GetLastError()));
        }
    }

exit:
    if(NULL != hService){
        CloseServiceHandle( hService );
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
    }

    DebugTrace(TRACE_PROC_LEAVE,(("StopWiaService: Leaving... Ret=0x%x\n"), rVal));
    return rVal;
}





/*
BOOL
SetServiceAccount(
    LPTSTR ServiceName,
    PSECURITY_INFO SecurityInfo
    )
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr;
    SC_HANDLE       hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        goto exit;
    }

    hService = OpenService(
        hSvcMgr,
        ServiceName,
        SERVICE_ALL_ACCESS
        );

    if (!hService) {
        goto exit;
    }


    if (!ChangeServiceConfig(
        hService,                        // handle to service
        SERVICE_NO_CHANGE,               // type of service
        SERVICE_NO_CHANGE,               // when to start service
        SERVICE_NO_CHANGE,               // severity if service fails to start
        NULL,                            // pointer to service binary file name
        NULL,                            // pointer to load ordering group name
        NULL,                            // pointer to variable to get tag identifier
        NULL,                            // pointer to array of dependency names
        SecurityInfo->AccountName,       // pointer to account name of service
        SecurityInfo->Password,          // pointer to password for service account
        NULL                             // pointer to display name
        )) {
        goto exit;
    }

    rVal = TRUE;

exit:
    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\security.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.cpp

Abstract:

Environment:

    WIN32 User Mode

Author:

    Vlad Sadovsky (vlads) 19-Apr-1998


--*/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "sti_ci.h"

#include <sti.h>
#include <stiregi.h>
#include <stilib.h>
#include <stiapi.h>
#include <stisvc.h>

#include <eventlog.h>

#include <ntsecapi.h>
#include <lm.h>



NTSTATUS
OpenPolicy(
    LPTSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
GetAccountSid(
    LPTSTR SystemName,          // where to lookup account
    LPTSTR AccountName,         // account of interest
    PSID *Sid                   // resultant buffer containing SID
    );

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPTSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPTSTR String                  // source (Unicode)
    );

#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

//
// If you have the ddk, include ntstatus.h.
//
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif


BOOL
GetDefaultDomainName(
    LPTSTR DomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;


    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        return FALSE;
    }

    //
    //  Query the domain information from the policy object.
    //
    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *) &DomainInfo );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaPolicyHandle);
        return FALSE;
    }


    (void) LsaClose(LsaPolicyHandle);

    //
    // Copy the domain name into our cache, and
    //

    CopyMemory( DomainName,
                DomainInfo->DomainName.Buffer,
                DomainInfo->DomainName.Length );

    //
    // Null terminate it appropriately
    //

    DomainName[DomainInfo->DomainName.Length / sizeof(WCHAR)] = L'\0';

    //
    // Clean up
    //
    LsaFreeMemory( (PVOID)DomainInfo );

    return TRUE;
}


LPTSTR
GetMachineName(
    LPWSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle = NULL;

    WCHAR   DomainName[128];
    WCHAR   LocalComputerName[128];

    LPTSTR MachineName = NULL;
    LPTSTR p;
    LPTSTR DCName = NULL;
    NET_API_STATUS NetStatus;
    UNICODE_STRING NameStrings;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_SID LsaSids = NULL;
    PUSER_MODALS_INFO_1 Modals = NULL;
    DWORD Size;
    NTSTATUS Status;

    //
    // Get the domain name
    //

    p = wcschr( wszAccountName, L'\\' );
    if (p) {
        *p = 0;
        wcscpy( DomainName, wszAccountName );
        *p = L'\\';
    } else {
        wcscpy( DomainName, wszAccountName );
    }

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        NULL,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // lookup the domain name for the account
    //

    InitLsaString( &NameStrings, AccountName );

    Status = LsaLookupNames(
        PolicyHandle,
        1,
        &NameStrings,
        &ReferencedDomains,
        &LsaSids
        );
    if (Status != STATUS_SUCCESS) {
        goto exit;
    }

    //
    // get the local computer name
    //

    Size = sizeof(LocalComputerName);
    if (!GetComputerNameW( LocalComputerName, &Size )) {
        goto exit;
    }

    //
    // see if we are tring to set a local account
    //

    if (wcscmp( LocalComputerName, ReferencedDomains->Domains->Name.Buffer ) != 0) {

        //
        // see what part of the domain we are attempting to set
        //

        NetStatus = NetUserModalsGet( NULL, 1, (LPBYTE*) &Modals );
        if (NetStatus != NERR_Success) {
            goto exit;
        }

        if (Modals->usrmod1_role != UAS_ROLE_PRIMARY) {

            //
            // we know we are remote, so get the real dc name
            //

            NetStatus = NetGetDCName( NULL, DomainName, (LPBYTE*) &DCName );
            if (NetStatus != NERR_Success) {
                goto exit;
            }

            MachineName = StringDup( DCName );

        }
    }


exit:
    if (Modals) {
        NetApiBufferFree( Modals );
    }
    if (DCName) {
        NetApiBufferFree( DCName );
    }
    if (ReferencedDomains) {
        LsaFreeMemory( ReferencedDomains );
    }
    if (LsaSids) {
        LsaFreeMemory( LsaSids );
    }
    if (PolicyHandle) {
        LsaClose( PolicyHandle );
    }

    return MachineName;
}



DWORD
SetServiceSecurity(
    LPTSTR AccountName
    )
{
    LSA_HANDLE PolicyHandle;
    PSID pSid;
    NTSTATUS Status;
    int iRetVal=RTN_ERROR;
    LPWSTR MachineName;

    WCHAR   NewAccountName[512];
    WCHAR   wszAccountName[256];

    *wszAccountName = L'\0';

    #ifdef UNICODE
    wcscpy(wszAccountName,AccountName);
    #else
    MultiByteToWideChar(CP_ACP,
                        0,
                        AccountName, -1,
                        wszAccountName, sizeof(wszAccountName));
    #endif


    if (AccountName[0] == L'.') {
        if (GetDefaultDomainName( NewAccountName )) {
            wcscat( NewAccountName, &AccountName[1] );
            AccountName = NewAccountName;
        }
    }

    //
    // try to get the correct machine name
    //
    MachineName = GetMachineName( wszAccountName );

    //
    // Open the policy on the target machine.
    //
    Status = OpenPolicy(
        MachineName,
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &PolicyHandle
        );
    if (Status != STATUS_SUCCESS) {
        return RTN_ERROR;
    }

    //
    // Obtain the SID of the user/group.
    // Note that we could target a specific machine, but we don't.
    // Specifying NULL for target machine searches for the SID in the
    // following order: well-known, Built-in and local, primary domain,
    // trusted domains.
    //
    if(GetAccountSid(
            MachineName, // target machine
            AccountName,// account to obtain SID
            &pSid       // buffer to allocate to contain resultant SID
            )) {
        //
        // We only grant the privilege if we succeeded in obtaining the
        // SID. We can actually add SIDs which cannot be looked up, but
        // looking up the SID is a good sanity check which is suitable for
        // most cases.

        //
        // Grant the SeServiceLogonRight to users represented by pSid.
        //
        if((Status=SetPrivilegeOnAccount(
                    PolicyHandle,           // policy handle
                    pSid,                   // SID to grant privilege
                    L"SeServiceLogonRight", // Unicode privilege
                    TRUE                    // enable the privilege
                    )) == STATUS_SUCCESS) {
            iRetVal=RTN_OK;
        }
    }

    //
    // Close the policy handle.
    //
    LsaClose(PolicyHandle);

    //
    // Free memory allocated for SID.
    //
    if(pSid != NULL) MemFree(pSid);

    return iRetVal;
}


void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPTSTR String
    )
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

NTSTATUS
OpenPolicy(
    LPTSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPTSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

/*++
This function attempts to obtain a SID representing the supplied
account on the supplied system.

If the function succeeds, the return value is TRUE. A buffer is
allocated which contains the SID representing the supplied account.
This buffer should be freed when it is no longer needed by calling
HeapFree(GetProcessHeap(), 0, buffer)

If the function fails, the return value is FALSE. Call GetLastError()
to obtain extended error information.
--*/

BOOL
GetAccountSid(
    LPTSTR SystemName,
    LPTSTR AccountName,
    PSID *Sid
    )
{
    LPTSTR ReferencedDomain=NULL;
    DWORD cbSid=128;    // initial allocation attempt
    DWORD cbReferencedDomain=32; // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=FALSE; // assume this function will fail

    __try {

    //
    // initial memory allocations
    //
    if((*Sid=LocalAlloc(cbSid)) == NULL) {
        __leave;
    }

    if((ReferencedDomain=LocalAlloc(cbReferencedDomain)) == NULL) {
        __leave;
    }

    //
    // Obtain the SID of the specified account on the specified system.
    //
    while(!LookupAccountName(
                    SystemName,         // machine to lookup account on
                    AccountName,        // account to lookup
                    *Sid,               // SID of interest
                    &cbSid,             // size of SID
                    ReferencedDomain,   // domain account was found on
                    &cbReferencedDomain,
                    &peUse
                    )) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // reallocate memory
            //
            if((*Sid=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        *Sid,
                        cbSid
                        )) == NULL) __leave;

            if((ReferencedDomain=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        ReferencedDomain,
                        cbReferencedDomain
                        )) == NULL) __leave;
        }
        else __leave;
    }

    //
    // Indicate success.
    //
    bSuccess=TRUE;

    } // finally
    __finally {

    //
    // Cleanup and indicate failure, if appropriate.
    //

    LocalFree(ReferencedDomain);

    if(!bSuccess) {
        if(*Sid != NULL) {
            LocalFree(*Sid);
            *Sid = NULL;
        }
    }

    } // finally

    return bSuccess;
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPTSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\userdbg.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 2000

Module Name:

    userdbg.h

Abstract:

    Project dependent header for debug.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    user mode only

Notes:

Revision History:

--*/

#ifndef __USERDBG__
#define __USERDBG__

#include <setupapi.h>

typedef struct _DIF_DEBUG {
    DWORD DifValue;
    LPTSTR DifString;
} DIF_DEBUG, *PDIF_DEBUG;

const DIF_DEBUG DifDebug[] =
{
    { 0,                                    TEXT("")                                  },  //  0x00000000
    { DIF_SELECTDEVICE,                     TEXT("DIF_SELECTDEVICE"                 ) },  //  0x00000001
    { DIF_INSTALLDEVICE,                    TEXT("DIF_INSTALLDEVICE"                ) },  //  0x00000002
    { DIF_ASSIGNRESOURCES,                  TEXT("DIF_ASSIGNRESOURCES"              ) },  //  0x00000003
    { DIF_PROPERTIES,                       TEXT("DIF_PROPERTIES"                   ) },  //  0x00000004
    { DIF_REMOVE,                           TEXT("DIF_REMOVE"                       ) },  //  0x00000005
    { DIF_FIRSTTIMESETUP,                   TEXT("DIF_FIRSTTIMESETUP"               ) },  //  0x00000006
    { DIF_FOUNDDEVICE,                      TEXT("DIF_FOUNDDEVICE"                  ) },  //  0x00000007
    { DIF_SELECTCLASSDRIVERS,               TEXT("DIF_SELECTCLASSDRIVERS"           ) },  //  0x00000008
    { DIF_VALIDATECLASSDRIVERS,             TEXT("DIF_VALIDATECLASSDRIVERS"         ) },  //  0x00000009
    { DIF_INSTALLCLASSDRIVERS,              TEXT("DIF_INSTALLCLASSDRIVERS"          ) },  //  0x0000000A
    { DIF_CALCDISKSPACE,                    TEXT("DIF_CALCDISKSPACE"                ) },  //  0x0000000B
    { DIF_DESTROYPRIVATEDATA,               TEXT("DIF_DESTROYPRIVATEDATA"           ) },  //  0x0000000C
    { DIF_VALIDATEDRIVER,                   TEXT("DIF_VALIDATEDRIVER"               ) },  //  0x0000000D
    { DIF_MOVEDEVICE,                       TEXT("DIF_MOVEDEVICE"                   ) },  //  0x0000000E
    { DIF_DETECT,                           TEXT("DIF_DETECT"                       ) },  //  0x0000000F
    { DIF_INSTALLWIZARD,                    TEXT("DIF_INSTALLWIZARD"                ) },  //  0x00000010
    { DIF_DESTROYWIZARDDATA,                TEXT("DIF_DESTROYWIZARDDATA"            ) },  //  0x00000011
    { DIF_PROPERTYCHANGE,                   TEXT("DIF_PROPERTYCHANGE"               ) },  //  0x00000012
    { DIF_ENABLECLASS,                      TEXT("DIF_ENABLECLASS"                  ) },  //  0x00000013
    { DIF_DETECTVERIFY,                     TEXT("DIF_DETECTVERIFY"                 ) },  //  0x00000014
    { DIF_INSTALLDEVICEFILES,               TEXT("DIF_INSTALLDEVICEFILES"           ) },  //  0x00000015
    { DIF_UNREMOVE,                         TEXT("DIF_UNREMOVE"                     ) },  //  0x00000016
    { DIF_SELECTBESTCOMPATDRV,              TEXT("DIF_SELECTBESTCOMPATDRV"          ) },  //  0x00000017
    { DIF_ALLOW_INSTALL,                    TEXT("DIF_ALLOW_INSTAL"                 ) },  //  0x00000018
    { DIF_REGISTERDEVICE,                   TEXT("DIF_REGISTERDEVICE"               ) },  //  0x00000019
    { DIF_NEWDEVICEWIZARD_PRESELECT,        TEXT("DIF_NEWDEVICEWIZARD_PRESELECT"    ) },  //  0x0000001A
    { DIF_NEWDEVICEWIZARD_SELECT,           TEXT("DIF_NEWDEVICEWIZARD_SELECT"       ) },  //  0x0000001B
    { DIF_NEWDEVICEWIZARD_PREANALYZE,       TEXT("DIF_NEWDEVICEWIZARD_PREANALYZE"   ) },  //  0x0000001C
    { DIF_NEWDEVICEWIZARD_POSTANALYZE,      TEXT("DIF_NEWDEVICEWIZARD_POSTANALYZE"  ) },  //  0x0000001D
    { DIF_NEWDEVICEWIZARD_FINISHINSTALL,    TEXT("DIF_NEWDEVICEWIZARD_FINISHINSTALL") },  //  0x0000001E
    { DIF_UNUSED1,                          TEXT("DIF_UNUSED1"                      ) },  //  0x0000001F
    { DIF_INSTALLINTERFACES,                TEXT("DIF_INSTALLINTERFACES"            ) },  //  0x00000020
    { DIF_DETECTCANCEL,                     TEXT("DIF_DETECTCANCE"                  ) },  //  0x00000021
    { DIF_REGISTER_COINSTALLERS,            TEXT("DIF_REGISTER_COINSTALLERS"        ) },  //  0x00000022
    { DIF_ADDPROPERTYPAGE_ADVANCED,         TEXT("DIF_ADDPROPERTYPAGE_ADVANCED"     ) },  //  0x00000023
    { DIF_ADDPROPERTYPAGE_BASIC,            TEXT("DIF_ADDPROPERTYPAGE_BASIC"        ) },  //  0x00000024
    { DIF_RESERVED1,                        TEXT("DIF_RESERVED1"                    ) },  //  0x00000025
    { DIF_TROUBLESHOOTER,                   TEXT("DIF_TROUBLESHOOTER"               ) },  //  0x00000026
    { DIF_POWERMESSAGEWAKE,                 TEXT("DIF_POWERMESSAGEWAKE"             ) },  //  0x00000027
    { 0,                                    TEXT("")                                  }   //  0x00000028
};


const TCHAR  *szInstallOpNames[] = {
    TEXT("SPFILENOTIFY_UNKNOWN            "), // 0x00000000
    TEXT("SPFILENOTIFY_STARTQUEUE         "), // 0x00000001
    TEXT("SPFILENOTIFY_ENDQUEUE           "), // 0x00000002
    TEXT("SPFILENOTIFY_STARTSUBQUEUE      "), // 0x00000003
    TEXT("SPFILENOTIFY_ENDSUBQUEUE        "), // 0x00000004
    TEXT("SPFILENOTIFY_STARTDELETE        "), // 0x00000005
    TEXT("SPFILENOTIFY_ENDDELETE          "), // 0x00000006
    TEXT("SPFILENOTIFY_DELETEERROR        "), // 0x00000007
    TEXT("SPFILENOTIFY_STARTRENAME        "), // 0x00000008
    TEXT("SPFILENOTIFY_ENDRENAME          "), // 0x00000009
    TEXT("SPFILENOTIFY_RENAMEERROR        "), // 0x0000000a
    TEXT("SPFILENOTIFY_STARTCOPY          "), // 0x0000000b
    TEXT("SPFILENOTIFY_ENDCOPY            "), // 0x0000000c
    TEXT("SPFILENOTIFY_COPYERROR          "), // 0x0000000d
    TEXT("SPFILENOTIFY_NEEDMEDIA          "), // 0x0000000e
    TEXT("SPFILENOTIFY_QUEUESCAN          ") // 0x0000000f
};


#endif //  __USERDBG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\util.cpp ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Util.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Utility function for WIA class installer.
*
*   NOTE:
*   All of string buffers dealt in these functions must have at least
*   MAX_DESCRIPTION size. Since it doesn't have size check of buffer, it assumes
*   all string size is unfer MAX_DESCRIPTION, which must be OK to be used only
*   for WIA class installer.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"
#include <regstr.h>
#include <cfgmgr32.h>

//
// Extern
//

extern HINSTANCE g_hDllInstance;

//
// Function
//

BOOL
GetInfInforamtionFromSelectedDevice(
    HDEVINFO    hDevInfo,
    LPTSTR      pInfFileName,
    LPTSTR      pInfSectionName
    )
{
    BOOL                    bRet;

    SP_DEVINFO_DATA         DeviceInfoData;
    SP_DRVINFO_DATA         DriverInfoData;
    SP_DRVINFO_DETAIL_DATA  DriverInfoDetailData;
    HINF                    hInf;

    TCHAR                   szInfFileName[MAX_DESCRIPTION];
    TCHAR                   szInfSectionName[MAX_DESCRIPTION];

    DebugTrace(TRACE_PROC_ENTER,(("GetInfInforamtionFromSelectedDevice: Enter... \r\n")));

    hInf    = INVALID_HANDLE_VALUE;
    bRet    = FALSE;

    //
    // Check arguments.
    //

    if( (NULL == hDevInfo)
     || (NULL == pInfFileName)
     || (NULL == pInfSectionName) )
    {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! Invalid argument. \r\n")));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Initialize locals.
    //

    memset (&DeviceInfoData, 0, sizeof(SP_DEVINFO_DATA));
    memset (&DriverInfoData, 0, sizeof(SP_DRVINFO_DATA));
    memset (&DriverInfoDetailData, 0, sizeof(SP_DRVINFO_DETAIL_DATA));
    memset (szInfFileName, 0, sizeof(szInfFileName));
    memset (szInfSectionName, 0, sizeof(szInfSectionName));

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    //
    // Get selected device element.
    //

    if (!SetupDiGetSelectedDevice (hDevInfo, &DeviceInfoData)) {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetSelectedDevice Failed. Err=0x%lX\r\n"), GetLastError()));
        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Get selected device driver information.
    //

    if (!SetupDiGetSelectedDriver(hDevInfo, &DeviceInfoData, &DriverInfoData)) {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetSelectedDriver Failed. Err=0x%lX\r\n"), GetLastError()));
        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Get detailed data of selected device driver.
    //

    if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                   &DeviceInfoData,
                                   &DriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL) )
    {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetDriverInfoDetail Failed.Er=0x%lX\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Copy INF filename.
    //

    _tcsncpy(szInfFileName, DriverInfoDetailData.InfFileName, sizeof(szInfFileName)/sizeof(TCHAR));

    //
    // Open INF file of selected driver.
    //

    hInf = SetupOpenInfFile(szInfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupOpenInfFile Failed.Er=0x%lX\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Get actual INF section name to be installed.
    //

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          DriverInfoDetailData.SectionName,
                                          szInfSectionName,
                                          sizeof(szInfSectionName)/sizeof(TCHAR),
                                          NULL,
                                          NULL) )
    {
        DebugTrace(TRACE_ERROR,(("GetInfInforamtionFromSelectedDevice: ERROR!! SetupDiGetActualSectionToInstall Failed.Er=0x%lX\r\n"),GetLastError()));

        bRet = FALSE;
        goto GetInfInforamtionFromSelectedDevice_return;
    }

    //
    // Copy strings to given buffer.
    //

    _tcsncpy(pInfFileName, szInfFileName, sizeof(szInfFileName)/sizeof(TCHAR));
    _tcsncpy(pInfSectionName, szInfSectionName, sizeof(szInfSectionName)/sizeof(TCHAR));

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetInfInforamtionFromSelectedDevice_return:

    if(INVALID_HANDLE_VALUE != hInf){
        SetupCloseInfFile(hInf);
    }

    DebugTrace(TRACE_PROC_LEAVE,(("GetInfInforamtionFromSelectedDevice: Leaving... Ret=0x%x\n"), bRet));
    return bRet;
}

BOOL
GetStringFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPTSTR   pBuffer
    )
{
    BOOL    bRet;
    LONG    lError;
    DWORD   dwSize;
    DWORD   dwType;
    TCHAR   szString[MAX_DESCRIPTION];

    //
    // Initialize local.
    //

    bRet        = FALSE;
    lError      = ERROR_SUCCESS;
    dwSize      = sizeof(szString);
    memset(szString, 0, sizeof(szString));

    //
    // Check arguments.
    //

    if( (NULL == hkRegistry)
     || (NULL == szValueName)
     || (NULL == pBuffer) )
    {
        DebugTrace(TRACE_ERROR,(("GetStringFromRegistry: ERROR!! Invalid argument\r\n")));

        bRet = FALSE;
        goto GetStringFromRegistry_return;
    }

    //
    // Get specified string from registry.
    //

    lError = RegQueryValueEx(hkRegistry,
                             szValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)szString,
                             &dwSize);
    if(ERROR_SUCCESS != lError){
        DebugTrace(TRACE_ERROR,(("GetStringFromRegistry: ERROR!! RegQueryValueEx failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto GetStringFromRegistry_return;
    }

    //
    // Make sure NULL termination.
    //

    szString[ARRAYSIZE(szString)-1] = TEXT('\0');

    //
    // Copy acquired string to given buffer. This function assume max-string/bufer size is MAX_DESCRIPTION.
    //

    _tcsncpy(pBuffer, szString, MAX_DESCRIPTION);

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetStringFromRegistry_return:
    return bRet;
}

BOOL
GetDwordFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPDWORD pdwValue
    )
{
    BOOL    bRet;
    LONG    lError;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwValue;

    //
    // Initialize local.
    //

    bRet        = FALSE;
    lError      = ERROR_SUCCESS;
    dwSize      = sizeof(dwValue);
    dwValue     = 0;

    //
    // Check arguments.
    //

    if( (NULL == hkRegistry)
     || (NULL == szValueName)
     || (NULL == pdwValue) )
    {
        DebugTrace(TRACE_ERROR,(("GetDwordFromRegistry: ERROR!! Invalid argument\r\n")));

        bRet = FALSE;
        goto GetDwordFromRegistry_return;
    }

    //
    // Get specified string from registry.
    //

    lError = RegQueryValueEx(hkRegistry,
                             szValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)&dwValue,
                             &dwSize);
    if(ERROR_SUCCESS != lError){
        DebugTrace(TRACE_ERROR,(("GetDwordFromRegistry: ERROR!! RegQueryValueEx failed. Err=0x%x. Size=0x%x, Type=0x%x\r\n"), lError, dwSize, dwType));

        bRet = FALSE;
        goto GetDwordFromRegistry_return;
    }

    //
    // Copy acquired DWORD value to given buffer.
    //

    *pdwValue = dwValue;

    //
    // Operation succeeded.
    //

    bRet = TRUE;

GetDwordFromRegistry_return:
    return bRet;
} // GetDwordFromRegistry

VOID
SetRunonceKey(
    LPTSTR  szValue,
    LPTSTR  szData
    )
{
    HKEY    hkRun;
    LONG    lResult;
    CString csData;

    //
    // Initialize local.
    //

    hkRun   = NULL;
    lResult = ERROR_SUCCESS;
    csData  = szData;

    //
    // Get RUNONCE regkey.
    //

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           REGSTR_PATH_RUNONCE,
                           0,
                           KEY_READ | KEY_WRITE,
                           &hkRun);
    if(ERROR_SUCCESS == lResult){
        csData.Store(hkRun, szValue);
        RegCloseKey(hkRun);
    } // if(ERROR_SUCCESS == lResult)
} // SetRunonceKey()

VOID
ShowInstallerMessage(
    DWORD   dwMessageId
    )
{
    CString     csTitle;
    CString     csText;

    csTitle.FromTable (MessageTitle);
    csText.FromTable ((unsigned)dwMessageId);

    if( !csTitle.IsEmpty() && !csText.IsEmpty()){
        MessageBox (GetActiveWindow(),
                    csText,
                    csTitle,
                    MB_ICONINFORMATION | MB_OK);
    } // if(csTitle.IsEmpty() || csText.IsEmpty())

} // ShowInstallerMessage()

BOOL
IsWindowsFile(
    LPTSTR  szFileName
    )
{
    BOOL    bRet;
    DWORD   dwNumberOfChar;
    TCHAR   szLayoutInfpath[MAX_PATH+1];
    TCHAR   szReturnBuffer[MAX_PATH];
    TCHAR   *pszFileNameWithoutPath;
    DWORD   Idx;

    DebugTrace(TRACE_PROC_ENTER,("IsWindowsFile: Enter... Checking %ws.\r\n", szFileName));

    //
    // Initialize local.
    //

    bRet                    = FALSE;
    dwNumberOfChar          = 0;
    Idx                     = 0;
    pszFileNameWithoutPath  = NULL;

    memset(szLayoutInfpath, 0, sizeof(szLayoutInfpath));

    //
    // Get INF filename without path.
    //

    while(TEXT('\0') != szFileName[Idx]){
        if(TEXT('\\') == szFileName[Idx]){
            pszFileNameWithoutPath = &(szFileName[Idx+1]);
        } // if('\\' == szFileName[Idx])
        Idx++;
    } // while('\0' != szFileName[Idx])

    //
    // Get system directory.
    //

    if(0 == GetWindowsDirectory(szLayoutInfpath, sizeof(szLayoutInfpath)/sizeof(TCHAR))){
        DebugTrace(TRACE_ERROR,("IsWindowsFile: ERROR!! GetWindowsDirectory failed. Err=0x%x.\r\n", GetLastError()));

        bRet = FALSE;
        goto IsWindowsFile_return;
    } // if(0 == GetWindowsDirectory(szSystemDir, sizeof(szSystemDir)/sizeof(TCHAR)))

    //
    // Create fullpath of layout.inf.
    //

    lstrcat(szLayoutInfpath, LAYOUT_INF_PATH);
    DebugTrace(TRACE_STATUS,("IsWindowsFile: Looking for \'%ws\' in %ws.\r\n", pszFileNameWithoutPath, szLayoutInfpath));

    //
    // See if provided filename is in layout.inf.
    //

    dwNumberOfChar = GetPrivateProfileString(SOURCEDISKFILES,
                                             pszFileNameWithoutPath,
                                             NULL,
                                             szReturnBuffer,
                                             sizeof(szReturnBuffer) / sizeof(TCHAR),
                                             szLayoutInfpath);
    if(0 == dwNumberOfChar){

        //
        // Filename doesn't exist in layout.inf.
        //

        bRet = FALSE;
        goto IsWindowsFile_return;

    } // if(0 == dwNumberOfChar)

    //
    // This filename exists in layout.inf.
    //

    bRet = TRUE;

IsWindowsFile_return:

    DebugTrace(TRACE_PROC_LEAVE,("IsWindowsFile: Leaving... Ret=0x%x\n", bRet));

    return bRet;

} // IsWindowsFile()

BOOL
IsProviderMs(
    LPTSTR  szInfName
    )
{

    BOOL                bRet;
    DWORD               dwSize;
    TCHAR               szProvider[MAX_PATH+1];
    PSP_INF_INFORMATION pspInfInfo;

    DebugTrace(TRACE_PROC_ENTER,("IsProviderMs: Enter... Checking %ws.\r\n", szInfName));

    //
    // Initialize local.
    //

    bRet        = FALSE;
    dwSize      = 0;
    pspInfInfo  = NULL;

    memset(szProvider, 0, sizeof(szProvider));
    
    //
    // Get INF information size.
    //

    SetupGetInfInformation(szInfName,
                           INFINFO_INF_NAME_IS_ABSOLUTE,
                           NULL,
                           0,
                           &dwSize);
    if(0 == dwSize){
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! Enable to get required size for INF info. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(0 == dwSize)

    //
    // Allocate buffer for INF information.
    //

    pspInfInfo = (PSP_INF_INFORMATION) new char[dwSize];
    if(NULL == pspInfInfo){
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! Insuffisient memory.\r\n")));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(NULL == pspInfInfo)

    //
    // Get actual INF informaton.
    //

    if(!SetupGetInfInformation(szInfName,
                               INFINFO_INF_NAME_IS_ABSOLUTE,
                               pspInfInfo,
                               dwSize,
                               &dwSize))
    {
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! Unable to get Inf info. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(!SetupGetInflnformation()

    //
    // Query "Provider" of given INF.
    //

    if(!SetupQueryInfVersionInformation(pspInfInfo,
                                        0,
                                        PROVIDER,
                                        szProvider,
                                        ARRAYSIZE(szProvider)-1,
                                        &dwSize))
    {
        DebugTrace(TRACE_ERROR,(("IsProviderMs: ERROR!! SetupQueryInfVersionInformation() failed. Err=0x%x.\r\n"), GetLastError()));

        bRet = FALSE;
        goto IsProviderMs_return;
    } // if(!SetupGetInflnformation()

    //
    // See if provider is "Microsoft"
    //
    
    DebugTrace(TRACE_STATUS,(("IsProviderMs: Provider = \'%ws\'.\r\n"), szProvider));
    if(0 == MyStrCmpi(szProvider, MICROSOFT)){
        
        //
        // This INF file has 'Provider = "Microsoft"'
        //

        bRet = TRUE;

    } // if(0 == lstrcmp(szProvider, MICROSOFT))

IsProviderMs_return:
    
    if(NULL != pspInfInfo){
        delete[] pspInfInfo;
    } // if(NULL != pspInfInfo)

    DebugTrace(TRACE_PROC_LEAVE,("IsProviderMs: Leaving... Ret=0x%x\n", bRet));

    return bRet;

} // IsProviderMs()

BOOL
IsIhvAndInboxExisting(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pDevInfoData
    )
{

    BOOL                    bRet;
    BOOL                    bIhvExists;
    BOOL                    bInboxExists;
    DWORD                   dwLastError;
    DWORD                   dwSize;
    DWORD                   Idx;
    SP_DRVINSTALL_PARAMS    spDriverInstallParams;
    SP_DRVINFO_DATA         spDriverInfoData;
    PSP_DRVINFO_DETAIL_DATA pspDriverInfoDetailData;

    //
    // Initialize local.
    //

    bRet                    = FALSE;
    bIhvExists              = FALSE;
    bInboxExists            = FALSE;
    dwSize                  = 0;
    Idx                     = 0;
    dwLastError             = ERROR_SUCCESS;
    pspDriverInfoDetailData = NULL;

    memset(&spDriverInstallParams, 0, sizeof(spDriverInstallParams));

    //
    // Get driver info.
    //

    memset(&spDriverInfoData, 0, sizeof(spDriverInfoData));
    spDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData); Idx++){

        //
        // Get driver install params.
        //

        memset(&spDriverInstallParams, 0, sizeof(spDriverInstallParams));
        spDriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams)){
            DebugTrace(TRACE_ERROR,("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInstallParams() failed LastError=0x%x.\r\n", GetLastError()));
            goto IsIhvAndInboxExisting_return;
        } // if(!SetupDiGetDriverInstallParams(hDevInfo, pDevInfoData, &spDriverInfoData, &spDriverInstallParams))

        //
        // Get buffer size required for driver derail data.
        //

        dwSize = 0;
        SetupDiGetDriverInfoDetail(hDevInfo,
                                   pDevInfoData,
                                   &spDriverInfoData,
                                   NULL,
                                   0,
                                   &dwSize);
        dwLastError = GetLastError();
        if(ERROR_INSUFFICIENT_BUFFER != dwLastError){
            DebugTrace(TRACE_ERROR,(("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInfoDetail() doesn't return required size.Er=0x%x\r\n"),dwLastError));
            goto IsIhvAndInboxExisting_return;
        } // if(ERROR_INSUFFICIENT_BUFFER != dwLastError)
                    
        //
        // Allocate required size of buffer for driver detailed data.
        //

        pspDriverInfoDetailData   = (PSP_DRVINFO_DETAIL_DATA)new char[dwSize];
        if(NULL == pspDriverInfoDetailData){
            DebugTrace(TRACE_ERROR,(("IsIhvAndInboxExisting: ERROR!! Unable to allocate driver detailed info buffer.\r\n")));
            goto IsIhvAndInboxExisting_return;
        } // if(NULL == pspDriverInfoDetailData)

        //
        // Initialize allocated buffer.
        //

        memset(pspDriverInfoDetailData, 0, dwSize);
        pspDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                
        //
        // Get detailed data of selected device driver.
        //

        if(!SetupDiGetDriverInfoDetail(hDevInfo,
                                       pDevInfoData,
                                       &spDriverInfoData,
                                       pspDriverInfoDetailData,
                                       dwSize,
                                       NULL) )
        {
            DebugTrace(TRACE_ERROR,("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInfoDetail() failed LastError=0x%x.\r\n", GetLastError()));

            delete[] pspDriverInfoDetailData;
            pspDriverInfoDetailData = NULL;
            continue;
        } // if(NULL == pspDriverInfoDetailData)

        //
        // See if INF filename is valid.
        //

        if(NULL == pspDriverInfoDetailData->InfFileName){
            DebugTrace(TRACE_ERROR,("IsIhvAndInboxExisting: ERROR!! SetupDiGetDriverInfoDetail() returned invalid INF name.\r\n"));
            delete[] pspDriverInfoDetailData;
            pspDriverInfoDetailData = NULL;
            continue;
        } // if(NULL == pspDriverInfoDetailData->InfFileName)

        //
        // If it's Inbox driver, lower the lank.
        //

        if( IsWindowsFile(pspDriverInfoDetailData->InfFileName) 
         && IsProviderMs(pspDriverInfoDetailData->InfFileName ) )
        {

            //
            // This is inbox INF.
            //
            
            bInboxExists = TRUE;

        } else { // if(IsWindowsFilw() && IsProviderMs())

            //
            // This is IHV INF.
            //
            
            bIhvExists = TRUE;
        }
        //
        // Clean up.
        //
                    
        delete[] pspDriverInfoDetailData;
        pspDriverInfoDetailData = NULL;

    } // for(Idx = 0; SetupDiEnumDriverInfo(hDevInfo, pDevInfoData, SPDIT_COMPATDRIVER, Idx, &spDriverInfoData), Idx++)
IsIhvAndInboxExisting_return:

    if( (TRUE == bInboxExists)
     && (TRUE == bIhvExists) )
    {
        bRet = TRUE;
    } else { // if(bInboxExists && bIhvExists)
        bRet = FALSE;
    } //  else // if(bInboxExists && bIhvExists)

    DebugTrace(TRACE_PROC_LEAVE,("IsIhvAndInboxExisting: Leaving... Ret=0x%x\n", bRet));
    return bRet;
} // IsProviderMs()

CInstallerMutex::CInstallerMutex(
    HANDLE* phMutex, 
    LPTSTR szMutexName, 
    DWORD dwTimeout
    )
{
    m_bSucceeded    = FALSE;
    m_phMutex       = phMutex;

    _try {
        *m_phMutex = CreateMutex(NULL, FALSE, szMutexName);
        if(NULL != *m_phMutex){

            //
            // Wait until ownership is acquired.
            //

            switch(WaitForSingleObject(*m_phMutex, dwTimeout)){
                case WAIT_ABANDONED:
                    DebugTrace(TRACE_ERROR, ("CInstallerMutex: ERROR!! Wait abandoned.\r\n"));
                    m_bSucceeded = TRUE;
                    break;

                case WAIT_OBJECT_0:
                    DebugTrace(TRACE_STATUS, ("CInstallerMutex: Mutex acquired.\r\n"));
                    m_bSucceeded = TRUE;
                    break;

                case WAIT_TIMEOUT:
                    DebugTrace(TRACE_WARNING, ("CInstallerMutex: WARNING!! Mutex acquisition timeout.\r\n"));
                    break;

                default:
                    DebugTrace(TRACE_ERROR, ("CInstallerMutex: ERROR!! Unexpected error from WaitForSingleObjecct().\r\n"));
                    break;
            } // switch(dwReturn)
        } // if(NULL != *m_phMutex)
    }
    _except (EXCEPTION_EXECUTE_HANDLER) {
         DebugTrace(TRACE_ERROR, ("CInstallerMutex: ERROR!! Unexpected exception.\r\n"));
    }
} // CInstallerMutex::CInstallerMutex()

CInstallerMutex::~CInstallerMutex(
    ) 
{
    if (m_bSucceeded) {
        ReleaseMutex(*m_phMutex);
        DebugTrace(TRACE_STATUS, ("CInstallerMutex: Mutex released.\r\n"));
    }
    if(NULL != *m_phMutex){
        CloseHandle(*m_phMutex);
    } // if(NULL != *m_phMutex)

} // CInstallerMutex::~CInstallerMutex(

HFONT 
GetIntroFont(
    HWND hwnd
    )
{
    static  HFONT   _hfontIntro = NULL;
    static  int     iDevCap = 0;

    if ( !_hfontIntro ){
        TCHAR               szBuffer[64];
        NONCLIENTMETRICS    ncm = { 0 };
        LOGFONT             lf;
        CString             csSize;
        HDC                 hDC = (HDC)NULL;

        hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        if(NULL != hDC){
        
            iDevCap = GetDeviceCaps(hDC, LOGPIXELSY);
            ncm.cbSize = sizeof(ncm);
            SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

            lf = ncm.lfMessageFont;
            if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTNAME, lf.lfFaceName, (sizeof(lf.lfFaceName)/sizeof(TCHAR)))){
                lf.lfWeight = FW_BOLD;
                
                if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTSIZE, szBuffer, (sizeof(szBuffer)/sizeof(TCHAR)))){
                    csSize = szBuffer;
                    lf.lfHeight = 0 - (iDevCap * (DWORD)csSize.Decode() / 72);

                    _hfontIntro = CreateFontIndirect(&lf);
                } // if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTSIZE, szBuffer, (sizeof(szBuffer)/sizeof(TCHAR))))
            } // if(0 != LoadString(g_hDllInstance, IDS_TITLEFONTNAME, lf.lfFaceName, (sizeof(lf.lfFaceName)/sizeof(TCHAR))))
            
            DeleteDC(hDC);

        } else { // if(NULL != hDC)
            DebugTrace(TRACE_ERROR, ("GetIntroFont: ERROR!! Unable to create DC.Err=0x%x.\r\n",GetLastError()));
        } // else(NULL != hDC)
    }
    return _hfontIntro;
} // GetIntroFont()

BOOL
IsDeviceRootEnumerated(
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData
    )
{
    CONFIGRET   cmRetCode;
    BOOL        bRet;
    ULONG       ulStatus;
    ULONG       ulProblem;
    

    DebugTrace(TRACE_PROC_ENTER,("IsDeviceRootEnumerated: Enter... \r\n"));

    //
    // Initialize local.
    //

    cmRetCode   = CR_SUCCESS;
    bRet        = FALSE;
    ulStatus    = 0;
    ulProblem   = 0;


    //
    // Devnode Status.
    //
    
    cmRetCode = CM_Get_DevNode_Status(&ulStatus,
                                      &ulProblem,
                                      pDevInfoData->DevInst,
                                      0);

    if(CR_SUCCESS != cmRetCode){
        
        //
        // Unable to get devnode status.
        //

        DebugTrace(TRACE_ERROR,("IsDeviceRootEnumerated: ERROR!! Unable to get Devnode status. CR=0x%x.\r\n", cmRetCode));

        bRet = FALSE;
        goto IsDeviceRootEnumerated_return;

    } // if(CD_SUCCESS != cmRetCode)

    //
    // See if it's root-enumerated.
    //

    if(DN_ROOT_ENUMERATED & ulStatus){
        
        //
        // This devnode is root-enumerated.
        //

        bRet = TRUE;

    } // if(DN_ROOT_ENUMERATED & ulStatus)

IsDeviceRootEnumerated_return:
    
    DebugTrace(TRACE_PROC_LEAVE,("IsDeviceRootEnumerated: Leaving... Ret=0x%x.\r\n", bRet));
    return bRet;

} // IsDeviceRootEnumerated()


int
MyStrCmpi(
    LPCTSTR str1,
    LPCTSTR str2
    )
{
    int iRet;
    
    //
    // Initialize local.
    //
    
    iRet = 0;
    
    //
    // Compare string.
    //
    
    if(CSTR_EQUAL == CompareString(LOCALE_INVARIANT,
                                   NORM_IGNORECASE, 
                                   str1, 
                                   -1,
                                   str2,
                                   -1) )
    {
        iRet = 0;
    } else {
        iRet = -1;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\sti_ci.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       sti_ci.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Generic header file for WIA class installer.
*
*******************************************************************************/

#ifndef _STI_CI_H_
#define _STI_CI_H_

//
// Include
//

#include <windows.h>
#include <windowsx.h>
#include <assert.h>
#include <tchar.h>
#include <setupapi.h>


#include "resource.h"
#include "cistr.h"
#include "debug.h"

//
// Define
//


#define ID_AUTO                 -1
#define NUM_WIA_PAGES           5
#define MAX_DATA_SECTION        512*sizeof(TCHAR)
#define MAX_DESCRIPTION         64*sizeof(TCHAR)
#define MAX_FRIENDLYNAME        64
#define MAX_DEVICE_ID           64
#define MAX_COMMANDLINE         256
#define MAX_STRING_LENGTH       1024
#define MAX_MUTEXTIMEOUT        60*1000              // 60 Sec
#define MANUAL_INSTALL_MASK     100

#define INVALID_DEVICE_INDEX    -1

#define MONITOR_NAME            TEXT("STIMON.EXE")
#define RUNDLL32                TEXT("RUNDLL32.EXE")
#define STILL_IMAGE             TEXT("StillImage")
#define FRIENDLYNAME            TEXT("FriendlyName")
#define VENDORSETUP             TEXT("VendorSetup")
#define DEVICESECTION           TEXT("DeviceData")
#define PORTNAME                TEXT("PortName")
#define DEVICETYPE              TEXT("DeviceType")
#define DEVICESUBTYPE           TEXT("DeviceSubType")
#define DRIVERDESC              TEXT("DriverDesc")
#define DESCRIPTION             TEXT("Description")
#define CREATEFILENAME          TEXT("CreateFileName")
#define CAPABILITIES            TEXT("Capabilities")
#define EVENTS                  TEXT("Events")
#define WIASECTION              TEXT("WiaSection")
#define PROPERTYPAGES           TEXT("PropertyPages")
#define VENDOR                  TEXT("Vendor")
#define UNINSTALLSECTION        TEXT("UninstallSection")
#define SUBCLASS                TEXT("SubClass")
#define ICMPROFILES             TEXT("ICMProfiles")
#define INFPATH                 TEXT("InfPath")
#define INFSECTION              TEXT("InfSection")
#define ISPNP                   TEXT("IsPnP")
#define USDCLASS                TEXT("USDClass")
#define LPTENUM                 TEXT("LptEnum")
#define ENUM                    TEXT("\\Enum")
#define PORTS                   TEXT("Ports")
#define DONT_LOAD               TEXT("don't load")
#define CONTROL_INI             TEXT("control.ini")
#define CPL_NAME                TEXT("sticpl.cpl")
#define NO                      TEXT("no")
#define LAUNCH_APP              TEXT("LaunchApplications")
#define SZ_GUID                 TEXT("GUID")
#define CONNECTION              TEXT("Connection")
#define SERIAL                  TEXT("Serial")
#define PARALLEL                TEXT("Parallel")
#define BOTH                    TEXT("Both")
#define AUTO                    TEXT("AUTO")
#define VIDEO_PATH_ID           TEXT("DShowDeviceId")
#define DEVICESECTION           TEXT("DeviceData")
#define WIAACMGR_PATH           TEXT("wiaacmgr.exe")
#define WIAACMGR_ARG            TEXT("-SelectDevice")
#define WIADEVLISTMUTEX         TEXT("WiaDeviceListMutex")
#define WIA_GUIDSTRING          TEXT("{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}")
#define STI_CI32_ENTRY_WIZMANU  TEXT("sti_ci.dll,WiaCreateWizardMenu")
#define LAYOUT_INF_PATH         TEXT("\\inf\\layout.inf")
#define SOURCEDISKFILES         TEXT("SourceDisksFiles")
#define PROVIDER                TEXT("Provider")
#define MICROSOFT               TEXT("Microsoft")
#define PORTSELECT              TEXT("PortSelect")
#define WIAINSTALLERMUTEX       TEXT("WiaInstallerMutex")
#define WIAINSTALLWIZMUTEX      TEXT("WiaInstallWizMutex")
#define WIAINSTALLERFILENAME    TEXT("sti_ci.dll")
#define WIAWIZARDCHORCUTNAME    TEXT("Scanner and Camera Wizard")
#define MESSAGE1                TEXT("Message1")
#define NEWDEVDLL               TEXT("newdev.dll")

#define BUTTON_NOT_PUSHED       0
#define BUTTON_NEXT             1
#define BUTTON_BACK             2

#define PORTSELMODE_NORMAL      0
#define PORTSELMODE_SKIP        1
#define PORTSELMODE_MESSAGE1    2

#ifndef DLLEXPORT
#define DLLEXPORT               __declspec(dllexport)
#endif // DLLEXPORT


//
// Registry Paths
//

#define REGKEY_DEVICE_PARMS             TEXT("Device Parameters")
#define REGKEY_CONTROLINIFILEMAPPING    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\control.ini")
#define REGSTR_VAL_FRIENDLY_NAME        TEXT("FriendlyName")
#define REGSTR_VAL_FRIENDLY_NAME_A      "FriendlyName"
#define REGSTR_VAL_DEVICE_ID            TEXT("DeviceID")
#define REGSTR_VAL_WIZMENU              TEXT("WIAWizardMenu")

#define REGKEY_WIASHEXT                 TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\DelegateFolders\\{E211B736-43FD-11D1-9EFB-0000F8757FCD}")
#define REGKEY_INSTALL_NAMESTORE        TEXT("SYSTEM\\CurrentControlSet\\Control\\StillImage\\DeviceNameStore")
#define REGSTR_VAL_WIASHEXT             TEXT("Scanners & Cameras")

//
// Migration
//

#define NAME_BEGIN_A                "BEGIN"
#define NAME_BEGIN_W                L"BEGIN"
#define NAME_END_A                  "END"
#define NAME_END_W                  L"END"

//
// Macro
//

#ifdef UNICODE
 #define AtoT(_d_, _s_)  MultiByteToWideChar(CP_ACP, 0, _s_, -1, _d_, MAX_FRIENDLYNAME+1);
#else // UNICODE
 #define AtoT(_d_, _s_)
#endif // UNICODE


#define IS_VALID_HANDLE(h)  (((h) != NULL) && ((h) != INVALID_HANDLE_VALUE))

#ifndef ARRAYSIZE
 #define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif


//
// Struct
//

typedef struct  _INSTALLER_CONTEXT {

    HDEVINFO            hDevInfo;
    SP_DEVINFO_DATA     spDevInfoData;
    HWND                hwndWizard;

    PVOID               pFirstPage;
    PVOID               pPrevSelectPage;
    PVOID               pPortSelectPage;
    PVOID               pNameDevicePage;
    PVOID               pFinalPage;
    PVOID               pDevice;

    BOOL                bShowFirstPage;
    BOOL                bCalledFromControlPanal;
    UCHAR               szPortName[MAX_DESCRIPTION];

} INSTALLER_CONTEXT, *PINSTALLER_CONTEXT;


// For migration.
typedef struct  _PARAM_LIST {
    PVOID           pNext;
    LPSTR           pParam1;
    LPSTR           pParam2;
} PARAM_LIST, *PPARAM_LIST;

typedef struct  _DEVICE_INFO {

    LPSTR           pszFriendlyName;
    LPSTR           pszCreateFileName;
    LPSTR           pszInfPath;
    LPSTR           pszInfSection;

    DWORD           dwNumberOfDeviceDataKey;
    PPARAM_LIST     pDeviceDataParam;
} DEVICE_INFO, *PDEVICE_INFO;



//
// Prototype
//

BOOL
GetInfInforamtionFromSelectedDevice(
    HDEVINFO    hDevInfo,
    LPTSTR      pInfFileName,
    LPTSTR      pInfSectionName
    );

BOOL
GetStringFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPTSTR  pBuffer
    );

BOOL
GetDwordFromRegistry(
    HKEY    hkRegistry,
    LPCTSTR szValueName,
    LPDWORD pdwValue
    );

VOID
ShowInstallerMessage(
    DWORD   dwMessageId
    );

VOID
SetRunonceKey(
    LPTSTR  szValue,
    LPTSTR  szData
    );
DWORD
DecodeHexA(
    LPSTR   lpstr
    );

BOOL
IsWindowsFile(
    LPTSTR  szFileName
    );

BOOL
IsProviderMs(
    LPTSTR  szInfName
    );

BOOL
IsIhvAndInboxExisting(
    HDEVINFO            hDevInfo,
    PSP_DEVINFO_DATA    pDevInfoData
    );

BOOL
IsNameAlreadyStored(
    LPTSTR  szName
    );

HFONT
GetIntroFont(
    HWND hwnd
    );

BOOL
IsDeviceRootEnumerated(
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData
    );

int
MyStrCmpi(
    LPCTSTR str1,
    LPCTSTR str2
    );

// from entry.cpp
extern "C"
DWORD
APIENTRY
CoinstallerEntry(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    );

DWORD
APIENTRY
CoinstallerPreProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    );

DWORD
APIENTRY
CoinstallerPostProcess(
    IN  DI_FUNCTION                     diFunction,
    IN  HDEVINFO                        hDevInfo,
    IN  PSP_DEVINFO_DATA                pDevInfoData,
    IN  OUT PCOINSTALLER_CONTEXT_DATA   pCoinstallerContext
    );


//
// Class
//

class CInstallerMutex {

private:
    HANDLE              *m_phMutex;
    BOOL                m_bSucceeded;

public:

    CInstallerMutex(HANDLE* phMutex, LPTSTR szMutexName, DWORD dwTimeout);
    ~CInstallerMutex();

    inline BOOL Succeeded() {
        return m_bSucceeded;
    }
};

#endif // _STI_CI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     StillImage class installer
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=sti_ci
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

TARGETEXT=dll
DLLENTRY=_DllMainCRTStartup
COFFBASE=usermode

#
# Make sure we pick up the latest versions of things
#
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)

#
# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
#
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

#
# Includes
#
INCLUDES = $(INCLUDES);\
    $(BASEDIR)\public\internal\shell\inc;


DLLDEF=..\sti_ci.def

SOURCES=                \
        ..\wizpage.cpp  \
        ..\prevpg.cpp   \
        ..\string.cpp   \
        ..\nameit.cpp   \
        ..\firstpg.cpp  \
        ..\finalpg.cpp  \
        ..\debug.cpp    \
        ..\service.cpp  \
        ..\util.cpp     \
        ..\portsel.cpp  \
        ..\exports.cpp  \
        ..\device.cpp   \
        ..\entry.cpp    \
        ..\sti_ci.rc



TARGETLIBS= $(TARGETLIBS) \
            $(SHELL_LIB_PATH)\shfusion.lib      \
            $(SDK_LIB_PATH)\shell32.lib         \
            $(SDK_LIB_PATH)\mscms.lib           \
            $(SDK_LIB_PATH)\oldnames.lib        \
            $(WIA_LIB_PATH)\stirt.lib           \
            $(SDK_LIB_PATH)\wiaguid.lib


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=sti_ci.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\string.cpp ===
/******************************************************************************

  Source File:  String.CPP

  String Handling class implementation, v 98.6 1/2

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  01-08-97  Bob Kjelgaard
  01-03-97  Bob Kjelgaard   Added special functions to aid port extraction
                            for plug-and-play.
  07-05-97  Tim Wells       Ported to NT.


******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//

#include "sti_ci.h"

//
// Extern
//

extern HINSTANCE g_hDllInstance;

//
// Function
//


CString::CString(const CString& csRef) {

    m_lpstr = (csRef.m_lpstr && *csRef.m_lpstr) ?
        new TCHAR[1 + lstrlen(csRef.m_lpstr)] : NULL;

    if  (m_lpstr)
        lstrcpy(m_lpstr, csRef.m_lpstr);
}

CString::CString(LPCTSTR lpstrRef){

    DWORD   dwLength;

    _try {
        dwLength = lstrlen(lpstrRef);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 
    
    if( (NULL != lpstrRef)
     && (NULL != *lpstrRef)
     && (0 != dwLength) )
    {
        m_lpstr = new TCHAR[dwLength+1];
        lstrcpy(m_lpstr, lpstrRef);
    }

} // CString::CString(LPCTSTR lpstrRef)

const CString&  CString::operator =(const CString& csRef) {

    Empty();

    m_lpstr = (csRef.m_lpstr && *csRef.m_lpstr) ?
        new TCHAR[1 + lstrlen(csRef.m_lpstr)] : NULL;

    if  (m_lpstr)
        lstrcpy(m_lpstr, csRef.m_lpstr);

    return  *this;

    }

const 
CString&  
CString::operator =(
    LPCTSTR lpstrRef
    ) 
{

    DWORD   dwLength;

    Empty();

    _try {
        dwLength = lstrlen(lpstrRef);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 
    
    if( (NULL != lpstrRef)
     && (NULL != *lpstrRef)
     && (0 != dwLength) )
    {
        m_lpstr = new TCHAR[dwLength+1];
        lstrcpy(m_lpstr, lpstrRef);
    }

    return  *this;
} // CString::operator =(LPCTSTR lpstrRef)

void    CString::GetContents(HWND hwnd) {

    Empty();

    if  (!IsWindow(hwnd))
        return;

    unsigned u = (unsigned) SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);

    if  (!u)
        return;

    m_lpstr = new TCHAR[++u];
    if(NULL != m_lpstr){
        SendMessage(hwnd, WM_GETTEXT, u, (LPARAM) m_lpstr);
    }
}

void    CString::FromTable(unsigned uid) {

    TCHAR    acTemp[MAX_PATH+1];

    memset(acTemp, 0, sizeof(acTemp));

    LoadString(g_hDllInstance, uid, acTemp, ARRAYSIZE(acTemp)-1);

    *this = acTemp;
}

void    CString::Load(ATOM at, BOOL bGlobal) {

    TCHAR    acTemp[MAX_PATH+1];

    memset(acTemp, 0, sizeof(acTemp));

    if(bGlobal){
        GlobalGetAtomName(at, 
                          acTemp, 
                          ARRAYSIZE(acTemp)-1);
    } else {
        GetAtomName(at, 
                    acTemp, 
                    sizeof(acTemp)/sizeof(TCHAR));
    }

    *this = acTemp;
}

void    
CString::Load(
    HINF    hInf,
    LPCTSTR lpstrSection, 
    LPCTSTR lpstrKeyword,
    DWORD   dwFieldIndex,
    LPCTSTR lpstrDefault
    ) 
{

    INFCONTEXT  InfContext;
    TCHAR       szKeyBuffer[MAX_PATH+1];
    TCHAR       szValueBuffer[MAX_PATH+1];
    
    //
    // Initialize local.
    //
    memset(&InfContext, 0, sizeof(InfContext));
    memset(szKeyBuffer, 0, sizeof(szKeyBuffer));
    memset(szValueBuffer, 0, sizeof(szValueBuffer));
    
    //
    // Cleanup contents;
    //

    Empty();

    //
    // Check all parameters.
    //
    
    if( (NULL == lpstrSection)
     || (NULL == lpstrKeyword)
     || (!IS_VALID_HANDLE(hInf)) )
    {
        //
        // Invalid parameter.
        //
        
        goto Load_return;
    }

    //
    // Get matching line.
    //

    while(SetupFindFirstLine(hInf, lpstrSection, lpstrKeyword, &InfContext)){
        
        //
        // Get a field of a line.
        //

        if(SetupGetStringField(&InfContext, dwFieldIndex, szValueBuffer, ARRAYSIZE(szValueBuffer)-1, NULL)){
            
            *this = szValueBuffer;
            break;
        }// if(SetupGetStringField(&InfContext, dwFieldIndex, szValueBuffer, ARRAYSIZE(szValueBuffer)-1))
    } // while(SetupFindFirstLine(hInf, lpstrSection, lpstrKeyword, &InfContext))

Load_return:

    return;

} // CString::Load() Load from INF

void    CString::Load(HKEY hk, LPCTSTR lpstrKeyword) {

    TCHAR   abTemp[MAX_PATH+1];
    ULONG   lcbNeeded = sizeof(abTemp)-sizeof(TCHAR);

    memset(abTemp, 0, sizeof(abTemp));

    RegQueryValueEx(hk, lpstrKeyword, NULL, NULL, (PBYTE)abTemp, &lcbNeeded);
    *this = (LPCTSTR) abTemp;
}

void    CString::MakeSystemPath(LPCTSTR lpstrFileName) {

    DWORD   dwLength;

    if (m_lpstr)
        delete m_lpstr;

    _try {
        dwLength = lstrlen(lpstrFileName);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    m_lpstr = new TCHAR[MAX_PATH * 2];
    if( (NULL != m_lpstr)
     && (0 != dwLength)
     && (MAX_PATH >= dwLength) )
    {
        memset(m_lpstr, 0, MAX_PATH*2*sizeof(TCHAR));

        UINT uiLength = GetSystemDirectory (m_lpstr, MAX_PATH);

        if ( *(m_lpstr + uiLength) != TEXT('\\'))
            lstrcat (m_lpstr, TEXT("\\"));

        lstrcat (m_lpstr, lpstrFileName);
    }
}

void    CString::Store(HKEY hk, LPCTSTR lpstrKey, LPCTSTR lpstrType) {

    DWORD   dwLength;

    if  (IsEmpty())
        return;

    _try {
        dwLength = lstrlen(lpstrKey);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        return;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    if (lpstrType && *lpstrType == TEXT('1')) {

        DWORD   dwValue = Decode();
        RegSetValueEx(hk, lpstrKey, NULL, REG_DWORD, (LPBYTE) &dwValue,
            sizeof (DWORD));

    } else {

        RegSetValueEx(hk, lpstrKey, NULL, REG_SZ, (LPBYTE) m_lpstr,
            (1 + lstrlen(m_lpstr)) * sizeof(TCHAR) );
    }
}

//  This one is a bit lame, but it does the job.

DWORD   CString::Decode() {

    if  (IsEmpty())
        return  0;

    for (LPTSTR  lpstrThis = m_lpstr;
        *lpstrThis && *lpstrThis == TEXT(' ');
        lpstrThis++)
        ;

    if  (!*lpstrThis)
        return  0;

    // BIUGBUG
    if  (lpstrThis[0] == TEXT('0') && (lpstrThis[1] | TEXT('\x20') ) == TEXT('x')) {
        //  Hex string
        lpstrThis += 2;
        DWORD   dwReturn = 0;

        while   (*lpstrThis) {
            switch  (*lpstrThis) {
                case    TEXT('0'):
                case    TEXT('1'):
                case    TEXT('2'):
                case    TEXT('3'):
                case    TEXT('4'):
                case    TEXT('5'):
                case    TEXT('6'):
                case    TEXT('7'):
                case    TEXT('8'):
                case    TEXT('9'):
                    dwReturn <<= 4;
                    dwReturn += ((*lpstrThis) - TEXT('0'));
                    break;

                case    TEXT('a'):
                case    TEXT('A'):
                case    TEXT('b'):
                case    TEXT('c'):
                case    TEXT('d'):
                case    TEXT('e'):
                case    TEXT('f'):
                case    TEXT('B'):
                case    TEXT('C'):
                case    TEXT('D'):
                case    TEXT('E'):
                case    TEXT('F'):
                    dwReturn <<= 4;
                    dwReturn += 10 + ((*lpstrThis | TEXT('\x20')) - TEXT('a'));
                    break;

                default:
                    return  dwReturn;
            }
            lpstrThis++;
        }
        return  dwReturn;
    }

    for (DWORD  dwReturn = 0;
         *lpstrThis && *lpstrThis >= TEXT('0') && *lpstrThis <= TEXT('9');
         lpstrThis++) {

        dwReturn *= 10;
        dwReturn += *lpstrThis - TEXT('0');
    }

    return  dwReturn;

}


CString  operator + (const CString& cs1, const CString& cs2) {

    if  (cs1.IsEmpty())
        return  cs2;

    if  (cs2.IsEmpty())
        return  cs1;

    CString csReturn;

    csReturn.m_lpstr = new TCHAR[ 1 + lstrlen(cs1) +lstrlen(cs2)];

    if(NULL != csReturn.m_lpstr){
        lstrcat(lstrcpy(csReturn.m_lpstr, cs1.m_lpstr), cs2.m_lpstr);
    }

    return  csReturn;
}

CString  operator + (const CString& cs1, LPCTSTR lpstr2) {

    DWORD   dwLength;

    _try {
        dwLength = lstrlen(lpstr2);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    if(0 == dwLength)
        return  cs1;

    if(cs1.IsEmpty())
        return  lpstr2;

    CString csReturn;

    csReturn.m_lpstr = new TCHAR[ 1 + lstrlen(cs1) + dwLength];
    if(NULL != csReturn.m_lpstr){
        lstrcat(lstrcpy(csReturn.m_lpstr, cs1.m_lpstr), lpstr2);
    }

    return  csReturn;
}

CString  operator + (LPCTSTR lpstr1,const CString& cs2) {

    DWORD   dwLength;

    _try {
        dwLength = lstrlen(lpstr1);
    } // _try {
    _except(EXCEPTION_EXECUTE_HANDLER) {
        dwLength = 0;
    } // _except(EXCEPTION_EXECUTE_HANDLER) 

    if(0 == dwLength)
        return  cs2;

    if  (cs2.IsEmpty())
        return  lpstr1;

    CString csReturn;

    csReturn.m_lpstr = new TCHAR[ 1 + dwLength +lstrlen(cs2)];

    if(NULL != csReturn.m_lpstr){
        lstrcat(lstrcpy(csReturn.m_lpstr, lpstr1), cs2.m_lpstr);
    }
    return  csReturn;
}


//  CStringArray class- the implementation is a bit lame, but it isn't
//  really necessary to not be lame, at this point...

CStringArray::CStringArray(unsigned uGrowBy) {
    m_ucItems = m_ucMax = 0;
    m_pcsContents = NULL;
    m_uGrowBy = uGrowBy ? uGrowBy : 10;
}

CStringArray::~CStringArray() {
    if  (m_pcsContents)
        delete[]  m_pcsContents;
}

VOID
CStringArray::Cleanup() {
    if  (m_pcsContents){
        delete[]  m_pcsContents;
    }
    m_pcsContents = NULL;
    m_ucItems = m_ucMax = 0;
}

void    CStringArray::Add(LPCTSTR lpstr) {

    if  (m_ucItems >= m_ucMax) {
        CString *pcsNew = new CString[m_ucMax += m_uGrowBy];

        if  (!pcsNew) {
            m_ucMax -= m_uGrowBy;
            return;
        }

        for (unsigned u = 0; u < m_ucItems; u++)
            pcsNew[u] = m_pcsContents[u];

        delete[]  m_pcsContents;
        m_pcsContents = pcsNew;
    }

    m_pcsContents[m_ucItems++] = lpstr;
}

CString&    CStringArray::operator [](unsigned u) {

    return  (u < m_ucItems) ? m_pcsContents[u] : m_csEmpty;
}

//  Split a string into tokens, and make an array of it

void    CStringArray::Tokenize(LPTSTR lpstr, TCHAR cSeparator) {

    BOOL    fInsideQuotes = FALSE;
    TCHAR   cPreviousChar = TEXT('\0');


    if  (m_pcsContents) {
        delete[]  m_pcsContents;
        m_pcsContents = NULL;
        m_ucItems = m_ucMax = 0;
    }

    if  (!lpstr)
        return;

    for (LPTSTR  lpstrThis = lpstr; *lpstr; lpstr = lpstrThis) {

        /*
        for (; *lpstrThis && *lpstrThis != cSeparator; lpstrThis++) {

        }
        */

        //
        // Skip for next separator , counting quotes
        //

        cPreviousChar = '\0';
        for (;*lpstrThis;  lpstrThis++) {

            if (fInsideQuotes) {
                if (*lpstrThis == TEXT('"')) {
                    if (cPreviousChar != TEXT('"')) {
                       // Previous was not a quote - going out of quotation
                        fInsideQuotes = FALSE;
                    }
                    else {
                        // Previous char was tab too - continue BUGBUG should coalesce
                    }
                    cPreviousChar = TEXT('\0');
                }
                else {
                    cPreviousChar = *lpstrThis;
                }
                continue;
            }
            else {
                if (*lpstrThis == TEXT('"')) {
                    // Starting quote
                    fInsideQuotes = TRUE;
                    cPreviousChar = TEXT('\0');
                    continue;
                }
                if (*lpstrThis == cSeparator) {
                    // Got to separator outside of quote - break the loop
                    break;
                }
            }
        }

        if  (*lpstrThis) {
            *lpstrThis = '\0';
            Add(lpstr);
            *lpstrThis++ = cSeparator;
        }
        else
            Add(lpstr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\wizpage.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Wizpage.h
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Generic wizard page class header file.
*
*******************************************************************************/

#ifndef _WIZPAGE_H_
#define _WIZPAGE_H_

//
// Include
//

#include "sti_ci.h"
#include "device.h"

//
// Class
//

class CInstallWizardPage
{

    static
    INT_PTR 
    CALLBACK 
    PageProc(
        HWND    hwndPage,
        UINT    uiMessage,
        WPARAM  wParam,
        LPARAM  lParam
        );

    PROPSHEETPAGE               m_PropSheetPage;        // This property sheet page
    HPROPSHEETPAGE              m_hPropSheetPage;       // Handle to this prop sheet page

protected:

    UINT                        m_uPreviousPage;        // Resource ID of previous page
    UINT                        m_uNextPage;            // Resource ID of next page
    HWND                        m_hwnd;                 // Window handle to this page
    HWND                        m_hwndWizard;           // Window handle to wizard
    CDevice                     *m_pCDevice;            // Device class object.
    BOOL                        m_bNextButtonPushed;    // Indicates how page was moved.
public:

    CInstallWizardPage(PINSTALLER_CONTEXT  pInstallerContext,
                       UINT                uTemplate
                       );
    ~CInstallWizardPage();

    HPROPSHEETPAGE Handle() { return m_hPropSheetPage; }
    
    virtual BOOL OnInit(){ return TRUE; }
    virtual BOOL OnNotify( LPNMHDR lpnmh ) { return FALSE; }
    virtual BOOL OnCommand(WORD wItem, WORD wNotifyCode, HWND hwndItem){ return  FALSE; }
    
};

#endif // !_WIZPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\clsinst\wizpage.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       Wizpage.cpp
*
*  VERSION:     1.0
*
*  AUTHOR:      KeisukeT
*
*  DATE:        27 Mar, 2000
*
*  DESCRIPTION:
*   Generic wizard page class. This is parent class of each wizard pages and it
*   handles common user operation of wizard.
*
*******************************************************************************/

//
// Precompiled header
//
#include "precomp.h"
#pragma hdrstop

//
// Include
//


#include "wizpage.h"
#include <stilib.h>

//
// Extern
//

extern HINSTANCE    g_hDllInstance;

//
// Function
//

INT_PTR
CALLBACK
CInstallWizardPage::PageProc(
    HWND    hwndPage,
    UINT    uiMessage,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    INT_PTR ipReturn = 0;

//    DebugTrace(TRACE_PROC_ENTER,(("CInstallWizardPage::PageProc: Enter... \r\n")));

    //
    // Get current context.
    //

    CInstallWizardPage *pInstallWizardPage = (CInstallWizardPage *)GetWindowLongPtr(hwndPage, DWLP_USER);

    switch (uiMessage) {

        case WM_INITDIALOG: {

            LPPROPSHEETPAGE pPropSheetPage;

            //  The lParam will point to the PROPSHEETPAGE structure which
            //  created this page.  Its lParam parameter will point to the
            //  object instance.

            pPropSheetPage = (LPPROPSHEETPAGE) lParam;
            pInstallWizardPage = (CInstallWizardPage *) pPropSheetPage->lParam;
            ::SetWindowLongPtr(hwndPage, DWLP_USER, (LONG_PTR)pInstallWizardPage);

            //
            // Save parent windows handle.
            //

            pInstallWizardPage->m_hwnd = hwndPage;

            //
            // Call derived class.
            //

            ipReturn = pInstallWizardPage->OnInit();

            goto PageProc_return;
            break;
        } // case WM_INITDIALOG:

        case WM_COMMAND:
        {
            //
            // Just pass down to the derived class.
            //

            ipReturn = pInstallWizardPage->OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND) LOWORD(lParam));
            goto PageProc_return;
            break;
        } // case WM_COMMAND:

        case WM_NOTIFY:
        {

            LPNMHDR lpnmh = (LPNMHDR) lParam;

            //
            // Let derivd class handle this first, then we do if it returns FALSE.
            //

            ipReturn = pInstallWizardPage->OnNotify(lpnmh);
            if(FALSE == ipReturn){
            DebugTrace(TRACE_STATUS,(("CInstallWizardPage::PageProc: Processing default WM_NOTIFY handler. \r\n")));

                switch  (lpnmh->code) {

                    case PSN_WIZBACK:

                        pInstallWizardPage->m_bNextButtonPushed = FALSE;

                        //
                        // Goto previous page.
                        //

                        ::SetWindowLongPtr(hwndPage, DWLP_MSGRESULT, (LONG_PTR)pInstallWizardPage->m_uPreviousPage);
                        ipReturn = TRUE;
                        goto PageProc_return;

                    case PSN_WIZNEXT:

                        pInstallWizardPage->m_bNextButtonPushed = TRUE;

                        //
                        // Goto next page.
                        //

                        ::SetWindowLongPtr(hwndPage, DWLP_MSGRESULT, (LONG_PTR)pInstallWizardPage->m_uNextPage);
                        ipReturn = TRUE;
                        goto PageProc_return;

                    case PSN_SETACTIVE: {

                        DWORD dwFlags;

                        //
                        //  Set the wizard buttons, according to next/prev page.
                        //

                        dwFlags =
                            (pInstallWizardPage->m_uPreviousPage    ? PSWIZB_BACK : 0)
                          | (pInstallWizardPage->m_uNextPage        ? PSWIZB_NEXT : PSWIZB_FINISH);

                        ::SendMessage(GetParent(hwndPage),
                                      PSM_SETWIZBUTTONS,
                                      0,
                                      (long) dwFlags);
                        ipReturn = TRUE;
                        goto PageProc_return;

                    } // case PSN_SETACTIVE:
                    
                    case PSN_QUERYCANCEL: {

                        //
                        // User canceled. Free device object if ever allocated.
                        //
                        if(NULL != pInstallWizardPage->m_pCDevice){
                            delete pInstallWizardPage->m_pCDevice;
                            pInstallWizardPage->m_pCDevice = NULL;
                        } // if(NULL != m_pCDevice)
                        ipReturn = TRUE;
                        goto PageProc_return;
                    } // case PSN_QUERYCANCEL:
                } // switch  (lpnmh->code)

                ipReturn = TRUE;;
            } // if(FALSE == ipReturn)

            goto PageProc_return;
            break;
        } // case WM_NOTIFY:

        default:
        ipReturn = FALSE;
    } // switch (uiMessage)

PageProc_return:
//    DebugTrace(TRACE_PROC_LEAVE,(("CInstallWizardPage::PageProc: Leaving... Ret=0x%x.\r\n"), ipReturn));
    return ipReturn;
}

CInstallWizardPage::CInstallWizardPage(
    PINSTALLER_CONTEXT  pInstallerContext,
    UINT                uTemplate
    )
{
    //
    // Initialize property sheet.
    //

    m_PropSheetPage.hInstance           = g_hDllInstance;
    m_PropSheetPage.pszTemplate         = MAKEINTRESOURCE(uTemplate);
    m_PropSheetPage.pszTitle            = MAKEINTRESOURCE(MessageTitle);
    m_PropSheetPage.dwSize              = sizeof m_PropSheetPage;
    m_PropSheetPage.dwFlags             = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    m_PropSheetPage.pfnDlgProc          = (DLGPROC)(PageProc);
    m_PropSheetPage.lParam              = (LPARAM) this;
    m_PropSheetPage.pszHeaderTitle      = MAKEINTRESOURCE(HeaderTitle);
    m_PropSheetPage.pszHeaderSubTitle   = MAKEINTRESOURCE(SubHeaderTitle);

    //
    // Don't want to show header on welcome/final page.
    //

    if( (IDD_DYNAWIZ_FIRSTPAGE == uTemplate)
     || (EmeraldCity == uTemplate) )
    {
        m_PropSheetPage.dwFlags |= PSP_HIDEHEADER;
    }

    //
    // We want to show some other header for some pages.
    //

    if(IDD_DYNAWIZ_SELECT_NEXTPAGE == uTemplate){
        m_PropSheetPage.pszHeaderTitle      = MAKEINTRESOURCE(HeaderForPortsel);
    } else if (NameTheDevice == uTemplate) {
        m_PropSheetPage.pszHeaderTitle      = MAKEINTRESOURCE(HeaderForNameIt);
    }
    //
    // Add the Fusion flags and global context, so the pages we add will pick up COMCTL32V6
    //

    m_PropSheetPage.hActCtx  = g_hActCtx;
    m_PropSheetPage.dwFlags |= PSP_USEFUSIONCONTEXT;

    //
    // Create Property sheet page.
    //

    m_hPropSheetPage = CreatePropertySheetPage(&m_PropSheetPage);

    //
    // Set other member.
    //

    m_hwnd              = NULL;
    m_hwndWizard        = pInstallerContext->hwndWizard;
    m_pCDevice          = NULL;
    m_bNextButtonPushed = TRUE;
}

CInstallWizardPage::~CInstallWizardPage(
    VOID
    )
{
    //
    // Destroy property sheet page.
    //

    if(NULL != m_hPropSheetPage){
        m_hPropSheetPage = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\inf\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     WIA INF files
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

NO_BROWSER_FILE=1

TARGETTYPE=NOTARGET
TARGETPATH=obj

SOURCES=

MISCFILES = ..\wia.inf      \
            ..\ircamera.inf \
            ..\testcam.inf  \
            ..\fscam.inf    \
            ..\testscan.inf \
            ..\kodak.inf    \
            ..\wiatwain.ds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\fileio.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    FileIo.c

Abstract:

    Routines to do File IO for the migration of Win95 printing to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 24-Aug-1998

Revision History:

--*/


#include    "precomp.h"
#pragma     hdrstop


CHAR
My_fgetc(
    HANDLE  hFile
    )
/*++

Routine Description:
    Gets a character from the file

Arguments:

Return Value:

--*/
{
    CHAR    c;
    DWORD   cbRead;

    if ( ReadFile(hFile, (LPBYTE)&c, sizeof(c), &cbRead, NULL)  &&
         cbRead == sizeof(c) )
        return c;
    else
        return (CHAR) EOF;
}


LPSTR
My_fgets(
    LPSTR   pszBuf,
    DWORD   dwSize,
    HANDLE  hFile
    )
/*++

Routine Description:
    Gets a line, or at most n characters from the file

Arguments:

Return Value:

--*/
{
    CHAR    c;
    DWORD   dwRead;
    LPSTR   ptr;

    ptr = pszBuf;
    while ( --dwSize > 0 && (c = My_fgetc(hFile)) != EOF )
        if ( (*ptr++ = c) == '\n' )
            break;

    *ptr = '\0';
    return ( c == EOF && ptr == pszBuf ) ? NULL : pszBuf;
}


DWORD
My_fread(
    LPBYTE      pBuf,
    DWORD       dwSize,
    HANDLE      hFile
    )
/*++

Routine Description:
    Read at most dwSize bytes to buffer

Arguments:

Return Value:
    Number of bytes read

--*/
{
    DWORD   cbRead;

    return  ReadFile(hFile, pBuf, dwSize, &cbRead, NULL) ? cbRead : 0;
}


BOOL
My_ungetc(
    HANDLE  hFile
    )
/*++

Routine Description:
    Unread one character

Arguments:

Return Value:

--*/
{
    return SetFilePointer(hFile, -1, NULL, FILE_CURRENT) != 0xFFFFFFFF;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\redist\precomp.h ===
#include <windows.h>
#include <winver.h>
#include <setupapi.h>
#include <tchar.h>
#include <sfcapip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\wiatwain\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   1-Aug-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     Fake TWAIN data source (real binary)
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiatwain
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

TARGETEXT=ds
DLLENTRY=_DllMainCRTStartup
COFFBASE=usermode

DLLDEF=..\wiatwain.def

SOURCES=                 \
        ..\wiatwain.cpp  \
        ..\wiatwain.rc

TARGETLIBS= $(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\redist\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiasetup.rc
//
#define IDI_WIASETUP                    1
#define IDS_WIA_DISPLAY_NAME            1
#define IDS_WIA_DESCRIPTION             2
#define IDS_STI_DESCRIPTION             3
#define IDS_STI_DISPLAY_NAME            4

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\makefile.inc ===
all: msg.h msg.rc msg00001.bin msg.mc

clean: cleansrc all

cleansrc:
    -erase msg.h msg00001.bin msg.rc msg.mc

msg.mc: $(BASE_INC_PATH)\vendinfo.mc
        copy $(BASE_INC_PATH)\vendinfo.mc msg.mc

msg.h msg00001.bin msg.rc:msg.mc
        mc -A -v msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\wiatwain\wiatwain.cpp ===
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiatwain.cpp
*
*  VERSION:     1.0
*
*  DATE:        1 August, 2000
*
*  AUTHOR:      Cooper Partin (coopp)
*
*  DESCRIPTION:
*   Main module, for the "real" fake TWAIN data source wiatwain.ds
*
*******************************************************************************/

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwreason, LPVOID lpReserved)
{    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\fileq.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    FileQ.c

Abstract:

    File queue routines for upgrade

Author:

    Muhunthan Sivapragasam (MuhuntS) 22-Jan-1996

Revision History:

--*/


#include "precomp.h"


//
// If the source disk is missing we will retry it 4 times waiting for
// 3 seconds between every try
//
#define     MISSING_MEDIA_RETRY_COUNT           4
#define     MISSING_MEDIA_RETRY_INTERVAL     3000


typedef struct _FILE_QUEUE_CONTEXT {

    PVOID   QueueContext;
} FILE_QUEUE_CONTEXT, *PFILE_QUEUE_CONTEXT;


UINT
MyQueueCallback(
    IN  PVOID   QueueContext,
    IN  UINT    Notification,
    IN  UINT_PTR Param1,
    IN  UINT_PTR Param2
    )
/*++

Routine Description:
    File queue callback routine for the upgrade. We will not prompt the user
    for missing file. But we will retry few times before failing

Arguments:
    QueueContext    : Points to FILE_QUEUE_CONTEXT
    Notification    : The event which is being notified
    Param1          : Depends on the notification
    Param2          : Depends on the notification

Return Value:
    None

--*/
{
    PFILE_QUEUE_CONTEXT     pFileQContext=(PFILE_QUEUE_CONTEXT)QueueContext;
    PSOURCE_MEDIA_W         pSource;
    PFILEPATHS_W            pFilePaths;

    switch (Notification) {

        case SPFILENOTIFY_COPYERROR:
            //
            // We know atleast pjlmon will be missing since it is copied
            // during textmode setup
            //
            pFilePaths = (PFILEPATHS_W) Param1;

            DebugMsg("Error %d copying %ws to %ws.",
                     pFilePaths->Win32Error, pFilePaths->Source,
                     pFilePaths->Target);

            return FILEOP_SKIP;

        case SPFILENOTIFY_NEEDMEDIA:
            pSource = (PSOURCE_MEDIA_W)Param1;

            //
            // Setup is going to add \i386 to the end. Tell it to look
            // right in the directory we give. Particularly needed for the
            // upgrade over the network case
            //
            if ( wcscmp(pSource->SourcePath, UpgradeData.pszSourceW) ) {

                wcscpy((LPWSTR)Param2, UpgradeData.pszSourceW);
                return FILEOP_NEWPATH;
            }

            DebugMsg("Error copying %ws from %ws.",
                     pSource->SourceFile, pSource->SourcePath);

            return FILEOP_SKIP;
    }

    return SetupDefaultQueueCallbackW(pFileQContext->QueueContext,
                                      Notification,
                                      Param1,
                                      Param2);
}


BOOL
InitFileCopyOnNT(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    On NT we will call ntprint.dll via SetupDiCallClassInstaller api with the
    DI_NOVCP flag so that all the necessary printer driver files are queued
    and copied at the end.

    This sets the necessary queue etc before calling the class installer

Arguments:
    hDevInfo    : Handle to printer device info list.

Return Value:
    TRUE on success. FALSE on error

--*/
{
    BOOL                        bRet = FALSE;
    HSPFILEQ                    CopyQueue;
    PFILE_QUEUE_CONTEXT         pFileQContext;
    SP_DEVINSTALL_PARAMS_W      DevInstallParams;

    //
    // Call the current device installation parameters
    //
    DevInstallParams.cbSize = sizeof(DevInstallParams);

    if ( !SetupDiGetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) )
        return FALSE;

    //
    // Set the parameters so that ntprint will just queue files and not commit
    // the file copy operations
    //
    if ( !(pFileQContext = AllocMem(sizeof(FILE_QUEUE_CONTEXT))) )
        goto Cleanup;

    pFileQContext->QueueContext = SetupInitDefaultQueueCallbackEx(
                                            INVALID_HANDLE_VALUE,
                                            INVALID_HANDLE_VALUE,
                                            0,
                                            0,
                                            NULL);

    DevInstallParams.FileQueue                  = SetupOpenFileQueue();
    DevInstallParams.InstallMsgHandlerContext   = pFileQContext;
    DevInstallParams.InstallMsgHandler          = MyQueueCallback;
    DevInstallParams.Flags                     |= DI_NOVCP;
    DevInstallParams.hwndParent                 = INVALID_HANDLE_VALUE;

    //
    // The files should be from the source dir
    //
    wcscpy(DevInstallParams.DriverPath, UpgradeData.pszSourceW);

    if ( DevInstallParams.FileQueue == INVALID_HANDLE_VALUE     ||
         pFileQContext->QueueContext == NULL                    ||
         !SetupDiSetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) ) {

        if ( DevInstallParams.FileQueue != INVALID_HANDLE_VALUE )
            SetupCloseFileQueue(DevInstallParams.FileQueue);

        if ( pFileQContext->QueueContext )
            SetupTermDefaultQueueCallback(pFileQContext->QueueContext);
    } else {

        bRet = TRUE;
    }

Cleanup:

    if ( !bRet )
        FreeMem(pFileQContext);

    return bRet;
}


BOOL
CommitFileQueueToCopyFiles(
    IN  HDEVINFO    hDevInfo
    )
/*++

Routine Description:
    After calling ntprint for each printer driver to queue up the files this
    routine is called to commit the file queue and do the actual file copy
    operations

Arguments:
    hDevInfo    : Handle to printer device info list.

Return Value:
    TRUE on success. FALSE on error

--*/
{
    BOOL                        bRet = FALSE;
    SP_DEVINSTALL_PARAMS_W      DevInstallParams;
    PFILE_QUEUE_CONTEXT         pFileQContext;

    DevInstallParams.cbSize = sizeof(DevInstallParams);

    if ( !SetupDiGetDeviceInstallParamsW(hDevInfo,
                                         NULL,
                                         &DevInstallParams) )
        return FALSE;

    pFileQContext = DevInstallParams.InstallMsgHandlerContext;

    bRet = SetupCommitFileQueueW(DevInstallParams.hwndParent,
                                 DevInstallParams.FileQueue,
                                 DevInstallParams.InstallMsgHandler,
                                 pFileQContext);

    SetupCloseFileQueue(DevInstallParams.FileQueue);
    SetupTermDefaultQueueCallback(pFileQContext->QueueContext);
    FreeMem(pFileQContext);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\local.h ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    local.h

Abstract:

    Local header file for migration DLL of WIA class.

Author:

    Keisuke Tsuchida (KeisukeT)  10-Oct-2000

Revision History:

--*/

#ifndef LOCAL_H
#define LOCAL_H


//
// Define
//


#define NAME_WIN9X_SETTING_FILE_A   "sti9x.txt"
#define NAME_WIN9X_SETTING_FILE_W   L"sti9x.txt"
#define NAME_MIGRATE_INF_A          "migrate.inf"
#define NAME_MIGRATE_INF_W          L"migrate.inf"
#define NAME_STILLIMAGE_A           "StillImage"
#define NAME_STILLIMAGE_W           L"StillImage"
#define NAME_FRIENDLYNAME_A         "FriendlyName"
#define NAME_FRIENDLYNAME_W         L"FriendlyName"
#define NAME_CREATEFILENAME_A       "CreateFileName"
#define NAME_CREATEFILENAME_W       L"CreateFileName"
#define NAME_INF_PATH_A             "InfPath"
#define NAME_INF_PATH_W             L"InfPath"
#define NAME_INF_SECTION_A          "InfSection"
#define NAME_INF_SECTION_W          L"InfSection"
#define NAME_INSTALLER_A            "sti_ci.dll"
#define NAME_INSTALLER_W            L"sti_ci.dll"
#define NAME_PROC_MIGRATEDEVICE_A   "MigrateDevice"
#define NAME_PROC_MIGRATEDEVICE_W   L"MigrateDevice"
#define NAME_DEVICE_A               "Device"
#define NAME_DEVICE_W               L"Device"
#define NAME_BEGIN_A                "BEGIN"
#define NAME_BEGIN_W                L"BEGIN"
#define NAME_END_A                  "END"
#define NAME_END_W                  L"END"



#define REGKEY_DEVICEDATA_A         "DeviceData"
#define REGKEY_DEVICEDATA_W         L"DeviceData"
#define REGVAL_SUBCLASS_A           "SubClass"
#define REGVAL_SUBCLASS_W           L"SubClass"
#define REGVAL_USDCLASS_A           "USDClass"
#define REGVAL_USDCLASS_W           L"USDClass"
#define REGVAL_NTMPDRIVER_A         "NTMPDriver"
#define REGVAL_NTMPDRIVER_W         L"NTMPDriver"

// Kodak related.

#define FILEVER_KODAKIMAGING_WIN98_MS   0x4000a
#define FILEVER_KODAKIMAGING_WIN98_LS   0x7ce
#define PRODVER_KODAKIMAGING_WIN98_MS   0x10000
#define PRODVER_KODAKIMAGING_WIN98_LS   0x51f

#define FILEVER_KODAKIMAGING_WINME_MS   0x4005a
#define FILEVER_KODAKIMAGING_WINME_LS   0xbb8
#define PRODVER_KODAKIMAGING_WINME_MS   0x10000
#define PRODVER_KODAKIMAGING_WINME_LS   0x520


#define NAME_KODAKIMAGING_A         "kodakimg.exe"
#define NAME_KODAKIMAGING_W         L"kodakimg.exe"
#define REGSTR_PATH_KODAKEVENT_A    "System\\CurrentControlSet\\Control\\StillImage\\Events\\STIProxyEvent\\{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"
#define REGSTR_PATH_KODAKEVENT_W    L"System\\CurrentControlSet\\Control\\StillImage\\Events\\STIProxyEvent\\{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"
#define REGSTR_KEY_KODAKGUID_A      "{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"
#define REGSTR_KEY_KODAKGUID_W      L"{5F89FC93-A94E-4C0B-A1F2-DB6E97AA0B38}"


#ifdef UNICODE
 #define NAME_KODAKIMAGING          NAME_KODAKIMAGING_W
 #define REGSTR_PATH_KODAKEVENT     REGSTR_PATH_KODAKEVENT_W
 #define REGSTR_KEY_KODAKGUID       REGSTR_KEY_KODAKGUID_W
#else   // #ifdef UNICODE
 #define NAME_KODAKIMAGING          NAME_KODAKIMAGING_A
 #define REGSTR_PATH_KODAKEVENT     REGSTR_PATH_KODAKEVENT_A
 #define REGSTR_KEY_KODAKGUID       REGSTR_KEY_KODAKGUID_A
#endif  // #ifdef UNICODE


//
// Typedef
//

typedef struct  _PARAM_LIST {
    PVOID           pNext;
    LPSTR           pParam1;
    LPSTR           pParam2;
} PARAM_LIST, *PPARAM_LIST;

typedef struct  _DEVICE_INFO {

    LPSTR           pszFriendlyName;
    LPSTR           pszCreateFileName;
    LPSTR           pszInfPath;
    LPSTR           pszInfSection;

    DWORD           dwNumberOfDeviceDataKey;
    PPARAM_LIST     pDeviceDataParam;
} DEVICE_INFO, *PDEVICE_INFO;


//
// Extern
//

extern HINSTANCE    g_hInst;

//
// Proto-type
//

//
// Migrate function
//


LONG
CALLBACK
Mig9xGetGlobalInfo(
    IN      HANDLE      hFile
    );


LONG
CALLBACK
Mig9xGetDeviceInfo(
    IN      HANDLE      hFile
    );

//
// Debug functions
//
VOID
DebugMsg(
    LPCSTR  pszFormat,
    ...
    );

//
// Heap management
//

PVOID
AllocMem(
    IN UINT cbSize
    );

VOID
FreeMem(
    IN PVOID pMem
    );

LPSTR
AllocStrA(
    IN LPCSTR  pszStr
    );

LPWSTR
AllocStrW(
    IN LPCWSTR  pszStr
    );

LPWSTR
AllocStrWFromStrA(
    LPCSTR  pszStr
    );

LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    );

VOID
FreePrinterInfo2Strings(
    PPRINTER_INFO_2A   pPrinterInfo2
    );

//
// Functions to write print config to the text file
//
BOOL
WriteToFile(
    HANDLE  hFile,
    LPCSTR  pszFormat,
    ...
    );

VOID
WriteString(
    IN      HANDLE  hFile,
    IN OUT  LPBOOL  pbFail,
    IN      LPCSTR  pszStr
    );

//
// Functions to parse the text file having printing config info
//
LPSTR
GetLine(
    IN      HANDLE  hFile,
    IN  OUT LPBOOL  pbFail
    );

VOID
ReadString(
    IN      HANDLE  hFile,
    OUT     LPSTR  *ppszParam1,
    OUT     LPSTR  *ppszParam2
    );

VOID
ReadDword(
    IN      HANDLE  hFile,
    IN      LPSTR   pszLine,
    IN      DWORD   dwLineSize,
    IN      LPSTR   pszPrefix,
    OUT     LPDWORD pdwValue,
    IN  OUT LPBOOL  pbFail
    );


//
// Misc stuff
//

LPSTR
ErrorMsg(
    VOID
    );

VOID
LogError(
    IN  LogSeverity Severity,
    IN  UINT        MessageId,
    ...
    );

LPSTR
GetStringFromRcFileA(
    IN  UINT    uId
    );

VOID
SetupNetworkPrinterUpgrade(
    IN  LPCSTR pszWorkingDir
    );

BOOL
ProcessNetPrnUpgradeForUser(
    HKEY    hKeyUser
    );

DWORD
MySetDefaultPrinter(
    IN  HKEY    hUserRegKey,
    IN  LPSTR   pszDefaultPrinterString
    );

VOID
WriteRunOnceCount(
    );

LPSTR
GetDefPrnString(
    IN  LPCSTR  pszPrinterName
    );

CHAR
My_fgetc(
    HANDLE  hFile
    );

LPSTR
My_fgets(
    LPSTR   pszBuf,
    DWORD   dwSize,
    HANDLE  hFile
    );

DWORD
My_fread(
    LPBYTE      pBuf,
    DWORD       dwSize,
    HANDLE      hFile
    );

BOOL
My_ungetc(
    HANDLE  hFile
    );


LONG
WriteRegistryToFile(
    IN  HANDLE  hFile,
    IN  HKEY    hKey,
    IN  LPCSTR  pszPath
    );

LONG
WriteRegistryValueToFile(
    HANDLE  hFile,
    LPSTR   pszValue,
    DWORD   dwType,
    PCHAR   pDataBuffer,
    DWORD   dwSize
    );

LONG
GetRegData(
    HKEY    hKey,
    LPSTR   pszValue,
    PCHAR   *ppDataBuffer,
    PDWORD  pdwType,
    PDWORD  pdwSize
    );

BOOL
IsSti(
    HKEY    hKeyDevice
    );

BOOL
IsKernelDriverRequired(
    HKEY    hKeyDevice
    );

LONG
WriteDeviceToFile(
    HANDLE  hFile,
    HKEY    hKey
    );

LONG
MigNtProcessMigrationInfo(
    HANDLE  hFile
    );

LONG
MigNtGetDevice(
    HANDLE          hFile,
    PDEVICE_INFO    pMigrateDevice
    );


VOID
MigNtFreeDeviceInfo(
    PDEVICE_INFO    pMigrateDevice
    );

VOID
MyLogError(
    LPCSTR  pszFormat,
    ...
    );

BOOL
MigNtIsWin9xImagingExisting(
    VOID
    );

VOID
MigNtRemoveKodakImagingKey(
    VOID
    );

#endif  // LOCAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\precomp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file

Author:

    Muhunthan Sivapragasam (MuhuntS)  17-Oct-1995

Revision History:

--*/

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <objbase.h>
#include <shellapi.h>
#include <setupapi.h>
#include <initguid.h>
#include <cfgmgr32.h>
#include "splsetup.h"
#include "local.h"
#include "resource.h"
#include <plugin.h>
#include <stiregi.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\redist\wiasetup.c ===
#include "precomp.h"
#include "resource.h"

#ifdef DEBUG
#define TRACE(x) Trace x
#else
#define TRACE(x) Trace x
#endif

#define ARRAY_LENGTH(x) (sizeof(x)/sizeof((x)[0]))

static const CHAR __filename[] = __FILE__;

#define CHECK(x) do { if(!(x)) \
{ CHAR ErrorText[80]; GetErrorText(GetLastError(), ErrorText, 80); \
TRACE((_T("%hs(%d): %hs failed. Error: %hs\n"), \
__filename, __LINE__, #x, ErrorText)); \
goto Cleanup; } } while(0)

#define CHECK2(x, y) do { if(!(x)) \
{ CHAR ErrorText[80]; GetErrorText(GetLastError(), ErrorText, 80); \
TRACE((_T("%hs(%d): %hs ("), __filename, __LINE__, #x)); \
TRACE((y)); \
TRACE((_T(") failed. Error: %hs\n"), ErrorText)); \
goto Cleanup; } } while(0)

#define CHECK_SUCCESS(x) do { LONG lr; lr = (x); if(lr != ERROR_SUCCESS) \
{ CHAR ErrorText[80]; GetErrorText(lr, ErrorText, 80); \
TRACE((_T("%hs(%d): %s failed. Error: %hs\n"), \
__filename, __LINE__, #x, ErrorText)); \
goto Cleanup; } } while(0)

void Trace(LPTSTR fmt, ...);
void GetErrorText(DWORD dwError, CHAR *ErrorText, UINT maxChar);
void MakeFileName(TCHAR *FileName, TCHAR *Directory, TCHAR *BaseName);
BOOL MyDeleteService(TCHAR *ServiceName);
BOOL MyMoveFile(TCHAR *File, TCHAR *SourceDir, TCHAR *DestinationDir);
BOOL MyDeleteDirectory(TCHAR *Directory);
BOOL MyRegDeleteKey(HKEY hKey, TCHAR *subkey);
BOOL RegisterServer32(TCHAR *Module, TCHAR *Options);
BOOL IsFirstFileOlderThanSecond(TCHAR *Source, TCHAR *Destination);


#define REGKEY_SVCHOST _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\SvcHost")
#define REGKEY_STISVC_PARAMETERS _T("SYSTEM\\CurrentControlSet\\Services\\StiSvc\\Parameters")
#define STIBACKUP_DIR _T("%SystemRoot%\\System32\\StiBackup.bak")
#define WINDOWS_DIR _T("%SystemRoot%")
#define TWAIN_DIR _T("%SystemRoot%\\twain_32")
#define SYSTEM32_DIR _T("%SystemRoot%\\System32")
#define DRIVERS_DIR _T("%SystemRoot%\\System32\\Drivers")
#define INF_DIR _T("%SystemRoot%\\Inf")
TCHAR WindowsDirectory[MAX_PATH];
TCHAR TwainDirectory[MAX_PATH];
TCHAR SystemDirectory[MAX_PATH];
TCHAR DriversDirectory[MAX_PATH];
TCHAR InfDirectory[MAX_PATH];

TCHAR szModuleName[] = _T("wiasetup.dll");

typedef struct FileTableEntry {
    TCHAR *FileName;
    TCHAR *Location;
    BOOL bRegister;
	BOOL bIgnore;
} FileTableEntry;

FileTableEntry FileTable[] = {
//    { _T("camocx.dll"), SystemDirectory, TRUE, FALSE },
//    { _T("cropview.dll"), SystemDirectory, TRUE, FALSE },
//    { _T("extend.dll"), SystemDirectory, FALSE, FALSE },
    { _T("scsiscan.sys"), DriversDirectory, FALSE, FALSE },
    { _T("sti.dll"), SystemDirectory, TRUE, FALSE },
    { _T("sti_ci.dll"), SystemDirectory, TRUE, FALSE },
    { _T("sticpl.cpl"), SystemDirectory, FALSE, FALSE },
    { _T("stimon.exe"), SystemDirectory, FALSE, FALSE },
    { _T("stisvc.exe"), SystemDirectory, FALSE, FALSE },
    { _T("twain_32.dll"), WindowsDirectory, FALSE, FALSE },
    { _T("twunk_32.exe"), WindowsDirectory, FALSE, FALSE },
    { _T("twunk_16.exe"), WindowsDirectory, FALSE, FALSE },
	{ _T("wiatwain.ds"), TwainDirectory, FALSE, FALSE },
    { _T("usbscan.sys"), DriversDirectory, FALSE, FALSE },
//    { _T("wiaacmgr.exe"), SystemDirectory, FALSE, FALSE },
    { _T("wiadefui.dll"), SystemDirectory, TRUE, FALSE },
//    { _T("wiadenum.dll"), SystemDirectory, TRUE, FALSE },
    { _T("wiadss.dll"), SystemDirectory, TRUE, FALSE },
    { _T("wiafbdrv.dll"), SystemDirectory, TRUE, FALSE },
//    { _T("wiascanx.dll"), SystemDirectory, TRUE, FALSE },
//    { _T("wiascr.dll"), SystemDirectory, TRUE, FALSE },
//    { _T("wiascr.tlb"), SystemDirectory, FALSE, FALSE },
    { _T("wiaservc.dll"), SystemDirectory, TRUE, FALSE },
    { _T("wiasf.ax"), SystemDirectory, TRUE, FALSE },
    { _T("wiashext.dll"), SystemDirectory, TRUE, FALSE },
//    { _T("wiastatd.dll"), SystemDirectory, FALSE, FALSE },
//    { _T("wiatscan.dll"), SystemDirectory, FALSE, FALSE },
    { _T("wiavusd.dll"), SystemDirectory, TRUE, FALSE },
    { _T("sti.inf"), InfDirectory, FALSE, FALSE },
    { NULL, NULL, FALSE, FALSE }
};

BOOL __stdcall InstallWia(void);
BOOL __stdcall RemoveWia(void);
UINT CALLBACK wsIterateCabinetCallback(PVOID, UINT, UINT, UINT);
BOOL InstallFileTable(FileTableEntry *pTable, TCHAR *DirInstallFrom, TCHAR *BackupDir); 
BOOL InstallWiaService(void);
BOOL InstallStiService(void);

#if 0
#ifdef UNICODE
#define WinMain wWinMain
#endif

int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPTSTR lpCmd, int nShow)
{
    if((lpCmd[0] == _T('-') || lpCmd[0] == _T('/')) && 
        (lpCmd[1] == _T('u') || lpCmd[0] == _T('U')))
    {
        CHECK(RemoveWia());
    }
    else
    {
        CHECK(InstallWia());
    }
Cleanup:
    return 0;
}
#endif


BOOL __stdcall InstallWia(void)
{
    BOOL success = FALSE;
    HINSTANCE hCi = NULL;

    TCHAR StiBackupDirectory[MAX_PATH];
    TCHAR TempDirectory[MAX_PATH];
    TCHAR WiaCabFile[MAX_PATH];
    TCHAR path[MAX_PATH];
    DWORD dwAttributes;
    int i;
    HMODULE hModule;

    BOOL CreatedBackupDirectory = FALSE;
    BOOL CreatedTempDirectory = FALSE;
    BOOL InstalledWiaEnvironment = FALSE;

	OSVERSIONINFOEX osv;

	ZeroMemory(&osv, sizeof(osv));
	osv.dwOSVersionInfoSize = sizeof(osv);
	osv.dwMajorVersion = 5;

	// make sure we have NT5 or better 
	CHECK(VerifyVersionInfo(&osv, VER_MAJORVERSION, VerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL)));

    //
    // Get system paths
    //
	CHECK(ExpandEnvironmentStrings(WINDOWS_DIR, WindowsDirectory, MAX_PATH));
	CHECK(ExpandEnvironmentStrings(TWAIN_DIR, TwainDirectory, MAX_PATH));
    CHECK(ExpandEnvironmentStrings(SYSTEM32_DIR, SystemDirectory, MAX_PATH));
    CHECK(ExpandEnvironmentStrings(DRIVERS_DIR, DriversDirectory, MAX_PATH));
    CHECK(ExpandEnvironmentStrings(INF_DIR, InfDirectory, MAX_PATH));

    CHECK(ExpandEnvironmentStrings(STIBACKUP_DIR, StiBackupDirectory, MAX_PATH));

    // Get our module file name
    hModule = GetModuleHandle(szModuleName);
    CHECK(hModule != NULL);
    CHECK(GetModuleFileName(hModule, WiaCabFile, MAX_PATH));

    //
    // Create backup directory, if it does not already exist
    //
    dwAttributes = GetFileAttributes(StiBackupDirectory);
    if(dwAttributes == -1)
    {
        CHECK(CreateDirectory(StiBackupDirectory, NULL));
    }
    CreatedBackupDirectory = TRUE;
    MakeFileName(path, StiBackupDirectory, _T("wiasetup.dll"));
    CHECK(CopyFile(WiaCabFile, path, FALSE));

    // Find the last "\"
    for(i = 0; i < MAX_PATH && WiaCabFile[i] != _T('\0'); i++)
        ;
    while(i > 0 && WiaCabFile[i] != _T('\\'))
        i--;
    CHECK(WiaCabFile[i] == _T('\\'));

    // Append cabinet name afer the last backslash
    lstrcpy(WiaCabFile + i, _T("\\wiasetup.cab"));

    // Verify that CAB file exist
    CHECK((dwAttributes = GetFileAttributes(WiaCabFile)) != -1);

    // Generate temp directory name and create temp directory
    CHECK(GetTempPath(MAX_PATH, path));
    CHECK(GetTempFileName(path, _T("wsetup"), 0, TempDirectory));
    CHECK(DeleteFile(TempDirectory));
    CHECK(CreateDirectory(TempDirectory, NULL));

    CreatedTempDirectory = TRUE;

    //
    // Extract our .CAB file into it
    //
    CHECK(SetupIterateCabinet(WiaCabFile, 0, wsIterateCabinetCallback, TempDirectory));

    //
    // Remove STISVC service
    //
    CHECK(MyDeleteService(_T("stisvc")));

    //
    // Install and register all the files
    //
    CHECK(InstallFileTable(FileTable, TempDirectory, StiBackupDirectory));
    InstalledWiaEnvironment = TRUE;

    CHECK(InstallWiaService());

    //
    // Mark success
    //
    success = TRUE;
    
Cleanup:
    if(CreatedTempDirectory) MyDeleteDirectory(TempDirectory);
    if(!success) 
    {
        if(InstalledWiaEnvironment) RemoveWia();
    }

    return success;
}

BOOL __stdcall RemoveWia(void)
{
    BOOL success = FALSE;
    TCHAR StiBackupDirectory[MAX_PATH];

    //
    // Get system paths
    //
	CHECK(ExpandEnvironmentStrings(WINDOWS_DIR, WindowsDirectory, MAX_PATH));
	CHECK(ExpandEnvironmentStrings(TWAIN_DIR, TwainDirectory, MAX_PATH));
    CHECK(ExpandEnvironmentStrings(SYSTEM32_DIR, SystemDirectory, MAX_PATH));
    CHECK(ExpandEnvironmentStrings(DRIVERS_DIR, DriversDirectory, MAX_PATH));

    CHECK(ExpandEnvironmentStrings(STIBACKUP_DIR, StiBackupDirectory, MAX_PATH));

    CHECK(MyDeleteService(_T("stisvc")));

    CHECK(InstallFileTable(FileTable, StiBackupDirectory, NULL));

    CHECK(InstallStiService());

    CHECK(MyDeleteDirectory(StiBackupDirectory));

    success = TRUE;

Cleanup:
    return success;
}

//
// This is called by SetupIterateCabinet for each file in cabinet
//
UINT CALLBACK 
wsIterateCabinetCallback(PVOID pContext, UINT Notification, 
                         UINT Param1, UINT Param2)
{
	UINT result = NO_ERROR;
	TCHAR *TargetDir = (TCHAR *)pContext;
	FILE_IN_CABINET_INFO *pInfo = NULL;
	FILEPATHS *pFilePaths = NULL;

	switch(Notification)
	{
	case SPFILENOTIFY_FILEINCABINET:
		pInfo = (FILE_IN_CABINET_INFO *)Param1;
        MakeFileName(pInfo->FullTargetName, TargetDir, (TCHAR *)pInfo->NameInCabinet);
		result = FILEOP_DOIT;  // Extract the file.
		break;

	case SPFILENOTIFY_FILEEXTRACTED:
		pFilePaths = (FILEPATHS *)Param1;
		result = NO_ERROR;
		break;

	case SPFILENOTIFY_NEEDNEWCABINET: // Unexpected.
		result = NO_ERROR;
		break;
	}

	return result;
}


BOOL 
InstallFileTable(
    FileTableEntry  *pTable, 
    TCHAR           *DirInstallFrom, 
    TCHAR           *BackupDir)
/*++
    Performs four passes over the specified file table:

    1. Checks version stamp of both source and destination files 
	   and marks older source files to ignore

    2. Unregister any old file that needs to be unregistered;

    3. Moves every old file into BackupDir and copies any new 
       file into place from DirInstallFrom;

    4. Registers any new file that needs to be registered;

--*/
{
    BOOL success = FALSE; 
    DWORD dwAttributes;
    TCHAR Source[MAX_PATH];
    TCHAR Destination[MAX_PATH];
    HANDLE hSfc = NULL;
    FileTableEntry  *p;

    CHECK(hSfc = SfcConnectToServer(NULL));

	//
	// Pass 1: mark any older source files to ignore
	//
	for(p = pTable; p->FileName != NULL; p++)
	{
		MakeFileName(Source, DirInstallFrom, p->FileName);
        dwAttributes = GetFileAttributes(Source);
        if(dwAttributes == -1) 
        {
			continue;
        }

		MakeFileName(Destination, p->Location, p->FileName);
        dwAttributes = GetFileAttributes(Destination);
        if(dwAttributes == -1) 
        {
            continue;
        }

		if(IsFirstFileOlderThanSecond(Source, Destination))
		{
			p->bIgnore = TRUE;
		}

    }

    //
    // Pass 2: unregister all DLLs that need registration
    //
    for(p = pTable; p->FileName != NULL; p++)
    {
        if(!p->bRegister) continue;

        MakeFileName(Destination, p->Location, p->FileName);

        dwAttributes = GetFileAttributes(Destination);
        if(dwAttributes != -1) 
        {
            CHECK(RegisterServer32(Destination, _T("/u /s")));
        }
    }


    //
    // Pass 3: Install all the files
    //
    for(p = pTable; p->FileName != NULL; p++)
    {
        //
        // Prepare full destination file name, make sure it exists
        //
        MakeFileName(Destination, p->Location, p->FileName);
        dwAttributes = GetFileAttributes(Destination);
        if(dwAttributes != -1)
        {
            //
            // If this file is under SFP, make exception
            //
            if(SfcIsFileProtected(hSfc, Destination)) 
            {
                if(SfcFileException(hSfc, Destination, 
                    SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED | 
                    SFC_ACTION_RENAMED_OLD_NAME) != ERROR_SUCCESS)
                {
                    TRACE((_T("InstallFileTable: Failed setting up SFC exception for %s\n"), Destination));
                }
            }

            //
            // delete the old file to backup directory
            //
            CHECK(MyMoveFile(p->FileName, p->Location, BackupDir));
        }

        //
        // Prepare full source file name, make sure it exists
        //
        MakeFileName(Source, DirInstallFrom, p->FileName);
        dwAttributes = GetFileAttributes(Source);
        if(dwAttributes != -1) 
        {
            //
            // move the new file into place
            //
            CHECK2(CopyFile(Source, Destination, FALSE), (_T("%s %s"), Source, Destination));
        }
    }

    //
    // Pass 4: Register all DLLs that need registration
    //
    for(p = pTable; p->FileName != NULL; p++)
    {
        if(!p->bRegister) continue;

        MakeFileName(Destination, p->Location, p->FileName);

        dwAttributes = GetFileAttributes(Destination);
        if(dwAttributes != -1) 
        {
            CHECK(RegisterServer32(Destination, _T("/s")));
        }
    }

    success = TRUE;

Cleanup:
    if(hSfc != NULL) SfcClose(hSfc);

    return success;
}

BOOL InstallWiaService(void)
{
    BOOL success = FALSE;
    SC_HANDLE hSvcMgr = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD checkPoint;
    TCHAR DisplayName[260];
    TCHAR Description[260];
    TCHAR mszStiSvc[] = _T("StiSvc\0");
    TCHAR szServiceDll[] = _T("%SystemRoot%\\System32\\wiaservc.dll");
    HMODULE hModule;
    HKEY hKey = NULL;

    CHECK(hModule = GetModuleHandle(szModuleName));
    CHECK(LoadString(hModule, IDS_WIA_DISPLAY_NAME, DisplayName, ARRAY_LENGTH(DisplayName)));
    CHECK(LoadString(hModule, IDS_WIA_DESCRIPTION, Description, ARRAY_LENGTH(Description)));

    //
    // Add svchost.exe -- specific entries
    //
    CHECK_SUCCESS(RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SVCHOST, 
        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL));
    CHECK_SUCCESS(RegSetValueEx(hKey, _T("imgsvc"), 0, REG_MULTI_SZ, 
        (BYTE *)mszStiSvc, (lstrlen(mszStiSvc) + 1) * sizeof(TCHAR)));
    CHECK_SUCCESS(RegCloseKey(hKey));

    CHECK_SUCCESS(RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_STISVC_PARAMETERS,  
        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL));
    CHECK_SUCCESS(RegSetValueEx(hKey, _T("ServiceDll"), 0, REG_EXPAND_SZ, 
        (BYTE *)szServiceDll, lstrlen(szServiceDll) * sizeof(TCHAR)));

    CHECK(hSvcMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));

    CHECK(hService = CreateService(hSvcMgr,
        _T("StiSvc"),
        DisplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS,
        SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        _T("%SystemRoot%\\System32\\svchost.exe -k imgsvc"),
        NULL,
        NULL,
        _T("RpcSs\0"),
        _T("LocalSystem"),
        NULL));
    success = TRUE;

Cleanup:
    if(hService) CloseServiceHandle(hService);
    if(hSvcMgr) CloseServiceHandle(hSvcMgr);
    if(hKey) RegCloseKey(hKey);
    return success;
}

BOOL InstallStiService(void)
{
    BOOL success = FALSE;
    HINF hInf = INVALID_HANDLE_VALUE;
    SC_HANDLE hSvcMgr = NULL;
    SC_HANDLE hService = NULL;
    TCHAR DisplayName[260];
    TCHAR Description[260];
    HMODULE hModule;
    HKEY hKey = NULL;
    LONG lResult;

    CHECK(hModule = GetModuleHandle(szModuleName));
    CHECK(LoadString(hModule, IDS_STI_DISPLAY_NAME, DisplayName, ARRAY_LENGTH(DisplayName)));
    CHECK(LoadString(hModule, IDS_STI_DESCRIPTION, Description, ARRAY_LENGTH(Description)));


    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SVCHOST, 
        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lResult == ERROR_SUCCESS) 
    {
        RegDeleteValue(hKey, _T("imgsvc"));
        CHECK_SUCCESS(RegCloseKey(hKey));
        hKey = NULL;
    }

    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_STISVC_PARAMETERS,
        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL);
    if(lResult == ERROR_SUCCESS)
    {
        RegDeleteValue(hKey, _T("ServiceDll"));
        CHECK_SUCCESS(RegCloseKey(hKey));
        hKey = NULL;
    }

    CHECK(hSvcMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));

    CHECK(hService = CreateService(hSvcMgr,
        _T("StiSvc"),
        DisplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS,
        SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        _T("%SystemRoot%\\System32\\stisvc.exe"),
        NULL,
        NULL,
        _T("RpcSs\0"),
        _T("LocalSystem"),
        NULL));

    hInf = SetupOpenInfFile(_T("sti.inf"), NULL, INF_STYLE_WIN4, NULL);
    CHECK(hInf != INVALID_HANDLE_VALUE);

    CHECK(SetupInstallFromInfSection(NULL, hInf, _T("ClassInstall32"),
        SPINST_REGISTRY, NULL, NULL, 0, NULL, NULL, NULL, NULL));

     success = TRUE;

Cleanup:
    if(hService) CloseServiceHandle(hService);
    if(hSvcMgr) CloseServiceHandle(hSvcMgr);
    if(hInf != INVALID_HANDLE_VALUE) SetupCloseInfFile(hInf);
    if(hKey) RegCloseKey(hKey);
    return TRUE;
}

void GetErrorText(DWORD dwError, CHAR *ErrorText, UINT maxChar)
{
	DWORD messageLength, charsToMove;
	LPSTR pBuffer = NULL;

	messageLength = FormatMessageA(
		FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
		NULL,
		dwError,
		0,
		(LPSTR)&pBuffer,
		0,
		NULL);

	charsToMove = min(maxChar, messageLength);

	if(charsToMove == 0) 
	{
		wsprintfA(ErrorText, "Unknown error %d (0x%X)", dwError, dwError);
	} 
	else if(charsToMove == maxChar) 
	{
		lstrcpyA(ErrorText, pBuffer);
		ErrorText[maxChar - 1] = '\0';
	} 
	else 
	{
		lstrcpyA(ErrorText, pBuffer);
	}

	if(pBuffer) LocalFree(pBuffer);
}


void Trace(LPTSTR fmt, ...)
{
    TCHAR buffer[1024];
    TCHAR fileName[MAX_PATH];
    HANDLE hFile;
    DWORD cbWritten;
    va_list a;

    va_start(a, fmt);

    wvsprintf(buffer, fmt, a);

    if(!ExpandEnvironmentStrings(_T("%SystemRoot%\\system32\\wiasetup.log"), fileName, MAX_PATH))
        lstrcpy(fileName, _T("wiasetup.log"));

    hFile = CreateFile(fileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
        NULL, OPEN_ALWAYS, 0, NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
#ifdef UNICODE
		CHAR bufferA[1024];

		WideCharToMultiByte(CP_ACP, 0, buffer, -1, bufferA, 1024, NULL, NULL);
#endif
        SetFilePointer(hFile, 0, 0, FILE_END);
#ifdef UNICODE
		WriteFile(hFile, bufferA, lstrlenA(bufferA), &cbWritten, NULL);
#else
        WriteFile(hFile, buffer, lstrlen(buffer), &cbWritten, NULL);
#endif
        CloseHandle(hFile);
    }

#ifdef DEBUG
    OutputDebugString(buffer);
#endif
}

void MakeFileName(TCHAR *FileName, TCHAR *Directory, TCHAR *BaseName)
{
    TCHAR c = _T('\0');

    // copy directory name
    while(*Directory) 
    {
        c = *(Directory++);
        *(FileName++) = c;
    }

    // make sure there is "\" or "/" between directory and file name
    if(c != _T('\\') && c != _T('/'))
    {
        *(FileName++) = _T('\\');
    }

    // append base name
    while(*BaseName)
    {
        *(FileName++) = *(BaseName++);
    }

    // zero-terminate resulting file name
    *(FileName++) = _T('\0');
}


BOOL MyDeleteService(TCHAR *ServiceName)
{
    BOOL success = FALSE;
    SC_HANDLE hSvcMgr = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;
    DWORD checkPoint;

    CHECK(hSvcMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));

    hService = OpenService(hSvcMgr, ServiceName, SERVICE_ALL_ACCESS);
    if(hService == NULL) 
    {
        if(GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) 
        {
            success = TRUE;
            goto Cleanup;
        } 

        TRACE((_T("Failed to open service\n")));
    }

    if(ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus))
    {
        while(ServiceStatus.dwCurrentState != SERVICE_STOPPED) 
        {
            checkPoint = ServiceStatus.dwCheckPoint;

            Sleep(ServiceStatus.dwWaitHint);

            CHECK(QueryServiceStatus(hService, &ServiceStatus));
            CHECK(ServiceStatus.dwCheckPoint != checkPoint);
        }
    } 
    else
    {
        CHECK(GetLastError() == ERROR_SERVICE_NOT_ACTIVE);
    }

    CHECK(DeleteService(hService));

    success = TRUE;

Cleanup:
    if(hService) CloseServiceHandle(hService);
    if(hSvcMgr) CloseServiceHandle(hSvcMgr);

    return success;
}

BOOL
MyDeleteFile(TCHAR *File)
{
    BOOL success = FALSE;
    TCHAR Backup[MAX_PATH];
    DWORD dwAttributes;

    dwAttributes = GetFileAttributes(File);
    if(dwAttributes == -1 || DeleteFile(File)) 
    {
        success = TRUE;
        goto Cleanup;
    }

    lstrcpy(Backup, File);
    lstrcat(Backup, _T(".deleted"));

    dwAttributes = GetFileAttributes(Backup);
    if(dwAttributes != -1)
    {
        if(!DeleteFile(Backup)) 
        {
            TRACE((_T("Can't delete %s, GetLastError() = \n"), Backup, GetLastError()));
            goto Cleanup;
        }
    }

    success = MoveFile(File, Backup);

    MoveFileEx(Backup, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);

Cleanup:
    return success;
}


BOOL 
MyMoveFile(
    TCHAR *File, 
    TCHAR *SourceDir, 
    TCHAR *DestinationDir)
/*++

--*/
{
    BOOL success = FALSE;
    TCHAR Source[MAX_PATH];
    TCHAR Destination[MAX_PATH];
    DWORD dwAttributes;

    MakeFileName(Source, SourceDir, File);

    if(DestinationDir != NULL) 
    {
        //
        // If backup directory is specified, produce destination file name
        //
        MakeFileName(Destination, DestinationDir, File);

        //
        // Delete the destination file if it exists
        //
        dwAttributes = GetFileAttributes(Destination);
        if(dwAttributes == -1)
        {
			//
			// We don't expect this to fail even if file is in use
			//
			CHECK2(MoveFile(Source, Destination), ("%s %s", Source, Destination));
		}
		else
		{
			// Destination file already exists -- don't clobber it, 
			// just delete the source file
			CHECK2(MyDeleteFile(Source), ("%s", Source));
		}
    }
    else
    {
        //
        // If backup directory is not specified, we just delete the source file
        //
        CHECK2(MyDeleteFile(Source), ("%s", Source));
    }

    success = TRUE;

Cleanup:
    return success;
}

BOOL 
MyDeleteDirectory(
    TCHAR *Directory)
{
    BOOL success = TRUE;
    TCHAR path[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    DWORD dwAttributes;

    dwAttributes = GetFileAttributes(Directory);

    if(dwAttributes == -1) {
        success = TRUE;
        goto Cleanup;
    }

    CHECK((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);
    
    MakeFileName(path, Directory, _T("*.*"));
    
    hFind = FindFirstFile(path, &fd);

    while(hFind != INVALID_HANDLE_VALUE)
    {
        // delete any file or directory that is not "." or ".."
        if(lstrcmp(fd.cFileName, _T(".")) != 0 &&
            lstrcmp(fd.cFileName, _T("..")) != 0)
        {
            MakeFileName(path, Directory, fd.cFileName);
            dwAttributes = GetFileAttributes(path);
            if(dwAttributes & FILE_ATTRIBUTE_DIRECTORY) 
            {
                CHECK2(MyDeleteDirectory(path), ("%s", path));
            } else {
                CHECK2(MyDeleteFile(path), ("%s", path));
            }
        }
        
        // if no more files, 
        // close enumerator (and thus break out of loop) 
        if(!FindNextFile(hFind, &fd))
        {
            FindClose(hFind);
            hFind = INVALID_HANDLE_VALUE;
        }
    }

    // don't forget to delete the directory
    CHECK2(RemoveDirectory(Directory), ("%s", Directory));

    success = TRUE;

Cleanup:

    // if we jumped out of while() loop in error, 
    // don't leave enumerator orphaned
    if(hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
    }

    return success;
}


BOOL MyRegDeleteKey(HKEY hKey, TCHAR *subkey)
{
    BOOL success;
    UINT result;

    result = RegDeleteKey(hKey, subkey);

    success = (result == ERROR_SUCCESS || result == ERROR_FILE_NOT_FOUND);

    if(!success)
    {
        SetLastError(result);
    }

    return success;
}


BOOL RegisterServer32(TCHAR *Module, TCHAR *Options)
{
    BOOL success = FALSE;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR Regsvr32[MAX_PATH];
    TCHAR *CmdLine = NULL;

    CHECK(ExpandEnvironmentStrings(_T("%SystemRoot%\\system32\\regsvr32.exe "), Regsvr32, MAX_PATH));

    CmdLine = (TCHAR *)LocalAlloc(LPTR, 
        sizeof(TCHAR) * (2 + lstrlen(Options) + lstrlen(Module) + lstrlen(Regsvr32)));
    CHECK(CmdLine != NULL);

    lstrcpy(CmdLine, Regsvr32);
    lstrcat(CmdLine, Options);
    lstrcat(CmdLine, _T(" "));
    lstrcat(CmdLine, Module);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    CHECK2(CreateProcess(NULL, CmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi), ("%s", CmdLine));

    CHECK(WaitForSingleObject(pi.hProcess, INFINITE) == WAIT_OBJECT_0);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    success = TRUE;

Cleanup:
    if(CmdLine) LocalFree((HLOCAL) CmdLine);
    return success;
}

BOOL IsFirstFileOlderThanSecond(TCHAR *FirstFile, TCHAR *SecondFile)
{
	BOOL success = FALSE;
	DWORD dwFirst, dwSecond;
	LPVOID pFirst = NULL;
	LPVOID pSecond = NULL;
	DWORD dummy;
	VS_FIXEDFILEINFO *pvFirst;
	VS_FIXEDFILEINFO *pvSecond;
	UINT uFirst, uSecond;

	dwFirst = GetFileVersionInfoSize(FirstFile, &dummy);
	dwSecond = GetFileVersionInfoSize(SecondFile, &dummy);
	if(dwFirst == 0 || dwSecond == 0) 
	{
		// one of them does not have version information.
		// consider this "not older"
		goto Cleanup;
	}
	CHECK(pFirst = LocalAlloc(LPTR, dwFirst));
	CHECK(pSecond = LocalAlloc(LPTR, dwSecond));
	CHECK(GetFileVersionInfo(FirstFile, 0, dwFirst, pFirst));
	CHECK(GetFileVersionInfo(SecondFile, 0, dwSecond, pSecond));
	CHECK(VerQueryValue(pFirst, _T("\\"), &pvFirst, &uFirst) && pvFirst);
	CHECK(VerQueryValue(pSecond, _T("\\"), &pvSecond, &uSecond) && pvSecond);

	if(pvFirst->dwFileVersionMS > pvSecond->dwFileVersionMS)
	{
		// first file version is definitely newer
		goto Cleanup;
	}

	if(pvFirst->dwFileVersionMS < pvSecond->dwFileVersionMS)
	{
		// first file is definitely older
		success = TRUE;
	}

	//
	// at this point we know that MS versions are the same
	//
	success = pvFirst->dwFileVersionLS < pvFirst->dwFileVersionLS;

Cleanup:
	if(pFirst) LocalFree(pFirst);
	if(pSecond) LocalFree(pSecond);

	return success;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\migmain.c ===
/*++

Copyright (c) 2000 Microsoft Corporation
All rights reserved.

Module Name:

    Migmain.c

Abstract:

    Routines to migrate Win95 to NT

Author:

    Keisuke Tsuchida (KeisukeT) 10-Oct-2000

Revision History:

--*/


#include    "precomp.h"
#pragma     hdrstop
#include    <devguid.h>
#include    "msg.h"

//
// Global
//

HINSTANCE   g_hInst = (HINSTANCE)NULL;

BOOL
DllEntryPoint(
    IN HINSTANCE    hInst,
    IN DWORD        dwReason,
    IN LPVOID       lpRes
    )

/*++

Routine Description:
    Dll entry point.

Arguments:

Return Value:

--*/
{
    UNREFERENCED_PARAMETER(lpRes);

    switch( dwReason ){

        case DLL_PROCESS_ATTACH:
            g_hInst = hInst;
            SetupOpenLog(FALSE);
            break;

        case DLL_PROCESS_DETACH:
            g_hInst = (HINSTANCE)NULL;
            SetupCloseLog();
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


LONG
QueryVersion(
    OUT     LPCSTR         *pszProductID,
    OUT     LPUINT          plDllVersion,
    OUT     LPINT          *pCodePageArray    OPTIONAL,
    OUT     LPCSTR         *ExeNamesBuf       OPTIONAL,
    OUT     PVENDORINFO    *pVendorInfo
    )
{
    BOOL            bFail = TRUE;
    LPSTR           pszLocalProductID;
    VENDORINFO      VendorInfo;
    DWORD           dwRet, dwNeeded, dwReturned, dwLangId;


    if ( !(pszLocalProductID = GetStringFromRcFileA(IDS_PRODUCTID)) )
        goto Done;

    ZeroMemory(&VendorInfo, sizeof(VendorInfo));
    dwLangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_COMPANY_NAME,
                   dwLangId,
                   VendorInfo.CompanyName,
                   sizeof(VendorInfo.CompanyName),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_SUPPORT_NUMBER,
                   dwLangId,
                   VendorInfo.SupportNumber,
                   sizeof(VendorInfo.SupportNumber),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_SUPPORT_URL,
                   dwLangId,
                   VendorInfo.SupportUrl,
                   sizeof(VendorInfo.SupportUrl),
                   0);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   (LPVOID)g_hInst,
                   MSG_VI_INSTRUCTIONS,
                   dwLangId,
                   VendorInfo.InstructionsToUser,
                   sizeof(VendorInfo.InstructionsToUser),
                   0);


    *pszProductID   = pszLocalProductID;
    *plDllVersion   = 1;
    *pCodePageArray = NULL;
    *ExeNamesBuf    = NULL;
    *pVendorInfo    = &VendorInfo;

/********
    //
    // Call this DLL only if there are some printers or printer drivers
    // installed
    //
    if ( EnumPrinterDriversA(NULL,
                             NULL,
                             3,
                             NULL,
                             0,
                             &dwNeeded,
                             &dwReturned)   &&
          EnumPrintersA(PRINTER_ENUM_LOCAL,
                        NULL,
                        2,
                        NULL,
                        0,
                        &dwNeeded,
                        &dwReturned) ) {

        return ERROR_NOT_INSTALLED;
    }
********/

    bFail = FALSE;

Done:
    if ( bFail ) {

        if ( dwRet = GetLastError() )
            return dwRet;

        return STG_E_UNKNOWN;
    }

    return ERROR_SUCCESS;
}


P_QUERY_VERSION     pQueryVersion   = QueryVersion;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\nt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation
All rights reserved.

Module Name:

    Nt.c

Abstract:

    Routines to migrate Win95 printing components to NT

Author:

    Keisuke Tsuchida (KeisukeT) 10-Oct-2000

Revision History:

--*/


#include "precomp.h"

//
// Extern
//

extern LPCSTR  g_WorkingDirectory;
extern LPCSTR  g_SourceDirectory;
extern LPCSTR  g_MediaDirectory;

//
// Typedef
//

typedef BOOL (WINAPI *PMIGRATEDEVICE)(PDEVICE_INFO);
typedef DWORD (WINAPI *PSHDELETEKEY)(HKEY, LPCSTR);


VOID
DeleteWin95Files(
    )
/*++

Routine Description:
    Read the migrate.inf and delete the files which are not needed on NT.

Arguments:
    None

Return Value:
    None

--*/
{
    HINF            hInf;
    CHAR            szPath[MAX_PATH];
    LONG            Count, Index;
    INFCONTEXT      InfContext;

//    sprintf(szPath, "%s\\%s", UpgradeData.pszDir, "migrate.inf");

    hInf = SetupOpenInfFileA(szPath, NULL, INF_STYLE_WIN4, NULL);

    if ( hInf == INVALID_HANDLE_VALUE )
        return;

    //
    // We will only do the deleting part here. Files which are handled by
    // the core migration dll do not have a destination directory since we
    // are recreating the printing environment from scratch
    //
    if ( (Count = SetupGetLineCountA(hInf, "Moved")) != -1 ) {

        for ( Index = 0 ; Index < Count ; ++Index ) {

            if ( SetupGetLineByIndexA(hInf, "Moved", Index, &InfContext)    &&
                 SetupGetStringFieldA(&InfContext, 0, szPath,
                                      sizeof(szPath), NULL) )
                DeleteFileA(szPath);
        }
    }

    SetupCloseInfFile(hInf);
}


PSECURITY_DESCRIPTOR
GetSecurityDescriptor(
    IN  LPCSTR  pszUser
    )
/*++

Routine Description:
    Get the users security

Arguments:
    pszUser     : sub key under HKEY_USER

Return Value:
    NULL on error, else a valid SECURITY_DESCRIPTOR.
    Memory is allocated in the heap and caller should free it.

--*/
{
    HKEY                    hKey = NULL;
    DWORD                   dwSize;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    if ( RegOpenKeyExA(HKEY_USERS,
                       pszUser,
                       0,
                       KEY_READ|KEY_WRITE,
                       &hKey)                                       ||
         RegGetKeySecurity(hKey,
                           DACL_SECURITY_INFORMATION,
                           NULL,
                           &dwSize) != ERROR_INSUFFICIENT_BUFFER    ||
         !(pSD = (PSECURITY_DESCRIPTOR) AllocMem(dwSize))           ||
         RegGetKeySecurity(hKey,
                           DACL_SECURITY_INFORMATION,
                           pSD,
                           &dwSize) ) {

        if ( hKey )
            RegCloseKey(hKey);

        FreeMem(pSD);
        pSD = NULL;
    }

    return pSD;
}


LONG
CALLBACK
InitializeNT(
    IN  LPCWSTR pszWorkingDir,
    IN  LPCWSTR pszSourceDir,
    IN  LPCWSTR pszMediaDir
    )
{
    LONG    lError;

    //
    // Initialize local.
    //
    
    lError = ERROR_SUCCESS;

    //
    // Save given parameters.
    //
    
    g_WorkingDirectory   = AllocStrAFromStrW(pszWorkingDir);
    g_SourceDirectory    = AllocStrAFromStrW(pszSourceDir);
    g_MediaDirectory     = AllocStrAFromStrW(pszMediaDir);

    if(NULL == g_WorkingDirectory){
        SetupLogError("WIA Migration: InitializeNT: ERROR!! insufficient memory.", LogSevError);
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto InitializeNT_return;
    }

InitializeNT_return:

    if(ERROR_SUCCESS != lError){
        
        //
        // Can't process migration. Clean up.
        //
        
        if(NULL != g_WorkingDirectory){
            FreeMem((PVOID)g_WorkingDirectory);
            g_WorkingDirectory = NULL;
        }

        if(NULL != g_SourceDirectory){
            FreeMem((PVOID)g_SourceDirectory);
            g_SourceDirectory = NULL;
        }

        if(NULL != g_MediaDirectory){
            FreeMem((PVOID)g_MediaDirectory);
            g_MediaDirectory = NULL;
        }
    } // if(ERROR_SUCCESS != lError)

    return lError;
}


LONG
CALLBACK
MigrateUserNT(
    IN  HINF        hUnattendInf,
    IN  HKEY        hUserRegKey,
    IN  LPCWSTR     pszUserName,
        LPVOID      Reserved
    )
{
    return  ERROR_SUCCESS;
}


LONG
CALLBACK
MigrateSystemNT(
    IN  HINF    hUnattendInf,
        LPVOID  Reserved
    )
{
    LONG    lError;
    HANDLE  hFile;
    CHAR    szFile[MAX_PATH];

    //
    // Initialize local.
    //

    lError  = ERROR_SUCCESS;
    hFile   = (HANDLE)INVALID_HANDLE_VALUE;

    //
    // Check global initialization.
    //

    if(NULL == g_WorkingDirectory){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        MyLogError("WIA Migration: MigrateSystemNT: ERROR!! Initialize failed. Err=0x%x\n", lError);

        goto MigrateSystemNT_return;
    } // if(NULL == g_WorkingDirectory)

    //
    // Create path to the files.
    //

//    wsprintfA(szFile, "%s\\%s", g_WorkingDirectory, NAME_WIN9X_SETTING_FILE_A);
    _snprintf(szFile, sizeof(szFile), "%s\\%s", g_WorkingDirectory, NAME_WIN9X_SETTING_FILE_A);

    //
    // Open migration file.
    //

    hFile = CreateFileA(szFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE){
        lError = GetLastError();
        MyLogError("WIA Migration: MigrateSystemNT: ERROR!! Unable to open setting file. Err=0x%x\n", lError);

        goto MigrateSystemNT_return;
    } // if (hFile == INVALID_HANDLE_VALUE)

    //
    // Process migration info file created on Win9x.
    //

    lError = MigNtProcessMigrationInfo(hFile);

    //
    // Remove certain reg if inbox Kodak Imaging for Win9x is installed.
    //

    if(MigNtIsWin9xImagingExisting()){
        MigNtRemoveKodakImagingKey();
    } // if(MigNtIsWin9xImagingExisting())

MigrateSystemNT_return:

    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE == hFile){
        CloseHandle(hFile);
    }

    return lError;
} // MigrateSystemNT()


LONG
MigNtProcessMigrationInfo(
    HANDLE  hFile
    )
{
    LONG            lError;
    DEVICE_INFO     MigrateDevice;
    HMODULE         hInstaller;
    PMIGRATEDEVICE  pfnMigrateDevice;


    //
    // Initialize local.
    //

    lError              = ERROR_SUCCESS;
    hInstaller          = (HMODULE)NULL;
    pfnMigrateDevice    = NULL;

    memset(&MigrateDevice, 0, sizeof(MigrateDevice));

    //
    // Load STI_CI.DLL.
    //

    hInstaller = LoadLibrary(NAME_INSTALLER_A);
    if(NULL == hInstaller){
        
        //
        // Unable to load sti_ci.dll.
        //

        lError = GetLastError();
        MyLogError("WIA Migration: MigNtProcessMigrationInfo: ERROR!! Unable to load sti_ci.dll. Err=0x%x\n", lError);

        goto MigNtProcessMigrationInfo_return;

    } // if(NULL == hInstaller)

    //
    // Get address of MigrateDevice()
    //

    pfnMigrateDevice = (PMIGRATEDEVICE)GetProcAddress(hInstaller, NAME_PROC_MIGRATEDEVICE_A);
    if(NULL == pfnMigrateDevice){
        
        //
        // Unable to get proc address.
        //

        lError = GetLastError();
        MyLogError("WIA Migration: MigNtProcessMigrationInfo: ERROR!! Unable to get proc address. Err=0x%x\n", lError);

        goto MigNtProcessMigrationInfo_return;

    } // if(NULL == pfnMigrateDevice)

    //
    // Query migrating device.
    //

    while(ERROR_SUCCESS == MigNtGetDevice(hFile, &MigrateDevice)){

        //
        // Install only COM/LPT device.
        //

        if( (NULL != strstr(MigrateDevice.pszCreateFileName, "COM"))
         || (NULL != strstr(MigrateDevice.pszCreateFileName, "LPT"))
         || (NULL != strstr(MigrateDevice.pszCreateFileName, "AUTO")) )
        {
            pfnMigrateDevice(&MigrateDevice);
        }

/***********
{
PPARAM_LIST pTemp;

printf("\"%s\" = \"%s\"\r\n", NAME_FRIENDLYNAME_A, MigrateDevice.pszFriendlyName);
printf("\"%s\" = \"%s\"\r\n", NAME_CREATEFILENAME_A, MigrateDevice.pszCreateFileName);
printf("\"%s\" = \"%s\"\r\n", NAME_INF_PATH_A, MigrateDevice.pszInfPath);
printf("\"%s\" = \"%s\"\r\n", NAME_INF_SECTION_A, MigrateDevice.pszInfSection);
    
for(pTemp = MigrateDevice.pDeviceDataParam; pTemp != NULL;){
    printf("\"%s\" = \"%s\"\r\n", pTemp->pParam1, pTemp->pParam2);
    pTemp = (PPARAM_LIST)pTemp->pNext;
} // for(pTemp = MigrateDevice.pDeviceDataParam; pTemp != NULL;)

printf("\r\n");

}
***********/

        //
        // Clean up.
        //

      MigNtFreeDeviceInfo(&MigrateDevice);

    } // while(ERROR_SUCCESS == MigNtGetDevice(hFile, &MigrateDevice))


MigNtProcessMigrationInfo_return:

    //
    // Clean up.
    //
    
    if(NULL != hInstaller){
        FreeLibrary(hInstaller);
    }
    
    return lError;
} // MigNtProcessMigrationInfo()


LONG
MigNtGetDevice(
    HANDLE          hFile,
    PDEVICE_INFO    pMigrateDevice
    )
{
    LONG        lError;
    LPSTR       pParam1;
    LPSTR       pParam2;
    BOOL        bFound;
    LPSTR       pszFriendlyName;
    LPSTR       pszCreateFileName;
    LPSTR       pszInfPath;
    LPSTR       pszInfSection;
    DWORD       dwNumberOfDeviceDataKey;
    PPARAM_LIST pDeviceDataParam;
    PPARAM_LIST pTempParam;
    //
    // Initialize local.
    //

    lError                  = ERROR_SUCCESS;
    pParam1                 = NULL;
    pParam2                 = NULL;
    bFound                  = FALSE;
    
    pszFriendlyName         = NULL;
    pszCreateFileName       = NULL;
    pszInfPath              = NULL;
    pszInfSection           = NULL;
    pDeviceDataParam        = NULL;
    pTempParam              = NULL;
    dwNumberOfDeviceDataKey = 0;

    //
    // Find "Device = BEGIN"
    //
    
    while(FALSE == bFound){
        
        ReadString(hFile, &pParam1, &pParam2);
        if( (NULL == pParam1) && (NULL == pParam2) ){
            //
            // Error or EOF.
            //

            lError = ERROR_NO_MORE_ITEMS;
            goto MigNtGetDevice_return;
        }
        
        if( (0 == lstrcmpiA(pParam1, NAME_DEVICE_A))
         && (0 == lstrcmpiA(pParam2, NAME_BEGIN_A)) )
        {
            
            //
            // Found begining of device description.
            //

            bFound = TRUE;
        }

        //
        // Free allocated memory.
        //

        FreeMem(pParam1);
        FreeMem(pParam2);
        pParam1 = NULL;
        pParam2 = NULL;
    } // while(FALSE == bFound)

    //
    // Get FriendlyName
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != lstrcmpiA(pParam1, NAME_FRIENDLYNAME_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != lstrcmpiA(pParam1, NAME_FRIENDLYNAME_A))

    //
    // Copy to allocated buffer.
    //

    pszFriendlyName = AllocStrA(pParam2);
    FreeMem(pParam1);
    FreeMem(pParam2);
    pParam1 = NULL;
    pParam2 = NULL;

    //
    // Get CreateFileName
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != lstrcmpiA(pParam1, NAME_CREATEFILENAME_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != lstrcmpiA(pParam1, NAME_CREATEFILENAME_A))

    //
    // Copy to allocated buffer.
    //

    pszCreateFileName = AllocStrA(pParam2);
    FreeMem(pParam1);
    FreeMem(pParam2);
    pParam1 = NULL;
    pParam2 = NULL;

    //
    // Get InfPath
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != lstrcmpiA(pParam1, NAME_INF_PATH_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != lstrcmpiA(pParam1, NAME_INF_PATH_A))

    //
    // Copy to allocated buffer.
    //

    pszInfPath = AllocStrA(pParam2);
    FreeMem(pParam1);
    FreeMem(pParam2);
    pParam1 = NULL;
    pParam2 = NULL;

    //
    // Get InfSection
    //

    ReadString(hFile, &pParam1, &pParam2);
    if( (NULL == pParam1) || (NULL == pParam2) ){
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigNtGetDevice_return;
    } // if( (NULL == pParam1) || (NULL == pParam2) )
    if(0 != lstrcmpiA(pParam1, NAME_INF_SECTION_A)){
        
        //
        // Invalid migration file.
        //
        
        lError = ERROR_INVALID_PARAMETER;
        goto MigNtGetDevice_return;
    } //if(0 != lstrcmpiA(pParam1, NAME_INF_SECTION_A))

    //
    // Copy to allocated buffer.
    //

    pszInfSection = AllocStrA(pParam2);
    FreeMem(pParam1);
    FreeMem(pParam2);
    pParam1 = NULL;
    pParam2 = NULL;

    //
    // Get DeviceData section.
    //

    bFound = FALSE;
    while(FALSE == bFound){
        ReadString(hFile, &pParam1, &pParam2);
        if( (NULL == pParam1) || (NULL == pParam2) ){
            lError = ERROR_NOT_ENOUGH_MEMORY;
            goto MigNtGetDevice_return;
        } // if( (NULL == pParam1) || (NULL == pParam2) )
        
        if(0 == lstrcmpiA(pParam1, REGKEY_DEVICEDATA_A)){
            //
            // Found beginning of DeviceData section.
            //

            bFound = TRUE;
        
        } // if(0 == lstrcmpiA(pParam1, REGKEY_DEVICEDATA_A))
        
        FreeMem(pParam1);
        FreeMem(pParam2);
        pParam1 = NULL;
        pParam2 = NULL;
        
    } // while(FALSE == bFound)

    //
    // Process until DeviceData = END is found.
    //

    bFound = FALSE;
    while(FALSE == bFound){
        ReadString(hFile, &pParam1, &pParam2);
        if( (NULL == pParam1) || (NULL == pParam2) ){
            lError = ERROR_NOT_ENOUGH_MEMORY;
            goto MigNtGetDevice_return;
        } // if( (NULL == pParam1) || (NULL == pParam2) )
        
        if( (0 == lstrcmpiA(pParam1, REGKEY_DEVICEDATA_A))
         && (0 == lstrcmpiA(pParam2, NAME_END_A)) )
        {
            //
            // Found beginning of DeviceData section.
            //

            bFound = TRUE;

            FreeMem(pParam1);
            FreeMem(pParam2);
            pParam1 = NULL;
            pParam2 = NULL;
            break;
        } // if(0 == lstrcmpiA(pParam1, REGKEY_DEVICEDATA_A))

        //
        // Increment counter.
        //

        dwNumberOfDeviceDataKey++;

        //
        // Allocate new structure for parameters.
        //
        
        pTempParam  = (PPARAM_LIST)AllocMem(sizeof(PARAM_LIST));
        if(NULL == pTempParam){
            lError = ERROR_NOT_ENOUGH_MEMORY;
            goto MigNtGetDevice_return;
        } // if(NULL == pTempParam)

        //
        // Set parameters.
        //

        pTempParam->pNext   = NULL;
        pTempParam->pParam1 = AllocStrA(pParam1);
        pTempParam->pParam2 = AllocStrA(pParam2);

        //
        // Add this parameter to list.
        //
        
        if(NULL == pDeviceDataParam){
            pDeviceDataParam = pTempParam;
        } else { // if(NULL == pDeviceDataParam)
            PPARAM_LIST pTemp;
            
            //
            // Find the last data, and add.
            //
            
            for(pTemp = pDeviceDataParam; NULL !=pTemp->pNext; pTemp=(PPARAM_LIST)pTemp->pNext);
            pTemp->pNext = (PVOID)pTempParam;

        } // else(NULL == pDeviceDataParam)

        FreeMem(pParam1);
        FreeMem(pParam2);
        pParam1 = NULL;
        pParam2 = NULL;
        
    } // while(FALSE == bFound)

    //
    // Copy all data.
    //

    pMigrateDevice->pszFriendlyName         = pszFriendlyName;
    pMigrateDevice->pszCreateFileName       = pszCreateFileName;
    pMigrateDevice->pszInfPath              = pszInfPath;
    pMigrateDevice->pszInfSection           = pszInfSection;
    pMigrateDevice->dwNumberOfDeviceDataKey = dwNumberOfDeviceDataKey;
    pMigrateDevice->pDeviceDataParam        = pDeviceDataParam;

    //
    // Operation succeeded.
    //

    lError = ERROR_SUCCESS;

MigNtGetDevice_return:

    //
    // Clean up.
    //

    if(ERROR_SUCCESS != lError){
        PPARAM_LIST pTemp;
        
        //
        // Free all allocated parameters.
        //

        if(NULL != pszFriendlyName){
            FreeMem(pszFriendlyName);
        }
        if(NULL != pszCreateFileName){
            FreeMem(pszCreateFileName);
        }
        if(NULL != pszInfPath){
            FreeMem(pszInfPath);
        }
        if(NULL != pszInfSection){
            FreeMem(pszInfSection);
        }
        if(NULL != pDeviceDataParam){
            pTemp = pDeviceDataParam;
            while(NULL != pTemp){
                pDeviceDataParam = (PPARAM_LIST)pDeviceDataParam->pNext;
                FreeMem(pTemp);
                pTemp = pDeviceDataParam;
            } // while(NULL != pTemp)
        } // if(NULL != pDeviceDataParam)
    } // if(ERROR_SUCCESS != lError)

    if(NULL != pParam1){
        FreeMem(pParam1);
    }

    if(NULL != pParam2){
        FreeMem(pParam2);
    }
    
    return lError;
} // MigNtGetDevice()


VOID
MigNtFreeDeviceInfo(
    PDEVICE_INFO    pMigrateDevice
    )
{
    PPARAM_LIST pCurrent;
    PPARAM_LIST pNext;

    if(NULL == pMigrateDevice){
        goto MigNtFreeDeviceInfo_return;
    } // if(NULL == pMigrateDevice)

    //
    // Free all allocated parameters.
    //

    if(NULL != pMigrateDevice->pszFriendlyName){
        FreeMem(pMigrateDevice->pszFriendlyName);
    }
    if(NULL != pMigrateDevice->pszCreateFileName){
        FreeMem(pMigrateDevice->pszCreateFileName);
    }
    if(NULL != pMigrateDevice->pszInfPath){
        FreeMem(pMigrateDevice->pszInfPath);
    }
    if(NULL != pMigrateDevice->pszInfSection){
        FreeMem(pMigrateDevice->pszInfSection);
    }
    if(NULL != pMigrateDevice->pDeviceDataParam){
        pCurrent = pMigrateDevice->pDeviceDataParam;
        while(NULL != pCurrent){
            pNext = (PPARAM_LIST)pCurrent->pNext;
            FreeMem(pCurrent);
            pCurrent = pNext;
        } // while(NULL != pTemp)
    } // if(NULL != pDeviceDataParam)

    //
    // Null out the buffer.
    //

    memset(pMigrateDevice, 0, sizeof(DEVICE_INFO));

MigNtFreeDeviceInfo_return:
    return;
} // MigNtFreeDeviceInfo()

BOOL
CALLBACK
MigNtIsWin9xImagingExisting(
    VOID
    )
{
    BOOL                bRet;
    LONG                lError;
    HKEY                hkKodak;
    TCHAR               szWindowsDirectory[MAX_PATH];
    TCHAR               szKodakImaging[MAX_PATH];
    DWORD               dwVersionInfoSize;
    DWORD               dwDummy;
    PVOID               pVersion;
    PVOID               pFileVersionInfo;
    DWORD               dwFileVersionInfoSize;

    

    //
    // Initialize local.
    //

    bRet                    = FALSE;
    lError                  = ERROR_SUCCESS;
    dwVersionInfoSize       = 0;
    dwFileVersionInfoSize   = 0;
    pVersion                = NULL;
    pFileVersionInfo        = NULL;

    memset(szWindowsDirectory, 0, sizeof(szWindowsDirectory));
    memset(szKodakImaging, 0, sizeof(szKodakImaging));

    //
    // Get Windows directory.
    //

    if(0 == GetWindowsDirectory(szWindowsDirectory, sizeof(szWindowsDirectory)/sizeof(TCHAR))){
        lError = GetLastError();
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! GetWindowsDirectory() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(0 == GetWindowsDirectory(szTemp, sizeof(szTemp)/sizeof(TCHAR)))

    //
    // Create path to Kodak Imaging.
    //

//    wsprintf(szKodakImaging, "%s\\%s", szWindowsDirectory, NAME_KODAKIMAGING);
    _sntprintf(szKodakImaging, sizeof(szKodakImaging)/sizeof(TCHAR), TEXT("%s\\%s"), szWindowsDirectory, NAME_KODAKIMAGING);

    //
    // Get size of version resource of the file.
    //

    dwVersionInfoSize = GetFileVersionInfoSize(szKodakImaging, &dwDummy);
    if(0 == dwVersionInfoSize){
        
        //
        // Unable to get version info of the file. Most probably the file doesn't exist.
        //

        lError = GetLastError();
        if(ERROR_FILE_NOT_FOUND == lError){

            //
            // File doesn't exist. Now it's safe to remove regkey for kodakimg.exe.
            //
            
            bRet = TRUE;

        } // if(ERROR_FILE_NOT_FOUND == lError)
//        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! GetFileVersionInfoSize() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(0 == dwVersionInfoSize)

    //
    // Allocate required size of buffer.
    //

    pVersion = AllocMem(dwVersionInfoSize);
    if(NULL == pVersion){
        lError = ERROR_INSUFFICIENT_BUFFER;
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! InsufficientBuffer. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(NULL == pVersion)

    //
    // Get version info.
    //

    if(FALSE == GetFileVersionInfo(szKodakImaging, 0, dwVersionInfoSize, pVersion)){
        lError = GetLastError();
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! GetVersionInfo() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(FALSE == GetVersionInfo(szKodakImaging, 0, dwVersionInfoSize, pVersion))

    //
    // See if the binary is Win9x inbox.
    //

    if(FALSE == VerQueryValue(pVersion, TEXT("\\"), &pFileVersionInfo, &dwFileVersionInfoSize)){
        lError = GetLastError();
        MyLogError("WIA Migration: MigNtIsWin9xImagingExisting: ERROR!! VerQueryValue() failed. Err=0x%x\n", lError);

        goto MigNtIsWin9xImagingExisting_return;
    } // if(FALSE == VerQueryValue(pVersion, TEXT("\\"), &pFileVersionInfo, &dwFileVersionInfoSize))

    if( (FILEVER_KODAKIMAGING_WIN98_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionMS)
     && (FILEVER_KODAKIMAGING_WIN98_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionLS)
     && (PRODVER_KODAKIMAGING_WIN98_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionMS)
     && (PRODVER_KODAKIMAGING_WIN98_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionLS) )
    {
        //
        // This is Win98 inbox Kodak Imaging. Process regkey removal.
        //
        
        bRet = TRUE;
    } else if( (FILEVER_KODAKIMAGING_WINME_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionMS)
            && (FILEVER_KODAKIMAGING_WINME_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwFileVersionLS)
            && (PRODVER_KODAKIMAGING_WINME_MS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionMS)
            && (PRODVER_KODAKIMAGING_WINME_LS == ((VS_FIXEDFILEINFO *)pFileVersionInfo)->dwProductVersionLS) )
    {
        //
        // This is WinMe inbox Kodak Imaging. Process regkey removal.
        //
        
        bRet = TRUE;
    }

MigNtIsWin9xImagingExisting_return:
    
    //
    // Cleanup.
    //
    
    if(NULL != pVersion){
        FreeMem(pVersion);
    } // if(NULL != pVersion)

    return bRet;

} // MigNtIsWin9xImagingExisting()


VOID
CALLBACK
MigNtRemoveKodakImagingKey(
    VOID
    )
{

    HMODULE         hmShlwapi;
    PSHDELETEKEY    pfnSHDeleteKey;

    //
    // Initialize local.
    //

    hmShlwapi       = (HMODULE)NULL;
    pfnSHDeleteKey  = (PSHDELETEKEY)NULL;

    //
    // Load shlwapi.dll.
    //
    
    hmShlwapi = LoadLibrary(TEXT("shlwapi.dll"));
    if(NULL == hmShlwapi){
        MyLogError("WIA Migration: MigNtRemoveKodakImagingKey: ERROR!! Unable to load hmShlwapi.dll. Err=0x%x.\n", GetLastError());

        goto MigNtRemoveKodakImagingKey_return;
    } // if(NULL == hmShlwapi)

    //
    // Get proc address of SHDeleteKey.
    //

    pfnSHDeleteKey = (PSHDELETEKEY)GetProcAddress(hmShlwapi, TEXT("SHDeleteKeyA"));
    if(NULL == pfnSHDeleteKey){
        MyLogError("WIA Migration: MigNtRemoveKodakImagingKey: ERROR!! Unable to find SHDeleteKeyA. Err=0x%x.\n", GetLastError());

        goto MigNtRemoveKodakImagingKey_return;
    } // if(NULL == hmShlwapi)

    //
    // Delete key.
    //

    if(ERROR_SUCCESS != pfnSHDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_KODAKEVENT_A)){
        MyLogError("WIA Migration: MigNtRemoveKodakImagingKey: ERROR!! Unable to delete key. Err=0x%x.\n", GetLastError());

        goto MigNtRemoveKodakImagingKey_return;
    } // if(ERROR_SUCCESS != pfnSHDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_KODAKEVENT_A))

MigNtRemoveKodakImagingKey_return:
    if(NULL != hmShlwapi){
        FreeLibrary(hmShlwapi);
        hmShlwapi = NULL;
    } // if(NULL != hmShlwapi)

} // MigNtRemoveKodakImagingKey()

//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//
P_INITIALIZE_NT     pfnInitializeNT         = InitializeNT;
P_MIGRATE_USER_NT   pfnMigrateUserNt        = MigrateUserNT;
P_MIGRATE_SYSTEM_NT pfnMigrateSystemNT      = MigrateSystemNT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\resource.h ===
#define     IDS_PRODUCTID                   1001
#define     IDS_TITLE                       1002

#define     IDS_DRIVERS_UPGRADE_FAILED      2001
#define     IDS_DRIVER_UPGRADE_FAILED       2002
#define     IDS_ADDDRIVER_FAILED            2003
#define     IDS_ICM_FAILED                  2004
#define     IDS_DEFAULT_PRINTER_FAILED      2005
#define     IDS_ADDPRINTER_FAILED           2006
#define     IDS_ADDMONITOR_FAILED           2007

#define     IDS_PRINTER_CANT_MIGRATE        3001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\win9x.c ===
/*++

Copyright (c) 2000 Microsoft Corporation
All rights reserved.

Module Name:

    Win9x.c

Abstract:

    Routines to pre-migrate Win9x to NT

Author:

    Keisuke Tsuchida (KeisukeT) 10-Oct-2000

Revision History:

--*/


#include "precomp.h"
#include "devguid.h" 

//
// Globals
//

 LPCSTR  g_WorkingDirectory   = NULL;
 LPCSTR  g_SourceDirectory    = NULL;
 LPCSTR  g_MediaDirectory     = NULL;
//LPCSTR  g_WorkingDirectory   = ".";
//LPCSTR  g_SourceDirectory    = ".";
//LPCSTR  g_MediaDirectory     = ".";

LONG
CALLBACK
Initialize9x(
    IN  LPCSTR      pszWorkingDir,
    IN  LPCSTR      pszSourceDir,
    IN  LPCSTR      pszMediaDir
    )
{
    LONG    lError;

    //
    // Initialize local.
    //

    lError = ERROR_SUCCESS;

    //
    // Save given parameters.
    //
    
    g_WorkingDirectory   = AllocStrA(pszWorkingDir);
    g_SourceDirectory    = AllocStrA(pszSourceDir);
    g_MediaDirectory     = AllocStrA(pszMediaDir);

    if( (NULL == g_WorkingDirectory)
     || (NULL == g_SourceDirectory)
     || (NULL == g_MediaDirectory)   )
    {
        SetupLogError("WIA Migration: Initialize9x: ERROR!! insufficient memory.", LogSevError);
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto Initialize9x_return;
    }

Initialize9x_return:

    if(ERROR_SUCCESS != lError){
        
        //
        // Can't process migration. Clean up.
        //
        
        if(NULL != g_WorkingDirectory){
            FreeMem((PVOID)g_WorkingDirectory);
            g_WorkingDirectory = NULL;
        }

        if(NULL != g_SourceDirectory){
            FreeMem((PVOID)g_SourceDirectory);
            g_SourceDirectory = NULL;
        }

        if(NULL != g_MediaDirectory){
            FreeMem((PVOID)g_MediaDirectory);
            g_MediaDirectory = NULL;
        }
    } // if(ERROR_SUCCESS != lError)

    return lError;
} // Initialize9x()


LONG
CALLBACK
MigrateUser9x(
    IN  HWND        hwndParent,
    IN  LPCSTR      pszUnattendFile,
    IN  HKEY        hUserRegKey,
    IN  LPCSTR      pszUserName,
        LPVOID      Reserved
    )
{
    //
    // Nothing to do
    //

    return  ERROR_SUCCESS;
} // MigrateUser9x()


LONG
CALLBACK
MigrateSystem9x(
    IN      HWND        hwndParent,
    IN      LPCSTR      pszUnattendFile,
    IN      LPVOID      Reserved
    )
{
    LONG    lError;
    CHAR    szFile[MAX_PATH];
    CHAR    szInfName[MAX_PATH];

    HANDLE  hSettingStore;
    HANDLE  hInf;

    //
    // Initialize locals.
    //
    
    lError          = ERROR_SUCCESS;
    hSettingStore   = (HANDLE)INVALID_HANDLE_VALUE;
    hInf            = (HANDLE)INVALID_HANDLE_VALUE;

    //
    // Check global initialization.
    //

    if( (NULL == g_WorkingDirectory)
     || (NULL == g_SourceDirectory)
     || (NULL == g_MediaDirectory)   )
    {
        SetupLogError("WIA Migration: MigrateSystem9x: ERROR!! Initialize failed.", LogSevError);
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto MigrateSystem9x_return;
    }

    //
    // Create path to the files.
    //

    wsprintfA(szFile, "%s\\%s", g_WorkingDirectory, NAME_WIN9X_SETTING_FILE_A);
    wsprintfA(szInfName, "%s\\%s", g_WorkingDirectory, NAME_MIGRATE_INF_A);

    //
    // Create files.
    //

    hSettingStore = CreateFileA(szFile,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
    if(INVALID_HANDLE_VALUE == hSettingStore){
        SetupLogError("WIA Migration: MigrateSystem9x: ERROR!! Unable to create setting file.", LogSevError);

        lError = GetLastError();
        goto MigrateSystem9x_return;
    } // if(INVALID_HANDLE_VALUE == hSettingStore)

    //
    // Create setting file based on device registry.
    //

    lError = Mig9xGetDeviceInfo(hSettingStore);
    if(ERROR_SUCCESS != lError){
        goto MigrateSystem9x_return;
    } // if(ERROR_SUCCESS != lError)

MigrateSystem9x_return:

    //
    // Clean up.
    //

    if(hSettingStore != INVALID_HANDLE_VALUE){
        CloseHandle(hSettingStore);
    }
    
    if(hInf != INVALID_HANDLE_VALUE){
        CloseHandle(hInf);
    }

    return  lError;

} // MigrateSystem9x()


LONG
CALLBACK
Mig9xGetGlobalInfo(
    IN      HANDLE      hFile
    )
{

    LONG    lError;
    HKEY    hKey;
    

    //
    // Initialize local.
    //
    
    lError  = ERROR_SUCCESS;
    hKey    = (HKEY)INVALID_HANDLE_VALUE;
    
    //
    // Open HKLM\SYSTEM\CurrentControlSet\Control\StillImage.
    //
    
    lError = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_STICONTROL_A,
                        &hKey);
    if(ERROR_SUCCESS != lError){
        SetupLogError("WIA Migration: Mig9xGetGlobalInfo: ERROR!! Unable to open Conrtol\\StilImage.", LogSevError);

        goto Mig9xGetGlobalInfo_return;
    } // if(ERROR_SUCCESS != lError)

    //
    // Spew to a file.
    //

    lError = WriteRegistryToFile(hFile, hKey, "\0");

Mig9xGetGlobalInfo_return:

    //
    // Clean up.
    //
    
    if(INVALID_HANDLE_VALUE != hKey){
        RegCloseKey(hKey);
    } // if(INVALID_HANDLE_VALUE != hKey)
    
    return lError;

} // Mig9xGetGlobalInfo()

LONG
CALLBACK
Mig9xGetDeviceInfo(
    IN      HANDLE      hFile
    )
{

    LONG            lError;
    DWORD           Idx;
    GUID            Guid;
    HANDLE          hDevInfo;
    SP_DEVINFO_DATA spDevInfoData;
    HKEY            hKeyDevice;
    PCHAR           pTempBuffer;


    //
    // Initialize locals.
    //

    lError      = ERROR_SUCCESS;
    Guid        = GUID_DEVCLASS_IMAGE;
    hDevInfo    = (HANDLE)INVALID_HANDLE_VALUE;
    Idx         = 0;
    hKeyDevice  = (HKEY)INVALID_HANDLE_VALUE;
    pTempBuffer = NULL;

    //
    // Enumerate WIA/STI devices and spew device info.
    //

    hDevInfo = SetupDiGetClassDevs(&Guid, NULL, NULL, DIGCF_PROFILE);
    if(INVALID_HANDLE_VALUE == hDevInfo){
        
        SetupLogError("WIA Migration: Mig9xGetDeviceInfo: ERROR!! Unable to acquire device list.", LogSevError);
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto Mig9xGetDeviceInfo_return;
        
    } // if(INVALID_HANDLE_VALUE == hDevInfo)

    //
    // Save installed device setting.
    //
    
    spDevInfoData.cbSize = sizeof(spDevInfoData);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++) {

        //
        // Open device registry key.
        //

        hKeyDevice = SetupDiOpenDevRegKey(hDevInfo,
                                          &spDevInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ);

        if (INVALID_HANDLE_VALUE != hKeyDevice) {
            
            if( (TRUE == IsSti(hKeyDevice))
             && (FALSE == IsKernelDriverRequired(hKeyDevice)) )
            {
                
                //
                // This is STI/WIA device with no kernel driver . Spew required info.
                //
                
                WriteDeviceToFile(hFile, hKeyDevice);
                
            } // if( IsSti(hKeyDevice) && !IsKernelDriverRequired(hKeyDevice))
        } // if (INVALID_HANDLE_VALUE != hKeyDevice) 
    } // for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)




Mig9xGetDeviceInfo_return:

    if(NULL != pTempBuffer){
        FreeMem(pTempBuffer);
    } // if(NULL != pTempBuffer)

    return lError;
} // Mig9xGetGlobalInfo()



BOOL
IsSti(
    HKEY    hKeyDevice
    )
{
    BOOL    bRet;
    PCHAR   pTempBuffer;
    LONG    lError;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    pTempBuffer = NULL;
    lError      = ERROR_SUCCESS;
    
    //
    // See if it's StillImage device.
    //
    
    lError = GetRegData(hKeyDevice, 
                        REGVAL_USDCLASS_A, 
                        &pTempBuffer, 
                        NULL, 
                        NULL);
    
    if( (ERROR_SUCCESS != lError)
     || (NULL == pTempBuffer) )
    {
        //
        // Unable to get "SubClass" data. This is not STI/WIA.
        //
        
        bRet = FALSE;
        goto IsSti_return;
    } // if( (ERROR_SUCCESS != lError) || (NULL == pTempBuffer)
    
    //
    // This is STI/WIA device.
    //

    bRet = TRUE;

IsSti_return:
    
    //
    // Clean up.
    //

    if(NULL != pTempBuffer){
        FreeMem(pTempBuffer);
    } // if(NULL != pTempBuffer)

    return bRet;
} // IsSti()


BOOL
IsKernelDriverRequired(
    HKEY    hKeyDevice
    )
{
    BOOL    bRet;
    PCHAR   pTempBuffer;
    LONG    lError;
    
    //
    // Initialize local.
    //

    bRet        = FALSE;
    pTempBuffer = NULL;
    lError      = ERROR_SUCCESS;
    
    //
    // See if it's StillImage device.
    //
    
    lError = GetRegData(hKeyDevice, 
                        REGVAL_NTMPDRIVER_A, 
                        &pTempBuffer, 
                        NULL, 
                        NULL);
    
    if( (ERROR_SUCCESS != lError)
     || (NULL == pTempBuffer) )
    {
        //
        // Unable to get "NTMPDriver" data. This device doesn't require kernel mode component.
        //

        bRet = FALSE;
        goto IsKernelDriverRequired_return;
    } // if( (ERROR_SUCCESS != lError) || (NULL == pTempBuffer)
    
    //
    // This device requires kernel mode component.
    //

    bRet = TRUE;

IsKernelDriverRequired_return:
    
    //
    // Clean up.
    //

    if(NULL != pTempBuffer){
        FreeMem(pTempBuffer);
    } // if(NULL != pTempBuffer)

    return bRet;
} // IsKernelDriverRequired()

LONG
WriteDeviceToFile(
    HANDLE  hFile,
    HKEY    hKey
    )
{
    LONG    lError;
    PCHAR   pFriendlyName;
    PCHAR   pCreateFileName;
    PCHAR   pInfPath;
    PCHAR   pInfSection;
    DWORD   dwType;
    CHAR    SpewBuffer[256];
    HKEY    hDeviceData;
    
    //
    // Initialize local.
    //

    lError          = ERROR_SUCCESS;
    pFriendlyName   = NULL;
    pCreateFileName = NULL;
    pInfPath        = NULL;
    pInfSection     = NULL;
    hDeviceData     = (HKEY)INVALID_HANDLE_VALUE;
    
    memset(SpewBuffer, 0, sizeof(SpewBuffer));

    //
    // Get FriendlyName.
    //
    
    lError = GetRegData(hKey, NAME_FRIENDLYNAME_A, &pFriendlyName, &dwType, NULL);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get FriendlyName.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get FriendlyName.", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // FriendlyName key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! FriendlyName is other than REG_SZ.", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    //
    // Get CreateFileName.
    //

    lError = GetRegData(hKey, NAME_CREATEFILENAME_A, &pCreateFileName, &dwType, NULL);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get CreateFileName.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get CreateFileName.", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // CreateFileName key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! CreateFileName is other than REG_SZ.", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    //
    // Get InfPath.
    //
    
    lError = GetRegData(hKey, NAME_INF_PATH_A, &pInfPath, &dwType, NULL);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get InfPath.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get InfPath.", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // InfPath key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! InfPath is other than REG_SZ.", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    //
    // Get InfSection.
    //

    lError = GetRegData(hKey, NAME_INF_SECTION_A, &pInfSection, &dwType, NULL);
    if(ERROR_SUCCESS != lError){
        
        //
        // Unable to get InfSection.
        //
        
        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! Unable to get InfSection.", LogSevError);
        goto WriteDeviceToFile_return;
    } // if(ERROR_SUCCESS != lError)

    if(REG_SZ != dwType){

        //
        // InfSection key is other than REG_SZ.
        //

        SetupLogError("WIA Migration: WriteDeviceToFile: ERROR!! InfSection is other than REG_SZ.", LogSevError);
        lError = ERROR_REGISTRY_CORRUPT;
        goto WriteDeviceToFile_return;
    } // if(REG_SZ != dwType)

    //
    // Spew device information.
    //

    WriteToFile(hFile, "\r\n");
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_DEVICE_A, NAME_BEGIN_A);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_FRIENDLYNAME_A, pFriendlyName);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_CREATEFILENAME_A, pCreateFileName);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_INF_PATH_A, pInfPath);
    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_INF_SECTION_A, pInfSection);

    //
    // Spew DaviceData section.
    //

    lError = RegOpenKey(hKey,
                        REGKEY_DEVICEDATA_A,
                        &hDeviceData);

    if(lError != ERROR_SUCCESS){

        //
        // Unable to open DeviceData or doesn't exist.
        //

    }

    //
    // Spew DeviceData section if exists.
    //

    if(INVALID_HANDLE_VALUE != hDeviceData){
        
        lError = WriteRegistryToFile(hFile, hDeviceData, REGKEY_DEVICEDATA_A);
        
    } // if(INVALID_HANDLE_VALUE != hDeviceData)

    //
    // Indicate the end of device description.
    //

    WriteToFile(hFile, "\"%s\" = \"%s\"\r\n", NAME_DEVICE_A, NAME_END_A);

WriteDeviceToFile_return:
    
    //
    // Clean up.
    //

    if(INVALID_HANDLE_VALUE != hDeviceData){
        RegCloseKey(hDeviceData);
    } //if(INVALID_HANDLE_VALUE != hDeviceData)

    if(NULL != pFriendlyName){
        FreeMem(pFriendlyName);
    }

    if(NULL != pCreateFileName){
        FreeMem(pCreateFileName);
    }

    if(NULL != pInfPath){
        FreeMem(pInfPath);
    }

    if(NULL != pInfSection){
        FreeMem(pInfSection);
    }

    return lError;
} // WriteDeviceToFile()


//
// The following are to make sure if setup changes the header file they
// first tell me (otherwise they will break build of this)
//

P_INITIALIZE_9X     pfnInitialize9x         = Initialize9x;
P_MIGRATE_USER_9X   pfnMigrateUser9x        = MigrateUser9x;
P_MIGRATE_SYSTEM_9X pfnMigrateSystem9x      = MigrateSystem9x;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation
All rights reserved.

Module Name:

    Util.c

Abstract:

    Uitility routines for printer migration from Win9x to NT

Author:

    Muhunthan Sivapragasam (MuhuntS) 02-Jan-1996

Revision History:

--*/


#include "precomp.h"


VOID
DebugMsg(
    LPCSTR  pszFormat,
    ...
    )
/*++

Routine Description:
    On debug builds brings up a message box on severe errors

Arguments:
    pszFormat   : Format string

Return Value:
    None

--*/
{
#if DBG
    LPSTR       psz;
    CHAR        szMsg[1024];
    va_list     vargs;

    va_start(vargs, pszFormat);
    vsprintf(szMsg, pszFormat, vargs);
    va_end(vargs);

#ifdef  MYDEBUG
    if ( psz = GetStringFromRcFileA(IDS_TITLE) ) {

        MessageBoxA(NULL, szMsg, psz, MB_OK);
        FreeMem(psz);
    }
#else
    OutputDebugStringA("Printing Migration : ");
    OutputDebugStringA(szMsg);
    OutputDebugStringA("\n");
#endif


#endif
}



VOID
LogError(
    IN  LogSeverity     Severity,
    IN  UINT            uMessageId,
    ...
    )
/*++

Routine Description:
    Logs an error in the setup error log on NT side when something can not be
    upgraded

Arguments:
    uMessageId  : Id to string in .rc file

Return Value:
    None

--*/
{
    LPSTR      pszFormat;
    CHAR       szMsg[1024];

    va_list     vargs;

    va_start(vargs, uMessageId);

    pszFormat = GetStringFromRcFileA(uMessageId);

    if ( pszFormat ) {

        wvsprintfA(szMsg, pszFormat, vargs);
        DebugMsg("%s", szMsg);
        SetupLogErrorA(szMsg, Severity);
    }

    FreeMem(pszFormat);

    va_end(vargs);
}


LPSTR
ErrorMsg(
    VOID
    )
/*++

Routine Description:
    Returns the error message string from a Win32 error

Arguments:
    None

Return Value:
    Pointer to a message string. Caller should free the string

--*/
{
    DWORD   dwLastError;
    LPSTR   pszStr = NULL;

    if ( !(dwLastError = GetLastError()) )
        dwLastError = STG_E_UNKNOWN;

    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER    |
                        FORMAT_MESSAGE_IGNORE_INSERTS   |
                        FORMAT_MESSAGE_FROM_SYSTEM      |
                        FORMAT_MESSAGE_MAX_WIDTH_MASK,
                   NULL,
                   dwLastError,
                   0,
                   (LPSTR)&pszStr,
                   0,
                   NULL);

    return pszStr;
}


PVOID
AllocMem(
    IN UINT cbSize
    )
/*++

Routine Description:
    Allocate memory from the heap

Arguments:
    cbSize  : Byte count

Return Value:
    Pointer to the allocated memory

--*/
{
    return LocalAlloc(LPTR, cbSize);
}


VOID
FreeMem(
    IN PVOID    p
    )
/*++

Routine Description:
    Free memory allocated on the heap

Arguments:
    p   : Pointer to the memory to be freed

Return Value:
    None

--*/
{
    LocalFree(p);
}


LPSTR
AllocStrA(
    LPCSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of an ansi string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = AllocMem((strlen(pszStr) + 1) * sizeof(CHAR));
        if ( pszRet )
            strcpy(pszRet, pszStr);
    }

    return pszRet;
}


LPWSTR
AllocStrW(
    LPCWSTR  pszStr
    )
/*++

Routine Description:
    Allocate memory and make a copy of a unicode string field

Arguments:
    pszStr   : String to copy

Return Value:
    Pointer to the copied string. Memory is allocated.

--*/
{
    LPWSTR  pszRet = NULL;

    if ( pszStr && *pszStr ) {

        pszRet = AllocMem((wcslen(pszStr) + 1) * sizeof(WCHAR));
        if ( pszRet )
            wcscpy(pszRet, pszStr);
    }

    return pszRet;
}


LPWSTR
AllocStrWFromStrA(
    LPCSTR  pszStr
    )
/*++

Routine Description:
    Returns the unicode string for a give ansi string. Memory is allocated.

Arguments:
    pszStr   : Gives the ansi string to copy

Return Value:
    Pointer to the copied unicode string. Memory is allocated.

--*/
{
    DWORD   dwLen;
    LPWSTR  pszRet = NULL;

    if ( pszStr                     &&
         *pszStr                    &&
         (dwLen = strlen(pszStr))   &&
         (pszRet = AllocMem((dwLen + 1) * sizeof(WCHAR))) ) {

        if ( MultiByteToWideChar(CP_ACP,
                                 MB_PRECOMPOSED,
                                 pszStr,
                                 dwLen,
                                 pszRet,
                                 dwLen) ) {

            pszRet[dwLen] = 0;
        } else {

            FreeMem(pszRet);
            pszRet = NULL;
        }

    }

    return pszRet;
}


LPSTR
AllocStrAFromStrW(
    LPCWSTR     pszStr
    )
/*++

Routine Description:
    Returns the ansi string for a give unicode string. Memory is allocated.

Arguments:
    pszStr   : Gives the ansi string to copy

Return Value:
    Pointer to the copied ansi string. Memory is allocated.

--*/
{
    DWORD   dwLen;
    LPSTR   pszRet = NULL;

    if ( pszStr                     &&
         *pszStr                    &&
         (dwLen = wcslen(pszStr))   &&
         (pszRet = AllocMem((dwLen + 1 ) * sizeof(CHAR))) ) {

        WideCharToMultiByte(CP_ACP,
                            0,
                            pszStr,
                            dwLen,
                            pszRet,
                            dwLen,
                            NULL,
                            NULL );
    }

    return pszRet;
}


BOOL
WriteToFile(
    HANDLE  hFile,
    LPCSTR  pszFormat,
    ...
    )
/*++

Routine Description:
    Format and write a string to the text file. This is used to write the
    printing configuration on Win9x

Arguments:
    hFile       : File handle
    pszFormat   : Format string for the message

Return Value:
    None

--*/
{
    CHAR        szMsg[1024];
    va_list     vargs;
    DWORD       dwSize, dwWritten;
    BOOL        bRet;

    bRet = TRUE;

    va_start(vargs, pszFormat);
    vsprintf(szMsg, pszFormat, vargs);  
    va_end(vargs);

    dwSize = strlen(szMsg) * sizeof(CHAR);

    if ( !WriteFile(hFile, (LPCVOID)szMsg, dwSize, &dwWritten, NULL)    ||
         dwSize != dwWritten ) {

        bRet = FALSE;
    }
    
    return bRet;
}


VOID
WriteString(
    IN      HANDLE  hFile,
    IN OUT  LPBOOL  pbFail,
    IN      LPCSTR  pszStr
    )
/*++

Routine Description:
    Writes a string to the upgrade file on Win9x side. Since spooler strings
    (ex. printer name, driver name) can have space in them we would write
    all strings with []\n. So we can read strings with space on NT.

Arguments:
    hFile       : File handle
    pszFormat   : Format string for the message
    pszStr      : String to write

Return Value:
    None

--*/
{
    DWORD   dwLen;

    if ( pszStr ) {

        dwLen = strlen(pszStr);
        WriteToFile(hFile, "%3d [%s]\n", dwLen, pszStr);
    }

}

LPSTR
GetStringFromRcFileA(
    UINT    uId
    )
/*++

Routine Description:
    Load a string from the .rc file and make a copy of it by doing AllocStr

Arguments:
    uId     : Identifier for the string to be loaded

Return Value:
    String value loaded, NULL on error. Caller should free the memory

--*/
{
    CHAR    buf[MAX_PATH];

    if ( LoadStringA(g_hInst, uId, buf, sizeof(buf) ))
        return AllocStrA(buf);
    else
        return NULL;
}



VOID
ReadString(
    IN      HANDLE  hFile,
    OUT     LPSTR  *ppszParam1,
    OUT     LPSTR  *ppszParam2
    )
{
    CHAR    c;
    LPSTR   pszParameter1;
    LPSTR   pszParameter2;
    DWORD   dwLen;
    CHAR    LineBuffer[MAX_PATH];
    DWORD   Idx;

    //
    // Initialize local.
    //

    c               = 0;
    pszParameter1   = NULL;
    pszParameter2   = NULL;
    dwLen           = 0;
    Idx             = 0;
    
    memset(LineBuffer, 0, sizeof(LineBuffer));

    //
    // Initialize caller buffer
    //

    *ppszParam1 = NULL;
    *ppszParam2 = NULL;

    //
    // First skip space/\r/\n.
    //

    c = (CHAR) My_fgetc(hFile);
    while( (' ' == c)
        || ('\n' == c)
        || ('\r' == c) )
    {
        c = (CHAR) My_fgetc(hFile);
    }

    //
    // See if it's EOF.
    //

    if(EOF == c){
        
        //
        // End of file.
        //

        goto ReadString_return;
    }

    //
    // Get a line.
    //

    Idx = 0;
    while( ('\n' != c) && (EOF != c) ){
        LineBuffer[Idx++] = c;
        c = (CHAR) My_fgetc(hFile);
    } // while( ('\n' != c) && (EOF != c) )
    dwLen = Idx;

    //
    // See if it's EOF.
    //

    if(EOF == c){
        
        //
        // Illegal migration file.
        //
        
        SetupLogError("WIA Migration: ReadString: ERROR!! Illegal migration file.", LogSevError);
        goto ReadString_return;
    }

    //
    // See if it's double quated.
    //

    if('\"' == LineBuffer[0]){
        pszParameter1 = &LineBuffer[1];
        Idx = 1;
    } else { // if('\"' == LineBuffer[0])

        //
        // There's no '"'. Invalid migration file.
        //
        SetupLogError("WIA Migration: ReadString: ERROR!! Illegal migration file with no Quote.", LogSevError);
        goto ReadString_return;
    } // if('\"' == LineBuffer[0])

    //
    // Find next '"' and replace with '\0'.
    //

    for(;'\"' != LineBuffer[Idx]; Idx++);
    LineBuffer[Idx] = '\0';

    //
    // Find next (3rd) '"', it's beginning of 2nd parameter.
    //

    for(;'\"' != LineBuffer[Idx]; Idx++);
    pszParameter2 = &LineBuffer[++Idx];

    //
    // Find last '"' and replace with '\0'.
    //

    for(;'\"' != LineBuffer[Idx]; Idx++);
    LineBuffer[Idx] = '\0';

    //
    // Allocate buffer for returning string.
    //

    *ppszParam1 = AllocStrA(pszParameter1);
    *ppszParam2 = AllocStrA(pszParameter2);

ReadString_return:
    return;
} // ReadString()


VOID
ReadDword(
    IN      HANDLE  hFile,
    IN      LPSTR   pszLine,
    IN      DWORD   dwLineSize,
    IN      LPSTR   pszPrefix,
    OUT     LPDWORD pdwValue,
    IN  OUT LPBOOL  pbFail
    )
{
    LPSTR   psz;

    if ( *pbFail || My_fgets(pszLine, dwLineSize, hFile) == NULL ) {

        *pbFail = TRUE;
        return;
    }

    //
    // First check the prefix matches to make sure we are in the right line
    //
    for ( psz = (LPSTR)pszLine ;
          *pszPrefix && *psz == *pszPrefix ;
          ++psz, ++pszPrefix )
    ;

    if ( *pszPrefix ) {

        *pbFail = TRUE;
        return;
    }

    //
    // Skip spaces
    //
    while ( *psz && *psz == ' ' )
        ++psz;

    *pdwValue = atoi(psz);
}


VOID
ReadDevMode(
    IN      HANDLE  hFile,
    OUT     LPDEVMODEA *ppDevMode,
    IN  OUT LPBOOL      pbFail
    )
{
    LPSTR   pszPrefix = "DevMode:";
    CHAR    c;
    DWORD   dwLen;
    LPINT   ptr;

    if ( *pbFail )
        return;

    // First skip the prefix
    //
    while ( *pszPrefix && (c = (CHAR) My_fgetc(hFile)) == *pszPrefix++ )
    ;

    if ( *pszPrefix )
        goto Fail;

    //
    // Skip spaces
    //
    while ( (c = (CHAR) My_fgetc(hFile)) == ' ' )
    ;

    //
    // Now is the devmode size
    //
    if ( !isdigit(c) )
        goto Fail;

    dwLen = c - '0';
    while ( isdigit(c = (CHAR) My_fgetc(hFile)) )
        dwLen = dwLen * 10 + c - '0';

    if ( dwLen == 0 )
        return;

    if ( c != ' ' )
        goto Fail;

    //
    // Now the devmode is there between []
    //
    if ( *ppDevMode = (LPDEVMODEA) AllocMem(dwLen) ) {

        if ( (c = (CHAR) My_fgetc(hFile)) != '[' )
            goto Fail;

        if ( dwLen != My_fread((LPVOID)*ppDevMode, dwLen, hFile) )
            goto Fail;

        //
        // Make sure now we have "]\n" to End
        //
        if ( (CHAR) My_fgetc(hFile) != ']' || (CHAR) My_fgetc(hFile) != '\n' ) {

            DebugMsg("Char check fails");
            goto Fail;
        }

        return; // Succesful exit
    }

Fail:
    *pbFail = TRUE;
}



LONG
WriteRegistryToFile(
    IN  HANDLE  hFile,
    IN  HKEY    hKey,
    IN  LPCSTR  pszPath
    )
{
    LONG    lError;
    HKEY    hSubKey;
    DWORD   dwValueSize;
    DWORD   dwDataSize;
    DWORD   dwSubKeySize;
    DWORD   dwTypeBuffer;

    PCHAR   pSubKeyBuffer;
    PCHAR   pValueBuffer;
    PCHAR   pDataBuffer;

    DWORD   Idx;
    
    //
    // Initialize local.
    //
    
    lError          = ERROR_SUCCESS;
    hSubKey         = (HKEY)INVALID_HANDLE_VALUE;
    dwValueSize     = 0;
    dwDataSize      = 0;
    dwSubKeySize    = 0;
    dwTypeBuffer    = 0;
    Idx             = 0;
    
    pSubKeyBuffer   = NULL;
    pValueBuffer    = NULL;
    pDataBuffer     = NULL;

    //
    // Query necessary buffer size.
    //

    lError = RegQueryInfoKeyA(hKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &dwSubKeySize,
                              NULL,
                              NULL,
                              &dwValueSize,
                              &dwDataSize,
                              NULL,
                              NULL);
    if(ERROR_SUCCESS != lError){

        //
        // Unable to retrieve key info.
        //

        goto WriteRegistryToFile_return;

    } // if(ERROR_SUCCESS != lError)

    //
    // Allocate buffers.
    //

    dwValueSize     = (dwValueSize+1+1) * sizeof(CHAR);
    dwSubKeySize    = (dwSubKeySize+1) * sizeof(CHAR);

    pValueBuffer    = AllocMem(dwValueSize);
    pDataBuffer     = AllocMem(dwDataSize);
    pSubKeyBuffer   = AllocMem(dwSubKeySize);

    if( (NULL == pValueBuffer)
     || (NULL == pDataBuffer)
     || (NULL == pSubKeyBuffer) )
    {

        //
        // Insufficient memory.
        //

        SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to allocate buffer.", LogSevError);
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto WriteRegistryToFile_return;
    } // if(NULL == pDataBuffer)

    //
    // Indicate beginning of this subkey to the file.
    //

    WriteToFile(hFile, "\"%s\" = \"BEGIN\"\r\n", pszPath);

    //
    // Enumerate all values.
    //

    while(ERROR_SUCCESS == lError){

        DWORD   dwLocalValueSize;
        DWORD   dwLocalDataSize;
        
        //
        // Reset buffer and size.
        //
        
        dwLocalValueSize    = dwValueSize;
        dwLocalDataSize     = dwDataSize;
        memset(pValueBuffer, 0, dwValueSize);
        memset(pDataBuffer, 0, dwDataSize);

        //
        // Acquire registry value/data..
        //

        lError = RegEnumValueA(hKey,
                               Idx,
                               pValueBuffer,
                               &dwLocalValueSize,
                               NULL,
                               &dwTypeBuffer,
                               pDataBuffer,
                               &dwLocalDataSize);
        if(ERROR_NO_MORE_ITEMS == lError){
            
            //
            // End of data.
            //
            
            continue;
        } // if(ERROR_NO_MORE_ITEMS == lError)

        if(ERROR_SUCCESS != lError){
            
            //
            // Unable to read registry value.
            //
            
            SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to acqure registry value/data.", LogSevError);
            goto WriteRegistryToFile_return;
        } // if(ERROR_NO_MORE_ITEMS == lError)

        //
        // Write this value to a file.
        //

        lError = WriteRegistryValueToFile(hFile,
                                          pValueBuffer,
                                          dwTypeBuffer,
                                          pDataBuffer,
                                          dwLocalDataSize);
        if(ERROR_SUCCESS != lError){
            
            //
            // Unable to write to a file.
            //

            SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to write to a file.", LogSevError);
            goto WriteRegistryToFile_return;
        } // if(ERROR_SUCCESS != lError)

        //
        // Goto next value.
        //
        
        Idx++;
                            
    } // while(ERROR_SUCCESS == lError)

    //
    // Enumerate all sub keys.
    //

    lError          = ERROR_SUCCESS;
    Idx             = 0;

    while(ERROR_SUCCESS == lError){

        memset(pSubKeyBuffer, 0, dwSubKeySize);
        lError = RegEnumKeyA(hKey, Idx++, pSubKeyBuffer, dwSubKeySize);
        if(ERROR_SUCCESS == lError){

            //
            // There's sub key exists. Spew it to the file and store all the
            // values recursively.
            //

            lError = RegOpenKey(hKey, pSubKeyBuffer, &hSubKey);
            if(ERROR_SUCCESS != lError){
                SetupLogError("WIA Migration: WriteRegistryToFile: ERROR!! Unable to open subkey.", LogSevError);
                continue;
            } // if(ERROR_SUCCESS != lError)

            //
            // Call subkey recursively.
            //
            
            lError = WriteRegistryToFile(hFile, hSubKey, pSubKeyBuffer);

        } // if(ERROR_SUCCESS == lError)
    } // while(ERROR_SUCCESS == lError)

    if(ERROR_NO_MORE_ITEMS == lError){
        
        //
        // Operation completed as expected.
        //
        
        lError = ERROR_SUCCESS;

    } // if(ERROR_NO_MORE_ITEMS == lError)

    //
    // Indicate end of this subkey to the file.
    //

    WriteToFile(hFile, "\"%s\" = \"END\"\r\n", pszPath);

WriteRegistryToFile_return:

    //
    // Clean up.
    //

    if(NULL != pValueBuffer){
        FreeMem(pValueBuffer);
    } // if(NULL != pValueBuffer)

    if(NULL != pDataBuffer){
        FreeMem(pDataBuffer);
    } // if(NULL != pDataBuffer)

    if(NULL != pSubKeyBuffer){
        FreeMem(pSubKeyBuffer);
    } // if(NULL != pSubKeyBuffer)

    return lError;
} // WriteRegistryToFile()


LONG
WriteRegistryValueToFile(
    HANDLE  hFile,
    LPSTR   pszValue,
    DWORD   dwType,
    PCHAR   pDataBuffer,
    DWORD   dwSize
    )
{

    LONG    lError;
    PCHAR   pSpewBuffer;
    DWORD   Idx;

    //
    // Initialize locals.
    //

    lError      = ERROR_SUCCESS;
    pSpewBuffer = NULL;

    //
    // Allocate buffer for actual spew.
    //
    
    pSpewBuffer = AllocMem(dwSize*3);
    if(NULL == pSpewBuffer){
        
        //
        // Unable to allocate buffer.
        //
        
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto WriteRegistryValueToFile_return;
    } // if(NULL == pSpewBuffer)
    
    for(Idx = 0; Idx < dwSize; Idx++){
        
        wsprintf(pSpewBuffer+Idx*3, "%02x", pDataBuffer[Idx]);
        *(pSpewBuffer+Idx*3+2) = ',';
        
    } // for(Idx = 0; Idx < dwSize; Idx++)
    
    *(pSpewBuffer+dwSize*3-1) = '\0';
    
    WriteToFile(hFile, "\"%s\" = \"%08x:%s\"\r\n", pszValue, dwType, pSpewBuffer);
    
    //
    // Operation succeeded.
    //
    
    lError = ERROR_SUCCESS;

WriteRegistryValueToFile_return:

    //
    // Clean up.
    //
    
    if(NULL != pSpewBuffer){
        FreeMem(pSpewBuffer);
    } // if(NULL != pSpewBuffer)
    
    return lError;

} // WriteRegistryValueToFile()


LONG
GetRegData(
    HKEY    hKey,
    LPSTR   pszValue,
    PCHAR   *ppDataBuffer,
    PDWORD  pdwType,
    PDWORD  pdwSize
    )
{

    LONG    lError;
    PCHAR   pTempBuffer;
    DWORD   dwRequiredSize;
    DWORD   dwType;
    
    //
    // Initialize local.
    //
    
    lError          = ERROR_SUCCESS;
    pTempBuffer     = NULL;
    dwRequiredSize  = 0;
    dwType          = 0;
    
    //
    // Get required size.
    //
    
    lError = RegQueryValueEx(hKey,
                             pszValue,
                             NULL,
                             &dwType,
                             NULL,
                             &dwRequiredSize);
    if( (ERROR_SUCCESS != lError)
     || (0 == dwRequiredSize) )
    {
        
        pTempBuffer = NULL;
        goto GetRegData_return;

    } // if(ERROR_MORE_DATA != lError)

    //
    // If it doesn't need actual data, just bail out.
    //

    if(NULL == ppDataBuffer){
        lError = ERROR_SUCCESS;
        goto GetRegData_return;
    } // if(NULL == ppDataBuffer)

    //
    // Allocate buffer to receive data.
    //

    pTempBuffer = AllocMem(dwRequiredSize);
    if(NULL == pTempBuffer){
        
        //
        // Allocation failed.
        //
        
        SetupLogError("WIA Migration: GetRegData: ERROR!! Unable to allocate buffer.", LogSevError);
        lError = ERROR_NOT_ENOUGH_MEMORY;
        goto GetRegData_return;
    } // if(NULL == pTempBuffer)

    //
    // Query the data.
    //

    lError = RegQueryValueEx(hKey,
                             pszValue,
                             NULL,
                             &dwType,
                             pTempBuffer,
                             &dwRequiredSize);
    if(ERROR_SUCCESS != lError){
        
        //
        // Data acquisition somehow failed. Free buffer.
        //
        
        goto GetRegData_return;
    } // if(ERROR_SUCCESS != lError)

GetRegData_return:

    if(ERROR_SUCCESS != lError){
        
        //
        // Operation unsuccessful. Free the buffer if allocated.
        //
        
        if(NULL != pTempBuffer){
            FreeMem(pTempBuffer);
            pTempBuffer = NULL;
        } // if(NULL != pTempBuffer)
    } // if(ERROR_SUCCESS != lError)

    //
    // Copy the result.
    //

    if(NULL != pdwSize){
        *pdwSize = dwRequiredSize;
    } // if(NULL != pdwSize)

    if(NULL != ppDataBuffer){
        *ppDataBuffer = pTempBuffer;
    } // if(NULL != ppDataBuffer)

    if(NULL != pdwType){
        *pdwType = dwType;
    } // if(NULL != pdwType)

    return lError;
} // GetRegData()

VOID
MyLogError(
    LPCSTR  pszFormat,
    ...
    )
{
    LPSTR       psz;
    CHAR        szMsg[1024];
    va_list     vargs;

    if(NULL != pszFormat){
        va_start(vargs, pszFormat);
        vsprintf(szMsg, pszFormat, vargs);
        va_end(vargs);

        SetupLogError(szMsg, LogSevError);
    } // if(NULL != pszFormat)

} // MyLogError()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\bmpinfo.cpp ===
// BMPInfo.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "BMPInfo.h"
#include "BMPInfoDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBMPInfoApp

BEGIN_MESSAGE_MAP(CBMPInfoApp, CWinApp)
    //{{AFX_MSG_MAP(CBMPInfoApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBMPInfoApp construction

CBMPInfoApp::CBMPInfoApp()
{
}

CBMPInfoApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CBMPInfoApp initialization

BOOL CBMPInfoApp::InitInstance()
{
    AfxEnableControlContainer();

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CBMPInfoDlg dlg;
    m_pMainWnd = &dlg;
    int nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
    }
    else if (nResponse == IDCANCEL)
    {
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\bmpinfo.h ===
// BMPInfo.h : main header file for the BMPINFO application
//

#ifndef _BMPINFO_H
#define _BMPINFO_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CBMPInfoApp:
// See BMPInfo.cpp for the implementation of this class
//

class CBMPInfoApp : public CWinApp
{
public:
    CBMPInfoApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBMPInfoApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CBMPInfoApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\bmpinfodlg.cpp ===
// BMPInfoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "BMPInfo.h"
#include "BMPInfoDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBMPInfoDlg dialog

CBMPInfoDlg::CBMPInfoDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CBMPInfoDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CBMPInfoDlg)
    m_FileType            = 0;
    m_FileSize            = 0;
    m_Reserved1           = 0;
    m_Reserved2           = 0;
    m_OffBits             = 0;
    m_BitmapHeaderSize    = 0;
    m_BitmapWidth         = 0;
    m_BitmapHeight        = 0;
    m_BitmapPlanes        = 0;
    m_BitmapBitCount      = 0;
    m_BitmapCompression   = 0;
    m_BitmapImageSize     = 0;
    m_BitmapXPelsPerMeter = 0;
    m_BitmapYPelsPerMeter = 0;
    m_BitmapClrUsed       = 0;
    m_BitmapClrImportant  = 0;
    m_bManipulateImage    = FALSE;
    //}}AFX_DATA_INIT
    
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CBMPInfoDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBMPInfoDlg)
    DDX_Text(pDX, IDC_FILE_TYPE, m_FileType);
    DDX_Text(pDX, IDC_FILE_SIZE, m_FileSize);
    DDX_Text(pDX, IDC_FILE_RESERVED1, m_Reserved1);
    DDX_Text(pDX, IDC_FILE_RESERVED2, m_Reserved2);
    DDX_Text(pDX, IDC_FILE_OFFBITS, m_OffBits);
    DDX_Text(pDX, IDC_BITMAP_HEADERSIZE, m_BitmapHeaderSize);
    DDX_Text(pDX, IDC_BITMAP_WIDTH, m_BitmapWidth);
    DDX_Text(pDX, IDC_BITMAP_HEIGHT, m_BitmapHeight);
    DDX_Text(pDX, IDC_BITMAP_PLANES, m_BitmapPlanes);
    DDX_Text(pDX, IDC_BITMAP_BITCOUNT, m_BitmapBitCount);
    DDX_Text(pDX, IDC_BITMAP_COMPRESSION, m_BitmapCompression);
    DDX_Text(pDX, IDC_BITMAP_IMAGESIZE, m_BitmapImageSize);
    DDX_Text(pDX, IDC_BITMAP_XPELSPERMETER, m_BitmapXPelsPerMeter);
    DDX_Text(pDX, IDC_BITMAP_YPELSPERMETER, m_BitmapYPelsPerMeter);
    DDX_Text(pDX, IDC_BITMAP_CLRUSED, m_BitmapClrUsed);
    DDX_Text(pDX, IDC_BITMAP_CLRIMPORTANT, m_BitmapClrImportant);
    DDX_Check(pDX, IDC_IMAGE_MANIPULATION_CHECKBOX, m_bManipulateImage);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CBMPInfoDlg, CDialog)
    //{{AFX_MSG_MAP(CBMPInfoDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_IMAGE_MANIPULATION_CHECKBOX, OnImageManipulationCheckbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBMPInfoDlg message handlers

BOOL CBMPInfoDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon
    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CBMPInfoDlg::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

HCURSOR CBMPInfoDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

LRESULT CBMPInfoDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
    if (message == WM_DROPFILES) {
        //
        // process the dropped file request
        //

        UINT result = 0;        // error result
        UINT cch = 0;           // size of the characters in buffer
        LPTSTR lpszFile = NULL; // buffer
        UINT iFile = 0;

        //
        // call once to get information on the DROP
        //

        result = DragQueryFile((HDROP) wParam,iFile, NULL, cch);

        //
        // alloc the needed mem for the operation
        //

        if (result > 0) {
            lpszFile = (LPTSTR)GlobalAlloc(GPTR,result + 1);

            if (lpszFile) {

                //
                // call again to fill the file information
                //

                cch = (result + 1); // assign the character count here
                result = DragQueryFile((HDROP) wParam,iFile,lpszFile,cch);
                m_BitmapFileName = lpszFile;
                GlobalUnlock(lpszFile);
                GlobalFree(lpszFile);
                UpdateFileInformation();
            }
        } else {
            AfxMessageBox("Could not allocate enough Memory for Bitmap File Name");
        }           
    }
    return CDialog::WindowProc(message, wParam, lParam);
}

void CBMPInfoDlg::UpdateFileInformation()
{
    BITMAPFILEHEADER bmfh;
    ZeroMemory(&bmfh, sizeof(BITMAPFILEHEADER));
    BITMAPINFOHEADER bmih;
    ZeroMemory(&bmih, sizeof(BITMAPINFOHEADER));

    CFile ImageFile;
    CFileException Exception;

    //
    // attempt to open the image file
    //

    if (!ImageFile.Open(m_BitmapFileName,CFile::modeRead,&Exception))
        AfxThrowFileException(Exception.m_cause);
    else {

        //
        // read the image file header and check if it's valid.
        //

        if (ImageFile.Read((LPSTR)&bmfh, sizeof(BITMAPFILEHEADER)) != sizeof(BITMAPFILEHEADER))
            AfxMessageBox("Error reading BITMAPFILEHEADER");
        else {

            //
            // read the image info header and check if it's valid.
            //

            if (ImageFile.Read((LPSTR)&bmih, sizeof(BITMAPINFOHEADER)) != sizeof(BITMAPINFOHEADER))
                AfxMessageBox("Error reading BITMAPINFOHEADER");
            else {

                //
                // update file header members here
                //

                if (bmfh.bfType != BMP_HEADER_MARKER)
                    AfxMessageBox("invalid BMP file format detected");
                else {
                    m_FileType            = bmfh.bfType; 
                    m_FileSize            = bmfh.bfSize; 
                    m_Reserved1           = bmfh.bfReserved1; 
                    m_Reserved2           = bmfh.bfReserved2; 
                    m_OffBits             = bmfh.bfOffBits;

                    //
                    // update image info header members here
                    //

                    m_BitmapHeaderSize    = bmih.biSize; 
                    m_BitmapWidth         = bmih.biWidth; 
                    m_BitmapHeight        = bmih.biHeight; 
                    m_BitmapPlanes        = bmih.biPlanes; 
                    m_BitmapBitCount      = bmih.biBitCount; 
                    m_BitmapCompression   = bmih.biCompression; 
                    m_BitmapImageSize     = bmih.biSizeImage; 
                    m_BitmapXPelsPerMeter = bmih.biXPelsPerMeter; 
                    m_BitmapYPelsPerMeter = bmih.biYPelsPerMeter; 
                    m_BitmapClrUsed       = bmih.biClrUsed; 
                    m_BitmapClrImportant  = bmih.biClrImportant; 

                    //
                    // display the current filename in the window header
                    //

                    SetWindowText(RipFileName());
                }
                if (m_bManipulateImage) {
                    ManipulateImage(&ImageFile);
                }
                UpdateData(FALSE);              
            }
        }

        //
        // close the image file
        //

        ImageFile.Close();
    }
}

CString CBMPInfoDlg::RipFileName()
{
    int index = 0;
    CString RippedFile = "";
    index = m_BitmapFileName.ReverseFind('\\');
    index ++;
    while (index <= (m_BitmapFileName.GetLength()-1)) {
        RippedFile = RippedFile + m_BitmapFileName[index];
        index++;
    }
    return (RippedFile);
}

void CBMPInfoDlg::OnImageManipulationCheckbox() 
{
    if(m_bManipulateImage)
        m_bManipulateImage = FALSE;
    else 
        m_bManipulateImage = TRUE;  
}

void CBMPInfoDlg::ManipulateImage(CFile *pImageFile)
{
    AfxMessageBox("There are no image manipulation routines written yet... sorry. :) ");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\bmpinfodlg.h ===
// BMPInfoDlg.h : header file
//

#if !defined(AFX_BMPINFODLG_H__5387ABF9_990C_11D2_B482_009027226441__INCLUDED_)
#define AFX_BMPINFODLG_H__5387ABF9_990C_11D2_B482_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CBMPInfoDlg dialog

#define BMP_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

class CBMPInfoDlg : public CDialog
{
// Construction
public:
    CBMPInfoDlg(CWnd* pParent = NULL);  // standard constructor

// Dialog Data
    //{{AFX_DATA(CBMPInfoDlg)
    enum { IDD = IDD_BMPINFO_DIALOG };
    DWORD    m_FileType;
    DWORD   m_FileSize;
    DWORD    m_Reserved1;
    DWORD    m_Reserved2;
    DWORD   m_OffBits;
    DWORD   m_BitmapHeaderSize;
    LONG    m_BitmapWidth;
    LONG    m_BitmapHeight;
    DWORD    m_BitmapPlanes;
    DWORD    m_BitmapBitCount;
    DWORD   m_BitmapCompression;
    DWORD   m_BitmapImageSize;
    LONG    m_BitmapXPelsPerMeter;
    LONG    m_BitmapYPelsPerMeter;
    DWORD   m_BitmapClrUsed;
    DWORD   m_BitmapClrImportant;
    BOOL    m_bManipulateImage;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBMPInfoDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CBMPInfoDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnImageManipulationCheckbox();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    CString RipFileName();
    void UpdateFileInformation();
    void ManipulateImage(CFile *pImageFile);
    CString m_BitmapFileName;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BMPINFODLG_H__5387ABF9_990C_11D2_B482_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\setup\win9xupg\test\win9x.c ===
/*++

Copyright (c) 1994 - 1995 Microsoft Corporation

Module Name:

    Win9x.c

Abstract:

    Test pre-migration of Win95 to NT

Author:
    MuhuntS


Revision History:
    01-17-97


--*/

#define NOMINMAX
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <setupapi.h>
#include <plugin.h>

P_QUERY_VERSION         QueryVersion;
P_INITIALIZE_9X         Initialize9x;
P_MIGRATE_SYSTEM_9X     MigrateSystem9x;

P_INITIALIZE_NT         InitializeNT;
P_MIGRATE_SYSTEM_NT     MigrateSystemNT;

WCHAR   szSrcDir[MAX_PATH], szWrkDir[MAX_PATH];

int __cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    PVENDORINFO     pVI;
    HMODULE         hModule;
    HANDLE          hAlive = NULL;
    DWORD           dwLastError;
    LPSTR           p1, p2, p3, p4, p5;
    LONG            x;
    UINT            v;
    INT             c;

    p1 = p2 = p3 = p4 = p5 = NULL;

    if ( argc < 3 ) {

        printf("Usage: %s <working-dir> <source-dir>\n", argv[0]);
        return 0;
    }

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        printf("%s: LoadLibrary failed with %d\n", argv[0], GetLastError());
        goto Cleanup;
    }

    //
    // Nt only?
    //
    if ( argc == 4 && argv[3][0] == '+' )
        goto DoNT;

    (FARPROC) QueryVersion      = GetProcAddress(hModule, "QueryVersion");
    (FARPROC) Initialize9x      = GetProcAddress(hModule, "Initialize9x");
    (FARPROC) MigrateSystem9x   = GetProcAddress(hModule, "MigrateSystem9x");

    if ( !QueryVersion || !Initialize9x || !MigrateSystem9x )
        goto Cleanup;

    x = QueryVersion(&p1, (LPUINT)&p2, (LPINT*)&p3, &p4, (PVENDORINFO*)&pVI);

    printf("QueryVersion returned %d\n", x);

    x = Initialize9x(argv[1], argv[2], 0);

    printf("Initialize9x returned %d\n", x);

    x = MigrateSystem9x(0, NULL, 0);

    printf("MigrateSystem9x returned %d\n", x);

    FreeLibrary(hModule);

    //
    // Win95 only?
    //
    if ( argc == 4 && argv[3][0] == '-' )
        goto Cleanup;

    hModule = LoadLibraryA("migrate.dll");
    if ( !hModule ) {

        printf("%s: LoadLibrary II failed with %d\n", argv[0], GetLastError());
        goto Cleanup;
    }

DoNT:
    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[1],
                        -1,
                        szWrkDir,
                        MAX_PATH);

    MultiByteToWideChar(CP_ACP,
                        MB_PRECOMPOSED,
                        argv[2],
                        -1,
                        szSrcDir,
                        MAX_PATH);

    InitializeNT     = (P_INITIALIZE_NT)GetProcAddress(hModule, "InitializeNT");
    MigrateSystemNT  = (P_MIGRATE_SYSTEM_NT)GetProcAddress(hModule, "MigrateSystemNT");

    if ( !InitializeNT || !MigrateSystemNT )
        goto Cleanup;

    hAlive = CreateEventA(NULL, FALSE, FALSE, "MigDllAlive");

    if ( ERROR_SUCCESS == InitializeNT(szWrkDir, szSrcDir, 0) )
        MigrateSystemNT(INVALID_HANDLE_VALUE, 0);

    FreeLibrary(hModule);
Cleanup:
    if ( hModule )
        FreeLibrary(hModule);

    if ( hAlive )
        CloseHandle(hAlive);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	BMPInfo.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=bmpinfo
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\bmpinfo.cpp          \
        ..\bmpinfodlg.cpp       \
        ..\bmpinfo.rc


# Add interlac.cpp if the PNG support is ever fixed

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\shell32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__5387ABFB_990C_11D2_B482_009027226441__INCLUDED_)
#define AFX_STDAFX_H__5387ABFB_990C_11D2_B482_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5387ABFB_990C_11D2_B482_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\bmpinfo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BMPInfo.rc
//
#define IDD_BMPINFO_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDC_FILE_TYPE                   1000
#define IDC_FILE_SIZE                   1001
#define IDC_FILE_RESERVED1              1002
#define IDC_FILE_RESERVED2              1003
#define IDC_FILE_OFFBITS                1004
#define IDC_BITMAP_HEADERSIZE           1005
#define IDC_BITMAP_WIDTH                1006
#define IDC_BITMAP_HEIGHT               1007
#define IDC_BITMAP_PLANES               1008
#define IDC_BITMAP_BITCOUNT             1009
#define IDC_BITMAP_COMPRESSION          1010
#define IDC_BITMAP_IMAGESIZE            1011
#define IDC_BITMAP_XPELSPERMETER        1012
#define IDC_BITMAP_YPELSPERMETER        1013
#define IDC_BITMAP_CLRUSED              1014
#define IDC_BITMAP_CLRIMPORTANT         1015
#define IDC_FAKE_EDIT                   1016
#define IDC_PREVIEW                     1017
#define IDC_IMAGE_MANIPULATION_CHECKBOX 1018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\csti\csti.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       csti.cpp
//
//--------------------------------------------------------------------------

/*****************************************************************************

    csti.cpp

    History:

        vlads   02/01/97

*****************************************************************************/

// ##define _X86_   1
#define WIN32_LEAN_AND_MEAN 1

#define INITGUID

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

#include <sti.h>
#include <stireg.h>
//#include <scanner.h>


// {AD879F40-0982-11d1-A43B-080009EEBDF6}
DEFINE_GUID( guidGreenButton, 0xad879f40, 0x982, 0x11d1, 0xa4, 0x3b, 0x8, 0x0, 0x9, 0xee, 0xbd, 0xf6 );

#define USE_GETSTATUS

/*****************************************************************************

    globals

*****************************************************************************/

PSTIA   g_pSti = NULL;
PSTIW   g_pStiW = NULL;

PSTIDEVICE  g_pStiDevice = NULL;
PSTIDEVICE  g_pStiDevice1 = NULL;


CHAR    SCLReset[]= "E";
CHAR    SetXRes[] = "*a150R";
CHAR    InqXRes[] = "*s10323R";
CHAR    ScanCmd[] = "*f0S";
CHAR    LampOn[]  = "*f1L";
CHAR    LampOff[] = "*f0L";
CHAR    PollButton[] = "*s1044E";

TCHAR   szSelectedDevice[STI_MAX_INTERNAL_NAME_LENGTH] = {L'\0'};

BOOL    g_fWait     = FALSE;
BOOL    g_fTestSCL  = FALSE;
BOOL    g_fTestEDNotifications = FALSE;
BOOL    g_fTestLaunchAPI = FALSE;
BOOL    g_fTestSetGetValue = FALSE;
BOOL    g_fTestRefreshAPI = TRUE;

/*****************************************************************************

    prototypes

*****************************************************************************/
INT __cdecl main( INT    cArgs,
                   char * pArgs[] );

HRESULT WINAPI
SendDeviceCommandString(
    PSTIDEVICE  pStiDevice,
    LPSTR       pszFormat,
    ...);

HRESULT WINAPI
TransactDevice(
    PSTIDEVICE  pStiDevice,
    LPSTR       lpResultBuffer,
    UINT        cbResultBufferSize,
    LPSTR pszFormat,
    ...);

VOID
TestEnumerationAndSelect(
    BOOL    fMakeSelection
    );

VOID
TestQueryCustomInterface(
    LPTSTR  pszDeviceName
    );

VOID
TestGetSetValue(
    LPTSTR  pszDeviceName
    );

BOOL
TestStiLaunch(
    BOOL    fRegister
    );

VOID
TestSCL(
    VOID
    );

VOID
TestWaitForNotifications(
    VOID
    );

VOID
TestEnableDisableNotifications(
    LPTSTR  pszDeviceName
    );

VOID
TestLaunchAPI(
    LPTSTR  pszDeviceName
    );

VOID
TestRefreshAPI(
    LPTSTR  pszDeviceName
    );


BOOL WINAPI
FormatStringV(
    IN LPTSTR   lpszStr,
    //LPSTR     lpszFirst,
    ...
    );

VOID
ProcessCommandLine(
    INT    cArgs,
    char * pArgs[]
    );


/*****************************************************************************

    main

*****************************************************************************/
INT __cdecl main( INT    cArgs,
                   char * pArgs[] )
{

    HRESULT hres;

    LPTSTR  pszDeviceName = NULL;
    BOOL    fAutoLaunched = FALSE;

    DWORD   dwMode = STI_DEVICE_CREATE_STATUS;

    //
    // Startup stuff
    //
    printf("CSTI: Console mode test application for still image interface \n");

    OSVERSIONINFO OsVer;
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVer);

    printf(" Running on operating system version: \n Platform = %d \t Major=%d \t Minor=%d \n",
           OsVer.dwPlatformId,OsVer.dwMajorVersion,OsVer.dwMinorVersion);

    ProcessCommandLine( cArgs,pArgs ) ;

    //
    // Request STI interface pointer
    //
    hres = StiCreateInstanceA(GetModuleHandle(NULL), STI_VERSION, &g_pSti,NULL);

    if (!SUCCEEDED(hres) ) {
        printf("CSTI: StiCreateInstance Returned result=%x \n",hres);
        exit(0);
    }

    g_pSti->WriteToErrorLog(STI_TRACE_INFORMATION,"CSTI application started");

    //
    // Test custom global interface
    //
    hres = g_pSti->QueryInterface(IID_IStillImageW,(LPVOID *)&g_pStiW);
    if (SUCCEEDED(hres) && g_pStiW) {
        g_pStiW->WriteToErrorLog(STI_TRACE_INFORMATION,L"(UNICODE) CSTI application started");
        g_pStiW->Release();
    }

    fAutoLaunched = TestStiLaunch(TRUE);

    //
    // Test enumeration and select device
    //
    TestEnumerationAndSelect(fAutoLaunched ? FALSE : TRUE);

    if (*szSelectedDevice == L'\0') {
        printf("Device not selected, can not continue");
        goto Cleanup;
    }

    pszDeviceName = szSelectedDevice;

    //
    // Test get/set values
    //
    if (g_fTestSetGetValue) {
        TestGetSetValue(pszDeviceName);
    }

    //
    // If needed test notifications
    //
    if (g_fTestEDNotifications) {
        TestEnableDisableNotifications(pszDeviceName);
    }

    if (g_fTestLaunchAPI) {
        TestLaunchAPI(pszDeviceName);
    }

    if (g_fTestRefreshAPI) {
        TestRefreshAPI(pszDeviceName);
    }

    //
    // Create object for first device
    //

    if (g_fTestSCL) {
        dwMode |= STI_DEVICE_CREATE_DATA;
    }

    hres = g_pSti->CreateDevice(pszDeviceName,
                              dwMode,   // Mode
                              &g_pStiDevice,              // Result
                              NULL );                   // Controlling unk

    printf("CSTI: Creating device %s returned result=%x\n",pszDeviceName,hres);

    if (!SUCCEEDED(hres)) {
        printf("CSTI: Call failed - abort \n",hres);
        goto Cleanup;
    }

    //
    // Test second open on the same thread
    //
    hres = g_pSti->CreateDevice(pszDeviceName,
                              dwMode,   // Mode
                              &g_pStiDevice1,              // Result
                              NULL );                   // Controlling unk

    printf("CSTI: Creating device %s second time returned result=%x\n",pszDeviceName,hres);

    g_pStiDevice1->Release();
    g_pStiDevice1 = NULL;


    //
    // Test getting custom interface
    //
    TestQueryCustomInterface(pszDeviceName);

    //
    // Test online status
    //
    STI_DEVICE_STATUS       DevStatus;

    ZeroMemory(&DevStatus,sizeof(DevStatus));

    printf("Getting online status.... :");

    DevStatus.StatusMask = STI_DEVSTATUS_ONLINE_STATE;

    hres = g_pStiDevice -> LockDevice(2000);
    printf("(Locking, ...hres=%X)  ..",hres);

    hres = g_pStiDevice->GetStatus(&DevStatus);

    if (SUCCEEDED(hres) ) {
        if (DevStatus.dwEventHandlingState & STI_ONLINESTATE_OPERATIONAL ) {
            printf("Online\n");
        }
        else {
            printf("Offline\n");
        }
    }
    else {
        printf("Failed, panic...hres=%X\n",hres);

    }

    hres = g_pStiDevice -> UnLockDevice();

    if (g_fWait) {
        TestWaitForNotifications();
    }

    if (g_fTestSCL) {
        TestSCL();
    }

    //
    // Clean up and exit
    //
Cleanup:

    if ( g_pStiDevice) {
        g_pStiDevice->UnLockDevice();
        g_pStiDevice->Release();
    }

    //
    // Delay exiting to test unload
    //
    printf("\nTo exit hit any key ...");
    _getch();

    if ( g_pSti) {
        g_pSti->Release();
    }

    return(0);

}


//
//TestStiLaunch
//
BOOL
TestStiLaunch(
    BOOL    fRegister
    )
{
    HRESULT hres;
    TCHAR   szEventName[65] = {L'\0'};

    DWORD   dwEventCode;
    DWORD   cbData = sizeof(szEventName);

    BOOL    fRet = FALSE;

    hres = g_pSti->GetSTILaunchInformation(szSelectedDevice,&dwEventCode,szEventName);

    if (SUCCEEDED(hres)) {

        CHAR    szMessage[255];

        wsprintf(szMessage,"CSti: Launched through autopush. DeviceName:%s EventName:%s \n",szSelectedDevice,szEventName);

        g_pSti->WriteToErrorLog(STI_TRACE_INFORMATION,szMessage);
        printf(szMessage);

        fRet = TRUE;
    }

    //
    // Register us with STI as launch app
    //
    if (fRegister) {

        CHAR    szModulePath[MAX_PATH+1+32];
        TCHAR   szModulePathW[MAX_PATH+1];

        DWORD   cch;

        cch = GetModuleFileName(NULL,szModulePath,sizeof(szModulePath));

        if (cch) {

            strcat(szModulePath," /Wait");

            #if 0
            cch = MultiByteToWideChar(CP_ACP, 0,
                                szModulePath, -1,
                                szModulePathW, sizeof(szModulePathW)
                                );
            #endif
            hres = g_pSti->RegisterLaunchApplication(TEXT("Console STI Test"),szModulePath) ;

        }
    }


    return fRet;
}

//
// TestEnumeration
//
VOID
TestEnumerationAndSelect(
    BOOL    fMakeSelection
    )
{

    HRESULT hres;
    PVOID   pBuffer;

    DWORD   dwItemsReturned;
    UINT    iCurrentSelection;
    UINT    iDev;

    PSTI_DEVICE_INFORMATIONA pDevInfo;

    printf("CSTI: Running device enumeration\n");

    //
    // Enumerate devices
    //
    hres = g_pSti->GetDeviceList( 0,  // Type
                                0,  // Flags
                                &dwItemsReturned,
                                &pBuffer
                               );
    printf("CSTI: Enumerating devices returned result=%x dwItemsReturned=%d\n",hres,dwItemsReturned);

    if (!SUCCEEDED(hres) || !pBuffer) {
        Beep(0,0);
        printf("CSTI Error : Call failed - abort \n",hres);
        return;
    }

    //
    // Print basic device information
    //
    pDevInfo = (PSTI_DEVICE_INFORMATIONA) pBuffer;

    for (iDev=0;
         iDev<dwItemsReturned ;
         iDev++,
          pDevInfo=(PSTI_DEVICE_INFORMATIONA)((LPBYTE)pDevInfo+pDevInfo->dwSize)
        ) {

        printf("\nImage device #%2d :\n",iDev+1);
        printf(" Type\t\t:%2d\n Internal name: %s\n",
                pDevInfo->DeviceType,
                pDevInfo->szDeviceInternalName
                );
    }

    printf("\n");
    if (*szSelectedDevice == L'\0') {
        printf("No currently selected device\n");
    }
    else {
        printf("Currently selected device:%s\n",szSelectedDevice);
    }

    pDevInfo = (PSTI_DEVICE_INFORMATIONA) pBuffer;

    if (fMakeSelection && dwItemsReturned) {

        *szSelectedDevice = L'\0';
        iCurrentSelection = 0;

        if ( dwItemsReturned == 1) {
            lstrcpy((LPSTR)szSelectedDevice,pDevInfo->szDeviceInternalName);
            printf("Only one device known, automatically selected device:%s\n",szSelectedDevice);
        }
        else {

            printf("Make a selection for currently active device:(1-%d)\n",dwItemsReturned);
            scanf("%2d",&iCurrentSelection);
            if (iCurrentSelection ==0 || iCurrentSelection > dwItemsReturned) {
                printf("CSTI Error: Invalid selection");
            }
            else {
                lstrcpy((LPSTR)szSelectedDevice,(pDevInfo+iCurrentSelection-1)->szDeviceInternalName);
                printf("Newly selected device:%s\n",szSelectedDevice);
            }
        }
    }

    if (pBuffer) {
        LocalFree(pBuffer);
        pBuffer = NULL;
    }
}

//
// TestGetSetValue
//

TCHAR   szTestValue[] = TEXT("TestValue");

VOID
TestGetSetValue(
    LPTSTR  pszDeviceName
    )
{
    HRESULT hRes;

    DWORD   dwType;
    DWORD   cbData;

    BYTE    aData[255];

    printf("\nCSTI Testing get/set device value for device: %s\n\n",pszDeviceName);

    ::lstrcpy((LPSTR)aData,"TestValueMeaning");
    cbData = ::lstrlen((LPCSTR)aData) + sizeof(TCHAR);

    hRes = g_pSti->SetDeviceValue(pszDeviceName,szTestValue,REG_SZ,aData,cbData);

    printf("Wrote value :%s containing :%s Result=%x\n",
           szTestValue, (LPCSTR)aData, hRes);

    cbData = sizeof(aData);
    hRes = g_pSti->GetDeviceValue(pszDeviceName,szTestValue,&dwType,aData,&cbData);

    printf("Got back value :%s containing :%s dwType:%2d cbData:%4d Result=%x\n",
           szTestValue, (LPCSTR)aData, dwType, cbData,hRes);

    cbData = sizeof(aData);
    hRes = g_pSti->GetDeviceValue(pszDeviceName,STI_DEVICE_VALUE_TWAIN_NAME_A,&dwType,aData,&cbData);

    printf("Got back value :%s containing :%s dwType:%2d cbData:%4d Result=%x\n",
           STI_DEVICE_VALUE_TWAIN_NAME, (LPCSTR)aData, dwType, cbData,hRes);

    printf("\n\n");

}


VOID
TestQueryCustomInterface(
    LPTSTR  pszDeviceName
    )
{

}

//
//
//
VOID
TestSCL(
    VOID
    )
{
    HRESULT hres;

    STI_DEVICE_STATUS       DevStatus;

    CHAR    ScanData[1024*16];
    ULONG   cbDataSize;

    UINT    xRes = 0;
    BOOL    fLocked = FALSE;

    //
    // Try to communicate to device in raw mode
    //

    g_pStiDevice->LockDevice(2000);

    // Resetting device
    g_pStiDevice->DeviceReset();

    //
    // Get and display status
    //
    ZeroMemory(&DevStatus,sizeof(DevStatus));
    hres = g_pStiDevice->GetStatus(&DevStatus);

    if (!SUCCEEDED(hres) ) {
        printf("CSTI: Get status call failed - abort \n",hres);
    }
    else {

    }

    //
    // Test lamp on/of capability
    //
    hres = SendDeviceCommandString(g_pStiDevice,LampOn);
    printf("\nHit any key...");
    _getch();

    hres = SendDeviceCommandString(g_pStiDevice,LampOff);
    printf("\n");

    //
    // Inquire commands ( X and Y resolution)
    //
    cbDataSize = sizeof(ScanData);
    ZeroMemory(ScanData,sizeof(ScanData));

    hres = TransactDevice(g_pStiDevice,ScanData,cbDataSize,InqXRes);

    if (SUCCEEDED(hres) ) {
        sscanf(ScanData,"%d",&xRes);

        printf("CSTI: XRes = %d\n",xRes);
    }

    //
    // Get status
    //

    printf(" Start polling for button.......");



#ifndef USE_GETSTATUS
    while (TRUE) {

        ZeroMemory(ScanData,sizeof(ScanData));
        hres = SendDeviceCommandString(g_pStiDevice,PollButton);

        if (SUCCEEDED(hres) ) {

            cbDataSize = sizeof(ScanData);
            hres = g_pStiDevice->RawReadData(ScanData,&cbDataSize,NULL);
            if (SUCCEEDED(hres) ) {
                printf("CSTI: Got data from polling Size=(%d) Data=(%s)\n",cbDataSize,ScanData);
            }
        }

        Sleep(2000);
    }

#else
    while (TRUE) {

        printf("\nLocking device");

        if (SUCCEEDED(hres) ) {

            ZeroMemory(&DevStatus,sizeof(DevStatus));
            DevStatus.StatusMask = STI_DEVSTATUS_EVENTS_STATE;

            hres = g_pStiDevice->GetStatus(&DevStatus);
            printf("\nGot status");
            if (SUCCEEDED(hres) ) {
                if (DevStatus.dwEventHandlingState & STI_EVENTHANDLING_PENDING ) {
                    printf("\nEvent detected");
                    g_pStiDevice->DeviceReset();
                }
            }
        }

        Sleep(2000);

    }
#endif

    printf("\nTo start scanning , hit any key...");
    _getch();

    //
    // Perform scan
    //
    hres = SendDeviceCommandString(g_pStiDevice,ScanCmd);

    UINT i=0;

    do {

        cbDataSize = sizeof(ScanData);
        hres = g_pStiDevice->RawReadData(ScanData,&cbDataSize,NULL);

        if (cbDataSize == sizeof (ScanData)) {
            i++;
            printf (".");
        }
    } while ( cbDataSize == sizeof (ScanData));

    printf ("\n CSTI: Scan done total Bytes = %ld.\n",(sizeof(ScanData))*i+cbDataSize);


}

//
//
//
VOID
TestWaitForNotifications(
    VOID
    )
{
    HANDLE  hWaitEvent;
    HRESULT hres;

    BOOL    fWaiting = TRUE;
    DWORD   dwErr = 0x56565656;

    hWaitEvent = CreateEvent( NULL, // Attributes
                              FALSE,    // Manual reset
                              FALSE,    // Initial state
                              NULL );   // Name

    if ( !hWaitEvent ) {
        return;
    }

    STISUBSCRIBE sSubscribe;

    ZeroMemory(&sSubscribe,sizeof(sSubscribe));

    sSubscribe.dwSize = sizeof(STISUBSCRIBE);
    sSubscribe.dwFlags = STI_SUBSCRIBE_FLAG_EVENT    ;

    sSubscribe.hWndNotify = NULL;
    sSubscribe.hEvent = hWaitEvent;
    sSubscribe.uiNotificationMessage = 0;

    hres = g_pStiDevice->Subscribe(&sSubscribe);

    printf("CSTI::Device::Attempted to subscribe . Returned %xh %u\n",hres,hres);

    printf("CSTI Waiing for notifications on device ( to stop press Q)..........\n");

    while (fWaiting) {

        dwErr = WaitForSingleObject(hWaitEvent,1000);

        switch (dwErr) {
            case WAIT_OBJECT_0:
                {
                    //
                    // Something came
                    //
                    STINOTIFY  sNotify;

                    ZeroMemory(&sNotify,sizeof(sNotify));
                    sNotify.dwSize = sizeof(sNotify);

                    printf("Received notification from opened device :");
                    hres = g_pStiDevice->GetLastNotificationData(&sNotify);
                    if (SUCCEEDED(hres)) {
                        printf("GUID={%8x-%4x-%4x-%lx}\n",
                               sNotify.guidNotificationCode.Data1,
                               sNotify.guidNotificationCode.Data2,
                               sNotify.guidNotificationCode.Data3,
                               (ULONG_PTR)sNotify.guidNotificationCode.Data4
                                );
                    }
                    else {
                        printf("Failed get data hres=%X\n",hres);
                    }
                }
                break;

            case WAIT_TIMEOUT:
                // Fall through
            default:
                //
                // Check for keyboard input
                //
                if (_kbhit()) {

                    int    ch;

                    ch = _getch();
                    if (toupper(ch) == 'Q') {
                        fWaiting = FALSE;
                    }
                }
                break;
        }
    }

    hres = g_pStiDevice->UnSubscribe();

    printf("CSTI::Device::UnSubscribing Returned %xh %u\n",hres,hres);
}

//
// Test Enable/Disable notfications on a device
//
VOID
TestEnableDisableNotifications(
    LPTSTR  pszDeviceName
    )
{

    int     ch = '\0';
    BOOL    fLooping = TRUE;
    BOOL    fState = FALSE;
    HRESULT hRes;

    printf("\nCSTI: Testing enable/disable notfications functionality for device: %s\n\n",pszDeviceName);

    while (fLooping) {

        hRes = g_pSti->GetHwNotificationState(pszDeviceName,&fState);

        if (SUCCEEDED(hRes)) {
            printf("Current notifcation state is: %s. (E,D,Q) >",
                   fState ? "Enabled" : "Disabled");
        }
        else {
            printf("Failed to get notification state, exiting ");
            exit(0);
        }

        ch = _getch();

        if (toupper(ch) == 'Q') {
            fLooping = FALSE;
        }
        else if (toupper(ch) == 'E') {
            g_pSti->EnableHwNotifications(pszDeviceName,TRUE);
        }
        else if (toupper(ch) == 'D') {
            g_pSti->EnableHwNotifications(pszDeviceName,FALSE);
        }
        printf("\n");
    }
}

//
// Test external launch API
//

VOID
TestLaunchAPI(
    LPTSTR  pszDeviceName
    )
{
    BOOL    fLooping = TRUE;
    HRESULT hRes;

    TCHAR   wszAppName[] = TEXT("HP PictureScan 3.0");
    GUID    guidLaunchEvent = guidGreenButton;

    STINOTIFY    sStiNotify;

    printf("\nCSTI: Testing external launching for device: %s\n\n",pszDeviceName);

    //printf("Enter name of the registered application to launch on a device:");

    ::ZeroMemory(&sStiNotify,sizeof(sStiNotify));
    sStiNotify.dwSize = sizeof(sStiNotify);
    sStiNotify.guidNotificationCode = guidLaunchEvent;

    hRes = g_pSti->LaunchApplicationForDevice(pszDeviceName,wszAppName,&sStiNotify);

    printf("CSTI: Launching application (%s) hResult=%x \n",wszAppName,hRes);
}

//
//  Bus refresh
//

VOID
TestRefreshAPI(
    LPTSTR  pszDeviceName
    )
{
    HRESULT hRes;

    printf("\nCSTI: Testing bus refresh for device: %s\n\n",pszDeviceName);

    hRes = g_pSti->RefreshDeviceBus(pszDeviceName);

    printf("CSTI: After bus refresh hResult=%x \n",hRes);

}



/*
 * Send formatted SCL string to the device
 *
 */
HRESULT
WINAPI
SendDeviceCommandString(
    PSTIDEVICE  pStiDevice,
    LPSTR       pszFormat,
    ...
    )
{

    CHAR    ScanCommand[255];
    UINT    cbChar;
    HRESULT hres;

    // Format command string
    ZeroMemory(ScanCommand,sizeof(ScanCommand));  // blank command
    ScanCommand[0]='\033';                       // stuff with Reset()
    cbChar = 1;

    va_list ap;
    va_start(ap, pszFormat);
    cbChar += vsprintf(ScanCommand+1, pszFormat, ap);
    va_end(ap);

    // Send it to the device
    hres = pStiDevice->RawWriteData(ScanCommand,cbChar,NULL);

    printf("CSTISendFormattoDevice: First byte : %2x Rest of string: %s returned result=%x\n",
            ScanCommand[0],ScanCommand+1,hres);

    return hres;

}

HRESULT
WINAPI
TransactDevice(
    PSTIDEVICE  pStiDevice,
    LPSTR       lpResultBuffer,
    UINT        cbResultBufferSize,
    LPSTR       pszFormat,
    ...
    )
{

    CHAR    ScanCommand[255];
    UINT    cbChar;
    ULONG   cbActual;
    HRESULT hres;

    // Format command string
    ZeroMemory(ScanCommand,sizeof(ScanCommand));
    ScanCommand[0]='\033';
    cbChar = 1;

    va_list ap;
    va_start(ap, pszFormat);
    cbChar += vsprintf(ScanCommand+1, pszFormat, ap);
    va_end(ap);

    // Send it to the device

    cbActual = 0;

    hres = S_OK;
    // hres = pStiDevice->Escape(StiTransact,ScanCommand,cbChar,lpResultBuffer,cbResultBufferSize,&cbActual);

    printf("CSTITransact : First byte : %2x Rest of string: %s returned result=%x\n",
            ScanCommand[0],ScanCommand+1,hres);

    return hres;

}

BOOL WINAPI
FormatStringV(
    IN LPTSTR   lpszStr,
    //LPSTR     lpszFirst,
    ...
    )
{
    DWORD   cch;
    LPSTR   pchBuff;
    BOOL    fRet = FALSE;
    DWORD   dwErr;

    va_list va;

    va_start(va,lpszStr);
    //va_arg(va,LPSTR);

    cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_STRING,
                                                                lpszStr,
                                0L,
                                0,
                                (LPSTR) &pchBuff,
                                1024,
                                                                &va);
    dwErr = ::GetLastError();

    if ( cch )     {
        ::lstrcpy(lpszStr,(LPCSTR) pchBuff );

        ::LocalFree( (VOID*) pchBuff );
    }

    return fRet;
}

//
// Parse command line
//
VOID
ProcessCommandLine(
    INT    cArgs,
    char * pArgs[]
    )
{
    if (cArgs < 2) {
        return;
    }

    LPSTR   pOption;

    for (INT i=1;i<cArgs;i++) {

        pOption = pArgs[i];

        // Skip delimiter
        if (*pOption == '/' || *pOption == '-') {
            pOption++;
        }
        if (!*pOption) {
            continue;
        }

        // Set globals
        if (!_stricmp(pOption,"Wait")) {
            g_fWait = TRUE;
        }
        else if (!_stricmp(pOption,"SCL")) {
            g_fTestSCL = TRUE;
        }
        else if (!_stricmp(pOption,"EDN")) {
            g_fTestEDNotifications = TRUE;
        }
        else if (!_stricmp(pOption,"LAUNCH")) {
            g_fTestLaunchAPI = TRUE;
        }
        else if (!_stricmp(pOption,"REFRESH")) {
            g_fTestRefreshAPI = TRUE;
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\cregistry.h ===
#ifndef _CREGISTRY_H
#define _CREGISTRY_H

class CRegistry {

public:

    CRegistry(LPTSTR szHomeRegistryKey)
    {
        DWORD dwDisposition = 0;
        LONG ErrorResult = RegCreateKeyEx(
            HKEY_CURRENT_USER,
            szHomeRegistryKey,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &m_hHomeKey,
            &dwDisposition);
        m_bReady = (ErrorResult == ERROR_SUCCESS);
    }
    ~CRegistry()
    {
        if(NULL != m_hHomeKey){
            RegCloseKey(m_hHomeKey);
        }
    }

    LONG ReadStringValue(LPTSTR szValueName, LPTSTR szValue, DWORD dwBufferSize)
    {        
        DWORD Type = REG_SZ;
        LONG ErrorResult = RegQueryValueEx(m_hHomeKey,
            szValueName,
            NULL,
            &Type,
            (LPBYTE)szValue,
            &dwBufferSize);
        return ErrorResult;
    }

    LONG ReadLongValue(LPTSTR szValueName)
    {
        DWORD dwBufferSize = sizeof(LONG);
        DWORD Type = REG_DWORD;
        LONG ReturnValue = 0;
        LONG ErrorResult = RegQueryValueEx(m_hHomeKey,
            szValueName,
            NULL,
            &Type,
            (LPBYTE)&ReturnValue,
            &dwBufferSize);
        return ReturnValue;
    }

    LONG WriteStringValue(LPTSTR szValueName, LPTSTR szValue)
    {        
        return RegSetValueEx(m_hHomeKey,
            szValueName,
            0,
            REG_SZ,
            (LPBYTE)szValue,
            lstrlen(szValue) + 1);        
    }

    LONG WriteLongValue(LPTSTR szValueName, LONG lValue)
    {
        return RegSetValueEx(m_hHomeKey,
            szValueName,
            0,
            REG_DWORD,
            (LPBYTE)&lValue,
            sizeof(LONG));                
    }

private:
    HKEY  m_hHomeKey;
    HKEY  m_CurrentKey;
    BOOL  m_bReady;
protected:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\datadump.h ===
#ifndef _DATADUMP
#define _DATADUMP

#define MAX_PAD_DATA 1048576    // 1 meg of padding

typedef struct _DATA_DESCRIPTION {

    DWORD  dwDataSize;
    DWORD  dwbpp;
    DWORD  dwWidth;
    DWORD  dwHeight;
    PBYTE  pRawData;

}DATA_DESCRIPTION,*PDATA_DESCRIPTION;

class CDATADUMP {
public:
    CDATADUMP()
    {
        m_pDIB       = NULL;
        m_pDIBHeader = NULL;
    }
    ~CDATADUMP()
    {
        FreeDIBMemory();
    }

    BOOL DumpDataToBitmap(LPTSTR szBitmapFileName,
                          PDATA_DESCRIPTION pDataDesc)
    {
        if(!AllocateDIBMemory(pDataDesc))
            return FALSE;

        if(!WriteDIBHeader(pDataDesc))
            return FALSE;

        if(!WriteRawDataToDIB(pDataDesc))
            return FALSE;

        if(!WriteDIBToDisk(szBitmapFileName))
            return FALSE;
        return TRUE;
    }

    BOOL DumpDataToDIB(PDATA_DESCRIPTION pDataDesc)
    {
        if(!AllocateDIBMemory(pDataDesc))
            return FALSE;

        if(!WriteDIBHeader(pDataDesc))
            return FALSE;

        if(!WriteRawDataToDIB(pDataDesc))
            return FALSE;

        return TRUE;
    }

    PBYTE GetDIBPtr()
    {
        return m_pDIB;
    }

    BOOL OwnDIBPtr(PBYTE *ppOUTDIB)
    {
        if(NULL != m_pDIB){

            //
            // assign the DIB pointer to new owner's pointer
            // new owner must free allocated DIB
            //

            *ppOUTDIB      = m_pDIB;

            //
            // set our pointer to NULL, so we don't try to
            // free the new owner's memory.
            //

            m_pDIB       = NULL;
            m_pDIBHeader = NULL;
            return TRUE;
        }
        return FALSE;
    }

private:

    PBYTE m_pDIB;
    BITMAPINFOHEADER *m_pDIBHeader;

    VOID FreeDIBMemory(){
        if (NULL != m_pDIB){
            LocalFree(m_pDIB);
            m_pDIB       = NULL;
            m_pDIBHeader = NULL;
        }
    }

    BOOL AllocateDIBMemory(PDATA_DESCRIPTION pDataDesc)
    {
        m_pDIB = (PBYTE)LocalAlloc(LPTR,sizeof(BITMAPINFOHEADER) +
                                       (sizeof(RGBQUAD) * 256)   +
                                        pDataDesc->dwDataSize    +
                                        MAX_PAD_DATA);
        if (NULL == m_pDIB)
            return FALSE;

        m_pDIBHeader = (BITMAPINFOHEADER*)m_pDIB;
        return TRUE;
    }

    LONG RawWidthBytes()
    {
        switch(m_pDIBHeader->biBitCount){
        case 1:
            return (LONG)((m_pDIBHeader->biWidth + 7) / 8);
            break;
        case 8:
            return (LONG)(m_pDIBHeader->biWidth);
            break;
        case 24:
            return (LONG)(m_pDIBHeader->biWidth * 3);
            break;
        default:
            break;
        }
        return 0;
    }

    BOOL WriteDIBHeader(PDATA_DESCRIPTION pDataDesc)
    {
        if(NULL == m_pDIB)
            return FALSE;

        m_pDIBHeader->biSize        = sizeof(BITMAPINFOHEADER);
        m_pDIBHeader->biBitCount    = (WORD)pDataDesc->dwbpp;
        m_pDIBHeader->biCompression = BI_RGB;
        m_pDIBHeader->biHeight      = pDataDesc->dwHeight;
        m_pDIBHeader->biWidth       = pDataDesc->dwWidth;
        m_pDIBHeader->biSizeImage   = pDataDesc->dwDataSize;
        m_pDIBHeader->biPlanes      = 1;
        m_pDIBHeader->biXPelsPerMeter = 0;
        m_pDIBHeader->biYPelsPerMeter = 0;

        switch(pDataDesc->dwbpp){
        case 1:
            m_pDIBHeader->biClrImportant= 2;
            m_pDIBHeader->biClrUsed     = 2;
            break;
        case 8:
            m_pDIBHeader->biClrImportant= 256;
            m_pDIBHeader->biClrUsed     = 256;
            break;
        case 24:
            m_pDIBHeader->biClrImportant= 0;
            m_pDIBHeader->biClrUsed     = 0;
            break;
        default:
            FreeDIBMemory();
            return FALSE;
            break;
        }

        return TRUE;
    }

    BOOL BuildPalette(RGBQUAD *pPalette)
    {
        BYTE i = 0;
        switch(m_pDIBHeader->biBitCount){
        case 1: // black and white palette
            {
                pPalette[0].rgbBlue     = 0;
                pPalette[0].rgbGreen    = 0;
                pPalette[0].rgbRed      = 0;
                pPalette[0].rgbReserved = 0;

                pPalette[1].rgbBlue     = 255;
                pPalette[1].rgbGreen    = 255;
                pPalette[1].rgbRed      = 255;
                pPalette[1].rgbReserved = 0;
            }
            break;
        case 8: // grayscale palette
            {
                for (i = 0; i < 255;i++) {
                    pPalette[i].rgbBlue     = i;
                    pPalette[i].rgbGreen    = i;
                    pPalette[i].rgbRed      = i;
                    pPalette[i].rgbReserved = 0;
                }
            }
            break;
        case 24:
        default:
            break;

        }
        return TRUE;
    }

    BOOL WriteRawDataToDIB(PDATA_DESCRIPTION pDataDesc)
    {
        //
        // create a palette (for 1-bit, and 8-bit images)
        //

        RGBQUAD *pPalette = (RGBQUAD*)LocalAlloc(LPTR,(sizeof(RGBQUAD) * m_pDIBHeader->biClrUsed));
        BuildPalette(pPalette);

        //
        // insert palette into DIB memory block, past BITMAPINFOHEADER
        //

        PBYTE pDest = m_pDIB + sizeof(BITMAPINFOHEADER);
        memcpy(pDest,
               pPalette,
               (sizeof(RGBQUAD) * m_pDIBHeader->biClrUsed));

        if(NULL != pPalette)
            LocalFree(pPalette);

        //
        // insert raw bits to DIB memory block
        // (DWORD alignment will happen here too)
        //

        pDest               = m_pDIB + sizeof(BITMAPINFOHEADER) + (m_pDIBHeader->biClrUsed * sizeof(RGBQUAD));
        PBYTE pRawData      = pDataDesc->pRawData;
        LONG lRawWidthBytes = RawWidthBytes();
        LONG PadWidthBytes  = ((((m_pDIBHeader->biWidth * m_pDIBHeader->biBitCount) + 31) / 8) & 0xfffffffc) - (lRawWidthBytes);

        //
        // update image size in BITMAPINFOHEADER, padding will increase total image size
        //

        m_pDIBHeader->biSizeImage += (PadWidthBytes * m_pDIBHeader->biHeight);
        PBYTE pPadData      = new BYTE[PadWidthBytes]; //(PBYTE)LocalAlloc(LPTR, PadWidthBytes);
        if(NULL != pPadData) {
            memset(pPadData,0,PadWidthBytes); // clear padded byte memory...
            Trace(TEXT("Copying Line data (%d total lines)"),m_pDIBHeader->biHeight);
            for(LONG Line = 1; Line <= m_pDIBHeader->biHeight; Line++) {
                // Trace(TEXT("Copy Line %d of %d"),Line,m_pDIBHeader->biHeight);

                //
                // copy a raw data line to DIB
                //

                memcpy(pDest,pRawData,lRawWidthBytes);

                //
                // move destination pointer (RawWidthBytes)
                //

                pDest    += lRawWidthBytes;

                //
                // copy a padded buffer to DIB
                //

                memcpy(pDest,pPadData,PadWidthBytes);

                //
                // move destination pointer (PadWidthBytes)
                //

                pDest    += PadWidthBytes;

                //
                // move src pointer RawWidthBytes only
                //

                pRawData += lRawWidthBytes;
            }
            Trace(TEXT("Done... data copy complete..for %d lines"),(Line - 1));

            //
            // free padded bytes memory
            //

            delete pPadData; //LocalFree(pPadData);

        } else
            return FALSE;
        return TRUE;
    }

    VOID Trace(LPCTSTR format,...)
    {
        TCHAR Buffer[1024];
        va_list arglist;
        va_start(arglist, format);
        wvsprintf(Buffer, format, arglist);
        va_end(arglist);
        OutputDebugString(Buffer);
        OutputDebugString(TEXT("\n"));
    }

    BOOL WriteDIBToDisk(LPTSTR szBitmapFileName)
    {
        //
        // create bitmap file on disk
        //

        HANDLE hBitmapFile = CreateFile(szBitmapFileName,
                                     GENERIC_READ | GENERIC_WRITE, // Access mask
                                     0,                            // Share mode
                                     NULL,                         // SA
                                     CREATE_ALWAYS,                // Create disposition
                                     FILE_ATTRIBUTE_NORMAL,        // Attributes
                                     NULL );
        if(NULL == hBitmapFile)
            return FALSE;

        //
        // create bitmap file header
        //

        BITMAPFILEHEADER BitmapFileHeader;
        BitmapFileHeader.bfOffBits = (sizeof(BITMAPFILEHEADER) +
                                      sizeof(BITMAPINFOHEADER) +
                                      (m_pDIBHeader->biClrUsed * sizeof(RGBQUAD)));

        BitmapFileHeader.bfReserved1 = 0;
        BitmapFileHeader.bfReserved2 = 0;
        BitmapFileHeader.bfSize = (BitmapFileHeader.bfOffBits +
                                   m_pDIBHeader->biSizeImage);

        BitmapFileHeader.bfType = MAKEWORD('B','M');

        DWORD dwWritten = 0;

        //
        // write bitmap file header to open bitmap file
        //

        WriteFile(hBitmapFile,&BitmapFileHeader,sizeof(BITMAPFILEHEADER),&dwWritten,NULL);

        //
        // write DIB memory to opend bitmap file
        //

        WriteFile(hBitmapFile,
                  m_pDIB,
                  (sizeof(BITMAPINFOHEADER) + m_pDIBHeader->biSizeImage + (sizeof(RGBQUAD) * m_pDIBHeader->biClrUsed)),
                  &dwWritten,
                  NULL);



        CloseHandle(hBitmapFile);

        return TRUE;
    }
    protected:

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\configdlg.cpp ===
// ConfigDlg.cpp : implementation file
//

#include "stdafx.h"
#include "devctrl.h"
#include "ConfigDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigDlg dialog


CConfigDlg::CConfigDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfigDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConfigDlg)
	m_Pipe1 = _T("");
	m_Pipe2 = _T("");
	m_Pipe3 = _T("");
	m_DefaultPipe = _T("");
	//}}AFX_DATA_INIT
}


void CConfigDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigDlg)
	DDX_Control(pDX, IDC_STATUS_COMBOBOX, m_StatusCombobox);
	DDX_Control(pDX, IDC_INTERRUPT_COMBOBOX, m_InterruptCombobox);
	DDX_Control(pDX, IDC_BULK_OUT_COMBOBOX, m_BulkOutCombobox);
	DDX_Control(pDX, IDC_BULK_IN_COMBOBOX, m_BulkInCombobox);
	DDX_Text(pDX, IDC_PIPE1_NAME_EDITBOX, m_Pipe1);
	DDX_Text(pDX, IDC_PIPE2_NAME_EDITBOX, m_Pipe2);
	DDX_Text(pDX, IDC_PIPE3_NAME_EDITBOX, m_Pipe3);
	DDX_Text(pDX, IDC_DEFAULT_PIPE_NAME_EDITBOX, m_DefaultPipe);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigDlg, CDialog)
	//{{AFX_MSG_MAP(CConfigDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigDlg message handlers

BOOL CConfigDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    m_StatusCombobox.SetCurSel(m_DeviceControl.StatusPipeIndex);
	m_InterruptCombobox.SetCurSel(m_DeviceControl.InterruptPipeIndex);
	m_BulkOutCombobox.SetCurSel(m_DeviceControl.BulkOutPipeIndex);
	m_BulkInCombobox.SetCurSel(m_DeviceControl.BulkInPipeIndex);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigDlg::OnOK() 
{
	m_DeviceControl.StatusPipeIndex = m_StatusCombobox.GetCurSel();
	m_DeviceControl.InterruptPipeIndex = m_InterruptCombobox.GetCurSel();
	m_DeviceControl.BulkOutPipeIndex = m_BulkOutCombobox.GetCurSel();
	m_DeviceControl.BulkInPipeIndex = m_BulkInCombobox.GetCurSel();
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\devctrldefs.h ===
#ifndef _DEVCTRL_DEFS_H
#define _DEVCTRL_DEFS_H

#define MAX_IO_HANDLES  16

typedef struct _DEVCTRL {

    HANDLE DeviceIOHandles[MAX_IO_HANDLES];
    INT    StatusPipeIndex;
    INT    InterruptPipeIndex;
    INT    BulkOutPipeIndex;
    INT    BulkInPipeIndex;

} DEVCTRL, *PDEVCTRL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\devctrl.cpp ===
// devctrl.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "devctrl.h"
#include "devctrlDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDevctrlApp

BEGIN_MESSAGE_MAP(CDevctrlApp, CWinApp)
    //{{AFX_MSG_MAP(CDevctrlApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDevctrlApp construction

CDevctrlApp::CDevctrlApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDevctrlApp object

CDevctrlApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDevctrlApp initialization

BOOL CDevctrlApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CDevctrlDlg dlg;
    m_pMainWnd = &dlg;
    int nResponse = (int)dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\devctrl.h ===
// devctrl.h : main header file for the DEVCTRL application
//

#if !defined(AFX_DEVCTRL_H__DA93F21A_CB04_421B_AEF1_F8767AD1B3B7__INCLUDED_)
#define AFX_DEVCTRL_H__DA93F21A_CB04_421B_AEF1_F8767AD1B3B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevctrlApp:
// See devctrl.cpp for the implementation of this class
//

class CDevctrlApp : public CWinApp
{
public:
	CDevctrlApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDevctrlApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDevctrlApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEVCTRL_H__DA93F21A_CB04_421B_AEF1_F8767AD1B3B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\configdlg.h ===
#if !defined(AFX_CONFIGDLG_H__DA48CC11_76C6_4405_A9BB_0AC3882E3E67__INCLUDED_)
#define AFX_CONFIGDLG_H__DA48CC11_76C6_4405_A9BB_0AC3882E3E67__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ConfigDlg.h : header file
//
#include "devctrldefs.h"

/////////////////////////////////////////////////////////////////////////////
// CConfigDlg dialog

class CConfigDlg : public CDialog
{
// Construction
public:
	CConfigDlg(CWnd* pParent = NULL);   // standard constructor
    DEVCTRL m_DeviceControl;

// Dialog Data
	//{{AFX_DATA(CConfigDlg)
	enum { IDD = IDD_CONFIGURE_DIALOG };
	CComboBox	m_StatusCombobox;
	CComboBox	m_InterruptCombobox;
	CComboBox	m_BulkOutCombobox;
	CComboBox	m_BulkInCombobox;
	CString	m_Pipe1;
	CString	m_Pipe2;
	CString	m_Pipe3;
	CString	m_DefaultPipe;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfigDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONFIGDLG_H__DA48CC11_76C6_4405_A9BB_0AC3882E3E67__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\csti\stdafx.h ===
//

#define _AFX_NO_BSTR_SUPPORT    1

#define AFX_CDECL               CDECL
#define AFXAPI                  WINAPI
#define AFX_DATA
#define AFX_DATADEF
#define DEBUG_NEW           new
#define TRACE1(s,x)         DPRINTF(DM_TRACE,s,x)
#define VERIFY              REQUIRE
#define _AFX_INLINE         inline

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

#include <tchar.h>
                                                
#include <stidebug.h>


/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
    typedef LPSTR BSTR;
#else
    typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CStringData
{
    long nRefs;     // reference count
    int nDataLength;
    int nAllocLength;
    // TCHAR data[nAllocLength]

    TCHAR* data()
        { return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
    CString();
    CString(const CString& stringSrc);
    CString(TCHAR ch, int nRepeat = 1);
    CString(LPCSTR lpsz);
    CString(LPCWSTR lpsz);
    CString(LPCTSTR lpch, int nLength);
    CString(const unsigned char* psz);

// Attributes & Operations
    // as an array of characters
    int GetLength() const;
    BOOL IsEmpty() const;
    void Empty();                       // free up the data

    TCHAR GetAt(int nIndex) const;      // 0 based
    TCHAR operator[](int nIndex) const; // same as GetAt
    void SetAt(int nIndex, TCHAR ch);
    operator LPCTSTR() const;           // as a C string

    // overloaded assignment
    const CString& operator=(const CString& stringSrc);
    const CString& operator=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator=(char ch);
#endif
    const CString& operator=(LPCSTR lpsz);
    const CString& operator=(LPCWSTR lpsz);
    const CString& operator=(const unsigned char* psz);

    // string concatenation
    const CString& operator+=(const CString& string);
    const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator+=(char ch);
#endif
    const CString& operator+=(LPCTSTR lpsz);

    friend CString AFXAPI operator+(const CString& string1,
            const CString& string2);
    friend CString AFXAPI operator+(const CString& string, TCHAR ch);
    friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
    friend CString AFXAPI operator+(const CString& string, char ch);
    friend CString AFXAPI operator+(char ch, const CString& string);
#endif
    friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
    friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

    // string comparison
    int Compare(LPCTSTR lpsz) const;         // straight character
    int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
    int Collate(LPCTSTR lpsz) const;         // NLS aware

    // simple sub-string extraction
    CString Mid(int nFirst, int nCount) const;
    CString Mid(int nFirst) const;
    CString Left(int nCount) const;
    CString Right(int nCount) const;

    CString SpanIncluding(LPCTSTR lpszCharSet) const;
    CString SpanExcluding(LPCTSTR lpszCharSet) const;

    // upper/lower/reverse conversion
    void MakeUpper();
    void MakeLower();
    void MakeReverse();

    // trimming whitespace (either side)
    void TrimRight();
    void TrimLeft();

    // searching (return starting index, or -1 if not found)
    // look for a single character match
    int Find(TCHAR ch) const;               // like "C" strchr
    int ReverseFind(TCHAR ch) const;
    int FindOneOf(LPCTSTR lpszCharSet) const;

    // look for a specific sub-string
    int Find(LPCTSTR lpszSub) const;        // like "C" strstr

    // simple formatting
    void AFX_CDECL Format(LPCTSTR lpszFormat, ...);
    void AFX_CDECL Format(UINT nFormatID, ...);

    // formatting for localization (uses FormatMessage API)
    void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
    void AFX_CDECL FormatMessage(UINT nFormatID, ...);

    // input and output
#ifdef _DEBUG
    friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,
                const CString& string);
#endif
    //friend CArchive& AFXAPI operator<<(CArchive& ar, const CString& string);
    //friend CArchive& AFXAPI operator>>(CArchive& ar, CString& string);

    // Windows support
    BOOL LoadString(UINT nID);          // load from string resource
                                        // 255 chars max
#ifndef _UNICODE
    // ANSI <-> OEM support (convert string in place)
    void AnsiToOem();
    void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
    // OLE BSTR support (use for OLE automation)
    BSTR AllocSysString() const;
    BSTR SetSysString(BSTR* pbstr) const;
#endif

    // Access to string implementation buffer as "C" character array
    LPTSTR GetBuffer(int nMinBufLength);
    void ReleaseBuffer(int nNewLength = -1);
    LPTSTR GetBufferSetLength(int nNewLength);
    void FreeExtra();

    // Use LockBuffer/UnlockBuffer to turn refcounting off
    LPTSTR LockBuffer();
    void UnlockBuffer();

// Implementation
public:
    ~CString();
    int GetAllocLength() const;

protected:
    LPTSTR m_pchData;   // pointer to ref counted string data

    // implementation helpers
    CStringData* GetData() const;
    void Init();
    void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
    void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
    void FormatV(LPCTSTR lpszFormat, va_list argList);
    void CopyBeforeWrite();
    void AllocBeforeWrite(int nLen);
    void Release();
    static void PASCAL Release(CStringData* pData);
    static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
//extern AFX_DATA TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()
                                
// CString
_AFX_INLINE CStringData* CString::GetData() const
    { ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
_AFX_INLINE void CString::Init()
    { m_pchData = afxEmptyString.m_pchData; }
_AFX_INLINE CString::CString(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
_AFX_INLINE const CString& CString::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
_AFX_INLINE const CString& CString::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
_AFX_INLINE const CString& CString::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
_AFX_INLINE CString AFXAPI operator+(const CString& string, char ch)
    { return string + (TCHAR)ch; }
_AFX_INLINE CString AFXAPI operator+(char ch, const CString& string)
    { return (TCHAR)ch + string; }
#endif

_AFX_INLINE int CString::GetLength() const
    { return GetData()->nDataLength; }
_AFX_INLINE int CString::GetAllocLength() const
    { return GetData()->nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
    { return GetData()->nDataLength == 0; }
_AFX_INLINE CString::operator LPCTSTR() const
    { return m_pchData; }
_AFX_INLINE int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
_AFX_INLINE int CString::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
_AFX_INLINE int CString::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
_AFX_INLINE int CString::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive

_AFX_INLINE TCHAR CString::GetAt(int nIndex) const
{
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < GetData()->nDataLength);
    return m_pchData[nIndex];
}
_AFX_INLINE TCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < GetData()->nDataLength);
    return m_pchData[nIndex];
}
_AFX_INLINE bool AFXAPI operator==(const CString& s1, const CString& s2)
    { return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) == 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) != 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, const CString& s2)
    { return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, const CString& s2)
    { return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) < 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) <= 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\pmxe3.cpp ===
#include "stdafx.h"
#include "pmxe3.h"

#include "datadump.h"


CPMXE3::CPMXE3(PDEVCTRL pDeviceControl)
{
    m_pDeviceControl = pDeviceControl;
    m_scanmode       = scHalftone;
    InitializeRegisters();
}

CPMXE3::~CPMXE3()
{

}

VOID CPMXE3::InitializeRegisters()
{
    Register0 =0x00;
  //Register1 =0x5a;
  //Register2 =0x00;
    Register3 =0x0f;
    Register4 =0x32;
    Register5 =0x14;
    Register6 =0x95;
    Register7 =0x07;
    Register8 =0xd0;
    Register9 =0x0a;
    Register10=0x0f;
    Register11=0xa0;
    Register12=0x40;
    Register13=0x80;
  //Register14=0x00;
  //Register15=0x00;
  //Register16=0x00;
  //Register17=0x00;
  //Register18=0x00;
  //Register19=0x00;
    Register20=0x00;
    Register21=0x00;
    Register22=0x13;
    Register23=0xec;
  //Register24=0xff;
    Register25=0x14;
    Register26=0x18;
    Register27=0x11;
    Register28=0x2c;
    Register29=0x2c;
  //Register30=0x00;
    Register31=0x00;
  //Register32=0x00;
  //Register33=0x00;
  //Register34=0x00;
  //Register35=0x00;

#ifdef DEBUG
    Trace(TEXT("Register Dump - At InitRegisters() Call"));
    DebugDumpRegisters();
#endif

}

VOID CPMXE3::DebugDumpRegisters()
{
    //
    // dump Init registers initial values
    //

    WORD CarriageStep  = MAKEWORD(Register8,Register7);                         // 2000
    WORD ScanAreaStart = MAKEWORD(Register21,Register20);                       // 0
    WORD ScanAreaWidth = MAKEWORD(Register23,Register22);                       // 5100
    WORD XResolution   = MAKEWORD(Register28,((E3_REG27*)&Register27)->XRes);   // 300 dpi
    WORD YResolution   = MAKEWORD(Register29,((E3_REG27*)&Register27)->YRes);   // 300 dpi
    WORD TriggerPeriod = MAKEWORD(Register11,Register10);                       // 4000

    Trace(TEXT("- WORD constructed Register values -"));
    Trace(TEXT("Carriage Step: %d"),CarriageStep);
    Trace(TEXT("ScanAreaStart: %d"),ScanAreaStart);
    Trace(TEXT("ScanAreaWidth: %d"),ScanAreaWidth);
    Trace(TEXT("XResolution:   %d"),XResolution);
    Trace(TEXT("YResolution:   %d"),YResolution);
    Trace(TEXT("TriggerPeriod  %d"),TriggerPeriod);
    Trace(TEXT("------------------------------------"));

    E3_REG3*  pRegister3  = (E3_REG3*)&Register3;
    Trace(TEXT("- Register3 -"));
    Trace(TEXT("EppUsb      = %d"),pRegister3->EppUsb);
    Trace(TEXT("FifoReset   = %d"),pRegister3->FifoReset);
    Trace(TEXT("ScanSpeed   = %d"),pRegister3->ScanSpeed);
    Trace(TEXT("SelfTest    = %d"),pRegister3->SelfTest);
    Trace(TEXT("SystemReset = %d"),pRegister3->SystemReset);
    Trace(TEXT("WatchDog    = %d"),pRegister3->WatchDog);
    Trace(TEXT("----------------"));


    E3_REG4*  pRegister4  = (E3_REG4*)&Register4;
    Trace(TEXT("- Register4 -"));
    Trace(TEXT("AsicTest       = %d"),pRegister4->AsicTest);
    Trace(TEXT("Refresh        = %d"),pRegister4->Refresh);
    Trace(TEXT("RefreshForever = %d"),pRegister4->RefreshForever);
    Trace(TEXT("ScanMode       = %d"),pRegister4->ScanMode);
    Trace(TEXT("WaitDelay      = %d"),pRegister4->WaitDelay);
    Trace(TEXT("YTable         = %d"),pRegister4->YTable);
    Trace(TEXT("----------------"));

    E3_REG5*  pRegister5  = (E3_REG5*)&Register5;
    Trace(TEXT("- Register5 -"));
    Trace(TEXT("Adc1210    = %d"),pRegister5->Adc1210);
    Trace(TEXT("Afe        = %d"),pRegister5->Afe);
    Trace(TEXT("Sensor     = %d"),pRegister5->Sensor);
    Trace(TEXT("Sensor_Res = %d"),pRegister5->Sensor_Res);
    Trace(TEXT("----------------"));

    E3_REG6*  pRegister6  = (E3_REG6*)&Register6;
    Trace(TEXT("- Register6 -"));
    Trace(TEXT("FullHalf   = %d"),pRegister6->FullHalf);
    Trace(TEXT("LineOffset = %d"),pRegister6->LineOffset);
    Trace(TEXT("MotorPower = %d"),pRegister6->MotorPower);
    Trace(TEXT("Operation  = %d"),pRegister6->Operation);
    Trace(TEXT("----------------"));

    E3_REG12* pRegister12 = (E3_REG12*)&Register12;
    Trace(TEXT("- Register12 -"));
    Trace(TEXT("FifoEmpty  = %d"),pRegister12->FifoEmpty);
    Trace(TEXT("FinishFlag = %d"),pRegister12->FinishFlag);
    Trace(TEXT("HomeSensor = %d"),pRegister12->HomeSensor);
    Trace(TEXT("HwSelfTest = %d"),pRegister12->HwSelfTest);
    Trace(TEXT("Lamp       = %d"),pRegister12->Lamp);
    Trace(TEXT("MotorMove  = %d"),pRegister12->MotorMove);
    Trace(TEXT("MotorStop  = %d"),pRegister12->MotorStop);
    Trace(TEXT("ScanStatus = %d"),pRegister12->ScanStatus);
    Trace(TEXT("----------------"));


    E3_REG13* pRegister13 = (E3_REG13*)&Register13;
    Trace(TEXT("- Register13 -"));
    Trace(TEXT("Cs       = %d"),pRegister13->Cs);
    Trace(TEXT("Reserved = %d"),pRegister13->Reserved);
    Trace(TEXT("Sclk     = %d"),pRegister13->Sclk);
    Trace(TEXT("Sdi      = %d"),pRegister13->Sdi);
    Trace(TEXT("Sdo      = %d"),pRegister13->Sdo);
    Trace(TEXT("WmVsamp  = %d"),pRegister13->WmVsamp);
    Trace(TEXT("----------------"));


    E3_REG26* pRegister26 = (E3_REG26*)&Register26;
    Trace(TEXT("- Register26 -"));
    Trace(TEXT("Start = %d"),pRegister26->Start);
    Trace(TEXT("Stop  = %d"),pRegister26->Stop);
    Trace(TEXT("----------------"));

    E3_REG31* pRegister31 = (E3_REG31*)&Register31;
    Trace(TEXT("- Register31 -"));
    Trace(TEXT("Key0 = %d"),pRegister31->Key0);
    Trace(TEXT("Key1 = %d"),pRegister31->Key1);
    Trace(TEXT("Key2 = %d"),pRegister31->Key2);
    Trace(TEXT("Key3 = %d"),pRegister31->Key3);
    Trace(TEXT("Key4 = %d"),pRegister31->Key4);
    Trace(TEXT("Key5 = %d"),pRegister31->Key5);
    Trace(TEXT("Key6 = %d"),pRegister31->Key6);
    Trace(TEXT("Key7 = %d"),pRegister31->Key7);
    Trace(TEXT("----------------"));

    Trace(TEXT("--- END REGISTER DUMP ---"));
}

BOOL CPMXE3::WriteRegister(INT RegisterNumber, BYTE Value)
{

    DWORD    cbRet = 0;
    BOOL     bSuccess = FALSE;
    BYTE     pData[2];

    pData[0] = BYTE(RegisterNumber);
    pData[1] = Value;

    IO_BLOCK IoBlock;

    IoBlock.uOffset = (BYTE)IOCTL_EPP_WRITE;
    IoBlock.uLength = 2;
    IoBlock.pbyData = pData;

    bSuccess = DeviceIoControl(m_pDeviceControl->DeviceIOHandles[m_pDeviceControl->BulkInPipeIndex],
                               (DWORD) IOCTL_WRITE_REGISTERS,
                               &IoBlock,
                               sizeof(IO_BLOCK),
                               NULL,
                               0,
                               &cbRet,
                               NULL);

    return bSuccess;
}
BOOL CPMXE3::WriteRegisterEx(INT RegisterNumber, BYTE Value)
{
    BYTE pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    pbuffer[0] = CMD_WRITE;
    pbuffer[1] = (BYTE)RegisterNumber;
    pbuffer[2] = 0; // length: low byte
    pbuffer[3] = 1; // length: high byte
    pbuffer[4] = Value;

    return RawWrite(m_pDeviceControl->BulkInPipeIndex,
             pbuffer,
             64,
             0);
}

BOOL CPMXE3::ReadRegister(INT RegisterNumber, BYTE *pValue)
{
    DWORD    cbRet = 0;
    BOOL     bSuccess  = FALSE;
    IO_BLOCK IoBlock;

    IoBlock.uOffset = MAKEWORD(IOCTL_EPP_READ, (BYTE)RegisterNumber);
    IoBlock.uLength = 1;
    IoBlock.pbyData = pValue;

    bSuccess = DeviceIoControl(m_pDeviceControl->DeviceIOHandles[m_pDeviceControl->BulkOutPipeIndex],
                             (DWORD) IOCTL_READ_REGISTERS,
                             (PVOID)&IoBlock,
                             (DWORD)sizeof(IO_BLOCK),
                             (PVOID)pValue,
                             (DWORD)sizeof(BYTE),
                             &cbRet,
                             NULL);
    return bSuccess;
}

BOOL CPMXE3::ReadRegisterEx(INT RegisterNumber, BYTE *pValue)
{
    BYTE pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    pbuffer[0] = CMD_READ;
    pbuffer[1] = (BYTE)RegisterNumber;
    pbuffer[2] = 0; // length: low byte
    pbuffer[3] = 1; // length: high byte

    LONG BytesRead = 0;
    *pValue        = 0;

    if(!RawWrite(m_pDeviceControl->BulkInPipeIndex, pbuffer, 64, 0)){
        return FALSE;
    }
    if(!RawRead(m_pDeviceControl->BulkOutPipeIndex, pbuffer, 64, &BytesRead,0)){
        return FALSE;
    }

    *pValue = pbuffer[0];
    return TRUE;
}

BOOL CPMXE3::SetXRes(LONG xRes)
{
    m_xres = xRes;
    return TRUE;
}

BOOL CPMXE3::SetYRes(LONG yRes)
{
    m_yres = yRes;
    return TRUE;
}

BOOL CPMXE3::SetXPos(LONG xPos)
{
    m_xpos = xPos;
    return TRUE;
}

BOOL CPMXE3::SetYPos(LONG yPos)
{
    m_ypos = yPos;
    return TRUE;
}

BOOL CPMXE3::SetXExt(LONG xExt)
{
    m_xext = xExt;
    return TRUE;
}

BOOL CPMXE3::SetYExt(LONG yExt)
{
    m_yext = yExt;
    return TRUE;
}

BOOL CPMXE3::SetDataType(LONG DataType)
{
    m_datatype = DataType;
    switch (m_datatype) {
    case 0: // WIA_DATA_THRESHOLD
        m_scanmode = scHalftone;
        break;
    case 1: // WIA_DATA_GRAYSCALE
        m_scanmode = scGrayScale;
        break;
    case 2: // WIA_DATA_COLOR
        m_scanmode = scFullColor;
        break;
    default:
        return FALSE;
        break;
    }

    return TRUE;
}

///////////////////////
//                   //
// DEVICE OPERATIONS //
//                   //
///////////////////////


BOOL CPMXE3::Lamp(BOOL bON)
{
    if(!ReadRegister(12,&Register12))
        return FALSE;

    if(bON)    // lamp ON
        ((E3_REG12*)&Register12)->Lamp = 1;
    else    // lamp OFF
        ((E3_REG12*)&Register12)->Lamp = 0;

    if(!WriteRegister(12,Register12))
        return FALSE;
    return TRUE;
}

BOOL CPMXE3::IsLampON()
{
    if(!ReadRegister(12,&Register12))
            return FALSE;

    if (((E3_REG12*)&Register12)->Lamp == 1)
        return TRUE;

    return FALSE;
}

BOOL CPMXE3::Motor(BOOL bON)
{
    if(!ReadRegister(6,&Register6))
        return FALSE;

    if(bON){    // Turn Motor ON
        ((E3_REG6*)&Register6)->MotorPower = 1;
    } else {    // Turn Motor OFF
        ((E3_REG6*)&Register6)->MotorPower = 0;
    }

    if(!WriteRegister(6,Register6))
            return FALSE;
    return TRUE;
}

BOOL CPMXE3::HomeCarriage()
{

    StopScan(); // must issue a STOP before homing carriage...or the device makes
                // a rather nasty grinding noise...("That can't be good.." -Cooper Partin, May 19,2000)

    INT TriggerPeriod    = 0;
    INT ScanSpeed        = 7;
    INT OverCLK          = 2;     // perfect for E3 series models
    INT ExposureTimeMin  = 2000;  // 2 seconds exposure time
    INT ExposureTime     = 12000; // possible choices, (13800,5610,11400,12000)

    //
    // calculate TriggerPeriod
    //

    if((ExposureTime / ( ScanSpeed + 1 ) ) * OverCLK < ExposureTimeMin * OverCLK)
        TriggerPeriod = (INT)(ExposureTimeMin * OverCLK);
    else
        TriggerPeriod = (INT)((ExposureTime / ( ScanSpeed + 1 ) ) * OverCLK);


    Register25 = 0x14;

    if(!WriteRegister(25,Register25))
        return FALSE;

    if(!SetMotorSpeed(TriggerPeriod,ScanSpeed))
        return FALSE;

    if(!ReadRegister(6,&Register6))
        return FALSE;

    if(!StopMode())
        return FALSE;

    ((E3_REG6*)&Register6)->MotorPower = 1; // motor ON
    ((E3_REG6*)&Register6)->Operation  = 5; // auto home

    if(!WriteRegister(6,Register6))
        return FALSE;

    //
    // Prevent any operations until scanner is in HOME position...
    // If any operations are done... could result in nasty noises
    // and system hangs... :) (just like forcing a car into reverse, while
    // driving down the freeway...)
    //

    while(!IsCarriageHOME()) {
        Sleep(100);
    }

    return TRUE;
}

BOOL CPMXE3::StopMode()
{
    ((E3_REG6*)&Register6)->Operation = 0;
    return WriteRegister(6,Register6);
}

BOOL CPMXE3::WriteStopImageRegister()
{
    BYTE pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    pbuffer[0] = CMD_STOPIMAGE;

    return RawWrite(m_pDeviceControl->BulkInPipeIndex,
             pbuffer,
             64,
             0);
}

BOOL CPMXE3::StopScan()
{

    if(!WriteStopImageRegister())
        return FALSE;

    if(!ReadRegister(6,&Register6))
        return FALSE;

    ((E3_REG6*)&Register6)->MotorPower = 0;
    ((E3_REG6*)&Register6)->Operation  = 0;

    if(!WriteRegister(6,Register6))
        return FALSE;

    ((E3_REG13*)&Register13)->Sdo  = 0;
    ((E3_REG13*)&Register13)->Sclk = 0;
    if(!WriteRegister(13,Register13))
        return FALSE;

    Register25 = 0x14;
    if(!WriteRegister(25,Register25))
        return FALSE;


    return TRUE;
}

BOOL CPMXE3::SetMotorSpeed(INT TriggerPeriod, INT ScanSpeed)
{
    //
    // set trigger period
    //

    Register10 = HIBYTE(TriggerPeriod/2);
    Register11 = LOBYTE(TriggerPeriod/2);
    if(!WriteRegister(10,Register10))
        return FALSE;
    if(!WriteRegister(11,Register11))
        return FALSE;

    //
    // set scan speed
    //

    // Register3 = 0;
    if(!ReadRegister(3,&Register3))
        return FALSE;

    ((E3_REG3*)&Register3)->ScanSpeed = ScanSpeed;
    if(!WriteRegister(3,Register3))
        return FALSE;

    //
    // initialize motor
    //

    // Register6 = 0;

    ((E3_REG6*)&Register6)->MotorPower = 1;
    ((E3_REG6*)&Register6)->FullHalf   = 1;
    ((E3_REG6*)&Register6)->Operation  = 0;
    if(!WriteRegister(6,Register6))
        return FALSE;

    return TRUE;
}

BOOL CPMXE3::MoveCarriage(BOOL bForward, INT Steps)
{
    INT TriggerPeriod    = 0;
    INT ScanSpeed        = 7;     // perfect for E3 series models
    INT OverCLK          = 2;     // perfect for E3 series models
    INT ExposureTimeMin  = 2000;  // 2 seconds exposure time
    INT ExposureTime     = 12000; // possible choices, (13800,5610,11400,12000)

    //
    // calculate TriggerPeriod
    //

    if((ExposureTime / ( ScanSpeed + 1 ) ) * OverCLK < ExposureTimeMin * OverCLK)
        TriggerPeriod = (INT)(ExposureTimeMin * OverCLK);
    else
        TriggerPeriod = (INT)((ExposureTime / ( ScanSpeed + 1 ) ) * OverCLK);

    if(!SetMotorSpeed(TriggerPeriod,ScanSpeed))
        return FALSE;

    Register7 = HIBYTE(Steps*2);  // high byte (move step)
    Register8 = LOBYTE(Steps*2);  // low byte (move step)

    if(!WriteRegister(7,Register7))
        return FALSE;
    if(!WriteRegister(8,Register8))
        return FALSE;

    if(!StopMode())
        return FALSE;

    if(!ReadRegister(6,&Register6))
        return FALSE;

    ((E3_REG6*)&Register6)->MotorPower = 1;

    if(bForward)    // move forward
        ((E3_REG6*)&Register6)->Operation  = 2;
    else            // move backward
        ((E3_REG6*)&Register6)->Operation  = 3;

    if(!WriteRegister(6,Register6))
        return FALSE;

    return TRUE;
}

BOOL CPMXE3::IsCarriageHOME()
{
    ReadRegister(12,&Register12);
    if((Register12&CARRIAGE_HOME) != CARRIAGE_HOME)
        return FALSE;
    return TRUE;
}

BOOL CPMXE3::IsMotorBusy()
{
    ReadRegister(12,&Register12);
    if((Register12&MOTOR_BUSY) != MOTOR_BUSY)
        return TRUE;
    return FALSE;
}

INT CPMXE3::GetScanSpeed()
{
    //
    // return a preferred scan speed, with respect to
    // the current y resolution.
    //

    if (m_yres>300)
        return 0;
    else if(m_yres>200)
        return 1;
    else if(m_yres>150)
        return 2;
    else if(m_yres>100)
        return 3;
    else if(m_yres>75)
        return 5;
    else if(m_yres>0)
        return 7;

    return 0;
}

BOOL CPMXE3::SetXandYResolution()
{
    //
    // X and Y resolution have to be set at the same time..
    //

    if(!ReadRegister(27,&Register27)){
        return FALSE;
    }

    if(!ReadRegister(28,&Register28)){
        return FALSE;
    }

    if(!ReadRegister(29,&Register29)){
        return FALSE;
    }

    ((E3_REG27*)&Register27)->XRes = HIBYTE(m_xres);
    ((E3_REG28*)&Register28)->XRes = LOBYTE(m_xres);

    ((E3_REG27*)&Register27)->YRes = HIBYTE(m_yres);
    ((E3_REG29*)&Register29)->YRes = LOBYTE(m_yres);

    if(!WriteRegister(27,Register27)){
        return FALSE;
    }

    if(!WriteRegister(28,Register28)){
        return FALSE;
    }

    if(!WriteRegister(29,Register29)){
        return FALSE;
    }

    return TRUE;
}

BOOL CPMXE3::SetScanWindow()
{
    //
    // set all three (xpos,ypos,xext,and current yext)
    // at this point..
    //

    if(!ReadRegister(7,&Register7))
        return FALSE;

    if(!ReadRegister(8,&Register8))
        return FALSE;

    if(!ReadRegister(20,&Register20))
        return FALSE;

    if(!ReadRegister(21,&Register21))
        return FALSE;

    if(!ReadRegister(22,&Register22))
        return FALSE;

    if(!ReadRegister(23,&Register23))
        return FALSE;

    if(!ReadRegister(26,&Register26))
        return FALSE;

    if(!ReadRegister(4,&Register4))
        return FALSE;

    LONG AreaStart       = m_xpos;
    LONG AreaStartOffset = 146; //180;

    AreaStart = (AreaStart * (600/*Hardware DPI*// m_xres));
    AreaStart += AreaStartOffset;

    ((E3_REG20*)&Register20)->AreaStart = HIBYTE(AreaStart);
    ((E3_REG21*)&Register21)->AreaStart = LOBYTE(AreaStart);

    if(!WriteRegister(20,Register20))
        return FALSE;
    if(!WriteRegister(21,Register21))
        return FALSE;

    ((E3_REG22*)&Register22)->AreaWidth = HIBYTE(m_xext);
    ((E3_REG23*)&Register23)->AreaWidth = LOBYTE(m_xext);

    if(!WriteRegister(22,Register22))
        return FALSE;

    if(!WriteRegister(23,Register23))
        return FALSE;

    if(!WriteRegister(27,Register27))
        return FALSE;

    if(!WriteRegister(28,Register28))
        return FALSE;

    if(!WriteRegister(29,Register29))
        return FALSE;

    LONG Length     = 0;
    LONG CutLine    = 2;
    LONG LineOffset = 0;

    Length = (LONG)(((m_yext + 1 + CutLine) * 600) + (m_yres - 1)) / m_yres;
    Length += ((GetScanSpeed()+1)*(LineOffset + 1) * 2);
    //Length = 6620;

    Trace(TEXT("Caculated Length for Motor stepping.. = %d (6620?)"),Length);
    Trace(TEXT("ScanSpeed used.. = %d"),GetScanSpeed());

    Register7 = HIBYTE(Length);
    Register8 = LOBYTE(Length);

    if(!WriteRegister(7,Register7))
        return FALSE;

    if(!WriteRegister(8,Register8))
        return FALSE;

    ((E3_REG26*)&Register26)->Stop = 0x08;
    ((E3_REG26*)&Register26)->Start = (BYTE)1;

    if(!WriteRegister(26,Register26))
        return FALSE;

    ((E3_REG4*)&Register4)->WaitDelay = 1; // USB models

    if(!WriteRegister(4,Register4))
        return FALSE;
    return TRUE;
}

VOID CPMXE3::GrayScaleToThreshold(LPBYTE lpSrc, LPBYTE lpDst, LONG RowBytes)
{
    //
    // code is borrowed from Visioneer scanner driver
    // could be optimized.
    //

    BYTE val      = 0;
    BYTE nValueBW = 0;
    INT  nCount1  = 0;
    INT  nCount   = 0;
    INT  LineArtThreshold = 110;

    for(nCount = 0, nCount1 = 0, nValueBW = 0;nCount < RowBytes; nCount++) {
        val = *(lpSrc + nCount);

        if(val > LineArtThreshold)
            nValueBW |= 1;

        if((nCount & 7)==7) {
            *(lpDst+nCount1) = nValueBW;
            nValueBW=0;
            nCount1++;
        } else
            nValueBW = nValueBW << 1;
    }

    if((nCount&7)!=0) {
        nValueBW=nValueBW << ( 8 - (nCount & 7));
        *(lpDst + nCount1) = nValueBW;
    }
}


BOOL CPMXE3::GetButtonStatus(PBYTE pButtons)
{
    //
    // button status for 5 button scanners only
    //
    // this may need to be rewritten using E3_REG31
    // which has Key values.
    //

    Register31 = 0;
    INT ButtonMask  = 1;

    if(!ReadRegister(31,&Register31))
        return FALSE;

    for(INT index = 0; index < 5 ; index++){
        if(Register31&ButtonMask)
            pButtons[index] = 1;
        else
            pButtons[index] = 0;
        ButtonMask<<=1;
    }

    if(Register31&0x01)
        pButtons[6] = 1;

    return TRUE;
}

BOOL CPMXE3::ClearButtonPress()
{
    Register31 = 0;
    if(!WriteRegister(31,Register31))
        return FALSE;
    return TRUE;
}

BOOL CPMXE3::WakeupScanner()
{
    //
    // turn on lamp
    // and turn on motor power
    //

    if(!Lamp(TRUE))
        return FALSE;
    return Motor(TRUE);
}

BOOL CPMXE3::SleepScanner()
{
    //
    // turn off the lamp
    // and turn of the motor power
    //

    if(!Lamp(FALSE))
        return FALSE;
    return Motor(FALSE);
}

BOOL CPMXE3::StartScan()
{
    if(!ResetFIFO())
        return FALSE;

    if(!Lamp(TRUE))
        return FALSE;

    // DownLoadLUT ??

    if(!SetXandYResolution())
        return FALSE;

    //
    // settings commit is done at scan time
    //

    if(!SetScanWindow())
        return FALSE;

    if(!ReadRegister(13,&Register13))
        return FALSE;

    ((E3_REG13*)&Register13)->Sdo  = 0;
    ((E3_REG13*)&Register13)->Sclk = 1;

    if(!WriteRegister(13,Register13))
        return FALSE;

    if(!ReadRegister(6,&Register6))
        return FALSE;

    if(!ReadRegister(9,&Register9))
        return FALSE;

    if(!ReadRegister(27,&Register27))
        return FALSE;

    ((E3_REG6*)&Register6)->LineOffset = 1;

    if(!WriteRegister(6,Register6))
        return FALSE;

    ((E3_REG4*)&Register4)->ScanMode = m_scanmode; // changes for data type
    ((E3_REG4*)&Register4)->YTable   = 1;

    if(!WriteRegister(4,Register4))
        return FALSE;

    ((E3_REG27*)&Register27)->True16Bits  = 0;
    ((E3_REG27*)&Register27)->AutoPattern = 0;

    if(!WriteRegister(27,Register27))
        return FALSE;

    INT TriggerPeriod = 5700;

    Register10 = HIBYTE(TriggerPeriod);
    Register11 = LOBYTE(TriggerPeriod);

    if(!WriteRegister(10,Register10))
        return FALSE;

    if(!WriteRegister(11,Register11))
        return FALSE;

    ((E3_REG3*)&Register3)->ScanSpeed = GetScanSpeed();

    if(!WriteRegister(3,Register3))
        return FALSE;

    ((E3_REG6*)&Register6)->FullHalf  = 0;
    ((E3_REG6*)&Register6)->Operation = 0;

    if(!WriteRegister(6,Register6))
        return FALSE;

    Register9 = (BYTE)10;   // backstep

    if(!WriteRegister(9,Register9))
        return FALSE;

    ((E3_REG6*)&Register6)->Operation = 0;

    if(!WriteRegister(6,Register6))
        return FALSE;

    ((E3_REG6*)&Register6)->MotorPower = 1;
    ((E3_REG6*)&Register6)->Operation  = 4; // scan

    if(!WriteRegister(6,Register6))
        return FALSE;

    // clear buttons
    if(!ClearButtonPress())
        return FALSE;

    Register25 = 0x10;  // GIO?
    if(!WriteRegister(25,Register25))
        return FALSE;

    return TRUE;
}

BOOL CPMXE3::ResetFIFO()
{
    for(INT nResetTimes = 0; nResetTimes < 2;nResetTimes++){

        StopMode();

        if(!ReadRegister(3,&Register3))
            return FALSE;

        ((E3_REG3*)&Register3)->FifoReset = 0;
        if(!WriteRegister(3,Register3))
            return FALSE;

        ((E3_REG3*)&Register3)->FifoReset = 1;
        if(!WriteRegister(3,Register3))
            return FALSE;
    }
    return TRUE;
}

BOOL CPMXE3::InitADC()
{
    if(!ReadRegister(5,&Register5))
        return FALSE;

    ((E3_REG5*)&Register5)->Adc1210    = 1;
    ((E3_REG5*)&Register5)->Afe        = 0;
    ((E3_REG5*)&Register5)->Sensor_Res = 1; // 600dpi model
    ((E3_REG5*)&Register5)->Sensor     = 0x02;

    if(!WriteRegister(5,Register5))
        return FALSE;

    Register25 = 0x14;

    if(!WriteRegister(25,Register25))
        return FALSE;

    if(!ClearButtonPress())
        return FALSE;

    /*

    BYTE RDark = 0x000000be;
    BYTE GDark = 0x000000be;
    BYTE BDark = 0x000000be;

    E3_WriteWm(1,0x03);
    E3_WriteWm(2,0x04);
    E3_WriteWm(3,0x22);
    E3_WriteWm(5,0x12);
    E3_WriteWm(0x20,(unsigned char)gRDark);    //Red channel Dark Value
    E3_WriteWm(0x21,(unsigned char)gGDark);    //Green channel Dark Value
    E3_WriteWm(0x22,(unsigned char)gBDark);    //Blue channel Dark Value
    E3_WriteWm(0x27,0x00);
    E3_WriteWm(0x2b,0x02);  //global Gain Value

    */

    ((E3_REG13*)&Register13)->WmVsamp = 1;

    if(!WriteRegister(13,Register13))
        return FALSE;
    return TRUE;
}

BOOL CPMXE3::Scan()
{

    //
    // check carriage position (needs to be in HOME, for a proper scan)
    //

    if (!IsCarriageHOME()) {
        if (!HomeCarriage())
            return FALSE;
    }

    if(!StopMode())
        return FALSE;

    if(!InitADC())
        return FALSE;

    if(!MoveCarriage(TRUE,CALIBRATION_STEPSIZE)) // calibration offset position
        return FALSE;

    if(!MoveCarriage(TRUE,SCAN_STARTPOS_STEPSIZE)) // scan start position
        return FALSE;

    if(!StopMode())
        return FALSE;

    if(!StartScan())
        return FALSE;

    LONG  lBytesRead        = 1;
    DWORD dwTotalImageSize  = 0;
    DWORD dwbpp             = 0;
    DWORD BytesPerLine      = 0;

    switch(m_datatype){
    case 0:
        dwbpp               = 1;
        BytesPerLine        = ((m_xext +7)/8);
        dwTotalImageSize    = (BytesPerLine * m_yext);
        break;
    case 1:
        dwbpp               = 8;
        BytesPerLine        = m_xext;
        dwTotalImageSize    = (m_xext * m_yext);
        break;
    case 2:
        dwbpp               = 24;
        BytesPerLine        = (m_xext * 3);
        dwTotalImageSize    = ((m_xext * m_yext) * 3);
        break;
    default:
        return FALSE;
        break;
    }

    //
    // setup data dumper, so we can see if the image needs
    // work.
    //

    DATA_DESCRIPTION DataDesc;

    DataDesc.dwbpp      = dwbpp;
    DataDesc.dwDataSize = dwTotalImageSize;
    DataDesc.dwHeight   = m_yext;
    DataDesc.dwWidth    = m_xext;
    DataDesc.pRawData   = (PBYTE)LocalAlloc(LPTR,DataDesc.dwDataSize + 1024);

    PBYTE pbuffer = DataDesc.pRawData;
    Trace(TEXT("Total bytes to Read: = %d"),dwTotalImageSize);
    Trace(TEXT("Data BYTES PER LINE  = %d"),BytesPerLine);

    LONG  NumLinesToRead    = (65535)/BytesPerLine;
    DWORD dwImageDataRead   = 0;
    DWORD dwTotalLinesRead  = 0;
    DWORD dwTotalBytesRead  = 0;

    while (dwImageDataRead < dwTotalImageSize) {

        //
        // Send request for chunk
        //

        /*
        BYTE pRegisters[64];
        memset(pRegisters,0,sizeof(pRegisters));

        pRegisters[0] = CMD_GETIMAGE;
        pRegisters[1] = (BYTE)NumLinesToRead; // 255 or less
        pRegisters[2] = HIBYTE(BytesPerLine);
        pRegisters[3] = LOBYTE(BytesPerLine);

        if (!RawWrite(m_pDeviceControl->BulkInPipeIndex,pRegisters,64,0))
            return FALSE;
        */

        DWORD             cbRet = 0;
        BOOL              bSuccess  = FALSE;
        IO_BLOCK          IoBlock;
        BYTE      Command[8];
        Command[0] = 0;
        Command[1] = 0xc;
        Command[2] = 128;
        Command[3] = 0;
        Command[4] = LOBYTE(BytesPerLine);
        Command[5] = HIBYTE(BytesPerLine);
        Command[6] = LOBYTE(NumLinesToRead);
        Command[7] = HIBYTE(NumLinesToRead);

        IoBlock.uOffset = (BYTE)IOCTL_READ_WRITE_DATA;
        IoBlock.uLength = (BYTE)8;
        IoBlock.pbyData = Command;

        Trace(TEXT("Issuing DeviceIOControl() call request for more data..."));

        bSuccess = DeviceIoControl(m_pDeviceControl->DeviceIOHandles[m_pDeviceControl->BulkInPipeIndex],
                               (DWORD) IOCTL_WRITE_REGISTERS,
                               &IoBlock,
                               sizeof(IO_BLOCK),
                               NULL,
                               0,
                               &cbRet,
                               NULL);

        //
        // read scanned data until requested chunk is recieved
        //

        LONG LinesRead = 0;
        lBytesRead = 0;

        Trace(TEXT("Requesting %d BYTES from device"),(BytesPerLine * NumLinesToRead));
        if (!RawRead(m_pDeviceControl->BulkOutPipeIndex,pbuffer,(BytesPerLine * NumLinesToRead),&lBytesRead,0)) {
            MessageBox(NULL,TEXT("Reading data band failed"),TEXT(""),MB_OK);
            return FALSE;
        }

        dwTotalBytesRead += lBytesRead;
        pbuffer          += lBytesRead;
        dwTotalLinesRead += (lBytesRead/BytesPerLine);

        if((m_yext - dwTotalLinesRead) < (DWORD)NumLinesToRead){
            NumLinesToRead = (m_yext - dwTotalLinesRead);
        }

        Trace(TEXT("Total Lines Read %d of %d"),dwTotalLinesRead,m_yext);

        if (lBytesRead == 0) {
            MessageBox(NULL,TEXT("No data returned from Read call"),TEXT(""),MB_OK);
            return FALSE;
        }

        Trace(TEXT("Recieved %d BYTES from device"),lBytesRead);

        //
        // increment buffers/counters
        //

        Sleep(400);
        dwImageDataRead += dwTotalBytesRead;
        dwTotalBytesRead = 0;
        Trace(TEXT("Total Bytes Read So Far: = %d"),dwImageDataRead);
    }

    StopScan();
    HomeCarriage();

    CDATADUMP Data;
    Data.DumpDataToBitmap(TEXT("PMXE3.BMP"),&DataDesc);

    if(NULL != DataDesc.pRawData)
        LocalFree(DataDesc.pRawData);

    return TRUE;
}

BOOL CPMXE3::RawWrite(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG lTimeout)
{
    DWORD dwBytesWritten = 0;
    BOOL  bSuccess = TRUE;
    OVERLAPPED  Overlapped;
    memset(&Overlapped,0,sizeof(OVERLAPPED));

    bSuccess = WriteFile(m_pDeviceControl->DeviceIOHandles[lPipeNum],
                     pbuffer,
                     lbuffersize,
                     &dwBytesWritten,
                     &Overlapped);
    if(dwBytesWritten < (ULONG)lbuffersize)
        return FALSE;
    return bSuccess;
}

BOOL CPMXE3::RawRead(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout)
{
    DWORD dwBytesRead = 0;
    OVERLAPPED  Overlapped;
    memset(&Overlapped,0,sizeof(OVERLAPPED));

    BOOL bSuccess = ReadFile(m_pDeviceControl->DeviceIOHandles[lPipeNum],
                    pbuffer,
                    lbuffersize,
                    &dwBytesRead,
                    &Overlapped);
    *plbytesread = dwBytesRead;
    return bSuccess;
}

VOID CPMXE3::Trace(LPCTSTR format,...)
{

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\devctrldlg.h ===
// devctrlDlg.h : header file
//

#if !defined(AFX_DEVCTRLDLG_H__4D791BBD_82C5_45B4_8F6D_0BE962C80FD1__INCLUDED_)
#define AFX_DEVCTRLDLG_H__4D791BBD_82C5_45B4_8F6D_0BE962C80FD1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Configdlg.h"
#include "devctrldefs.h"
#include "cregistry.h"
#include "hpscl.h"
#include "pmxe3.h"

#define DEVCTRL_APP_KEY TEXT("Software\\Microsoft\\WIA\\Tools\\devctrl")

//
// put new scanner models here
//

#define HP_SCL_SCANNER          0
#define VISIONEER_E3_SCANNER    1

/////////////////////////////////////////////////////////////////////////////
// CDevctrlDlg dialog

class CDevctrlDlg : public CDialog
{
// Construction
public:
    void ReadRegistryValues();
    void WriteRegistryValues();
    void CloseAllHandles();
    void InitDefaultSettings();
    BOOL WriteScannerSettings();
    CDevctrlDlg(CWnd* pParent = NULL);  // standard constructor

    DEVCTRL m_DeviceControl;
    CRegistry * m_pRegistry;
    CString m_Pipe1;
    CString m_Pipe2;
    CString m_Pipe3;

    LONG m_datatype;
    LONG m_device;

    CHPSCL* m_phpscl;
    CPMXE3* m_pprimaxE3;

// Dialog Data
    //{{AFX_DATA(CDevctrlDlg)
    enum { IDD = IDD_DEVCTRL_DIALOG };
    CButton m_CreateButton;
    CComboBox   m_DataTypeCombobox;
    CComboBox   m_DeviceCombobox;
    long    m_xres;
    long    m_yres;
    long    m_xpos;
    long    m_ypos;
    long    m_xext;
    long    m_yext;
    CString m_CreateFileName;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDevctrlDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CDevctrlDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnWriteSettingsButton();
    afx_msg void OnScanButton();
    afx_msg void OnAbortScanButton();
    afx_msg void OnConfigureButton();
    afx_msg void OnCreateButton();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEVCTRLDLG_H__4D791BBD_82C5_45B4_8F6D_0BE962C80FD1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\hpscl.cpp ===
#include "stdafx.h"
#include "hpscl.h"
#include "datadump.h"

CHPSCL::CHPSCL(PDEVCTRL pDeviceControl)
{
    m_pDeviceControl = pDeviceControl;
}

CHPSCL::~CHPSCL()
{

}

BOOL CHPSCL::SetXRes(LONG xRes)
{
    m_xres = xRes;
    CHAR pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    sprintf(pbuffer,"\x1B*a%dR",xRes);
    return RawWrite(m_pDeviceControl->BulkInPipeIndex,(PBYTE)pbuffer,lstrlenA(pbuffer),0);
}

BOOL CHPSCL::SetYRes(LONG yRes)
{
    m_yres = yRes;
    CHAR pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    sprintf(pbuffer,"\x1B*a%dS",yRes);
    return RawWrite(m_pDeviceControl->BulkInPipeIndex,(PBYTE)pbuffer,lstrlenA(pbuffer),0);
}

BOOL CHPSCL::SetXPos(LONG xPos)
{
    m_xpos = xPos;
    CHAR pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    LONG OpticalValue = xPos;
    OpticalValue = ((OpticalValue * 300) / m_xres);
    sprintf(pbuffer,"\x1B*f%dX",OpticalValue);
    return RawWrite(m_pDeviceControl->BulkInPipeIndex,(PBYTE)pbuffer,lstrlenA(pbuffer),0);
}

BOOL CHPSCL::SetYPos(LONG yPos)
{
    m_ypos = yPos;
    CHAR pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    LONG OpticalValue = yPos;
    OpticalValue = ((OpticalValue * 300) / m_yres);
    sprintf(pbuffer,"\x1B*f%dY",OpticalValue);
    return RawWrite(m_pDeviceControl->BulkInPipeIndex,(PBYTE)pbuffer,lstrlenA(pbuffer),0);
}

BOOL CHPSCL::SetXExt(LONG xExt)
{
    m_xext = xExt;
    CHAR pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    LONG OpticalValue = xExt;
    OpticalValue = ((OpticalValue * 300) / m_xres);
    sprintf(pbuffer,"\x1B*f%dP",OpticalValue);
    return RawWrite(m_pDeviceControl->BulkInPipeIndex,(PBYTE)pbuffer,lstrlenA(pbuffer),0);
}

BOOL CHPSCL::SetYExt(LONG yExt)
{
    m_yext = yExt;
    CHAR pbuffer[64];
    memset(pbuffer,0,sizeof(pbuffer));
    LONG OpticalValue = yExt;
    OpticalValue = ((OpticalValue * 300) / m_yres);
    sprintf(pbuffer,"\x1B*f%dQ",OpticalValue);
    return RawWrite(m_pDeviceControl->BulkInPipeIndex,(PBYTE)pbuffer,lstrlenA(pbuffer),0);
}

BOOL CHPSCL::SetDataType(LONG DataType)
{
    m_datatype = DataType;
    BOOL bSuccess = TRUE;
    switch(m_datatype){
    case 0: // WIA_DATA_THRESHOLD
        bSuccess = RawWrite(m_pDeviceControl->BulkInPipeIndex,
                            (PBYTE)"\x1B*a0T",5,0);
        if(bSuccess){
            return RawWrite(m_pDeviceControl->BulkInPipeIndex,
                            (PBYTE)"\x1B*a1G",5,0);
        }
            break;
    case 1: // WIA_DATA_GRAYSCALE
        bSuccess = RawWrite(m_pDeviceControl->BulkInPipeIndex,
                            (PBYTE)"\x1B*a4T",5,0);
        if(bSuccess){
            return RawWrite(m_pDeviceControl->BulkInPipeIndex,
                            (PBYTE)"\x1B*a8G",5,0);
        }
            break;
    case 2: // WIA_DATA_COLOR
        bSuccess = RawWrite(m_pDeviceControl->BulkInPipeIndex,
                            (PBYTE)"\x1B*a5T",5,0);
        if(bSuccess){
            return RawWrite(m_pDeviceControl->BulkInPipeIndex,
                            (PBYTE)"\x1B*a24G",6,0);
        }
            break;
    default:
        break;
    }
        return FALSE;
}

BOOL CHPSCL::Scan()
{
    LONG  lBytesRead        = 1;
    DWORD dwTotalImageSize  = 0;
    DWORD dwbpp             = 0;
    DWORD BytesPerLine      = 0;

    switch(m_datatype){
    case 0:
        dwbpp               = 1;
        BytesPerLine        = ((m_xext +7)/8);
        dwTotalImageSize    = (BytesPerLine * m_yext);
        break;
    case 1:
        dwbpp               = 8;
        BytesPerLine        = m_xext;
        dwTotalImageSize    = (m_xext * m_yext);
        break;
    case 2:
        dwbpp               = 24;
        BytesPerLine        = (m_xext * 3);
        dwTotalImageSize    = ((m_xext * m_yext) * 3);
        break;
    default:
        return FALSE;
        break;
    }

    //
    // setup data dumper, so we can see if the image needs
    // work.
    //

    DATA_DESCRIPTION DataDesc;

    DataDesc.dwbpp      = dwbpp;
    DataDesc.dwDataSize = dwTotalImageSize;
    DataDesc.dwHeight   = m_yext;
    DataDesc.dwWidth    = m_xext;
    DataDesc.pRawData   = (PBYTE)LocalAlloc(LPTR,DataDesc.dwDataSize + 1024);

    PBYTE pbuffer = DataDesc.pRawData;
    Trace(TEXT("Total bytes to Read: = %d"),dwTotalImageSize);

    //
    // start scan
    //

    if(!RawWrite(m_pDeviceControl->BulkInPipeIndex,(PBYTE)"\x1B*f0S",5,0)){
        MessageBox(NULL,TEXT("Starting Scan failed.."),TEXT(""),MB_OK);
        return FALSE;
    }

    //
    // read scanned data
    //

    if(!RawRead(m_pDeviceControl->BulkOutPipeIndex,pbuffer,(dwTotalImageSize),&lBytesRead,0)){
        MessageBox(NULL,TEXT("Reading first band failed"),TEXT(""),MB_OK);
        return FALSE;
    }

    Trace(TEXT("Total Bytes Read: = %d"),lBytesRead);

    /*
    pbuffer+=lBytesRead;
    dwTotalImageSize -=lBytesRead;
    Trace(TEXT("Bytes left to read: = %d"),dwTotalImageSize);

    while(dwTotalImageSize > 0){

        lBytesRead = 0;

        //
        // read scanned data (continued..)
        //

        if(!RawRead(m_pDeviceControl->BulkOutPipeIndex,pbuffer,(dwTotalImageSize),&lBytesRead,0)){
            MessageBox(NULL,TEXT("Reading band failed"),TEXT(""),MB_OK);
            dwTotalImageSize = 0;
        }

        pbuffer+=lBytesRead;
        dwTotalImageSize -=lBytesRead;
        Trace(TEXT("Bytes left to read: = %d"),dwTotalImageSize);
    }
    */

    CDATADUMP Data;
    Data.DumpDataToBitmap(TEXT("HPSCL.BMP"),&DataDesc);

    if(NULL != DataDesc.pRawData)
        LocalFree(DataDesc.pRawData);

    return TRUE;
}

BOOL CHPSCL::RawWrite(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG lTimeout)
{
    DWORD dwBytesWritten = 0;
    BOOL  bSuccess = TRUE;
    bSuccess = WriteFile(m_pDeviceControl->DeviceIOHandles[lPipeNum],
                     pbuffer,
                     lbuffersize,
                     &dwBytesWritten,
                     NULL);
    if(dwBytesWritten < (ULONG)lbuffersize)
        return FALSE;
    return bSuccess;
}

BOOL CHPSCL::RawRead(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout)
{
    DWORD dwBytesRead = 0;
    BOOL bSuccess = ReadFile(m_pDeviceControl->DeviceIOHandles[lPipeNum],
                    pbuffer,
                    lbuffersize,
                    &dwBytesRead,
                    NULL);
    *plbytesread = dwBytesRead;

    return bSuccess;
}

VOID CHPSCL::Trace(LPCTSTR format,...)
{

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\pmxe3.h ===
#ifndef _PMXE3_H
#define _PMXE3_H

#include "devio.h"

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Notes:
//
// To control the Visioneer scanners, you need to create two handles. One is the standard
// CreateFile handle, (\\.\USBSCAN0), and the other is a "\2" added value. (ex. \\.\USBSCAN0\2)
// All reading of values and data is done with "\\.\USBSCAN0\2", and writing values is done with
// "\\.\USBSCAN0".
//
//////////////////////////////////////////////////////////////////////////////////////////////////

//
// common defines
//

//////////////////////////////////////////
// Taken from NTDDK.H                   //
//////////////////////////////////////////

#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//////////////////////////////////////////
// Taken from USBSCAN.H                 //
//////////////////////////////////////////

#define FILE_DEVICE_USB_SCAN    0x8000
#define IOCTL_INDEX             0x0800

#define IOCTL_GET_VERSION               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX,   METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CANCEL_IO                 CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+1, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WAIT_ON_DEVICE_EVENT      CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+2, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_READ_REGISTERS            CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+3, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WRITE_REGISTERS           CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+4, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CHANNEL_ALIGN_RQST    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+5, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_DEVICE_DESCRIPTOR     CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+6, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RESET_PIPE                CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+7, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_USB_DESCRIPTOR        CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+8, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SEND_USB_REQUEST          CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+9, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_PIPE_CONFIGURATION    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+10,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _IO_BLOCK {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;
} IO_BLOCK, *PIO_BLOCK;

///////////////////////////////////////////

#define IOCTL_GET_DEVICE_INFO   0x0
#define IOCTL_GET_DEVICE_STATUS 0x1
#define IOCTL_READ_WRITE_DATA   0x82
#define IOCTL_EPP_ADDR          0x83
#define IOCTL_EPP_READ          0x84
#define IOCTL_EPP_WRITE         0x85
#define IOCTL_SPP_STATUS        0x86
#define IOCTL_SPP_CONTROL       0x87
#define IOCTL_SPP_DATA_BUS      0x88
#define IOCTL_GPIO_OE           0x89
#define IOCTL_GPIO_READ         0x8A
#define IOCTL_GPIO_WRITE        0x8B

#define CARRIAGE_HOME 0x04
#define MOTOR_BUSY    0x08

#define CALIBRATION_STEPSIZE    103
#define SCAN_STARTPOS_STEPSIZE  100
#define CCD_LINEOFFSET            4


#define scFirstCompositionMode  0

#define scLineArt               0
#define scHalftone              1
#define scGrayScale             1
#define scBilevelColor          3
#define scFullColor             4
#define scPreview               5
#define sc36BitsColor           6 // 36 bits color mode, for 600 dpi scanner
#define sc30BitsColor           7 // 30 bits color mode, for 300 dpi scanner
#define sc12BitsGray            8
#define sc12BitsLineArt         9
#define sc42BitsColor           10
#define sc14BitsGray            11
#define sc14BitsLineArt         12
#define scLastCompositionMode   13

//
// BYTE operation codes
//

#define CMD_READ      0x00
#define CMD_WRITE     0x01
#define CMD_WRITE_WM  0x03
#define CMD_GETIMAGE  0x05
#define CMD_STOPIMAGE 0x06

//
// Register structures
//

typedef struct _E3_REG0  {
    BYTE AsicID :8;
}E3_REG0;

typedef struct _E3_REG3  {
    BYTE SystemReset :1;
    BYTE FifoReset   :1;
    BYTE EppUsb      :1;
    BYTE WatchDog    :1;
    BYTE SelfTest    :1;
    BYTE ScanSpeed   :3;
}E3_REG3;

typedef struct _E3_REG4  {
    BYTE AsicTest        :1;
    BYTE YTable          :1;
    BYTE Refresh         :1;
    BYTE RefreshForever  :1;
    BYTE WaitDelay       :2;
    BYTE ScanMode        :2;
}E3_REG4;

typedef struct _E3_REG5  {
    BYTE Sensor      :2;
    BYTE Sensor_Res  :2;
    BYTE Afe         :3;
    BYTE Adc1210     :1;
}E3_REG5;

typedef struct _E3_REG6  {
    BYTE MotorPower  :1;
    BYTE FullHalf    :1;
    BYTE Operation   :3;
    BYTE LineOffset  :3;
}E3_REG6;

typedef struct _E3_REG12 {
    BYTE MotorMove   :1;
    BYTE MotorStop   :1;
    BYTE HomeSensor  :1;
    BYTE FinishFlag  :1;
    BYTE FifoEmpty   :1;
    BYTE HwSelfTest  :1;
    BYTE ScanStatus  :1;
    BYTE Lamp        :1;
}E3_REG12;

typedef struct _E3_REG13 {
    BYTE Sdi         :1;
    BYTE Sdo         :1;
    BYTE Sclk        :1;
    BYTE Cs          :1;
    BYTE Reserved    :1;
    BYTE WmVsamp     :3;
}E3_REG13;

typedef struct _E3_REG20 {
    BYTE AreaStart       :6;
    BYTE Reserved        :2;
}E3_REG20;

typedef struct _E3_REG21 {
    BYTE AreaStart       :8;
}E3_REG21;

typedef struct _E3_REG22 {
    BYTE AreaWidth       :6;
    BYTE Reserved        :2;
}E3_REG22;

typedef struct _E3_REG23 {
    BYTE AreaWidth       :8;
}E3_REG23;

typedef struct _E3_REG26 {
    BYTE Stop            :4;
    BYTE Start           :4;
}E3_REG26;

typedef struct _E3_REG27 {
    BYTE YRes        :2;
    BYTE Reserved    :1;
    BYTE AutoPattern :1;
    BYTE XRes        :2;
    BYTE Reserved2   :1;
    BYTE True16Bits  :1;
}E3_REG27;

typedef struct _E3_REG28 {
    BYTE XRes        :8;
}E3_REG28;

typedef struct _E3_REG29 {
    BYTE YRes        :8;
}E3_REG29;

typedef struct _E3_REG31 {
    BYTE Key0            :1;
    BYTE Key1            :1;
    BYTE Key2            :1;
    BYTE Key3            :1;
    BYTE Key4            :1;
    BYTE Key5            :1;
    BYTE Key6            :1;
    BYTE Key7            :1;
}E3_REG31;

class CPMXE3 {
public:
    CPMXE3(PDEVCTRL pDeviceControl);
    ~CPMXE3();

    // overides
    BOOL SetXRes(LONG xRes);
    BOOL SetYRes(LONG yRes);
    BOOL SetXPos(LONG xPos);
    BOOL SetYPos(LONG yPos);
    BOOL SetXExt(LONG xExt);
    BOOL SetYExt(LONG yExt);
    BOOL SetDataType(LONG DataType);
    BOOL Scan();

    PDEVCTRL m_pDeviceControl;

    long m_xres;
    long m_yres;
    long m_xpos;
    long m_ypos;
    long m_xext;
    long m_yext;
    long m_datatype;

    BOOL RawWrite(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG lTimeout);
    BOOL RawRead(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout);

    //
    // device specific helpers
    //

    long m_scanmode; // pPrimax specific member

    VOID InitializeRegisters();
    BOOL WriteRegister(INT RegisterNumber, BYTE Value);
    BOOL WriteRegisterEx(INT RegisterNumber, BYTE Value);
    BOOL ReadRegister(INT RegisterNumber, BYTE *pValue);
    BOOL ReadRegisterEx(INT RegisterNumber, BYTE *pValue);
    BOOL WriteStopImageRegister();
    INT  GetScanSpeed();
    BOOL Lamp(BOOL bON);
    BOOL IsCarriageHOME();
    BOOL IsMotorBusy();
    BOOL IsLampON();
    BOOL HomeCarriage();
    BOOL StopMode();
    BOOL SetMotorSpeed(INT TriggerPeriod, INT ScanSpeed);
    BOOL MoveCarriage(BOOL bForward, INT Steps);
    BOOL Motor(BOOL bON);
    BOOL StopScan();
    BOOL GetButtonStatus(PBYTE pButtons);
    BOOL ClearButtonPress();
    BOOL WakeupScanner();
    BOOL SleepScanner();
    BOOL ResetFIFO();
    BOOL InitADC();
    BOOL StartScan();

    VOID DebugDumpRegisters();
    VOID Trace(LPCTSTR format,...);

    BOOL SetXandYResolution();
    BOOL SetScanWindow();

    //
    // simple image processing
    //

    VOID GrayScaleToThreshold(LPBYTE lpSrc, LPBYTE lpDst, LONG RowBytes);

    //
    // internal registers, for device communication
    //

    BYTE Register0;  // -- Asic ID
    BYTE Register3;  // -- reset (System,FIFO), selftest, scan speed, eppusb, watchdog?
    BYTE Register4;  // -- AsicTest, YTable, refresh DRAM, waitdelay, and scanmode
    BYTE Register5;  // -- Asic description, Sensor type, sensor resolution, Afe, Adc1210
    BYTE Register6;  // -- Motor power,motor operations,line offsets
    BYTE Register7;  // -- carriage step high byte
    BYTE Register8;  // -- carriage step low byte
    BYTE Register9;  // -- carriage backstep
    BYTE Register10; // -- trigger period high byte
    BYTE Register11; // -- trigger period low byte
    BYTE Register12; // -- Motor (move/stop), selftest, Lamp, FIFO status, and Scan status
    BYTE Register13; // -- Sdi,Sdo,Sclk,Cs,WmVSamp
    BYTE Register20; // -- scan area start high byte
    BYTE Register21; // -- scan area start low byte
    BYTE Register22; // -- scan area width high byte
    BYTE Register23; // -- scan area width low byte
    BYTE Register25; // -- ?
    BYTE Register26; // --
    BYTE Register27; // -- (X,Y Resolution setting high byte(use regsiters(27,28)))
    BYTE Register28; // -- X Resolution (low byte)
    BYTE Register29; // -- Y Resolution (low byte)
    BYTE Register31; // -- Button press information

protected:


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\devio.h ===
#ifndef _DEVICEIO_H
#define _DEVICEIO_H

#include "devctrldefs.h"

/////////////////////////////////////////////////
//                                             //
// BASE CLASS for simple device control object //
//                                             //
/////////////////////////////////////////////////

class CDevIO {
public:
    CDevIO(PDEVCTRL pDeviceControl);
    ~CDevIO();

    virtual BOOL SetXRes(LONG xRes);
    virtual BOOL SetYRes(LONG yRes);
    virtual BOOL SetXPos(LONG xPos);
    virtual BOOL SetYPos(LONG yPos);
    virtual BOOL SetXExt(LONG xExt);
    virtual BOOL SetYExt(LONG yExt);
    virtual BOOL SetDataType(LONG DataType);

    virtual BOOL Scan();

    long m_xres;
    long m_yres;
    long m_xpos;
    long m_ypos;
    long m_xext;
    long m_yext;
    long m_datatype;

    PDEVCTRL m_pDeviceControl;

    BOOL RawWrite(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG lTimeout);
    BOOL RawRead(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout);

private:


protected:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\hpscl.h ===
#ifndef _HPSCL_H
#define _HPSCL_H

#include "devio.h"

class CHPSCL {
public:
    CHPSCL(PDEVCTRL pDeviceControl);
    ~CHPSCL();

    // overides
    BOOL SetXRes(LONG xRes);
    BOOL SetYRes(LONG yRes);
    BOOL SetXPos(LONG xPos);
    BOOL SetYPos(LONG yPos);
    BOOL SetXExt(LONG xExt);
    BOOL SetYExt(LONG yExt);
    BOOL SetDataType(LONG DataType);
    BOOL Scan();

    PDEVCTRL m_pDeviceControl;

    long m_xres;
    long m_yres;
    long m_xpos;
    long m_ypos;
    long m_xext;
    long m_yext;
    long m_datatype;

    BOOL RawWrite(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG lTimeout);
    BOOL RawRead(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout);
    VOID Trace(LPCTSTR format,...);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\devio.cpp ===
#include "stdafx.h"
#include "devio.h"

CDevIO::CDevIO(PDEVCTRL pDeviceControl)
{
    m_pDeviceControl = pDeviceControl;
}

BOOL CDevIO::SetXRes(LONG xRes)
{
    return FALSE;
}

BOOL CDevIO::SetYRes(LONG yRes)
{
    return FALSE;
}

BOOL CDevIO::SetXPos(LONG xPos)
{
    return FALSE;
}

BOOL CDevIO::SetYPos(LONG yPos)
{
    return FALSE;
}

BOOL CDevIO::SetXExt(LONG xExt)
{
    return FALSE;
}

BOOL CDevIO::SetYExt(LONG yExt)
{
    return FALSE;
}

BOOL CDevIO::SetDataType(LONG DataType)
{
    return FALSE;
}

BOOL CDevIO::Scan()
{
    return FALSE;
}

BOOL CDevIO::RawWrite(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG lTimeout)
{
    DWORD dwBytesWritten = 0;
    return WriteFile(m_pDeviceControl->DeviceIOHandles[lPipeNum],
                     pbuffer,
                     lbuffersize,
                     &dwBytesWritten,
                     NULL);    
}

BOOL CDevIO::RawRead(LONG lPipeNum,BYTE *pbuffer,LONG lbuffersize,LONG *plbytesread,LONG lTimeout)
{
    DWORD dwBytesRead = 0;
    return ReadFile(m_pDeviceControl->DeviceIOHandles[lPipeNum],
                    pbuffer,
                    lbuffersize,
                    &dwBytesRead,
                    NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\devctrldlg.cpp ===
// devctrlDlg.cpp : implementation file
//

#include "stdafx.h"
#include "devctrl.h"
#include "devctrlDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDevctrlDlg dialog

CDevctrlDlg::CDevctrlDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CDevctrlDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDevctrlDlg)
    m_xres = 0;
    m_yres = 0;
    m_xpos = 0;
    m_ypos = 0;
    m_xext = 0;
    m_yext = 0;
    m_CreateFileName = _T("");
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDevctrlDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDevctrlDlg)
    DDX_Control(pDX, IDC_CREATE_BUTTON, m_CreateButton);
    DDX_Control(pDX, IDC_DATATYPE_COMBOBOX, m_DataTypeCombobox);
    DDX_Control(pDX, IDC_DEVICE_COMBO_BOX, m_DeviceCombobox);
    DDX_Text(pDX, IDC_XRES_EDITBOX, m_xres);
    DDX_Text(pDX, IDC_YRES_EDITBOX, m_yres);
    DDX_Text(pDX, IDC_XPOS_EDITBOX, m_xpos);
    DDX_Text(pDX, IDC_YPOS_EDITBOX, m_ypos);
    DDX_Text(pDX, IDC_XEXT_EDITBOX, m_xext);
    DDX_Text(pDX, IDC_YEXT_EDITBOX, m_yext);
    DDX_Text(pDX, IDC_CREATE_FILENAME_EDITBOX, m_CreateFileName);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDevctrlDlg, CDialog)
    //{{AFX_MSG_MAP(CDevctrlDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_WRITE_SETTINGS_BUTTON, OnWriteSettingsButton)
    ON_BN_CLICKED(IDC_SCAN_BUTTON, OnScanButton)
    ON_BN_CLICKED(IDC_ABORT_SCAN_BUTTON, OnAbortScanButton)
    ON_BN_CLICKED(IDC_CONFIGURE_BUTTON, OnConfigureButton)
    ON_BN_CLICKED(IDC_CREATE_BUTTON, OnCreateButton)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDevctrlDlg message handlers

BOOL CDevctrlDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    ReadRegistryValues();

    memset(m_DeviceControl.DeviceIOHandles,
           0,
           sizeof(m_DeviceControl.DeviceIOHandles));
    m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME)));

    //
    // TODO: fix the base object. Creating a new
    //       one for each scanner...is a waste.
    //       This was done temporarly because of
    //       time constraints..in tool development.
    //       -coop
    //


    m_phpscl   = NULL;
    m_pprimaxE3 = NULL;

    m_phpscl   = new CHPSCL(&m_DeviceControl);
    m_pprimaxE3 = new CPMXE3(&m_DeviceControl);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDevctrlDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDevctrlDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDevctrlDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CDevctrlDlg::OnWriteSettingsButton()
{
    // nothing
}

BOOL CDevctrlDlg::WriteScannerSettings()
{

    UpdateData(TRUE);

    //
    // TODO: fix the base object, so we can use that
    //       object to do these operations... not
    //       create a new one each time...
    //       -coop
    //

    switch(m_DeviceCombobox.GetCurSel()){
    case HP_SCL_SCANNER:
        if(!m_phpscl->SetXRes(m_xres)){
            MessageBox(TEXT("Setting X Resolution Failed"));
            return FALSE;
            break;
        }

        if(!m_phpscl->SetYRes(m_yres)){
            MessageBox(TEXT("Setting Y Resolution Failed"));
            return FALSE;
            break;
        }

        if(!m_phpscl->SetXPos(m_xpos)){
            MessageBox(TEXT("Setting X Position Failed"));
            return FALSE;
            break;
        }

        if(!m_phpscl->SetYPos(m_ypos)){
            MessageBox(TEXT("Setting Y Position Failed"));
            return FALSE;
            break;
        }

        if(!m_phpscl->SetXExt(m_xext)){
            MessageBox(TEXT("Setting X Extent Failed"));
            return FALSE;
            break;
        }

        if(!m_phpscl->SetYExt(m_yext)){
            MessageBox(TEXT("Setting Y Extent Failed"));
            return FALSE;
            break;
        }

        if(!m_phpscl->SetDataType(m_DataTypeCombobox.GetCurSel())){
            MessageBox(TEXT("Setting Data Type Failed"));
            return FALSE;
            break;
        }
        break;
    case VISIONEER_E3_SCANNER:

        if(!m_pprimaxE3->WakeupScanner()){
            MessageBox(TEXT("Scanner will not wake up!"));
            return FALSE;
            break;
        }

        if(!m_pprimaxE3->SetXRes(m_xres)){
            MessageBox(TEXT("Setting X Resolution Failed"));
            return FALSE;
            break;
        }

        if(!m_pprimaxE3->SetYRes(m_yres)){
            MessageBox(TEXT("Setting Y Resolution Failed"));
            return FALSE;
            break;
        }

        if(!m_pprimaxE3->SetXPos(m_xpos)){
            MessageBox(TEXT("Setting X Position Failed"));
            return FALSE;
            break;
        }

        if(!m_pprimaxE3->SetYPos(m_ypos)){
            MessageBox(TEXT("Setting Y Position Failed"));
            return FALSE;
            break;
        }

        if(!m_pprimaxE3->SetXExt(m_xext)){
            MessageBox(TEXT("Setting X Extent Failed"));
            return FALSE;
            break;
        }

        if(!m_pprimaxE3->SetYExt(m_yext)){
            MessageBox(TEXT("Setting Y Extent Failed"));
            return FALSE;
            break;
        }

        if(!m_pprimaxE3->SetDataType(m_DataTypeCombobox.GetCurSel())){
            MessageBox(TEXT("Setting Data Type Failed"));
            return FALSE;
            break;
        }
        break;
    default:
        MessageBox(TEXT("unknown device type selected"),TEXT("Error"),MB_ICONERROR);
        return FALSE;
        break;
    }

    return TRUE;
}

void CDevctrlDlg::OnScanButton()
{
    if(!WriteScannerSettings())
        return;

    switch(m_DeviceCombobox.GetCurSel()){
    case HP_SCL_SCANNER:
        if (!m_phpscl->Scan())
            MessageBox(TEXT("Scan Failed"),TEXT("Error"),MB_ICONERROR);
        break;
    case VISIONEER_E3_SCANNER:
        if (!m_pprimaxE3->Scan()) {
            MessageBox(TEXT("Scan Failed"),TEXT("Error"),MB_ICONERROR);
            break;
        }
        break;
    default:
        MessageBox(TEXT("unknown device type selected"),TEXT("Error"),MB_ICONERROR);
        break;
    }
}

void CDevctrlDlg::OnAbortScanButton()
{
    // TODO: Add your control notification handler code here

}

void CDevctrlDlg::InitDefaultSettings()
{
    m_DeviceCombobox.SetCurSel(0);      // hp scanner
    m_DataTypeCombobox.SetCurSel(0);    // 1 bit data

    // settings

    m_xext = 100;
    m_yext = 100;
    m_xpos = 0;
    m_ypos = 0;
    m_xres = 150;
    m_yres = 150;

    m_CreateFileName = "\\\\.\\Usbscan0";
    UpdateData(FALSE);
}

void CDevctrlDlg::OnConfigureButton()
{
    UpdateData(TRUE);
    CConfigDlg ConfigDialog;
    ConfigDialog.m_Pipe1        = m_Pipe1;
    ConfigDialog.m_Pipe2        = m_Pipe2;
    ConfigDialog.m_Pipe3        = m_Pipe3;
    ConfigDialog.m_DefaultPipe  = m_CreateFileName;

    ConfigDialog.m_DeviceControl.StatusPipeIndex = m_DeviceControl.StatusPipeIndex;
    ConfigDialog.m_DeviceControl.InterruptPipeIndex = m_DeviceControl.InterruptPipeIndex;
    ConfigDialog.m_DeviceControl.BulkOutPipeIndex = m_DeviceControl.BulkOutPipeIndex;
    ConfigDialog.m_DeviceControl.BulkInPipeIndex = m_DeviceControl.BulkInPipeIndex;

    if(ConfigDialog.DoModal() == IDOK){

        //
        // only update information, if the user pressed "OK"
        //

        m_Pipe1 = ConfigDialog.m_Pipe1;
        m_Pipe2 = ConfigDialog.m_Pipe2;
        m_Pipe3 = ConfigDialog.m_Pipe3;

        m_DeviceControl.StatusPipeIndex = ConfigDialog.m_DeviceControl.StatusPipeIndex;
        m_DeviceControl.InterruptPipeIndex = ConfigDialog.m_DeviceControl.InterruptPipeIndex;
        m_DeviceControl.BulkOutPipeIndex = ConfigDialog.m_DeviceControl.BulkOutPipeIndex;
        m_DeviceControl.BulkInPipeIndex = ConfigDialog.m_DeviceControl.BulkInPipeIndex;

    }
}

void CDevctrlDlg::OnCreateButton()
{
    if(NULL != m_DeviceControl.DeviceIOHandles[0]){
        if(MessageBox(TEXT("A default handle is already created.\nWould you like to free the existing one?"),
            TEXT("Warning.."),MB_YESNO) == IDYES){
            CloseAllHandles();
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME)));
            return;

        } else {
            m_CreateButton.SetCheck(1);
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME2)));
            return;
        }
    }

    UpdateData(TRUE);

    //
    // create Default handle
    //

    m_DeviceControl.DeviceIOHandles[0] = CreateFile(m_CreateFileName,
                                     GENERIC_READ | GENERIC_WRITE, // Access mask
                                     0,                            // Share mode
                                     NULL,                         // SA
                                     OPEN_EXISTING,                // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM,        // Attributes
                                     NULL );

    if(NULL != m_DeviceControl.DeviceIOHandles[0]){
        MessageBox(TEXT("Default handle was created successfully"),TEXT("CreateFile() Success!"));
        m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME2)));
    } else {
        MessageBox(TEXT("Default handle creation failed"),TEXT("CreateFile() Failure!"));
        m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME)));
    }

    //
    // create pipe1 handle
    //

    if(m_Pipe1.GetLength() > 0){

        m_DeviceControl.DeviceIOHandles[1] = CreateFile(m_CreateFileName + m_Pipe1,
            GENERIC_READ | GENERIC_WRITE, // Access mask
            0,                            // Share mode
            NULL,                         // SA
            OPEN_EXISTING,                // Create disposition
            FILE_ATTRIBUTE_SYSTEM,        // Attributes
            NULL );

        if(NULL != m_DeviceControl.DeviceIOHandles[1]){
            MessageBox(TEXT("pipe 1 handle was created successfully"),TEXT("CreateFile() Success!"));
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME2)));
        } else {
            MessageBox(TEXT("Default handle creation failed"),TEXT("CreateFile() Failure!"));
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME)));
        }
    }

    //
    // create pipe2 handle
    //

    if(m_Pipe2.GetLength() > 0){

        m_DeviceControl.DeviceIOHandles[2] = CreateFile(m_CreateFileName + m_Pipe2,
            GENERIC_READ | GENERIC_WRITE, // Access mask
            0,                            // Share mode
            NULL,                         // SA
            OPEN_EXISTING,                // Create disposition
            FILE_ATTRIBUTE_SYSTEM,        // Attributes
            NULL );

        if(NULL != m_DeviceControl.DeviceIOHandles[2]){
            MessageBox(TEXT("pipe 2 handle was created successfully"),TEXT("CreateFile() Success!"));
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME2)));
        } else {
            MessageBox(TEXT("Default handle creation failed"),TEXT("CreateFile() Failure!"));
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME)));
        }
    }

    //
    // create pipe3 handle
    //

    if(m_Pipe3.GetLength() > 0){

        m_DeviceControl.DeviceIOHandles[3] = CreateFile(m_CreateFileName + m_Pipe3,
            GENERIC_READ | GENERIC_WRITE, // Access mask
            0,                            // Share mode
            NULL,                         // SA
            OPEN_EXISTING,                // Create disposition
            FILE_ATTRIBUTE_SYSTEM,        // Attributes
            NULL );

        if(NULL != m_DeviceControl.DeviceIOHandles[3]){
            MessageBox(TEXT("pipe 3 handle was created successfully"),TEXT("CreateFile() Success!"));
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME2)));
        } else {
            MessageBox(TEXT("Default handle creation failed"),TEXT("CreateFile() Failure!"));
            m_CreateButton.SetIcon(LoadIcon(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_MAINFRAME)));
        }
    }
}

void CDevctrlDlg::CloseAllHandles()
{
    for(int index = 0; index < MAX_IO_HANDLES ; index++){
        if(NULL != m_DeviceControl.DeviceIOHandles[index]){
            CloseHandle(m_DeviceControl.DeviceIOHandles[index]);
            m_DeviceControl.DeviceIOHandles[index] = NULL;
        }
    }
}

void CDevctrlDlg::ReadRegistryValues()
{
    CRegistry Registry(DEVCTRL_APP_KEY);
    TCHAR szTemp[255];
    memset(szTemp,0,sizeof(szTemp));

    Registry.ReadStringValue(TEXT("CreateFileName"), szTemp,sizeof(szTemp));
    if(lstrlen(szTemp) == 0){
        m_CreateFileName = "\\\\.\\Usbscan0";
    } else {
        m_CreateFileName = szTemp;
    }

    Registry.ReadStringValue(TEXT("Pipe1Name"), szTemp,sizeof(szTemp));
    m_Pipe1 = szTemp;

    Registry.ReadStringValue(TEXT("Pipe2Name"), szTemp,sizeof(szTemp));
    m_Pipe2 = szTemp;

    Registry.ReadStringValue(TEXT("Pipe3Name"), szTemp,sizeof(szTemp));
    m_Pipe3 = szTemp;

    m_xres = Registry.ReadLongValue(TEXT("XResolution"));
    m_yres = Registry.ReadLongValue(TEXT("YResolution"));
    m_xpos = Registry.ReadLongValue(TEXT("XPosition"));
    m_ypos = Registry.ReadLongValue(TEXT("YPosition"));
    m_xext = Registry.ReadLongValue(TEXT("XExtent"));
    m_yext = Registry.ReadLongValue(TEXT("YExtent"));

    m_DeviceControl.StatusPipeIndex = Registry.ReadLongValue(TEXT("StatusPipeIndex"));
    m_DeviceControl.InterruptPipeIndex = Registry.ReadLongValue(TEXT("InterruptPipeIndex"));
    m_DeviceControl.BulkOutPipeIndex = Registry.ReadLongValue(TEXT("BulkOutPipeIndex"));
    m_DeviceControl.BulkInPipeIndex = Registry.ReadLongValue(TEXT("BulkInPipeIndex"));

    m_datatype = Registry.ReadLongValue(TEXT("DataType"));
    m_device = Registry.ReadLongValue(TEXT("Device"));

    m_DeviceCombobox.SetCurSel(m_device);
    m_DataTypeCombobox.SetCurSel(m_datatype);

    UpdateData(FALSE);

    // InitDefaultSettings();
}

void CDevctrlDlg::WriteRegistryValues()
{
    UpdateData(TRUE);
    CRegistry Registry(DEVCTRL_APP_KEY);
    TCHAR szTemp[255];
    memset(szTemp,0,sizeof(szTemp));

    Registry.WriteStringValue(TEXT("CreateFileName"),m_CreateFileName.GetBuffer(255));
    Registry.WriteStringValue(TEXT("Pipe1Name"),m_Pipe1.GetBuffer(255));
    Registry.WriteStringValue(TEXT("Pipe2Name"),m_Pipe2.GetBuffer(255));
    Registry.WriteStringValue(TEXT("Pipe3Name"),m_Pipe3.GetBuffer(255));
    Registry.WriteLongValue(TEXT("XResolution"),m_xres);
    Registry.WriteLongValue(TEXT("YResolution"),m_yres);
    Registry.WriteLongValue(TEXT("XPosition"),m_xpos);
    Registry.WriteLongValue(TEXT("YPosition"),m_ypos);
    Registry.WriteLongValue(TEXT("XExtent"),m_xext);
    Registry.WriteLongValue(TEXT("YExtent"),m_yext);
    Registry.WriteLongValue(TEXT("StatusPipeIndex"),m_DeviceControl.StatusPipeIndex);
    Registry.WriteLongValue(TEXT("InterruptPipeIndex"),m_DeviceControl.InterruptPipeIndex);
    Registry.WriteLongValue(TEXT("BulkOutPipeIndex"),m_DeviceControl.BulkOutPipeIndex);
    Registry.WriteLongValue(TEXT("BulkInPipeIndex"),m_DeviceControl.BulkInPipeIndex);


    Registry.WriteLongValue(TEXT("DataType"),(LONG)m_DataTypeCombobox.GetCurSel());
    Registry.WriteLongValue(TEXT("Device"),(LONG)m_DeviceCombobox.GetCurSel());

    // InitDefaultSettings();
}

void CDevctrlDlg::OnCancel()
{
    WriteRegistryValues();
    if(m_phpscl)
        delete m_phpscl;
    if(m_pprimaxE3)
        delete m_pprimaxE3;

    CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=devctrl
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\devctrl.cpp    \
        ..\devctrldlg.cpp \
        ..\configdlg.cpp  \
        ..\devio.cpp      \
        ..\hpscl.cpp      \
        ..\pmxe3.cpp      \
        ..\devctrl.rc

# Add interlac.cpp if the PNG support is ever fixed

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\winmm.lib       \
        $(SDK_LIB_PATH)\irnotif.lib     \
        $(SDK_LIB_PATH)\\userenv.lib    \
        $(SDK_LIB_PATH)\comdlg32.lib    \
        $(SDK_LIB_PATH)\atl.lib         \
        $(SDK_LIB_PATH)\mscms.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\cwia.h ===
// CWIA.H

#ifndef _CWIA_H
#define _CWIA_H

#include "wia.h"
#include "datatypes.h"
#include "sti.h"

#define MIN_PROPID 2

//
// helper MACROS
//

#define RECTWIDTH(lpRect)  ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect) ((lpRect)->bottom - (lpRect)->top)

typedef BOOL (*FPPROGRESS)(LPTSTR lpszText, LONG lPercentComplete);
typedef struct _DATA_ACQUIRE_INFO {
	DWORD dwCookie;
	FPPROGRESS pProgressFunc;
	BOOL bPreview;
    BOOL bTransferToFile;
    BOOL bTransferToClipboard;
    CHAR szFileName[256];
	HBITMAP hBitmap;
	HWND hWnd;
    HGLOBAL hClipboardData;
    HGLOBAL hBitmapData;
} DATA_ACQUIRE_INFO;

//
// global helpers, for all to use
//

HRESULT WriteInterfaceToGlobalInterfaceTable(DWORD *pdwCookie, IWiaItem *pIWiaItem);
HRESULT ReadInterfaceFromGlobalInterfaceTable(DWORD dwCookie, IWiaItem **ppIWiaItem);

class CWIA {
public:
	 CWIA(DATA_ACQUIRE_INFO* pDataAcquireInfo = NULL, IWiaItem *pRootItem = NULL);
	~CWIA();
	
	VOID CleanUp();

	//
	// operations
	//

	HRESULT GetLastWIAError(TCHAR *pszErrorText = NULL);
	HRESULT ReadRangeLong(IWiaItem *pIWiaItem, PROPID propid, ULONG ulFlag, LONG *plVal);	
	HRESULT ReadLong(IWiaItem *pIWiaItem, PROPID propid, LONG *plVal);
	HRESULT ReadStr(IWiaItem *pIWiaItem, PROPID propid, BSTR *pbstr);
	HRESULT ReadGuid(IWiaItem *pIWiaItem, PROPID propid, GUID *pguidVal);

	HRESULT WriteLong(IWiaItem *pIWiaItem, PROPID propid, LONG lVal);
	HRESULT WriteGuid(IWiaItem *pIWiaItem, PROPID propid, GUID guidVal);

	HRESULT DoBandedTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo);
    HRESULT DoFileTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo);
	BOOL IsAcquireComplete();

	HRESULT EnumerateSupportedFormats(IWiaItem *pIWiaItem, WIA_FORMAT_INFO **ppSupportedFormats, ULONG *pulCount);

	//
	// Root Item operations
	//

	VOID SetRootItem(IWiaItem *pRootItem);
	IWiaItem *GetRootItem();
	LONG GetRootItemType(IWiaItem *pRootItem = NULL);

	//
	// standard item operations
	//

	BOOL SetFirstChild();
	IWiaItem *GetFirstChild();
	
private:
	
	//
	// helpers
	//

	VOID SaveErrorText(TCHAR *pszText);

	//
	// Read/Write LONG properties
	//

	HRESULT WritePropLong(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LONG lVal);
	HRESULT ReadPropLong(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, LONG *plval);

	//
	// Read/Write GUID properties
	//

	HRESULT WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal);
	HRESULT ReadPropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID *pguidVal);

	//
	// Read/Write BSTR properties
	//

	HRESULT ReadPropStr(PROPID propid,IWiaPropertyStorage  *pIWiaPropStg,BSTR *pbstr);
	HRESULT WritePropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, BSTR bstr);

protected:

	IWiaItem  *m_pIWiaRootItem;
	IWiaItem  *m_pIWiaFirstChildItem;
	BOOL      m_bFinishedAcquire;

	TCHAR     m_szErrorText[MAX_PATH];
	HRESULT   m_hrLastError;
};

//
// IWiaDataCallback Data callback transfer
//

class CWiaDataCallback : public IWiaDataCallback
{

private:

   ULONG                    m_cRef;         // Object reference count.     
   LONG                     m_MemBlockSize;
   LONG                     m_BytesTransfered;
   GUID                     m_cFormat;
   FPPROGRESS               m_pProgressFunc;
   LONG                     m_lPageCount;
   BOOL                     m_bCanceled;
   DATA_ACQUIRE_INFO*       m_pDataAcquireInfo;
   BOOL                     m_bBitmapCreated;
public:

    CWiaDataCallback();
    ~CWiaDataCallback();

    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

	//
	// public members
	//

    HRESULT _stdcall Initialize(DATA_ACQUIRE_INFO* pDataAcquireInfo = NULL);
    HRESULT _stdcall BandedDataCallback(LONG  lMessage,
										LONG  lStatus,
										LONG  lPercentComplete,
										LONG  lOffset,
										LONG  lLength,
										LONG  lReserved,
										LONG  lResLength,
										BYTE* pbBuffer);	
private:

	//
	// helpers
	//

	VOID AddDataToHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset);
	VOID CreateHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset);
	void ScreenRectToClientRect(HWND hWnd,LPRECT pRect);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	devctrl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\adfdlg.h ===
#ifndef _ADFDLG_H
#define _ADFDLG_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ADFDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CADFDlg dialog

class CADFDlg : public CDialog
{
// Construction
public:
    CADFDlg(ADF_SETTINGS *pADFSettings, CWnd* pParent = NULL);   // standard constructor
    UINT m_MaxPagesAllowed;

// Dialog Data
    //{{AFX_DATA(CADFDlg)
    enum { IDD = IDD_ADF_SETTING_DIALOG };
    CComboBox   m_PageOrderComboBox;
    CComboBox   m_ADFModeComboBox;
    CEdit   m_ScanNumberOfPagesEditBox;
    CString m_ADFStatusText;
    UINT    m_NumberOfPages;
    CButton m_ScanAllPages;
    CButton m_ScanNumberOfPages;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CADFDlg)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    ADF_SETTINGS *m_pADFSettings;
    LONG m_DocumentHandlingSelectBackup;
    VOID InitStatusText();
    VOID InitFeederModeComboBox();
    VOID InitPageOrderComboBox();
    INT GetIDAndStringFromDocHandlingStatus(LONG lDocHandlingStatus, TCHAR *pszString);
    // Generated message map functions
    //{{AFX_MSG(CADFDlg)
    afx_msg void OnKillfocusNumberOfPagesEditbox();
    virtual BOOL OnInitDialog();
    afx_msg void OnScanAllPagesRadiobutton();
    afx_msg void OnScanSpecifiedPagesRadiobutton();
    afx_msg void OnSelchangeAdfModeCombobox();
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\cwia.cpp ===
// CWIA.cpp : implementation file
//

#include "stdafx.h"
#include "CWIA.h"

extern IGlobalInterfaceTable *g_pGIT;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWIA::CWIA(DATA_ACQUIRE_INFO* pThreadDataInfo, IWiaItem *pRootItem)
{
    m_bFinishedAcquire = FALSE;
    m_pIWiaRootItem   = NULL;
    m_pIWiaFirstChildItem = NULL;
    if(pRootItem != NULL)
        m_pIWiaRootItem = pRootItem;
}

CWIA::~CWIA()
{

}

VOID CWIA::CleanUp()
{
    if(m_pIWiaRootItem != NULL)
        m_pIWiaRootItem->Release();
    if(m_pIWiaFirstChildItem != NULL)
        m_pIWiaFirstChildItem->Release();
}

VOID CWIA::SetRootItem(IWiaItem *pRootItem)
{
    m_pIWiaRootItem = pRootItem;
    SetFirstChild();
}

BOOL CWIA::IsAcquireComplete()
{
    return m_bFinishedAcquire;
}

HRESULT CWIA::EnumerateSupportedFormats(IWiaItem *pIWiaItem, WIA_FORMAT_INFO **ppSupportedFormats, ULONG *pulCount)
{
    HRESULT hr  = E_FAIL;
    *pulCount = 0;
    IWiaDataTransfer *pIWiaDataTransfer = NULL;

    IWiaItem *pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        hr = pTargetItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
        if (SUCCEEDED(hr)) {
            IEnumWIA_FORMAT_INFO *pIEnumWIA_FORMAT_INFO;

            hr = pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pIEnumWIA_FORMAT_INFO);
            if (SUCCEEDED(hr)) {

                hr = pIEnumWIA_FORMAT_INFO->Reset();
                if(SUCCEEDED(hr)) {
                    hr = pIEnumWIA_FORMAT_INFO->GetCount(pulCount);
                    if(SUCCEEDED(hr)) {

                        //
                        // caller of this routine must free the allocated memory
                        //

                        *ppSupportedFormats = (WIA_FORMAT_INFO*)GlobalAlloc(GPTR,(sizeof(WIA_FORMAT_INFO) * (*pulCount)));
                        if(*ppSupportedFormats != NULL) {
                            hr = pIEnumWIA_FORMAT_INFO->Next(*pulCount, *ppSupportedFormats, pulCount);
                            if(hr != S_OK) {

                                //
                                // if this failed, write error to Last error buffer,
                                // and let the procedure wind out
                                //

                                //
                                // free allocated memory, because we failed
                                //

                                GlobalFree(*ppSupportedFormats);

                                //
                                // set pointer to NULL, to clean the exit path for
                                // application
                                //

                                *ppSupportedFormats = NULL;
                                SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIEnumWIA_FORMAT_INFO->Next() failed"));
                            }
                        } else {
                            SaveErrorText(TEXT("EnumerateSupportedFileTypes, out of memory"));
                        }
                    } else {
                        SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIEnumWIA_FORMAT_INFO->GetCount() failed"));
                    }
                } else {
                    SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIEnumWIA_FORMAT_INFO->Reset() failed"));
                }

                //
                // Release supported format enumerator interface
                //

                pIEnumWIA_FORMAT_INFO->Release();
            } else {
                SaveErrorText(TEXT("EnumerateSupportedFileTypes, pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO() failed"));
            }

            //
            // Release data transfer interface
            //

            pIWiaDataTransfer->Release();
        } else {
            SaveErrorText(TEXT("EnumerateSupportedFileTypes, QI for IWiaDataTransfer failed"));
        }
    }
    return hr;
}

BOOL CWIA::SetFirstChild()
{
    HRESULT hr = E_FAIL;
    BOOL bSuccess = FALSE;
    IEnumWiaItem* pIEnumWiaItem = NULL;
    IWiaItem *pIWiaItem = NULL;

    hr = m_pIWiaRootItem->EnumChildItems(&pIEnumWiaItem);
    if(SUCCEEDED(hr)) {

        //
        // get first child item
        //

        hr = pIEnumWiaItem->Next(1,&pIWiaItem,NULL);
        if(hr == S_OK) {

            //
            // item was retrieved, so now assign you first child member
            //

            m_pIWiaFirstChildItem = pIWiaItem;

            //
            // assign success flag
            //

            bSuccess = TRUE;
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("SetFirstChild, pIEnumWiaItem->Next failed"));
            m_hrLastError = hr;
        }

        //
        // release Item enumerator
        //

        pIEnumWiaItem->Release();
    }
    return bSuccess;
}

IWiaItem* CWIA::GetFirstChild()
{
    return m_pIWiaFirstChildItem;
}

IWiaItem* CWIA::GetRootItem()
{
    return m_pIWiaRootItem;
}

LONG CWIA::GetRootItemType(IWiaItem *pRootItem)
{
    IWiaItem *pTargetRootItem = NULL;

    //
    // start with the requested RootItem first
    //

    pTargetRootItem = pRootItem;

    if(pTargetRootItem == NULL) {

        //
        // the requested root item is NULL, so try our
        // internal root item (m_pIWiaRootItem)
        //

        pTargetRootItem = m_pIWiaRootItem;
    }

    //
    // get Root item's type (ie. device type)
    //

    LONG lVal = -888;

    if (pTargetRootItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        HRESULT hr = S_OK;
        hr = pTargetRootItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            //
            // read Root Item's Type
            //

            hr = ReadPropLong(WIA_DIP_DEV_TYPE, pIWiaPropStg, &lVal);
            if(SUCCEEDED(hr)) {

                //
                // release the IWiaPropertyStorage Interface
                //

                pIWiaPropStg->Release();
            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("GetRootItemType, ReadPropLong(WIA_DIP_DEV_TYPE) failed"));
                m_hrLastError = hr;
            }
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("GetRootItemType, ReadPropLong(WIA_DIP_DEV_TYPE) failed"));
            m_hrLastError = hr;
        }
    }
    return(GET_STIDEVICE_TYPE(lVal));
}

//
// ERROR PROCESSING
//

VOID CWIA::SaveErrorText(TCHAR *pszText)
{
    lstrcpy(m_szErrorText,pszText);
}

HRESULT CWIA::GetLastWIAError(TCHAR *pszErrorText)
{
    if(pszErrorText != NULL)
        lstrcpy(pszErrorText, m_szErrorText);
    return m_hrLastError;
}

//
// PROPERTY ACCESS HELPERS
//

HRESULT CWIA::WritePropLong(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LONG lVal)
{
    HRESULT     hr = E_FAIL;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_I4;
    propvar[0].lVal = lVal;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hr;
}

HRESULT CWIA::ReadPropLong(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, LONG *plval)
{
    HRESULT           hr = E_FAIL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize = 0;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        *plval = PropVar[0].lVal;
    }
    return hr;
}

HRESULT CWIA::ReadRangeLong(IWiaItem *pIWiaItem, PROPID propid, ULONG ulFlag, LONG *plVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       AttrPropVar;
    ULONG             ulAccessFlags = 0;

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            //
            // get property's attributes
            //

            hr = pIWiaPropStg->GetPropertyAttributes(1, PropSpec, &ulAccessFlags, &AttrPropVar);
            if(SUCCEEDED(hr)) {
                *plVal = (LONG)AttrPropVar.caul.pElems[ulFlag];
            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadRangeLong, GetPropertyAttributes() failed"));
                m_hrLastError = hr;
            }

            //
            // release the IWiaPropertyStorage Interface
            //

            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadRangeLong, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::ReadLong(IWiaItem *pIWiaItem, PROPID propid, LONG *plVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = ReadPropLong(propid,pIWiaPropStg,plVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadLong, ReadPropLong() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadLong, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::WriteLong(IWiaItem *pIWiaItem, PROPID propid, LONG lVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = WritePropLong(propid,pIWiaPropStg,lVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("WriteLong, WritePropLong() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("WriteLong, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::ReadStr(IWiaItem *pIWiaItem, PROPID propid, BSTR *pbstr)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = ReadPropStr(propid,pIWiaPropStg,pbstr);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadStr, ReadPropStr() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadStr, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::ReadGuid(IWiaItem *pIWiaItem, PROPID propid, GUID *pguidVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = ReadPropGUID(propid,pIWiaPropStg,pguidVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("ReadGuid, ReadPropGuid() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("ReadGuid, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::WriteGuid(IWiaItem *pIWiaItem, PROPID propid, GUID guidVal)
{
    HRESULT           hr = E_FAIL;
    IWiaItem         *pTargetItem = NULL;
    PROPSPEC          PropSpec[1];

    //
    // create a propspec
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;

    pTargetItem = pIWiaItem;
    if(pTargetItem == NULL) {

        //
        // use first child of root
        //

        pTargetItem = m_pIWiaFirstChildItem;
    }

    if(pTargetItem != NULL) {

        //
        // get an IWiaPropertyStorage Interface
        //

        IWiaPropertyStorage *pIWiaPropStg;
        hr = pTargetItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (SUCCEEDED(hr)) {

            hr = WritePropGUID(propid,pIWiaPropStg,guidVal);
            if(SUCCEEDED(hr)) {

                //
                // read has taken place
                //

            } else {

                //
                // save last error, for later request
                //

                SaveErrorText(TEXT("WriteGuid, WritePropGuid() failed"));
                m_hrLastError = hr;
            }
            pIWiaPropStg->Release();
        } else {

            //
            // save last error, for later request
            //

            SaveErrorText(TEXT("WriteGuid, QI for IWiaProperyStorage failed"));
            m_hrLastError = hr;
        }
    }
    return hr;
}

HRESULT CWIA::DoBandedTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    HRESULT hr = S_OK;

    //
    // Write TYMED value to callback
    //

    hr = WriteLong(m_pIWiaFirstChildItem,WIA_IPA_TYMED,TYMED_CALLBACK);

    //
    // get IWiaDatatransfer interface
    //

    IWiaDataTransfer *pIBandTran = NULL;
    hr = m_pIWiaFirstChildItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIBandTran);
    if (SUCCEEDED(hr)) {

        //
        // create Banded callback
        //

        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback* pCBandedCB = new CWiaDataCallback();
        if (pCBandedCB) {
            hr = pCBandedCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (SUCCEEDED(hr)) {
                WIA_DATA_TRANSFER_INFO  wiaDataTransInfo;

                pCBandedCB->Initialize(pDataAcquireInfo);

                ZeroMemory(&wiaDataTransInfo, sizeof(WIA_DATA_TRANSFER_INFO));
                wiaDataTransInfo.ulSize = sizeof(WIA_DATA_TRANSFER_INFO);
                wiaDataTransInfo.ulBufferSize = 524288;//262144; // calculate, or determine buffer size

                hr = pIBandTran->idtGetBandedData(&wiaDataTransInfo, pIWiaDataCallback);
                m_bFinishedAcquire = TRUE;
                pIBandTran->Release();
                if (hr == S_OK) {
                    OutputDebugString(TEXT("IWiaData Transfer.(CALLBACK)..Success\n"));
                } else if (hr == S_FALSE) {
                    OutputDebugString(TEXT("IWiaData Transfer.(CALLBACK)..Canceled by user\n"));
                } else {
                    OutputDebugString(TEXT("* idtGetBandedData() Failed\n"));
                }

                //
                // release Callback object
                //

                pCBandedCB->Release();
            } else
                // TEXT("* pCBandedCB->QueryInterface(IID_IWiaDataCallback) Failed");
                return hr;
        } else
            return hr;
            // TEXT("* pCBandedCB failed to create..");
    } else
        return hr;
        // TEXT("* pIWiaItem->QueryInterface(IID_IWiaDataTransfer) Failed");
    return S_OK;
}

HRESULT CWIA::DoFileTransfer(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    HRESULT hr = S_OK;

    //
    // Write TYMED value to file
    //

    hr = WriteLong(m_pIWiaFirstChildItem,WIA_IPA_TYMED,TYMED_FILE);

    //
    // get IWiaDatatransfer interface
    //

    IWiaDataTransfer *pIBandTran = NULL;
    hr = m_pIWiaFirstChildItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIBandTran);
    if (SUCCEEDED(hr)) {

        //
        // create Banded callback
        //

        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback* pCBandedCB = new CWiaDataCallback();
        if (pCBandedCB) {
            hr = pCBandedCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (SUCCEEDED(hr)) {

                //
                // fill out STGMEDIUM
                //

                STGMEDIUM StgMedium;
                ZeroMemory(&StgMedium, sizeof(STGMEDIUM));

                StgMedium.tymed          = TYMED_FILE;
                StgMedium.lpszFileName   = NULL;
                StgMedium.pUnkForRelease = NULL;
                StgMedium.hGlobal        = NULL;

                pCBandedCB->Initialize(pDataAcquireInfo);

                hr = pIBandTran->idtGetData(&StgMedium,pIWiaDataCallback);
                m_bFinishedAcquire = TRUE;
                pIBandTran->Release();

                if (hr == S_OK) {

                    OutputDebugString(TEXT("IWiaData Transfer.(FILE)..Success\n"));

                    //
                    // We have completed the transfer...so now move the temporary file into
                    // the needed location, with the users requested file name.
                    //

                    CString WIATempFile = StgMedium.lpszFileName;
                    if(!CopyFile(WIATempFile,pDataAcquireInfo->szFileName,FALSE)){
                        OutputDebugString(TEXT("Failed to copy temp file.."));
                    }

                    //
                    // delete WIA created TEMP file
                    //

                    DeleteFile(WIATempFile);

                } else if (hr == S_FALSE) {
                    OutputDebugString(TEXT("IWiaData Transfer.(FILE)..Canceled by user\n"));
                } else {
                    OutputDebugString(TEXT("* idtGetData() Failed\n"));
                }

                //
                // release Callback object
                //

                pCBandedCB->Release();
            } else
                // TEXT("* pCBandedCB->QueryInterface(IID_IWiaDataCallback) Failed");
                return hr;
        } else
            return hr;
            // TEXT("* pCBandedCB failed to create..");
    } else
        return hr;
        // TEXT("* pIWiaItem->QueryInterface(IID_IWiaDataTransfer) Failed");
    return hr;
}

HRESULT CWIA::WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal)
{
    HRESULT     hr = E_FAIL;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_CLSID;
    propvar[0].puuid = &guidVal;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hr;
}

HRESULT CWIA::ReadPropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID *pguidVal)
{
    HRESULT           hr = E_FAIL;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize = 0;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        pguidVal = PropVar[0].puuid;
    }
    return hr;
}

HRESULT CWIA::ReadPropStr(PROPID propid,IWiaPropertyStorage  *pIWiaPropStg,BSTR *pbstr)
{
    HRESULT     hr = S_OK;
    PROPSPEC    PropSpec[1];
    PROPVARIANT PropVar[1];
    UINT        cbSize = 0;

    *pbstr = NULL;
    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hr = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hr)) {
        if (PropVar[0].pwszVal) {
            *pbstr = SysAllocString(PropVar[0].pwszVal);
        } else {
            *pbstr = SysAllocString(L"");
        }
        if (*pbstr == NULL) {
            hr = E_OUTOFMEMORY;
        }
        PropVariantClear(PropVar);
    }
    return hr;
}

HRESULT CWIA::WritePropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, BSTR bstr)
{
    HRESULT     hr = S_OK;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt      = VT_BSTR;
    propvar[0].pwszVal = bstr;

    hr = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////////////////////

HRESULT _stdcall CWiaDataCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaDataCallback)
        *ppv = (IWiaDataCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CWiaDataCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaDataCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

CWiaDataCallback::CWiaDataCallback()
{
    m_cRef              = 0;
    m_BytesTransfered   = 0;
    m_pProgressFunc     = NULL;
    m_bCanceled         = FALSE;
    m_bBitmapCreated    = FALSE;
}

CWiaDataCallback::~CWiaDataCallback()
{

}

HRESULT _stdcall CWiaDataCallback::Initialize(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    m_pProgressFunc = pDataAcquireInfo->pProgressFunc;
    m_pDataAcquireInfo = pDataAcquireInfo;
    m_lPageCount = 0;
    return S_OK;
}

HRESULT _stdcall CWiaDataCallback::BandedDataCallback(LONG  lMessage,
                                                      LONG  lStatus,
                                                      LONG  lPercentComplete,
                                                      LONG  lOffset,
                                                      LONG  lLength,
                                                      LONG  lReserved,
                                                      LONG  lResLength,
                                                      BYTE* pbBuffer)
{
    m_bCanceled = FALSE;

    //
    // process callback messages
    //

    switch (lMessage)
    {
    case IT_MSG_DATA_HEADER:
        {
            PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
            m_MemBlockSize                    = pHeader->lBufferSize;

            //
            // If the Buffer is 0, then alloc a 64k chunk (default)
            //

            if(m_MemBlockSize <= 0)
                m_MemBlockSize = 65535;

            if(m_pDataAcquireInfo->bTransferToClipboard) {
                m_pDataAcquireInfo->hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,m_MemBlockSize);
            } else {
                m_pDataAcquireInfo->hBitmapData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,m_MemBlockSize);
            }
            m_BytesTransfered            = 0;
            m_cFormat                    = pHeader->guidFormatID;
        }
        break;

    case IT_MSG_DATA:
        {
            //
            // increment bytes transferred counter
            //

            m_BytesTransfered += lLength;
            if(m_BytesTransfered >= m_MemBlockSize){

                //
                // Alloc more memory for transfer buffer
                //

                m_MemBlockSize += (lLength * 2);

                if(m_pDataAcquireInfo->bTransferToClipboard) {
                    if(m_pDataAcquireInfo->hClipboardData != NULL) {
                        m_pDataAcquireInfo->hClipboardData = GlobalReAlloc(m_pDataAcquireInfo->hClipboardData,
                                                                           m_MemBlockSize, GMEM_MOVEABLE);
                    }
                } else {
                    if(m_pDataAcquireInfo->hBitmapData != NULL) {
                        m_pDataAcquireInfo->hBitmapData = GlobalReAlloc(m_pDataAcquireInfo->hBitmapData,
                                                                           m_MemBlockSize, GMEM_MOVEABLE);
                    }
                }
            }


            if(m_pDataAcquireInfo->bTransferToClipboard) {
                BYTE* pByte = (BYTE*)GlobalLock(m_pDataAcquireInfo->hClipboardData);
                memcpy(pByte + lOffset, pbBuffer, lLength);
                GlobalUnlock(m_pDataAcquireInfo->hClipboardData);
            } else {
                if(m_pDataAcquireInfo->hBitmapData != NULL) {
                    BYTE* pByte = (BYTE*)GlobalLock(m_pDataAcquireInfo->hBitmapData);
                    memcpy(pByte + lOffset, pbBuffer, lLength);
                    GlobalUnlock(m_pDataAcquireInfo->hBitmapData);
                }
            }

            //
            // do any extra image processing here
            //

            if(!m_pDataAcquireInfo->bTransferToClipboard) {
                if(m_cFormat == WiaImgFmt_MEMORYBMP) {

                    if(m_bBitmapCreated) {

                        //
                        // Add data to your bitmap
                        //

                        AddDataToHBITMAP(m_pDataAcquireInfo->hWnd,
                            m_pDataAcquireInfo->hBitmapData,
                            &m_pDataAcquireInfo->hBitmap,
                            lOffset);

                    } else {

                        //
                        // Create your bitmap for display
                        //

                        CreateHBITMAP(m_pDataAcquireInfo->hWnd,
                            m_pDataAcquireInfo->hBitmapData,
                            &m_pDataAcquireInfo->hBitmap,
                            lOffset);
                    }

                }
                else if(m_cFormat == WiaImgFmt_TIFF) {

                }
            }

            //
            // process progress monitor
            //

            if(m_pProgressFunc != NULL){
                if(lPercentComplete == 0)
                    m_bCanceled = m_pProgressFunc(TEXT("Acquiring Image..."),lPercentComplete);
                else {
                    TCHAR szBuffer[MAX_PATH];
                    sprintf(szBuffer,TEXT("%d%% Complete..."),lPercentComplete);
                    m_bCanceled = m_pProgressFunc(szBuffer,lPercentComplete);
                }
            }
        }
        break;

    case IT_MSG_STATUS:
        {

            //
            // process "Status" message
            //

            if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE) {
                if(m_pProgressFunc != NULL)
                    m_bCanceled = m_pProgressFunc(TEXT("Transfer from device"),lPercentComplete);
            }
            else if (lStatus & IT_STATUS_PROCESSING_DATA) {
                if(m_pProgressFunc != NULL)
                    m_bCanceled = m_pProgressFunc(TEXT("Processing Data"),lPercentComplete);
            }
            else if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT) {
                if(m_pProgressFunc != NULL)
                    m_bCanceled = m_pProgressFunc(TEXT("Transfer to Client"),lPercentComplete);
            }
        }
        break;

    case IT_MSG_NEW_PAGE:
        {
            //
            // process "New Page" message
            //

            PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
            m_lPageCount =  pHeader->lPageCount;
            if(m_pProgressFunc != NULL)
                m_bCanceled = m_pProgressFunc(TEXT("New Page"),lPercentComplete);
        }
        break;
    }

    //
    // check use canceled acquire
    //

   if(m_bCanceled)
       return S_FALSE;

   return S_OK;
}

void CWiaDataCallback::AddDataToHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset)
{
    BYTE* pData = (BYTE*)GlobalLock(hBitmapData);
    if(pData) {
        HDC hdc = ::GetDC(hWnd);
        if(*phBitmap == NULL) {
            OutputDebugString(TEXT("HBITMAP is NULL...this is a bad thing\n"));
            return;
        }
        if(hdc == NULL) {
            OutputDebugString(TEXT("HDC is NULL...this is a bad thing\n"));
            return;
        }
        LPBITMAPINFO pbmi   = (LPBITMAPINFO)pData;

        if(hdc != NULL){
            if(pbmi != NULL) {
                if(SetDIBits(hdc,
                    *phBitmap,
                    0,
                    (pbmi->bmiHeader.biHeight < 0?(-(pbmi->bmiHeader.biHeight)):pbmi->bmiHeader.biHeight),
                    pData + sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed),
                    pbmi,
                    DIB_RGB_COLORS) == 0) {

                    DWORD dwLastError = GetLastError();
                    TCHAR buf[10];
                    sprintf(buf,"GetLastError() code = %d\n",dwLastError);
                    OutputDebugString("AddDataToHBITMAP, SetDIBits failed..with ");
                    OutputDebugString(buf);
                }
            }
        }
        GlobalUnlock(hBitmapData);
    } else {
        OutputDebugString(TEXT("No bitmap memory available..\n"));
    }
}
void CWiaDataCallback::CreateHBITMAP(HWND hWnd, HGLOBAL hBitmapData, HBITMAP *phBitmap, LONG lOffset)
{
    HDC hdc             = NULL; // DC to draw to
    LPBITMAPINFO pbmi   = NULL; // pointer to BITMAPINFO struct
    BITMAP  bitmap;
    BYTE *pDib          = NULL; // dib data
    BYTE *pData         = (BYTE*)GlobalLock(hBitmapData);

    if(pData) {

        if(*phBitmap != NULL) {

            //
            // delete old bitmap, if one exists
            //

            OutputDebugString(TEXT("Destroying old HBITMAP..\n"));
            DeleteObject(*phBitmap);
        }

        //
        // get hdc
        //

        hdc = ::GetWindowDC(hWnd);
        if(hdc != NULL){


            //
            // set bitmap header information
            //

            pbmi   = (LPBITMAPINFO)pData;
            if (pbmi != NULL) {

                //
                // create a HBITMAP object
                //

                *phBitmap = ::CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(void **)&pDib,NULL,0);

                if (*phBitmap != NULL) {

                    //
                    // initialize it to white
                    //

                    memset(pDib,255,pbmi->bmiHeader.biSizeImage);

                    //
                    // get HBITMAP
                    //

                    ::GetObject(*phBitmap,sizeof(BITMAP),(LPSTR)&bitmap);
                    m_bBitmapCreated = TRUE;
                } else {
                    OutputDebugString(TEXT("HBITMAP is NULL..\n"));
                }
            } else {
                OutputDebugString(TEXT("BITMAPINFOHEADER is NULL..\n"));
            }

            //
            // release hdc
            //

            ::ReleaseDC(hWnd,hdc);
        } else {
            OutputDebugString(TEXT("DC is NULL\n"));
        }
        GlobalUnlock(hBitmapData);
    } else {
        OutputDebugString(TEXT("No bitmap memory available..\n"));
    }
}

//
// global Interface access functions
//

HRESULT WriteInterfaceToGlobalInterfaceTable(DWORD *pdwCookie, IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    hr = g_pGIT->RegisterInterfaceInGlobal(pIWiaItem, IID_IWiaItem,  pdwCookie);
    return hr;
}

HRESULT ReadInterfaceFromGlobalInterfaceTable(DWORD dwCookie, IWiaItem **ppIWiaItem)
{
    HRESULT hr = S_OK;
    hr = g_pGIT->GetInterfaceFromGlobal(dwCookie, IID_IWiaItem, (void**)ppIWiaItem);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__CC503845_B377_4BE0_8AB2_749567CA9F62__INCLUDED_)
#define AFX_STDAFX_H__CC503845_B377_4BE0_8AB2_749567CA9F62__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes

#ifndef DEV_STUDIO_5
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#endif

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CC503845_B377_4BE0_8AB2_749567CA9F62__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\devctrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by devctrl.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DEVCTRL_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDD_CONFIGURE_DIALOG            130
#define IDR_MAINFRAME2                  132
#define IDC_DEVICE_COMBO_BOX            1000
#define IDC_WRITE_SETTINGS_BUTTON       1001
#define IDC_SCAN_BUTTON                 1002
#define IDC_ABORT_SCAN_BUTTON           1003
#define IDC_XRES_EDITBOX                1004
#define IDC_YRES_EDITBOX                1005
#define IDC_XPOS_EDITBOX                1006
#define IDC_YPOS_EDITBOX                1007
#define IDC_XEXT_EDITBOX                1008
#define IDC_YEXT_EDITBOX                1009
#define IDC_DATATYPE_COMBOBOX           1010
#define IDC_CREATE_FILENAME_EDITBOX     1011
#define IDC_CONFIGURE_BUTTON            1012
#define IDC_DEFAULT_PIPE_NAME_EDITBOX   1013
#define IDC_PIPE1_NAME_EDITBOX          1014
#define IDC_PIPE2_NAME_EDITBOX          1015
#define IDC_PIPE3_NAME_EDITBOX          1016
#define IDC_BULK_OUT_COMBOBOX           1021
#define IDC_CREATE_FILE_CHECKBOX        1022
#define IDC_CREATE_BUTTON               1023
#define IDC_STATUS_COMBOBOX             1024
#define IDC_INTERRUPT_COMBOBOX          1025
#define IDC_BULK_IN_COMBOBOX            1026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1024
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\adfdlg.cpp ===
// ADFDlg.cpp : implementation file
//

#include "stdafx.h"
#include "msqscan.h"
#include "ADFDlg.h"
#include "uitables.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[];
extern WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[];
extern WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[];

/////////////////////////////////////////////////////////////////////////////
// CADFDlg dialog


CADFDlg::CADFDlg(ADF_SETTINGS *pADFSettings, CWnd* pParent /*=NULL*/)
    : CDialog(CADFDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CADFDlg)
    m_ADFStatusText = _T("No document feeder is attached..");
    m_NumberOfPages = 1;
    m_pADFSettings = pADFSettings;
    m_MaxPagesAllowed = m_pADFSettings->lDocumentHandlingCapacity;
    m_DocumentHandlingSelectBackup = m_pADFSettings->lDocumentHandlingSelect;
    //}}AFX_DATA_INIT

    if(m_MaxPagesAllowed <= 0){
        m_MaxPagesAllowed = 50; // set to a large max value
    }
}


void CADFDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CADFDlg)    
    DDX_Control(pDX, IDC_ADF_MODE_COMBOBOX, m_ADFModeComboBox);
    DDX_Control(pDX, IDC_NUMBER_OF_PAGES_EDITBOX, m_ScanNumberOfPagesEditBox);
    DDX_Text(pDX, IDC_FEEDER_STATUS_TEXT, m_ADFStatusText);
    DDX_Text(pDX, IDC_NUMBER_OF_PAGES_EDITBOX, m_NumberOfPages);
    DDV_MinMaxUInt(pDX, m_NumberOfPages, 0, m_MaxPagesAllowed);
    DDX_Control(pDX, IDC_SCAN_ALL_PAGES_RADIOBUTTON, m_ScanAllPages);
    DDX_Control(pDX, IDC_SCAN_SPECIFIED_PAGES_RADIOBUTTON, m_ScanNumberOfPages);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CADFDlg, CDialog)
    //{{AFX_MSG_MAP(CADFDlg)
    ON_EN_KILLFOCUS(IDC_NUMBER_OF_PAGES_EDITBOX, OnKillfocusNumberOfPagesEditbox)
    ON_BN_CLICKED(IDC_SCAN_ALL_PAGES_RADIOBUTTON, OnScanAllPagesRadiobutton)
    ON_BN_CLICKED(IDC_SCAN_SPECIFIED_PAGES_RADIOBUTTON, OnScanSpecifiedPagesRadiobutton)
    ON_CBN_SELCHANGE(IDC_ADF_MODE_COMBOBOX, OnSelchangeAdfModeCombobox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CADFDlg message handlers

void CADFDlg::OnKillfocusNumberOfPagesEditbox()
{

    //
    // write number of pages to member variable/forcing validation
    //

    UpdateData(TRUE);
    m_pADFSettings->lPages = m_NumberOfPages;
}

BOOL CADFDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // default to scanning only a single page
    //

    m_ScanNumberOfPages.SetCheck(1);
    OnScanSpecifiedPagesRadiobutton();

    //
    // Initialize Scanner status text
    //

    InitStatusText();

    //
    // Initialize Feeder Mode combo box, and handle
    // special case, for FLATBED selection
    //

    InitFeederModeComboBox();
    OnSelchangeAdfModeCombobox();
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CADFDlg::OnScanAllPagesRadiobutton()
{
    //
    // disable pages edit box
    //

    m_NumberOfPages = 0;
    UpdateData(FALSE);
    m_ScanNumberOfPagesEditBox.EnableWindow(FALSE);
}

void CADFDlg::OnScanSpecifiedPagesRadiobutton()
{
    //
    // enable pages edit box
    //

    m_ScanNumberOfPagesEditBox.EnableWindow(TRUE);
}

VOID CADFDlg::InitStatusText()
{
    for(ULONG index = 0;index < NUM_WIA_DOC_HANDLING_STATUS_ENTRIES;index++) {
        if((m_pADFSettings->lDocumentHandlingStatus &
            g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].lFlagValue) ==
            g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].lFlagValue) {

            //
            // we found a match, so add it to the text
            //

            m_ADFStatusText = g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].szFlagName;
            UpdateData(FALSE);
        }
    }
}

VOID CADFDlg::InitFeederModeComboBox()
{
    //
    // check all three possible modes, FEEDER, FLATBED, and DUPLEX
    //

    ULONG NumModes = 3;
    for(ULONG index = 0;index < NumModes;index++) {
        if((m_pADFSettings->lDocumentHandlingCapabilites &
            g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[index].lFlagValue) ==
            g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[index].lFlagValue) {

            //
            // we found a match, so add it to the combobox along with the flag value
            //

            INT InsertIndex = m_ADFModeComboBox.AddString(g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].szFlagName);
            m_ADFModeComboBox.SetItemData(InsertIndex, g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].lFlagValue);

            //
            // set the combobox to the current setting value using the Document Handling Select
            //

            if((m_pADFSettings->lDocumentHandlingSelect &
                g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].lFlagValue) ==
                g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[index].lFlagValue) {

                m_ADFModeComboBox.SetCurSel(InsertIndex);
            }
        }
    }
}

INT CADFDlg::GetIDAndStringFromDocHandlingStatus(LONG lDocHandlingStatus, TCHAR *pszString)
{
    INT index = 0;
    while(g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].lFlagValue != lDocHandlingStatus && index < NUM_WIA_DOC_HANDLING_STATUS_ENTRIES) {
        index++;
    }

    if(index > NUM_WIA_DOC_HANDLING_STATUS_ENTRIES)
        index = NUM_WIA_DOC_HANDLING_STATUS_ENTRIES;

    lstrcpy(pszString, g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[index].szFlagName);

    return index;
}

void CADFDlg::OnSelchangeAdfModeCombobox()
{
    INT Index = m_ADFModeComboBox.GetCurSel();
    LONG lFlagValue = 0;
    lFlagValue = (LONG)m_ADFModeComboBox.GetItemData(Index);

    //
    // check for FLATBED setting, and adjust UI
    //

    if((lFlagValue & FLATBED) == FLATBED) {        
        m_ScanAllPages.EnableWindow(FALSE);
        m_ScanNumberOfPages.EnableWindow(FALSE);

        if(m_ScanNumberOfPages.GetCheck() == 1) {
            m_ScanNumberOfPagesEditBox.EnableWindow(FALSE);
        }

    } else {
        m_ScanAllPages.EnableWindow(TRUE);
        m_ScanNumberOfPages.EnableWindow(TRUE);

        if(m_ScanNumberOfPages.GetCheck() == 1) {
            m_ScanNumberOfPagesEditBox.EnableWindow(TRUE);
        }
    }
}

void CADFDlg::OnOK()
{
    //
    // get current Mode setting
    //

    LONG lModeflag = 0;

    INT Index = m_ADFModeComboBox.GetCurSel();
    lModeflag = (LONG)m_ADFModeComboBox.GetItemData(Index);
    
    //
    // clear old settings
    //

    m_pADFSettings->lDocumentHandlingSelect = 0;

    //
    // set new settings
    //

    m_pADFSettings->lDocumentHandlingSelect = lModeflag;

    //
    // set page count
    //

    m_pADFSettings->lPages = m_NumberOfPages;

    CDialog::OnOK();
}

void CADFDlg::OnCancel()
{
    m_pADFSettings->lDocumentHandlingSelect = m_DocumentHandlingSelectBackup;
    m_pADFSettings->lPages = 1;
    CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\datatypes.h ===
// DataTypes.h

#ifndef _DATA_H
#define _DATA_H

typedef struct _RANGE_TYPE {
	LONG Min;
	LONG Max;
	LONG Nom;
	LONG Step;
	LONG Current;
} RANGE_TYPE;

typedef struct _SUPPORTED_FORMAT {
	TYMED tymed;
	GUID guidFormat;
} SUPPORTED_FORMAT;

typedef struct _SCANNER_SETTINGS {
	RANGE_TYPE Brightness;
	RANGE_TYPE Contrast;
	RANGE_TYPE Resolution;
	SUPPORTED_FORMAT *pSupportedFormats;	
}SCANNER_SETTINGS;

typedef struct _ADF_SETTINGS {
    LONG lDocumentHandlingCapabilites;
	LONG lDocumentHandlingSelect;
	LONG lDocumentHandlingStatus;
	LONG lDocumentHandlingCapacity;
	LONG lPages;
}ADF_SETTINGS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\msqscan.h ===
// MSQSCAN.h : main header file for the MSQSCAN application
//

#ifndef _MSQSCAN_H
#define _MSQSCAN_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#define WM_UPDATE_PREVIEW WM_USER + 503

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp:
// See MSQSCAN.cpp for the implementation of this class
//

class CMSQSCANApp : public CWinApp
{
public:
    CMSQSCANApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMSQSCANApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CMSQSCANApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\msqscan.cpp ===
// MSQSCAN.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "MSQSCAN.h"
#include "MSQSCANDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp

BEGIN_MESSAGE_MAP(CMSQSCANApp, CWinApp)
    //{{AFX_MSG_MAP(CMSQSCANApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp construction

CMSQSCANApp::CMSQSCANApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMSQSCANApp object

CMSQSCANApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANApp initialization

BOOL CMSQSCANApp::InitInstance()
{
    AfxEnableControlContainer();

    //
    // Initialize COM
    //

    if (SUCCEEDED(CoInitialize(NULL))) {


        // Standard initialization
        // If you are not using these features and wish to reduce the size
        //  of your final executable, you should remove from the following
        //  the specific initialization routines you do not need.

#ifdef _AFXDLL
        Enable3dControls();         // Call this when using MFC in a shared DLL
#else
        Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

        CMSQSCANDlg dlg;
        m_pMainWnd = &dlg;

        switch (dlg.DoModal()) {
        case IDOK:
            break;
        case IDCANCEL:
            break;
        default:
            break;
        }

        //
        // clean up WIA before we uninitialize COM
        //

        dlg.m_WIA.CleanUp();

        if(dlg.m_DataAcquireInfo.hBitmapData != NULL) {
            GlobalUnlock(dlg.m_DataAcquireInfo.hBitmapData);
            GlobalFree(dlg.m_DataAcquireInfo.hBitmapData);
            dlg.m_DataAcquireInfo.hBitmapData = NULL;
        }

        //
        // Uninitialize COM
        //

        CoUninitialize();

    } else {
        AfxMessageBox("COM Failed to initialize correctly");
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\msqscandlg.cpp ===
// MSQSCANDlg.cpp : implementation file
//

#include "stdafx.h"
#include "MSQSCAN.h"
#include "MSQSCANDlg.h"
#include "ProgressDlg.h"
#include "uitables.h"
#include "ADFDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define PIXELS_PER_INCH_FACTOR 32
#define PREVIEW_WINDOW_OFFSET  11

DWORD g_dwCookie = 0;
IGlobalInterfaceTable *g_pGIT = NULL;

//
// global UI lookup tables
//

extern WIA_FORMAT_TABLE_ENTRY   g_WIA_FORMAT_TABLE[];
extern WIA_DATATYPE_TABLE_ENTRY g_WIA_DATATYPE_TABLE[];

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg dialog

CMSQSCANDlg::CMSQSCANDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CMSQSCANDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMSQSCANDlg)
    m_MAX_Brightness = _T("");
    m_MAX_Contrast   = _T("");
    m_MIN_Brightness = _T("");
    m_MIN_Contrast   = _T("");
    m_XResolution    = 0;
    m_YResolution    = 0;
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_DataAcquireInfo.bTransferToClipboard = FALSE;
    m_DataAcquireInfo.bPreview             = TRUE;
    m_DataAcquireInfo.bTransferToFile      = FALSE;
    m_DataAcquireInfo.dwCookie             = 0;
    m_DataAcquireInfo.hBitmap              = NULL;
    m_DataAcquireInfo.hClipboardData       = NULL;
    m_DataAcquireInfo.pProgressFunc        = NULL;
    m_DataAcquireInfo.hBitmapData          = NULL;
    m_pConnectEventCB = NULL;
}

void CMSQSCANDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMSQSCANDlg)
    DDX_Control(pDX, IDC_CHANGE_BOTH_CHECKBOX, m_ChangeBothResolutionsCheckBox);
    DDX_Control(pDX, IDC_EDIT_YRES_SPIN_BUDDY, m_YResolutionBuddy);
    DDX_Control(pDX, IDC_EDIT_XRES_SPIN_BUDDY, m_XResolutionBuddy);
    DDX_Control(pDX, IDC_SCAN_BUTTON, m_ScanButton);
    DDX_Control(pDX, IDC_PREVIEW_BUTTON, m_PreviewButton);
    DDX_Control(pDX, IDC_IMAGE_FILETYPE_COMBO, m_FileTypeComboBox);
    DDX_Control(pDX, IDC_DATATYPE_COMBO, m_DataTypeComboBox);
    DDX_Control(pDX, IDC_CONTRAST_SLIDER, m_ContrastSlider);
    DDX_Control(pDX, IDC_BRIGHTNESS_SLIDER, m_BrightnessSlider);
    DDX_Control(pDX, IDC_PREVIEW_WINDOW, m_PreviewRect);
    DDX_Text(pDX, IDC_MAX_BRIGHTNESS, m_MAX_Brightness);
    DDX_Text(pDX, IDC_MAX_CONTRAST, m_MAX_Contrast);
    DDX_Text(pDX, IDC_MIN_BRIGHTNESS, m_MIN_Brightness);
    DDX_Text(pDX, IDC_MIN_CONTRAST, m_MIN_Contrast);
    DDX_Text(pDX, IDC_EDIT_XRES, m_XResolution);
    DDX_Text(pDX, IDC_EDIT_YRES, m_YResolution);
    DDX_Control(pDX, IDC_DATA_TO_FILE, m_DataToFile);
    DDX_Control(pDX, IDC_DATA_TO_CLIPBOARD, m_DataToClipboard);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CMSQSCANDlg, CDialog)
    //{{AFX_MSG_MAP(CMSQSCANDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_NOTIFY(UDN_DELTAPOS, IDC_EDIT_XRES_SPIN_BUDDY, OnDeltaposEditXresSpinBuddy)
    ON_NOTIFY(UDN_DELTAPOS, IDC_EDIT_YRES_SPIN_BUDDY, OnDeltaposEditYresSpinBuddy)
    ON_EN_SETFOCUS(IDC_EDIT_XRES, OnSetfocusEditXres)
    ON_EN_KILLFOCUS(IDC_EDIT_XRES, OnKillfocusEditXres)
    ON_EN_KILLFOCUS(IDC_EDIT_YRES, OnKillfocusEditYres)
    ON_EN_SETFOCUS(IDC_EDIT_YRES, OnSetfocusEditYres)
    ON_BN_CLICKED(IDC_SCAN_BUTTON, OnScanButton)
    ON_BN_CLICKED(IDC_PREVIEW_BUTTON, OnPreviewButton)
    ON_COMMAND(ID_FILE_CLOSE, OnFileClose)
    ON_COMMAND(ID_FILE_SELECT_DEVICE, OnFileSelectDevice)
    ON_BN_CLICKED(IDC_ADF_SETTINGS, OnAdfSettings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg message handlers

BOOL CMSQSCANDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    //
    // Set radio button setting (Data to File as DEFAULT setting)
    //

    m_DataToFile.SetCheck(1);
    m_DataAcquireInfo.hBitmap = NULL;

    OnFileSelectDevice();

    return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CMSQSCANDlg::OnPaint()
{
    if (IsIconic()) {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CMSQSCANDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg message handlers

BOOL CMSQSCANDlg::InitDialogSettings()
{

    //
    // fill common resolution combo box
    //

    if (InitResolutionEditBoxes()) {

        //
        // fill data type combo box
        //

        if (InitDataTypeComboBox()) {

            //
            // set min/max contrast slider control
            //

            if (InitContrastSlider()) {

                //
                // set min/max brightness slider control
                //

                if (InitBrightnessSlider()) {

                    //
                    // fill supported file type combo box
                    //

                    if (!InitFileTypeComboBox()) {
                        return FALSE;
                    }
                } else {
                    MessageBox("Brightness Slider control failed to initialize");
                    return FALSE;
                }
            } else {
                MessageBox("Contrast Slider control failed to initialize");
                return FALSE;
            }
        } else {
            MessageBox("Data Type combobox failed to initialize");
            return FALSE;
        }
    } else {
        MessageBox("Resolution edit boxes failed to initialize");
        return FALSE;
    }
    return TRUE;
}

BOOL CMSQSCANDlg::InitResolutionEditBoxes()
{

    //
    // Set buddy controls to their "buddy"
    //

    LONG lMin = 0;
    LONG lMax = 0;
    LONG lCurrent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MIN,&lMin);
    if (SUCCEEDED(hr)) {
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MAX,&lMax);
        if (SUCCEEDED(hr)) {
            hr = m_WIA.ReadLong(NULL,WIA_IPS_XRES,&lCurrent);
            if (FAILED(hr)) {
                MessageBox("Application Failed to read x resolution (Min Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read x resolution (Max Setting)");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to read x resolution (Current Setting)");
        return FALSE;
    }

    m_XResolutionBuddy.SetBuddy(GetDlgItem(IDC_EDIT_XRES));
    m_XResolutionBuddy.SetRange(lMin,lMax);
    m_XResolutionBuddy.SetPos(lCurrent);
    m_XResolution = m_XResolutionBuddy.GetPos();

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MIN,&lMin);
    if (SUCCEEDED(hr)) {
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XRES,WIA_RANGE_MAX,&lMax);
        if (SUCCEEDED(hr)) {

            hr = m_WIA.ReadLong(NULL,WIA_IPS_XRES,&lCurrent);
            if (FAILED(hr)) {
                MessageBox("Application Failed to read y resolution (Min Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read y resolution (Max Setting)");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to read y resolution (Current Setting)");
        return FALSE;
    }

    m_YResolutionBuddy.SetBuddy(GetDlgItem(IDC_EDIT_YRES));
    m_YResolutionBuddy.SetRange(lMin,lMax);
    m_YResolutionBuddy.SetPos(lCurrent);
    m_YResolution = m_YResolutionBuddy.GetPos();

    //
    // set current selection, to be scanner's current setting
    //

    UpdateData(FALSE);

    //
    // check 'change both resolutions' check box
    //

    m_ChangeBothResolutionsCheckBox.SetCheck(1);

    return TRUE;
}

BOOL CMSQSCANDlg::InitDataTypeComboBox()
{
    //
    // reset data type combo box
    //

    m_DataTypeComboBox.ResetContent();

    //
    // set current selection, to be scanner's current setting
    //

    //
    // Below is a hard coded supported data type list.  This should be obtained from the
    // device itself. (ie. some scanners may not support color..)
    // This was done for testing purposes.
    //

    ULONG ulCount = 3;
    TCHAR szDataType[MAX_PATH];
    LONG plDataType[3] = {
        WIA_DATA_THRESHOLD,
        WIA_DATA_COLOR,
        WIA_DATA_GRAYSCALE
    };

    for(ULONG index = 0;index < ulCount;index++) {

        //
        // add data type  to combo box
        //

        INT TableIndex  = GetIDAndStringFromDataType(plDataType[index],szDataType);
        INT InsertIndex = m_DataTypeComboBox.AddString(szDataType);
        m_DataTypeComboBox.SetItemData(InsertIndex, TableIndex);
    }

    return TRUE;
}

BOOL CMSQSCANDlg::InitContrastSlider()
{
    LONG lMin = 0;
    LONG lMax = 0;
    LONG lCurrent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_CONTRAST,WIA_RANGE_MIN,&lMin);
    if(SUCCEEDED(hr)){
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_CONTRAST,WIA_RANGE_MAX,&lMax);
        if(SUCCEEDED(hr)) {
            hr = m_WIA.ReadLong(NULL,WIA_IPS_CONTRAST,&lCurrent);
            if(FAILED(hr)){
                MessageBox("Application Failed to read contrast (Current Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read contrast (Max Setting)");
            return FALSE;
        }
    }else {
        MessageBox("Application Failed to read contrast (Min Setting)");
        return FALSE;
    }

    m_ContrastSlider.SetRange(lMin,lMax,TRUE);
    m_ContrastSlider.SetPos(lCurrent);
    m_ContrastSlider.SetTicFreq(lMax/11);

    m_MIN_Contrast.Format("%d",lMin);
    m_MAX_Contrast.Format("%d",lMax);

    UpdateData(FALSE);

    //
    // set current selection, to be scanner's current setting
    //

    m_DataTypeComboBox.SetCurSel(0);
    return TRUE;
}

BOOL CMSQSCANDlg::InitBrightnessSlider()
{
    LONG lMin = 0;
    LONG lMax = 0;
    LONG lCurrent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_BRIGHTNESS,WIA_RANGE_MIN,&lMin);
    if (SUCCEEDED(hr)) {
        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_BRIGHTNESS,WIA_RANGE_MAX,&lMax);
        if (SUCCEEDED(hr)) {
            hr = m_WIA.ReadLong(NULL,WIA_IPS_BRIGHTNESS,&lCurrent);
            if (FAILED(hr)) {
                MessageBox("Application Failed to read brightness (Current Setting)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to read brightness (Max Setting)");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to read brightness (Min Setting)");
        return FALSE;
    }

    m_BrightnessSlider.SetRange(lMin,lMax,TRUE);
    m_BrightnessSlider.SetPos(lCurrent);
    m_BrightnessSlider.SetTicFreq(lMax/11);

    m_MIN_Brightness.Format("%d",lMin);
    m_MAX_Brightness.Format("%d",lMax);

    UpdateData(FALSE);

    //
    // set current selection, to be scanner's current setting
    //

    return TRUE;
}

BOOL CMSQSCANDlg::InitFileTypeComboBox()
{
    //
    // reset file type combo box
    //

    m_FileTypeComboBox.ResetContent();

    HRESULT hr = S_OK;
    TCHAR szguidFormat[MAX_PATH];

    //
    // set current selection, to be scanner's current setting
    //

    //
    // enumerate supported file types
    //

    WIA_FORMAT_INFO *pSupportedFormats = NULL;
    ULONG ulCount = 0;

    hr = m_WIA.EnumerateSupportedFormats(NULL, &pSupportedFormats, &ulCount);
    if(SUCCEEDED(hr)) {

        //
        // filter out TYMED_FILE formats only
        //

        for(ULONG index = 0;index < ulCount;index++) {
            if(pSupportedFormats[index].lTymed == TYMED_FILE) {

                //
                // add supported file format to combo box
                //

                INT TableIndex  = GetIDAndStringFromGUID(pSupportedFormats[index].guidFormatID,szguidFormat);
                INT InsertIndex = m_FileTypeComboBox.AddString(szguidFormat);
                m_FileTypeComboBox.SetItemData(InsertIndex, TableIndex);
            }
        }

        //
        // free the memory allocated by the CWIA call
        //

        GlobalFree(pSupportedFormats);
        m_FileTypeComboBox.SetCurSel(0);
        return TRUE;
    }
    return FALSE;
}

BOOL CMSQSCANDlg::SetDeviceNameToWindowTitle(BSTR bstrDeviceName)
{
    //
    // convert BSTR to a CString
    //

    CString DeviceName = bstrDeviceName;

    //
    // write the new title to the window
    //

    SetWindowText("Microsoft Quick Scan: [ " + DeviceName + " ]");
    return TRUE;
}

void CMSQSCANDlg::OnDeltaposEditXresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_YResolution = (pNMUpDown->iPos + pNMUpDown->iDelta);
        UpdateData(FALSE);
    }
    *pResult = 0;
}

void CMSQSCANDlg::OnDeltaposEditYresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = (pNMUpDown->iPos + pNMUpDown->iDelta);
        UpdateData(FALSE);
    }
    *pResult = 0;
}

void CMSQSCANDlg::OnSetfocusEditXres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = m_YResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnKillfocusEditXres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_YResolution = m_XResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnKillfocusEditYres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = m_YResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnSetfocusEditYres()
{
    UpdateData(TRUE);
    if(m_ChangeBothResolutionsCheckBox.GetCheck() == 1) {
        m_XResolution = m_YResolution;
        UpdateData(FALSE);
    }
}

void CMSQSCANDlg::OnScanButton()
{
    memset(m_DataAcquireInfo.szFileName,0,sizeof(m_DataAcquireInfo.szFileName));

    if(m_DataToFile.GetCheck() == 1) {
        
        //
        // scan to file
        //

        m_DataAcquireInfo.bTransferToFile = TRUE;

        //
        // allow user to set the file name
        //

        CHAR szFilter[256];
        memset(szFilter,0,sizeof(szFilter));
        CFileDialog FileDialog(FALSE);

        //
        // Get filter from selected combobox (file type)
        //

        INT CurrentSelection = m_FileTypeComboBox.GetCurSel();
        m_FileTypeComboBox.GetLBText(CurrentSelection, szFilter);
        FileDialog.m_ofn.lpstrFilter = szFilter;

        //
        // Show the SaveAs dialog to user
        //

        if(FileDialog.DoModal() == IDOK) {

            //
            // save user selected filename
            //

            strcpy(m_DataAcquireInfo.szFileName,FileDialog.m_ofn.lpstrFile);
            DeleteFile(m_DataAcquireInfo.szFileName);
        } else {

            //
            // do nothing... the user decided not to enter a file name
            //

            return;
        }

    } else {

        //
        // scan to clipboard
        //

        m_DataAcquireInfo.bTransferToFile = FALSE;
        m_DataAcquireInfo.bTransferToClipboard = TRUE;
    }

    //
    // Write settings from dialog to device
    //

    if(WriteScannerSettingsToDevice()) {

        ADF_SETTINGS ADFSettings;
        if(SUCCEEDED(ReadADFSettings(&ADFSettings))){

            //
            // check file type, and warn user about BMP files.
            //

            CHAR szFormat[256];
            memset(szFormat,0,sizeof(szFormat));
        
            INT FILEFORMAT = m_FileTypeComboBox.GetCurSel();
            m_FileTypeComboBox.GetLBText(FILEFORMAT, szFormat);
            if (NULL != strstr(szFormat,"BMP")) {
                if(ADFSettings.lPages > 1) {
                    MessageBox(TEXT("BMP Files will only save the last page scanned, because there\nis no Multi-page BMP file format."),TEXT("BMP File Format Warning"),MB_ICONWARNING);
                } else if(ADFSettings.lPages == 0) {
                    MessageBox(TEXT("BMP Files will only save the last page scanned, because there\nis no Multi-page BMP file format."),TEXT("BMP File Format Warning"),MB_ICONWARNING);
                }
            }
        }

        //
        // create progress dialog object
        //

        CProgressDlg ProgDlg(this);

        //
        // set preview flag, and data acquire information
        //

        m_DataAcquireInfo.bPreview = FALSE; // this is a 'final' scan
        ProgDlg.SetAcquireData(&m_DataAcquireInfo);

        //
        // activate scan progress dialog
        //

        ProgDlg.DoModal();

        if(m_DataAcquireInfo.bTransferToClipboard ) {

            //
            // Put memory on clipboard
            //

            PutDataOnClipboard();
            m_DataAcquireInfo.bTransferToClipboard  = FALSE;
        }
    }
}

void CMSQSCANDlg::OnPreviewButton()
{

    memset(m_DataAcquireInfo.szFileName,0,sizeof(m_DataAcquireInfo.szFileName));
    m_DataAcquireInfo.bTransferToFile = FALSE;

    //
    // Write settings from dialog to device
    //

    if(WriteScannerSettingsToDevice(TRUE)) {

        //
        // create progress dialog object
        //

        CProgressDlg ProgDlg(this);

        //
        // set preview flag, and data acquire information
        //

        m_DataAcquireInfo.bPreview = TRUE; // this is a 'preview' scan
        if(m_DataAcquireInfo.hBitmapData != NULL) {
            GlobalUnlock(m_DataAcquireInfo.hBitmapData);

            //
            // free previous preview scan
            //

            GlobalFree(m_DataAcquireInfo.hBitmapData);
            m_DataAcquireInfo.hBitmapData = NULL;
        }

        ProgDlg.SetAcquireData(&m_DataAcquireInfo);

        //
        // activate scan progress dialog
        //

        ProgDlg.DoModal();
        Invalidate();
    }
}

INT CMSQSCANDlg::GetIDAndStringFromGUID(GUID guidFormat, TCHAR *pszguidString)
{
    INT index = 0;
    while(*(g_WIA_FORMAT_TABLE[index].pguidFormat) != guidFormat && index < NUM_WIA_FORMAT_INFO_ENTRIES) {
        index++;
    }

    if(index > NUM_WIA_FORMAT_INFO_ENTRIES)
        index = NUM_WIA_FORMAT_INFO_ENTRIES;

    lstrcpy(pszguidString, g_WIA_FORMAT_TABLE[index].szFormatName);

    return index;
}

GUID CMSQSCANDlg::GetGuidFromID(INT iID)
{
    return *(g_WIA_FORMAT_TABLE[iID].pguidFormat);
}

LRESULT CMSQSCANDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    if(message == WM_UPDATE_PREVIEW) {
        m_PreviewWindow.SetHBITMAP(m_DataAcquireInfo.hBitmap);
    }
    return CDialog::WindowProc(message, wParam, lParam);
}

INT CMSQSCANDlg::GetIDAndStringFromDataType(LONG lDataType, TCHAR *pszString)
{
    INT index = 0;
    while(g_WIA_DATATYPE_TABLE[index].lDataType != lDataType && index < NUM_WIA_DATATYPE_ENTRIES) {
        index++;
    }

    if(index > NUM_WIA_DATATYPE_ENTRIES)
        index = NUM_WIA_DATATYPE_ENTRIES;

    lstrcpy(pszString, g_WIA_DATATYPE_TABLE[index].szDataTypeName);

    return index;
}

LONG CMSQSCANDlg::GetDataTypeFromID(INT iID)
{
    return (g_WIA_DATATYPE_TABLE[iID].lDataType);
}

BOOL CMSQSCANDlg::WriteScannerSettingsToDevice(BOOL bPreview)
{
    HRESULT hr = S_OK;
    int SelectionIndex = 0;
    int TableIndex = 0;
    SelectionIndex = m_DataTypeComboBox.GetCurSel();
    TableIndex = (int)m_DataTypeComboBox.GetItemData(SelectionIndex);

    //
    // Set data type
    //

    hr = m_WIA.WriteLong(NULL,WIA_IPA_DATATYPE,GetDataTypeFromID(TableIndex));

    if(SUCCEEDED(hr)){
        LONG lBrightness = m_BrightnessSlider.GetPos();

        //
        // Set Brightness
        //

        hr = m_WIA.WriteLong(NULL,WIA_IPS_BRIGHTNESS,lBrightness);
        if(SUCCEEDED(hr)){
            LONG lContrast = m_ContrastSlider.GetPos();

            //
            // Set Contrast
            //

            hr = m_WIA.WriteLong(NULL,WIA_IPS_CONTRAST,lContrast);
            if(FAILED(hr)) {
                MessageBox("Application Failed to set Data Type");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to set Brightness");
            return FALSE;
        }
    } else {
        MessageBox("Application Failed to set Data Type");
        return FALSE;
    }

    //
    // Reset selection rect, to be full bed.
    // This is good to do if you want a solid starting
    // place, for extent setting
    //

    if(!ResetWindowExtents()) {
        return FALSE;
    }

    if(bPreview) {

        //
        // set to preview  X resolution
        //

        hr = m_WIA.WriteLong(NULL,WIA_IPS_XRES,PREVIEW_RES);
        if(SUCCEEDED(hr)) {

            //
            // set to preview  Y resolution
            //

            hr = m_WIA.WriteLong(NULL,WIA_IPS_YRES,PREVIEW_RES);
            if(SUCCEEDED(hr)) {

                //
                // set to memory bitmap for preview display
                //

                hr = m_WIA.WriteGuid(NULL,WIA_IPA_FORMAT,WiaImgFmt_MEMORYBMP);
                if(FAILED(hr)) {
                    MessageBox("Application Failed to set format to Memory BMP");
                    return FALSE;
                }
            } else {
                MessageBox("Application Failed to set Y Resolution (Preview)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to set X Resolution (Preview)");
            return FALSE;
        }

    } else {

        //
        // Are we scanning to the clipboard??
        //

        if(m_DataAcquireInfo.bTransferToClipboard ) {

            //
            // Do only Banded transfer, and WiaImgFmt_MEMORYBMP for clipboard
            // transfers. (This application can only do this function using
            // those specific settings).
            // Note: Other applications are not restricted by this. This is
            //       is a design issue with this sample only!!!
            //

            //
            // set to memory bitmap for clipboard scanning
            //

            hr = m_WIA.WriteGuid(NULL,WIA_IPA_FORMAT,WiaImgFmt_MEMORYBMP);
            if(FAILED(hr)) {
                MessageBox("Memory BMP could not be set to Device");
                return FALSE;
            }
        }

        //
        // write dialog setting for resolution
        //

        UpdateData(TRUE);

        //
        // set X resolution
        //

        hr = m_WIA.WriteLong(NULL,WIA_IPS_XRES,m_XResolution);
        if(SUCCEEDED(hr)) {

            //
            // set Y resolution
            //

            hr = m_WIA.WriteLong(NULL,WIA_IPS_YRES,m_YResolution);
            if(FAILED(hr)) {
                MessageBox("Application Failed to set Y Resolution (Preview)");
                return FALSE;
            }
        } else {
            MessageBox("Application Failed to set X Resolution (Preview)");
            return FALSE;
        }

        //
        // write extent values
        //

        CRect SelectionRect;
        m_PreviewWindow.GetSelectionRect(SelectionRect);

        CRect PreviewRect;
        m_PreviewWindow.GetWindowRect(PreviewRect);

        LONG lXPos = 0;
        LONG lYPos = 0;
        LONG lMaxXExtent = 0;
        LONG lMaxYExtent = 0;
        LONG lXExtent = 0;
        LONG lYExtent = 0;

        hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XEXTENT,WIA_RANGE_MAX,&lMaxXExtent);
        if(SUCCEEDED(hr)) {
            hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_YEXTENT,WIA_RANGE_MAX,&lMaxYExtent);
            if(FAILED(hr)) {
                MessageBox("Application failed to read y extent (Max value)");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to read x extent (Max value)");
            return FALSE;
        }

        FLOAT fxRatio = ((FLOAT)lMaxXExtent/(FLOAT)PreviewRect.Width());
        FLOAT fyRatio = ((FLOAT)lMaxYExtent/(FLOAT)PreviewRect.Height());

        lXPos = (LONG)(SelectionRect.left * fxRatio);
        lYPos = (LONG)(SelectionRect.top * fyRatio);

        lXExtent = (LONG)(SelectionRect.Width() * fxRatio);
        lYExtent = (LONG)(SelectionRect.Height() * fyRatio);

        hr = m_WIA.WriteLong(NULL,WIA_IPS_XPOS,lXPos);
        if(SUCCEEDED(hr)) {
            hr = m_WIA.WriteLong(NULL,WIA_IPS_YPOS,lYPos);
            if(SUCCEEDED(hr)) {
                hr = m_WIA.WriteLong(NULL,WIA_IPS_XEXTENT,lXExtent);
                if(SUCCEEDED(hr)) {
                    hr = m_WIA.WriteLong(NULL,WIA_IPS_YEXTENT,lYExtent);
                    if(FAILED(hr)){
                        MessageBox("Application failed to set Y Extent");
                        return FALSE;
                    }
                } else {
                    MessageBox("Application failed to set X Extent");
                    return FALSE;
                }
            }else {
                MessageBox("Application failed to set Y Position");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to set X Position");
            return FALSE;
        }
    }
    return TRUE;
}

void CMSQSCANDlg::OnFileClose()
{
    CDialog::OnOK();
}

void CMSQSCANDlg::OnFileSelectDevice()
{
    CRect DialogClientRect;

    GetClientRect(DialogClientRect);

    //
    // use scan window place holder, as template for placing the scan
    // preview window
    //

    CRect WindowRect;
    m_PreviewRect.GetWindowRect(WindowRect);
    ScreenToClient(WindowRect);

    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,(void**)&g_pGIT);

    if(SUCCEEDED(hr)) {

        hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
            IID_IWiaDevMgr,(void**)&m_pIWiaDevMgr);

        if (SUCCEEDED(hr)) {
           
            //
            // An example on how to register for Device Connection Events
            //

            m_pConnectEventCB = new CEventCallback;
            if (m_pConnectEventCB) {

                IWiaEventCallback* pIWiaEventCallback = NULL;
                IUnknown*       pIUnkRelease;

                // register connected event
                m_pConnectEventCB->Initialize(ID_WIAEVENT_CONNECT);
                m_pConnectEventCB->QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);

                GUID guidConnect = WIA_EVENT_DEVICE_CONNECTED;
                hr = m_pIWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                                   NULL,
                                                                   &guidConnect,
                                                                   pIWiaEventCallback,
                                                                   &pIUnkRelease);

                m_pConnectEventCB->m_pIUnkRelease = pIUnkRelease;                
                               
                //
                // An Example on how to register for events with this application 
                //

                WCHAR szMyApplicationLaunchPath[MAX_PATH];
                memset(szMyApplicationLaunchPath,0,sizeof(szMyApplicationLaunchPath));
                GetModuleFileNameW(NULL,szMyApplicationLaunchPath,sizeof(szMyApplicationLaunchPath));
                BSTR bstrMyApplicationLaunchPath = SysAllocString(szMyApplicationLaunchPath);
                
                WCHAR szMyApplicationName[MAX_PATH];
                memset(szMyApplicationName,0,sizeof(szMyApplicationName));                                                                    
                HINSTANCE hInst = AfxGetInstanceHandle();
                if(hInst){
                    LoadStringW(hInst, IDS_MYAPPLICATION_NAME, szMyApplicationName, (sizeof(szMyApplicationName)/sizeof(WCHAR)));
                    
                    BSTR bstrMyApplicationName = SysAllocString(szMyApplicationName);
                    
                    GUID guidScanButtonEvent = WIA_EVENT_SCAN_IMAGE;
                    hr = m_pIWiaDevMgr->RegisterEventCallbackProgram(
                                            WIA_REGISTER_EVENT_CALLBACK,
                                            NULL,
                                            &guidScanButtonEvent,
                                            bstrMyApplicationLaunchPath,
                                            bstrMyApplicationName,
                                            bstrMyApplicationName,
                                            bstrMyApplicationLaunchPath);
                    if(FAILED(hr)){
                        MessageBox("Could not Register Application for Events");
                        hr = S_OK; // continue and try to use device
                    }

                    SysFreeString(bstrMyApplicationName);
                    bstrMyApplicationName = NULL;

                }
                SysFreeString(bstrMyApplicationLaunchPath);
                bstrMyApplicationLaunchPath = NULL;                

            }            
            if (SUCCEEDED(hr)) {

                //
                // select your scanning device here
                //

                IWiaItem *pIWiaRootItem = NULL;

                hr = m_pIWiaDevMgr->SelectDeviceDlg(m_hWnd,StiDeviceTypeScanner,0,NULL,&pIWiaRootItem);
                if (hr == S_OK) {

                    //
                    // Write interface to Global Interface Table
                    //

                    hr = WriteInterfaceToGlobalInterfaceTable(&m_DataAcquireInfo.dwCookie,
                                                              pIWiaRootItem);
                    if (SUCCEEDED(hr)) {

                        //
                        // save root item (device) created
                        //

                        m_WIA.SetRootItem(pIWiaRootItem);

                        //
                        // query selected device for it's name
                        //

                        BSTR bstrDeviceName;
                        hr = m_WIA.ReadStr(pIWiaRootItem,WIA_DIP_DEV_NAME,&bstrDeviceName);
                        if (SUCCEEDED(hr)) {
                            SetDeviceNameToWindowTitle(bstrDeviceName);
                            SysFreeString(bstrDeviceName);
                        }

                        //
                        // query selected device for scanner bed size, so we can create
                        // a scanner preview window
                        //

                        LONG MaxScanBedWidth  = 0;
                        LONG MaxScanBedHeight = 0;
                        FLOAT fRatio     = 0;
                        FLOAT fXFactor   = 0.0f;
                        FLOAT fYFactor   = 0.0f;
                        FLOAT fTheFactor = 0.0f;

                        m_WIA.ReadLong(pIWiaRootItem,WIA_DPS_HORIZONTAL_BED_SIZE,&MaxScanBedWidth);
                        m_WIA.ReadLong(pIWiaRootItem,WIA_DPS_VERTICAL_BED_SIZE,&MaxScanBedHeight);

                        fRatio = (FLOAT)((FLOAT)MaxScanBedHeight / (FLOAT)MaxScanBedWidth);

                        fXFactor = (FLOAT)WindowRect.Width()/(FLOAT)MaxScanBedWidth;
                        fYFactor = (FLOAT)WindowRect.Height()/(FLOAT)MaxScanBedHeight;

                        if (fXFactor > fYFactor)
                            fTheFactor = fYFactor;
                        else
                            fTheFactor = fXFactor;

                        //
                        // adjust the pixel returned size so it will fit on the dialog correctly
                        //

                        WindowRect.right = (LONG)(fTheFactor * MaxScanBedWidth) + WindowRect.left;
                        WindowRect.bottom = (LONG)(fTheFactor * MaxScanBedHeight) + WindowRect.top;
                        //WindowRect.right = (MaxScanBedWidth/PIXELS_PER_INCH_FACTOR);
                        //WindowRect.bottom = (LONG)(WindowRect.right * fRatio);

                        //
                        // check scanner bed size, against actual window size, and adjust
                        //

                        if (DialogClientRect.bottom < WindowRect.bottom) {
                            CRect DialogRect;
                            GetWindowRect(DialogRect);
                            DialogRect.InflateRect(0,0,0,(WindowRect.bottom - DialogClientRect.bottom) + 10);
                            MoveWindow(DialogRect);
                        }
                    } else {
                        MessageBox("Failed to Set IWiaRootItem Interface in to Global Interface Table");
                    }

                } else {
                    MessageBox("No Scanner was selected.");
                    return;
                }
            } else {
                MessageBox("Could not Register for Device Disconnect Events");
            }

            m_PreviewWindow.DestroyWindow();

            //
            // create the preview window
            //

            if(!m_PreviewWindow.Create(NULL,
                                   TEXT("Preview Window"),
                                   WS_CHILD|WS_VISIBLE,
                                   WindowRect,
                                   this,
                                   PREVIEW_WND_ID)){
                MessageBox("Failed to create preview window");
                return;
            }

            m_DataAcquireInfo.hWnd = m_PreviewWindow.m_hWnd;

            //
            // intialize selection rect to entire bed for preview
            //

            m_PreviewWindow.SetPreviewRect(WindowRect);

            //
            // InitDialogSettings
            //

            InitDialogSettings();

        } else {
            MessageBox("CoCreateInstance for WIA Device Manager failed");
            return;
        }
    } else {
        MessageBox("CoCreateInstance for Global Interface Table failed");
        return;
    }
}

BOOL CMSQSCANDlg::PutDataOnClipboard()
{
    BOOL bSuccess = FALSE;
    if(OpenClipboard()){
        if(EmptyClipboard()){
            BYTE* pbBuf = (BYTE*)GlobalLock(m_DataAcquireInfo.hClipboardData);
            VerticalFlip(pbBuf);
            GlobalUnlock(m_DataAcquireInfo.hClipboardData);
            if(SetClipboardData(CF_DIB, m_DataAcquireInfo.hClipboardData) == NULL) {
                MessageBox("SetClipboardData failed");
            } else {

                //
                // We succeeded to give memory handle to clipboard
                //

                bSuccess = TRUE;
            }
        } else {
            MessageBox("EmptyClipboard failed");
        }
        if (!CloseClipboard()) {
            MessageBox("CloseClipboard failed");
        }
    } else {
        MessageBox("OpenClipboard failed");
    }

    if(!bSuccess) {

        //
        // Free the memory ourselves, because the Clipboard failed to accept it.
        //

        GlobalFree(m_DataAcquireInfo.hClipboardData);
    }

    //
    // Set handle to NULL, to mark it fresh when scanning more data.
    // This handle is now owned by the Clipbpard...so freeing it would be a bad idea.
    //

    m_DataAcquireInfo.hClipboardData = NULL;
    return bSuccess;
}

VOID CMSQSCANDlg::VerticalFlip(BYTE *pBuf)
{
    HRESULT             hr = S_OK;
    LONG                lHeight;
    LONG                lWidth;
    BITMAPINFOHEADER    *pbmih;
    PBYTE               pTop    = NULL;
    PBYTE               pBottom = NULL;

    pbmih = (BITMAPINFOHEADER*) pBuf;

    if (pbmih->biHeight > 0) {
        return;
    }

    pTop = pBuf + pbmih->biSize + ((pbmih->biClrUsed) * sizeof(RGBQUAD));
    lWidth = ((pbmih->biWidth * pbmih->biBitCount + 31) / 32) * 4;
    pbmih->biHeight = abs(pbmih->biHeight);
    lHeight = pbmih->biHeight;

    PBYTE pTempBuffer = (PBYTE)LocalAlloc(LPTR, lWidth);

    if (pTempBuffer) {
        LONG  index = 0;
        pBottom = pTop + (lHeight-1) * lWidth;
        for (index = 0;index < (lHeight/2);index++) {

            memcpy(pTempBuffer, pTop, lWidth);
            memcpy(pTop, pBottom, lWidth);
            memcpy(pBottom,pTempBuffer, lWidth);

            pTop    += lWidth;
            pBottom -= lWidth;
        }
        LocalFree(pTempBuffer);
    }
}

BOOL CMSQSCANDlg::ResetWindowExtents()
{

    LONG lMaxXExtent = 0;
    LONG lMaxYExtent = 0;
    HRESULT hr = S_OK;

    hr = m_WIA.WriteLong(NULL,WIA_IPS_XPOS,0);
    if(SUCCEEDED(hr)) {
        hr = m_WIA.WriteLong(NULL,WIA_IPS_YPOS,0);
        if(SUCCEEDED(hr)){
            hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_XEXTENT,WIA_RANGE_MAX,&lMaxXExtent);
            if(SUCCEEDED(hr)){
                hr = m_WIA.ReadRangeLong(NULL,WIA_IPS_YEXTENT,WIA_RANGE_MAX,&lMaxYExtent);
                if(SUCCEEDED(hr)){
                    hr = m_WIA.WriteLong(NULL,WIA_IPS_XEXTENT,lMaxXExtent);
                    if(SUCCEEDED(hr)){
                        hr = m_WIA.WriteLong(NULL,WIA_IPS_YEXTENT,lMaxYExtent);
                        if(FAILED(hr)) {
                            MessageBox("Application failed to write y extent");
                            return FALSE;
                        }
                    } else {
                        MessageBox("Application failed to write x extent");
                        return FALSE;
                    }
                } else {
                    MessageBox("Application failed to read y extent");
                    return FALSE;
                }
            } else {
                MessageBox("Application failed to read x extent");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to write y pos");
            return FALSE;
        }
    } else {
        MessageBox("Application failed to write x pos");
        return FALSE;
    }
    return TRUE;
}

BOOL CMSQSCANDlg::ReadADFSettings(ADF_SETTINGS *pADFSettings)
{

//#define USE_FAKE_ADFCAPS
#ifdef USE_FAKE_ADFCAPS
    pADFSettings->lDocumentHandlingCapabilites = FEED|       // Feeder
                                                 FLAT|       // Flatbed
                                                 DUP;        // Duplex
    pADFSettings->lDocumentHandlingCapacity    = 20;         // 20 pages max
    pADFSettings->lDocumentHandlingSelect      = FLATBED|    // Feeder Mode is ON
                                                 FRONT_FIRST|// scan front page first
                                                 FRONT_ONLY; // scan front only

    pADFSettings->lDocumentHandlingStatus      = FLAT_READY; // Feeder is ready
    pADFSettings->lPages = 1;                                // Initialize pages to 1
    return TRUE;

#endif

    HRESULT hr = S_OK;
    if(pADFSettings!= NULL) {

        //
        // Read Settings From Root Item
        //

        IWiaItem *pRootItem = NULL;
        pRootItem = m_WIA.GetRootItem();

        if(pRootItem != NULL) {
            hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_SELECT,&pADFSettings->lDocumentHandlingSelect);
            if(SUCCEEDED(hr)){
                hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES,&pADFSettings->lDocumentHandlingCapabilites);
                if(SUCCEEDED(hr)){
                    hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_STATUS,&pADFSettings->lDocumentHandlingStatus);
                    if(SUCCEEDED(hr)){
                        hr = m_WIA.ReadLong(pRootItem,WIA_DPS_PAGES,&pADFSettings->lPages);
                        if (SUCCEEDED(hr)) {
                            hr = m_WIA.ReadLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_CAPACITY,&pADFSettings->lDocumentHandlingCapacity);
                            if (FAILED(hr)) {
                                MessageBox("Application failed to read the Document Handling Capacity");
                                return FALSE;
                            }
                        } else {
                            MessageBox("Application failed to read the Pages Property");
                            return FALSE;
                        }
                    }  else {
                        MessageBox("Application failed to read the Document Handling Status");
                        return FALSE;
                    }
                }  else {
                    MessageBox("Application failed to read the Document Handling Capabilites");
                    return FALSE;
                }
            } else {
                MessageBox("Application failed to read the Document Handling Select Property");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to find the Root Item.");
            return FALSE;
        }
    } else {
        MessageBox("Application failed to read ADF settings, because the pointer to the Settings structure is NULL");
        return FALSE;
    }
    return TRUE;
}

BOOL CMSQSCANDlg::WriteADFSettings(ADF_SETTINGS *pADFSettings)
{
    HRESULT hr = S_OK;
    if(pADFSettings!= NULL) {

        //
        // Write Settings to the Root Item
        //

        IWiaItem *pRootItem = NULL;
        pRootItem = m_WIA.GetRootItem();

        if(pRootItem != NULL) {
            hr = m_WIA.WriteLong(pRootItem,WIA_DPS_DOCUMENT_HANDLING_SELECT,pADFSettings->lDocumentHandlingSelect);
            if(FAILED(hr)){
                MessageBox("Application failed to write ADF settings, because the Document Handling Select value failed to set");
                return FALSE;
            }
            hr = m_WIA.WriteLong(pRootItem,WIA_DPS_PAGES,pADFSettings->lPages);
            if(FAILED(hr)){
                MessageBox("Application failed to write ADF settings, because the Pages property failed to set");
                return FALSE;
            }
        } else {
            MessageBox("Application failed to find the Root Item.");
            return FALSE;
        }
    } else {
        MessageBox("Application failed to write ADF settings, because the pointer to the Settings structure is NULL");
        return FALSE;
    }
    return TRUE;
}

void CMSQSCANDlg::OnAdfSettings()
{
    if(ReadADFSettings(&m_ADFSettings)) {

        //
        // create ADF dialog object
        //

        CADFDlg ADFDlg(&m_ADFSettings);

        //
        // display setting dialog
        //

        if(ADFDlg.DoModal() == IDOK) {

            //
            // write ADF settings back to the scanner if the user pushes the "OK" button
            //

            WriteADFSettings(&m_ADFSettings);
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CEventCallback message handlers

HRESULT _stdcall CEventCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaEventCallback)
        *ppv = (IWiaEventCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CEventCallback::AddRef()
{
    InterlockedIncrement((long*)&m_cRef);
    return m_cRef;
}

ULONG   _stdcall CEventCallback::Release()
{
	ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
	{
        delete this;
        return 0;
    }
    return ulRefCount;
}

CEventCallback::CEventCallback()
{
    m_cRef = 0;
    m_pIUnkRelease = NULL;
}

CEventCallback::~CEventCallback()
{
    Release();
}

HRESULT _stdcall CEventCallback::Initialize(int EventID)
{
	if((EventID > 1)||(EventID < 0))
		return S_FALSE;

	m_EventID = EventID;
	return S_OK;
}

HRESULT _stdcall CEventCallback::ImageEventCallback(
    const GUID                      *pEventGUID,
    BSTR                            bstrEventDescription,
    BSTR                            bstrDeviceID,
    BSTR                            bstrDeviceDescription,
    DWORD                           dwDeviceType,
    BSTR                            bstrFullItemName,
    ULONG                           *plEventType,
    ULONG                           ulReserved)
{
	switch(m_EventID)
	{
	case ID_WIAEVENT_CONNECT:
		MessageBox(NULL,"a connect event has been trapped...","Event Notice",MB_OK);
		break;
	case ID_WIAEVENT_DISCONNECT:
		MessageBox(NULL,"a disconnect event has been trapped...","Event Notice",MB_OK);
		break;
	default:
		AfxMessageBox("Ah HA!..an event just happened!!!!\n and...I have no clue what is was..");
		break;
	}
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\preview.cpp ===
// Preview.cpp : implementation file
//

#include "stdafx.h"
#include "MSQSCAN.h"
#include "Preview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPreview

CPreview::CPreview()
{
    m_hBitmap = NULL;
}

CPreview::~CPreview()
{
}

void CPreview::GetSelectionRect(RECT *pRect)
{
    CopyRect(pRect,&m_RectTracker.m_rect);
}

void CPreview::SetSelectionRect(RECT *pRect)
{
    CopyRect(&m_RectTracker.m_rect,pRect);
    InvalidateSelectionRect();
}

void CPreview::SetPreviewRect(CRect Rect)
{
    m_PreviewRect.left = 0;
    m_PreviewRect.top = 0;
    m_PreviewRect.right = Rect.Width();
    m_PreviewRect.bottom = Rect.Height();
    
    //
    // set selection rect styles
    //

    m_RectTracker.m_rect.left = PREVIEW_SELECT_OFFSET;
    m_RectTracker.m_rect.top = PREVIEW_SELECT_OFFSET;
    m_RectTracker.m_rect.right = Rect.Width()-PREVIEW_SELECT_OFFSET;
    m_RectTracker.m_rect.bottom = Rect.Height()-PREVIEW_SELECT_OFFSET;
        
    m_RectTracker.m_nStyle = CRectTracker::resizeInside|CRectTracker::dottedLine;
    m_RectTracker.SetClippingWindow(m_RectTracker.m_rect);
}

BEGIN_MESSAGE_MAP(CPreview, CWnd)
    //{{AFX_MSG_MAP(CPreview)   
    ON_WM_LBUTTONDOWN()
    ON_WM_SETCURSOR()
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreview message handlers

void CPreview::OnLButtonDown(UINT nFlags, CPoint point) 
{   
    m_RectTracker.Track(this,point,FALSE,this);
    InvalidateSelectionRect();
    CWnd::OnLButtonDown(nFlags, point);
}

BOOL CPreview::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
    if(m_RectTracker.SetCursor(pWnd,nHitTest))
        return TRUE;
    return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

void CPreview::OnPaint() 
{
    CPaintDC dc(this); // device context for painting       
    
    if(m_hBitmap == NULL) {
        
        CRect TrueRect;        
        GetWindowRect(TrueRect);
        
        //
        // convert to client coords
        //
        
        CWnd* pParent = GetParent();
        if(pParent) {
            ScreenToClient(TrueRect);
            
            //
            // create a white brush
            //
            
            CBrush WhiteBrush;
            WhiteBrush.CreateSolidBrush(RGB(255,255,255));
            
            //
            // select white brush, while saving previously selected brush
            //
            
            CBrush* pOldBrush = dc.SelectObject(&WhiteBrush);
            
            //
            // fill the preview window with white
            //
            
            dc.FillRect(TrueRect,&WhiteBrush);
            
            //
            // put back the previously selected brush
            //
            
            dc.SelectObject(pOldBrush);
            
            //
            // destroy the white brush
            //
            
            WhiteBrush.DeleteObject();
        }
    } else {

        //
        // paint preview bitmap
        //

        PaintHBITMAPToDC();
    }

    //
    // draw the selection rect, over the image
    //

    m_RectTracker.Draw(&dc);
}

void CPreview::InvalidateSelectionRect()
{
    //
    // get parent window
    //

    CWnd* pParent = GetParent();
    
    if(pParent) {
        
        //
        // get your window rect
        //
        
        CRect TrueRect;
        GetWindowRect(TrueRect);
        
        //
        // convert to client coords
        //
        
        pParent->ScreenToClient(TrueRect);
        
        //
        // invalidate through parent, because we are using the parent's DC to
        // draw images.
        //
        
        pParent->InvalidateRect(TrueRect);
    }
}

void CPreview::SetHBITMAP(HBITMAP hBitmap)
{
    m_hBitmap = hBitmap;
    PaintHBITMAPToDC();
}

void CPreview::PaintHBITMAPToDC()
{
    //
    // get hdc
    //

    HDC hMemorydc = NULL;
    HDC hdc = ::GetWindowDC(m_hWnd);
    BITMAP bitmap;

    if(hdc != NULL){
        
        //
        // create a memory dc
        //
        
        hMemorydc = ::CreateCompatibleDC(hdc);
        if(hMemorydc != NULL){
                        
            //
            // select HBITMAP into your hMemorydc
            //
            
            if(::GetObject(m_hBitmap,sizeof(BITMAP),(LPSTR)&bitmap) != 0) {
                HGDIOBJ hGDIObj = ::SelectObject(hMemorydc,m_hBitmap);
                
                RECT ImageRect;
                ImageRect.top = 0;
                ImageRect.left = 0;
                ImageRect.right = bitmap.bmWidth;
                ImageRect.bottom = bitmap.bmHeight;
                                
                ScaleBitmapToDC(hdc,hMemorydc,&m_PreviewRect,&ImageRect);
                                
            } else {
                OutputDebugString(TEXT("Failed GetObject\n"));
            }
        }
        
        //
        // delete hMemorydc
        //
                
        ::DeleteDC(hMemorydc);               
    }
    
    //
    // delete hdc
    //
    
    ::ReleaseDC(m_hWnd,hdc);    
}

void CPreview::ScreenRectToClientRect(HWND hWnd,LPRECT pRect)
{
    POINT PtConvert;

    PtConvert.x = pRect->left;
    PtConvert.y = pRect->top;

    //
    // convert upper left point
    //

    ::ScreenToClient(hWnd,&PtConvert);

    pRect->left = PtConvert.x;
    pRect->top = PtConvert.y;

    PtConvert.x = pRect->right;
    PtConvert.y = pRect->bottom;

    //
    // convert lower right point
    //

    ::ScreenToClient(hWnd,&PtConvert);

    pRect->right = PtConvert.x;
    pRect->bottom = PtConvert.y;

    pRect->bottom-=1;
    pRect->left+=1;
    pRect->right-=1;
    pRect->top+=1;
}

void CPreview::ScaleBitmapToDC(HDC hDC, HDC hDCM, LPRECT lpDCRect, LPRECT lpDIBRect)
{
    ::SetStretchBltMode(hDC, COLORONCOLOR);    

    if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDIBRect)) &&
        (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDIBRect)))
                    ::BitBlt (hDC,                   // hDC
                             lpDCRect->left,        // DestX
                             lpDCRect->top,         // DestY
                             RECTWIDTH(lpDCRect),   // nDestWidth
                             RECTHEIGHT(lpDCRect),  // nDestHeight                             
                             hDCM,
                             0,
                             0,
                             SRCCOPY);        
    else {
                      StretchBlt(hDC,                   // hDC
                                lpDCRect->left,        // DestX
                                lpDCRect->top,         // DestY
                                lpDCRect->right,//ScaledWidth,           // nDestWidth
                                lpDCRect->bottom,//ScaledHeight,          // nDestHeight
                                hDCM,
                                0,                     // SrcX
                                0,                     // SrcY
                                RECTWIDTH(lpDIBRect),  // wSrcWidth
                                RECTHEIGHT(lpDIBRect), // wSrcHeight
                                SRCCOPY);              // dwROP        
    }   
}
/////////////////////////////////////////////////////////////////////////////
// CRectTrackerEx overridden functions

void CRectTrackerEx::AdjustRect( int nHandle, LPRECT lpRect )
{
    //
    // if clipping rect is empty, do nothing
    // 

    if (!m_rectClippingWindow.IsRectEmpty()) {
        if (nHandle == hitMiddle) {

            // user is dragging entire selection around...
            // make sure selection rect does not get out of clipping
            // rect
            //

            CRect rect = lpRect;
            if (rect.right > m_rectClippingWindow.right)
                rect.OffsetRect(m_rectClippingWindow.right - rect.right, 0);
            if (rect.left < m_rectClippingWindow.left)
                rect.OffsetRect(m_rectClippingWindow.left - rect.left, 0);
            if (rect.bottom > m_rectClippingWindow.bottom)
                rect.OffsetRect(0, m_rectClippingWindow.bottom - rect.bottom);
            if (rect.top < m_rectClippingWindow.top)
                rect.OffsetRect(0, m_rectClippingWindow.top - rect.top);
            *lpRect = rect;
        } else {

            //
            // user is resizing the selection rect
            // make sure selection rect does not extend outside of clipping
            // rect
            //

            int *px, *py;

            //
            // get X and Y selection axis
            //

            GetModifyPointers(nHandle, &px, &py, NULL, NULL);           

            if (px != NULL)
                *px = max(min(m_rectClippingWindow.right, *px), m_rectClippingWindow.left);
            if (py != NULL)
                *py = max(min(m_rectClippingWindow.bottom, *py), m_rectClippingWindow.top);

            CRect rect = lpRect;

            //
            // check/adjust X axis
            //

            if (px != NULL && abs(rect.Width()) < m_sizeMin.cx) {
                if (*px == rect.left)
                    rect.left = rect.right;
                else
                    rect.right = rect.left;
            }

            //
            // check/adjust Y axis
            //

            if (py != NULL && abs(rect.Height()) < m_sizeMin.cy) {
                if (*py == rect.top)
                    rect.top = rect.bottom;
                else
                    rect.bottom = rect.top;
            }

            //
            // save the adjusted rectangle
            //

            *lpRect = rect;
        }
    }
}

void CRectTrackerEx::SetClippingWindow(CRect Rect)
{
    m_rectClippingWindow = Rect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\preview.h ===
#ifndef _PREVIEW_H
#define _PREVIEW_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Preview.h : header file
//

#define PREVIEW_SELECT_OFFSET 1

/////////////////////////////////////////////////////////////////////////////
// CRectTrackerEx

class CRectTrackerEx : public CRectTracker
{
public :
	void SetClippingWindow(CRect Rect);
protected:
	CRect m_rectClippingWindow;
	virtual void AdjustRect( int nHandle, LPRECT lpRect );
};

/////////////////////////////////////////////////////////////////////////////
// CPreview window

class CPreview : public CWnd
{
// Construction
public:
	void SetHBITMAP(HBITMAP hBitmap);
	void PaintHBITMAPToDC();
	void ScaleBitmapToDC(HDC hDC, HDC hDCM, LPRECT lpDCRect, LPRECT lpDIBRect);	
	
	void ScreenRectToClientRect(HWND hWnd,LPRECT pRect);	
    
	CRectTrackerEx m_RectTracker;
	CPreview();

// Attributes
public:

// Operations
public:
	void GetSelectionRect(RECT *pRect);
	void SetSelectionRect(RECT *pRect);

	void InvalidateSelectionRect();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreview)
	//}}AFX_VIRTUAL

// Implementation
public:
	void SetPreviewRect(CRect Rect);	
	virtual ~CPreview();

	// Generated message map functions
protected:
	HBITMAP m_hBitmap;
	CRect m_PreviewRect;
	//{{AFX_MSG(CPreview)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\progressdlg.cpp ===
// ProgressDlg.cpp : implementation file
//

#include "stdafx.h"
#include "msqscan.h"
#include "ProgressDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// globals
//

extern IGlobalInterfaceTable * g_pGIT;
HWND g_hWnd = NULL;
BOOL g_bCancel = FALSE; // use global for now, It would be better to use an "event"
BOOL g_bPaintPreview  = TRUE;

/////////////////////////////////////////////////////////////////////////////
// Thread Information

UINT WINAPIV DataAcquireThreadProc(LPVOID pParam)
{
    HRESULT hr = S_OK;

    //
    // Initialize COM, for this thread
    //

    hr = CoInitialize(NULL);

    if(SUCCEEDED(hr)) {

        //
        // set global cancel flag
        //

        g_bCancel = FALSE;

        //
        // prepare, and use the DATA_ACQUIRE_INFO struct
        //

        DATA_ACQUIRE_INFO *pDataAcquireInfo = (DATA_ACQUIRE_INFO*)pParam;
        pDataAcquireInfo->pProgressFunc = &ProgressFunction;
        g_bPaintPreview = pDataAcquireInfo->bPreview;

        IWiaItem *pIWiaRootItem = NULL;

        hr = ReadInterfaceFromGlobalInterfaceTable(pDataAcquireInfo->dwCookie, &pIWiaRootItem);
        if(SUCCEEDED(hr)) {

            //
            // create a new WIA object for data transfer
            //

            CWIA MyWIA;

            //
            // set the Root Item, used for current settings
            //

            MyWIA.SetRootItem(pIWiaRootItem);

            //
            // Initiate WIA Transfer
            //

            if(pDataAcquireInfo->bTransferToFile) {
                hr = MyWIA.DoFileTransfer(pDataAcquireInfo);
                if(SUCCEEDED(hr)) {
                    OutputDebugString(TEXT("WIA File Transfer is complete...\n"));
                } else if(hr == WIA_ERROR_PAPER_EMPTY){
                    MessageBox(NULL,TEXT("Document Feeder is out of Paper"),TEXT("ADF Status Message"),MB_ICONERROR);
                }

            } else {
                hr = MyWIA.DoBandedTransfer(pDataAcquireInfo);
                if(SUCCEEDED(hr)) {
                    OutputDebugString(TEXT("WIA Banded Transfer is complete...\n"));
                }
            }

            //
            // Do Window messaging, while thread processes
            //

            while (!MyWIA.IsAcquireComplete()) {
                MSG message;
                if(::PeekMessage(&message, NULL, 0, 0, PM_NOREMOVE)) {
                    ::TranslateMessage(&message);
                    ::DispatchMessage(&message);
                }
            }
        }

        //
        // Uninitialize COM, for this thread
        //

        CoUninitialize();
    }

    //
    // Post the quit message, to close the progress dialog
    //

    ::PostMessage(g_hWnd, WM_CANCEL_ACQUIRE, 0, 0);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// Progress Callback function

BOOL ProgressFunction(LPTSTR lpszText, LONG lPercentComplete)
{
    ::PostMessage(g_hWnd, WM_STEP_PROGRESS, 0, lPercentComplete);
    ::PostMessage(g_hWnd, WM_UPDATE_PROGRESS_TEXT, 0, (LPARAM)lpszText);

    if(g_bPaintPreview) {

        //
        // make parent update it's preview
        //

        HWND hParentWnd = NULL;
        hParentWnd = GetParent(g_hWnd);
        if(hParentWnd != NULL)
            ::PostMessage(hParentWnd,WM_UPDATE_PREVIEW,0,0);
    }

    return g_bCancel;
}

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

CProgressDlg::CProgressDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CProgressDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CProgressDlg)
    m_ProgressText = _T("");
    m_pDataAcquireThread = NULL;
    //}}AFX_DATA_INIT
}

void CProgressDlg::SetAcquireData(DATA_ACQUIRE_INFO* pDataAcquireInfo)
{
    m_pDataAcquireInfo = pDataAcquireInfo;
}

void CProgressDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CProgressDlg)
    DDX_Control(pDX, IDC_CANCEL, m_CancelButton);
    DDX_Control(pDX, IDC_PROGRESS_CONTROL, m_ProgressCtrl);
    DDX_Text(pDX, IDC_PROGRESS_TEXT, m_ProgressText);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CProgressDlg)
    ON_BN_CLICKED(IDC_CANCEL, OnCancel)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg message handlers

void CProgressDlg::OnCancel()
{

    //
    // suspend the data acquire thread
    //

    m_pDataAcquireThread->SuspendThread();

    //
    // set the global cancel flag
    //

    g_bCancel = TRUE;

    //
    // resume the data acquire thread
    //

    m_pDataAcquireThread->ResumeThread();

    //
    // post a nice, wait message while WIA catches up with the
    // cancel..ie. S_FALSE sent through the callback Interface
    //

    m_ProgressText = TEXT("Please Wait... Your Acquire is being canceled.");
    UpdateData(FALSE);

    //
    // disable the 'cancel' button, to show the user that somthing did happen,
    // when they pushed 'cancel'.
    //

    m_CancelButton.EnableWindow(FALSE);
}

BOOL CProgressDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // set the progress range, 0-100% complete
    //

    m_ProgressCtrl.SetRange(0,100);
    m_ProgressCtrl.SetPos(0);

    //
    // save window handle, for messages
    //

    g_hWnd = m_hWnd;

    //
    // start data acquire thread
    //

    m_pDataAcquireThread = AfxBeginThread(DataAcquireThreadProc, m_pDataAcquireInfo, THREAD_PRIORITY_NORMAL);

    //
    // suspend thread until dialog is ready to acquire
    //

    m_pDataAcquireThread->SuspendThread();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CProgressDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    //
    // Trap progress control message, sent from data acquire thread
    //

    switch(message) {
    case WM_STEP_PROGRESS:

        //
        // step progress control
        //

        m_ProgressCtrl.SetPos((int)lParam);
        break;
    case WM_ACTIVATE:

        //
        // dialog is ready, so resume thread for acquiring data
        //

        m_pDataAcquireThread->ResumeThread();
        break;
    case WM_CANCEL_ACQUIRE:

        //
        // cancel/close dialog
        //

        CDialog::OnOK();
        break;
    default:
        break;
    }

    //
    // handle any special cases
    //

    //
    // if the user has canceled the acquire, do not process another
    // progress text message, because we already have updated them
    // with a 'friendly' wait message.
    //

    if(!g_bCancel) {
        if(message == WM_UPDATE_PROGRESS_TEXT) {
            m_ProgressText = (LPTSTR)lParam;
            UpdateData(FALSE);
        }
    }
    return CDialog::WindowProc(message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\msqscandlg.h ===
// MSQSCANDlg.h : header file
//

#ifndef _MSQSCANDLG_H
#define _MSQSCANDLG_H

#include "Preview.h"

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define PREVIEW_RES 100

#include "datatypes.h"

#define ID_WIAEVENT_CONNECT		0
#define ID_WIAEVENT_DISCONNECT	1

/////////////////////////////////////////////////////////////////////////////
// CEventCallback

class CEventCallback : public IWiaEventCallback
{
private:
   ULONG	m_cRef;		// Object reference count.
   int		m_EventID;	// What kind of event is this callback for?
public:
   IUnknown *m_pIUnkRelease; // release server registration
public:
    // Constructor, initialization and destructor methods.
    CEventCallback();
    ~CEventCallback();

    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall Initialize(int EventID);

    HRESULT _stdcall ImageEventCallback(
        const GUID      *pEventGUID,
        BSTR            bstrEventDescription,
        BSTR            bstrDeviceID,
        BSTR            bstrDeviceDescription,
        DWORD           dwDeviceType,
        BSTR            bstrFullItemName,
        ULONG           *plEventType,
        ULONG           ulReserved);
};

/////////////////////////////////////////////////////////////////////////////
// CMSQSCANDlg dialog

class CMSQSCANDlg : public CDialog
{
// Construction
public:    
    CMSQSCANDlg(CWnd* pParent = NULL);  // standard constructor
    
    //
    // events callback
    //

    CEventCallback* m_pConnectEventCB;

    //
    // scanner preview window
    //

    CPreview m_PreviewWindow;

    //
    // WIA components, WIA device manager, and WIA Wrapper object
    //

    IWiaDevMgr *m_pIWiaDevMgr;
    CWIA m_WIA;
    
    //
    // Data transfer, thread information structure
    //

    DATA_ACQUIRE_INFO m_DataAcquireInfo;    
    ADF_SETTINGS      m_ADFSettings;
    
    //
    // UI <--> device settings helpers
    //

    BOOL InitDialogSettings();
    BOOL InitResolutionEditBoxes();
    BOOL InitDataTypeComboBox();
    BOOL InitContrastSlider();
    BOOL InitBrightnessSlider();
    BOOL InitFileTypeComboBox();
    BOOL ResetWindowExtents();
	BOOL ReadADFSettings(ADF_SETTINGS *pADFSettings);
    BOOL WriteADFSettings(ADF_SETTINGS *pADFSettings);

    BOOL WriteScannerSettingsToDevice(BOOL bPreview = FALSE);

    //
    // UI helpers
    //

    INT  GetIDAndStringFromGUID(GUID guidFormat, TCHAR *pszguidString);
    GUID GetGuidFromID(INT iID);
    INT  GetIDAndStringFromDataType(LONG lDataType, TCHAR *pszguidString);
    LONG GetDataTypeFromID(INT iID);
    BOOL SetDeviceNameToWindowTitle(BSTR bstrDeviceName);
    
    //
    // Image (clipboard manipulation) helpers
    //

    BOOL PutDataOnClipboard();
    VOID VerticalFlip(BYTE *pBuf);
    
// Dialog Data
    //{{AFX_DATA(CMSQSCANDlg)
    enum { IDD = IDD_MSQSCAN_DIALOG };
    CButton m_ChangeBothResolutionsCheckBox;
    CSpinButtonCtrl m_YResolutionBuddy;
    CSpinButtonCtrl m_XResolutionBuddy;
    CButton m_ScanButton;
    CButton m_PreviewButton;
    CComboBox   m_FileTypeComboBox;
    CComboBox   m_DataTypeComboBox;
    CSliderCtrl m_ContrastSlider;
    CSliderCtrl m_BrightnessSlider;
    CStatic m_PreviewRect;
    CString m_MAX_Brightness;
    CString m_MAX_Contrast;
    CString m_MIN_Brightness;
    CString m_MIN_Contrast;
    long    m_XResolution;
    long    m_YResolution;
    CButton m_DataToFile;
    CButton m_DataToClipboard;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMSQSCANDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CMSQSCANDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnDeltaposEditXresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDeltaposEditYresSpinBuddy(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSetfocusEditXres();
    afx_msg void OnKillfocusEditXres();
    afx_msg void OnKillfocusEditYres();
    afx_msg void OnSetfocusEditYres();
    afx_msg void OnScanButton();
    afx_msg void OnPreviewButton();
    afx_msg void OnFileClose();
    afx_msg void OnFileSelectDevice();
	afx_msg void OnAdfSettings();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSQSCANDLG_H__E1A2B3DB_C967_47EF_8487_C4F243D0BC58__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=msqscan
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\msqscan.cpp          \
        ..\msqscandlg.cpp       \
        ..\preview.cpp          \
        ..\uitables.cpp         \
        ..\progressdlg.cpp      \
        ..\cwia.cpp             \
        ..\adfdlg.cpp           \
        ..\msqscan.rc


# Add interlac.cpp if the PNG support is ever fixed

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\wiaguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSQSCAN.rc
//
#define IDD_MSQSCAN_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDB_MSLOGO_BITMAP               130
#define IDD_PROGRESS_DIALOG             131
#define IDR_MSQSCAN_MENU                132
#define IDD_ADF_SETTING_DIALOG          133
#define IDC_PREVIEW_WINDOW              1000
#define PREVIEW_WND_ID                  1001
#define IDC_BRIGHTNESS_SLIDER           1002
#define IDC_CONTRAST_SLIDER             1003
#define IDC_DATATYPE_COMBO              1005
#define IDC_IMAGE_FILETYPE_COMBO        1006
#define IDC_MIN_CONTRAST                1007
#define IDC_MAX_CONTRAST                1008
#define IDC_MIN_BRIGHTNESS              1009
#define IDC_MAX_BRIGHTNESS              1010
#define IDC_PREVIEW_BUTTON              1011
#define IDC_SCAN_BUTTON                 1012
#define IDC_EDIT_XRES                   1015
#define IDC_EDIT_YRES                   1016
#define IDC_EDIT_XRES_SPIN_BUDDY        1017
#define IDC_EDIT_YRES_SPIN_BUDDY        1018
#define IDC_CHANGE_BOTH_CHECKBOX        1019
#define IDC_DATA_TO_FILE                1022
#define IDC_DATA_TO_CLIPBOARD           1023
#define IDC_MSLOGO                      1024
#define IDC_PROGRESS_CONTROL            1025
#define IDC_PROGRESS_TEXT               1026
#define IDC_CANCEL                      1027
#define IDC_ADF_SETTINGS                1029
#define IDC_FEEDER_STATUS_TEXT          1033
#define IDC_ADF_MODE_COMBOBOX           1034
#define IDC_SCAN_ALL_PAGES_RADIOBUTTON  1035
#define IDC_SCAN_SPECIFIED_PAGES_RADIOBUTTON 1036
#define IDC_NUMBER_OF_PAGES_EDITBOX     1037
#define IDC_PAGE_ORDER_COMBOBOX         1039
#define IDS_MYAPPLICATION_NAME          1040
#define ID_FILE_SELECT_DEVICE           32771

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1041
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\progressdlg.h ===
#ifndef _PROGRESSDLG_H
#define _PROGRESSDLG_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ProgressDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CProgressDlg dialog

//
// User defined windows messages
//

#define WM_STEP_PROGRESS        WM_USER + 500
#define WM_CANCEL_ACQUIRE       WM_USER + 501
#define WM_UPDATE_PROGRESS_TEXT WM_USER + 502

class CProgressDlg : public CDialog
{
// Construction
public:
    CProgressDlg(CWnd* pParent = NULL);   // standard constructor
    void SetAcquireData(DATA_ACQUIRE_INFO* pDataAcquireInfo);
    DATA_ACQUIRE_INFO* m_pDataAcquireInfo;
// Dialog Data
    //{{AFX_DATA(CProgressDlg)
    enum { IDD = IDD_PROGRESS_DIALOG };
    CButton       m_CancelButton;
    CProgressCtrl m_ProgressCtrl;
    CString       m_ProgressText;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CProgressDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    CWinThread* m_pDataAcquireThread;

protected:

    // Generated message map functions
    //{{AFX_MSG(CProgressDlg)
    afx_msg void OnCancel();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//
// Thread information
//

UINT WINAPIV DataAcquireThreadProc(LPVOID pParam);

BOOL ProgressFunction(LPTSTR lpszText, LONG lPercentComplete);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\uitables.cpp ===
// UITABLES.CPP

#include "stdafx.h"
#include "uitables.h"

//
// WIA Format Table, for UI display (english only, these should be in a resource file)
//

WIA_FORMAT_TABLE_ENTRY g_WIA_FORMAT_TABLE[NUM_WIA_FORMAT_INFO_ENTRIES] = {
    &WiaImgFmt_UNDEFINED,TEXT("Undefined File")            ,
    &WiaImgFmt_MEMORYBMP,TEXT("Memory Bitmap File (*.BMP)"),
    &WiaImgFmt_BMP,      TEXT("Bitmap File (*.BMP)")       ,
    &WiaImgFmt_EMF,      TEXT("EMF File (*.EMF)")          ,
    &WiaImgFmt_WMF,      TEXT("WMF File (*.WMF)")          ,
    &WiaImgFmt_JPEG,     TEXT("JPEG File (*.JPG)")         ,
    &WiaImgFmt_GIF,      TEXT("GIF File (*.GIF)")          ,
    &WiaImgFmt_TIFF,     TEXT("Tiff File (*.TIF)")         ,
    &WiaImgFmt_EXIF,     TEXT("Exif File (*.XIF)")         ,
    &WiaImgFmt_PHOTOCD,  TEXT("Photo CD File (*.PCD)")     ,
    &WiaImgFmt_FLASHPIX, TEXT("Flash Pix File (*.FPX)")    ,
    &GUID_NULL,       TEXT("Unknown Format GUID (*.???)"),
};

//
// WIA Data Type Table, for UI display (english only, these should be in a resource file)
//

WIA_DATATYPE_TABLE_ENTRY g_WIA_DATATYPE_TABLE[NUM_WIA_DATATYPE_ENTRIES] = {
    WIA_DATA_THRESHOLD,      TEXT("1 bit black and white")     ,
    WIA_DATA_DITHER,         TEXT("Black and white dither")    ,
    WIA_DATA_GRAYSCALE,      TEXT("8 bit grayscale")           ,
    WIA_DATA_COLOR,          TEXT("24 bit color")              ,
    WIA_DATA_COLOR_THRESHOLD,TEXT("8 bit paletted color ")     ,
    WIA_DATA_COLOR_DITHER,   TEXT("Color dither")              ,
    9999,                    TEXT("Unknown Data Type")         ,
};

//
// WIA Document Handling Tables, for UI display (english only, these should be in a resource file)
//

WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_CAPABILITES_TABLE[NUM_WIA_DOC_HANDLING_CAPS_ENTRIES] = {
    FEED,             TEXT("ADF capable"),
    FLAT,             TEXT("Flatbed capable"),
    DUP,              TEXT("Duplex capable"),
    DETECT_FLAT,      TEXT("Flatbed detection capable"),
    DETECT_SCAN,      TEXT("Scan detection capable"),
    DETECT_FEED,      TEXT("ADF detection capable"),
    DETECT_DUP,       TEXT("Duplex detection capable"),
    DETECT_FEED_AVAIL,TEXT("Scanner can automatically detect if an ADF is installed"),
    DETECT_DUP_AVAIL, TEXT("Scanner can automatically detect if Duplex unit is installed"),
    9999,             TEXT("Unknown capability flag value"),
};

WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_STATUS_TABLE[NUM_WIA_DOC_HANDLING_STATUS_ENTRIES] = {
    FEED_READY,   TEXT("Feeder Ready"),
    FLAT_READY,   TEXT("Flatbed Ready"),
    DUP_READY,    TEXT("Duplex Ready"),
    FLAT_COVER_UP,TEXT("Flatbed cover is up"),
    PATH_COVER_UP,TEXT("Pathway is covered up"),
    PAPER_JAM,    TEXT("Paper Jam detected"),
    9999,         TEXT("Unknown status flag value"),
};

WIA_DOCUMENT_HANDLING_TABLE_ENTRY g_WIA_DOCUMENT_HANDLING_SELECT_TABLE[NUM_WIA_DOC_HANDLING_SELECT_ENTRIES] = {
    FEEDER,      TEXT("Feeder Mode"),
    FLATBED,     TEXT("Flatbed Mode"),
    DUPLEX,      TEXT("Duplex Mode"),
    FRONT_FIRST, TEXT("Scan front page first"),
    BACK_FIRST,  TEXT("Scan back page first"),
    FRONT_ONLY,  TEXT("Scan front page only"),
    BACK_ONLY,   TEXT("Scan back page only"),
    NEXT_PAGE,   TEXT("Scan next page"),
    PREFEED,     TEXT("Prefeed the document"),
    AUTO_ADVANCE,TEXT("Auto Advance the feeder"),
    9999,        TEXT("Unknown select flag value"),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  MSQSCAN.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "cwia.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\msqscan\uitables.h ===
// UITABLES.H

#ifndef _UITABLES_H
#define _UITABLES_H

#include "wia.h"
#include "datatypes.h"
#include "sti.h"
#include "uitables.h"

//
// TABLE entry counters
//

#define NUM_WIA_FORMAT_INFO_ENTRIES         12
#define NUM_WIA_DATATYPE_ENTRIES             7
#define NUM_WIA_DOC_HANDLING_CAPS_ENTRIES   10
#define NUM_WIA_DOC_HANDLING_STATUS_ENTRIES  7
#define NUM_WIA_DOC_HANDLING_SELECT_ENTRIES 11

#define WIA_DOC_HANDLING_SELECT_PAGEORDER_INDEX 3

//
// TABLE entry types
//

typedef struct _WIA_FORMAT_TABLE_ENTRY {
	const GUID *pguidFormat;
	TCHAR szFormatName[MAX_PATH];
}WIA_FORMAT_TABLE_ENTRY;

typedef struct _WIA_DATATYPE_TABLE_ENTRY {
	LONG lDataType;
	TCHAR szDataTypeName[MAX_PATH];
}WIA_DATATYPE_TABLE_ENTRY;

typedef struct _WIA_DOCUMENT_HANDLING_TABLE_ENTRY {
	LONG lFlagValue;
	TCHAR szFlagName[MAX_PATH];
}WIA_DOCUMENT_HANDLING_TABLE_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\cwindow.h ===
// CWindow.h
#ifndef _CWINDOW_H
#define _CWINDOW_H

#include <commctrl.h>

#ifndef STRICT
#define WNDPROC FARPROC
#endif

#if !defined(GWLP_USERDATA)
    #define GWLP_USERDATA    GWL_USERDATA
    #define GWLP_WNDPROC     GWL_WNDPROC
    #define DWLP_USER        DWL_USER
    #define DWLP_MSGRESULT   DWL_MSGRESULT
    #define SetWindowLongPtr SetWindowLong
    #define GetWindowLongPtr GetWindowLong
    #define INT_PTR          LONG
#endif

#define WM_PARENT_WM_SIZE WM_USER+900

#define SC_BEGIN_MESSAGE_HANDLERS(className) \
    className *This = NULL;\
    This = (className*)GetWindowLongPtr(hWnd,GWLP_USERDATA);\
    if (This == NULL) \
    {\
        This = new className(hWnd);\
        SetWindowLongPtr(hWnd,GWLP_USERDATA,(INT_PTR)This);\
    }\
    else if (WM_NCDESTROY == uMsg)\
    {\
        delete This;\
        This = NULL;\
        SetWindowLongPtr(hWnd,GWLP_USERDATA,0);\
    }\
    switch (uMsg)

#define SC_HANDLE_MESSAGE(msg,handler) \
    case (msg):\
        {\
            if (This)\
            {\
               return This->handler( wParam, lParam );\
            }\
        }\
        break

#define SC_HANDLE_MESSAGE_CALL_DEFAULT_TREEVIEW() \
        if(gTreeViewWndSysWndProc != NULL) {\
            CallWindowProc(gTreeViewWndSysWndProc, hWnd, uMsg, wParam,lParam);\
        }

#define SC_HANDLE_MESSAGE_CALL_DEFAULT_LISTVIEW() \
        if(gListViewWndSysWndProc != NULL) {\
            CallWindowProc(gListViewWndSysWndProc, hWnd, uMsg, wParam,lParam);\
        }

#define SC_HANDLE_MESSAGE_DEFAULT_TREEVIEW() \
    default:\
        {\
            if (This)\
            {\
                if(/*This->*/gTreeViewWndSysWndProc != NULL) {\
                   return CallWindowProc(/*This->*/gTreeViewWndSysWndProc, hWnd, uMsg, wParam,lParam);\
                }\
            }\
        } \
        break

#define SC_HANDLE_MESSAGE_DEFAULT_LISTVIEW() \
    default:\
        {\
            if (This)\
            {\
                if(/*This->*/gListViewWndSysWndProc != NULL) {\
                   return CallWindowProc(/*This->*/gListViewWndSysWndProc, hWnd, uMsg, wParam,lParam);\
                }\
            }\
        } \
        break

#define SC_FORWARD_MESSAGE(msg,hwndForward)\
    case (msg):\
        {\
            return SendMessage( hwndForward, msg, wParam, lParam );\
        }\
        break

#define SC_END_MESSAGE_HANDLERS() \
    return (DefWindowProc(hWnd,uMsg,wParam,lParam))
    
#define SC_HANDLE_REGISTERED_MESSAGE(msg,handler)\
    if (This && uMsg == This->msg)\
    {\
        return This->handler( wParam, lParam );\
    }

#define SC_BEGIN_DIALOG_MESSAGE_HANDLERS(className) \
    UINT_PTR bRes = FALSE;\
    className *This = (className *)GetWindowLongPtr(hWnd,DWLP_USER);\
    if (WM_INITDIALOG == uMsg)\
    {\
        This = new className( hWnd );\
        SetWindowLongPtr(hWnd,DWLP_USER,(INT_PTR)This);\
    }\
    else if (WM_NCDESTROY == uMsg)\
    {\
        if (This)\
            delete This;\
        This = NULL;\
        SetWindowLongPtr(hWnd,DWLP_USER,(INT_PTR)This);\
    }\
    switch (uMsg)

#define SC_HANDLE_DIALOG_MESSAGE(msg,handler) \
case (msg):\
    {\
        if (This)\
        {\
            LRESULT lRes = This->handler( wParam, lParam );\
            if (WM_CTLCOLORBTN==msg || WM_CTLCOLORDLG==msg || WM_CTLCOLOREDIT==msg || WM_CTLCOLORLISTBOX==msg || WM_CTLCOLORMSGBOX==msg || WM_CTLCOLORSCROLLBAR==msg || WM_CTLCOLORSTATIC==msg)\
                bRes = (UINT_PTR)(lRes);\
            SetWindowLongPtr( hWnd, DWLP_MSGRESULT, (INT_PTR)lRes );\
            bRes = true;\
        }\
    }\
    break

#define SC_HANDLE_REGISTERED_DIALOG_MESSAGE(msg,handler)\
        if (This && uMsg == This->msg)\
        {\
            LRESULT lRes = This->handler( wParam, lParam );\
            SetWindowLongPtr( hWnd, DWLP_MSGRESULT, (INT_PTR)lRes );\
            bRes = true;\
        }

#define SC_END_DIALOG_MESSAGE_HANDLERS() \
    return (bRes)

#define SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()

#define SC_HANDLE_NOTIFY_MESSAGE_CODE(_code,proc)\
    if ((_code) == ((LPNMHDR)lParam)->code)\
        return proc( wParam, lParam )

#define SC_HANDLE_NOTIFY_MESSAGE_CONTROL(_code,id,proc)\
    if ((_code) == ((LPNMHDR)lParam)->code && (id) == (int)wParam)\
        return proc( wParam, lParam )

#define SC_END_NOTIFY_MESSAGE_HANDLERS()\
    return 0;

#define SC_BEGIN_COMMAND_HANDLERS()

#define SC_HANDLE_COMMAND_NOTIFY(nCode,nIdCtl,handler)\
    if (nCode==(int)HIWORD(wParam) && nIdCtl==(int)LOWORD(wParam))\
    {\
        handler( wParam, lParam );\
        return (0);\
    }

#define SC_HANDLE_COMMAND(nIdCtl,handler)\
    if (nIdCtl==(int)LOWORD(wParam))\
    {\
        handler( wParam, lParam );\
        return (0);\
    }

#define SC_END_COMMAND_HANDLERS()\
    return (0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\listviewwnd.h ===
#ifndef _LISTVIEWWINDOW
#define _LISTVIEWWINDOW

#include "stdafx.h"
#include "CWindow.h"

extern WNDPROC gListViewWndSysWndProc;

class CListViewWnd {
private:

public:
    HWND m_hWnd;

    CListViewWnd( HWND hWnd )
    : m_hWnd(hWnd)
    {

    }

    ~CListViewWnd(void)
    {

    }

    static BOOL RegisterClass( HINSTANCE hInstance, LPCTSTR pszClassName )
    {
        WNDCLASSEX wcex;
        ZeroMemory(&wcex,sizeof(wcex));
        wcex.cbSize = sizeof(wcex);
        if (!GetClassInfoEx( hInstance, pszClassName, &wcex )) {
            ZeroMemory(&wcex,sizeof(wcex));
            wcex.cbSize        = sizeof(wcex);
            wcex.style         = 0;
            wcex.lpfnWndProc   = ListViewWndProc;
            wcex.cbClsExtra    = 0;
            wcex.cbWndExtra    = 0;
            wcex.hInstance     = hInstance;
            wcex.hIcon         = 0;
            wcex.hCursor       = ::LoadCursor(NULL, IDC_ARROW);
            wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
            wcex.lpszMenuName  = NULL;
            wcex.lpszClassName = pszClassName;
            wcex.hIconSm       = 0;
            if (!::RegisterClassEx(&wcex)) {
                return FALSE;
            }
            return TRUE;
        }
        return TRUE;
    }

    static HWND Create( LPCTSTR lpWindowName,
                        LPCTSTR lpWindowClassName,
                        DWORD dwStyle,
                        DWORD dwExStyle,
                        int x,
                        int y,
                        int nWidth,
                        int nHeight,
                        HWND hWndParent,
                        HMENU hMenu,
                        HINSTANCE hInstance )
    {

        //
        // register the window class
        //

        if (RegisterClass( hInstance, lpWindowClassName )) {
            HWND hWnd = CreateWindowEx(dwExStyle,
                                  lpWindowClassName,
                                  lpWindowName,
                                  dwStyle,
                                  x,
                                  y,
                                  nWidth,
                                  nHeight,
                                  hWndParent,
                                  hMenu,
                                  hInstance,
                                  NULL );
            SetWindowLongPtr(hWnd,GWLP_USERDATA,NULL);

            gListViewWndSysWndProc = (WNDPROC)SetWindowLongPtr(hWnd,
                                                               GWLP_WNDPROC,
                                                               (LONG)(LONG_PTR)ListViewWndProc);
            return hWnd;
        } else {
            Trace(TEXT("RegisterClass failed, GetLastError() reported %d"),GetLastError());
            return NULL;
        }
    }

    //
    // Public members
    //

    VOID SetWindowHandle(HWND hWnd);
    INT InsertColumn(INT nColumnNumber, const LVCOLUMN* pColumn );
    BOOL SetItem(const LPLVITEM pitem);
    BOOL InsertItem(const LPLVITEM pitem);
    VOID GetHeaderWnd(HWND *phHeaderWnd);

    //
    // windows message handlers
    //

    LRESULT OnPaint      ( WPARAM wParam, LPARAM lParam );
    LRESULT OnDestroy    ( WPARAM wParam, LPARAM lParam );
    LRESULT OnCreate     ( WPARAM wParam, LPARAM lParam );
    LPARAM  OnSize       ( WPARAM wParam, LPARAM lParam );
    LPARAM  OnSetFocus   ( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand    ( WPARAM wParam, LPARAM lParam );
    LRESULT OnRButtonDown(WPARAM wParam, LPARAM lParam);
    LRESULT OnLButtonDown(WPARAM wParam, LPARAM lParam);
    LRESULT OnParentResize(WPARAM wParam, LPARAM lParam);
    INT     OnHitTestEx  (POINT pt, INT *iCol);

    static LRESULT CALLBACK ListViewWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        //Trace(TEXT("Messages to ListViewWnd\nhWnd = %p, uMsg = %d, wParam = %x, lParam = %x"), hWnd, uMsg, wParam, lParam);
        switch(uMsg) {
        case WM_PAINT:
        case WM_LBUTTONDOWN:
        //case WM_NCHITTEST:
            SC_HANDLE_MESSAGE_CALL_DEFAULT_LISTVIEW();
            break;
        default:
            break;
        }

        SC_BEGIN_MESSAGE_HANDLERS(CListViewWnd)
        {
            SC_HANDLE_MESSAGE(WM_RBUTTONDOWN, OnRButtonDown);
            SC_HANDLE_MESSAGE(WM_LBUTTONDOWN, OnLButtonDown);
            SC_HANDLE_MESSAGE(WM_PARENT_WM_SIZE, OnParentResize);
            SC_HANDLE_MESSAGE(WM_PAINT, OnPaint);
            SC_HANDLE_MESSAGE_DEFAULT_LISTVIEW();
        }
        SC_END_MESSAGE_HANDLERS();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\mainwnd.cpp ===
#include "stdafx.h"
#include "MainWnd.h"
#include "resource.h"

BOOL CALLBACK MyEnumChildProc( HWND hwnd, LPARAM lParam);

LRESULT CMainWnd::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND(IDM_EXIT,OnFileExit);
        SC_HANDLE_COMMAND(IDM_SELECT_DEVICE,OnSelectDevice);
    }
    SC_END_COMMAND_HANDLERS();
}

LRESULT CMainWnd::OnPaint( WPARAM wParam, LPARAM lParam )
{    
    PAINTSTRUCT ps;
    HDC hDC = BeginPaint( m_hWnd, &ps );
    if (hDC) {
        EndPaint( m_hWnd, &ps );
    }
    return(0);
}

LRESULT CMainWnd::OnDestroy( WPARAM wParam, LPARAM lParam )
{
    PostQuitMessage(0);
    return(0);
}

LRESULT CMainWnd::OnCreate( WPARAM wParam, LPARAM lParam )
{        
    return(0);
}

VOID CMainWnd::OnFileExit( WPARAM wParam, LPARAM lParam )
{
    PostQuitMessage(0);
}

VOID CMainWnd::OnSelectDevice( WPARAM wParam, LPARAM lParam )
{
    MessageBox(NULL,TEXT("This is for the Select Device Dialog"),TEXT("Place Holder Dialog"),MB_OK);
    return;
}

LPARAM CMainWnd::OnSize( WPARAM wParam, LPARAM lParam )
{
    INT nWidth  = LOWORD(lParam);   // width of client area 
    INT nHeight = HIWORD(lParam);   // height of client area 
    //Trace(TEXT("Client Width = %d, Client Height = %d"),nWidth,nHeight);

    MSG msg;
    msg.message = WM_PARENT_WM_SIZE;
    msg.lParam = lParam;
    msg.wParam = 0;

    PostMessageToAllChildren(msg);

    switch(wParam) {
    case SIZE_MAXHIDE:    
        break; 
    case SIZE_MAXIMIZED: 
        break; 
    case SIZE_MAXSHOW: 
        break; 
    case SIZE_MINIMIZED: 
        break; 
    case SIZE_RESTORED:
        break;
    default:
        break;
    }            
    return(0);
}

LPARAM CMainWnd::OnSetFocus( WPARAM wParam, LPARAM lParam )
{
    InvalidateRect( m_hWnd, NULL, FALSE );
    return(0);
}

VOID CMainWnd::PostMessageToAllChildren(MSG msg)
{
    EnumChildWindows(m_hWnd,(WNDENUMPROC)MyEnumChildProc,(LPARAM)&msg);    
}

BOOL CALLBACK MyEnumChildProc( HWND hwnd, LPARAM lParam)
{
    if(hwnd == NULL)
        return FALSE;
    MSG *pMsg = (MSG*)lParam;
    PostMessage(hwnd, pMsg->message,pMsg->wParam,pMsg->lParam);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\listviewwnd.cpp ===
#include "stdafx.h"
#include "ListViewWnd.h"
#include "resource.h"

LRESULT CListViewWnd::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        
    }
    SC_END_COMMAND_HANDLERS();
}

VOID CListViewWnd::GetHeaderWnd(HWND *phHeaderWnd)
{
    *phHeaderWnd = NULL;
    *phHeaderWnd = GetWindow(m_hWnd,GW_CHILD);
}

LRESULT CListViewWnd::OnPaint( WPARAM wParam, LPARAM lParam )
{
    //
    // invalidate window
    //

    RedrawWindow(m_hWnd, NULL, NULL, RDW_INVALIDATE);
    PAINTSTRUCT ps;
    HDC hDC = BeginPaint( m_hWnd, &ps );
    if (hDC) {

        //
        // Get Header window (first child)
        //

        HWND hHeaderWnd = NULL;
        GetHeaderWnd(&hHeaderWnd);        
        if (hHeaderWnd != NULL) {

            INT nColumnCount = Header_GetItemCount(hHeaderWnd);

            RECT WindowClientRect;

            //
            // Get client rect of header window, and calculate the top line
            // using the 'bottom' offset of the header window rect
            //

            GetClientRect(hHeaderWnd,&WindowClientRect);
            INT iTop = WindowClientRect.bottom;

            //
            // Get client rect of list view window
            //

            GetClientRect(m_hWnd,&WindowClientRect);
            INT iBorderX = 0 - GetScrollPos(m_hWnd, SB_HORZ);
            for (INT i = 0; i < nColumnCount; i++) {
                iBorderX += ListView_GetColumnWidth(m_hWnd,i);
                if (iBorderX >= WindowClientRect.right)
                    break;

                MoveToEx(hDC, (iBorderX - 1), iTop, NULL );
                LineTo(hDC, (iBorderX - 1), WindowClientRect.bottom);
            }

            //
            // Draw horizontal grid lines
            //


            if ( !ListView_GetItemRect(m_hWnd, 0, &WindowClientRect, LVIR_BOUNDS))
                return(0);

            INT iHeight = WindowClientRect.bottom - WindowClientRect.top;

            GetClientRect(m_hWnd, &WindowClientRect);

            INT iWidth = WindowClientRect.right;        
            for ( i = 1; i <= ListView_GetCountPerPage(m_hWnd); i++ ) {
                MoveToEx(hDC, 0, iTop + iHeight * i, NULL);
                LineTo(hDC, iWidth, iTop + iHeight * i);
            }
        } else {
            Trace(TEXT("ListView's Header (child window) could not be found!!"));
        }
        EndPaint( m_hWnd, &ps );
    } else {
        Trace(TEXT("Not Painting...."));
    }
    return(0);
}

LRESULT CListViewWnd::OnDestroy( WPARAM wParam, LPARAM lParam )
{
    PostQuitMessage(0);
    return(0);
}

LRESULT CListViewWnd::OnCreate( WPARAM wParam, LPARAM lParam )
{        
    return(0);
}

LPARAM CListViewWnd::OnSize( WPARAM wParam, LPARAM lParam )
{
    //InvalidateRect( m_hWnd, NULL, FALSE );
    return(0);
}

LPARAM CListViewWnd::OnSetFocus( WPARAM wParam, LPARAM lParam )
{
    InvalidateRect( m_hWnd, NULL, FALSE );
    return(0);
}

VOID CListViewWnd::SetWindowHandle(HWND hWnd)
{
    m_hWnd = hWnd;
}

LRESULT CListViewWnd::OnRButtonDown(WPARAM wParam, LPARAM lParam)
{    
    MessageBox(NULL,TEXT("You Right Clicked on the ListView!"),TEXT("Right Click"),MB_OK);
    return (0);
}

LRESULT CListViewWnd::OnLButtonDown(WPARAM wParam, LPARAM lParam)
{
    int index = 0;
    int colnum = 0;

    POINT point;
    point.x = LOWORD(lParam);
    point.y = HIWORD(lParam);
    
    if( ( index = OnHitTestEx( point, &colnum )) != -1 )
    {
        
        // EditSubLabel( index, colnum );
        Trace(TEXT("EDIT label (Index = %d, Column = %d"),index,colnum);            
        
        //
        // ListView_SetItemState(m_hWnd, index, LVIS_SELECTED | LVIS_FOCUSED ,
        //                LVIS_SELECTED | LVIS_FOCUSED);         
    }
    return (0);
}

INT CListViewWnd::InsertColumn(INT nColumnNumber, const LVCOLUMN* pColumn )
{
    return ListView_InsertColumn(m_hWnd,nColumnNumber,pColumn);
}

BOOL CListViewWnd::SetItem(const LPLVITEM pitem)
{
    BOOL bSuccess = FALSE;
    bSuccess = ListView_SetItem(m_hWnd,pitem);

    //
    // auto adjust the column width to fit the new value
    //

    ListView_SetColumnWidth(m_hWnd, pitem->iSubItem, LVSCW_AUTOSIZE );
    return bSuccess;
}

BOOL CListViewWnd::InsertItem(const LPLVITEM pitem)
{
    BOOL bSuccess = FALSE;
    bSuccess = ListView_InsertItem(m_hWnd,pitem);
    
    //
    // auto adjust the column width to fit the new value
    //
    
    ListView_SetColumnWidth(m_hWnd, pitem->iSubItem, LVSCW_AUTOSIZE );
    return bSuccess;
}

LRESULT CListViewWnd::OnParentResize(WPARAM wParam, LPARAM lParam)
{    
    RECT WindowRect;
    GetWindowRect(m_hWnd,&WindowRect);
    INT nWidth  = LOWORD(lParam);   // width of client area 
    INT nHeight = HIWORD(lParam);   // height of client area
    POINT pt;
    pt.x = WindowRect.left; 
    pt.y = WindowRect.top;
    HWND hWnd = GetParent(m_hWnd);
    ScreenToClient(hWnd,&pt);
    MoveWindow(m_hWnd,pt.x,pt.y,(WindowRect.right - WindowRect.left),nHeight,TRUE);
    return (0);
}

INT CListViewWnd::OnHitTestEx (POINT pt, INT *pCol)
{       
    INT iColumn = 0;
    INT iRow    = 0;
        
    if(pCol)
        *pCol = 0;

    //
    // Get the top and bottom row visible
    //

    iRow = ListView_GetTopIndex(m_hWnd);
    INT iBottom = iRow + ListView_GetCountPerPage(m_hWnd);
    if(iBottom > ListView_GetItemCount(m_hWnd))
        iBottom = ListView_GetItemCount(m_hWnd);
    
    //
    // Get the number of columns
    //
    
    HWND hHeaderWnd = NULL;
    GetHeaderWnd(&hHeaderWnd);

    INT iColumnCount = Header_GetItemCount(hHeaderWnd);
    Trace(TEXT("Column Count = %d"),iColumnCount);
    
    //
    // Loop through the visible rows
    //

    for(iRow ;iRow <= iBottom; iRow++)
    {
        
        //
        // Get bounding rect of item and check whether point falls in it.
        //

        RECT ItemRect;
        ListView_GetItemRect( m_hWnd, iRow, &ItemRect, LVIR_BOUNDS );
        if(PtInRect(&ItemRect, pt))
        {
            // Trace(TEXT("Point in RECT"));

            //
            // Now find the column
            //

            for( iColumn = 0; iColumn < iColumnCount; iColumn++ )
            {
                INT ColumnWidth = ListView_GetColumnWidth(m_hWnd, iColumn);
                if( pt.x >= ItemRect.left 
                    && pt.x <= (ItemRect.left + ColumnWidth) )
                {
                    if(pCol){                    
                       *pCol = iColumn;
                       Trace(TEXT("Column Number = %d"),iColumn);
                    }
                    return iRow;
                }
                ItemRect.left += ColumnWidth;
            }
        } else {

            //
            // Point not in RECT
            //
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PropView.rc
//
#define IDC_MYICON                      2
#define IDD_PROPVIEW_DIALOG             102
#define IDS_APPNAME                     103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_PROPVIEW                    107
#define IDI_SMALL                       108
#define IDI_ITEM                        108
#define IDC_PROPVIEW                    109
#define IDC_APPWNDCLASS                 110
#define IDC_PROPVIEW_MENU               111
#define IDC_TREEVIEWWNDCLASS            112
#define IDS_TREEVIEWNAME                113
#define IDC_LISTVIEWWNDCLASS            114
#define IDS_LISTVIEWNAME                115
#define IDR_MAINFRAME                   128
#define IDI_ROOTICON                    129
#define IDI_FOLDERICON                  130
#define IDS_PROPERTYNAME                131
#define IDS_PROPERTYACCESS              132
#define IDS_PROPERTYTYPE                133
#define IDS_PROPERTYVALUE               134
#define IDM_SELECT_DEVICE               135

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\propview.h ===
#if !defined(AFX_PROPVIEW_H__B35FDF2C_7FB4_444C_8086_B824B2212C07__INCLUDED_)
#define AFX_PROPVIEW_H__B35FDF2C_7FB4_444C_8086_B824B2212C07__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_PROPVIEW_H__B35FDF2C_7FB4_444C_8086_B824B2212C07__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\propview.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "MainWnd.h"
#include "TreeViewWnd.h"
#include "ListViewWnd.h"

//
// global WndProcs, for handling subclassed windows
//

WNDPROC gTreeViewWndSysWndProc = NULL;
WNDPROC gListViewWndSysWndProc = NULL;

#define _ADDDUMMYITEMS      // add dummy items for debugging TreeViewWnd
#define _ADDDUMMYPROPERTIES // add dummy properties for debugging ListViewWnd

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{

    INITCOMMONCONTROLSEX InitCtrls;
    InitCtrls.dwSize = sizeof(INITCOMMONCONTROLSEX);
    InitCtrls.dwICC = ICC_TREEVIEW_CLASSES|ICC_LISTVIEW_CLASSES;

    InitCommonControlsEx(&InitCtrls);


    TCHAR szWndName[255];
    TCHAR szWndClassName[255];
    LoadString(hInstance,IDS_APPNAME,szWndName,sizeof(szWndName));
    LoadString(hInstance,IDC_APPWNDCLASS,szWndClassName,sizeof(szWndClassName));

    CMainWnd MainWnd(NULL);
    HWND hWnd = MainWnd.Create(szWndName,
                               szWndClassName,
                               WS_OVERLAPPEDWINDOW,
                               0,
                               CW_USEDEFAULT, CW_USEDEFAULT,
                               CW_USEDEFAULT, CW_USEDEFAULT,
                               NULL,
                               LoadMenu( hInstance, MAKEINTRESOURCE(IDC_PROPVIEW_MENU)),
                               hInstance );
    if (!hWnd) {
        Trace(TEXT("\nUnable to create main appication window\n"));
        return FALSE;
    }

    ShowWindow(hWnd, SW_SHOW);
    UpdateWindow(hWnd);

    //
    // create TREEVIEW child window
    //

    LoadString(hInstance,IDS_TREEVIEWNAME,szWndName,sizeof(szWndName));
    LoadString(hInstance,IDC_TREEVIEWWNDCLASS,szWndClassName,sizeof(szWndClassName));

    //
    // calculate the child window's height and width using the parents dimisions.
    // note: Child's starting width is 1/3 the parents width.
    //

    RECT MainWndClientRect;
    GetClientRect(hWnd,&MainWndClientRect);
    INT iWindowWidth  = (MainWndClientRect.right - MainWndClientRect.left)/3;
    INT iWindowHeight = (MainWndClientRect.bottom - MainWndClientRect.top);

    CTreeViewWnd TreeViewWnd(NULL);
    HWND hTreeViewWnd = TreeViewWnd.Create(szWndName,
                                           szWndClassName,
                                           WS_CHILD|WS_VISIBLE|WS_SIZEBOX|WS_TABSTOP|
                                           TVS_HASBUTTONS|TVS_HASLINES |TVS_LINESATROOT|
                                           TVS_EDITLABELS | TVS_SHOWSELALWAYS,
                                           WS_EX_CLIENTEDGE/*|WS_EX_NOPARENTNOTIFY*/,
                                           0, 0,
                                           iWindowWidth, iWindowHeight,
                                           hWnd,
                                           NULL,
                                           hInstance);

    if (!hTreeViewWnd) {
        Trace(TEXT("\nUnable to create tree view window\n"));
        return FALSE;
    }

    TreeViewWnd.SetWindowHandle(hTreeViewWnd);

#ifdef _ADDDUMMYITEMS

    //
    // TODO: Remove this code.
    //       (inserting items to see if we are working properly)
    //

    INT ICON_ROOTITEM = -1;
    INT ICON_FOLDER   = -1;
    INT ICON_ITEM     = -1;

    TV_INSERTSTRUCT tv;

    tv.hParent              = TVI_ROOT;
    tv.hInsertAfter         = TVI_LAST;
    tv.item.mask            = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_PARAM;
    tv.item.hItem           = NULL;
    tv.item.state           = TVIS_EXPANDED;
    tv.item.stateMask       = TVIS_STATEIMAGEMASK;
    tv.item.cchTextMax      = 6;
    tv.item.cChildren       = 0;
    tv.item.lParam          = 0;
    tv.item.pszText         = TEXT("Root Item");

    //
    // Create image list
    //

    HIMAGELIST hImageList = NULL;

    hImageList = CreateImageList(16,16,0,3);
    if(hImageList != NULL) {

        //
        // assign indexes to loaded icons
        //

        AddIconToImageList(hInstance,IDI_ROOTICON,hImageList,&ICON_ROOTITEM);
        AddIconToImageList(hInstance,IDI_FOLDERICON,hImageList,&ICON_FOLDER);
        AddIconToImageList(hInstance,IDI_ITEM,hImageList,&ICON_ITEM);

        //
        // set image list
        //

        TreeViewWnd.SetImageList(hImageList,TVSIL_NORMAL);
    } else {
        Trace(TEXT("Image list failed to be created"));
    }

    //
    // Add the Root Item
    //

    tv.item.iImage          = ICON_ROOTITEM;
    tv.item.iSelectedImage  = ICON_ROOTITEM;

    HTREEITEM hTreeItem = NULL;
    hTreeItem = TreeViewWnd.InsertItem(&tv);

    //
    // Add child items
    //

    tv.item.iImage          = ICON_ITEM;
    tv.item.iSelectedImage  = ICON_ITEM;

    tv.hParent              = hTreeItem;
    tv.item.pszText         = TEXT("Child Item 1");
    hTreeItem = TreeViewWnd.InsertItem(&tv);

    tv.item.pszText         = TEXT("Child Item 2");
    hTreeItem = TreeViewWnd.InsertItem(&tv);

    //
    // Add a Folder
    //

    tv.item.iImage          = ICON_FOLDER;
    tv.item.iSelectedImage  = ICON_FOLDER;

    tv.item.pszText         = TEXT("Folder Item");
    hTreeItem = TreeViewWnd.InsertItem(&tv);

    //
    // Add child item
    //

    tv.item.iImage          = ICON_ITEM;
    tv.item.iSelectedImage  = ICON_ITEM;

    tv.hParent              = hTreeItem;
    tv.item.pszText         = TEXT("Folder Child Item 1");
    hTreeItem = TreeViewWnd.InsertItem(&tv);

#endif

    ShowWindow(hTreeViewWnd, SW_SHOW);
    UpdateWindow(hTreeViewWnd);


    //
    // create LISTVIEW child window
    //

    LoadString(hInstance,IDS_LISTVIEWNAME,szWndName,sizeof(szWndName));
    LoadString(hInstance,IDC_LISTVIEWWNDCLASS,szWndClassName,sizeof(szWndClassName));

    //
    // calculate the child window's width using the ListView's width and Parent's width dimisions.
    // note: ListView will be offset to the right in relation to the TreeView window (sibling)
    //

    INT iTreeViewWidth = iWindowWidth;
    INT iXOffset = iTreeViewWidth;
    iWindowWidth = (MainWndClientRect.right - MainWndClientRect.left) - iTreeViewWidth;

    CListViewWnd ListViewWnd(NULL);
    HWND hListViewWnd = ListViewWnd.Create(szWndName,
                                           szWndClassName,
                                           WS_CHILD|WS_VISIBLE|WS_SIZEBOX|WS_TABSTOP|
                                           LVS_REPORT|LVS_EDITLABELS|LVS_SINGLESEL,
                                           WS_EX_CLIENTEDGE|WS_EX_NOPARENTNOTIFY,
                                           iXOffset,0,
                                           iWindowWidth, iWindowHeight,
                                           hWnd,
                                           NULL,
                                           hInstance );

    if (!hListViewWnd) {
        Trace(TEXT("\nUnable to create list view window\n"));
        return FALSE;
    }

    ListViewWnd.SetWindowHandle(hListViewWnd);

#ifdef _ADDDUMMYPROPERTIES
    LVCOLUMN lv;
    LV_ITEM  lvitem;

    INT nNewColumnIndex = 0;
    INT PropID          = 0;

    TCHAR szString[255];

    //
    // add column headers, from resource
    //

    LoadString(hInstance,IDS_PROPERTYNAME,szString,sizeof(szString));

    lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lv.fmt          = LVCFMT_LEFT ;
    lv.cx           = 100;
    lv.pszText      = szString;
    lv.cchTextMax   = 0;
    lv.iOrder       = nNewColumnIndex;
    lv.iSubItem     = nNewColumnIndex;
    nNewColumnIndex = ListViewWnd.InsertColumn(0,&lv);
    nNewColumnIndex++;

    LoadString(hInstance,IDS_PROPERTYVALUE,szString,sizeof(szString));
    nNewColumnIndex = ListViewWnd.InsertColumn(1,&lv);
    nNewColumnIndex++;

    LoadString(hInstance,IDS_PROPERTYTYPE,szString,sizeof(szString));
    nNewColumnIndex = ListViewWnd.InsertColumn(2,&lv);
    nNewColumnIndex++;

    LoadString(hInstance,IDS_PROPERTYACCESS,szString,sizeof(szString));
    nNewColumnIndex = ListViewWnd.InsertColumn(3,&lv);

    //
    // add properties
    //

    lvitem.mask     = LVIF_TEXT | LVIF_PARAM; // set PARAM mask, if setting lParam value
    lvitem.pszText  = szString;
    lvitem.iImage   = NULL;
    lvitem.lParam   = PropID;

    for(INT nItem = 0; nItem < 100;nItem++) {
        lvitem.mask     = LVIF_TEXT; // set TEXT mask
        lvitem.iItem    = nItem;
        lvitem.iSubItem = 0; //first column
        sprintf(szString,"Property %d",nItem);
        ListViewWnd.InsertItem(&lvitem);

        lvitem.iSubItem = 1; //second column
        sprintf(szString,"%d",nItem+100);
        ListViewWnd.SetItem(&lvitem);

        lvitem.iSubItem = 2; //third column
        lstrcpy(szString,TEXT("VT_I4"));
        ListViewWnd.SetItem(&lvitem);

        lvitem.iSubItem = 3; //fourth column
        lstrcpy(szString,TEXT("READONLY"));
        ListViewWnd.SetItem(&lvitem);
    }

#endif

    ShowWindow(hListViewWnd, SW_SHOW);
    UpdateWindow(hListViewWnd);

    //
    // Load the Accelerator keys
    //

    HACCEL hAccel = LoadAccelerators( hInstance, (LPCTSTR)IDC_PROPVIEW );

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator( hWnd, hAccel, &msg )) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return (int)msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\mainwnd.h ===
#ifndef _MAINAPPWINDOW
#define _MAINAPPWINDOW

#include "stdafx.h"
#include "CWindow.h"

class CMainWnd {
private:
    HWND m_hWnd;
    INT m_IconResourceID;
public:

    CMainWnd( HWND hWnd )
    : m_hWnd(hWnd)
    {
        
    }

    ~CMainWnd(void)
    {

    }

    static BOOL RegisterClass( HINSTANCE hInstance, LPCTSTR pszClassName )
    {
        WNDCLASSEX wcex;
        ZeroMemory(&wcex,sizeof(wcex));
        wcex.cbSize = sizeof(wcex);
        if (!GetClassInfoEx( hInstance, pszClassName, &wcex )) {
            ZeroMemory(&wcex,sizeof(wcex));
            wcex.cbSize        = sizeof(wcex);
            wcex.style         = 0;
            wcex.lpfnWndProc   = (WNDPROC)WndProc;
            wcex.cbClsExtra    = 0;
            wcex.cbWndExtra    = 0;
            wcex.hInstance     = hInstance;            
            wcex.hIcon         = ::LoadIcon(hInstance, MAKEINTRESOURCE(107/*IDI_PROPVIEW*/));            
            wcex.hCursor       = ::LoadCursor(NULL, IDC_ARROW);
            wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
            wcex.lpszMenuName  = NULL;
            wcex.lpszClassName = pszClassName;
            wcex.hIconSm       = 0;
            if (!::RegisterClassEx(&wcex)) {                
                return FALSE;
            }
            return TRUE;
        }
        return TRUE;
    }

    static HWND Create( LPCTSTR lpWindowName,
                        LPCTSTR lpWindowClassName,
                        DWORD dwStyle,
                        DWORD dwExStyle,
                        int x,
                        int y,
                        int nWidth,
                        int nHeight,
                        HWND hWndParent,
                        HMENU hMenu,
                        HINSTANCE hInstance )
    {

        //
        // register the window class
        //
        
        if (RegisterClass( hInstance, lpWindowClassName )) {
            HWND hWnd = CreateWindowEx(dwExStyle,
                                  lpWindowClassName,
                                  lpWindowName,
                                  dwStyle,
                                  x,
                                  y,
                                  nWidth,
                                  nHeight,
                                  hWndParent,
                                  hMenu,
                                  hInstance,
                                  NULL );
            SetWindowLongPtr(hWnd,GWLP_USERDATA,NULL);
            return hWnd;
        } else {
            Trace(TEXT("RegisterClass failed, GetLastError() reported %d"),GetLastError());
            return NULL;
        }
    }
        
    //
    // public helpers
    //
    
    VOID PostMessageToAllChildren(MSG msg);
    
    //
    // windows message handlers
    //

    LRESULT OnPaint   ( WPARAM wParam, LPARAM lParam );
    LRESULT OnDestroy ( WPARAM wParam, LPARAM lParam );
    LRESULT OnCreate  ( WPARAM wParam, LPARAM lParam );
    LPARAM  OnSize    ( WPARAM wParam, LPARAM lParam );
    LPARAM  OnSetFocus( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand ( WPARAM wParam, LPARAM lParam );

    //
    // menu handlers
    //

    VOID    OnFileExit( WPARAM wParam, LPARAM lParam );
    VOID    OnSelectDevice( WPARAM wParam, LPARAM lParam );

    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        //Trace(TEXT("Messages to MainWnd\nhWnd = %p, uMsg = %d, wParam = %x, lParam = %x"), hWnd, uMsg, wParam, lParam);
        SC_BEGIN_MESSAGE_HANDLERS(CMainWnd)
        {
            SC_HANDLE_MESSAGE( WM_PAINT,    OnPaint );
            SC_HANDLE_MESSAGE( WM_DESTROY,  OnDestroy );
            SC_HANDLE_MESSAGE( WM_CREATE,   OnCreate );
            SC_HANDLE_MESSAGE( WM_COMMAND,  OnCommand );
            SC_HANDLE_MESSAGE( WM_SIZE,     OnSize );
            SC_HANDLE_MESSAGE( WM_SETFOCUS, OnSetFocus );    
        }
        SC_END_MESSAGE_HANDLERS();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\sources.inc ===
#
# Builds a simple windows-based test program
#

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=propview
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMTYPE=windows

INCLUDES=$(INCLUDES)

SOURCES= \
        ..\propview.cpp         \
        ..\mainwnd.cpp          \
        ..\treeviewwnd.cpp      \
        ..\listviewwnd.cpp      \
        ..\utils.cpp            \
        ..\propview.rc

USE_NATIVE_EH=1
USE_MSVCRT=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\comctl32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN

// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <stdio.h>

#include "utils.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\treeviewwnd.cpp ===
#include "stdafx.h"
#include "TreeViewWnd.h"
#include "resource.h"

LRESULT CTreeViewWnd::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        
    }
    SC_END_COMMAND_HANDLERS();
}

LRESULT CTreeViewWnd::OnPaint( WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC hDC = BeginPaint( m_hWnd, &ps );
    if (hDC) {
        EndPaint( m_hWnd, &ps );
    }
    return(0);
}

LRESULT CTreeViewWnd::OnDestroy( WPARAM wParam, LPARAM lParam )
{
    PostQuitMessage(0);
    return(0);
}

LRESULT CTreeViewWnd::OnCreate( WPARAM wParam, LPARAM lParam )
{        
    return(0);
}

LPARAM CTreeViewWnd::OnSize( WPARAM wParam, LPARAM lParam )
{
    InvalidateRect( m_hWnd, NULL, FALSE );
    return(0);
}

LRESULT CTreeViewWnd::OnSizing  ( WPARAM wParam, LPARAM lParam )
{
    Trace(TEXT("TreeViewWnd is Sizing"));
    return (0);
}

LPARAM CTreeViewWnd::OnSetFocus( WPARAM wParam, LPARAM lParam )
{
    InvalidateRect( m_hWnd, NULL, FALSE );
    return(0);
}

HTREEITEM CTreeViewWnd::InsertItem( LPTVINSERTSTRUCT lpInsertStruct )
{
    Trace(TEXT("Inserting Item [%s] into the Tree"),lpInsertStruct->item.pszText);
    return TreeView_InsertItem(m_hWnd, lpInsertStruct);
}

HIMAGELIST CTreeViewWnd::SetImageList(HIMAGELIST hImageList, INT iImage)
{
    //
    // ( iImage ) can be one of the following
    //
    // TVSIL_NORMAL  Indicates the normal image list, 
    //               which contains selected, nonselected, 
    //               and overlay images for the items of a 
    //               tree view control.

    //
    // TVSIL_STATE  Indicates the state image list.
    //              You can use state images to indicate 
    //              application-defined item states. A state
    //              image is displayed to the left of an item's
    //              selected or nonselected image.  
    
    return TreeView_SetImageList(m_hWnd, hImageList, iImage);
}

VOID CTreeViewWnd::SetWindowHandle(HWND hWnd)
{
    m_hWnd = hWnd;
}

LRESULT CTreeViewWnd::OnRButtonDown(WPARAM wParam, LPARAM lParam)
{
    MessageBox(NULL,TEXT("You Right Clicked on the TreeView!"),TEXT("Right Click"),MB_OK);
    return (0);
}

LRESULT CTreeViewWnd::OnParentResize(WPARAM wParam, LPARAM lParam)
{    
    RECT WindowRect;
    GetWindowRect(m_hWnd,&WindowRect);
    INT nWidth  = LOWORD(lParam);   // width of client area 
    INT nHeight = HIWORD(lParam);   // height of client area 
    MoveWindow(m_hWnd,0,0,(WindowRect.right - WindowRect.left),nHeight,TRUE);
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\utils.cpp ===
#include "stdafx.h"
#include "utils.h"

VOID Trace(LPCTSTR format,...)
{
    
#ifdef _DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}
     
HIMAGELIST CreateImageList(INT iImageWidth, INT iImageHeight, INT iMask, INT iNumIcons)
{
    HIMAGELIST hImageList = NULL;
    
    //
    // TODO: Find out what this mask means
    //

    iMask = ILC_MASK;
    
    hImageList = ImageList_Create(iImageWidth, iImageHeight, iMask, iNumIcons, 0);
    return hImageList;
}

BOOL AddIconToImageList(HINSTANCE hInstance, INT IconResourceID, HIMAGELIST hImageList, INT *pIconIndex)
{    
    HICON hIcon = NULL;
    hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IconResourceID));
    if(hIcon == NULL){
        Trace(TEXT("LoadIcon failed to load IconResourceID %d"),IconResourceID);
        return FALSE;
    }
    *pIconIndex = ImageList_AddIcon(hImageList, hIcon); 
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\utils.h ===
// utils.h

#ifndef _UTILS_H
#define _UTILS_H

#include <commctrl.h>

VOID Trace(LPCTSTR Format, ...);

//
// Image list helpers
//

HIMAGELIST CreateImageList(INT iImageWidth,
                           INT iImageHeight,
                           INT iMask,
                           INT iNumIcons);

BOOL AddIconToImageList(HINSTANCE hInstance,
                        INT IconResourceID,
                        HIMAGELIST hImageList,
                        INT *pIconIndex);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\propview\treeviewwnd.h ===
#ifndef _TREEVIEWWINDOW
#define _TREEVIEWWINDOW

#include "stdafx.h"
#include "CWindow.h"

extern WNDPROC gTreeViewWndSysWndProc;

class CTreeViewWnd {
private:

public:
    HWND m_hWnd;

    //
    // Revisit this in the future!, static variable here, would be better than
    // using a global, to store the OldWindowProc value.
    //

    //  static WNDPROC OldWindowProc;

    CTreeViewWnd( HWND hWnd )
    : m_hWnd(hWnd)
    {
    }

    ~CTreeViewWnd(void)
    {

    }

    static BOOL RegisterClass( HINSTANCE hInstance, LPCTSTR pszClassName)
    {
        WNDCLASSEX wcex;
        ZeroMemory(&wcex,sizeof(wcex));
        wcex.cbSize = sizeof(wcex);
        if (!GetClassInfoEx( hInstance, pszClassName, &wcex )) {
            ZeroMemory(&wcex,sizeof(wcex));
            wcex.cbSize        = sizeof(wcex);
            wcex.style         = 0;
            wcex.lpfnWndProc   = TreeViewWndProc;
            wcex.cbClsExtra    = 0;
            wcex.cbWndExtra    = 0;
            wcex.hInstance     = hInstance;
            wcex.hIcon         = 0;
            wcex.hCursor       = ::LoadCursor(NULL, IDC_ARROW);
            wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
            wcex.lpszMenuName  = NULL;
            wcex.lpszClassName = pszClassName;
            wcex.hIconSm       = 0;
            if (!::RegisterClassEx(&wcex)) {
                return FALSE;
            }
            return TRUE;
        }
        return TRUE;
    }

    static HWND Create( LPCTSTR lpWindowName,
                        LPCTSTR lpWindowClassName,
                        DWORD dwStyle,
                        DWORD dwExStyle,
                        int x,
                        int y,
                        int nWidth,
                        int nHeight,
                        HWND hWndParent,
                        HMENU hMenu,
                        HINSTANCE hInstance)
    {

        //
        // register the window class
        //

        if (RegisterClass( hInstance, lpWindowClassName)) {
            HWND hWnd = CreateWindowEx(dwExStyle,
                                  lpWindowClassName,
                                  lpWindowName,
                                  dwStyle,
                                  x,
                                  y,
                                  nWidth,
                                  nHeight,
                                  hWndParent,
                                  hMenu,
                                  hInstance,
                                  NULL );
            SetWindowLongPtr(hWnd,GWLP_USERDATA,NULL);

            gTreeViewWndSysWndProc = (WNDPROC)SetWindowLongPtr(hWnd,
                                                               GWLP_WNDPROC,
                                                               (LONG)(LONG_PTR)TreeViewWndProc);
            return hWnd;

        } else {
            Trace(TEXT("RegisterClass failed, GetLastError() reported %d"),GetLastError());
            return NULL;
        }
    }

    //
    // Public members
    //

    VOID SetWindowHandle(HWND hWnd);
    HTREEITEM  InsertItem  (LPTVINSERTSTRUCT lpInsertStruct );
    HIMAGELIST SetImageList(HIMAGELIST hImageList, INT iImage);

    //
    // windows message handlers
    //

    LRESULT OnPaint   ( WPARAM wParam, LPARAM lParam );
    LRESULT OnDestroy ( WPARAM wParam, LPARAM lParam );
    LRESULT OnCreate  ( WPARAM wParam, LPARAM lParam );
    LPARAM  OnSize    ( WPARAM wParam, LPARAM lParam );
    LRESULT OnSizing  ( WPARAM wParam, LPARAM lParam );
    LPARAM  OnSetFocus( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand ( WPARAM wParam, LPARAM lParam );
    LRESULT OnRButtonDown(WPARAM wParam, LPARAM lParam);
    LRESULT OnParentResize(WPARAM wParam, LPARAM lParam);

    static LRESULT CALLBACK TreeViewWndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        //Trace(TEXT("Messages to TreeViewWnd\nhWnd = %p, uMsg = %d, wParam = %x, lParam = %x"), hWnd, uMsg, wParam, lParam);
        SC_BEGIN_MESSAGE_HANDLERS(CTreeViewWnd)
        {
            SC_HANDLE_MESSAGE( WM_RBUTTONDOWN, OnRButtonDown);
            SC_HANDLE_MESSAGE(WM_PARENT_WM_SIZE, OnParentResize);
            SC_HANDLE_MESSAGE_DEFAULT_TREEVIEW();
        }
        SC_END_MESSAGE_HANDLERS();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\remote\connect\connect.cpp ===
#include <tchar.h>
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <stdlib.h>
#include <stdarg.h>
#include <wia.h>
#include <stdio.h>

#ifdef _DEBUG
#define TRACE(x) Trace x
#else
#define TRACE(x) Trace x
#endif

#define RELEASE(x)\
                  do {\
                  if((x)) {\
                  (x)->Release(); \
                  (x) = NULL;\
                  }\
                  }while(0)

#define REQUIRE(x)\
                  do {\
                  if(!(x)) {\
                  TRACE((_T("%hs(%d): %hs failed with LastError() = %d\r\n"),\
                  __FILE__, __LINE__, #x, GetLastError()));\
                  goto Cleanup;\
                  }\
                  } while(0)


#define REQUIRE_S_OK(x)\
                       do {\
                       hr = (x);\
                       \
                       if(hr != S_OK) {\
                       TRACE((_T("%hs(%d): %hs failed with hr = %x\r\n"),\
                       __FILE__, __LINE__, #x, hr));\
                       goto Cleanup;\
                       }\
                       } while(0)

#define REQUIRE_SUCCESS(x)\
                          do {\
                          DWORD dwResult = (x);\
                          \
                          if(dwResult != ERROR_SUCCESS) {\
                          TRACE((_T("%hs(%d): %hs failed with status = %x\r\n"),\
                          __FILE__, __LINE__, #x, dwResult));\
                          goto Cleanup;\
                          }\
                          } while(0)



void Trace(LPCTSTR fmt, ...)
{
    TCHAR buffer[2048];
    va_list marker;

    va_start(marker, fmt);
    wvsprintf(buffer, fmt, marker);

    printf("\nError: %ws", buffer);
}

struct regVals_t {
    ULONG propId;
    LPWSTR propName;
} regVals[] = {
    {WIA_DIP_DEV_ID, WIA_DIP_DEV_ID_STR},
    {WIA_DIP_VEND_DESC, WIA_DIP_VEND_DESC_STR},
    {WIA_DIP_DEV_DESC, WIA_DIP_DEV_DESC_STR},
    {WIA_DIP_DEV_TYPE, WIA_DIP_DEV_TYPE_STR},
    {WIA_DIP_PORT_NAME, WIA_DIP_PORT_NAME_STR},
    {WIA_DIP_DEV_NAME, WIA_DIP_DEV_NAME_STR},
    {WIA_DIP_SERVER_NAME, WIA_DIP_SERVER_NAME_STR},
    {WIA_DIP_REMOTE_DEV_ID, WIA_DIP_REMOTE_DEV_ID_STR},
    {WIA_DIP_UI_CLSID, WIA_DIP_UI_CLSID_STR}
};
#define NREGVALS (sizeof(regVals) / sizeof(regVals[0]))

HRESULT RegisterRemoteScanners(LPCWSTR servername) 
{
    HRESULT hr;
    IWiaDevMgr *pDevMgr = NULL;
    IEnumWIA_DEV_INFO *pEnumInfo = NULL;
    IWiaPropertyStorage *pWiaPropStg = NULL;
    COSERVERINFO csi;
    HKEY hDevList = NULL;
    HKEY hKey = NULL;
    MULTI_QI mq[1];

    ZeroMemory(&csi, sizeof(csi));
    csi.pAuthInfo = NULL;
    csi.pwszName = SysAllocString(servername);

    mq[0].hr = S_OK;
    mq[0].pIID = &IID_IWiaDevMgr;
    mq[0].pItf = NULL;

    REQUIRE_S_OK(CoCreateInstanceEx(CLSID_WiaDevMgr, NULL, CLSCTX_REMOTE_SERVER, 
        &csi, 1, mq));

    pDevMgr = (IWiaDevMgr *)mq[0].pItf;

    REQUIRE_SUCCESS(RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        _T("SYSTEM\\CurrentControlSet\\Control\\StillImage\\DevList"),
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hDevList,
        NULL));

    //
    // Enumerate all devices scanner
    //
    REQUIRE_S_OK(pDevMgr->EnumDeviceInfo(0, &pEnumInfo));

    while(pEnumInfo->Next(1, &pWiaPropStg, NULL) == S_OK) 
    {
        PROPSPEC ps[NREGVALS];
        PROPVARIANT pv[NREGVALS];
        WCHAR keyname[MAX_PATH];
        WCHAR *p;
        int i;

        ZeroMemory(pv, sizeof(pv));
        for(i = 0; i < NREGVALS; i++) {
            ps[i].ulKind = PRSPEC_PROPID;
            ps[i].propid = regVals[i].propId;
        }

        REQUIRE_S_OK(pWiaPropStg->ReadMultiple(
            sizeof(ps) / sizeof(ps[0]), 
            ps, 
            pv));

        //
        // Skip any remote devices (anything other than "local"
        // in server name field
        //
        for(i = 0; i < NREGVALS; i++) {
            if(regVals[i].propId == WIA_DIP_SERVER_NAME) {
                if(wcscmp(pv[i].bstrVal, L"local")) {
                    goto SkipDevice;
                }
            }
        }

        //
        // pv[0] consists of device ID and "\NNN", replace "\" with ".", prepend target machine name
        //
        p = pv[0].bstrVal;
        wcscpy(keyname, servername);
        wcscat(keyname, L".");
        while(*p && *p != L'\\')
        {
            p++;
        }
        REQUIRE(*p == L'\\');
        REQUIRE(*(++p) != L'\0');

        wcscat(keyname, p);

        //
        // Create device key and populate values
        //
        REQUIRE_SUCCESS(RegCreateKeyExW(
            hDevList,
            keyname,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            NULL));

        for(i = 0; i < NREGVALS; i++) {

            switch(pv[i].vt) {

            case VT_BSTR:
                if(regVals[i].propId == WIA_DIP_SERVER_NAME) {
                    //
                    // Server name is reported as "local",
                    // we need to set it to the actual server name
                    // 
                    REQUIRE_SUCCESS(RegSetValueExW(
                        hKey, 
                        regVals[i].propName,
                        0,
                        REG_SZ,
                        (CONST BYTE *)servername,
                        wcslen(servername) * sizeof(WCHAR)));
                } else {
                    //
                    // All other values we simply copy 
                    //
                    REQUIRE_SUCCESS(RegSetValueExW(
                        hKey, 
                        regVals[i].propName,
                        0,
                        REG_SZ,
                        (CONST BYTE *)pv[i].bstrVal,
                        wcslen(pv[i].bstrVal) * sizeof(WCHAR)));
                }
                break;

            case VT_I4:
                REQUIRE_SUCCESS(RegSetValueExW(
                    hKey,
                    regVals[i].propName,
                    0,
                    REG_DWORD,
                    (CONST BYTE *)&pv[i].lVal,
                    sizeof(DWORD)));
                break;

            default:
                TRACE((_T("Unexpected property type: %d\n"), pv[i].vt));
                break;
            }

            PropVariantClear(pv + i);
        }

        RegCloseKey(hKey);
        
SkipDevice:        
        RELEASE(pWiaPropStg);
    }

Cleanup:
    if(hDevList) RegCloseKey(hDevList);
    RELEASE(pEnumInfo);
    RELEASE(pDevMgr);

    if(csi.pwszName) SysFreeString(csi.pwszName);
    return hr;
}


int __cdecl main(int argc, char **argv)
{
    HRESULT hr;
    WCHAR servername[MAX_PATH];
    HKEY hKey;


    if(argc < 2) {
        printf("usage: connect <server name>\n");
        exit(0);
    }

    MultiByteToWideChar(CP_ACP, 0, argv[1], -1, servername, sizeof(servername) / sizeof(servername[0]));

    printf("Registering scanners on %s...", argv[1]);
    
    REQUIRE_S_OK(CoInitializeEx(NULL, COINIT_MULTITHREADED));
    REQUIRE_S_OK(CoInitializeSecurity(NULL, -1, NULL, NULL,
                                      RPC_C_AUTHN_LEVEL_CONNECT,
                                      RPC_C_IMP_LEVEL_IMPERSONATE,
                                      NULL,
                                      0,
                                      NULL));
    REQUIRE_S_OK(RegisterRemoteScanners(servername));

    REQUIRE_SUCCESS(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 _T("SYSTEM\\CurrentControlSet\\Control\\StillImage\\DevList"),
                                   0,
                                   KEY_READ,
                                   &hKey));
    for(int i = 0;;i++) {
        TCHAR subkeyName[1024];
        DWORD subkeySize;
        HKEY hSubKey;
        TCHAR string[1024];
        DWORD cbString;
        DWORD dwType;
                
        subkeySize = sizeof(subkeyName) / sizeof(subkeyName[0]);
        if(RegEnumKeyEx(hKey, i, subkeyName, &subkeySize, 0, NULL, NULL, NULL) != ERROR_SUCCESS) {
            break;
        }
        REQUIRE_SUCCESS(RegOpenKeyEx(hKey, subkeyName, 0, KEY_READ, &hSubKey));
        cbString = sizeof(string);
        REQUIRE_SUCCESS(RegQueryValueEx(hSubKey, _T("Server"), NULL, &dwType, (BYTE *)string, &cbString));
        if(lstrcmpi(string, servername))
            continue;
        
        cbString = sizeof(string);
        REQUIRE_SUCCESS(RegQueryValueEx(hSubKey, _T("Name"), NULL, &dwType, (BYTE *)string, &cbString));
        printf("\nRegistered: %ws", string);
        RegCloseKey(hSubKey);
    }


    printf("\ndone.\n");
    
Cleanup:
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\acquire.h ===
/******************************************************************************

  acquire.h

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include    <scanner.h>                 // SCL commands

//
// Hewlett-Packard ScanJet command strings
//
WCHAR szScanReadyMfr[]   = L"Hewlett-Packard";

CHAR SCLReset[]         = "E";
CHAR SetXRes[]          = "*a%dR";
CHAR SetYRes[]          = "*a%dS";
CHAR SetXExtPix[]       = "*f%dP";
CHAR SetYExtPix[]       = "*f%dQ";
CHAR InqXRes[]          = "*s10323R";
CHAR SetBitsPerPixel[]  = "*a%dG";
CHAR SetIntensity[]     = "*a%dL";
CHAR SetContrast[]      = "*a%dK";
CHAR SetNegative[]      = "*a%dI";
CHAR SetMirror[]        = "*a%dM";
CHAR SetDataType[]      = "*a%dT";
CHAR ScanCmd[]          = "*f0S";
CHAR LampOn[]           = "*f1L";
CHAR LampOff[]          = "*f0L";
CHAR PollButton[]       = "*s1044E";


LPBITMAPINFO            pDIB = NULL;        // pointer to DIB bitmap header
HBITMAP                 hDIBSection = NULL; // handle to DIB
LPBYTE                  pDIBBits = NULL;    // pointer to DIB bit data
int                     m_XSize = 800,      // horizontal size in pixels
                        m_YSize = 800;      // vertical size in pixels

BYTE					bRed        = 0,	// bitmap colors
						bGreen      = 100,
						bBlue       = 50;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\ntlog.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ntlog.h
//
//--------------------------------------------------------------------------

/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|		   10-Oct-96 (darrenf)  fixed _FILE_ for unicode, added _NTLOG_LOGPATH handling	
|
\*---------------------------------------------------------------------------*/

// If doing C++ stuff, this needs to be here to
// prevent decorating of symbols.
//
#ifdef __cplusplus
extern "C" {
#endif

// **NEW** 10/26/96 Log path environment variable **NEW**
// if the environment variable _NTLOG_LOGPATH is set to a non-empty string 
// the value of this variable will be prepended to the log name
// The path should NOT include a trailing backslash.

// No validation is performed on the path, however, if the value is invalid,
// the call to tlCreateLog will fail because CreateFile will fail.

// Basically should be used to force logfiles to a location other than the current directory
// without changing the source file.

// **NEW** 1/20/97 environment variable to force diffable files **NEW**
// if the environment variable _NTLOG_DIFFABLE is set, then log files
// will not contain process and thread specific data, and time and date data.
//


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable



// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,TEXT(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,TEXT(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,TEXT(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,TEXT(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,TEXT(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,TEXT(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,TEXT(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,TEXT(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,TEXT(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,TEXT(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,TEXT(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,TEXT(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,TEXT(__FILE__),(int)__LINE__



// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPCWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPCSTR,DWORD);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPCWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPCSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPCWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPCSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPCSTR,int,LPCSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPCWSTR,int,LPCWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPCSTR,int,LPCSTR,...);

#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define TESTDATA                 HANDLE        hLog;
#define TESTOTHERDATA            extern HANDLE hLog;


//  These must be useless.  TL_* macros do not include TLS_TEST or
//  TLS_VARIATION, so they DO NOT count in the stats.  Leaving them around
//  for 'backwards compatibility, if anyone was actually using them...
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK


//  macros for incrementing test/variation counts for various log levels
//
#define L_TESTPASS                   hLog,TLS_TEST | TL_PASS
#define L_TESTWARN                   hLog,TLS_TEST | TL_WARN
#define L_TESTDEBUG                  hLog,TLS_TEST | TL_TESTDEBUG
#define L_TESTTRACE                  hLog,TLS_TEST | TL_SYSTEM
#define L_TESTFAIL                   hLog,TLS_TEST | TL_SEV1
#define L_TESTFAIL2                  hLog,TLS_TEST | TL_SEV2
#define L_TESTFAIL3                  hLog,TLS_TEST | TL_SEV3
#define L_TESTBLOCK                  hLog,TLS_TEST | TL_BLOCK
#define L_TESTABORT                  hLog,TLS_TEST | TL_ABORT

#define L_VARPASS                   hLog,TLS_VARIATION | TL_PASS
#define L_VARWARN                   hLog,TLS_VARIATION | TL_WARN
#define L_VARDEBUG                  hLog,TLS_VARIATION | TL_TESTDEBUG
#define L_VARTRACE                  hLog,TLS_VARIATION | TL_SYSTEM
#define L_VARFAIL                   hLog,TLS_VARIATION | TL_SEV1
#define L_VARFAIL2                  hLog,TLS_VARIATION | TL_SEV2
#define L_VARFAIL3                  hLog,TLS_VARIATION | TL_SEV3
#define L_VARBLOCK                  hLog,TLS_VARIATION | TL_BLOCK
#define L_VARABORT                  hLog,TLS_VARIATION | TL_ABORT


#define TESTBEGIN(cmd,logfilename){                                                       \
                                      DWORD __tlFlags;                                    \
                                      __tlFlags = tlParseCmdLine(cmd);                    \
                                      hLog      = tlCreateLog(logfilename,__tlFlags);     \
                                      tlAddParticipant(hLog,0l,0);

#define TESTEND                       tlRemoveParticipant(hLog);                          \
                                      tlDestroyLog(hLog);                                 \
                                  }

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                                  \
                                 {                                                                           \
                                     DWORD __dwResult;                                                       \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);

#define ENDVARIATION                 __dwResult = tlEndVariation(hLog);                                      \
                                     tlLog(hLog,__dwResult | TL_VARIATION,TEXT("End Variation reported"));   \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                           \
                                    LPTSTR _lpFN = _szNM;                                                    \
                                    tlAddParticipant(_hLG,0,0);                                              \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                               \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);             \
                                    tlRemoveParticipant(_hLG);                                               \
                                    return(_ret);                                                            \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                                \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);            \
                                     tlRemoveParticipant(_hLG);                                              \
                                     return;                                                                 \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    (expr) ? tlLog(L_TESTPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg)
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_TESTFAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_TESTFAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_TESTFAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_TESTPASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTABORT(msg)          tlLog(L_TESTABORT,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_TESTWARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_TESTBLOCK,TEXT("%s"),(LPTSTR)msg);

#define VARRESULT(expr,msg)    (expr) ? tlLog(L_VARPASS,TEXT("%s"),(LPTSTR)msg) : tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg)
#define VARFAIL(msg)           VARSEV2(msg)
#define VARSEV1(msg)           tlLog(L_VARFAIL ,TEXT("%s"),(LPTSTR)msg);
#define VARSEV2(msg)           tlLog(L_VARFAIL2,TEXT("%s"),(LPTSTR)msg);
#define VARSEV3(msg)           tlLog(L_VARFAIL3,TEXT("%s"),(LPTSTR)msg);
#define VARPASS(msg)           tlLog(L_VARPASS ,TEXT("%s"),(LPTSTR)msg);
#define VARABORT(msg)          tlLog(L_VARABORT,TEXT("%s"),(LPTSTR)msg);
#define VARWARN(expr,msg)      if(expr) tlLog(L_VARWARN,TEXT("%s"),(LPTSTR)msg);
#define VARBLOCK(expr,msg)     if(expr) tlLog(L_VARBLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\acquire.cpp ===
/******************************************************************************

  acquire.cpp

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include    <scanner.h>                 // SCL commands

//
// Hewlett-Packard ScanJet command strings
//
CHAR SCLReset[]         = "E";
CHAR SetXRes[]          = "*a%dR";
CHAR SetYRes[]          = "*a%dS";
CHAR SetXExtPix[]       = "*f%dP";
CHAR SetYExtPix[]       = "*f%dQ";
CHAR InqXRes[]          = "*s10323R";
CHAR SetBitsPerPixel[]  = "*a%dG";
CHAR SetIntensity[]     = "*a%dL";
CHAR SetContrast[]      = "*a%dK";
CHAR SetNegative[]      = "*a%dI";
CHAR SetMirror[]        = "*a%dM";
CHAR SetDataType[]      = "*a%dT";
CHAR ScanCmd[]          = "*f0S";
CHAR LampOn[]           = "*f1L";
CHAR LampOff[]          = "*f0L";
CHAR PollButton[]       = "*s1044E";


LPBITMAPINFO            pDIB = NULL;        // pointer to DIB bitmap header
HBITMAP                 hDIBSection = NULL; // handle to DIB
LPBYTE                  pDIBBits = NULL;    // pointer to DIB bit data
int                     m_XSize = 800,      // horizontal size in pixels
                        m_YSize = 800;      // vertical size in pixels

BYTE					bRed        = 0,	// bitmap colors
						bGreen      = 100,
						bBlue       = 50;


/*****************************************************************************
    int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
        Determine whether we have Acquire commands for device

    Parameters:
        Pointer to Device Information structure

    Return:
        1 if Acquire commands available, 0 otherwise

*****************************************************************************/
int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
{
	int n;

WCHAR szScanReadyMfr[]   = L"Hewlett-Packard";
WCHAR szScanReadyDev[][48] = {
    L"Hewlett-Packard ScanJet 5p",
    L"Hewlett-Packard ScanJet 6100c or 4c/3c",
    L"Hewlett-Packard ScanJet 4p",
    L"Hewlett-Packard ScanJet 3p",
    L"Hewlett-Packard ScanJet IIcx",
    L"Hewlett-Packard ScanJet IIp",
    L"Hewlett-Packard ScanJet IIc",
	L""
};


	//
	// look for non-camera from Hewlett-Packard
	//
	if ((GET_STIDEVICE_TYPE(pStiDevI->DeviceType) == 1) &&
		(wcscmp(pStiDevI->pszVendorDescription,szScanReadyMfr) == 0)) {
		for (n = 0;*szScanReadyDev[n];n++) {
			//
			// is it an HP SCL compatible device?
			//
			if (wcscmp(pStiDevI->pszLocalName,szScanReadyDev[n]) == 0)
				return (1);
		}
	}
	return (0);
}


/******************************************************************************
    HRESULT
    WINAPI
    SendDeviceCommandString(
        PSTIDEVICE  pStiDevice,
        LPSTR       pszFormat,
        ...
        )
    Send formatted SCL string to the device

    Parameters:
        StiDevice buffer and the command string

    Return:
        HRESULT of last failed Sti call

******************************************************************************/
HRESULT
WINAPI
SendDeviceCommandString(
    PSTIDEVICE  pStiDevice,
    LPSTR       pszFormat,
    ...
    )
{

	HRESULT hres = STI_OK,
		    hError = STI_OK;
    CHAR    ScanCommand[255];
    UINT    cbChar = 1;


    //
    // lock device first
    //
    hres = pStiDevice->LockDevice(2000);

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"LockDevice",TRUE);
		hError = hres;
    }
	else {
	    //
		// Format command string
		//
	    ZeroMemory(ScanCommand,sizeof(ScanCommand));
		ScanCommand[0]='\033';

	    va_list ap;
		va_start(ap, pszFormat);
		cbChar += wvsprintfA(ScanCommand+1, pszFormat, ap);
	    va_end(ap);

		DisplayOutput("->RawWriteData sending \"%2x %s\"",
			ScanCommand[0],ScanCommand+1);

	    //
		// Send command string to the device
	    //
		hres = pStiDevice->RawWriteData(
			ScanCommand,    //
	        cbChar,         //
		    NULL            //
			);

		if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"RawWriteData",TRUE);
			hError = hres;
		}
	}

    //
    // unlock device
    //
    hres = pStiDevice->UnLockDevice();

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"UnLockDevice",TRUE);
		hError = hres;
    }

    return (hError);
}


/******************************************************************************
    HRESULT
    WINAPI
    TransactDevice(
        PSTIDEVICE  pStiDevice,
        LPSTR       lpResultBuffer,
        UINT        cbResultBufferSize,
        LPSTR       pszFormat,
        ...
        )
    Send formatted SCL string to the device and return data in a buffer.

    Parameters:
        StiDevice buffer, data buffer, sizeof databuffer and the command string.

    Return:
        HRESULT of last failed Sti call

******************************************************************************/
HRESULT
WINAPI
TransactDevice(
    PSTIDEVICE  pStiDevice,
    LPSTR       lpResultBuffer,
    UINT        cbResultBufferSize,
    LPSTR       pszFormat,
    ...
    )
{

	HRESULT hres = STI_OK,
		    hError = STI_OK;
    CHAR    ScanCommand[255];
    UINT    cbChar = 1;
    ULONG   cbActual = 0;


    //
    // lock device first
    //
    hres = pStiDevice->LockDevice(2000);

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"LockDevice",TRUE);
		hError = hres;
    }
	else {
	    //
		// Format command string
	    //
		ZeroMemory(ScanCommand,sizeof(ScanCommand));
	    ScanCommand[0]='\033';

	    va_list ap;
		va_start(ap, pszFormat);
	    cbChar += wvsprintfA(ScanCommand+1, pszFormat, ap);
		va_end(ap);

	    DisplayOutput("->Escape sending \"%2x %s\"",
		    ScanCommand[0],ScanCommand+1);

		//
		// Send command string to the device
		//
		hres = pStiDevice->Escape(
			StiTransact,        // EscapeFunction
			ScanCommand,        // lpInData
			cbChar,             // cbInDataSize
			lpResultBuffer,     // pOutData
			cbResultBufferSize, // dwOutDataSize
			&cbActual);         // pdwActualData
		
		if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"Escape",TRUE);
			hError = hres;
		}
		if (cbActual != 0)
			DisplayOutput("  cbActual %xh",cbActual);
	}

    //
    // unlock device
    //
    hres = pStiDevice->UnLockDevice();

    if (! SUCCEEDED(hres)) {
		StiDisplayError(hres,"UnLockDevice",TRUE);
		hError = hres;
    }

    return (hError);
}


/*****************************************************************************
    void StiLamp(int nOnOff)
        Turn the scanner lamp on and off

    Parameters:
        Send "ON" to turn lamp on, "OFF" to turn it off.

    Return:
        none

*****************************************************************************/
void StiLamp(int nOnOff)
{
    HRESULT hres;


    //
    // check that an Sti device is selected
    //
    if (pStiDevice == NULL)
        return;

    //
    // Test lamp on/off capability
    //
    if (nOnOff == ON) {
        strcpy(pszStr1,LampOn);
        strcpy(pszStr2,"On");
    }
    else {
        strcpy(pszStr1,LampOff);
        strcpy(pszStr2,"Off");
    }

    hres = SendDeviceCommandString(pStiDevice,pszStr1);

	if (SUCCEEDED(hres)) {
        DisplayOutput("Turned Lamp  %s",pszStr2);
	}

	return;
}


/*****************************************************************************
    INT StiScan(HWND hWnd)
        Scan and display an image from device.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT StiScan(HWND hWnd)
{
    HRESULT             hres;
    ULONG               cbDataSize,
                        ulDIBSize,
                        ulScanSize;
    RGBTRIPLE           *pTriplet;
    LPBYTE              pDIBPtr;
    UINT                i,
                        iPixel,
                        xRes = 0;
    int                 m_XResolution = 100,
                        m_YResolution = 100;
    CHAR                ScanData[1024*16];


    //
    // ensure there is an active still imaging device open
    //
    if (pStiDevice == NULL)
		return (-1);

    //
    // Set basic parameters
    //
    hres = SendDeviceCommandString(pStiDevice,SetBitsPerPixel,24);
	if (! SUCCEEDED(hres))
		return (-1);
	hres = SendDeviceCommandString(pStiDevice,SetIntensity,0);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetContrast,0);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetNegative,1);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetMirror,0);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetDataType,5);    // Color
	if (! SUCCEEDED(hres))
		return (-1);

    hres = SendDeviceCommandString(pStiDevice,SetXRes,m_XResolution);
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetYRes,m_YResolution);
	if (! SUCCEEDED(hres))
		return (-1);

    hres = SendDeviceCommandString(pStiDevice,SetXExtPix,(m_XSize*300/m_XResolution));
	if (! SUCCEEDED(hres))
		return (-1);
    hres = SendDeviceCommandString(pStiDevice,SetYExtPix,(m_YSize*300/m_YResolution));
	if (! SUCCEEDED(hres))
		return (-1);

    //
    // Inquire commands ( X and Y resolution)
    //
    cbDataSize = sizeof(ScanData);
    ZeroMemory(ScanData,sizeof(ScanData));
/*
    hres = TransactDevice(pStiDevice,ScanData,cbDataSize,InqXRes);
	if (! SUCCEEDED(hres))
		return (-1);
*/

    //
    // calculate the size of the DIB
    //
    ulDIBSize = pDIB->bmiHeader.biWidth * (-pDIB->bmiHeader.biHeight);

    //
    // start the scan
    //
    hres = SendDeviceCommandString(pStiDevice,ScanCmd);

    for (i = 0,pDIBPtr = pDIBBits,cbDataSize = sizeof(ScanData);
        cbDataSize == sizeof(ScanData);i++) {

		//
	    // lock device first
		//
	    hres = pStiDevice->LockDevice(2000);
	
	    if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"LockDevice",TRUE);
	    }
		else {
			hres = pStiDevice->RawReadData(ScanData,&cbDataSize,NULL);

			if (! SUCCEEDED(hres)) {
				StiDisplayError(hres,"RawReadData",TRUE);
			}
		}

		//
		// unlock device
	    //
		hres = pStiDevice->UnLockDevice();

	    if (! SUCCEEDED(hres)) {
			StiDisplayError(hres,"UnLockDevice",TRUE);
	    }

        if ((cbDataSize * i) < ulDIBSize) {
            //
            // copy this scanline into the DIB until it is full
            //
            memcpy(pDIBPtr,ScanData,cbDataSize);
            pDIBPtr += cbDataSize;
        }
    }

    //
    // how large was the scan?
    //
    ulScanSize = (sizeof(ScanData))*i+cbDataSize;

    DisplayOutput("Scan done. Total passes %d, bytes %lu.",
        i,ulScanSize);

    //
    // Triplets coming in from scanner are inverted from DIB format
    //
    for (iPixel = 0,pTriplet = (RGBTRIPLE *) pDIBBits;
        iPixel < ulDIBSize/3;iPixel++,pTriplet++) {
        BYTE    bTemp;

        bTemp = pTriplet->rgbtBlue;
        pTriplet->rgbtBlue = pTriplet->rgbtRed;
        pTriplet->rgbtRed = bTemp;
        }

    //
    // display the DIB
    //
    DisplayScanDIB(hWnd);
    nScanCount++;

    return (0);
}


/*****************************************************************************
    INT     CreateScanDIB(HWND);
        Create a DIB to display scanned image..

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT CreateScanDIB(HWND hWnd)
{
    HDC                 hScreenDC;
    RGBTRIPLE           *pTriplet;
    LPBITMAPINFOHEADER  pHdr;
    int                 x,
                        y;


    GdiFlush();

    // delete the DIB object if it exists
    if (hDIBSection)
        DeleteObject(hDIBSection);

/*

    hWindow = CreateWindow((LPSTR) pszB,
        (LPSTR) pszA,
        WS_OVERLAPPEDWINDOW,
        rect.left,
        rect.top,
        rect.right,
        rect.bottom,
        (HWND) NULL,
        0,
        hInst,
        NULL);

*/

    //
    // initialize the DIB
    //
    pDIB = (LPBITMAPINFO) GlobalAlloc(GPTR,sizeof(BITMAPINFO));

    pHdr = &pDIB->bmiHeader;

    pHdr->biSize            = sizeof(BITMAPINFOHEADER);
    pHdr->biWidth           = m_XSize;
    pHdr->biHeight          = -m_YSize; // indicate top-down dib
    pHdr->biPlanes          = 1;
    pHdr->biBitCount        = 24;
    pHdr->biCompression     = BI_RGB;
    pHdr->biSizeImage       = 0;
    pHdr->biXPelsPerMeter   = 0;
    pHdr->biYPelsPerMeter   = 0;
    pHdr->biClrUsed         = 0;
    pHdr->biClrImportant    = 0;

    //
    // create the DIB
    //
    hScreenDC = GetDC(hWnd);
    if (NULL == (hDIBSection = CreateDIBSection(hScreenDC,
        (PBITMAPINFO) pDIB,
        DIB_RGB_COLORS,
        (void **) &pDIBBits,
        NULL,
        0)))
    {
        LastError(TRUE);
        DisplayOutput("*failed to create DIB");
        ReleaseDC(hWnd,hScreenDC);
        return (-1);
    }
    ReleaseDC(hWnd,hScreenDC);

    //
    // Fill the DIB with colors
    //
    pTriplet = (RGBTRIPLE *) pDIBBits;

    for (x = 0;x < m_XSize;x++) {
        for (y = 0;y < m_YSize;y++,pTriplet++) {
            pTriplet->rgbtRed   = bRed;
            pTriplet->rgbtGreen = bGreen;
            pTriplet->rgbtBlue  = bBlue;
        }
    }

    return (0);
}


/*****************************************************************************
    INT     DeleteScanDIB();
        Delete the DIB used to display a scanned image..

    Parameters:

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DeleteScanDIB()
{
	GdiFlush();
	DeleteObject(hDIBSection);
	
    return (0);
}


/*****************************************************************************
    INT     DisplayScanDIB(HWND);
        Show the DIB.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DisplayScanDIB(HWND hWnd)
{
    HDC                 hScreenDC;


    //
    // display the DIB
    //
    hScreenDC = GetDC(hWnd);
    SetDIBitsToDevice(hScreenDC,
        0,0,
        m_XSize,m_YSize,
        0,0,
        0,m_YSize,
        pDIBBits,
        (LPBITMAPINFO) pDIB,
        DIB_RGB_COLORS);
    ReleaseDC(hWnd,hScreenDC);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\stisvc.cpp ===
/******************************************************************************

  stiddk.cpp

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/


/*****************************************************************************
    int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
        Determine whether we have Acquire commands for device

    Parameters:
        Pointer to Device Information structure

    Return:
        1 if Acquire commands available, 0 otherwise

*****************************************************************************/
int IsScanDevice(PSTI_DEVICE_INFORMATION pStiDevI)
{
	return (0);
}


/******************************************************************************
    HRESULT
    WINAPI
    SendDeviceCommandString(
        PSTIDEVICE  pStiDevice,
        LPSTR       pszFormat,
        ...
        )
    Send formatted command string to device

    Parameters:
        StiDevice buffer and the command string

    Return:
        Result of the call.

******************************************************************************/
HRESULT
WINAPI
SendDeviceCommandString(
    PSTIDEVICE  pStiDevice,
    LPSTR       pszFormat,
    ...
    )
{
    HRESULT hres = STIERR_UNSUPPORTED;


    return (hres);
}


/******************************************************************************
    HRESULT
    WINAPI
    TransactDevice(
        PSTIDEVICE  pStiDevice,
        LPSTR       lpResultBuffer,
        UINT        cbResultBufferSize,
        LPSTR       pszFormat,
        ...
        )
    Send formatted command string to device and return data in a buffer.

    Parameters:
        StiDevice buffer, data buffer, sizeof databuffer and the command string.

    Return:
        Result of the call.

******************************************************************************/
HRESULT
WINAPI
TransactDevice(
    PSTIDEVICE  pStiDevice,
    LPSTR       lpResultBuffer,
    UINT        cbResultBufferSize,
    LPSTR       pszFormat,
    ...
    )
{
    HRESULT hres = STIERR_UNSUPPORTED;


    return (hres);
}


/*****************************************************************************
    void StiLamp(int nOnOff)
        Turn the scanner lamp on and off

    Parameters:
        Send "ON" to turn lamp on, "OFF" to turn it off.

    Return:
        none

*****************************************************************************/
void StiLamp(int nOnOff)
{
	return;
}


/*****************************************************************************
    INT StiScan(HWND hWnd)
        Scan and display an image from device.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT StiScan(HWND hWnd)
{
	return (-1);
}


/*****************************************************************************
    INT     CreateScanDIB(HWND);
        Create a DIB to display scanned image..

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT CreateScanDIB(HWND hWnd)
{
	return (-1);
}


/*****************************************************************************
    INT     DeleteScanDIB();
        Delete the DIB used to display a scanned image..

    Parameters:

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DeleteScanDIB()
{
    return (-1);
}


/*****************************************************************************
    INT     DisplayScanDIB(HWND);
        Show the DIB.

    Parameters:
        Handle to the window to display image in.

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT DisplayScanDIB(HWND hWnd)
{
    return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\stillvue.h ===
/******************************************************************************

  stillvue.h

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#pragma warning (disable:4001)          // ignore '//' comments

#define     _X86_   1
#define     WIN32_LEAN_AND_MEAN 1

#include    <windows.h>
#include    <sti.h>                     // Still Image services
#include    "ntlog.h"                   // ntlogging APIs

#include    "resource.h"                // resource defines

#include    <stdio.h>
#include    <stdlib.h>                  // rand()
#include    <string.h>                  // strcat
#include    <time.h>                    // srand(time())

#include    "winx.h"


/*****************************************************************************

        global defines

*****************************************************************************/

#define LONGSTRING                  256
#define MEDSTRING                   128
#define SHORTSTRING                 32


/*****************************************************************************

        HWEnable states

*****************************************************************************/

#define OFF                                                     0
#define ON                                                      1
#define PEEK                                            2


/*****************************************************************************

        events

*****************************************************************************/

#define STIEVENTARG                                     "StiEvent"
#define STIDEVARG                                       "StiDevice"


/*****************************************************************************

    StiSelect contexts

*****************************************************************************/

#define AUTO            1
#define EVENT           4
#define MANUAL          8


/*****************************************************************************

    ErrorLog structure

*****************************************************************************/

typedef struct _ERRECORD
{
        // index into current test suite
        int                     nIndex;
        // unique test ID
        int                     nTest;
        // total number of times this test failed
        int                     nCount;
        // TRUE = compliance test failure; FALSE = acceptable error
        BOOL            bFatal;
        // the actual error returned
        DWORD           dwError;
        // any associated error string
        WCHAR           szErrorString[MEDSTRING];
        // previous / next record
        _ERRECORD       *pPrev;
        _ERRECORD       *pNext;
} ERRECORD, *PERRECORD;

typedef struct _DEVLOG
{
        // internal device name
        WCHAR           szInternalName[STI_MAX_INTERNAL_NAME_LENGTH];
        // friendly device name
        WCHAR           szLocalName[STI_MAX_INTERNAL_NAME_LENGTH];
        // pointer to error record structure
        PERRECORD       pRecord;
        // error total
        int                     nError;
        // previous / next record
        _DEVLOG         *pPrev;
        _DEVLOG         *pNext;
} DEVLOG, *PDEVLOG;


/*****************************************************************************

    stillvue.cpp prototypes

*****************************************************************************/

BOOL    StartAutoTimer(HWND);
BOOL    ComplianceDialog(HWND);
void    LogOutput(int,LPSTR,...);
VOID    DisplayOutput(LPSTR,...);
int     EndTest(HWND,int);
void    FatalError(char *);
BOOL    FirstInstance(HANDLE);
void    Help();
HWND    MakeWindow(HANDLE);
BOOL    ParseCmdLine(LPSTR);

BOOL    CommandParse(HWND,UINT,WPARAM,LPARAM);
BOOL    Creation(HWND,UINT,WPARAM,LPARAM);
BOOL    Destruction(HWND,UINT,WPARAM,LPARAM);
BOOL    HScroll(HWND,UINT,WPARAM,LPARAM);
BOOL    VScroll(HWND,UINT,WPARAM,LPARAM);

BOOL    NTLogInit();
BOOL    NTLogEnd();

BOOL FAR PASCAL   Compliance(HWND,UINT,WPARAM,LPARAM);
BOOL FAR PASCAL   Settings(HWND,UINT,WPARAM,LPARAM);

long FAR PASCAL   WiskProc(HWND,UINT,WPARAM,LPARAM);


/*****************************************************************************

    wsti.cpp prototypes

*****************************************************************************/

int       ClosePrivateList(PDEVLOG *);
void      DisplayLogPassFail(BOOL);
int       InitPrivateList(PDEVLOG *,int *);
int       NextStiDevice();
void      StiDisplayError(HRESULT,char *,BOOL);
HRESULT   StiEnumPrivate(PVOID *,DWORD *);
int       StiSelect(HWND,int,BOOL *);

void      IStillDeviceMenu(DWORD);
void      IStillImageMenu(DWORD);
void      IStillNameMenu(DWORD);
void      IStillScanMenu(DWORD);

HRESULT   StiClose(BOOL *);
HRESULT   StiCreateInstance(BOOL *);
HRESULT   StiDeviceRelease(BOOL *);
HRESULT   StiDiagnostic(BOOL *);
HRESULT   StiEnableHwNotification(LPWSTR,int *,BOOL *);
HRESULT   StiEnum(BOOL *);
HRESULT   StiEscape(DWORD,char *,BOOL *);
HRESULT   StiEvent(HWND);
HRESULT   StiGetCaps(BOOL *);
HRESULT   StiGetDeviceValue(LPWSTR,LPWSTR,LPBYTE,DWORD *,DWORD,BOOL *);
HRESULT   StiGetDeviceInfo(LPWSTR,BOOL *);
HRESULT   StiGetLastErrorInfo(BOOL *);
HRESULT   StiGetStatus(int,BOOL *);
HRESULT   StiImageRelease(BOOL *);
HRESULT   StiRawReadData(char *,LPDWORD,BOOL *);
HRESULT   StiRawWriteData(char *,DWORD,BOOL *);
HRESULT   StiRawReadCommand(char *,LPDWORD,BOOL *);
HRESULT   StiRawWriteCommand(char *,DWORD,BOOL *);
HRESULT   StiRefresh(LPWSTR,BOOL *);
HRESULT   StiRegister(HWND,HINSTANCE,int,BOOL *);
HRESULT   StiReset(BOOL *);
HRESULT   StiSetDeviceValue(LPWSTR,LPWSTR,LPBYTE,DWORD,DWORD,BOOL *);
HRESULT   StiSubscribe(BOOL *);
HRESULT   StiWriteErrLog(DWORD,LPCWSTR,BOOL *);

BOOL FAR PASCAL   SelectDevice(HWND,UINT,WPARAM,LPARAM);


/*****************************************************************************

    acquire.cpp prototypes

*****************************************************************************/

int     IsScanDevice(PSTI_DEVICE_INFORMATION);
void    StiLamp(int);
INT     StiScan(HWND);

INT     CreateScanDIB(HWND);
INT     DeleteScanDIB();
INT     DisplayScanDIB(HWND);

HRESULT WINAPI   SendDeviceCommandString(PSTIDEVICE,LPSTR,...);
HRESULT WINAPI   TransactDevice(PSTIDEVICE,LPSTR,UINT,LPSTR,...);


/*****************************************************************************

    winx.cpp prototypes

*****************************************************************************/

BOOL   GetFinalWindow (HANDLE hInst,LPRECT lprRect,LPSTR  lpzINI,LPSTR  lpzSection);
BOOL   SaveFinalWindow (HANDLE hInst,HWND hWnd,LPSTR lpzINI,LPSTR lpzSection);
BOOL   LastError(BOOL bNewOnly);

BOOL   ErrorMsg(HWND hWnd, LPSTR lpzMsg, LPSTR lpzCaption, BOOL bFatal);
int    NextToken(char *pDest,char *pSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\stillvue.cpp ===
/******************************************************************************

  stillvue.cpp
  Simple test of WDM Still Image Class

  Copyright (C) Microsoft Corporation, 1997 - 1999
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#define     INITGUID

#include    "stillvue.h"

#include <dbt.h>
#include <devguid.h>
#include <pnpmgr.h>

#include    "stivar.h"                // stillvue local includes

//
// defined in wsti.cpp
//
extern      WCHAR szFriendlyName[];
extern      WCHAR szInternalName[];
extern      DWORD dwStiTotal;
extern      PSTI_DEVICE_INFORMATION pStiInfoPtr;


/******************************************************************************
  BOOL CommandParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Handle user menu commands.
******************************************************************************/
BOOL CommandParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    HRESULT hres = STI_OK;
    DWORD   dwSize = 0,
            dwType = 0,
            dwPriority = STI_TRACE_ERROR,
            EscapeFunction = 0,
            dwNumberOfBytes = 0;
    WCHAR   szMessage[] = L"Sti Compliance Test message";
    WCHAR   szDevKey[LONGSTRING];
    char    lpInData[LONGSTRING],
            lpOutData[LONGSTRING];
    int     nReturn = 0;    // generic return value
    BOOL    bReturn;


    //
    // Set the InATest semaphore
    //
    nInATestSemaphore = 1;

    switch(wParam)
    {
    // IStillImage Interfaces
    case IDM_CREATE_INSTANCE:
        hres = StiCreateInstance(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_DEVLIST:
        hres = StiEnum(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_CREATE_DEV:
        if (bAuto)
            hres = StiSelect(hWnd,AUTO,&bReturn);
        else
            hres = StiSelect(hWnd,MANUAL,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_DEVINFO:
        hres = StiGetDeviceInfo(szInternalName,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_DEVVAL:
        hres = StiGetDeviceValue(szInternalName,
            STI_DEVICE_VALUE_TWAIN_NAME,(LPBYTE) lpInData,
            &dwType,DWORD(LONGSTRING),&bReturn);
        hres = StiGetDeviceValue(szInternalName,
            STI_DEVICE_VALUE_ISIS_NAME,(LPBYTE) lpInData,
            &dwType,DWORD(LONGSTRING),&bReturn);
        hres = StiGetDeviceValue(szInternalName,
            STI_DEVICE_VALUE_ICM_PROFILE,(LPBYTE) lpInData,
            &dwType,DWORD(LONGSTRING),&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_SET_DEVVAL:
        //
        // Store a dummy registry key and value
        //
        wcscpy(szDevKey,L"StiTestRegKey");
        strcpy(lpOutData,"This is a bland statement");
        dwType = REG_SZ;
        dwSize = strlen(lpOutData);

        //
        // set the value and then retrieve it
        //
        hres = StiSetDeviceValue(szInternalName,
            szDevKey,(LPBYTE) lpOutData,dwType,dwSize,&bReturn);
        hres = StiGetDeviceValue(szInternalName,
            szDevKey,(LPBYTE) lpOutData,&dwType,DWORD(LONGSTRING),&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_REGISTER_LAUNCH:
        hres = StiRegister(hWnd,hThisInstance,ON,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_UNREGISTER_LAUNCH:
        hres = StiRegister(hWnd,hThisInstance,OFF,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_ENABLE_HWNOTIF:
        //
        // Change Hw notification to inverse
        //
        nHWState = 0;

        hres = StiEnableHwNotification(szInternalName,&nHWState,&bReturn);
        DisplayLogPassFail(bReturn);
        if (nHWState == 0)
            nHWState = 1;
        else
            nHWState = 0;
        hres = StiEnableHwNotification(szInternalName,&nHWState,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_HWNOTIF:
        //
        // Look at the current HW notification state
        //
        nHWState = PEEK;
        hres = StiEnableHwNotification(szInternalName,&nHWState,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_REFRESH_DEVBUS:
        hres = StiRefresh(szInternalName,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_WRITE_ERRORLOG:
        for (;lParam >= 1;lParam--)
            hres = StiWriteErrLog(dwPriority,szMessage,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_IMAGE_RELEASE:
        hres = StiImageRelease(&bReturn);
        DisplayLogPassFail(bReturn);
        break;

    // IStillImage_Device Interfaces
    case IDM_GET_STATUS_A:
        nReturn = STI_DEVSTATUS_ONLINE_STATE;
        hres = StiGetStatus(nReturn,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_STATUS_B:
        nReturn = STI_DEVSTATUS_EVENTS_STATE;
        hres = StiGetStatus(nReturn,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_STATUS_C:
        nReturn = STI_DEVSTATUS_ONLINE_STATE | STI_DEVSTATUS_EVENTS_STATE;
        hres = StiGetStatus(nReturn,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_CAPS:
        hres = StiGetCaps(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_DEVICERESET:
        hres = StiReset(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_DIAGNOSTIC:
        hres = StiDiagnostic(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_GET_LASTERRINFO:
        hres = StiGetLastErrorInfo(&bReturn);
        DisplayLogPassFail(bReturn);
        DisplayOutput("");
        break;
    case IDM_SUBSCRIBE:
        hres = StiSubscribe(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_UNSUBSCRIBE:
        nUnSubscribe = 0;
        DisplayOutput("");
        break;

    case IDM_ESCAPE_A:
        //
        // Set up the Escape command parameters
        //
        EscapeFunction = 0;
        strcpy(lpInData,"This is a bland statement");

        hres = StiEscape(EscapeFunction,&lpInData[0],&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWREADDATA_A:
        //
        // Set up the RawReadData command parameters
        //
        ZeroMemory(lpInData,LONGSTRING);
        dwNumberOfBytes = 16;

        hres = StiRawReadData(lpInData,&dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWWRITEDATA_A:
        //
        // Set up the RawReadData command parameters
        //
        strcpy(lpOutData,"The eagle flies high");
        dwNumberOfBytes = strlen(lpOutData);

        hres = StiRawWriteData(lpOutData,dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWREADCOMMAND_A:
        //
        // Set up the RawReadCommand command parameters
        //
        ZeroMemory(lpInData,LONGSTRING);
        dwNumberOfBytes = 16;

        hres = StiRawReadCommand(lpInData,&dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_RAWWRITECOMMAND_A:
        //
        // Set up the RawWriteCommand command parameters
        //
        strcpy(lpOutData,"Jack and Jill went up the hill");
        dwNumberOfBytes = strlen(lpOutData);

        hres = StiRawWriteCommand(lpOutData,dwNumberOfBytes,&bReturn);
        DisplayLogPassFail(bReturn);
        break;

    case IDM_DEVICE_RELEASE:
        hres = StiDeviceRelease(&bReturn);
        DisplayLogPassFail(bReturn);
        break;
    case IDM_NEXT_DEVICE:
        hres = NextStiDevice();
        DisplayLogPassFail(bReturn);
        break;

    case IDM_LAMPON:
        StiLamp(ON);
        break;
    case IDM_LAMPOFF:
        StiLamp(OFF);
        break;
    case IDM_SCAN:
        hres = StiScan(hWnd);
        break;
    case IDM_SHOWDIB:
        hres = DisplayScanDIB(hWnd);
        break;

    case IDM_COMPLIANCE:
        //
        // assign a test suite and start the automated test timer
        //
        pSuite = nComplianceSuite;
        nMaxCount = 3;
        nTimeScan = 10;
        nTimeNext = 1;
        bAuto = StartAutoTimer(hWnd);
        break;
    case IDM_SHIPCRIT:
        //
        // assign a test suite and start the automated test timer
        //
        pSuite = nShipcritSuite;
        nMaxCount = 200;
        nTimeScan = 10;
        nTimeNext = 1;
        bAuto = StartAutoTimer(hWnd);
        break;

    case IDM_PAUSE:
        // toggle pausing automation (if running) on/off
        if (! nPause) {
            DisplayOutput("..pausing automated test..");
            nPause = 1;
           }
        else {
            DisplayOutput("Resuming automated test");
            nPause = 0;
        }
        break;
    case IDM_AUTO:
        // toggle the automation on/off
        if (bAuto) {
            // stop the auto timer and the stress tests
            KillTimer(hWnd,TIMER_ONE);
            bAuto = FALSE;
            EnableMenuItem(hMenu, IDM_PAUSE,  MF_DISABLED);
            DisplayOutput("Ending the tests");
        }
        else {
            // start the auto timer and the stress tests
            LoadString(hThisInstance,IDS_APPNAME,pszStr1,MEDSTRING);
            if (! SetTimer(hWnd,TIMER_ONE,nTimeNext * nTimeMultiplier,NULL))
                ErrorMsg((HWND) NULL,"Too many clocks or timers!",pszStr1,TRUE);
            else {
                bAuto = TRUE;
                EnableMenuItem(hMenu, IDM_PAUSE,  MF_ENABLED);
                DisplayOutput("Starting the Sti Compliance tests");
                pSuite = nComplianceSuite;
                //
                // initialize NT Logging
                //
                NTLogInit();
            }
        }
        break;
    case IDM_SETTINGS:
        bReturn = fDialog(IDD_SETTINGS, hWnd, (FARPROC) Settings);

        // implement the settings if user pressed OK
        if (bReturn != FALSE)
        {
            if (nTTNext != nTimeNext) {
                nTimeNext = nTTNext;
                DisplayOutput("Test interval changed to %d seconds",nTimeNext);
            }
            if (nTTScan != nTimeScan) {
                nTimeScan = nTTScan;
                DisplayOutput("Scan interval changed to %d seconds",
                    nTimeScan * nTimeNext);
            }
            if (nTTMax != nMaxCount) {
                nMaxCount = nTTMax;
                DisplayOutput("Test loops changed to %d (0 is forever)",
                    nMaxCount);
            }
        }
        break;
    case IDM_HELP:
        Help();
        break;
    default:
        break;
    }
    //
    // Clear the InATest semaphore
    //
    nInATestSemaphore = 0;

    // always return 0
    return 0;
}


/******************************************************************************
  BOOL TimerParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Each timer tick, decide whether to run the next test, repeat a prior test,
  end testing, or shut everything down.
******************************************************************************/
BOOL TimerParse(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    HRESULT hres = STI_OK;              // generic Sti return value
    int     nReturn = 0,                // generic return value
            *pTest;                     // pointer to the test suite to run
    BOOL    bResume = TRUE,             // reset timer flag
            bReturn = TRUE;             // dialog box return value
static int  nDeviceNumber = 1;          // current device
static int  nCountdown = nTimeScan;     // WM_TIMER ticks until next scan
static DWORD dwOut = 0;


    //
    // Don't start a test if paused or running a test currently.
    //
    //
    if ((nInTimerSemaphore)||(nInATestSemaphore)||(nPause))
        return 0;

    //
    // Suspend the timer while running this test.
    // Set Flag to reset timer
    // Set the nInTimerSemaphore
    // Set the current test ID
    //
    KillTimer(hWnd,TIMER_ONE);
    bResume = TRUE;
    nInTimerSemaphore = 1;
    nTestID = nNextTest;

    //
    // point to the next test in the current suite to run
    //
    pTest = pSuite + nNextTest;

    switch (*pTest)
    {
    case NONE:
        nNextTest++;
        break;
    case HELP:
        nNextTest++;
        break;
    case COMPLIANCE:
        //
        // initialize test structures
        //
        if (pdevRoot == NULL) {
            InitPrivateList(&pdevRoot,pSuite);
            pdevPtr = pdevRoot;
        }

        //
        // if this is COMPLIANCE test, ask user to confirm test
        //
        bResume = ComplianceDialog(hWnd);

        nNextTest++;
        break;
    case SHIPCRIT:
        //
        // initialize test structures
        //
        if (pdevRoot == NULL) {
            InitPrivateList(&pdevRoot,pSuite);
            pdevPtr = pdevRoot;
        }
        nNextTest++;
        break;
    case ERRORLOG:
        nNextTest++;
        break;
    case TEST:
        nNextTest++;
        break;
    case tBeginningOfTest:
        DisplayOutput("Begin Testing test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Begin Testing test, loop %d, device %d",nTestCount,nDeviceNumber);
        nNextTest++;
        break;
    case tCreateInstance:
        DisplayOutput("CreateInstance test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"CreateInstance test, loop %d, device %d",nTestCount,nDeviceNumber);
        DisplayOutput("%S (%S) is being tested",
            pdevPtr->szLocalName,pdevPtr->szInternalName);
        tlLog(hNTLog,TL_LOG,"%S (%S) is being tested",
            pdevPtr->szLocalName,pdevPtr->szInternalName);
        DisplayOutput("");
        PostMessage(hWnd,WM_COMMAND,IDM_CREATE_INSTANCE,0);
        nNextTest++;
        break;
    case tGetDeviceList:
        DisplayOutput("GetDeviceList test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetDeviceList test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_DEVLIST,0);
        nNextTest++;
        break;
    case tCreateDevice:
        DisplayOutput("CreateDevice test (Device ONLINE), loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,
            "CreateDevice test (Device ONLINE), loop %d, device %d",nTestCount,nDeviceNumber);
        //
        // Call Sti with device
        //
        nNameOnly = 0;
        PostMessage(hWnd,WM_COMMAND,IDM_CREATE_DEV,0);
        nNextTest++;
        break;
    case tSelectDeviceName:
        DisplayOutput("SelectDeviceName test (Device OFFLINE), "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"SelectDeviceName test (Device OFFLINE),"\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        //
        // Call Sti with device name only
        //
        nNameOnly = 1;
        PostMessage(hWnd,WM_COMMAND,IDM_CREATE_DEV,0);
        nNextTest++;
        break;
    case tGetDeviceInfo:
        DisplayOutput("GetDeviceInfo test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetDeviceInfo test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_DEVINFO,0);
        nNextTest++;
        break;
    case tGetDeviceValue:
        DisplayOutput("GetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_DEVVAL,0);
        nNextTest++;
        break;
    case tSetDeviceValue:
        DisplayOutput("SetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"SetDeviceValue test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_SET_DEVVAL,0);
        nNextTest++;
        break;
    case tRegisterLaunchApplication:
        DisplayOutput("RegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_REGISTER_LAUNCH,0);
        nNextTest++;
        break;
    case tUnRegisterLaunchApplication:
        DisplayOutput("UnRegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"UnRegisterLaunchApplication test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_UNREGISTER_LAUNCH,0);
        nNextTest++;
        break;
    case tEnableHwNotifications:
        DisplayOutput("EnableHwNotifications test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"EnableHwNotifications test, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_ENABLE_HWNOTIF,0);
        nNextTest++;
        break;
    case tGetHwNotificationState:
        DisplayOutput("GetHwNotificationState test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetHwNotificationState test, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_HWNOTIF,0);
        nNextTest++;
        break;
    case tWriteToErrorLog:
        DisplayOutput("WriteToErrorLog test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"WriteToErrorLog test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_WRITE_ERRORLOG,0);
        nNextTest++;
        break;
    case tWriteToErrorLogBig:
        DisplayOutput("WriteToErrorLog test, Variation 1, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"WriteToErrorLog test, Variation 1, "\
            "loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_WRITE_ERRORLOG,100);
        nNextTest++;
        break;
    case tGetStatusA:
        DisplayOutput("GetStatus (Online) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetStatus test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_STATUS_A,0);
        nNextTest++;
        break;
    case tGetStatusB:
        DisplayOutput("GetStatus (Event) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetStatus test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_STATUS_B,0);
        nNextTest++;
        break;
    case tGetStatusC:
        DisplayOutput("GetStatus (All) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetStatus test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_STATUS_C,0);
        nNextTest++;
        break;
    case tGetCapabilities:
        DisplayOutput("GetCapabilities test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetCapabilities test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_CAPS,0);
        nNextTest++;
        break;
    case tDeviceReset:
        DisplayOutput("DeviceReset test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"DeviceReset test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_DEVICERESET,0);
        nNextTest++;
        break;
    case tDiagnostic:
        DisplayOutput("Diagnostic test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Diagnostic test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_DIAGNOSTIC,0);
        nNextTest++;
        break;
    case tGetLastInfoError:
        DisplayOutput("GetLastInfoError test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"GetLastInfoError test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_GET_LASTERRINFO,0);
        nNextTest++;
        break;
    case tSubscribe:
        DisplayOutput("Subscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Subscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_SUBSCRIBE,0);
        nNextTest++;
        break;
    case tUnSubscribe:
        DisplayOutput("UnSubscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"UnSubscribe test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_UNSUBSCRIBE,0);
        nNextTest++;
        break;
    case tEscapeA:
        DisplayOutput("Escape (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"Escape test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_ESCAPE_A,0);
        nNextTest++;
        break;
    case tRawReadDataA:
        DisplayOutput("RawReadData (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawReadData test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWREADDATA_A,0);
        nNextTest++;
        break;
    case tRawWriteDataA:
        DisplayOutput("RawWriteData (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawWriteData test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWWRITEDATA_A,0);
        nNextTest++;
        break;
    case tRawReadCommandA:
        DisplayOutput("RawReadCommand (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawReadCommand test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWREADCOMMAND_A,0);
        nNextTest++;
        break;
    case tRawWriteCommandA:
        DisplayOutput("RawWriteCommand (variation A) test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"RawWriteCommand test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_RAWWRITECOMMAND_A,0);
        nNextTest++;
        break;
    case tAcquire:
        if (! nICanScan) {
            nNextTest++;
        } else {
            if (nCountdown == nTimeScan) {
                nCountdown--;
                DisplayOutput("...countdown %d to acquire...",nCountdown);
                PostMessage(hWnd,WM_COMMAND,IDM_SCAN,0);
            }
            else {
                if (nCountdown == 0) {
                    nNextTest++;
                    nCountdown = nTimeScan;
                }
                else {
                    nCountdown--;
                    DisplayOutput("Acquire test, loop %d, device %d",nTestCount,nDeviceNumber);
                    tlLog(hNTLog,TL_LOG,"Acquire test, loop %d, device %d",nTestCount,nDeviceNumber);
                    PostMessage(hWnd,WM_COMMAND,IDM_SHOWDIB,0);
                }
            }
        }
        break;
    case tReleaseDevice:
        DisplayOutput("ReleaseDevice test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"ReleaseDevice test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_DEVICE_RELEASE,0);
        nNextTest++;
        break;
    case tReleaseSti:
        DisplayOutput("ReleaseSti test, loop %d, device %d",nTestCount,nDeviceNumber);
        tlLog(hNTLog,TL_LOG,"ReleaseSti test, loop %d, device %d",nTestCount,nDeviceNumber);
        PostMessage(hWnd,WM_COMMAND,IDM_IMAGE_RELEASE,0);
        nNextTest++;
        break;
    case tHelp:
        PostMessage(hWnd,WM_COMMAND,IDM_HELP,0);
        nNextTest++;
        break;
    case tTest:
        DisplayOutput("   Line %d",dwOut++);
        nNextTest++;
        break;
    case tEndOfTest:
        //
        // Reached the end of test suite
        //
        DisplayOutput("test loop complete");
        tlLog(hNTLog,TL_LOG,"test loop complete");
        if (nICanScan) {
            DisplayOutput("-> %d loops (%d scans and %d errors) device %d",
                nTestCount,nScanCount,pdevPtr->nError,nDeviceNumber);
            tlLog(hNTLog,TL_LOG,"-> %d loops (%d scans and %d errors) device %d",
                nTestCount,nScanCount,pdevPtr->nError,nDeviceNumber);
        } else {
            DisplayOutput("-> %d loops (%d errors) device %d",
                nTestCount,pdevPtr->nError,nDeviceNumber);
            tlLog(hNTLog,TL_LOG,"-> %d loops (%d errors) device %d",
                nTestCount,pdevPtr->nError,nDeviceNumber);
        }

        //
        // Have we run requested number of tests per device?
        //
        if (((nTestCount >= nMaxCount) &&
            ((dwStiTotal == (DWORD) (nDeviceNumber)) || (dwStiTotal == 0)) &&
            (nMaxCount != 0))) {
            DisplayOutput("Requested number of test loops per device "\
                "reached");
            tlLog(hNTLog,TL_LOG,"Requested number of test loops per "\
                "device reached");

            //
            // shut off timer and turn off automation
            //
            KillTimer(hWnd,TIMER_ONE);
            bAuto = FALSE;
            bResume = FALSE;

            //
            // print the test summary for the devices
            //
            DisplayOutput("");
            tlLog(hNTLog,TL_LOG,"");
            if (pdevRoot == NULL) {
                DisplayOutput("No valid Still Imaging devices were found");
                tlLog(hNTLog,TL_LOG,"No valid Still Imaging devices were found");
            } else {
                PDEVLOG     pD = pdevRoot;
                PERRECORD   pR = NULL;
                BOOL        bPF = FALSE;


                DisplayOutput("Testing results:");
                tlLog(hNTLog,TL_LOG,"Testing results:");

                do {
                    DisplayOutput(" %S (%S)",pD->szLocalName,pD->szInternalName);
                    tlLog(hNTLog,TL_LOG," %S (%S)",pD->szLocalName,
                        pD->szInternalName);

                    for (pR = pD->pRecord;pR->pNext != NULL;pR = pR->pNext) {
                        if (pR->bFatal && pR->nCount) {
                            DisplayOutput("  %s failures: %d",
                                StrFromTable(pR->nTest,StSuiteStrings),
                                pR->nCount);
                            tlLog(hNTLog,TL_LOG,"  %s failures: %d",
                                StrFromTable(pR->nTest,StSuiteStrings),
                                pR->nCount);
                            //
                            // set the FAIL flag
                            //
                            bPF = TRUE;
                        }
                    }
                    if (bPF == TRUE) {
                        DisplayOutput("FAIL: This device has FAILED the "\
                            "Still Imaging Compliance test!");
                        tlLog(hNTLog,TL_LOG,"FAIL: This device has FAILED "\
                            "the Still Imaging Compliance test!");
                    } else {
                        DisplayOutput("PASS: This device has PASSED the "\
                            "Still Imaging Compliance test!");
                        tlLog(hNTLog,TL_LOG,"PASS: This device has PASSED "\
                            "the Still Imaging Compliance test!");
                    }

                    // cycle through all devices, BREAK at end of list
                    if (pD->pNext) {
                        pD = pD->pNext;
                        DisplayOutput("");
                        tlLog(hNTLog,TL_LOG,"");
                        bPF = FALSE;
                    } else {
                        DisplayOutput("");
                        break;
                    }
                } while (TRUE);
            }
            //
            // free the private lists and close Sti subsystem
            //
            ClosePrivateList(&pdevRoot);
            StiClose(&bReturn);
            //
            // reset test counters
            //
            nDeviceNumber = 1;
            nNextTest = 0;
            nTestCount = 1;

            DisplayOutput("End of testing");
            tlLog(hNTLog,TL_LOG,"End of testing");
            DisplayOutput("");

        } else {
            //
            // Point to first test (past initialization) in list.
            //
            nNextTest = 2;
            //
            // select next device in device log
            // Note that this list isn't dynamic for PNP changes...
            //
            nDeviceNumber = NextStiDevice();

            //
            // increment test pass counter if we're at first device again
            //
            if ((++nDeviceNumber) == 1)
                nTestCount++;

            DisplayOutput("");
        }
        break;
    default:
        DisplayOutput("");
        DisplayOutput("Unimplemented test # %d",*pTest);
        DisplayOutput("");
        nNextTest++;
        break;
    }
    //
    // Resume the timer if the flag is set
    //
    if (bResume) {
        if (! SetTimer(hWnd,TIMER_ONE,nTimeNext * nTimeMultiplier,NULL)) {
            LoadString(hThisInstance,IDS_APPNAME,pszStr1,MEDSTRING);
            ErrorMsg((HWND) NULL,"Too many clocks or timers!",pszStr1,TRUE);
        }
    }
    //
    // Clear the nInTimerSemaphore
    //
    nInTimerSemaphore = 0;

    // always return 0
    return 0;
}


/******************************************************************************
  int EndTest(HWND hWnd,int nNumTest)

  After each test run cleanup.
******************************************************************************/
int EndTest(HWND hWnd,int nNumTest)
{
    int     nReturn = 0;    // generic return value
    BOOL    bReturn;        // generic return value


    // shut off timer
    KillTimer(hWnd,TIMER_ONE);

    // close any open still imaging devices
    StiClose(&bReturn);

    // save test stats if more than non-trivial number of tests run
    if (nTestCount >= 2)
    {
        LoadString(hThisInstance,IDS_PRIVINI,pszOut,LONGSTRING);
        LoadString(hThisInstance,IDS_PRIVSECTION,pszStr4,LONGSTRING);

        _itoa(nTestCount,pszStr2,10);
        WritePrivateProfileString(pszStr4,"Last count",pszStr2,pszOut);
        _itoa(nScanCount,pszStr2,10);
        WritePrivateProfileString(pszStr4,"Last scan",pszStr2,pszOut);
        _itoa(nError,pszStr2,10);
        WritePrivateProfileString(pszStr4,"Last error",pszStr2,pszOut);
    }
    DisplayOutput("Testing complete");
    DisplayOutput("This run was %d loops (%d scans and %d errors)",
        nTestCount,nScanCount,nError);

    // reset current line, errors
//    nError = nNextLine = 0;

    //
    // end NT Logging
    //
    NTLogEnd();

    return nReturn;
}


/******************************************************************************
  BOOL NTLogInit()

  Initialize NT logging
******************************************************************************/
BOOL NTLogInit()
{
    //
    // Create the log object. We are specifying that the file be refreshed,
    // and that logging be output for variations. The flags also specify that
    // only output at SEV2, WARN and PASS levels should be logged.
    //
    dwNTStyle = TLS_SEV2 | TLS_WARN | TLS_PASS | TLS_VARIATION | TLS_REFRESH |
        TLS_TEST;


    LoadString(hThisInstance,IDS_NTLOG,pszStr1,LONGSTRING);
    hNTLog = tlCreateLog(pszStr1,dwNTStyle);
    tlAddParticipant(hNTLog,NULL,0);

    return (TRUE);
}


/******************************************************************************
  BOOL NTLogEnd()

  Terminate NT logging
******************************************************************************/
BOOL NTLogEnd()
{

    tlRemoveParticipant(hNTLog);
    tlDestroyLog(hNTLog);

    return (TRUE);
}


/******************************************************************************
  void Help()

  Display help.
******************************************************************************/
void Help()
{
    DisplayOutput("Stillvue command line parameters");
    DisplayOutput("");
    DisplayOutput("Stillvue -COMPLIANCE");
    DisplayOutput("  WHQL external Sti Compliance test");
    DisplayOutput("Stillvue -SHIPCRIT");
    DisplayOutput("  Internal PSD Sti Compliance test");
    DisplayOutput("Stillvue -ERRORLOG");
    DisplayOutput("  Errorlog limits test");
//    DisplayOutput("Stillvue -EXIT");
//    DisplayOutput("  Application will Exit after test completes");
    DisplayOutput("Stillvue -NODIALOG");
    DisplayOutput("  Don't display opening dialog");
    DisplayOutput("Stillvue -HELP");
    DisplayOutput("  Display this help");
    DisplayOutput("");

/*
    DisplayOutput("Stillvue /INF test.inf");
    DisplayOutput("  Read test.inf file");
    DisplayOutput("Stillvue /LOG test.log");
    DisplayOutput("  Write to test.log file");
    DisplayOutput("Stillvue /");
    DisplayOutput("  ");
*/

}


/******************************************************************************
  BOOL StartAutoTimer(HWND)
    Start the automated test timer

  Parameters
    Handle to app's window

  Return
    Return TRUE if successful, else FALSE

******************************************************************************/
BOOL StartAutoTimer(HWND hWnd)
{
    BOOL bAutoTimer = TRUE;


    // start the timer to run tests automatically
    LoadString(hThisInstance,IDS_APPNAME,pszStr1,MEDSTRING);

    if (! SetTimer(hWnd,TIMER_ONE,nTimeNext * nTimeMultiplier,NULL)) {
        ErrorMsg((HWND) NULL,"Too many clocks or timers!",pszStr1,TRUE);
        bAutoTimer = FALSE;
    } else {
        EnableMenuItem(hMenu, IDM_PAUSE,  MF_ENABLED);
        DisplayOutput("Starting the Automated tests");
    }

    return (bAutoTimer);
}


/******************************************************************************
  BOOL ComplianceDialog(HWND)
    Call the Compliance test confirmation dialog

  Parameters
    Handle to app's window

  Return
    Return TRUE if user pressed OK, else FALSE

******************************************************************************/
BOOL ComplianceDialog(HWND hWnd)
{
    BOOL bReturn = FALSE;


    if ((pSuite[0] == COMPLIANCE)&&(bCompDiag == TRUE)) {
        bReturn = fDialog(IDD_COMPLIANCE, hWnd, (FARPROC) Compliance);
        //
        // implement the settings if user pressed OK
        //
        if (bReturn == FALSE)
        {
            //
            // shut off timer and turn off automation
            //
            KillTimer(hWnd,TIMER_ONE);
            bAuto = FALSE;

            //
            // free the private lists
            //
            ClosePrivateList(&pdevRoot);

            DisplayOutput("Testing cancelled at user request");
            tlLog(hNTLog,TL_LOG,"Testing cancelled at user request");
        } else {
            DisplayOutput("Testing starting at user request");
            tlLog(hNTLog,TL_LOG,"Testing starting at user request");
        }
    }

    return (bReturn);
}


/******************************************************************************
    BOOL FAR PASCAL Compliance(HWND,UINT,WPARAM,LPARAM)
        OK the Compliance test dialog

    Parameters:
        The usual dialog box parameters.

    Return:
        Result of the call.

******************************************************************************/
BOOL FAR PASCAL Compliance(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
    PDEVLOG pPtr = pdevRoot;
    int     iIndex = 0;


    switch (msg) {

        case WM_INITDIALOG:

            //
            // fill dialog with Sti Device Internal Names
            //

            if (pPtr == NULL) {
                //
                // could not find any devices
                //
                wsprintf(pszStr1,"%s","No Sti devices found!");
                iIndex = SendDlgItemMessage(hDlg,IDC_COMPLIANCE_DEV_NAME,
                    LB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            } else {
                for (;pPtr->szLocalName;) {
                    //
                    // convert UNICODE string to ANSI
                    //
                    wsprintf(pszStr1,"%ls",pPtr->szLocalName);
                    iIndex = SendDlgItemMessage(hDlg,IDC_COMPLIANCE_DEV_NAME,
                        LB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);

                    if (pPtr->pNext)
                        pPtr = pPtr->pNext;
                    else
                        break;
                }
            }

            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }
    }
    return FALSE;
}


/******************************************************************************
    BOOL FAR PASCAL Settings(HWND,UINT,WPARAM,LPARAM)
        Miscellaneous settings dialog

    Parameters:
        The usual dialog box parameters.

    Return:
        Result of the call.

******************************************************************************/
BOOL FAR PASCAL Settings(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
    int     iIndex;
    int     iMC[] = { 0,1,10,100,200,300,-1 };
    int     iTN[] = { 1,2,5,10,20,30,-1 };
    int     iTS[] = { 10,20,30,60,120,-1 };

    switch (msg) {

        case WM_INITDIALOG:

            //
            // fill the comboboxes
            //
            for (iIndex = 0;iMC[iIndex] != -1;iIndex++) {
                _itoa(iMC[iIndex],pszStr1,10);
                SendDlgItemMessage(hDlg,IDC_MAX_SCAN,
                    CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }
            for (iIndex = 0;iTN[iIndex] != -1;iIndex++) {
                _itoa(iTN[iIndex],pszStr1,10);
                SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,
                    CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }
            for (iIndex = 0;iTS[iIndex] != -1;iIndex++) {
                _itoa(iTS[iIndex],pszStr1,10);
                SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,
                    CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }

            //
            // set the combobox to the current setttings
            //
            for (iIndex = 0;iMC[iIndex] != -1;iIndex++) {
                if (nMaxCount == iMC[iIndex])
                    break;
            }
            SendDlgItemMessage(hDlg,IDC_MAX_SCAN,CB_SETCURSEL,iIndex,0);
            for (iIndex = 0;iTN[iIndex] != -1;iIndex++) {
                if (nTimeNext == iTN[iIndex])
                    break;
            }
            SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,CB_SETCURSEL,iIndex,0);
            for (iIndex = 0;iTS[iIndex] != -1;iIndex++) {
                if (nTimeScan == iTS[iIndex])
                    break;
            }
            SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,CB_SETCURSEL,iIndex,0);

            return TRUE;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    iIndex = SendDlgItemMessage(hDlg,IDC_MAX_SCAN,CB_GETCURSEL,0,0);
                    iIndex = SendDlgItemMessage(hDlg,IDC_MAX_SCAN,
                        CB_GETLBTEXT,iIndex,(LPARAM) (LPCTSTR) pszStr1);
                    nTTMax = atoi(pszStr1);

                    iIndex = SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,CB_GETCURSEL,0,0);
                    iIndex = SendDlgItemMessage(hDlg,IDC_AUTO_SECONDS,
                        CB_GETLBTEXT,iIndex,(LPARAM) (LPCTSTR) pszStr1);
                    nTTNext = atoi(pszStr1);

                    iIndex = SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,CB_GETCURSEL,0,0);
                    iIndex = SendDlgItemMessage(hDlg,IDC_SCAN_SECONDS,
                        CB_GETLBTEXT,iIndex,(LPARAM) (LPCTSTR) pszStr1);
                    nTTScan = atoi(pszStr1);

                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return TRUE;
            }

    }
    return FALSE;
}


/******************************************************************************
  BOOL SizeDiff(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Output redraw handler when window size changes.
******************************************************************************/
BOOL SizeDiff(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    RECT rcClient;


    GetClientRect(hWnd,&rcClient);
    SetWindowPos(hLogWindow,NULL,0,0,
        rcClient.right+(GetSystemMetrics(SM_CXBORDER)*2),
        rcClient.bottom+(GetSystemMetrics(SM_CXBORDER)*2),
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
    // always return 0
    return 0;
}


/******************************************************************************
  BOOL HScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Horizontal scroll handler.
******************************************************************************/
BOOL HScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    int iHscrollInc;


    switch (LOWORD (wParam))
    {
    case SB_LINEUP :
        iHscrollInc = -1 ;
        break ;

    case SB_LINEDOWN :
        iHscrollInc = 1 ;
        break ;

    case SB_PAGEUP :
        iHscrollInc = -8 ;
        break ;

    case SB_PAGEDOWN :
        iHscrollInc = 8 ;
        break ;

    case SB_THUMBPOSITION :
        iHscrollInc = HIWORD(wParam) - iHscrollPos ;
        break ;

    default :
        iHscrollInc = 0 ;
    }
    iHscrollInc = max (-iHscrollPos,
        min (iHscrollInc, iHscrollMax - iHscrollPos)) ;

    if (iHscrollInc != 0)
    {
        iHscrollPos += iHscrollInc ;
        ScrollWindow (hWnd, -cxChar * iHscrollInc, 0, NULL, NULL) ;
        SetScrollPos (hWnd, SB_HORZ, iHscrollPos, TRUE) ;
    }
    // always return 0
    return 0;
}


/******************************************************************************
  BOOL VScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)

  Vertical scroll handler.
******************************************************************************/
BOOL VScroll(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    int iVscrollInc;


    switch (LOWORD (wParam))
    {
    case SB_TOP :
        iVscrollInc = -iVscrollPos ;
        break ;

    case SB_BOTTOM :
        iVscrollInc = iVscrollMax - iVscrollPos ;
        break ;

    case SB_LINEUP :
        iVscrollInc = -1 ;
        break ;

    case SB_LINEDOWN :
        iVscrollInc = 1 ;
        break ;

    case SB_PAGEUP :
        iVscrollInc = min (-1, -cyClient / cyChar) ;
        break ;

    case SB_PAGEDOWN :
        iVscrollInc = max (1, cyClient / cyChar) ;
        break ;

    case SB_THUMBTRACK :
        iVscrollInc = HIWORD (wParam) - iVscrollPos ;
        break ;

    default :
        iVscrollInc = 0 ;
    }
    iVscrollInc = max (-iVscrollPos,
        min (iVscrollInc, iVscrollMax - iVscrollPos)) ;

    if (iVscrollInc != 0)
    {
        iVscrollPos += iVscrollInc ;
        ScrollWindow (hWnd, 0, -cyChar * iVscrollInc, NULL, NULL) ;
        SetScrollPos (hWnd, SB_VERT, iVscrollPos, TRUE) ;
        UpdateWindow (hWnd) ;
    }
    // always return 0
    return 0;
}


/******************************************************************************
  BOOL Creation(HWND,UINT,WPARAM,LPARAM)

  Initialization and global allocation.
  Return 0 to continue creation of window, -1 to quit
******************************************************************************/
BOOL Creation(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    TEXTMETRIC  tm;
    RECT        rRect;
    HDC         hDC;


    // seed random generator
    srand((unsigned)time(NULL));

    // create the 5 display and utility strings
    if (! ((hLHand[0] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszOut = (PSTR) LocalLock(hLHand[0]))))
        return -1;
    if (! ((hLHand[1] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr2 = (PSTR) LocalLock(hLHand[1]))))
        return -1;
    if (! ((hLHand[2] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr1 = (PSTR) LocalLock(hLHand[2]))))
        return -1;
    if (! ((hLHand[3] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr3 = (PSTR) LocalLock(hLHand[3]))))
        return -1;
    if (! ((hLHand[4] = LocalAlloc(LPTR,LONGSTRING)) &&
        (pszStr4 = (PSTR) LocalLock(hLHand[4]))))
        return -1;

    // create output display window
    hDC = GetDC(hWnd);
    GetTextMetrics(hDC,&tm);

    cxChar = tm.tmAveCharWidth ;
    cxCaps = (tm.tmPitchAndFamily & 1 ? 3 : 2) * cxChar / 2 ;
    cyChar = tm.tmHeight + tm.tmExternalLeading ;
    iMaxWidth = 40 * cxChar + 22 * cxCaps ;

    ReleaseDC(hWnd,hDC);

    GetClientRect(hWnd,&rRect);

    if (NULL == (hLogWindow = CreateWindow("LISTBOX",NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL |
        LBS_NOINTEGRALHEIGHT | LBS_NOSEL,
        0,0,rRect.right,rRect.bottom,hWnd,NULL,
        (HINSTANCE)GetWindowLong(hWnd,GWL_HINSTANCE),NULL)))
        return -1;

    // create the DIB to display scanned image
    CreateScanDIB(hWnd);

    // return 0 to continue creation of window
    return 0;
}


/******************************************************************************
  BOOL Destruction(HWND,UINT,WPARAM,LPARAM)

  Current instance termination routines.
  Free error message buffer, send destroy window message.
  Note that if Creation() fails, pszMessage is 0.
******************************************************************************/
BOOL Destruction(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    int     x;  // loop counter


    LoadString(hThisInstance,IDS_PRIVINI,pszStr2,LONGSTRING);
    LoadString(hThisInstance,IDS_PRIVSECTION,pszStr1,LONGSTRING);

    // save window location
    SaveFinalWindow(hThisInstance,hWnd,pszStr2,pszStr1);

    // free the 5 display and utility strings
    for (x = 0;x < 5;x++)
    {
        LocalUnlock(hLHand[x]);
        LocalFree(hLHand[x]);
    }

    // delete the DIB object
    DeleteScanDIB();

    // free the output and main windows
    DestroyWindow(hLogWindow);
    DestroyWindow(hWnd);

    // always return 0
    return 0;
}


/******************************************************************************
  BOOL OnDeviceChange(HWND,UINT,WPARAM,LPARAM)

******************************************************************************/

const   CHAR    cszStiBroadcastPrefix[] = TEXT("STI");

BOOL OnDeviceChange(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    struct _DEV_BROADCAST_USERDEFINED *pBroadcastHeader;

    if (wParam == DBT_USERDEFINED ) {

        pBroadcastHeader = (struct _DEV_BROADCAST_USERDEFINED *)lParam;

        __try {

            if (pBroadcastHeader &&
                (pBroadcastHeader->dbud_dbh.dbch_devicetype == DBT_DEVTYP_OEM) &&
                (_strnicmp(pBroadcastHeader->dbud_szName,cszStiBroadcastPrefix,lstrlen(cszStiBroadcastPrefix)) == 0)
                ) {

                //
                // Got STI device broadcast
                //

                DisplayOutput("Received STI device broadcast with message:%s  ",
                              pBroadcastHeader->dbud_szName + lstrlen(cszStiBroadcastPrefix));

            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER ) {
            ::GetExceptionCode();
        }

    }

    return FALSE;
}


/******************************************************************************
  BOOL FirstInstance(HANDLE)

  Register the window.
  Return TRUE/FALSE on success/failure.
******************************************************************************/
BOOL FirstInstance(HINSTANCE hInst)
{
   PWNDCLASS    pClass;
   PSTR         pszClass;


    if (! (pszClass = (PSTR) LocalAlloc(LPTR, LONGSTRING)))
        return FALSE;
    LoadString((HINSTANCE)hInst, IDS_CLASSNAME, pszClass, LONGSTRING);

    pClass = (PWNDCLASS) LocalAlloc(LPTR, sizeof(WNDCLASS));

    // set hbrBackground to 0 for no background (app draws background)
    // use COLOR_BACKGROUND+1 for desktop color
    pClass->style          = CS_HREDRAW | CS_VREDRAW;
    pClass->lpfnWndProc    = WiskProc;
    pClass->cbClsExtra     = 0;
    pClass->cbWndExtra     = 0;
    pClass->hInstance      = (HINSTANCE)hInst;
    pClass->hIcon          = LoadIcon((HINSTANCE)hInst, MAKEINTRESOURCE(IDI_STI));
    pClass->hCursor        = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
    pClass->hbrBackground  = (HBRUSH) (COLOR_WINDOW + 1);
    pClass->lpszMenuName   = NULL;
    pClass->lpszClassName  = (LPSTR) pszClass;

    if (! (RegisterClass((LPWNDCLASS) pClass)))
        return FALSE;

    LocalFree((HANDLE) pClass);
    LocalFree((HANDLE) pszClass);

    return TRUE;
}


/******************************************************************************
  HWND MakeWindow(HANDLE)

  Create a window for current instance.
  Return handle to window (which is 0 on failure)
******************************************************************************/
HWND MakeWindow(HINSTANCE hInst)
{
    HWND    hWindow;
    PSTR    pszA,pszB;
    RECT    rect;
    DWORD   dwError;


    // if we can't get string memory, shut down app
    if (pszA = (PSTR) LocalAlloc(LPTR, LONGSTRING))
    {
        if (! (pszB = (PSTR) LocalAlloc(LPTR, LONGSTRING)))
        {
            LocalFree((HANDLE) pszA);
            return FALSE;
        }
    }
    else
        return FALSE;

    // get the caption, classname
    LoadString(hInst, IDS_PRIVINI, pszA, LONGSTRING);
    LoadString(hInst, IDS_PRIVSECTION, pszB, LONGSTRING);

    GetFinalWindow(hInst,&rect,pszA,pszB);

    LoadString(hInst,IDS_CAPTION,pszA,LONGSTRING);
    LoadString(hInst,IDS_CLASSNAME,pszB,LONGSTRING);

    hWindow = CreateWindow((LPSTR) pszB,
        (LPSTR) pszA,
        WS_OVERLAPPEDWINDOW,
        rect.left,
        rect.top,
        rect.right,
        rect.bottom,
        (HWND) NULL,
        0,
        hInst,
        NULL);

    if (hWindow == 0)
        dwError = GetLastError();

    // Save Instance globally
    hThisInstance = hInst;

    LocalFree((HANDLE) pszB);
    LocalFree((HANDLE) pszA);

    return hWindow;
}


/******************************************************************************
  void DisplayOutput(LPSTR pString,...)

  Show text on the display window
******************************************************************************/
void DisplayOutput(LPSTR pString,...)
{
    char    Buffer[512];
    MSG     msg;
    int     iIndex;
    va_list list;


    va_start(list,pString);
    vsprintf(Buffer,pString,list);

    if (ulCount1++ == MAX_LOOP)
    {
        ulCount1 = 1;
        ulCount2++;
        SendMessage(hLogWindow,LB_RESETCONTENT,0,0);
    }

    iIndex = SendMessage(hLogWindow,LB_ADDSTRING,0,(LPARAM)Buffer);
    SendMessage(hLogWindow,LB_SETCURSEL,iIndex,(LPARAM)MAKELONG(FALSE,0));

    while (PeekMessage(&msg,NULL,0,0,PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UpdateWindow(hLogWindow);
}


/******************************************************************************
  void LogOutput(int,LPSTR pString,...)

  Show text on the display window
******************************************************************************/
void LogOutput(int nVerbose,LPSTR pString,...)
{
    char    Buffer[512];
    MSG     msg;
    int     iIndex;
    va_list list;


    va_start(list,pString);
    vsprintf(Buffer,pString,list);

    if (ulCount1++ == MAX_LOOP)
    {
        ulCount1 = 1;
        ulCount2++;
        SendMessage(hLogWindow,LB_RESETCONTENT,0,0);
    }

    iIndex = SendMessage(hLogWindow,LB_ADDSTRING,0,(LPARAM)Buffer);
    SendMessage(hLogWindow,LB_SETCURSEL,iIndex,(LPARAM)MAKELONG(FALSE,0));

    while (PeekMessage(&msg,NULL,0,0,PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UpdateWindow(hLogWindow);
}


/*****************************************************************************
    void StiDisplayError(HRESULT,char *,BOOL)
        Display verbose error information

    Parameters:
        HRESULT from failed call
        failed call title string
        BOOL TRUE to record error, else ignore it


    Return:
        none

*****************************************************************************/
void FatalError(char *szMsg)
{
    DisplayOutput(szMsg);
    DisplayOutput("* FATAL ERROR CANNOT CONTINUE *");

    return;
}


/******************************************************************************
  void DisplayLogPassFail(BOOL bPass)


******************************************************************************/
void DisplayLogPassFail(BOOL bPass)
{
    if (bPass)
        sprintf(pszStr1,"  PASS");
    else
        sprintf(pszStr1,"  FAIL");
    DisplayOutput(pszStr1);
    DisplayOutput("");
    tlLog(hNTLog,TL_LOG,pszStr1);
}


/******************************************************************************
  BOOL ParseCmdLine(LPSTR lpCmdLine)

  Parse the command line for valid options

  Return TRUE if an automated test was selected, else FALSE
******************************************************************************/
BOOL ParseCmdLine(LPSTR lpCmdLine)
{
    int     nAnyTest = 0,
            nInfFile = 0,
            nLogFile = 0,
            nWLogFile = 0,
            next;
    char    *pArg,
            *szPtr,
            szTmpBuf[LONGSTRING];


    if (*lpCmdLine) {
        DisplayOutput("Command line: \"%s\"",lpCmdLine);
        DisplayOutput("");
    }

    for (pArg = lpCmdLine;*pArg;)
    {
        next = NextToken(szTmpBuf,pArg);
        pArg += next;

        // remove the common command line separators (if present)
        if (szTmpBuf[0] == '/' || szTmpBuf[0] == '-')
            strcpy(szTmpBuf,(szTmpBuf + 1));

        // upper case our parameter
        for (szPtr = &szTmpBuf[0];*szPtr;szPtr++)
            *szPtr = toupper(*szPtr);

        // Look for other switches
        switch(szTmpBuf[0])
        {
        case '?':
        case 'H':
            if (! nAnyTest) {
                // request for help
                if ((! strncmp("?",szTmpBuf,strlen(szTmpBuf)) ||
                    (! strncmp("HELP",szTmpBuf,strlen(szTmpBuf))))) {
                    pSuite = nHelpSuite;
                    nMaxCount = 1;
                    nAnyTest = 1;
                }
            }
            break;
        case 'C':
            if (! nAnyTest) {
                // external Sti compliance test
                if (! strncmp("COMPLIANCE",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nComplianceSuite;
                    nMaxCount = 3;
                    nTimeScan = 10;
                    nTimeNext = 1;
                    nAnyTest = 1;

                    // get handle to the compliance menu
                    hMenu = LoadMenu(hThisInstance,
                        MAKEINTRESOURCE(IDR_STI_COMP));
                }
            }
            break;
        case 'E':
            if (! nAnyTest) {
                // external Sti compliance test
                if (! strncmp("ERRORLOG",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nErrorlogSuite;
                    nMaxCount = 1;
                    nTimeNext = 1;
                    nAnyTest = 1;
                }
            }
            // exit when test has run
            if (! strncmp("EXIT",szTmpBuf,strlen(szTmpBuf)))
                bExit = TRUE;
            break;
        case 'I':
            if (! nInfFile) {
                // read test instructions from an .INF file
                if (! strncmp("INF",szTmpBuf,strlen(szTmpBuf))) {
// inf file stuff
                    nInfFile = 1;
                }
            }
            break;
        case 'L':
            if (! nLogFile) {
                // write screen output to .LOG file
                if (! strncmp("LOG",szTmpBuf,strlen(szTmpBuf))) {
// log file stuff
                    nLogFile = 1;
                }
            }
            break;
        case 'N':
            // don't show COMPLIANCE test dialog
            if (! strncmp("NODIALOG",szTmpBuf,strlen(szTmpBuf)))
                bCompDiag = FALSE;
            break;
        case 'S':
            if (! nAnyTest) {
                // internal Sti SHIPCRIT test
                if (! strncmp("SHIPCRIT",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nShipcritSuite;
                    nMaxCount = 200;
                    nTimeScan = 10;
                    nTimeNext = 1;
                    nAnyTest = 1;
                }
            }
            // the application was launched by an Sti event!
            if (! (strncmp(STIEVENTARG,szTmpBuf, strlen(STIEVENTARG))) ||
                (! (strncmp(STIDEVARG,szTmpBuf, strlen(STIDEVARG))))) {
                nEvent = 1;
                MessageBox(NULL,szTmpBuf,"Stillvue",MB_OK);
            }
            break;
        case 'T':
            if (! nAnyTest) {
                // external Sti compliance test
                if (! strncmp("TEST",szTmpBuf,strlen(szTmpBuf))) {
                    pSuite = nOutputSuite;
                    nMaxCount = 0;
                    nTimeNext = 1;
                    nAnyTest = 1;
                    nTimeMultiplier = 1;
                }
            }
            break;
        case 'W':
            if (! nWLogFile) {
                // write NTLOG output to STIWHQL.LOG file
                if (! strncmp("WHQL",szTmpBuf,strlen(szTmpBuf))) {
// log file stuff
                    nWLogFile = 1;
                }
            }
            break;
        default:
            break;
        }
    }

    if (nAnyTest)
        return TRUE;
    else
        return FALSE;
}


/******************************************************************************
  int PASCAL WinMain(HANDLE,HANDLE,LPSTR,short)

  The app itself.
******************************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR lpCmdLine,
                   int nCmdShow)
{
    MSG     msg;                        // message passing structure
    HWND    hWnd;                       // Handle to main window
    HMENU   hMenuPopup;                 // add ports to PORT menu


    // exit if registration and window creation fail
    if (! FirstInstance (hInstance))
       return FALSE;

    // Can't create window? Bail out
    if (! (hWnd = MakeWindow (hInstance)))
        return FALSE;

    ShowWindow(hWnd,nCmdShow);

    // save instance
    hThisInstance = hInstance;

    // initialize NT Logging
    NTLogInit();

    // display name of this app
    LoadString(hThisInstance,IDS_APPNAME,pszOut,LONGSTRING);
    LoadString(hThisInstance,IDS_CAPTION,pszStr2,LONGSTRING);
    wsprintf(pszStr1,"%s - %s",pszOut,pszStr2);
    DisplayOutput(pszStr1);

    // display last run statistics
    {
        int     nCount,
                nScan,
                nError;


        LoadString(hThisInstance,IDS_PRIVINI,pszStr3,LONGSTRING);
        LoadString(hThisInstance,IDS_PRIVSECTION,pszStr4,LONGSTRING);

        nCount = GetPrivateProfileInt(pszStr4,"Last count",0,pszStr3);
        nScan  = GetPrivateProfileInt(pszStr4,"Last scan",0,pszStr3);
        nError = GetPrivateProfileInt(pszStr4,"Last error",0,pszStr3);

        wsprintf(pszStr1,
            "Last run was %d loops (%d scans and %d errors)",
            nCount,nScan,nError);
        DisplayOutput(pszStr1);
    }

    // get handle to the standard menu
    hMenu = LoadMenu(hThisInstance, MAKEINTRESOURCE(IDR_STI_LAB));

    // parse the command line
    bAuto = ParseCmdLine(lpCmdLine);

    // start test timer if automated test on command line
    if (bAuto)
    {
        bAuto = StartAutoTimer(hWnd);
    }

    // start Sti event handler if an Sti event launched us
    if (nEvent)
    {
        BOOL    bReturn;


        StiCreateInstance(&bReturn);
        StiEnum(&bReturn);
        StiEvent(hWnd);
        // select the device that called the event
        StiSelect(hWnd,EVENT,&bReturn);
    }

    // load the selected menu
    hMenuPopup = CreateMenu();
    SetMenu(hWnd, hMenu);

    while (GetMessage(&msg,(HWND) NULL,0,0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}


/******************************************************************************
  long FAR PASCAL WiskProc(HWND,UINT,WPARAM,LPARAM)

  The main exported procedure.
******************************************************************************/
long FAR PASCAL WiskProc(HWND hWnd,UINT wMsgID,WPARAM wParam,LPARAM lParam)
{
    switch (wMsgID)
    {
        case WM_COMMAND:
            return CommandParse(hWnd,wMsgID,wParam,lParam);

        case WM_TIMER:
            return TimerParse(hWnd,wMsgID,wParam,lParam);

        case WM_SIZE:
            return SizeDiff(hWnd,wMsgID,wParam,lParam);

        case WM_HSCROLL:
            return HScroll(hWnd,wMsgID,wParam,lParam);

        case WM_VSCROLL:
            return VScroll(hWnd,wMsgID,wParam,lParam);

        case WM_CLOSE:
            EndTest(hWnd,0);
            return Destruction(hWnd,wMsgID,wParam,lParam);

        case WM_DESTROY:
            PostQuitMessage(0);
            return 0L;

        case WM_CREATE:
            return Creation(hWnd,wMsgID,wParam,lParam);

        case WM_DEVICECHANGE:
            return OnDeviceChange(hWnd,wMsgID,wParam,lParam);

        default:
            return DefWindowProc(hWnd,wMsgID,wParam,lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\stivar.h ===
/******************************************************************************

  stivar.h

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include "resource.h"

//
// reset listbox window display after this many iterations
//
#define MAX_LOOP 16383

//
// INF defines
//
#define INFBUFSIZ                   0x8000      // assume 32k for largest INF

//
// available test suites
//

#define NONE                        500         // no test suite selected
#define HELP                        501         // display help
#define COMPLIANCE                  502         // external compliance suite
#define SHIPCRIT                    503         // internal compliance suite
#define ERRORLOG                    504         // big error log test
#define TEST                        505         // test test

//
// Sti service tests
//
enum TimedTests {
    // open iStillImage interface
    tCreateInstance,
    // IStillImage interface
    tGetDeviceList,
    tCreateDevice,
    tGetDeviceInfo,
    tGetDeviceValue,
    tSetDeviceValue,
    tRegisterLaunchApplication,
    tUnRegisterLaunchApplication,
    tEnableHwNotifications,
    tGetHwNotificationState,
    tWriteToErrorLog,
    // variation
    tWriteToErrorLogBig,
    tReleaseSti,
    // IStillDevice interface
    tGetStatusA,
    tGetStatusB,
    tGetStatusC,
    tGetCapabilities,
    tDeviceReset,
    tDiagnostic,
    tGetLastInfoError,
    tSubscribe,
    tUnSubscribe,
    tEscapeA,
    tEscapeB,
    tRawReadDataA,
    tRawReadDataB,
    tRawWriteDataA,
    tRawWriteDataB,
    tRawReadCommandA,
    tRawReadCommandB,
    tRawWriteCommandA,
    tRawWriteCommandB,
    tReleaseDevice,
    // select a device name
    tSelectDeviceName,
    // Scan (if HP SCL device)
    tAcquire,
    // help request
    tHelp,
    // Beginning of test pass initialization
    tBeginningOfTest,
    // output test
    tTest,
    // End of test pass summary
    tEndOfTest
} tLabTests;

//
// display help
//
int nHelpSuite[] = {
    HELP,
    tBeginningOfTest,
    tHelp,
    tEndOfTest,
    -1
};

//
// external Sti Compliance tests
//
int nComplianceSuite[] = {
    COMPLIANCE,
    tBeginningOfTest,
    tCreateInstance,
    tGetDeviceList,
    tCreateDevice,
    tGetStatusA,
    tGetStatusB,
    tGetStatusC,
    tDiagnostic,
    tGetDeviceValue,
    tGetCapabilities,
    tGetLastInfoError,
//  tSubscribe,
//  tUnSubscribe,
    tDeviceReset,
    tEscapeA,
    tRawReadDataA,
    tRawWriteDataA,
    tRawReadCommandA,
    tRawWriteCommandA,
    tReleaseDevice,
    tReleaseSti,
    tEndOfTest,
    -1
};

//
// internal Sti Compliance tests
//
int nShipcritSuite[] = {
    SHIPCRIT,
    tBeginningOfTest,
    tCreateInstance,
    tGetDeviceList,
    tSelectDeviceName,
    tGetDeviceInfo,
    tGetDeviceValue,
    tSetDeviceValue,
    tRegisterLaunchApplication,
    tUnRegisterLaunchApplication,
    tEnableHwNotifications,
    tGetHwNotificationState,
    tWriteToErrorLog,
    tCreateDevice,
    tGetStatusA,
    tGetStatusB,
    tGetStatusC,
    tDiagnostic,
    tDeviceReset,
    tGetDeviceInfo,
    tGetDeviceValue,
    tSetDeviceValue,
    tRegisterLaunchApplication,
    tUnRegisterLaunchApplication,
    tEnableHwNotifications,
    tGetHwNotificationState,
    tWriteToErrorLog,
    tGetCapabilities,
    tGetLastInfoError,
//  tSubscribe,
//  tUnSubscribe,
    tEscapeA,
    tRawReadDataA,
    tRawWriteDataA,
    tRawReadCommandA,
    tRawWriteCommandA,
    tAcquire,
    tReleaseDevice,
    tReleaseSti,
    tEndOfTest,
    -1
};


//
// big Error log tests
//
int nErrorlogSuite[] = {
    ERRORLOG,
    tBeginningOfTest,
    tCreateInstance,
    tGetDeviceList,
    tSelectDeviceName,
    tWriteToErrorLogBig,
    tReleaseSti,
    tEndOfTest,
    -1
};


//
// test tests
//
int nOutputSuite[] = {
    TEST,
    tBeginningOfTest,
    tTest,
    tEndOfTest,
    -1
};


//
// Test Suite test strings
//
STRINGTABLE StSuiteStrings[] =
{
    tCreateInstance, "Create Instance",0,
    tGetDeviceList, "Get Device List",0,
    tCreateDevice, "Create Device",0,
    tGetDeviceInfo, "Get Device Info",0,
    tGetDeviceValue, "Get Device Value",0,
    tSetDeviceValue, "Set Device Value",0,
    tRegisterLaunchApplication, "Register Launch Application",0,
    tUnRegisterLaunchApplication, "UnRegister Launch Application",0,
    tEnableHwNotifications, "Enable Hardware Notifications",0,
    tGetHwNotificationState, "Get Hardware Notification State",0,
    tWriteToErrorLog, "Write To Error Log (variation A)",0,
    tWriteToErrorLogBig, "Write to Error Log (variation B)",0,
    tReleaseSti, "Release Sti subsystem",0,
    tGetStatusA, "Get Status (Online)",0,
    tGetStatusB, "Get Status (Event)",0,
    tGetStatusC, "Get Status (All)",0,
    tGetCapabilities, "Get Capabilities",0,
    tDeviceReset, "Device Reset",0,
    tDiagnostic, "Diagnostic",0,
    tGetLastInfoError, "Get Last Error Information",0,
    tSubscribe, "Subscribe",0,
    tUnSubscribe, "Unsubscribe",0,
    tEscapeA, "Escape (variation A)",0,
    tEscapeB, "Escape (variation B)",0,
    tRawReadDataA, "Raw Read Data (variation A)",0,
    tRawReadDataB, "Raw Read Data (variation B)",0,
    tRawWriteDataA, "Raw Write Data (variation A)",0,
    tRawWriteDataB, "Raw Write Data (variation B)",0,
    tRawReadCommandA, "Raw Read Command (variation A)",0,
    tRawReadCommandB, "Raw Read Command (variation B)",0,
    tRawWriteCommandA, "Raw Write Command (variation A)",0,
    tRawWriteCommandB, "Raw Write Command (variation B)",0,
    tReleaseDevice, "Release Device",0,
    tSelectDeviceName, "Select Device Name",0,
    tAcquire, "Acquire",0,
    tHelp, "Help",0,
    tBeginningOfTest, "Beginning of Test",0,
    tTest, "Test",0,
    tEndOfTest, "End of testing",0,
    0, "Unknown Test",-1
};


//
// timers
//
#define TIMER_ONE                   3001
#define TIMER_TWO                   3002


//
// GLOBAL VARIABLES
//

//
// global window handles
//
HINSTANCE   hThisInstance;              // current instance
HWND        hThisWindow;                // current window
HMENU       hMenu;                      // current menu

//
// general purpose strings
//
HGLOBAL     hLHand[5];                  // utility string handles
LPSTR       lpzString;                  // utility FAR string
PSTR        pszOut,                     // TextOut string
            pszStr1,                    // utility NEAR strings
            pszStr2,
            pszStr3,
            pszStr4;

//
// global test settings
//
BOOL        bAuto        = FALSE,        // TRUE = running an Automated test
            bCompDiag    = TRUE,         // TRUE = show COMPLIANCE test dialog
            bExit        = FALSE;        // TRUE = exit when test has completed
int         nError       = 0,            // number of errors
            nEvent       = 0,            // 1 = StiEvent, 2 = StiDevice
            nFatal       = 0,            // can't continue after this...
            nGo          = 0,            // 1 = nonstop timed test
            nHWState     = 0,            // current HWEnable state
            nICanScan    = 0,            // Stillvue can / can't scan this device
            nInATestSemaphore = 0,       // 1 = a test is running
            nInTimerSemaphore = 0,       // 1 = don't reenter TimerParse
            nLastLine    = 1,            // last line number in script
            nMaxCount    = 1,            // run test Suite this many times
            nNameOnly    = 0,            // 1 = select device name, not device
            nNextLine    = 1,            // next line of inf to run
            nNextTest    = 0,            // pointer to next test to run
            nPause       = 0,            // toggle for run (0) pause test (! 0)
            nRunInf      = 0,            // 0 = no INF, 1 = INF is loaded
            nRadix       = 10,           // base is decimal (or hex)
            nSaveLog     = 0,            // always write out log
            nScanCount   = 0,            // number of scans run so far
            nScriptLine  = 1,            // next script line to parse
            nTestCount   = 1,            // number of tests run so far
            nTestID      = 0,            // the current test ID
            nTimeMultiplier = 1000,      // multiply nTimeNext for seconds
            nTimeNext    = 5,            // wait time between timer in seconds
            nTimeState   = 0,            // 0 timer is off, 1 timer is on
            nTimeScan    = 60,           // wait nTimeNext units before next scan
            nTTMax       = 0,            // temp var
            nTTNext      = 0,            // temp var
            nTTScan      = 0,            // temp var
            nUnSubscribe = 0,            // 0 = UnSubscribe'd, 1 = Subscribed
            nUnSubscribeSemaphore = 0;   // semaphore for UnSubscribe
int         *pSuite      = nHelpSuite;   // pointer to test Suite to run
DWORD       dwLastError  = 0;            // last GetLastError found

//
// text display
//
HWND        hLogWindow;
ULONG       ulCount1,ulCount2;
int         cxChar,cxCaps,cyChar,cxClient,cyClient,iMaxWidth,
            iHscrollPos,iHscrollMax,
            iVscrollPos,iVscrollMax;

//
// inf, logfile, NT logging
//
HANDLE      hLog = NULL,                // output log file handle
            hDLog = NULL,               // display output log handle
            hNTLog = NULL;              // NT log handle
char        szInfName[LONGSTRING] = "", // input script file name
            szDLogName[LONGSTRING] = "",// display output log file name
            szWLogName[LONGSTRING] = "";// WHQL NTLOG output log file name
LPSTR       lpInf = NULL,               // buffer for INF commands
            lpLine;
DWORD       dwNTStyle;                  // NTLog style

//
// device logging
//
PDEVLOG     pdevPtr = NULL,             // pointer to current device log device
            pdevRoot = NULL;            // base of the device log table
PVOID       pInfoPrivate = NULL;        // private list of devices under test
PSTI_DEVICE_INFORMATION
            pInfoPrivatePtr = NULL;     // pointer to device in pStiBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stillvue.rc
//
#define IDD_SELECT                      701
#define IDD_SETTINGS                    702
#define IDD_SETVALUE                    703
#define IDD_COMPLIANCE                  704
#define IDI_STI                         801
#define IDR_STI_COMP                    901
#define IDR_STI_DDK                     902
#define IDR_STI_LAB                     903
#define IDM_                            1001
#define IDM_GO                          1002
#define IDM_STOP                        1003
#define IDM_TIMERON                     1004
#define IDM_TIMEROFF                    1005
#define IDM_TIMERNEW                    1006
#define IDM_CLEAR                       1007
#define IDM_HEX                         1008
#define IDM_DECIMAL                     1009
#define IDM_TIMEOUT                     1010
#define IDM_NEXT                        1011
#define IDC_EDIT1                       1011
#define IDM_AUTO                        1012
#define IDM_OPEN                        1013
#define IDM_CLOSE                       1014
#define IDM_HELP                        1015
#define IDM_ACTION                      1016
#define IDM_LAMPON                      1017
#define IDM_LAMPOFF                     1018
#define IDM_SCAN                        1019
#define IDM_ACQUIRE                     1020
#define IDM_SHOWDIB                     1021
#define IDM_PAUSE                       1022
#define IDM_SETTINGS                    1023
#define IDM_LAST_STATS                  1024
#define IDM_THIS_STATS                  1025
#define IDM_GETLASTERROR                1026
#define IDM_INTERNAL                    1027
#define IDM_EXTERNAL                    1028
#define IDM_COMPLIANCE                  1029
#define IDM_SHIPCRIT                    1030
#define IDM__                           1050
#define IDM_CREATE_INSTANCE             1051
#define IDM___                          1052
#define IDM_INITIALIZE                  1053
#define IDM_GET_DEVLIST                 1054
#define IDM_GET_DEVINFO                 1055
#define IDM_CREATE_DEV                  1056
#define IDM_PICK_NAME                   1057
#define IDM_GET_DEVVAL                  1058
#define IDM_SET_DEVVAL                  1059
#define IDM_GET_LAUNCHINFO              1060
#define IDM_REGISTER_LAUNCH             1061
#define IDM_UNREGISTER_LAUNCH           1062
#define IDM_ENABLE_HWNOTIF              1063
#define IDM_GET_HWNOTIF                 1064
#define IDM_REFRESH_DEVBUS              1065
#define IDM_LAUNCH_APP_FOR_DEV          1066
#define IDM_SETUP_DEVPARAMS             1067
#define IDM_WRITE_ERRORLOG              1068
#define IDM_IMAGE_RELEASE               1069
#define IDM____                         1070
#define IDM_GET_STATUS_A                1071
#define IDM_GET_STATUS_B                1072
#define IDM_GET_STATUS_C                1073
#define IDM_GET_CAPS                    1074
#define IDM_DEVICERESET                 1075
#define IDM_DIAGNOSTIC                  1076
#define IDM_GET_LASTERRINFO             1077
#define IDM_LOCKDEV                     1078
#define IDM_UNLOCKDEV                   1080
#define IDM_SUBSCRIBE                   1081
#define IDM_UNSUBSCRIBE                 1082
#define IDM_GET_LASTNOTIFDATA           1083
#define IDM_ESCAPE_A                    1084
#define IDM_ESCAPE_B                    1085
#define IDM_RAWREADDATA_A               1086
#define IDM_RAWREADDATA_B               1087
#define IDM_RAWWRITEDATA_A              1088
#define IDM_RAWWRITEDATA_B              1089
#define IDM_RAWREADCOMMAND_A            1090
#define IDM_RAWREADCOMMAND_B            1091
#define IDM_RAWWRITECOMMAND_A           1092
#define IDM_RAWWRITECOMMAND_B           1093
#define IDM_DEVICE_RELEASE              1094
#define IDM_NEXT_DEVICE                 1095
#define IDM_____                        1096
#define IDC_SELECT_DEVICE               1201
#define IDC_SELECT_NAME                 1202
#define IDC_USER_DEVICE                 1203
#define IDC_AUTO_SECONDS                1204
#define IDC_SCAN_SECONDS                1205
#define IDC_RGB_R                       1206
#define IDC_RGB_G                       1207
#define IDC_RGB_B                       1208
#define IDC_MAX_SCAN                    1209
#define IDC_GET_VALUE                   1210
#define IDC_SETVAL_TYPE                 1211
#define IDC_SETVAL_DATA                 1212
#define IDC_COMPLIANCE_DEV_NAME         1213
#define IDC_                            1214
#define IDS_CLASSNAME                   1501
#define IDS_APPNAME                     1502
#define IDS_CAPTION                     1503
#define IDS_PRIVSECTION                 1504
#define IDS_PRIVINI                     1505
#define IDS_AUTO                        1506
#define IDS_LAST_COUNT                  1507
#define IDS_LAST_SCAN                   1508
#define IDS_LAST_ERROR                  1509
#define IDS_THIS_COUNT                  1510
#define IDS_THIS_SCAN                   1511
#define IDS_THIS_ERROR                  1512
#define IDS_NTLOG                       1514

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\winx.h ===
/******************************************************************************

  winx.h
  Windows utility procedures

  Copyright (C) Microsoft Corporation, 1997 - 1997
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/


// macros
#define RANDBYTE(r)     LOBYTE(rand() % ((r)+1))

#ifdef _DEBUG
#define TRAP { _asm int 3 }
#else
#define TRAP {}
#endif

// stringtables
typedef struct _STRINGTABLE
{
    long    number;
    char    *szString;
    long    end;
} STRINGTABLE, *PSTRINGTABLE;

/*
STRINGTABLE StSample[] =
{
    0, "String zero",0,
    1, "String one",0,
    0, "",-1
};

Retrieve strings associated with unique values:
  strString = StrFromTable(nValue,&StSample);

*/
extern STRINGTABLE StWinerror[];

// prototypes
ULONG   atox(LPSTR);
void    DisplayDebug(LPSTR sz,...);
BOOL    ErrorMsg(HWND,LPSTR,LPSTR,BOOL);
BOOL    fDialog(int,HWND,FARPROC);
void    FormatHex(unsigned char *,char *);
BOOL    GetFinalWindow (HANDLE,LPRECT,LPSTR,LPSTR);
BOOL    LastError(BOOL);
int     NextToken(char *,char *);
BOOL    SaveFinalWindow (HANDLE,HWND,LPSTR,LPSTR);
char *  StrFromTable(long,PSTRINGTABLE);
BOOL    Wait32(DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\wsti.cpp ===
/******************************************************************************

  wsti.cpp
  WDM Still Imaging interface

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include "stillvue.h"

//
// globals defined in Stivar.h
//
extern  PDEVLOG         pdevPtr,                   // pointer to current device log device
pdevRoot;                  // base of the device log table
extern  PSTR            pszStr1,pszStr2,pszStr3,   // utility strings
pszStr4;
extern  HINSTANCE       hThisInstance;             // instance of this app
extern  HANDLE  hNTLog;                            // NT log handle
extern  HMENU           hMenu;                     // current menu
extern  int             *pSuite;                   // pointer to test Suite to run
extern  int             nError, nICanScan,         // global flags
nNextTest,                 // index into pSuite
nNameOnly, nScanCount,
nTestID,
nUnSubscribeSemaphore,     // semaphore for StiSubscribe
nUnSubscribe;              // flag to request UnSubscribe

//
// STI.H - STI_DEVICE_MJ_TYPE
//
STRINGTABLE StStiDeviceType[] =
{
    0, "StiDeviceTypeDefault",0,
    1, "StiDeviceTypeScanner",0,
    2, "StiDeviceTypeDigitalCamera",0,
    0, "Unknown device type",-1
};

//
// STIERR.H - errors
//
STRINGTABLE StStiError[] =
{
    STI_OK,                     "STI_OK",0,
    STI_NOTCONNECTED,           "STI_NOTCONNECTED",0,
    STI_CHANGENOEFFECT,         "STI_CHANGENOEFFECT",0,
    STIERR_OLD_VERSION,         "STIERR_OLD_VERSION",0,
    STIERR_BETA_VERSION,        "STIERR_BETA_VERSION",0,
    STIERR_BADDRIVER,           "STIERR_BADDRIVER",0,
    STIERR_DEVICENOTREG,        "STIERR_DEVICENOTREG",0,
    STIERR_OBJECTNOTFOUND,      "STIERR_OBJECTNOTFOUND",0,
    STIERR_INVALID_PARAM,       "STIERR_INVALID_PARAM",0,
    STIERR_NOINTERFACE,         "STIERR_NOINTERFACE",0,
    STIERR_GENERIC,             "STIERR_GENERIC", 0,
    STIERR_OUTOFMEMORY,         "STIERR_OUTOFMEMORY", 0,
    STIERR_UNSUPPORTED,         "STIERR_UNSUPPORTED", 0,
    STIERR_NOT_INITIALIZED,     "STIERR_NOT_INITIALIZED", 0,
    STIERR_ALREADY_INITIALIZED, "STIERR_ALREADY_INITIALIZED", 0,
    STIERR_DEVICE_LOCKED,       "STIERR_DEVICE_LOCKED", 0,
    STIERR_READONLY,            "STIERR_READONLY", 0,
    STIERR_NOTINITIALIZED,      "STIERR_NOTINITIALIZED", 0,
    STIERR_NEEDS_LOCK,          "STIERR_NEEDS_LOCK", 0,
    STIERR_SHARING_VIOLATION,   "STIERR_SHARING_VIOLATION", 0,
    STIERR_HANDLEEXISTS,        "STIERR_HANDLEEXISTS", 0,
    STIERR_INVALID_DEVICE_NAME, "STIERR_INVALID_DEVICE_NAME", 0,
    STIERR_INVALID_HW_TYPE,     "STIERR_INVALID_HW_TYPE", 0,
    STIERR_INVALID_HW_TYPE,     "STIERR_INVALID_HW_TYPE", 0,
    STIERR_NOEVENTS,            "STIERR_NOEVENTS", 0,
    0, "Unknown STI error",-1
};

//
// WINNT.H -  Predefined Value Types.
//
STRINGTABLE StRegValType[] =
{
    0, "REG_NONE",0,
    1, "REG_SZ",0,
    3, "REG_BINARY",0,
    4, "REG_DWORD",0,
    0, "Unknown reg type",-1
};

//
// global still image
//
PSTI                    pSti = NULL;        // handle to Sti subsystem
PVOID                   pStiInfo = NULL;    // Sti device info buffer
PSTI_DEVICE_INFORMATION pStiInfoPtr = NULL; // pointer to device in pStiBuffer
PSTIDEVICE              pStiDevice = NULL;  // Sti device being used
HANDLE                  hWaitEvent;         // Subscribe Event handle
int                     nStiNumber = 0;     // 0 based index into pStiInfo
DWORD                   dwStiTotal = 0;     // total number of Sti devices found
WCHAR                   szInternalName[STI_MAX_INTERNAL_NAME_LENGTH];
// user selected Sti device name
WCHAR                   szFriendlyName[STI_MAX_INTERNAL_NAME_LENGTH];
// user selected Sti friendly name


/*****************************************************************************

        define ACQUIRE to load device specific command handler for stub
        functions defined in STIDDK.CPP

*****************************************************************************/
#ifdef ACQUIRE
//
// device specific image acquire code
//
    #include "acquire.cpp"

#else
//
// only exercise Sti services
//
    #include "stisvc.cpp"

#endif


/*****************************************************************************
    void IStillImageMenu(DWORD dwState)
        Enable or Disable the menus for the IStillDevice interface.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillImageMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_IMAGE_RELEASE,         dwState);
    EnableMenuItem(hMenu, IDM_GET_DEVLIST,           dwState);
    EnableMenuItem(hMenu, IDM_CREATE_DEV,            dwState);
    EnableMenuItem(hMenu, IDM_REGISTER_LAUNCH,       dwState);
    EnableMenuItem(hMenu, IDM_UNREGISTER_LAUNCH,     dwState);
    EnableMenuItem(hMenu, IDM_WRITE_ERRORLOG,        dwState);
}


/*****************************************************************************
    void IStillNameMenu(DWORD dwState)
        Enable or Disable the menus for the IStillImage interface that only
                require a device name.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillNameMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_GET_DEVINFO,        dwState);
    EnableMenuItem(hMenu, IDM_GET_DEVVAL,         dwState);
    EnableMenuItem(hMenu, IDM_SET_DEVVAL,         dwState);
    EnableMenuItem(hMenu, IDM_GET_LAUNCHINFO,     dwState);
    EnableMenuItem(hMenu, IDM_ENABLE_HWNOTIF,     dwState);
    EnableMenuItem(hMenu, IDM_GET_HWNOTIF,        dwState);
    EnableMenuItem(hMenu, IDM_REFRESH_DEVBUS,     dwState);
    EnableMenuItem(hMenu, IDM_LAUNCH_APP_FOR_DEV, dwState);
    EnableMenuItem(hMenu, IDM_SETUP_DEVPARAMS,    dwState);
}


/*****************************************************************************
    void IStillDeviceMenu(DWORD dwState)
        Enable or Disable the menus for the IStillDevice interface.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillDeviceMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_GET_CAPS,           dwState);
    EnableMenuItem(hMenu, IDM_GET_STATUS_A,       dwState);
    EnableMenuItem(hMenu, IDM_GET_STATUS_B,       dwState);
    EnableMenuItem(hMenu, IDM_GET_STATUS_C,       dwState);
    EnableMenuItem(hMenu, IDM_DEVICERESET,        dwState);
    EnableMenuItem(hMenu, IDM_DIAGNOSTIC,         dwState);
    EnableMenuItem(hMenu, IDM_ESCAPE_A,           dwState);
    EnableMenuItem(hMenu, IDM_ESCAPE_B,           dwState);
    EnableMenuItem(hMenu, IDM_GET_LASTERRINFO,    dwState);
    EnableMenuItem(hMenu, IDM_LOCKDEV,            dwState);
    EnableMenuItem(hMenu, IDM_UNLOCKDEV,          dwState);
    EnableMenuItem(hMenu, IDM_RAWREADDATA_A,      dwState);
    EnableMenuItem(hMenu, IDM_RAWREADDATA_B,      dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITEDATA_A,     dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITEDATA_B,     dwState);
    EnableMenuItem(hMenu, IDM_RAWREADCOMMAND_A,   dwState);
    EnableMenuItem(hMenu, IDM_RAWREADCOMMAND_B,   dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITECOMMAND_A,  dwState);
    EnableMenuItem(hMenu, IDM_RAWWRITECOMMAND_B,  dwState);
    EnableMenuItem(hMenu, IDM_SUBSCRIBE,          dwState);
    EnableMenuItem(hMenu, IDM_UNSUBSCRIBE,        dwState);
    EnableMenuItem(hMenu, IDM_DEVICE_RELEASE,     dwState);
}


/*****************************************************************************
    void IStillScanMenu(DWORD dwState)
        Enable or Disable the menus for scanning.

    Parameters:
        MF_ENABLED or MF_GRAYED

    Return:
        none

*****************************************************************************/
void IStillScanMenu(DWORD dwState)
{
    EnableMenuItem(hMenu, IDM_LAMPON,   dwState);
    EnableMenuItem(hMenu, IDM_LAMPOFF,  dwState);
    EnableMenuItem(hMenu, IDM_SCAN,             dwState);
}


/*****************************************************************************
    int NextStiDevice()
        Select next valid Sti device

    Parameters:
        none

    Return:
        number of next sti device (0 == first)

*****************************************************************************/
int NextStiDevice()
{
    //
    // select next device from static list (go to first at end of list)
    //
    nStiNumber++;

    if ( nStiNumber >= (int) dwStiTotal ) {
        //
        // point to head of list
        //
        nStiNumber = 0;
    }

    //
    // select next device from device log (go to first at end of list)
    //
    if ( pdevPtr->pNext ) {
        pdevPtr = pdevPtr->pNext;
    } else {
        //
        // point to head of list
        //
        pdevPtr = pdevRoot;
    }

    return nStiNumber;
}


/*****************************************************************************
    HRESULT StiCreateInstance(BOOL *)
        Opens Sti subsystem

    Parameters:
        Pointer to receive PASS/FAIL status

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiCreateInstance(BOOL *bPass)
{
    HRESULT hres = STI_OK;
    BOOL    bReturn;


    //
    // close any open devices before enumeration
    //
    StiClose(&bReturn);

    //
    // The StiCreateInstance interface locates the primary still image interface.
    // Use this call to optain the pointer to the IStillImage interface.
    //
    hres = StiCreateInstance(
                            GetModuleHandle(NULL),  // instance handle of this application
                            STI_VERSION,            // Sti version
                            &pSti,                  // pointer to IStillImage interface
                            NULL                    // pointer to controlling unknown of OLE aggregation
                            );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"StiCreateInstance",TRUE);
        *bPass = FALSE;
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;
    DisplayOutput(" The Sti subsystem is opened");
    DisplayOutput("");

    //
    // Enable the menu items for IStillImage interface calls available
    //
    IStillImageMenu(MF_ENABLED);
    EnableMenuItem(hMenu, IDM_CREATE_INSTANCE,       MF_GRAYED);

    return (hres);
}


/*****************************************************************************
    HRESULT StiClose(BOOL *)
        Close any open devices and Sti subsystem

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiClose(BOOL *bPass)
{
    HRESULT hres = STI_OK;


    *bPass = TRUE;

    // stop subscribing
    nUnSubscribe = 0;

    // close any open devices and then close Sti subsystem
    hres = StiDeviceRelease(bPass);
    hres = StiImageRelease(bPass);

    //
    // clear the internal device name and the friendly user name
    //
    ZeroMemory(szInternalName,STI_MAX_INTERNAL_NAME_LENGTH);
    ZeroMemory(szFriendlyName,STI_MAX_INTERNAL_NAME_LENGTH);

    return (hres);
}


/*****************************************************************************
    HRESULT StiDeviceRelease(BOOL *)
        Close the Sti subsystem

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiDeviceRelease(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;


    *bPass = TRUE;

    //
    // Need to UnSuscribe if the semaphore is set.
    //
    if ( nUnSubscribeSemaphore ) {
        //
        // clear the semaphores
        //
        nUnSubscribe = nUnSubscribeSemaphore = 0;

        // UnSubscribe is called when an application no longer wants to receive
        // events from a device.
        //
        hres = pStiDevice->UnSubscribe();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"UnSubscribe",TRUE);
            hError = hres;
            *bPass = FALSE;
        }

        //
        // we're done with the event
        //
        CloseHandle(hWaitEvent);

        DisplayOutput(" StiDeviceRelease has UnSubscribed");
    }
    //
    // The STI_DEVICE_INFORMATION array returned by GetDeviceList needs to
    // be freed with LocalFree(). Also, resetting internal Sti device counter.
    //
    if ( pStiInfo )
        LocalFree(pStiInfo);
    pStiInfo = pStiInfoPtr = NULL;

    //
    // close device if any are open
    //
    if ( pStiDevice ) {
        //
        // Close an open device.
        //
        hres = pStiDevice->Release();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"Release (Device)",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else
            DisplayOutput(" Device Released");

        DisplayOutput("");

        //
        // clear the Sti device pointer
        //
        pStiDevice = NULL;

        //
        // disable IStiDevice menu items
        //
        IStillDeviceMenu(MF_GRAYED);
        IStillNameMenu(MF_GRAYED);
        IStillScanMenu(MF_GRAYED);
        EnableMenuItem(hMenu, IDM_IMAGE_RELEASE,      MF_ENABLED);
        CheckMenuItem(hMenu,  IDM_ENABLE_HWNOTIF,     MF_UNCHECKED);
    }

    return (hError);
}


/*****************************************************************************
    HRESULT StiImageRelease(BOOL *)
        Close the Sti subsystem

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiImageRelease(BOOL *bPass)
{
    HRESULT hres = STI_OK;


    *bPass = TRUE;

    //
    // if Sti subsystem is open, close it
    //
    if ( pSti ) {
        //
        // Close the Still Imaging subsystem.
        //
        hres = pSti->Release();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"Release (Image)",TRUE);
            *bPass = FALSE;
        } else
            DisplayOutput(" Imaging subsystem Released");

        DisplayOutput("");

        //
        // clear the Sti subsystem pointer
        //
        pSti = NULL;

        //
        // Disable the menu items for IStillImage interface calls
        //
        IStillNameMenu(MF_GRAYED);
        IStillImageMenu(MF_GRAYED);
        EnableMenuItem(hMenu, IDM_CREATE_INSTANCE,       MF_ENABLED);
    }

    return (hres);
}


/*****************************************************************************
    HRESULT StiEnum(BOOL *)
        Opens Sti subsystem and enumerates any still image devices found

    Parameters:
        Pointer to receive PASS/FAIL status

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiEnum(BOOL *bPass)
{
    HRESULT hres = STI_OK;

    DWORD   dwCounter;
    DWORD   dwStiCount = 0;

    PSTI_DEVICE_INFORMATION pI = NULL;
    BOOL    bReturn;

    PCSTR   pszStringTablePtr = NULL;



    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }

    //
    // Enumerate devices
    //
    dwStiTotal = 0;
    pStiInfo = NULL;

    //
    // The GetDeviceList interface is used to get a list of the installed still
    // image devices. Use this call to obtain a STI_DEVICE_INFORMATION array
    // filled with info on all currently installed Sti devices.
    // * NOTE: the STI subsystem allocates memory for the Sti device information
    // buffer, but the caller needs to free this memory with LocalFree().
    //
    hres = pSti->GetDeviceList(
                              NULL,           // Type (reserved, use NULL)
                              NULL,           // Flags (reserved, use NULL)
                              &dwStiTotal,    // address of variable to return number of devices found
                              &pStiInfo       // Sti device info buffer
                              );

    if ( ! SUCCEEDED(hres) || ! pStiInfo ) {
        StiDisplayError(hres,"GetDeviceList",TRUE);
        StiClose(&bReturn);
        *bPass = FALSE;
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Display Sti info on each device found
    //
    for ( dwCounter = 0,pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo;
        dwCounter < dwStiTotal;
        dwCounter++, pStiInfoPtr++ ) {

        DisplayOutput(" Device number %2d",dwCounter + 1);
        pszStringTablePtr = StrFromTable(GET_STIDEVICE_TYPE(pStiInfoPtr->DeviceType),
                               StStiDeviceType);
        DisplayOutput("  Device type %xh %s",
                      GET_STIDEVICE_TYPE(pStiInfoPtr->DeviceType),
                      pszStringTablePtr);
        DisplayOutput("  Device subtype %xh",
                      GET_STIDEVICE_SUBTYPE(pStiInfoPtr->DeviceType));
        DisplayOutput("  Internal name \"%S\"",
                      pStiInfoPtr->szDeviceInternalName);
        DisplayOutput("  Device capabilities %xh",
                      pStiInfoPtr->DeviceCapabilities);
        DisplayOutput("  Hardware configuration %xh",
                      pStiInfoPtr->dwHardwareConfiguration);
        DisplayOutput("  Vendor description \"%S\"",
                      pStiInfoPtr->pszVendorDescription);
        DisplayOutput("  Device description \"%S\"",
                      pStiInfoPtr->pszDeviceDescription);
        DisplayOutput("  Port Name \"%S\"",
                      pStiInfoPtr->pszPortName);
        DisplayOutput("  Prop provider \"%S\"",
                      pStiInfoPtr->pszPropProvider);
        DisplayOutput("  Local name \"%S\"",
                      pStiInfoPtr->pszLocalName);
        DisplayOutput("");
    }

    //
    // point to most recently selected device again
    //
    pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo + nStiNumber;

    DisplayOutput(" GetDeviceList found %d device%s",dwStiTotal,
                  dwStiTotal == 1 ? "" : "s");

    if ( dwStiTotal != dwCounter ) {
        DisplayOutput("* Get DeviceList actually returned %d devices",dwCounter);
        dwStiTotal = dwCounter;
        nError++;
        pdevPtr-nError++;
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiEnumPrivate(PVOID *, DWORD *)
        Call GetDeviceList and return pointer to struct

    Parameters:
        Pointer to private DeviceList
                Pointer to number of devices found counter

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiEnumPrivate(PVOID *pPtr, DWORD *dwHowMany)
{
    HRESULT hres = STI_OK;
    BOOL    bReturn;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti )
        return (STIERR_GENERIC);

    //
    // The GetDeviceList interface is used to get a list of the installed still
    // image devices. Use this call to obtain a STI_DEVICE_INFORMATION array
    // filled with info on all currently installed Sti devices.
    // * NOTE: the STI subsystem allocates memory for the Sti device information
    // buffer, but the caller needs to free this memory with LocalFree().
    //
    hres = pSti->GetDeviceList(
                              NULL,            // Type (reserved, use NULL)
                              NULL,            // Flags (reserved, use NULL)
                              dwHowMany,       // address of variable to return number of devices found
                              pPtr             // Sti device info buffer
                              );

    if ( ! SUCCEEDED(hres) || ! *pPtr ) {
        StiDisplayError(hres,"GetDeviceList",TRUE);
        StiClose(&bReturn);
        return (STIERR_GENERIC);
    }

    return (hres);
}


/*****************************************************************************
    INT StiSelect(HWND hWnd,int nContext,BOOL *)
        Select and open a specific Still Image device

    Parameters:
        handle to current window
                context we were called from
                pointer to receive Pass/Fail

    Return:
        0 on success, -1 on error

*****************************************************************************/
INT StiSelect(HWND hWnd,int nContext,BOOL *bPass)
{
    HRESULT hres = STI_OK;
    BOOL    bReturn;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (-1);
    }
    *bPass = TRUE;

    //
    // look for devices if count of available is 0
    //
    if ( dwStiTotal == 0 ) {
        StiEnum(&bReturn);
    }

    //
    // if still no devices, inform user and leave
    //
    if ( dwStiTotal == 0 ) {

        ZeroMemory(szInternalName,sizeof(szInternalName));
        ZeroMemory(szFriendlyName,sizeof(szFriendlyName));

        DisplayOutput("* No Sti devices found!");
        DisplayOutput("");
        *bPass = FALSE;
        return (-1);
    }

    switch ( nContext ) {
        case EVENT:
            //
            // Sti push event or automated test
            //
            if ( nStiNumber == -1 ) {
                //
                // we could not select the correct device, just return
                //
                nStiNumber = 0;
                return (0);
            }
            break;
        case MANUAL:
            //
            // manual device selection
            //
            bReturn = fDialog(IDD_SELECT, hWnd, (FARPROC) SelectDevice);

            //
            // just return if user pressed CANCEL in dialog
            //
            if ( bReturn == FALSE ) {
                return (0);
            }
            break;
    }

    //
    // close any currently active imaging device
    //
    if ( pStiDevice )
        StiDeviceRelease(&bReturn);

    //
    // get pointer to device selected in dialog
    //
    pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo + nStiNumber;

    if ( ! *(pStiInfoPtr->szDeviceInternalName) ) {
        DisplayOutput("* Invalid device name !");
        nError++;
        pdevPtr-nError++;
        *bPass = FALSE;
        return (-1);
    }

    //
    // copy the internal device name and the friendly user name
    //
    wcscpy(szInternalName,pStiInfoPtr->szDeviceInternalName);
    wcscpy(szFriendlyName,pStiInfoPtr->pszLocalName);
    IStillNameMenu(MF_ENABLED);

    DisplayOutput(" Selected device %d \"%S\"",nStiNumber + 1,szInternalName);
    DisplayOutput(" Friendly name \"%S\"",szFriendlyName);

    //
    // Are we selecting the device or just its name?
    //
    if ( ! nNameOnly ) {
        //
        // The CreateDevice interface creates an IStiDevice object.
        // The IStiDevice object provides access to the IStiDevice interface
        // and device specific Imaging functionality.
        //
        hres = pSti->CreateDevice(
                                 pStiInfoPtr->szDeviceInternalName,
                                 // internal device name
                                 STI_DEVICE_CREATE_BOTH,     // device creation mode
                                 &pStiDevice,            // pointer where IStiDevice object is to be stored
                                 NULL );                 // pointer to controlling unknown of OLE aggregation

        if ( ! SUCCEEDED(hres) || ! pStiDevice ) {
            StiDisplayError(hres,"CreateDevice",TRUE);
            DisplayOutput("* \"%S\" (%S) cannot be tested",
                          pStiInfoPtr->pszLocalName,pStiInfoPtr->szDeviceInternalName);
            DisplayOutput("");
            *bPass = FALSE;
            return (-1);
        }

        //
        // enable Sti menu items
        //
        IStillDeviceMenu(MF_ENABLED);
        CheckMenuItem(hMenu,  IDM_ENABLE_HWNOTIF,     MF_CHECKED);
        EnableMenuItem(hMenu, IDM_IMAGE_RELEASE,      MF_GRAYED);

        //
        // Do we have scan commands for this device?
        //
        if ( nICanScan = IsScanDevice(pStiInfoPtr) ) {
            IStillScanMenu(MF_ENABLED);
        }
        DisplayOutput(" \"%S\" is ready for Testing",szFriendlyName);
    }
    DisplayOutput("");

    return (0);
}


/******************************************************************************
    BOOL FAR PASCAL SelectDevice(HWND,UINT,WPARAM,LPARAM)
        Put up a dialog for user to select a Still Image device

    Parameters:
        The usual dialog box parameters.

    Return:
        Result of the call.

******************************************************************************/
BOOL FAR PASCAL SelectDevice(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
    PSTI_DEVICE_INFORMATION
    pTmpInfoPtr;
    DWORD   dwCounter;
    int     iIndex;
    static int      iLastPick = 0;


    switch ( msg ) {

        case WM_INITDIALOG:

            //
            // fill dialog with Sti Device Internal Names
            //
            for ( dwCounter = 0, pTmpInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo;
                dwCounter < dwStiTotal;dwCounter++, pTmpInfoPtr++ ) {
                //
                // convert UNICODE string to ANSI
                //
                wsprintf(pszStr1,"%ls",pTmpInfoPtr->pszLocalName);

                iIndex = SendDlgItemMessage(hDlg,IDC_SELECT_DEVICE,
                                            CB_ADDSTRING,0,(LPARAM) (LPCTSTR) pszStr1);
            }
            SendDlgItemMessage(hDlg,IDC_SELECT_DEVICE,CB_SETCURSEL,iLastPick,0);

            return (TRUE);

        case WM_COMMAND:
            switch ( wParam ) {
                case IDOK:
                    nStiNumber = SendDlgItemMessage(hDlg,IDC_SELECT_DEVICE,
                                                    CB_GETCURSEL,0,0);
                    nNameOnly = SendDlgItemMessage(hDlg,IDC_SELECT_NAME,
                                                   BM_GETCHECK,0,0);

                    //
                    // ensure device number not greater than total
                    // (NOTE: dwStiTotal is 1's base, while nStiNumber is 0 based)
                    //
                    if ( nStiNumber >= (int) dwStiTotal )
                        nStiNumber = (int) dwStiTotal - 1;
                    if ( nStiNumber < 0 )
                        nStiNumber = 0;
                    iLastPick = nStiNumber;

                    EndDialog(hDlg, TRUE);
                    return (TRUE);

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return (TRUE);
            }

    }
    return (FALSE);
}


/*****************************************************************************
    void StiDisplayError(HRESULT,char *,BOOL)
        Display verbose error information

    Parameters:
        HRESULT from failed call
        TRUE = record error as compliance failure


    Return:
        none

*****************************************************************************/
void StiDisplayError(HRESULT hres,char *szCall,BOOL bFail)
{
    PERRECORD               pR = pdevPtr->pRecord;
    BOOL                    bReturn;


    StiGetLastErrorInfo(&bReturn);
    LastError(TRUE);

    //
    // record the error
    //
    pR += nTestID;
    pR->nCount++;


// BUG BUG can't copy the string correctly to UNICODE string

//      sprintf(pszStr4,"%s",StrFromTable(hres,StStiError));
//      swprintf(pR->szErrorString,L"%s",pszStr4);

    //
    // compliance test failure error?
    //
    if ( bFail ) {
        nError++;
        pdevPtr-nError++;
        pR->bFatal = TRUE;
        DisplayOutput("* Sti Compliance test error");
        tlLog(hNTLog,TL_LOG,"* Sti Compliance test error");

    } else {
        DisplayOutput("* Allowed error");
    }
    DisplayOutput("* %s returned %xh (%d)",szCall,hres,hres);
    if ( bFail )
        tlLog(hNTLog,TL_LOG,"* %s returned %xh (%d)",szCall,hres,hres);
    DisplayOutput(" \"%s\"",StrFromTable(hres,StStiError));
    if ( bFail )
        tlLog(hNTLog,TL_LOG," \"%s\"",StrFromTable(hres,StStiError));

    return;
}


/******************************************************************************
    int InitPrivateList(PDEVLOG,int *)
        Initialize private test structures

    Parameters:
        pointer to Devicelog to initialize
                pointer to test suite

    Return:
        total number of devices found (-1 on failure)

******************************************************************************/
int InitPrivateList(PDEVLOG *pDev,int *pSuiteList)
{
    DWORD           dwStiDevCount = 0;
    PVOID           pList = NULL;
    PSTI_DEVICE_INFORMATION
    pInfoPrivatePtr = NULL;     // pointer to device in pStiBuffer
    PDEVLOG         pPtr = NULL;
    PERRECORD       precPtr = NULL;
    int                     i,k,nNumberTests,nTotalDevices;
    BOOL            bReturn;


    //
    // get the current number of devices and their names
    //
    StiCreateInstance(&bReturn);

    StiEnumPrivate(&pList,&dwStiDevCount);
    if ( ! pList ) {
        DisplayOutput("* No Sti device attached !");
    } else {
        pInfoPrivatePtr = (PSTI_DEVICE_INFORMATION) pList;
    }

    //
    // create at least one list entry (even if no devices are found)
    //
    if ( ! dwStiDevCount ) {
        dwStiDevCount = 1;
        nTotalDevices = 0;
    } else
        nTotalDevices = (int) dwStiDevCount;

    //
    // create a device log for each device
    //
    pPtr = (PDEVLOG) calloc(dwStiDevCount,sizeof(DEVLOG));
    if ( pPtr == NULL ) {
        FatalError("Could not initialize private structures");
        return (-1);
    }
    *pDev = pPtr;

    //
    // count the number of tests in suite
    //
    for ( nNumberTests = 0;pSuiteList[nNumberTests] != -1;nNumberTests++ )
        ;

    //
    // initialize linked list pointers and error records for each device log
    //
    for ( i = 0;i < (int) dwStiDevCount;i++,pPtr++,pInfoPrivatePtr++ ) {
        if ( i ) {
            (pPtr - 1)->pNext = pPtr;
            pPtr->pPrev = pPtr - 1;
        }
        if ( nTotalDevices ) {
            wcscpy(pPtr->szInternalName,pInfoPrivatePtr->szDeviceInternalName);
            wcscpy(pPtr->szLocalName,pInfoPrivatePtr->pszLocalName);
        } else {
            wcscpy(pPtr->szInternalName,L"* Invalid !");
            wcscpy(pPtr->szLocalName,L"* No Sti device attached !");
        }

        //
        // create one error log for each test (nNumberTests)
        //
        pPtr->pRecord = (PERRECORD) calloc(nNumberTests,sizeof(ERRECORD));
        if ( pPtr->pRecord == NULL ) {
            FatalError("Could not initialize private structures");
            return (-1);
        }
        //
        // initialize linked list pointers and error records for each record
        //
        for ( k = 0,precPtr = pPtr->pRecord;k < nNumberTests;k++,precPtr++ ) {
            precPtr->nIndex = k;
            precPtr->nTest = pSuite[k];
            if ( k ) {
                (precPtr - 1)->pNext = precPtr;
                precPtr->pPrev = precPtr - 1;
            }
        }
    }

    //
    // free the device list
    //
    LocalFree(pList);
    StiClose(&bReturn);

    return (nTotalDevices);
}


/******************************************************************************
    int ClosePrivateList(PDEVLOG)
        Remove private test structures

    Parameters:
        pointer to Devicelog to close

    Return:
        0 on success
        -1 on failure

******************************************************************************/
int ClosePrivateList(PDEVLOG *pDev)
{
    PDEVLOG pPtr = (PDEVLOG) *pDev;


    if ( pDev == NULL )
        return (0);

    //
    // free each device log's error record
    //
    for ( ;pPtr->pNext;pPtr++ ) {
        if ( pPtr->pRecord )
            free(pPtr->pRecord);
    }

    //
    // free the device log
    //
    if ( *pDev ) {
        free(*pDev);
        *pDev = NULL;
    }

    return (0);
}


/*****************************************************************************
    HRESULT StiGetDeviceValue(LPWSTR,LPWSTR,DWORD *,BOOL *)
                Get driver information

    Parameters:
        szDevname - internal device name
                szKeyname - key to access
                dwType - pointer to data type
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetDeviceValue(LPWSTR szDevname,LPWSTR szKeyname,LPBYTE pData,
                          DWORD *dwType,DWORD cbData,BOOL *bPass)
{
    HRESULT hres = STI_OK;

//
// WINNT.H - Predefined Value Types
//
    STRINGTABLE StRegType[] =
    {
        REG_NONE,   "REG_NONE",0,
        REG_SZ,     "REG_SZ",0,
        REG_BINARY, "REG_BINARY",0,
        REG_DWORD,  "REG_DWORD",0,
        0,          "Unknown Reg Type",-1
    };


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    ZeroMemory(pData,cbData);

    DisplayOutput(" GetDeviceValue for device \"%S\"",szDevname);
    DisplayOutput("  Key requested: \"%S\"",szKeyname);

    //
    // The GetDeviceValue function is used to retrieve data associated with a
    // still image device. Essentially, data is associated with a device
    // through a key/data type/value triplet. The only reserved standard
    // ValueNames, as defined in STI.H, are the following:
    //
    // ICMProfiles - string containing a comma-sperated list of ICM profiles
    // TwainDS - TWAIN data source display name
    // ISISDriverName - ISIS driver name
    //
    hres = pSti->GetDeviceValue(
                               szDevname,              // internal device name
                               szKeyname,              // value tag string
                               dwType,                 // pointer where data type will be stored
                               pData,                  // pointer where value will be stored
                               &cbData                 // size of value pointer storage
                               );

    if ( !SUCCEEDED(hres) ) {
        //
        // The only required registry item is STI_DEVICE_VALUE_ICM_PROFILE
        //
        if ( hres == STIERR_OBJECTNOTFOUND ) {
            if ( ! wcscmp(STI_DEVICE_VALUE_ICM_PROFILE,szKeyname) ) {
                //
                // Only STI_DEVICE_VALUE_ICM_PROFILE is a required key
                // Therefore, only this one Failure is a COMPLIANCE test failure
                //
                *bPass = FALSE;
                StiDisplayError(hres,"GetDeviceValue",TRUE);
            } else {
                StiDisplayError(hres,"GetDeviceValue",FALSE);
            }
        } else {
            *bPass = FALSE;
            StiDisplayError(hres,"GetDeviceValue",TRUE);
        }
    } else {
        DisplayOutput("  Reg Type %d %s",* dwType,
                      StrFromTable(*dwType,StRegType));
        DisplayOutput("  The following %d bytes were read from the Registry:",
                      cbData);
        DisplayOutput("  \"%s\"",pData);
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiSetDeviceValue(LPWSTR,LPWSTR,LPWSTR,DWORD,BOOL *)
                Set driver information

    Parameters:
        szDevname - internal device name
                szKeyname - key to access
                pData - value to write
                dwType - data type
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiSetDeviceValue(LPWSTR szDevname,LPWSTR szKeyname,LPBYTE pData,
                          DWORD dwType,DWORD cbData,BOOL *bPass)
{
    HRESULT hres = STI_OK;

//
// WINNT.H - Predefined Value Types
//
    STRINGTABLE StRegType[] =
    {
        REG_NONE,   "REG_NONE",0,
        REG_SZ,     "REG_SZ",0,
        REG_BINARY, "REG_BINARY",0,
        REG_DWORD,  "REG_DWORD",0,
        0,          "Unknown Reg Type",-1
    };


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    DisplayOutput(" SetDeviceValue for device \"%S\"",szDevname);
    DisplayOutput("  Key \"%S",szKeyname);

    //
    // The SetDeviceValue function is used to associate any additional data
    // with a still image device. It is used internally to store the values of
    // strings that are required to communicate information to imaging APIs
    // during use of push model behavoir. However, this function can be used
    // to associate any ancillary data with a device. The only reserved
    // ValueNames, as defined in STI.H, are the following:
    //
    // ICMProfiles - string containing a comma-sperated list of ICM profiles
    // TwainDS - TWAIN data source display name
    // ISISDriverName - ISIS driver name
    //
    hres = pSti->SetDeviceValue(
                               szDevname,              // internal device name
                               szKeyname,              // value tag string
                               dwType,                 // data type sent
                               pData,              // pointer to data to send
                               cbData                  // byte size of data
                               );

    if ( !SUCCEEDED(hres) ) {
        //
        // SetDeviceValue is not required under NT
        //
        StiDisplayError(hres,"SetDeviceValue",FALSE);
    } else {
        //pszStr1 = StrFromTable(dwType,StRegType);
        DisplayOutput("  Reg Type %d %s",dwType,StrFromTable(dwType,StRegType));
        DisplayOutput("  The following %d bytes were written to the Registry:",
                      cbData);
        DisplayOutput("  \"%s\"",(char *) pData);
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiRegister(HWND,int,BOOL *)
                Register or Unregister the application to receive Sti Launch events.

    Parameters:
        Handle to the window to display image in.
                Instance for access to string table
                int nOnOff == ON to register, OFF to unregister
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRegister(HWND hWnd,HINSTANCE hInstance,int nOnOff,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    CHAR    szModulePath[MAX_PATH+1];
    WCHAR   szModulePathW[MAX_PATH+1],
    szAppName[MEDSTRING];
    DWORD   cch;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Retrieve name of this application from STRING table
    // and convert to UNICODE.
    //
    LoadString(hInstance,IDS_APPNAME,pszStr1,MEDSTRING);
    cch = MultiByteToWideChar(CP_ACP, 0,
                              pszStr1, -1,
                              szAppName,MEDSTRING);
    if ( ! cch ) {
        LastError(TRUE);
        *bPass = FALSE;
        return (STIERR_GENERIC);
    }

    //
    // Register/deregister app
    //
    if ( nOnOff == ON ) {
        //
        // Register our application.
        // Get full path to executable and convert to UNICODE.
        //
        cch = GetModuleFileName(NULL,szModulePath,sizeof(szModulePath));

        if ( ! cch ) {
            LastError(TRUE);
            *bPass = FALSE;
            return (STIERR_GENERIC);
        }
        cch = MultiByteToWideChar(CP_ACP, 0,
                                  szModulePath, -1,
                                  szModulePathW, sizeof(szModulePathW));

        //
        // The RegisterLaunchApplication function should be called by
        // applications that would like to be launched in response to an
        // Sti push event. This function can be called more than once,
        // and should be called each time the application rus in case
        // the user relocates the application.
        //
        hres = pSti->RegisterLaunchApplication(
                                              szAppName,                      // short name of app
                                              szModulePathW           // full path to executable
                                              );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"RegisterLaunchApplication",TRUE);
            *bPass = FALSE;
            hError = hres;
        } else {
            DisplayOutput(" %s registered for Sti Launch Application",pszStr1);
        }
    } else {
        //
        // Unregister our application
        //
        hres = pSti->UnregisterLaunchApplication(
                                                szAppName                       // short name of app
                                                );
        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"UnregisterLaunchApplication",TRUE);
            hError = hres;
        } else {
            DisplayOutput(" %s Unregistered from Sti Launch",pszStr1);
        }
    }
    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiEvent(HWND hWnd)
                Handle a push model event.
                This function is called when the test app has been
                        a) registered as a push event handler
                        b) launched by a push event

    Parameters:
        Handle to the window to display image in.

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiEvent(HWND hWnd)
{
    HRESULT hres = STI_OK;
    WCHAR   szDeviceName[STI_MAX_INTERNAL_NAME_LENGTH + 1],
    szEventName[LONGSTRING];
    DWORD   cch,
    dwEventCode = 0,
    cbData = LONGSTRING;
    int             nCounter;
    BOOL    bBadFlag = FALSE;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }


    ZeroMemory(szDeviceName,STI_MAX_INTERNAL_NAME_LENGTH + 1);
    ZeroMemory(szEventName,LONGSTRING);

    //
    // For an application started through push model launch,
    // GetSTILaunchInformation returns the associated information. This
    // information is used to determine which device to use and what
    // event caused the application to be launched.
    //
    hres = pSti->GetSTILaunchInformation(
                                        szDeviceName,           // pointer to where device name will be stored
                                        &dwEventCode,           // reserved
                                        szEventName                     // pointer to where GUID will be stored
                                        );

    if ( !SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetSTILaunchInformation",TRUE);
        return (STIERR_GENERIC);
    }

    ZeroMemory(pszStr2,LONGSTRING);
    ZeroMemory(pszStr4,LONGSTRING);
    cch = WideCharToMultiByte(CP_ACP,0,
                              szDeviceName,-1,
                              pszStr1,STI_MAX_INTERNAL_NAME_LENGTH + 1,
                              pszStr2,&bBadFlag);
    if ( ! cch )
        LastError(TRUE);
    if ( bBadFlag ) {
        DisplayOutput("* UNICODE translation error");
        bBadFlag = FALSE;
    }
    DisplayOutput(" %s launched via Sti push",pszStr1);
    DisplayOutput(" Event code %d (%xh)",dwEventCode,dwEventCode);

    cch = WideCharToMultiByte(CP_ACP,0,
                              szEventName,-1,
                              pszStr1,STI_MAX_INTERNAL_NAME_LENGTH + 1,
                              pszStr2,&bBadFlag);
    if ( ! cch )
        LastError(TRUE);
    if ( bBadFlag ) {
        DisplayOutput("* UNICODE translation error");
        bBadFlag = FALSE;
    }
    DisplayOutput(" Event name %s",pszStr1);

    //
    // find the Sti device that sent the event
    // set nStiNumber to -1 (no device), then set to event device when found
    //
    for ( nStiNumber = -1,nCounter = 0,
          pStiInfoPtr = (PSTI_DEVICE_INFORMATION) pStiInfo;
        nCounter < (int) dwStiTotal;pStiInfoPtr++,nCounter++ ) {
        if ( ! wcscmp(szDeviceName,pStiInfoPtr->szDeviceInternalName) )
            nStiNumber = nCounter;
    }
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiGetDeviceInfo(LPWSTR szDevName,BOOL *pPass)
                Display information about the selected device

    Parameters:
                WCHAR string of the selected device
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetDeviceInfo(LPWSTR szDevname,BOOL *bPass)
{
    HRESULT                                     hres = STI_OK;
    PVOID                                   pInfo = NULL;
    PSTI_DEVICE_INFORMATION pInfoPtr = NULL;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Given a device name, the GetDeviceInfo interface makes available a
    // structure that describes the various attributes of the device.
    // * NOTE: the STI subsystem allocates memory for the Sti device information
    // buffer, but the caller needs to free this memory with LocalFree().
    //
    hres = pSti->GetDeviceInfo(
                              szDevname,              // pointer to the internal device name
                              &pInfo);                // Sti device info buffer

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetDeviceInfo",TRUE);
        *bPass = FALSE;
    }

    pInfoPtr = (PSTI_DEVICE_INFORMATION) pInfo;

    DisplayOutput(" GetDeviceInfo for \"%S\"",szDevname);
    //pszStr1 = StrFromTable(GET_STIDEVICE_TYPE(pInfoPtr->DeviceType),StStiDeviceType);
    DisplayOutput("  Device type %xh %s",
                  GET_STIDEVICE_TYPE(pInfoPtr->DeviceType),
                  StrFromTable(GET_STIDEVICE_TYPE(pInfoPtr->DeviceType),StStiDeviceType));
    DisplayOutput("  Device subtype %xh",
                  GET_STIDEVICE_SUBTYPE(pInfoPtr->DeviceType));
    DisplayOutput("  Internal name \"%S\"",
                  pInfoPtr->szDeviceInternalName);
    DisplayOutput("  Device capabilities %xh",
                  pInfoPtr->DeviceCapabilities);
    DisplayOutput("  Hardware configuration %xh",
                  pInfoPtr->dwHardwareConfiguration);
    DisplayOutput("  Vendor description \"%S\"",
                  pInfoPtr->pszVendorDescription);
    DisplayOutput("  Device description \"%S\"",
                  pInfoPtr->pszDeviceDescription);
    DisplayOutput("  Port Name \"%S\"",
                  pInfoPtr->pszPortName);
    DisplayOutput("  Prop provider \"%S\"",
                  pInfoPtr->pszPropProvider);
    DisplayOutput("  Local name \"%S\"",
                  pInfoPtr->pszLocalName);
    DisplayOutput("");

    // free the STI_DEVICE_INFORMATION buffer
    if ( pInfo )
        LocalFree(pInfo);

    return (hres);
}


/*****************************************************************************
    HRESULT StiEnableHwNotification(LPWSTR,int *,BOOL *)
                Determine the current notification handling state and if requested,
                change it.

    Parameters:
                internal device name
        pointer to state request (current state returned in pointer)
                        ON = turn on polling
                        OFF = turn off polling
                        PEEK = return current polling state
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiEnableHwNotification(LPWSTR szDevnameW,int *nState,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    BOOL    bState = OFF;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // GetHwNotificationState gets the current state of notification handling.
    // The state parameter returns TRUE if the notification is enabled.
    //
    hres = pSti->GetHwNotificationState(
                                       szDevnameW,             // internal device name
                                       &bState                 // pointer where state will be stored
                                       );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetHwNotificationState",TRUE);
        *bPass = FALSE;
        hError = hres;
    } else {
        DisplayOutput(" Hardware Notification state is %s",
                      bState ? "TRUE (ON)" : "FALSE (OFF)");
    }

    if ( *nState != PEEK ) {
        //
        // EnableHwNotifications is used to turn event notification on and off.
        // For polled devices, this function will turn polling on and off.
        //
        hres = pSti->EnableHwNotifications(
                                          szDevnameW,             // internal device name
                                          *nState                 // new state to be set
                                          );
        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"GetHwNotificationState",TRUE);
            *bPass = FALSE;
            return (hres);
        }

        //
        // Ensure the state was changed
        //
        hres = pSti->GetHwNotificationState(
                                           szDevnameW,             // internal device name
                                           &bState                 // pointer where state will be stored
                                           );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"GetHwNotificationState",TRUE);
            *bPass = FALSE;
            hError = hres;
        } else {
            DisplayOutput(" Hw state has been set to %s",
                          bState ? "TRUE (ON)" : "FALSE (OFF)");
        }

        if ( bState ) {
            if ( GetMenuState(hMenu, IDM_ENABLE_HWNOTIF, NULL) == MF_UNCHECKED )
                CheckMenuItem(hMenu, IDM_ENABLE_HWNOTIF, MF_CHECKED);
        } else {
            if ( GetMenuState(hMenu, IDM_ENABLE_HWNOTIF, NULL) == MF_CHECKED )
                CheckMenuItem(hMenu, IDM_ENABLE_HWNOTIF, MF_UNCHECKED);
        }
    }
    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRefresh(LPWSTR,BOOL *)
                Refresh the bus for non-PNP devices

    Parameters:
                internal device name
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRefresh(LPWSTR szDevnameW,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    BOOL    bState = OFF;

/**/
    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // GetHwNotificationState gets the current state of notification handling.
    // The state parameter returns TRUE if the notification is enabled.
    //
    hres = pSti->RefreshDeviceBus(
                                 szDevnameW              // internal device name
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"RefreshDeviceBus",TRUE);
        *bPass = TRUE;
        hError = hres;
    } else
        DisplayOutput(" RefreshDeviceBus called on \"%S\"",szDevnameW);

    DisplayOutput("");
/**/
    return (hError);
}


/*****************************************************************************
    HRESULT StiWriteErrLog(DWORD,LPCWSTR,BOOL *)
                Write a string to the error log

    Parameters:
                DWORD severity, which can be
                        STI_TRACE_INFORMATION
                        STI_TRACE_WARNING
                        STI_TRACE_ERROR
                Wide character message to write to log.
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiWriteErrLog(DWORD dwSeverity,LPCWSTR pszMessage,BOOL *bPass)
{
    HRESULT hres = STI_OK;


    //
    // check that Sti subsystem is loaded
    //
    if ( ! pSti ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"StiNotLoaded",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // WriteToErrorLog can be used to write debugging and diagnostic
    // information into the Sti log file, located in the Windows directory
    // STI_TRACE.LOG. The user can control whether informational, warning or
    // error messages, or any combination of these three are put in the log
    // file through the Scanners & Cameras control panel.
    //
    hres = pSti->WriteToErrorLog(
                                dwSeverity,                     // severity of error
                                pszMessage                      // string to write to log
                                );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"WriteToErrorLog",TRUE);
        *bPass = FALSE;
    } else
        DisplayOutput(" WriteToErrorLog wrote \"%S\"",pszMessage);
    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiGetStatus(int,BOOL *)
                Retrieve the user mode status of the driver.

    Parameters:
                StatusMask to retrieve status for. Can be a combination of:
                        STI_DEV_ONLINE_STATE
                        STI_DEV_EVENTS_STATE
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiGetStatus(int nMask,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DWORD                           dwTimeout = 2000;
    STI_DEVICE_STATUS       StiStatus;

//
// STI.H - STI_DEVICE_MJ_TYPE
//
    STRINGTABLE StStiStatusMask[] =
    {
        STI_DEVSTATUS_ONLINE_STATE, "STI_DEVSTATUS_ONLINE_STATE",0,
        STI_DEVSTATUS_EVENTS_STATE, "STI_DEVSTATUS_EVENTS_STATE",0,
        STI_DEVSTATUS_ONLINE_STATE | STI_DEVSTATUS_EVENTS_STATE,
        "STI_DEVSTATUS_ONLINE_STATE | STI_DEVSTATUS_EVENTS_STATE",0,
        0, "Unknown status mask",-1
    };


    //
    // check that an Sti device is selected
    //
    if ( pStiDevice == NULL ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before GetStatus
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for GetStatus");

        //
        // Get and display status
        //
        ZeroMemory(&StiStatus,sizeof(StiStatus));
        //
        // The STI_DEVICE_STATUS dwSize field MUST be set by the caller.
        //
        StiStatus.dwSize = sizeof(STI_DEVICE_STATUS);
        //
        // The STI_DEVICE_STATUS StatusMask field MUST be set to the desired
        // status to retrieve.
        //
        StiStatus.StatusMask = nMask;

        DisplayOutput("  %s mask",StrFromTable(nMask,StStiStatusMask));

        //
        // The GetStatus interface gets the status from the user-mode
        // minidriver. Status returned can indicate online status and/or
        // device event activity.
        //
        hres = pStiDevice->GetStatus(
                                    &StiStatus                              // pointer to a STI_DEVICE_STATUS struct
                                    );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"GetStatus",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else {
            DisplayOutput(" GetStatus on %S",szFriendlyName);
        }
        //
        // Is the device on?
        //
        if ( (StiStatus.dwOnlineState == 0) &&
             (nMask & STI_DEVSTATUS_ONLINE_STATE) ) {
            DisplayOutput("* Device is TURNED OFF OR OFFLINE!!");
        }

        DisplayOutput("  %xh (%d) StatusMask",
                      StiStatus.StatusMask,StiStatus.StatusMask);
        DisplayOutput("  %xh (%d) dwOnlineState",
                      StiStatus.dwOnlineState,StiStatus.dwOnlineState);
        DisplayOutput("  %xh (%d) dwHardwareStatusCode",
                      StiStatus.dwHardwareStatusCode,StiStatus.dwHardwareStatusCode);
        DisplayOutput("  %xh (%d) dwEventHandlingState",
                      StiStatus.dwEventHandlingState,StiStatus.dwEventHandlingState);
        DisplayOutput("  %xh (%d) dwPollingInterval",
                      StiStatus.dwPollingInterval,StiStatus.dwPollingInterval);

        if ( StiStatus.dwSize != sizeof(STI_DEVICE_STATUS) ) {
            DisplayOutput("* Expected STI_DEVICE_STATUS dwSize %d, got %d",
                          sizeof(STI_DEVICE_STATUS),StiStatus.dwSize);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiGetCaps(BOOL *)
                Return the device capabilities

    Parameters:
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetCaps(BOOL *bPass)
{
    HRESULT                             hres = STI_OK;
    STI_DEV_CAPS            StiDevCaps = { 0};


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // The GetCapabilities function returns the capabilities of the device.
    //
    hres = pStiDevice->GetCapabilities(
                                      &StiDevCaps                             // pointer to a STI_DEV_CAPS struct
                                      );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"GetCapabilities",TRUE);
        *bPass = FALSE;
    } else {
        DisplayOutput(" GetCapabilities on \"%S\'",szFriendlyName);

        DisplayOutput("  %xh (%d) dwGeneric",
                      StiDevCaps.dwGeneric,StiDevCaps.dwGeneric);
    }

    DisplayOutput("");

    return (hres);
}


/*****************************************************************************
    HRESULT StiReset(BOOL *)
                Puts the device into a known state.

    Parameters:
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiReset(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DWORD   dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before DeviceReset
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for DeviceReset");

        //
        // The DeviceReset interface requests that a device be returned to a
        // known state.
        //
        hres = pStiDevice->DeviceReset();

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"DeviceReset",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else
            DisplayOutput(" DeviceReset on \"%S\"",szFriendlyName);
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiDiagnostic(BOOL *)
                Return user mode driver diagnostic info

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiDiagnostic(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DIAG    diag;
    DWORD   dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before Diagnostic
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for Diagnostic");

        //
        // get diagnostic info
        //
        ZeroMemory(&diag,sizeof(diag));
        //
        // The DIAG dwSize field MUST be set by the caller.
        //
        diag.dwSize = sizeof(DIAG);
        //
        // The dwBasicDiagCode of this structure should be initialized with
        // the desired request code. Currently, only one request code is
        // defined, STI_DIAGCODE_HWPRESENCE.
        diag.dwBasicDiagCode = STI_DIAGCODE_HWPRESENCE;
        //
        // There is also a vendor defined field called dwVendorDiagCode that
        // can optionally be filled in.
        //
        diag.dwVendorDiagCode = 0;

        //
        // The Diagnostic interface executes the diagnostic method of the user
        // mode minidriver.
        //
        hres = pStiDevice->Diagnostic(
                                     &diag                           // pointer to STI_DIAG structure
                                     );

        if ( ! SUCCEEDED(hres) ) {
            StiDisplayError(hres,"Diagnostic",TRUE);
            hError = hres;
            *bPass = FALSE;
        } else {
            DisplayOutput(" Diagnostic on \"%S\"",szFriendlyName);
        }

        DisplayOutput("  %xh (%d) dwBasicDiagCode",
                      diag.dwBasicDiagCode,diag.dwBasicDiagCode);
        DisplayOutput("  %xh (%d) dwVendorDiagCode",
                      diag.dwVendorDiagCode,diag.dwVendorDiagCode);
        DisplayOutput("  %xh (%d) dwStatusMask",
                      diag.dwStatusMask,diag.dwStatusMask);

        if ( diag.dwSize != sizeof(DIAG) )
            DisplayOutput("* Expected DIAG dwSize %d, got %d",
                          sizeof(DIAG),diag.dwSize);

        //
        // any extended error info?
        //
        if ( diag.sErrorInfo.dwSize == 0 ) {
            DisplayOutput("   No Extended Errors");
        } else {
            if ( diag.sErrorInfo.dwSize != sizeof(STI_ERROR_INFO) )
                DisplayOutput("* Expected STI_ERROR_INFO dwSize %d, got %d",
                              sizeof(STI_ERROR_INFO),diag.sErrorInfo.dwSize);
            DisplayOutput("   %xh (%d) sErrorInfo.dwGenericError",
                          diag.sErrorInfo.dwGenericError,diag.sErrorInfo.dwGenericError);
            DisplayOutput("   %xh (%d) sErrorInfo.dwVendorError",
                          diag.sErrorInfo.dwVendorError,diag.sErrorInfo.dwVendorError);
            if ( * diag.sErrorInfo.szExtendedErrorText )
                DisplayOutput("   sErrorInfo.szExtendedErrorText %s",
                              diag.sErrorInfo.szExtendedErrorText);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiGetLastErrorInfo(BOOL *)
                Get and display last error from Sti device.

    Parameters:
        pointer to receive Pass/Fail result

    Return:
        HRESULT of last Sti call

*****************************************************************************/
HRESULT StiGetLastErrorInfo(BOOL *bPass)
{
    HRESULT                     hres = STI_OK;
    STI_ERROR_INFO  StiError;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        DisplayOutput("* NoStiDevice !");
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // get last error info
    //
    ZeroMemory(&StiError,sizeof(StiError));
    //
    // The STI_ERROR_INFO dwSize field MUST be set by the caller.
    //
    StiError.dwSize = sizeof(STI_ERROR_INFO);

    //
    // The GetLastErrorInfo interface returns the last known error from
    // the user-mode minidriver.
    //
    hres = pStiDevice->GetLastErrorInfo(
                                       &StiError                               // pointer to STI_ERROR_INFO structure
                                       );

    if ( ! SUCCEEDED(hres) ) {
        DisplayOutput("* NoStiDevice !");
        *bPass = FALSE;
    } else
        DisplayOutput(" GetLastErrorInfo on %S",szFriendlyName);

    //
    // any extended error info?
    //
    if ( StiError.dwSize == 0 ) {
        DisplayOutput("No Extended Errors");
    } else {
        if ( StiError.dwSize != sizeof(STI_ERROR_INFO) )
            DisplayOutput("* Expected STI_ERROR_INFO dwSize %d, got %d",
                          sizeof(STI_ERROR_INFO),StiError.dwSize);
        DisplayOutput("  %xh (%d) sErrorInfo.dwGenericError",
                      StiError.dwGenericError,StiError.dwGenericError);
        DisplayOutput("  %xh (%d) sErrorInfo.dwVendorError",
                      StiError.dwVendorError,StiError.dwVendorError);
        if ( * StiError.szExtendedErrorText )
            DisplayOutput("  sErrorInfo.szExtendedErrorText %s",
                          StiError.szExtendedErrorText);
    }

    return (hres);
}


/*****************************************************************************
    HRESULT StiSubscribe(BOOL *)
                Demonstrate Subscribe, UnSubscribe and GetLastNotificationData

    Parameters:
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiSubscribe(BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    STISUBSCRIBE                sSubscribe;
    DWORD                               dwErr = 0x56565656;
    int                                     nWait = TRUE;
    BOOL                                fWaiting = TRUE;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // create an unnamed event object for notification structure
    //
    hWaitEvent = CreateEvent(NULL,   // security attributes
                             FALSE,  // manual reset event flag
                             FALSE,  // initial state flag
                             NULL ); // event-object name pointer

    if ( ! hWaitEvent ) {
        *bPass = FALSE;
        return STIERR_GENERIC;
    }

    //
    // prepare the event notification structure
    //
    ZeroMemory(&sSubscribe,sizeof(sSubscribe));
    //
    // The STISUBSCRIBE dwSize field MUST be set by the caller.
    //
    sSubscribe.dwSize = sizeof(STISUBSCRIBE);
    //
    // When flag is STI_SUBSCRIBE_FLAG_WINDOW, window handle is passed in as
    // parameter. When flag is STI_SUBSCRIBE_FLAG_EVENT, event handle is
    // passed in as a parameter.
    //
    sSubscribe.dwFlags = STI_SUBSCRIBE_FLAG_EVENT;
    //
    // not used
    //
    sSubscribe.dwFilter = 0;
    //
    // When STI_SUBSCRIBE_FLAG_WINDOW bit is set, following field should
    // be set to handle of window which will receive notification message.
    //
    sSubscribe.hWndNotify = NULL;
    //
    // Handle of WIN32 auto-reset event, which will be signalled whenever
    // device has notification pending.
    //
    sSubscribe.hEvent = hWaitEvent;
    //
    // Code of notification message, sent to window
    //
    sSubscribe.uiNotificationMessage = 0;

    //
    // Subscribe is called by an application that wants to start receiving event
    // notifications from a device. This is useful for control center-style
    // applications. Each call to Subscribe should be paired with a call to
    // UnSubscribe.
    //
    hres = pStiDevice->Subscribe(
                                &sSubscribe                             // pointer to STISUBSCRIBE structure
                                );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"Subscribe",TRUE);
        CloseHandle(hWaitEvent);
        *bPass = FALSE;
        return (hres);
    }

    //
    // set the flag and semaphore for Subscribe mode
    //
    nUnSubscribe = nUnSubscribeSemaphore = 1;

    //
    // Now we wait for an event
    //
    DisplayOutput(" Subscribe on %S",szFriendlyName);

    while ( nUnSubscribe ) {

        dwErr = WaitForSingleObject(hWaitEvent,1000);

        switch ( dwErr ) {
            case WAIT_OBJECT_0:
                {
                    STINOTIFY  sNotify;


                    //
                    // received a notification
                    //
                    DisplayOutput("  WAIT_OBJECT_0 %xh (%d)",dwErr,dwErr);
                    DisplayOutput("  Received notification");

                    //
                    // prepare the notification description structure
                    //
                    ZeroMemory(&sNotify,sizeof(sNotify));
                    //
                    // The STINOTIFY dwSize field MUST be set by the caller.
                    //
                    sNotify.dwSize = sizeof(STINOTIFY);

                    //
                    // GetLastNotifyData returns information about the last
                    // event on the device.
                    //
                    hres = pStiDevice->GetLastNotificationData(
                                                              &sNotify        // pointer to STINOTIFY structure
                                                              );
                    if ( ! SUCCEEDED(hres) ) {
                        StiDisplayError(hres,"GetLastNotificationData",TRUE);
                        hError = hres;
                        *bPass = FALSE;
                    } else {
                        DisplayOutput("  GetLastNotificationData");
                        DisplayOutput("   GUID {%8x-%4x-%4x-%x}",
                                      sNotify.guidNotificationCode.Data1,
                                      sNotify.guidNotificationCode.Data2,
                                      sNotify.guidNotificationCode.Data3,
                                      sNotify.guidNotificationCode.Data4
                                     );
                    }
                }
                break;

            case WAIT_TIMEOUT:
                //
                // no notification
                //
                DisplayOutput("  WAIT_TIMEOUT %xh (%d)",dwErr,dwErr);
                DisplayOutput("  (select UnSubscribe from the IStillDevice "\
                              "menu to quit)");
                break;
            case WAIT_ABANDONED:
                DisplayOutput("  WAIT_ABANDONED %xh (%d)",dwErr,dwErr);
                break;
            default:
                DisplayOutput("  default %xh (%d)",dwErr,dwErr);
                break;
        }
    }

    //
    // if the device is gone, StiDeviceRelease has already been
    //   unsubscribed elsewhere in this app
    //
    if ( ! pStiDevice )
        return (STIERR_GENERIC);

    //
    // UnSubscribe is called when an application no longer wants to receive
    // events from a device.
    //
    hres = pStiDevice->UnSubscribe();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnSubscribe",TRUE);
        hError = hres;
        *bPass = FALSE;
    }

    //
    // we're done with the event
    //
    CloseHandle(hWaitEvent);

    //
    // clear the semaphore
    //
    nUnSubscribeSemaphore = 0;

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiEscape(DWORD,char *,BOOL *)
                The Escape function is dependent on the vendor's implementation.
                Even if a device does not require the Escape function, the driver
                must provide it. A non-functional Escape must return an error.

    Parameters:
                DWORD EscapeFunction - driver defined code
                char *lpInData - pointer to data to be sent to device
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiEscape(DWORD EscapeFunction,char *lpInData,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    DWORD   dwTimeout = 2000;

    DWORD   cbInDataSize,
    dwOutDataSize,
    pdwActualData;
    char    pOutData[LONGSTRING];


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before Escape
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for Escape");

        //
        // Set up the command
        //
        cbInDataSize = strlen(lpInData + 1);
        //
        // zero out other parameters (for clarity's sake only)
        //
        ZeroMemory(pOutData,LONGSTRING);
        dwOutDataSize = pdwActualData = 0;

        //
        // The Escape function executes a multiparameter I/O call. The semantics
        // of this call is determined by the specific user-mode minidriver.
        //
        hres = pStiDevice->Escape(
                                 EscapeFunction, // General operation code. The meaning of this code
                                 // varies in each user mode minidriver. There is no
                                 // utilization of this code by the still image
                                 // minidriver.
                                 lpInData,       // Pointer to an input memory buffer. If there are
                                 // multiple areas of memory to be read from, they
                                 // must be packaged in some sort of structure
                                 // before being passed to this API.
                                 cbInDataSize,   // The length in bytes of the memory pointed to by
                                 // lpInData
                                 pOutData,       // Pointer to a memory buffer usable for writing.
                                 // Access to this memory is checked to be sure it
                                 // is available for writing.
                                 dwOutDataSize,  // The length in bytes of the memory pointed to by
                                 // lpOutData.
                                 &pdwActualData  // Pointer to a DWORD that gets the number of bytes
                                 // actually transferred to pOutData. If this value
                                 // is less than dwOutDataSize, then an error
                                 // situation could exist.
                                 );

        if ( ! SUCCEEDED(hres) ) {
            hError = hres;
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if the escape IOCTL is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"Escape",FALSE);
                DisplayOutput("  Escape IOCTL %d unsupported",EscapeFunction);
            } else {
                StiDisplayError(hres,"Escape",TRUE);
                *bPass = FALSE;
            }
        } else {
            DisplayOutput(" Escape on %S",szFriendlyName);

            DisplayOutput("  %xh (%d) EscapeFunction",
                          EscapeFunction,EscapeFunction);
            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  lpInData",
                          lpInData[0],
                          lpInData[1],
                          lpInData[2],
                          lpInData[3],
                          lpInData[4],
                          lpInData[5],
                          lpInData[6],
                          lpInData[7],
                          lpInData[8],
                          lpInData[9],
                          lpInData[10],
                          lpInData[11],
                          lpInData[12],
                          lpInData[13],
                          lpInData[14],
                          lpInData[15]
                         );
            DisplayOutput("  %xh (%d) cbInDataSize",
                          cbInDataSize,cbInDataSize);
            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  pOutData",
                          pOutData[0],
                          pOutData[1],
                          pOutData[2],
                          pOutData[3],
                          pOutData[4],
                          pOutData[5],
                          pOutData[6],
                          pOutData[7],
                          pOutData[8],
                          pOutData[9],
                          pOutData[10],
                          pOutData[11],
                          pOutData[12],
                          pOutData[13],
                          pOutData[14],
                          pOutData[15]
                         );
            DisplayOutput("  %xh (%d) dwOutDataSize",
                          dwOutDataSize,dwOutDataSize);
            DisplayOutput("  %xh (%d) pdwActualData",
                          pdwActualData,pdwActualData);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawReadData(char *,LPDWORD,BOOL *)
                Obtains data from a device.

                The RawReadData function is dependent on the vendor's implementation.
                Even if a device does not require the RawReadData function, the driver
                must provide it. A non-functional RawReadData must return an error.

    Parameters:
                char *lpBuffer - Location in memory to transfer the data coming in
                        from the device.
                LPDWORD lpdwNumberOfBytes - number of bytes to be read
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawReadData(char *lpBuffer,LPDWORD lpdwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before RawReadData
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawReadData");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawReadData interface reads data from a device. This is a
        // general operation for obtaining data from a device. Depending on
        // the user-mode minidriver for the device, command streams and data
        // streams can be read with this call. Some devices may seperate
        // commands from data by using RawReadCommand.
        //
        hres = pStiDevice->RawReadData(
                                      lpBuffer,                       // Location in memory to transfer the data
                                      // coming from the device
                                      lpdwNumberOfBytes,  // Number of bytes requested to be read
                                      lpOverlapped        // This is used to signal that the operation
                                      // of this call should be asynchronous. The
                                      // value here conforms to the Win32 APIs.
                                      );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawReadData is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawReadData",FALSE);
                DisplayOutput("  RawReadData unsupported");
            } else {
                StiDisplayError(hres,"RawReadData",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawReadData on %S",szFriendlyName);

            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  lpBuffer",
                          lpBuffer[0],
                          lpBuffer[1],
                          lpBuffer[2],
                          lpBuffer[3],
                          lpBuffer[4],
                          lpBuffer[5],
                          lpBuffer[6],
                          lpBuffer[7],
                          lpBuffer[8],
                          lpBuffer[9],
                          lpBuffer[10],
                          lpBuffer[11],
                          lpBuffer[12],
                          lpBuffer[13],
                          lpBuffer[14],
                          lpBuffer[15]
                         );
            DisplayOutput("  %xh (%d) lpdwNumberOfBytes read",
                          *lpdwNumberOfBytes,*lpdwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawWriteData(char *,DWORD,BOOL *)
                Sends data to the device.

                The RawWriteData function is dependent on the vendor's
                implementation. Even if a device does not require the RawWriteData
                function, the driver must provide it. A non-functional RawWriteData
                must return an error.

    Parameters:
                char *lpBuffer - Location in memory to read from when sending data to
                        a device.
                LPDWORD lpdwNumberOfBytes - number of bytes of data to be sent
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawWriteData(char *lpBuffer,DWORD dwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before RawWriteData
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawWriteData");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawWriteData interface writes data to a device. This is a
        // general operation for sending data to a device. Depending on
        // the user-mode minidriver for the device, command streams and data
        // streams can be written with this call. Some devices may seperate
        // commands from data by using RawWriteCommand.
        //
        hres = pStiDevice->RawWriteData(
                                       lpBuffer,                       // Location in memory to read from when sending
                                       // data to a device
                                       dwNumberOfBytes,    // Number of bytes of data to send
                                       lpOverlapped        // This is used to signal that the operation
                                       // of this call should be asynchronous. The
                                       // value here conforms to the Win32 APIs.
                                       );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawWriteData is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawWriteData",FALSE);
                DisplayOutput("  RawWriteData unsupported");
            } else {
                StiDisplayError(hres,"RawWriteData",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawWriteData on %S",szFriendlyName);
            DisplayOutput("  %xh (%d) dwNumberOfBytes sent",
                          dwNumberOfBytes,dwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawReadCommand(char *,LPDWORD,BOOL *)
                Obtains command information from the device. Unique to the IStiDevice
                interface.

                The RawReadCommand function is dependent on the vendor's implementation.
                Even if a device does not require the RawReadCommand function, the
                driver must provide it. A non-functional RawReadCommand must return an
                error.

    Parameters:
                char *lpBuffer - Location in memory to transfer the data coming in
                        from the device.
                LPDWORD lpdwNumberOfBytes - number of bytes to be read
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawReadCommand(char *lpBuffer,LPDWORD lpdwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;


    //
    // Must lock device before RawReadCommand
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawReadCommand");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawReadCommand interface reads command information from a
        // device. The implementation of this call depends on the user-mode
        // minidriver for the device. Many devices will not require
        // separating commands and data. If this call is not used, the
        // user-mode minidriver should return STIERR_UNSUPPORTED.
        //
        hres = pStiDevice->RawReadCommand(
                                         lpBuffer,                       // Location in memory to transfer the command
                                         // information coming from the device
                                         lpdwNumberOfBytes,  // Number of command bytes requested to be read
                                         lpOverlapped        // This is used to signal that the operation
                                         // of this call should be asynchronous. The
                                         // value here conforms to the Win32 APIs.
                                         );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawReadCommand is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawReadCommand",FALSE);
                DisplayOutput("  RawReadCommand unsupported");
            } else {
                StiDisplayError(hres,"RawReadCommand",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawReadCommand on %S",szFriendlyName);

            DisplayOutput("  %x %x %x %x %x %x %x %x - %x %x %x %x %x %x %x %x  lpBuffer",
                          lpBuffer[0],
                          lpBuffer[1],
                          lpBuffer[2],
                          lpBuffer[3],
                          lpBuffer[4],
                          lpBuffer[5],
                          lpBuffer[6],
                          lpBuffer[7],
                          lpBuffer[8],
                          lpBuffer[9],
                          lpBuffer[10],
                          lpBuffer[11],
                          lpBuffer[12],
                          lpBuffer[13],
                          lpBuffer[14],
                          lpBuffer[15]
                         );
            DisplayOutput("  %xh (%d) lpdwNumberOfBytes read",
                          *lpdwNumberOfBytes,*lpdwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}


/*****************************************************************************
    HRESULT StiRawWriteCommand(char *,DWORD,BOOL *)
                Sends command information to the device. Unique to the IStiDevice
                interface.

                The RawWriteCommand function is dependent on the vendor's
                implementation. Even if a device does not require the RawWriteCommand
                function, the driver must provide it. A non-functional RawWriteCommand
                must return an error.

    Parameters:
                char *lpBuffer - Location in memory to read from when sending data to
                        a device.
                LPDWORD lpdwNumberOfBytes - number of bytes of data to be sent
                pointer to receive Pass/Fail result

    Return:
        HRESULT of last failed Sti call

*****************************************************************************/
HRESULT StiRawWriteCommand(char *lpBuffer,DWORD dwNumberOfBytes,BOOL *bPass)
{
    HRESULT hres = STI_OK,
    hError = STI_OK;
    LPOVERLAPPED    lpOverlapped;
    DWORD           dwTimeout = 2000;


    //
    // check that an Sti device is selected
    //
    if ( ! pStiDevice ) {
        *bPass = FALSE;
        StiDisplayError(STIERR_GENERIC,"NoStiDevice",TRUE);
        return (STIERR_GENERIC);
    }
    *bPass = TRUE;

    //
    // Must lock device before RawWriteCommand
    //
    // The LockDevice locks the apparatus for a single application to access.
    // Each LockDevice should be paired with a matching UnLockDevice call.
    //
    hres = pStiDevice->LockDevice(
                                 dwTimeout               // timeout in milliseconds
                                 );

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"LockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else {
        DisplayOutput(" Device is locked for RawWriteCommand");

        //
        // Set up the command
        //
        lpOverlapped = NULL;

        //
        // The RawWriteCommand interface sends command information to the
        // device. The implementation of this call depends on the user-mode
        // minidriver for the device. Many devices will not require
        // separating commands and data. If this call is not used, the
        // user-mode minidriver should return STIERR_UNSUPPORTED.
        //
        hres = pStiDevice->RawWriteCommand(
                                          lpBuffer,                       // Location in memory to read from when writing
                                          // command information to the device
                                          dwNumberOfBytes,    // Number of bytes of data to send
                                          lpOverlapped        // This is used to signal that the operation
                                          // of this call should be asynchronous. The
                                          // value here conforms to the Win32 APIs.
                                          );

        if ( ! SUCCEEDED(hres) ) {
            if ( hres == STIERR_UNSUPPORTED ) {
                //
                // COMPLIANCE test:
                //   if RawWriteData is NOT supported, the driver MUST
                //   return STIERR_UNSUPPORTED
                //
                StiDisplayError(hres,"RawWriteCommand",FALSE);
                DisplayOutput("  RawWriteCommand unsupported");
            } else {
                StiDisplayError(hres,"RawWriteCommand",TRUE);
                *bPass = FALSE;
            }
            hError = hres;
        } else {
            DisplayOutput(" RawWriteCommand on %S",szFriendlyName);
            DisplayOutput("  %xh (%d) dwNumberOfBytes sent",
                          dwNumberOfBytes,dwNumberOfBytes);
        }
    }

    //
    // The UnLockDevice interface unlocks a device that was previously locked.
    //
    hres = pStiDevice->UnLockDevice();

    if ( ! SUCCEEDED(hres) ) {
        StiDisplayError(hres,"UnLockDevice",TRUE);
        hError = hres;
        *bPass = FALSE;
    } else
        DisplayOutput(" Device is unlocked");

    DisplayOutput("");

    return (hError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wiadbgcfg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiadbgcfg.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WIADBGCFG_DIALOG            102
#define IDR_MAINFRAME                   128
#define IDC_MODULES_COMBOBOX            1000
#define IDC_DEBUG_FLAGS_EDITBOX         1001
#define IDC_FLAGS_LIST                  1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\stillvue\winx.cpp ===
/******************************************************************************

  winx.cpp
  Windows utility procedures

  Copyright (C) Microsoft Corporation, 1997 - 1998
  All rights reserved

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

******************************************************************************/

#include "stillvue.h"

#include <math.h>                       // pow

// WINERROR.H - GetLastError errors
STRINGTABLE StWinerror[] =
{
    ERROR_SUCCESS,              "ERROR_SUCCESS",0,
    ERROR_FILE_NOT_FOUND,       "ERROR_FILE_NOT_FOUND",0,
    ERROR_PATH_NOT_FOUND,       "ERROR_PATH_NOT_FOUND",0,
    ERROR_INVALID_FUNCTION,     "ERROR_INVALID_FUNCTION",0,
    ERROR_ACCESS_DENIED,        "ERROR_ACCESS_DENIED",0,
    ERROR_INVALID_HANDLE,       "ERROR_INVALID_HANDLE",0,
    ERROR_INVALID_PARAMETER,    "ERROR_INVALID_PARAMETER",0,
    ERROR_CALL_NOT_IMPLEMENTED, "ERROR_CALL_NOT_IMPLEMENTED",0,
    ERROR_ALREADY_EXISTS,       "ERROR_ALREADY_EXISTS",0,
    ERROR_INVALID_FLAGS,		"ERROR_INVALID_FLAGS",0,
    ERROR_INVALID_CATEGORY,		"ERROR_INVALID_CATEGORY",0,
    RPC_S_SERVER_UNAVAILABLE,   "RPC_S_SERVER_UNAVAILABLE",0,
    0, "See WINERROR.H",-1
};


/******************************************************************************
  ULONG atox(LPSTR lpHex)

  Convert string to hexadecimal value.
******************************************************************************/
ULONG atox(LPSTR lpHex)
{
    char    *p;
    int     x;
    double  y;
    ULONG   z,ulHex = 0l;


    for (p = lpHex,x = 0;p[x];x++)
        ;

    for (x--,y = 0.0;lpHex <= (p + x);x--,y++)
    {
        z = (ULONG) pow(16.0,y);

        if ((p[x] >= '0')&&(p[x] <= '9'))
            ulHex += ((p[x] - '0') * z);
        if ((p[x] >= 'A')&&(p[x] <= 'F'))
            ulHex += ((p[x] - 'A' + 10) * z);
        if ((p[x] >= 'a')&&(p[x] <= 'f'))
            ulHex += ((p[x] - 'a' + 10) * z);
    }

    return (ulHex);
}


#ifdef _DEBUG

/******************************************************************************
  void DisplayDebug(LPSTR sz,...)

  Output text to debugger.
******************************************************************************/
void DisplayDebug(LPSTR sz,...)
{
    char    Buffer[512];
    va_list list;


    va_start(list,sz);
    vsprintf(Buffer,sz,list);

    OutputDebugString(Buffer);
    OutputDebugString("\n");

    return;
}

#else

/******************************************************************************
  void DisplayDebug(LPSTR sz,...)

  Output text to debugger - nonfunctional retail version..
******************************************************************************/
void DisplayDebug(LPSTR sz,...)
{
    return;
}

#endif


/******************************************************************************
    BOOL ErrorMsg(HWND, LPSTR, LPSTR, BOOL)
    Display an error message and send WM_QUIT if error is fatal.

    Parameters: handle to current window,
    long pointer to string with error message,
    long pointer to string with message box caption,
    error (Fatal if TRUE)

    Shut down app if bFatal is TRUE, continue if FALSE.
******************************************************************************/
BOOL ErrorMsg(HWND hWnd, LPSTR lpzMsg, LPSTR lpzCaption, BOOL bFatal)
{
    MessageBox(hWnd, lpzMsg, lpzCaption, MB_ICONEXCLAMATION | MB_OK);
    if (bFatal)
         PostMessage (hWnd, WM_QUIT, 0, 0L);

    return (bFatal);
}


/******************************************************************************
    fDialog(id,hwnd,fpfn)

    Description:
    This function displays a dialog box and returns the exit code.
    the function passed will have a proc instance made for it.

    Parameters:
    id              resource id of dialog to display
    hwnd            parent window of dialog
    fpfn            dialog message function

    Returns:
    exit code of dialog (what was passed to EndDialog)

******************************************************************************/
BOOL fDialog(int id,HWND hWnd,FARPROC fPfn)
{
    BOOL        f;
    HINSTANCE   hInst;

    hInst = (HINSTANCE) GetWindowLong(hWnd,GWL_HINSTANCE);
    fPfn  = MakeProcInstance(fPfn,hInst);
    f = DialogBox(hInst,MAKEINTRESOURCE(id),hWnd,(DLGPROC)fPfn);
    FreeProcInstance(fPfn);
 
	return (f);
}


/******************************************************************************
    void FormatHex(unsigned char *szSource, char *szDest)

    take first 16 bytes from szSource,
    format into a hex dump string,
    then copy the string into szDest
    szDest must have room for at least 66 bytes

    sample code fragment showing use:
    char            szOut[128],         // output string

    // print header
    sprintf(szOut,
        "Offset    --------------------- hex ---------------------  ---- ascii -----");
    puts(szOut);

    // dump 512 bytes (32 lines, 16 bytes per line)
    for (i = 0; i < 32; i++)
        {
        // get next 16 bytes
        _fmemcpy(szDbgMsg,fpSector + (i*16),16);

        // get current offset into data block
        sprintf(szOut,"%03xh(%03d) ",i*16,i*16);

        // append debug string after data block offset message
        FormatHex(szDbgMsg, szOut + strlen(szOut));
        puts(szOut);
        }

******************************************************************************/
void FormatHex(unsigned char *szSource, char *szDest)
{
    unsigned short  j;


    sprintf(szDest,
        "%02x %02x %02x %02x %02x %02x %02x %02x:"\
        "%02x %02x %02x %02x %02x %02x %02x %02x  ",
        szSource[0],
        szSource[1],
        szSource[2],
        szSource[3],
        szSource[4],
        szSource[5],
        szSource[6],
        szSource[7],
        szSource[8],
        szSource[9],
        szSource[10],
        szSource[11],
        szSource[12],
        szSource[13],
        szSource[14],
        szSource[15]);

    // replace bytes with undesirable Sprintf side effects with SPACE
    for (j = 0; j < 16; j++)
        {
        if ((0x00 == szSource[j]) ||
            (0x07 == szSource[j]) ||
            (0x09 == szSource[j]) ||
            (0x0a == szSource[j]) ||
            (0x0d == szSource[j]) ||
            (0x1a == szSource[j]))
            szSource[j] = 0x20;
        }

    sprintf(szDest + strlen(szDest),
        "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c",
        szSource[0],
        szSource[1],
        szSource[2],
        szSource[3],
        szSource[4],
        szSource[5],
        szSource[6],
        szSource[7],
        szSource[8],
        szSource[9],
        szSource[10],
        szSource[11],
        szSource[12],
        szSource[13],
        szSource[14],
        szSource[15]);

    return;
}


/******************************************************************************
    BOOL GetFinalWindow(HANDLE, LPRECT, LPSTR, LPSTR)
    Retrieve the last window size & location from a private INI

    Parameters: handle to current instance,
    long pointer to a rectangle with window size/shape,
    string with INI filename,
    string with Section name

    Returns: success/failure (never fails)

    Get display size in pixels and private INI saved width and height.
    Default width (for no previous INI) is 1/3 display width.
    Default height (for no previous INI) is 1/3 display height.
    If saved size or postion would put part or all the window
    off the desktop, first change the position then the size until
    the window is completely on the desktop.

******************************************************************************/
BOOL GetFinalWindow (HANDLE hInst,
                     LPRECT lprRect,
                     LPSTR  lpzINI,
                     LPSTR  lpzSection)
{
    int       x, nDisplayWidth, nDisplayHeight;
    RECT      rect;


    nDisplayWidth  = GetSystemMetrics(SM_CXSCREEN);
    nDisplayHeight = GetSystemMetrics(SM_CYSCREEN);

    rect.left   = GetPrivateProfileInt(lpzSection, "Left",
       (nDisplayWidth/10) * 7,lpzINI);
    rect.top    = GetPrivateProfileInt(lpzSection, "Top",
       (nDisplayHeight/10) * 8,lpzINI);
    rect.right  = GetPrivateProfileInt(lpzSection, "Right",
       nDisplayWidth,lpzINI);
    rect.bottom = GetPrivateProfileInt(lpzSection, "Bottom",
       nDisplayHeight,lpzINI);


/*/////////////////////////////////////////////////////////////////////////////
    if window hangs off top or left of display, change location to
    edge of display and preserve size.
/////////////////////////////////////////////////////////////////////////////*/
    if (rect.top < 0)
         {
         rect.bottom += rect.top * -1;
         rect.top = 0;
         }

    if (rect.left < 0)
         {
         rect.right += rect.left * -1;
         rect.left = 0;
         }

/*/////////////////////////////////////////////////////////////////////////////
    if window hangs off bottom or right of display, change location
    to bring it back onscreen.  If window dimension is greater than
    display, reduce to size of display.
/////////////////////////////////////////////////////////////////////////////*/
    if (rect.bottom > nDisplayHeight)
         {
         if (rect.bottom > nDisplayHeight * 2)
              {
              rect.top    = 0;
              rect.bottom = nDisplayHeight;
              }
         else
              {
              x = rect.bottom - nDisplayHeight;
              rect.bottom -= x;
              rect.top    -= x;
              }
         }

    if (rect.right > nDisplayWidth)
         {
         if (rect.right > nDisplayWidth * 2)
              {
              rect.left  = 0;
              rect.right = nDisplayWidth;
              }
         else
              {
              x = rect.right - nDisplayWidth;
              rect.right -= x;
              rect.left  -= x;
              }
         }

/*/////////////////////////////////////////////////////////////////////////////
    GetWindowRect() returns a rect where right and bottom are absolute
    (measured from 0,0 of display).  However, CreateWindow requires
    right and bottom to be relative (measured from 0,0 of the window
    to be created).  SaveFinalWindow saves an absolute rect, and
    GetFinalRect converts these to relative measurements.
/////////////////////////////////////////////////////////////////////////////*/
    SetRect(lprRect,
         rect.left,
         rect.top,
         rect.right - rect.left,
         rect.bottom - rect.top);

    return (TRUE);
}


/******************************************************************************
    BOOL LastError(BOOL)

    Calls GetLastError and displays result in a nice string

    Parameters: bNewOnly == TRUE if you only want changed error displayed
    Returns: TRUE if it found an error, else FALSE
******************************************************************************/
BOOL LastError(BOOL bNewOnly)
{
static  DWORD   dwLast = 0;
        DWORD   dwError;


    if (dwError = GetLastError())
    {
        // if user asked for only new errors
        if (bNewOnly)
        {
            // not a new error
            if (dwLast == dwError)
                return FALSE;
            // new error, save it
            dwLast = dwError;
        }
        DisplayOutput("*GetLastError %xh %d \"%s\"",
            dwError,dwError,StrFromTable(dwError,StWinerror));
        return (TRUE);
    }

	return (FALSE);
}


/******************************************************************************
  int NextToken(char *pDest,char *pSrc)

  Return next token from a command line string.
******************************************************************************/
int NextToken(char *pDest,char *pSrc)
{
    char    *pA,*pB;
    int     x;


    // point pArg to start of token in string pSrc
    for (pA = pSrc;*pA && isspace((int) *pA);pA++)
        ;

    // find end of token in string pSrc
    for (pB = pA;((*pB) && (! isspace((int) *pB)));pB++)
        ;

	// count of chars to next token or end of string
	x = (min((pB - pA),(int) strlen(pSrc))) + 1;

    // pszDest now contains the arg
    lstrcpyn(pDest,pA,x);

    // return sizeof token
    return (x);
}


/******************************************************************************
    BOOL SaveFinalWindow(HANDLE, HWND, LPSTR, LPSTR)
    Save the current window size & location to a private INI

    Parameters: handle to current instance,
    handle to current window,
    string with INI filename,
    string with Section name

    Returns: success/failure (fails if window is MIN or MAX)
******************************************************************************/
BOOL SaveFinalWindow (HANDLE hInst,
                      HWND hWnd,
                      LPSTR lpzINI,
                      LPSTR lpzSection)
{
    PSTR      pszValue;
    RECT      rectWnd, rectINI;


    // if the window is minimized OR maximised, don't save anything
    if (IsIconic(hWnd) || IsZoomed(hWnd))
         return (FALSE);

    GetWindowRect (hWnd, &rectWnd);

    // get INI data.  If there isn't any, we'll get the default and
    // save the current Window data.
    rectINI.left   = GetPrivateProfileInt(lpzSection, "Left", 0, lpzINI);
    rectINI.top    = GetPrivateProfileInt(lpzSection, "Top", 0, lpzINI);
    rectINI.right  = GetPrivateProfileInt(lpzSection, "Right", 0, lpzINI);
    rectINI.bottom = GetPrivateProfileInt(lpzSection, "Bottom", 0, lpzINI);

    // if current window is same as in INI, don't change INI
    if ( rectINI.left   == rectWnd.left  &&
         rectINI.top    == rectWnd.top   &&
         rectINI.right  == rectWnd.right &&
         rectINI.bottom == rectWnd.bottom)
         return (TRUE);

    // EXIT if we can't local alloc our string stuffer
    if ((pszValue = (PSTR) LocalAlloc(LPTR, 80)) == NULL)
         return (FALSE);

    // it's different, so save
    sprintf(pszValue, "%d", rectWnd.left);
    WritePrivateProfileString(lpzSection, "Left", pszValue, lpzINI);
    sprintf(pszValue, "%d", rectWnd.top);
    WritePrivateProfileString(lpzSection, "Top", pszValue, lpzINI);
    sprintf(pszValue, "%d", rectWnd.right);
    WritePrivateProfileString(lpzSection, "Right", pszValue, lpzINI);
    sprintf(pszValue, "%d", rectWnd.bottom);
    WritePrivateProfileString(lpzSection, "Bottom", pszValue, lpzINI);
    LocalFree((HANDLE) pszValue);

    return (TRUE);
}


/******************************************************************************
  char * StrFromTable(long number,PSTRINGTABLE pstrTable)

  Return string associated with a value from a string table.
******************************************************************************/
char * StrFromTable(long number,PSTRINGTABLE pstrTable)
{
    for (;pstrTable->end != -1;pstrTable++)
    {
        if (number == pstrTable->number)
            break;
    }

    return (pstrTable->szString);
}


/******************************************************************************
    BOOL Wait32(DWORD)

    wait DWORD milliseconds, then return

******************************************************************************/
BOOL Wait32(DWORD dwTime)
{
   DWORD   dwNewTime,
           dwOldTime;


   // wait dwTime, then exit
   dwOldTime = GetCurrentTime();
   while (TRUE)
       {
       dwNewTime = GetCurrentTime();
       if (dwNewTime > dwOldTime + dwTime)
           break;
       }

   return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4C9E66C2_A22A_4EB0_9364_2726EF56B60E__INCLUDED_)
#define AFX_STDAFX_H__4C9E66C2_A22A_4EB0_9364_2726EF56B60E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "fileio.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4C9E66C2_A22A_4EB0_9364_2726EF56B60E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\fileio.h ===
#ifndef _FILEIO_H
#define _FILEIO_H

#define WIN32_MEAN_AND_LEAN
#define WIN32_EXTRA_LEAN

class CFileIO {
public:
    CFileIO(LPCTSTR szFileName = NULL)
    {
        m_hFile         = NULL;
        m_TotalFileSize = 0;
        Open(szFileName);        
    }

    ~CFileIO()
    {
        Close();
    }
    
    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: Open()
    // Purpose: open a given file, for reading and writing
    // Parameters:
    // LPCTSTR szFileName - File name to open
    //
    ////////////////////////////////////////////////////////////////////
    HRESULT Open(LPCTSTR szFileName, BOOL bCreate = FALSE){
        if(NULL != szFileName){
            DWORD dwOpen = OPEN_EXISTING;
            if(bCreate){
                dwOpen = OPEN_ALWAYS;
            }
            m_hFile = CreateFile(szFileName,
                GENERIC_READ|GENERIC_WRITE,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                NULL,
                dwOpen,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
            
            BY_HANDLE_FILE_INFORMATION FileInfo;
            memset(&FileInfo,0,sizeof(BY_HANDLE_FILE_INFORMATION));
            GetFileInformationByHandle(m_hFile,&FileInfo);            
            m_TotalFileSize = FileInfo.nFileSizeLow;
        }
        m_bReady = (INVALID_HANDLE_VALUE != m_hFile);
        if(m_bReady)
            return S_OK;
        return E_FAIL;
    }

    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: FileSize()
    // Purpose: return the file size of the currently opened file
    // Parameters: none
    //     
    ////////////////////////////////////////////////////////////////////

    LONG FileSize(){
        return m_TotalFileSize;
    }

    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: EraseFile()
    // Purpose: erase file contents, by resetting the EOF
    // Parameters: none
    //     
    ////////////////////////////////////////////////////////////////////

    VOID EraseFile(){
        SetEndOfFile(m_hFile);    
    }

    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: WriteEOL()
    // Purpose: write a carriage return, line feed to the file
    // Parameters: none
    //     
    ////////////////////////////////////////////////////////////////////

    BOOL WriteEOL(){
        DWORD dwBytesWritten = 0;
        TCHAR EndOfLine[2];
        EndOfLine[0] = TEXT('\r');
        EndOfLine[1] = TEXT('\n');                
        return WriteFile(EndOfLine,2,&dwBytesWritten,NULL);
    }
    
    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: Close()
    // Purpose: close the opened file
    // Parameters: none
    //     
    ////////////////////////////////////////////////////////////////////

    VOID Close(){
        if(NULL != m_hFile){
            CloseHandle(m_hFile);
            m_hFile = NULL;
        }
    }

    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: ReadLine()
    // Purpose: read a text line from a text-base file
    // Parameters:
    // LPTSTR szTextLine - buffer for text line data
    // LONG   lBufferSize - size of szTextLine buffer
    // PLONG  pNumTCHARs - number of characters read (can be NULL)
    //     
    ////////////////////////////////////////////////////////////////////

    BOOL ReadLine (LPTSTR szTextLine, LONG lBufferSize, PLONG pNumTCHARs){
        TCHAR ch                = TEXT(' ');
        LONG index              = 0;
        DWORD dwBytesRead       = 1;
        DWORD dwTotalBytesRead  = 0;
        memset(szTextLine,0,lBufferSize);
        
        while(ch != TEXT('\r') && 
              ch != TEXT('\n') &&
              dwBytesRead > 0) {

            if(!ReadFile(&ch,sizeof(TCHAR),&dwBytesRead,NULL)){
                return FALSE;
            }
            
            if(dwBytesRead > 0){
                szTextLine[index] = ch;
                dwTotalBytesRead += dwBytesRead;
                index++;
            }
        }

        //
        // rip to next line...
        //

        while(ch == TEXT('\r') && dwBytesRead > 0){
            ch = TEXT(' ');
            if(!ReadFile(&ch,sizeof(TCHAR),&dwBytesRead,NULL)) {
                return FALSE;
            }            
        }

        if(NULL != pNumTCHARs){
            *pNumTCHARs = 0;
            *pNumTCHARs = (dwTotalBytesRead/sizeof(TCHAR));
        }
        
        if(dwTotalBytesRead > 0)
            return TRUE;
        
        return FALSE;
    }
    
    BOOL WriteLine(LPTSTR szTextLine){
        DWORD dwBytesWritten = 0;
        if(WriteFile((LPCVOID)szTextLine,(lstrlen(szTextLine) * sizeof(TCHAR)),&dwBytesWritten,NULL)){
            return WriteFile((LPCVOID)TEXT("\r\n"),(2* sizeof(TCHAR)),&dwBytesWritten,NULL);
        } else {
            return FALSE;
        }
    }
    
    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: ReadFile()
    // Purpose: read data from a file
    // Parameters:
    // LPVOID lpBuffer - buffer to fill with data
    // DWORD nNumberOfBytesToRead - number of bytes to read
    // LPDWORD lpNumberOfBytesRead - number of bytes read
    // LPOVERLAPPED lpOverlapped - overlap
    //     
    ////////////////////////////////////////////////////////////////////

    BOOL ReadFile(LPVOID lpBuffer,
        DWORD nNumberOfBytesToRead,
        LPDWORD lpNumberOfBytesRead,
        LPOVERLAPPED lpOverlapped){
        if(!m_bReady){
            return FALSE;
        }
        return ::ReadFile(m_hFile,lpBuffer,nNumberOfBytesToRead,
            lpNumberOfBytesRead,lpOverlapped);
    }
    
    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: WriteFile()
    // Purpose: write data to a file
    // Parameters:
    // LPCVOID lpBuffer - buffer to write to a file
    // DWORD nNumberOfBytesToWrite - number of bytes to write
    // LPDWORD lpNumberOfBytesWritten - number of bytes written
    // LPOVERLAPPED lpOverlapped - overlap
    //     
    ////////////////////////////////////////////////////////////////////

    BOOL WriteFile(LPCVOID lpBuffer,
        DWORD nNumberOfBytesToWrite,
        LPDWORD lpNumberOfBytesWritten,
        LPOVERLAPPED lpOverlapped){
        
        if(!m_bReady){
            return FALSE;
        }
        return ::WriteFile(m_hFile,lpBuffer,nNumberOfBytesToWrite,
            lpNumberOfBytesWritten,lpOverlapped);
    }

    ////////////////////////////////////////////////////////////////////
    //
    // Function Name: SeekFile()
    // Purpose: move current file pointer
    // Parameters:
    // DWORD dwBytesToSeek - number of bytes to move file pointer
    // DWORD dwMoveMethod - method of moving file pointer
    // [Valid dwMoveMethods]
    // FILE_BEGIN   - from the beginning of the file
    // FILE_CURRENT - from the current file position
    // FILE_END     - from the end of the file
    //     
    ////////////////////////////////////////////////////////////////////

    BOOL SeekFile(DWORD dwBytesToSeek, DWORD dwMoveMethod){
        DWORD dwFilePointer = 0;
        dwFilePointer = SetFilePointer(m_hFile,dwBytesToSeek,NULL,dwMoveMethod);
        if (dwFilePointer == 0xFFFFFFFF)
            return FALSE;
        return TRUE;
    }
    
private:
    HANDLE m_hFile;         // file handle
    BOOL   m_bReady;        // cfileio class ready flag
    LONG   m_TotalFileSize; // file size (bytes)
protected:
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\wiadbgcfg.cpp ===
// wiadbgcfg.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wiadbgcfg.h"
#include "wiadbgcfgDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiadbgcfgApp

BEGIN_MESSAGE_MAP(CWiadbgcfgApp, CWinApp)
    //{{AFX_MSG_MAP(CWiadbgcfgApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiadbgcfgApp construction

CWiadbgcfgApp::CWiadbgcfgApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWiadbgcfgApp object

CWiadbgcfgApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWiadbgcfgApp initialization

BOOL CWiadbgcfgApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CWiadbgcfgDlg dlg;
    m_pMainWnd = &dlg;
    int nResponse = (int)dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    dlg.FreeDataBaseMemory();

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\addremove.cpp ===
// AddRemove.cpp : implementation file
//

#include "stdafx.h"
#include "wialogcfg.h"
#include "AddRemove.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddRemove dialog


CAddRemove::CAddRemove(CWnd* pParent /*=NULL*/)
	: CDialog(CAddRemove::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddRemove)
	m_NewKeyName = _T("");
	m_StatusText = _T("");
	//}}AFX_DATA_INIT
}


void CAddRemove::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddRemove)
	DDX_Text(pDX, IDC_EDIT_KEYNAME, m_NewKeyName);
	DDX_Text(pDX, IDC_STATUS_TEXT, m_StatusText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddRemove, CDialog)
	//{{AFX_MSG_MAP(CAddRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddRemove message handlers

void CAddRemove::OnOK() 
{
	UpdateData(TRUE);
	if(m_NewKeyName.IsEmpty()) {
		MessageBox("Please enter a Module Name, or\npress 'Cancel' to exit.",m_szTitle,MB_ICONERROR|MB_OK);
	} else {
		CDialog::OnOK();
	}
}

void CAddRemove::SetTitle(TCHAR *pszDlgTitle)
{
	lstrcpy(m_szTitle,pszDlgTitle);
}

void CAddRemove::SetStatusText(TCHAR *pszStatusText)
{
	m_StatusText = pszStatusText;
}

BOOL CAddRemove::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	SetWindowText(m_szTitle);
	UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddRemove::GetNewKeyName(TCHAR *pszNewKeyName)
{
	lstrcpy(pszNewKeyName,m_NewKeyName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\wiadbgcfg.h ===
// wiadbgcfg.h : main header file for the WIADBGCFG application
//

#if !defined(AFX_WIADBGCFG_H__FBB8E037_44AE_47D7_9898_446B35718919__INCLUDED_)
#define AFX_WIADBGCFG_H__FBB8E037_44AE_47D7_9898_446B35718919__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWiadbgcfgApp:
// See wiadbgcfg.cpp for the implementation of this class
//

class CWiadbgcfgApp : public CWinApp
{
public:
	CWiadbgcfgApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiadbgcfgApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWiadbgcfgApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIADBGCFG_H__FBB8E037_44AE_47D7_9898_446B35718919__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\wiadbgcfgdlg.cpp ===
// wiadbgcfgDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wiadbgcfg.h"
#include "wiadbgcfgDlg.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DEBUG_REGKEY_ROOT TEXT("System\\CurrentControlSet\\Control\\StillImage\\Debug")
#define DWORD_REGVALUE_DEBUGFLAGS TEXT("DebugFlags")
#define WIADBGCFG_DATAFILE TEXT("wiadbgcfg.txt")

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog {
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum {
        IDD = IDD_ABOUTBOX
    };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
//{{AFX_MSG_MAP(CAboutDlg)
// No message handlers
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiadbgcfgDlg dialog

CWiadbgcfgDlg::CWiadbgcfgDlg(CWnd* pParent /*=NULL*/)
: CDialog(CWiadbgcfgDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CWiadbgcfgDlg)
    m_szDebugFlags = _T("");
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_dwNumEntrysInDataBase = 0;
    m_pFlagDataBase = NULL;
}

void CWiadbgcfgDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiadbgcfgDlg)
    DDX_Control(pDX, IDC_FLAGS_LIST, m_DefinedDebugFlagsListBox);
    DDX_Control(pDX, IDC_MODULES_COMBOBOX, m_ModuleSelectionComboBox);
    DDX_Text(pDX, IDC_DEBUG_FLAGS_EDITBOX, m_szDebugFlags);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWiadbgcfgDlg, CDialog)
//{{AFX_MSG_MAP(CWiadbgcfgDlg)
ON_WM_SYSCOMMAND()
ON_WM_PAINT()
ON_WM_QUERYDRAGICON()
ON_CBN_SELCHANGE(IDC_MODULES_COMBOBOX, OnSelchangeModulesCombobox)
ON_WM_CLOSE()
ON_EN_CHANGE(IDC_DEBUG_FLAGS_EDITBOX, OnChangeDebugFlagsEditbox)
ON_LBN_SELCHANGE(IDC_FLAGS_LIST, OnSelchangeFlagsList)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiadbgcfgDlg message handlers

BOOL CWiadbgcfgDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL) {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty()) {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    m_lDebugFlags = 0;

    BuildFlagDataBaseFromFile();

    return AddModulesToComboBox();
}

void CWiadbgcfgDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX) {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    } else {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWiadbgcfgDlg::OnPaint()
{
    if (IsIconic()) {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    } else {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWiadbgcfgDlg::OnQueryDragIcon()
{
    return(HCURSOR) m_hIcon;
}

BOOL CWiadbgcfgDlg::AddModulesToComboBox()
{
    BOOL bSuccess   = FALSE;
    HKEY hTargetKey = NULL;
    DWORD dwNumKeys = 0;
    LONG lResult    = ERROR_NO_MORE_ITEMS;
    TCHAR szKeyName[MAX_PATH];

    //
    // open root Debug registry key
    //

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,DEBUG_REGKEY_ROOT,&hTargetKey)) {

        //
        // enumerate sub keys
        //

        memset(szKeyName,0,sizeof(szKeyName));
        lResult = RegEnumKey(hTargetKey,dwNumKeys,szKeyName,sizeof(szKeyName));

        //
        // while there are no more keys...
        //

        while (lResult != ERROR_NO_MORE_ITEMS) {
            memset(szKeyName,0,sizeof(szKeyName));
            lResult = RegEnumKey(hTargetKey,dwNumKeys,szKeyName,sizeof(szKeyName));

            //
            // if the key name is longer than 0 characters...
            // add it to the combobox.
            //

            if (lstrlen(szKeyName) > 0) {
                m_ModuleSelectionComboBox.AddString(szKeyName);
            }

            //
            // increment the key index/counter
            //

            dwNumKeys++;
        }

        //
        // check to see if we recieved any valid keys...
        //

        if (dwNumKeys > 0) {
            bSuccess = TRUE;
        }

        //
        // close root Debug registry key
        //

        if (NULL != hTargetKey) {
            RegCloseKey(hTargetKey);
            hTargetKey = NULL;
        }
    }

    //
    // if the enumertation was a success...
    // populate the other controls..
    //

    if (bSuccess) {
        m_ModuleSelectionComboBox.SetCurSel(0);
        UpdateCurrentValueFromRegistry();
        OnChangeDebugFlagsEditbox();
    }

    //
    // return success value
    //

    return bSuccess;
}

VOID CWiadbgcfgDlg::UpdateCurrentValueFromRegistry()
{
    HKEY hDebugKey = NULL;
    TCHAR szDebugKey[MAX_PATH];
    if (ConstructDebugRegKey(szDebugKey,sizeof(szDebugKey))) {

        //
        // open registry key
        //

        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,szDebugKey,&hDebugKey)) {

            //
            // initialize DWORD reading values
            //

            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            //
            // read current registry value
            //

            RegQueryValueEx(hDebugKey,DWORD_REGVALUE_DEBUGFLAGS,0,&dwType,(LPBYTE)&m_lDebugFlags,&dwSize);

            //
            // update UI
            //

            UpdateEditBox();

            //
            // close registry key
            //

            RegCloseKey(hDebugKey);

            //
            // add flags for that module to list box
            //

            TCHAR szModuleName[MAX_PATH];
            memset(szModuleName,0,sizeof(szModuleName));
            GetSelectedModuleName(szModuleName,sizeof(szModuleName));

            AddFlagsToListBox(szModuleName);
        }
    }
}

VOID CWiadbgcfgDlg::UpdateCurrentValueToRegistry()
{
    HKEY hDebugKey = NULL;
    TCHAR szDebugKey[MAX_PATH];
    if (ConstructDebugRegKey(szDebugKey,sizeof(szDebugKey))) {

        //
        // open registry key
        //

        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,szDebugKey,&hDebugKey)) {

            //
            // initialize DWORD reading values
            //

            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            //
            // write current registry value
            //

            RegSetValueEx(hDebugKey,DWORD_REGVALUE_DEBUGFLAGS,0,dwType,(LPBYTE)&m_lDebugFlags,dwSize);

            //
            // close registry key
            //

            RegCloseKey(hDebugKey);
        }
    }
}

void CWiadbgcfgDlg::UpdateEditBox()
{
    //
    // format display string, from saved current value
    //

    m_szDebugFlags.Format(TEXT("0x%08X"),m_lDebugFlags);

    //
    // update dialog control, with formatted current value
    //

    UpdateData(FALSE);

    UpdateListBoxSelectionFromEditBox();
}

BOOL CWiadbgcfgDlg::GetSelectedModuleName(TCHAR *szModuleName, DWORD dwSize)
{
    memset(szModuleName,0,dwSize);

    //
    // get current selection index from combo box
    //

    INT iCurSel = m_ModuleSelectionComboBox.GetCurSel();

    //
    // check that we have a selection
    //

    if (iCurSel > -1) {

        //
        // get module name from combo box
        //

        m_ModuleSelectionComboBox.GetLBText(iCurSel, szModuleName);
        return TRUE;
    }
    return FALSE;
}

BOOL CWiadbgcfgDlg::ConstructDebugRegKey(TCHAR *pszDebugRegKey, DWORD dwSize)
{
    memset(pszDebugRegKey,0,dwSize);

    //
    // copy root registry string, adding on "\"
    //

    lstrcpy(pszDebugRegKey,DEBUG_REGKEY_ROOT);
    lstrcat(pszDebugRegKey,TEXT("\\"));

    TCHAR szRegKey[MAX_PATH];
    if (GetSelectedModuleName(szRegKey,sizeof(szRegKey))) {

        //
        // concat module name to end of root registry key, to
        // form new debug key to open
        //

        lstrcat(pszDebugRegKey,szRegKey);

        return TRUE;

    }
    return FALSE;
}

void CWiadbgcfgDlg::OnSelchangeModulesCombobox()
{

    //
    // update the dialog, when the user changes the selected module
    //

    UpdateCurrentValueFromRegistry();
    OnChangeDebugFlagsEditbox();
}

BOOL CWiadbgcfgDlg::BuildFlagDataBaseFromFile()
{
    CFileIO DATA_FILE;
    HRESULT hr = S_OK;
    hr = DATA_FILE.Open(WIADBGCFG_DATAFILE);
    if (FAILED(hr)) {

        //
        // display warning to user..and attempt to generate the default data file
        // with wia service entries
        //

        TCHAR szWarningString[MAX_PATH];
        memset(szWarningString,0,sizeof(szWarningString));
        lstrcpy(szWarningString,WIADBGCFG_DATAFILE);
        lstrcat(szWarningString, TEXT(" could not be found..This Program will generate one for you.\nYou can add custom flags by editing this file."));
        MessageBox(szWarningString,TEXT("Configuration File Warning"),MB_ICONWARNING);

        CreateDefaultDataFile();

        //
        // attempt to reopen data file
        //

        hr = DATA_FILE.Open(WIADBGCFG_DATAFILE);
    }
    if (SUCCEEDED(hr)) {

        //
        // data file is open... count valid entries
        //

        TCHAR szString[MAX_PATH];
        memset(szString,0,sizeof(szString));
        LONG lNumCharactersRead = 0;
        while (DATA_FILE.ReadLine(szString,sizeof(szString),&lNumCharactersRead)) {
            if ((szString[0] == '/') && (szString[1] == '/')) {

                //
                // skip the comment lines
                //

            } else if ((szString[0] == 13)) {

                //
                // skip the empty carriage returns..and line feeds
                //

            } else {
                DWORD dwError = ValidateEntry(szString);
                m_dwNumEntrysInDataBase++;
            }
        }
        DATA_FILE.Close();
    } else {
        MessageBox(TEXT("flags data file could not be opened.."),TEXT("Configuration File Error"),MB_ICONERROR);
        return FALSE;
    }

    //
    // allocate flag data base
    //

    LONG lEntryNumber = 0;
    m_pFlagDataBase = new PREDEFINED_FLAGS[m_dwNumEntrysInDataBase];
    if (m_pFlagDataBase) {
        hr = DATA_FILE.Open(WIADBGCFG_DATAFILE);
    } else {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr)) {
        TCHAR szString[MAX_PATH];
        memset(szString,0,sizeof(szString));
        LONG lNumCharactersRead = 0;
        while (DATA_FILE.ReadLine(szString,sizeof(szString),&lNumCharactersRead)) {
            if ((szString[0] == '/') && (szString[1] == '/')) {

                //
                // skip the comment lines
                //

            } else if ((szString[0] == 13)) {

                //
                // skip the empty carriage returns..and line feeds
                //

            } else {
                DWORD dwError = ValidateEntry(szString);
                ParseEntry(szString,&m_pFlagDataBase[lEntryNumber]);
                lEntryNumber++;
            }
        }
        DATA_FILE.Close();
    } else {
        MessageBox(TEXT("flags data file could not be opened.."),TEXT("Configuration File Error"),MB_ICONERROR);
        return FALSE;
    }
    return TRUE;
}

void CWiadbgcfgDlg::OnClose()
{
    CDialog::OnClose();
}

VOID CWiadbgcfgDlg::AddFlagsToListBox(TCHAR *szModuleName)
{
    m_DefinedDebugFlagsListBox.ResetContent();
    for (DWORD dwindex = 0; dwindex < m_dwNumEntrysInDataBase; dwindex++) {
        if ((lstrcmpi(TEXT("global"),m_pFlagDataBase[dwindex].szModule) == 0) || (lstrcmpi(szModuleName, m_pFlagDataBase[dwindex].szModule) == 0)) {
            TCHAR szListBoxString[MAX_PATH];
            memset(szListBoxString,0,sizeof(szListBoxString));
            lstrcpy(szListBoxString,m_pFlagDataBase[dwindex].szName);
            m_DefinedDebugFlagsListBox.AddString(szListBoxString);
        }
    }
}

VOID CWiadbgcfgDlg::FreeDataBaseMemory()
{
    if (m_pFlagDataBase) {
        delete [] m_pFlagDataBase;
        m_pFlagDataBase = NULL;
    }
}

DWORD CWiadbgcfgDlg::ValidateEntry(TCHAR *szEntry)
{
    DWORD dwError = VALID_ENTRY;

    // VALID_ENTRY
    // MISSING_QUOTE
    // MISSING_FIELD
    // INVALID_FLAG
    // INVALID_NAME
    // INVALID_DESCRIPTION

    return dwError;
}

VOID CWiadbgcfgDlg::CreateDefaultDataFile()
{
    CFileIO DATA_FILE;
    /*
    const DWORD WIAUDBG_ERRORS                = 0x00000001;
    const DWORD WIAUDBG_WARNINGS              = 0x00000002;
    const DWORD WIAUDBG_TRACES                = 0x00000004;
    const DWORD WIAUDBG_FNS                   = 0x00000008;  // Function entry and exit
    const DWORD WIAUDBG_DUMP                  = 0x00000010;  // Dump data
    const DWORD WIAUDBG_PRINT_TIME            = 0x08000000;  // Prints time for each message
    const DWORD WIAUDBG_PRINT_INFO            = 0x10000000;  // Turns on thread, file, line info
    const DWORD WIAUDBG_DONT_LOG_TO_DEBUGGER  = 0x20000000;
    const DWORD WIAUDBG_DONT_LOG_TO_FILE      = 0x40000000;
    const DWORD WIAUDBG_BREAK_ON_ERRORS       = 0x80000000;  // Do DebugBreak on errors
    */
    if (SUCCEEDED(DATA_FILE.Open(WIADBGCFG_DATAFILE,TRUE))) {
        DATA_FILE.WriteLine(TEXT("//"));
        DATA_FILE.WriteLine(TEXT("// Module Name     Flag Description              Flag Value"));
        DATA_FILE.WriteLine(TEXT("//"));
        DATA_FILE.WriteLine(TEXT(""));
        DATA_FILE.WriteLine(TEXT("\"global\", \"Log Errors\",               \"0x00000001\""));
        DATA_FILE.WriteLine(TEXT("\"global\", \"Log Warnings\",             \"0x00000002\""));
        DATA_FILE.WriteLine(TEXT("\"global\", \"Log Traces\",               \"0x00000004\""));
        DATA_FILE.WriteLine(TEXT("\"global\", \"Log Function Entry/Exits\", \"0x00000008\""));
        DATA_FILE.WriteLine(TEXT("\"global\", \"Don't Log to Debugger\",    \"0x20000000\""));
        DATA_FILE.WriteLine(TEXT("\"global\", \"Don't Log To File\",        \"0x40000000\""));
        DATA_FILE.WriteLine(TEXT("\"global\", \"Break on Errors\",          \"0x80000000\""));
        DATA_FILE.WriteLine(TEXT(""));
        DATA_FILE.WriteLine(TEXT(""));
        DATA_FILE.WriteLine(TEXT(""));
        DATA_FILE.WriteLine(TEXT("//"));
        DATA_FILE.WriteLine(TEXT("// Add your custom flags here, follow same format as above."));
        DATA_FILE.WriteLine(TEXT("//"));
        DATA_FILE.WriteLine(TEXT("\"module.dll\", \"Text String Description\",  \" flag value\""));
        DATA_FILE.Close();
    } else {
        MessageBox(TEXT("Default data file could not be created."),TEXT("Configuration File Error"),MB_ICONERROR);
    }
}

VOID CWiadbgcfgDlg::ParseEntry(TCHAR *pszString, PPREDEFINED_FLAGS pFlagInfo)
{
    TCHAR *pch = pszString;
    LONG lLen  = lstrlen(pszString);
    BOOL bModuleName = FALSE;
    BOOL bFlagName   = FALSE;
    BOOL bFlagValue  = FALSE;
    BOOL bFirstQuote = FALSE;
    BOOL bLastQuote  = FALSE;
    LONG lCopyIndex  = 0;
    TCHAR szFlagValue[MAX_PATH];

    memset(szFlagValue,0,sizeof(szFlagValue));
    memset(pFlagInfo,0,sizeof(PREDEFINED_FLAGS));

    for (LONG i = 0; i < lLen; i++) {

        if (!bModuleName) {

            //
            // strip off module name
            //

            if (!bFirstQuote) {
                if (pch[i] == '"') {
                    bFirstQuote = TRUE;
                    lCopyIndex = 0;
                }
            } else {
                if (pch[i] != '"') {
                    pFlagInfo->szModule[lCopyIndex] = pch[i];
                    lCopyIndex++;
                } else {
                    bModuleName = TRUE;
                    bFirstQuote = FALSE;
                }
            }
        } else if (!bFlagName) {

            //
            // strip off flag name
            //

            if (!bFirstQuote) {
                if (pch[i] == '"') {
                    bFirstQuote = TRUE;
                    lCopyIndex = 0;
                }
            } else {
                if (pch[i] != '"') {
                    pFlagInfo->szName[lCopyIndex] = pch[i];
                    lCopyIndex++;
                } else {
                    bFlagName = TRUE;
                    bFirstQuote = FALSE;
                }
            }

        } else if (!bFlagValue) {

            //
            // strip off flag value
            //

            if (!bFirstQuote) {
                if (pch[i] == '"') {
                    bFirstQuote = TRUE;
                    lCopyIndex = 0;
                }
            } else {
                if (pch[i] != '"') {
                    szFlagValue[lCopyIndex] = pch[i];
                    lCopyIndex++;
                } else {
                    bFlagValue = TRUE;
                    bFirstQuote = FALSE;
#ifdef UNICODE
                    swscanf(szFlagValue,TEXT("0x%08X"),&pFlagInfo->dwFlagValue);
#else
                    sscanf(szFlagValue,TEXT("0x%08X"),&pFlagInfo->dwFlagValue);
#endif
                }
            }
        }
    }
}

void CWiadbgcfgDlg::OnChangeDebugFlagsEditbox()
{
    UpdateData(TRUE);

#ifdef UNICODE
    swscanf(m_szDebugFlags,TEXT("0x%08X"),&m_lDebugFlags);
#else
    sscanf(m_szDebugFlags,TEXT("0x%08X"),&m_lDebugFlags);
#endif

    INT iNumItems = 0;
    iNumItems = m_DefinedDebugFlagsListBox.GetCount();
    for(INT i = 0; i < iNumItems; i++){
        m_DefinedDebugFlagsListBox.SetSel(i,FALSE);
    }
    UpdateListBoxSelectionFromEditBox();
    UpdateCurrentValueToRegistry();
}

BOOL CWiadbgcfgDlg::GetDebugFlagFromDataBase(TCHAR *szModuleName, TCHAR *szFlagName, LONG *pFlagValue)
{
    BOOL bFound = FALSE;
    for (DWORD dwindex = 0; dwindex < m_dwNumEntrysInDataBase; dwindex++) {
        if ((lstrcmpi(TEXT("global"),m_pFlagDataBase[dwindex].szModule) == 0) || lstrcmpi(szModuleName, m_pFlagDataBase[dwindex].szModule) == 0) {
            TCHAR szListBoxString[MAX_PATH];
            memset(szListBoxString,0,sizeof(szListBoxString));
            if (lstrcmpi(szFlagName, m_pFlagDataBase[dwindex].szName) == 0) {
                *pFlagValue = m_pFlagDataBase[dwindex].dwFlagValue;
                bFound = TRUE;
                dwindex = m_dwNumEntrysInDataBase;
            }
        }
    }
    return bFound;
}

void CWiadbgcfgDlg::OnSelchangeFlagsList()
{
    TCHAR szModuleName[MAX_PATH];
    if(GetSelectedModuleName(szModuleName,sizeof(szModuleName))){
        TCHAR szListBoxValue[MAX_PATH];
        m_lDebugFlags = 0;
        LONG lListBoxValue = 0;
        int indexArray[100];

        memset(indexArray,0,sizeof(indexArray));
        int iNumItemsSelected = m_DefinedDebugFlagsListBox.GetSelItems(100,indexArray);
        for (int i = 0; i < iNumItemsSelected; i++) {
            memset(szListBoxValue,0,sizeof(szListBoxValue));
            m_DefinedDebugFlagsListBox.GetText(indexArray[i],szListBoxValue);
            if (GetDebugFlagFromDataBase(szModuleName,szListBoxValue,&lListBoxValue)) {
                m_lDebugFlags |= lListBoxValue;
            } else {

            }
        }

        m_szDebugFlags.Format(TEXT("0x%08X"),m_lDebugFlags);

        //
        // update dialog control, with formatted current value
        //

        UpdateData(FALSE);

        UpdateCurrentValueToRegistry();
    }
}

void CWiadbgcfgDlg::UpdateListBoxSelectionFromEditBox()
{
    INT iNumItems = 0;
    iNumItems = m_DefinedDebugFlagsListBox.GetCount();
    if(iNumItems > 0){
        TCHAR szModuleName[MAX_PATH];
        GetSelectedModuleName(szModuleName,sizeof(szModuleName));
        for(INT i = 0; i < iNumItems; i++){
            TCHAR szListBoxString[MAX_PATH];
            memset(szListBoxString,0,sizeof(szListBoxString));
            m_DefinedDebugFlagsListBox.GetText(i,szListBoxString);
            LONG lFlagValue = 0;
            if(GetDebugFlagFromDataBase(szModuleName,szListBoxString,&lFlagValue)){
                if(m_lDebugFlags & lFlagValue){
                    m_DefinedDebugFlagsListBox.SetSel(i);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiadbgcfg\wiadbgcfgdlg.h ===
// wiadbgcfgDlg.h : header file
//

#if !defined(AFX_WIADBGCFGDLG_H__7811AC6A_1268_4534_A8F7_330497C591AA__INCLUDED_)
#define AFX_WIADBGCFGDLG_H__7811AC6A_1268_4534_A8F7_330497C591AA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// flag data base entry struct definition
typedef struct _PREDEFINED_FLAGS {
    TCHAR szModule[MAX_PATH];   // module that owns the user defined flag
    TCHAR szName[MAX_PATH];     // name of the flag...to display in list box
    DWORD dwFlagValue;          // actual flag value
}PREDEFINED_FLAGS,*PPREDEFINED_FLAGS;

#define VALID_ENTRY         0x0000000
#define MISSING_QUOTE       0x0000002
#define MISSING_FIELD       0x0000004
#define INVALID_FLAG        0x1000000
#define INVALID_NAME        0x2000000
#define INVALID_DESCRIPTION 0x4000000

/////////////////////////////////////////////////////////////////////////////
// CWiadbgcfgDlg dialog

class CWiadbgcfgDlg : public CDialog
{
// Construction
public:
    void UpdateListBoxSelectionFromEditBox();

    // data base helpers
    DWORD m_dwNumEntrysInDataBase;
    PPREDEFINED_FLAGS m_pFlagDataBase;
    BOOL BuildFlagDataBaseFromFile();
    VOID CreateDefaultDataFile();
    VOID FreeDataBaseMemory();

    // entry parsing helpers
    BOOL GetDebugFlagFromDataBase(TCHAR *szModuleName, TCHAR *szFlagName, LONG *pFlagValue);
    VOID ParseEntry(TCHAR *pszString, PPREDEFINED_FLAGS pFlagInfo);
    DWORD ValidateEntry(TCHAR *szEntry);

    // user interface helpers
    BOOL AddModulesToComboBox();
    VOID AddFlagsToListBox(TCHAR *szModuleName);
    BOOL ConstructDebugRegKey(TCHAR *pszDebugRegKey, DWORD dwSize);
    BOOL GetSelectedModuleName(TCHAR *szModuleName, DWORD dwSize);
    VOID UpdateCurrentValueFromRegistry();
    VOID UpdateCurrentValueToRegistry();
    VOID UpdateEditBox();

    CWiadbgcfgDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
    //{{AFX_DATA(CWiadbgcfgDlg)
    enum { IDD = IDD_WIADBGCFG_DIALOG };
    CListBox    m_DefinedDebugFlagsListBox;
    CComboBox   m_ModuleSelectionComboBox;
    CString     m_szDebugFlags;
    LONG        m_lDebugFlags;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWiadbgcfgDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CWiadbgcfgDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnSelchangeModulesCombobox();
    afx_msg void OnClose();
    afx_msg void OnChangeDebugFlagsEditbox();
    afx_msg void OnSelchangeFlagsList();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIADBGCFGDLG_H__7811AC6A_1268_4534_A8F7_330497C591AA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\addremove.h ===
#if !defined(AFX_ADDREMOVE_H__9F6CA02B_7D47_4DD2_A5A9_495D0EEA841F__INCLUDED_)
#define AFX_ADDREMOVE_H__9F6CA02B_7D47_4DD2_A5A9_495D0EEA841F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AddRemove.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddRemove dialog

class CAddRemove : public CDialog
{
// Construction
public:
	void GetNewKeyName(TCHAR *pszNewKeyName);
	void SetStatusText(TCHAR *pszStatusText);
	void SetTitle(TCHAR *pszDlgTitle);
	TCHAR m_szTitle[MAX_PATH];
	CAddRemove(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddRemove)
	enum { IDD = IDD_ADD_REMOVE_DIALOG };
	CString	m_NewKeyName;
	CString	m_StatusText;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddRemove)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddRemove)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDREMOVE_H__9F6CA02B_7D47_4DD2_A5A9_495D0EEA841F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\logviewer.cpp ===
// LogViewer.cpp : implementation file
//

#include "stdafx.h"
#include "wialogcfg.h"
#include "LogViewer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static DWORD CALLBACK MyStreamInCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

CProgCtrl::CProgCtrl()
{
    m_pProgressCtrl = NULL;
}

CProgCtrl::~CProgCtrl()
{

}

void CProgCtrl::SetControl(CProgressCtrl *pProgressCtrl)
{
    m_pProgressCtrl = pProgressCtrl;
}

void CProgCtrl::SetupProgressCtrl(PROGCTRL_SETUP_INFO *pSetupInfo)
{
    m_pProgressCtrl->SetStep(pSetupInfo->iStepValue);
    m_pProgressCtrl->SetRange((short)pSetupInfo->iMinRange,(short)pSetupInfo->iMaxRange);
    m_MaxRange = pSetupInfo->iMaxRange;
}

void CProgCtrl::StepIt()
{
    //TCHAR szBuffer[MAX_PATH];
    //sprintf(szBuffer,"Processing %d%",(m_pProgressCtrl->StepIt() * 100) / m_MaxRange);
    //m_pStaticText->SetWindowText(szBuffer);
    //m_pStaticText->Invalidate();

    m_pProgressCtrl->StepIt();
}

void CProgCtrl::DestroyME()
{

}

/////////////////////////////////////////////////////////////////////////////
// CLogViewer dialog


CLogViewer::CLogViewer(CWnd* pParent /*=NULL*/)
    : CDialog(CLogViewer::IDD, pParent)
{
    //{{AFX_DATA_INIT(CLogViewer)
    m_pProgDlg = NULL;
    m_bColorizeLog = FALSE;
    //}}AFX_DATA_INIT
}


void CLogViewer::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogViewer)
    DDX_Control(pDX, IDC_RICHEDIT_LOGVIEWER, m_LogViewer);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLogViewer, CDialog)
    //{{AFX_MSG_MAP(CLogViewer)
    ON_WM_SIZE()
    ON_WM_SHOWWINDOW()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogViewer message handlers

BOOL CLogViewer::OnInitDialog()
{
    CDialog::OnInitDialog();
    m_bKillInitialSelection = TRUE;

    //
    // Set FONT to fixed, for formatting reasons
    //

    HFONT hFixedFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
    if(hFixedFont != NULL)
        m_LogViewer.SendMessage(WM_SETFONT,(WPARAM)hFixedFont,0);

    //
    // Get Windows Directory
    //

    TCHAR szLogFilePath[MAX_PATH];

    DWORD dwLength = 0;
    dwLength = ::GetWindowsDirectory(szLogFilePath,sizeof(szLogFilePath));
    if (( dwLength == 0) || !*szLogFilePath ) {
        OutputDebugString(TEXT("Could not GetWindowsDirectory()"));
        return TRUE;
    }

    //
    // Add log file name to Windows Directory
    //

    lstrcat(lstrcat(szLogFilePath,TEXT("\\")),TEXT("wiaservc.log"));

    // The file from which to load the contents of the rich edit control.
    CFile cFile(szLogFilePath, CFile::shareDenyNone|CFile::modeRead);
    EDITSTREAM es;

    es.dwCookie = (DWORD) (DWORD_PTR)&cFile;
    es.pfnCallback = MyStreamInCallback;
    m_LogViewer.StreamIn(SF_TEXT, es);
    UpdateData(TRUE);

    if(m_bColorizeLog)
        ParseLogToColor();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

static DWORD CALLBACK MyStreamInCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    CFile* pFile = (CFile*) dwCookie;
    *pcb = pFile->Read(pbBuff, cb);
    return 0;
}

void CLogViewer::OnSize(UINT nType, int cx, int cy)
{
    CDialog::OnSize(nType, cx, cy);
    if(m_LogViewer.m_hWnd != NULL) {
        m_LogViewer.MoveWindow(0, 0, cx, cy);
    }
}

void CLogViewer::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CDialog::OnShowWindow(bShow, nStatus);
    if(m_bKillInitialSelection) {
        m_LogViewer.SetSel(0,0);
        m_bKillInitialSelection = FALSE;
    }
}

void CLogViewer::ColorizeText(BOOL bColorize)
{
    m_bColorizeLog = bColorize;
}
void CLogViewer::ColorLine(int LineNumber, COLORREF rgbColor)
{
    int iStartSel = 0;
    int iEndSel   = -1;

    if(LineNumber >0) {
        iStartSel = m_LogViewer.LineIndex(LineNumber);
        iEndSel   = iStartSel + m_LogViewer.LineLength(iStartSel);
    }


    CHARFORMAT cf;
    memset(&cf,0,sizeof(cf));
    cf.cbSize       = sizeof(CHARFORMAT);
    cf.dwMask       = CFM_COLOR | CFM_UNDERLINE | CFM_BOLD;
    cf.dwEffects    =(unsigned long) ~( CFE_AUTOCOLOR | CFE_UNDERLINE | CFE_BOLD);
    cf.crTextColor  = rgbColor;

    m_LogViewer.SetSel(iStartSel,iEndSel);
    m_LogViewer.SetSelectionCharFormat(cf);
}

void CLogViewer::ColorLine(int iStartSel, int iEndSel, COLORREF rgbColor)
{
    CHARFORMAT cf;
    memset(&cf,0,sizeof(cf));
    cf.cbSize       = sizeof(CHARFORMAT);
    cf.dwMask       = CFM_COLOR | CFM_UNDERLINE | CFM_BOLD;
    cf.dwEffects    =(unsigned long) ~( CFE_AUTOCOLOR | CFE_UNDERLINE | CFE_BOLD);
    cf.crTextColor  = rgbColor;

    m_LogViewer.SetSel(iStartSel,iEndSel);
    m_LogViewer.SetSelectionCharFormat(cf);
}

void CLogViewer::ParseLogToColor()
{
    TCHAR szBuffer[MAX_PATH];
    int NumLines = m_LogViewer.GetLineCount();
    int iStartSel = 0;
    int iEndSel = 0;
    BOOL bTrace = FALSE;
    BOOL bError = FALSE;
    BOOL bhResult = FALSE;
    BOOL bWarning = FALSE;

    if(m_pProgDlg != NULL) {

        PROGCTRL_SETUP_INFO SetupInfo;
        SetupInfo.iMinRange = 0;
        SetupInfo.iMaxRange = NumLines;
        SetupInfo.iStepValue = 1;

        m_pProgDlg->SetupProgressCtrl(&SetupInfo);

        for(int LineNumber = 0;LineNumber < NumLines;LineNumber++) {

            m_pProgDlg->StepIt();

            //
            // get line to parse
            //

            int CharactersWritten = m_LogViewer.GetLine(LineNumber,szBuffer,MAX_PATH);
            szBuffer[CharactersWritten] = '\0';

            //
            // Search for TRACE
            //

            if(strstr(szBuffer,TEXT("TRACE"))!= NULL) {
                if(bhResult) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bhResult = FALSE;
                }
                if(bWarning) {
                    ColorLine(iStartSel,iEndSel,RGB(255,127,0));
                    bWarning = FALSE;
                }
                if(bError) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bError = FALSE;
                }

                if(bTrace == FALSE) {
                    bTrace = TRUE;
                }
            }

            //
            // Search for ERROR
            //

            if(strstr(szBuffer,TEXT("ERROR")) != NULL) {
                if(bTrace)
                    bTrace = FALSE;
                if(bhResult) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bhResult = FALSE;
                }
                if(bWarning) {
                    ColorLine(iStartSel,iEndSel,RGB(255,127,0));
                    bWarning = FALSE;
                }
                if(bError == FALSE) {
                    iStartSel = m_LogViewer.LineIndex(LineNumber);
                    bError = TRUE;
                    iEndSel = iStartSel + m_LogViewer.LineLength(iStartSel);
                } else {
                    int itempStartSel = m_LogViewer.LineIndex(LineNumber);
                    iEndSel = itempStartSel + m_LogViewer.LineLength(itempStartSel);
                }
            }

            //
            // Search for HRESULT
            //

            if(strstr(szBuffer,TEXT("HRESULT")) != NULL) {
                if(bTrace)
                    bTrace = FALSE;
                if(bError) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bError = FALSE;
                }
                if(bWarning) {
                    ColorLine(iStartSel,iEndSel,RGB(255,127,0));
                    bWarning = FALSE;
                }
                if(bhResult == FALSE) {
                    iStartSel = m_LogViewer.LineIndex(LineNumber);
                    bhResult = TRUE;
                    iEndSel = iStartSel + m_LogViewer.LineLength(iStartSel);
                } else {
                    int itempStartSel = m_LogViewer.LineIndex(LineNumber);
                    iEndSel = itempStartSel + m_LogViewer.LineLength(itempStartSel);
                }
            }

            //
            // Search for WARNING
            //

            if(strstr(szBuffer,TEXT("WARNING")) != NULL) {
                if(bTrace)
                    bTrace = FALSE;
                if(bError) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bError = FALSE;
                }
                if(bhResult) {
                    ColorLine(iStartSel,iEndSel,RGB(255,0,0));
                    bhResult = FALSE;
                }
                if(bWarning == FALSE) {
                    iStartSel = m_LogViewer.LineIndex(LineNumber);
                    bWarning = TRUE;
                    iEndSel = iStartSel + m_LogViewer.LineLength(iStartSel);
                } else {
                    int itempStartSel = m_LogViewer.LineIndex(LineNumber);
                    iEndSel = itempStartSel + m_LogViewer.LineLength(itempStartSel);
                }
            }

            //
            // Column separators
            //

            if(strstr(szBuffer,TEXT("=====")) != NULL){
                ColorLine(LineNumber,RGB(0,0,255));
                ColorLine(LineNumber+1,RGB(0,0,255));
                ColorLine(LineNumber+2,RGB(0,0,255));
                LineNumber+=3;
            }
    }

    if(bError)
        ColorLine(iStartSel,iEndSel,RGB(255,0,0));
    else if (bhResult)
        ColorLine(iStartSel,iEndSel,RGB(255,0,0));
    else if (bWarning)
        ColorLine(iStartSel,iEndSel,RGB(255,110,0));

    m_pProgDlg->DestroyME();
    }
}

void CLogViewer::SetProgressCtrl(CProgCtrl *pProgCtrl)
{
    m_pProgDlg = pProgCtrl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\logviewer.h ===
#if !defined(AFX_LOGVIEWER_H__4F84A510_9B65_4A6D_A02D_7493977E56B7__INCLUDED_)
#define AFX_LOGVIEWER_H__4F84A510_9B65_4A6D_A02D_7493977E56B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogViewer.h : header file
//

typedef struct _PROGCTRL_SETUP_INFO {	
	int iMaxRange;
	int iMinRange;
	int iStepValue;
}PROGCTRL_SETUP_INFO;

class CProgCtrl
{
public:
	CProgCtrl();
	~CProgCtrl();
	void SetControl(CProgressCtrl *pProgressCtrl);
	void SetupProgressCtrl(PROGCTRL_SETUP_INFO *pSetupInfo);
	void StepIt();
	void DestroyME();
	int m_MaxRange;
	BOOL bCancel;
private:
	 CProgressCtrl *m_pProgressCtrl;
	 CStatic  *m_pStaticText;
};

/////////////////////////////////////////////////////////////////////////////
// CLogViewer dialog

class CLogViewer : public CDialog
{
// Construction
public:
	void ColorizeText(BOOL bColorize);
	CProgCtrl *m_pProgDlg;
	void SetProgressCtrl(CProgCtrl *pProgCtrl);
	void ParseLogToColor();
	void ColorLine(int LineNumber, COLORREF rgbColor);
	void ColorLine(int iStartSel, int iEndSel, COLORREF rgbColor);
	BOOL m_bKillInitialSelection;
	BOOL m_bColorizeLog;
	CLogViewer(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLogViewer)
	enum { IDD = IDD_VIEW_LOG_DIALOG };
	CRichEditCtrl	m_LogViewer;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogViewer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support	
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLogViewer)
	virtual BOOL OnInitDialog();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGVIEWER_H__4F84A510_9B65_4A6D_A02D_7493977E56B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\registry.cpp ===
//
// Registry.cpp
//

#include "stdafx.h"
#include "Registry.h"

CRegistry::CRegistry()
{
	m_hkey = NULL;
    bhkeyValid = FALSE;
}

CRegistry::~CRegistry()
{
	Close();
}

CRegistry::CRegistry(const TCHAR *pszSubKey, HKEY hkey)
{
	m_hkey = NULL;
    bhkeyValid = FALSE;
    Open(pszSubKey, hkey);
}

BOOL CRegistry::Open(const TCHAR *pszSubKey, HKEY hkey)
{
	Close();
    m_error = RegCreateKey(hkey, pszSubKey, &m_hkey);
    if (m_error)
        bhkeyValid = FALSE;    
    else
        bhkeyValid = TRUE;
    return bhkeyValid;
}

BOOL CRegistry::Close()
{
    if (bhkeyValid)
        RegCloseKey(m_hkey);
    m_hkey = NULL;
    bhkeyValid = FALSE;
    return TRUE;
}

BOOL CRegistry::CreateKey(const TCHAR *pszSubKey)
{
	HKEY hKey;
	m_error = RegCreateKey(m_hkey, pszSubKey, &hKey);
	if(m_error)
		return FALSE;
	return TRUE;
}

BOOL CRegistry::DeleteKey(const TCHAR *pszSubKey)
{
	m_error = RegDeleteKey(m_hkey,pszSubKey);
	if(m_error)
		return FALSE;
	else
		return TRUE;
}

LONG CRegistry::SetValue(const TCHAR *pszValue, DWORD dwNumber)
{
    if (bhkeyValid) {
        m_error = RegSetValueEx(m_hkey,
			                    pszValue,
								0,
								REG_DWORD,
								(BYTE *)&dwNumber,
								sizeof(dwNumber));
    }
    return m_error;
}

LONG CRegistry::GetValue(const TCHAR *pszValue, DWORD dwDefault)
{
	DWORD   dwType = REG_DWORD;
    long    dwNumber = 0L;
    DWORD   dwSize = sizeof(dwNumber);
	
    if (bhkeyValid) {
        m_error = RegQueryValueEx(m_hkey,
			                     (LPTSTR) pszValue,
								  0,
								  &dwType,
								  (LPBYTE)&dwNumber,
								  &dwSize);
    }
    if (m_error)
        dwNumber = dwDefault;	
    return dwNumber;
}

VOID CRegistry::MoveToSubKey(const TCHAR *pszSubKeyName)
{
    HKEY _hNewKey;
    if (bhkeyValid) {
        m_error = RegOpenKey ( m_hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (m_error == ERROR_SUCCESS) {
            RegCloseKey(m_hkey);
            m_hkey = _hNewKey;
        }
    }
}

LONG CRegistry::EnumerateKeys(DWORD dwIndex,TCHAR *pszKeyName, DWORD dwSize)
{
	FILETIME ft;
	LONG lError = 0;
	memset(pszKeyName,0,sizeof(pszKeyName));

	lError =  RegEnumKeyEx(m_hkey,       // handle to key to enumerate
					    dwIndex,      // index of subkey to enumerate
					    pszKeyName,   // address of buffer for subkey name
					    &dwSize,      // address for size of subkey buffer
					    NULL,         // reserved
					    NULL,         // address of buffer for class string
					    NULL,         // address for size of class buffer
					    &ft           // address for time key last written to
		);

	return lError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\registry.h ===
#ifndef REGISTRY_H
#define REGISRTY_H

#if _MSC_VER > 1000
#pragma once
#endif

#include "resource.h"

class CRegistry
{
    public:
        CRegistry();
        CRegistry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~CRegistry();
        BOOL Open(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
		BOOL CreateKey(const TCHAR *pszSubKey);
		BOOL DeleteKey(const TCHAR *pszSubKey);
        BOOL Close();
        
        LONG SetValue(const TCHAR *pszValue, DWORD dwNumber);
        LONG GetValue(const TCHAR *pszValue,DWORD dwDefault);
        VOID MoveToSubKey(const TCHAR *pszSubKeyName);
        
        HKEY GetKey()      { return m_hkey;    };
        BOOL IsValid()     { return bhkeyValid;};
		LONG GetError()    { return m_error;   };
		VOID ClearErrors() { m_error = 0;      };
		LONG EnumerateKeys(DWORD dwIndex,TCHAR *pszKeyName, DWORD dwSize);
    private:
        HKEY m_hkey;
        long m_error;
        BOOL bhkeyValid;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WiaLogCFG.rc
//
#define REGSTR_PATH_STICONTROL          1
#define REGSTR_VAL_LOG_LEVEL            2
#define REGSTR_VAL_MODE                 3
#define REGSTR_VAL_MAXSIZE              4
#define REGSTR_VAL_TRUNCATE_ON_BOOT     5
#define REGSTR_VAL_DETAIL               6
#define REGSTR_VAL_LOGGING              7
#define REGSTR_VAL_CLEARLOG_ON_BOOT     8
#define REGSTR_VAL_LOG_TO_DEBUGGER      9
#define IDD_WIALOGCFG_DIALOG            102
#define IDR_MAINFRAME                   128
#define IDD_ADD_REMOVE_DIALOG           129
#define IDD_VIEW_LOG_DIALOG             130
#define IDD_PARSE_PROGRESS_DIALOG       131
#define IDC_LOG_LEVEL_TRACE             1000
#define IDC_LOG_LEVEL_WARNING           1001
#define IDC_LOG_LEVEL_ERROR             1002
#define IDC_FILTER_OFF                  1004
#define IDC_FILTER_1                    1005
#define IDC_FILTER_2                    1006
#define IDC_FILTER_3                    1007
#define IDC_FILTER_CUSTOM               1008
#define IDC_EDIT_CUSTOM_LEVEL           1009
#define IDC_ADD_TIME                    1010
#define IDC_ADD_MODULENAME              1011
#define IDC_ADD_THREADID                1012
#define IDC_SELECT_MODULE_COMBOBOX      1013
#define IDC_ADD_MODULE_BUTTON           1014
#define IDC_DELETE_MODULE_BUTTON        1015
#define IDC_TRUNCATE_ON_BOOT            1016
#define IDC_WRITE_SETTINGS_BUTTON       1018
#define IDC_EDIT_KEYNAME                1019
#define IDC_STATUS_TEXT                 1020
#define IDC_CLEARLOG_BUTTON             1021
#define IDC_VIEW_LOG_BUTTON             1023
#define IDC_RICHEDIT_LOGVIEWER          1024
#define IDC_PROGRESS1                   1025
#define IDC_PARSE_PROGRESS              1025
#define IDC_CANCEL_PARSING_BUTTON       1026
#define IDC_PARSE_TEXT_STATUS           1027
#define IDC_CLEARLOG_ON_BOOT            1028
#define IDC_LOG_TO_DEBUGGER             1030
#define IDC_COLOR_CODE_LOGVIEWER_TEXT   1031

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1F9A0657_96C6_4152_936F_107C2C80F540__INCLUDED_)
#define AFX_STDAFX_H__1F9A0657_96C6_4152_936F_107C2C80F540__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F9A0657_96C6_4152_936F_107C2C80F540__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wialogcfg
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\wialogcfg.cpp        \
        ..\wialogcfgdlg.cpp     \
        ..\registry.cpp         \
        ..\logviewer.cpp        \
        ..\addremove.cpp        \
        ..\wialogcfg.rc


# Add interlac.cpp if the PNG support is ever fixed

MISCFILES = ..\wialogcfg.htm

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WiaLogCFG.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\wialogcfg.cpp ===
// WiaLogCFG.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "WiaLogCFG.h"
#include "WiaLogCFGDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp

BEGIN_MESSAGE_MAP(CWiaLogCFGApp, CWinApp)
    //{{AFX_MSG_MAP(CWiaLogCFGApp)
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp construction

CWiaLogCFGApp::CWiaLogCFGApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWiaLogCFGApp object

CWiaLogCFGApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp initialization

BOOL CWiaLogCFGApp::InitInstance()
{
    AfxInitRichEdit();
    // Standard initialization

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    CWiaLogCFGDlg dlg;
    m_pMainWnd = &dlg;
    dlg.DoModal();

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\wialogcfg.h ===
// WiaLogCFG.h : main header file for the WIALOGCFG application
//

#if !defined(AFX_WIALOGCFG_H__57F2BBE2_5F4E_42E4_B468_7DE49BBA22B7__INCLUDED_)
#define AFX_WIALOGCFG_H__57F2BBE2_5F4E_42E4_B468_7DE49BBA22B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGApp:
// See WiaLogCFG.cpp for the implementation of this class
//

class CWiaLogCFGApp : public CWinApp
{
public:
	CWiaLogCFGApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaLogCFGApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWiaLogCFGApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIALOGCFG_H__57F2BBE2_5F4E_42E4_B468_7DE49BBA22B7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\clistbox.h ===
#ifndef _CLISTBOX
#define _CLISTBOX

class CListBoxUtil {
public:
    CListBoxUtil(HWND hListBox);
    ~CListBoxUtil();
    
    // helper functions
    void ResetContent();
    void AddStringAndData(LPTSTR szString, void* pData);    
    int  GetCurSelTextAndData(LPTSTR szString, void** pData);
    void SetCurSel(int NewCurSel);
    int  GetCount();
private:
    HWND m_hWnd;
protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\clistbox.cpp ===
#include "stdafx.h"
#include "clistbox.h"

CListBoxUtil::CListBoxUtil(HWND hListBox)
{
    m_hWnd = hListBox;
}

CListBoxUtil::~CListBoxUtil()
{

}

void CListBoxUtil::ResetContent()
{
    SendMessage(m_hWnd,LB_RESETCONTENT,(WPARAM)0,(LPARAM)0);
}

void CListBoxUtil::AddStringAndData(LPTSTR szString, void* pData)
{
    int InsertIndex = (int)SendMessage(m_hWnd,LB_ADDSTRING,(WPARAM)0,(LPARAM)szString);
    SendMessage(m_hWnd,LB_SETITEMDATA,(WPARAM)InsertIndex,(LPARAM)pData);
}

int CListBoxUtil::GetCurSelTextAndData(LPTSTR szString, void** pData)
{
    int CurSel = 0;
    *pData  = NULL;

    //
    // get current selected index
    //

    CurSel = (int)SendMessage(m_hWnd,LB_GETCURSEL,(WPARAM)0,(LPARAM)0);

    //
    // get string at that index, if one is selected
    //

    if(CurSel > -1) {
        SendMessage(m_hWnd,LB_GETTEXT,(WPARAM)CurSel,(LPARAM)szString);
        *pData = (void*)SendMessage(m_hWnd,LB_GETITEMDATA,(WPARAM)CurSel,(LPARAM)0);
    }

    return CurSel;
}

void CListBoxUtil::SetCurSel(int NewCurSel)
{
    SendMessage(m_hWnd,LB_SETCURSEL,(WPARAM)NewCurSel,(LPARAM)0);
}

int CListBoxUtil::GetCount()
{
    return (int)SendMessage(m_hWnd,LB_GETCOUNT,(WPARAM)0,(LPARAM)0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\wialogcfgdlg.cpp ===
// WiaLogCFGDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WiaLogCFG.h"
#include "WiaLogCFGDlg.h"
#include "AddRemove.h"
#include "LogViewer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGDlg dialog

CWiaLogCFGDlg::CWiaLogCFGDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CWiaLogCFGDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CWiaLogCFGDlg)
    m_dwCustomLevel = 0;
    //}}AFX_DATA_INIT
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_bColorCodeLogViewerText = FALSE;
}

void CWiaLogCFGDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiaLogCFGDlg)
	DDX_Control(pDX, IDC_COLOR_CODE_LOGVIEWER_TEXT, m_ColorCodeLogViewerTextCheckBox);
	DDX_Control(pDX, IDC_LOG_TO_DEBUGGER, m_LogToDebuggerCheckBox);
	DDX_Control(pDX, IDC_CLEARLOG_ON_BOOT, m_ClearLogOnBootCheckBox);
	DDX_Control(pDX, IDC_PARSE_PROGRESS, m_ProgressCtrl);
    DDX_Control(pDX, IDC_ADD_TIME, m_AddTimeCheckBox);
    DDX_Control(pDX, IDC_ADD_THREADID, m_AddThreadIDCheckBox);
    DDX_Control(pDX, IDC_ADD_MODULENAME, m_AddModuleCheckBox);
    DDX_Control(pDX, IDC_TRUNCATE_ON_BOOT, m_TruncateOnBootCheckBox);
    DDX_Control(pDX, IDC_SELECT_MODULE_COMBOBOX, m_ModuleComboBox);
    DDX_Control(pDX, IDC_LOG_LEVEL_WARNING, m_WarningCheckBox);
    DDX_Control(pDX, IDC_LOG_LEVEL_ERROR, m_ErrorCheckBox);
    DDX_Control(pDX, IDC_LOG_LEVEL_TRACE, m_TraceCheckBox);
    DDX_Control(pDX, IDC_FILTER_OFF, m_FilterOff);
    DDX_Control(pDX, IDC_FILTER_1, m_Filter1);
    DDX_Control(pDX, IDC_FILTER_2, m_Filter2);
    DDX_Control(pDX, IDC_FILTER_3, m_Filter3);
    DDX_Control(pDX, IDC_FILTER_CUSTOM, m_FilterCustom);
    DDX_Text(pDX, IDC_EDIT_CUSTOM_LEVEL, m_dwCustomLevel);
    DDV_MinMaxDWord(pDX, m_dwCustomLevel, 0, 9999);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWiaLogCFGDlg, CDialog)
    //{{AFX_MSG_MAP(CWiaLogCFGDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_ADD_MODULE_BUTTON, OnAddModuleButton)
    ON_BN_CLICKED(IDC_DELETE_MODULE_BUTTON, OnDeleteModuleButton)
    ON_BN_CLICKED(IDC_WRITE_SETTINGS_BUTTON, OnWriteSettingsButton)
    ON_CBN_SELCHANGE(IDC_SELECT_MODULE_COMBOBOX, OnSelchangeSelectModuleCombobox)
	ON_BN_CLICKED(IDC_CLEARLOG_BUTTON, OnClearlogButton)
	ON_BN_CLICKED(IDC_VIEW_LOG_BUTTON, OnViewLogButton)
	ON_CBN_SETFOCUS(IDC_SELECT_MODULE_COMBOBOX, OnSetfocusSelectModuleCombobox)
	ON_CBN_DROPDOWN(IDC_SELECT_MODULE_COMBOBOX, OnDropdownSelectModuleCombobox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGDlg message handlers

BOOL CWiaLogCFGDlg::OnInitDialog()
{
    m_hInstance = NULL;
    m_hInstance = AfxGetInstanceHandle();
    CDialog::OnInitDialog();
	
	ShowProgress(FALSE);
	
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon
    
    m_LogInfo.dwLevel          = 0;
    m_LogInfo.dwMaxSize        = 100000;
    m_LogInfo.dwMode           = 0;
    m_LogInfo.dwTruncateOnBoot = 0;
    memset(m_LogInfo.szKeyName,0,sizeof(m_LogInfo.szKeyName));

    m_CurrentSelection = 0;
    
    InitializeDialogSettings(SETTINGS_RESET_DIALOG);
    RegistryOperation(REG_READ);
    InitializeDialogSettings(SETTINGS_TO_DIALOG);

	CheckGlobalServiceSettings();

    return TRUE;  // return TRUE  unless you set the focus to a control
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWiaLogCFGDlg::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

HCURSOR CWiaLogCFGDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CWiaLogCFGDlg::OnAddModuleButton() 
{
	CAddRemove AddRemoveDlg;
	AddRemoveDlg.SetTitle(TEXT("Add a Module"));
	AddRemoveDlg.SetStatusText(TEXT("Enter a Module Name:"));
	if(AddRemoveDlg.DoModal() == IDOK) {
		m_TruncateOnBootCheckBox.SetCheck(0);
		m_ClearLogOnBootCheckBox.SetCheck(0);
		AddRemoveDlg.GetNewKeyName(m_LogInfo.szKeyName);
		RegistryOperation(REG_ADD_KEY);		
		RegistryOperation(REG_READ);
		CheckGlobalServiceSettings();
	}
}

void CWiaLogCFGDlg::OnDeleteModuleButton() 
{
	if(MessageBox(TEXT("Are you sure you want to DELETE this module?"),
		          TEXT("Delete Module"),
				  MB_YESNO|MB_ICONQUESTION) == IDYES) {

		//
		// Delete this module
		//
		
		RegistryOperation(REG_DELETE_KEY);
		RegistryOperation(REG_READ);
	}
}

void CWiaLogCFGDlg::RegistryOperation(ULONG ulFlags)
{   
    TCHAR szAppRegistryKey[MAX_PATH];
    TCHAR szValueName[MAX_PATH];
        
    LoadString(m_hInstance, REGSTR_PATH_STICONTROL, szAppRegistryKey, MAX_PATH);
    CRegistry Registry(szAppRegistryKey,HKEY_LOCAL_MACHINE);

    //
    // move to logging
    //

    LoadString(m_hInstance,REGSTR_VAL_LOGGING , szValueName, MAX_PATH);
    Registry.MoveToSubKey(szValueName);

	if(ulFlags == REG_ADD_KEY) {

		//
		// Add a new key
		//

		Registry.CreateKey(m_LogInfo.szKeyName);
		
		//
		// change current selection to an invalid selection
		//

		m_CurrentSelection = -99;
		return;
	}
	
	if( ulFlags == REG_DELETE_KEY) {

		//
		// delete a Key
		//

		Registry.DeleteKey(m_LogInfo.szKeyName);
		return;
	}

    //
    // enumerate keys
    //

    DWORD dwIndex = 0;
    TCHAR pszKeyName[64];

    m_ModuleComboBox.ResetContent();
    
    while(Registry.EnumerateKeys(dwIndex++,pszKeyName, sizeof(pszKeyName)) != ERROR_NO_MORE_ITEMS) {
        m_ModuleComboBox.AddString(pszKeyName); 
    }
    
	if(m_CurrentSelection == -99){
		INT nIndex = m_ModuleComboBox.FindString(-1, m_LogInfo.szKeyName);
		m_CurrentSelection = nIndex;
		m_ModuleComboBox.SetCurSel(nIndex);

	} else {		
		m_ModuleComboBox.GetLBText(m_CurrentSelection,m_LogInfo.szKeyName);
	}

    m_ModuleComboBox.SetCurSel(m_CurrentSelection);
    
	//
    // move to DLL specifc subkey
    //

    Registry.MoveToSubKey(m_LogInfo.szKeyName);    

    switch(ulFlags) {
    case REG_WRITE:        
        LoadString(m_hInstance,REGSTR_VAL_LOG_LEVEL , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwLevel);
        
        LoadString(m_hInstance,REGSTR_VAL_MODE , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwMode);
        
        LoadString(m_hInstance,REGSTR_VAL_MAXSIZE , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwMaxSize);
        
        LoadString(m_hInstance,REGSTR_VAL_TRUNCATE_ON_BOOT , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwTruncateOnBoot);

		LoadString(m_hInstance,REGSTR_VAL_CLEARLOG_ON_BOOT , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwClearLogOnBoot);

        LoadString(m_hInstance,REGSTR_VAL_DETAIL , szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwDetail);

		LoadString(m_hInstance,REGSTR_VAL_LOG_TO_DEBUGGER, szValueName, MAX_PATH);
        Registry.SetValue(szValueName,m_LogInfo.dwLogToDebugger);
		
        break;    
	case REG_READ:
    default:        
        LoadString(m_hInstance,REGSTR_VAL_LOG_LEVEL , szValueName, MAX_PATH);
        m_LogInfo.dwLevel = Registry.GetValue(szValueName,WIALOG_NO_LEVEL);
        
        LoadString(m_hInstance,REGSTR_VAL_MODE , szValueName, MAX_PATH);
        m_LogInfo.dwMode = Registry.GetValue(szValueName,WIALOG_ADD_MODULE|WIALOG_ADD_THREAD);
        
        LoadString(m_hInstance,REGSTR_VAL_MAXSIZE , szValueName, MAX_PATH);
        m_LogInfo.dwMaxSize = Registry.GetValue(szValueName,100000);
        
        LoadString(m_hInstance,REGSTR_VAL_TRUNCATE_ON_BOOT, szValueName, MAX_PATH);
        m_LogInfo.dwTruncateOnBoot = Registry.GetValue(szValueName,0);

		LoadString(m_hInstance,REGSTR_VAL_CLEARLOG_ON_BOOT, szValueName, MAX_PATH);
        m_LogInfo.dwClearLogOnBoot = Registry.GetValue(szValueName,0);
		
        LoadString(m_hInstance,REGSTR_VAL_DETAIL , szValueName, MAX_PATH);
        m_LogInfo.dwDetail = Registry.GetValue(szValueName,0);

		LoadString(m_hInstance,REGSTR_VAL_LOG_TO_DEBUGGER, szValueName, MAX_PATH);
		m_LogInfo.dwLogToDebugger = Registry.GetValue(szValueName,0);

        break;
    }
}

void CWiaLogCFGDlg::InitializeDialogSettings(ULONG ulFlags)
{
    switch (ulFlags) {
    case SETTINGS_TO_DIALOG:

        //
        // set level of detail
        //

        switch (m_LogInfo.dwDetail) {
        case WIALOG_NO_LEVEL:
            m_FilterOff.SetCheck(1);
            break;
        case WIALOG_LEVEL1 :
            m_Filter1.SetCheck(1);
            break;
        case WIALOG_LEVEL2:
            m_Filter2.SetCheck(1);
            break;
        case WIALOG_LEVEL3:
            m_Filter3.SetCheck(1);
            break;      
        default:
            m_FilterCustom.SetCheck(1);
            m_dwCustomLevel = m_LogInfo.dwDetail;
            UpdateData(FALSE);          
            break;
        }

        //
        // set truncate on boot check box
        //

        if (m_LogInfo.dwTruncateOnBoot != 0)
            m_TruncateOnBootCheckBox.SetCheck(1);
        else
            m_TruncateOnBootCheckBox.SetCheck(0);

		//
        // set clear log on boot check box
        //

        if (m_LogInfo.dwClearLogOnBoot != 0)
            m_ClearLogOnBootCheckBox.SetCheck(1);
        else
            m_ClearLogOnBootCheckBox.SetCheck(0);

		//
		// set log to debugger check box
		//

		if (m_LogInfo.dwLogToDebugger != 0)
            m_LogToDebuggerCheckBox.SetCheck(1);
        else
            m_LogToDebuggerCheckBox.SetCheck(0);



        //
        // set trace level check boxes
        //

        if (m_LogInfo.dwLevel & WIALOG_TRACE)
            m_TraceCheckBox.SetCheck(1);
        if (m_LogInfo.dwLevel & WIALOG_ERROR)
            m_ErrorCheckBox.SetCheck(1);
        if (m_LogInfo.dwLevel & WIALOG_WARNING)
            m_WarningCheckBox.SetCheck(1);

        //
        // set additional details check boxes
        //

        if (m_LogInfo.dwMode & WIALOG_ADD_TIME)
            m_AddTimeCheckBox.SetCheck(1);
        if (m_LogInfo.dwMode & WIALOG_ADD_MODULE)
            m_AddModuleCheckBox.SetCheck(1);
        if (m_LogInfo.dwMode & WIALOG_ADD_THREAD)
            m_AddThreadIDCheckBox.SetCheck(1);
    break;
    case SETTINGS_FROM_DIALOG:

        //
        // get level of detail
        //

        if (m_FilterOff.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_NO_LEVEL;
        if (m_Filter1.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_LEVEL1;
        if (m_Filter2.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_LEVEL2;
        if (m_Filter3.GetCheck() == 1)
            m_LogInfo.dwDetail = WIALOG_LEVEL3;
        if (m_FilterCustom.GetCheck() == 1) {
            UpdateData(TRUE);
            m_LogInfo.dwDetail = m_dwCustomLevel;
        }

        //
        // get truncate on boot check box
        //

        if (m_TruncateOnBootCheckBox.GetCheck() == 1)
            m_LogInfo.dwTruncateOnBoot = 1;
        else
            m_LogInfo.dwTruncateOnBoot = 0;

		//
        // get clear log on boot check box
        //

        if (m_ClearLogOnBootCheckBox.GetCheck() == 1)
            m_LogInfo.dwClearLogOnBoot = 1;
        else
            m_LogInfo.dwClearLogOnBoot = 0;

        
		//
		// get log to debugger check box
		//

		if(m_LogToDebuggerCheckBox.GetCheck() == 1)
			m_LogInfo.dwLogToDebugger = 1;
		else
			m_LogInfo.dwLogToDebugger = 0;


		//
        // get trace level check boxes
        //

        m_LogInfo.dwLevel = 0;

        if (m_TraceCheckBox.GetCheck() == 1)
            m_LogInfo.dwLevel = m_LogInfo.dwLevel | WIALOG_TRACE;
        if (m_ErrorCheckBox.GetCheck() == 1)
            m_LogInfo.dwLevel = m_LogInfo.dwLevel | WIALOG_ERROR;
        if (m_WarningCheckBox.GetCheck() == 1)
            m_LogInfo.dwLevel = m_LogInfo.dwLevel | WIALOG_WARNING;

        //
        // set additional details check boxes
        //

		m_LogInfo.dwMode = 0;

        if (m_AddTimeCheckBox.GetCheck() == 1)
            m_LogInfo.dwMode = m_LogInfo.dwMode | WIALOG_ADD_TIME;
        if (m_AddModuleCheckBox.GetCheck() == 1)
            m_LogInfo.dwMode = m_LogInfo.dwMode | WIALOG_ADD_MODULE;
        if (m_AddThreadIDCheckBox.GetCheck() == 1)
            m_LogInfo.dwMode = m_LogInfo.dwMode | WIALOG_ADD_THREAD;
    break;
    default:        
        m_FilterOff.SetCheck(0);                
        m_Filter1.SetCheck(0);              
        m_Filter2.SetCheck(0);              
        m_Filter3.SetCheck(0);          
        m_FilterCustom.SetCheck(0);                         
        m_TruncateOnBootCheckBox.SetCheck(0);       
        m_TraceCheckBox.SetCheck(0);        
        m_ErrorCheckBox.SetCheck(0);        
        m_WarningCheckBox.SetCheck(0);              
        m_AddTimeCheckBox.SetCheck(0);
        m_AddModuleCheckBox.SetCheck(0);
        m_AddThreadIDCheckBox.SetCheck(0);
		m_dwCustomLevel = 0;
		UpdateData(FALSE);
    break;
    }
}

void CWiaLogCFGDlg::OnOK() 
{   
    InitializeDialogSettings(SETTINGS_FROM_DIALOG);
    RegistryOperation(REG_WRITE);
    CDialog::OnOK();
}

void CWiaLogCFGDlg::OnWriteSettingsButton() 
{
    InitializeDialogSettings(SETTINGS_FROM_DIALOG);
    RegistryOperation(REG_WRITE);
}

void CWiaLogCFGDlg::OnSelchangeSelectModuleCombobox() 
{
    m_CurrentSelection = m_ModuleComboBox.GetCurSel();
    if(m_CurrentSelection < 0)
        return;
    
	CheckGlobalServiceSettings();

    InitializeDialogSettings(SETTINGS_RESET_DIALOG);    
    RegistryOperation(REG_READ);
    InitializeDialogSettings(SETTINGS_TO_DIALOG);   
}

void CWiaLogCFGDlg::OnClearlogButton() 
{
	//
    // Get Windows Directory
    //
	
	TCHAR szLogFilePath[MAX_PATH];

	DWORD dwLength = 0;
    dwLength = ::GetWindowsDirectory(szLogFilePath,sizeof(szLogFilePath));
    if (( dwLength == 0) || !*szLogFilePath ) {
        OutputDebugString(TEXT("Could not GetWindowsDirectory()"));
        return;
    }

    //
    // Add log file name to Windows Directory
    //

    lstrcat(lstrcat(szLogFilePath,TEXT("\\")),TEXT("wiaservc.log"));

    //
    // Create / open Log file
    //


    HANDLE hLogFile = ::CreateFile(szLogFilePath,
                              GENERIC_WRITE,
                              FILE_SHARE_WRITE | FILE_SHARE_READ,
                              NULL,       // security attributes
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);      // template file handle

    if(hLogFile != NULL)
		CloseHandle(hLogFile);
}

void CWiaLogCFGDlg::OnViewLogButton() 
{
	CLogViewer LogViewer;
	
	if (m_ColorCodeLogViewerTextCheckBox.GetCheck() == 1)
            m_bColorCodeLogViewerText = TRUE;
        else
            m_bColorCodeLogViewerText = FALSE;
	
	LogViewer.ColorizeText(m_bColorCodeLogViewerText);
	
	//
	// initialize progress
	//
	
	m_ProgCtrl.SetControl(&m_ProgressCtrl);

	LogViewer.SetProgressCtrl(&m_ProgCtrl);
	ShowProgress(TRUE);	
	LogViewer.DoModal();
	ShowProgress(FALSE);	
}

void CWiaLogCFGDlg::ShowProgress(BOOL bShow)
{
	if(bShow) {
		m_ProgressCtrl.ShowWindow(SW_SHOW);
	} else {
		m_ProgressCtrl.ShowWindow(SW_HIDE);
	}
	
}

void CWiaLogCFGDlg::OnSetfocusSelectModuleCombobox() 
{
	OnWriteSettingsButton();
}

void CWiaLogCFGDlg::OnDropdownSelectModuleCombobox() 
{
	OnWriteSettingsButton();	
}

void CWiaLogCFGDlg::CheckGlobalServiceSettings()
{
	TCHAR szKeyName[MAX_PATH];
	m_ModuleComboBox.GetLBText(m_CurrentSelection,szKeyName);
	if(lstrcmp(szKeyName,TEXT("WIASERVC")) == 0) {
		m_TruncateOnBootCheckBox.EnableWindow(TRUE);
		m_ClearLogOnBootCheckBox.EnableWindow(TRUE);
	} else {
		m_TruncateOnBootCheckBox.EnableWindow(FALSE);
		m_ClearLogOnBootCheckBox.EnableWindow(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\msgwrap.h ===
#ifndef _MSGWRAPPER_H
#define _MSGWRAPPER_H

class CMessageWrapper {
public:
	CMessageWrapper();
	~CMessageWrapper();

	VOID Initialize(HINSTANCE hInstance);
	
	BOOL OnInitDialog(HWND hDlg);
	BOOL OnAbout(HWND hDlg);
	BOOL OnExit(HWND hDlg, WPARAM wParam);
    BOOL OnBrowse(HWND hDlg, LPTSTR szApplicationFilePath);
    BOOL Register(HWND hDlg, long lFlags);
    BOOL OnRefreshDeviceListBox(HWND hDlg);
	LPTSTR GetResourceString(INT ResourceID, LPTSTR szString, INT isize = 255);
    VOID EnableAllControls(HWND hDlg, bool bEnable);
private:
	VOID DisplayError(INT ErrorCode);	
protected:
	HINSTANCE m_hInstance;
	HICON m_hSmallIcon;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\sources.inc ===
#
# Builds a simple windows-based test program
#

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiapeek
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMTYPE=windows

INCLUDES=$(INCLUDES)

SOURCES= \
        ..\wiapeek.cpp \
        ..\msgwrap.cpp  \
        ..\clistbox.cpp \
        ..\tools.cpp    \
        ..\wiapeek.rc

USE_NATIVE_EH=1
USE_MSVCRT=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\comctl32.lib \
            $(SDK_LIB_PATH)\wiaguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiapeek.rc
//
#define IDC_MYICON                      2
#define IDD_DIALOG_DIALOG               102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   104
#define IDM_ABOUT                       105
#define IDM_EXIT                        106
#define IDS_HELLO                       107
#define IDI_DIALOG                      108
#define IDI_SMALL                       109
#define IDC_DIALOG                      110
#define IDC_DIALOG_MENU                 111
#define IDS_DIALOG_TITLE                112
#define IDS_DIALOG_ABOUT_TEXT           113
#define IDS_DIALOG_ABOUT_TITLE          114
#define IDS_DIALOG_ERROR_TITLE          115
#define IDS_DIALOG_BROWSE_TITLE         116
#define IDS_NO_WIA_DEVICES              117
#define IDS_NO_WIA_EVENTS               118
#define IDS_SUCCESSFUL_REGISTER         119
#define IDS_UNSUCCESSFUL_REGISTER       120
#define IDR_MAINFRAME                   128
#define IDD_MAIN_DIALOG                 129
#define IDC_WIA_DEVICE_LIST             1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wialogcfg\wialogcfgdlg.h ===
// WiaLogCFGDlg.h : header file
//

#if !defined(AFX_WIALOGCFGDLG_H__361D7213_DFA2_4525_81A7_5F9B180FEFB7__INCLUDED_)
#define AFX_WIALOGCFGDLG_H__361D7213_DFA2_4525_81A7_5F9B180FEFB7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Type of logging
#define WIALOG_TRACE   0x00000001
#define WIALOG_WARNING 0x00000002
#define WIALOG_ERROR   0x00000004

// level of detail for TRACE logging
#define WIALOG_LEVEL1  1 // Entry and Exit point of each function/method
#define WIALOG_LEVEL2  2 // LEVEL 1, + traces within the function/method
#define WIALOG_LEVEL3  3 // LEVEL 1, LEVEL 2, and any extra debugging information
#define WIALOG_LEVEL4  4 // USER DEFINED data + all LEVELS of tracing

#define WIALOG_NO_RESOURCE_ID   0
#define WIALOG_NO_LEVEL         0


// format details for logging
#define WIALOG_ADD_TIME           0x00010000
#define WIALOG_ADD_MODULE         0x00020000
#define WIALOG_ADD_THREAD         0x00040000
#define WIALOG_ADD_THREADTIME     0x00080000
#define WIALOG_LOG_TOUI           0x00100000
                                       
#define WIALOG_MESSAGE_TYPE_MASK  0x0000ffff
#define WIALOG_MESSAGE_FLAGS_MASK 0xffff0000
#define WIALOG_CHECK_TRUNCATE_ON_BOOT   0x00000001

#define WIALOG_DEBUGGER           0x00000008
#define WIALOG_UI                 0x00000016

#define REG_READ		0
#define REG_WRITE		1
#define REG_ADD_KEY		2
#define REG_DELETE_KEY	3

#define SETTINGS_RESET_DIALOG  -1
#define SETTINGS_TO_DIALOG		0
#define SETTINGS_FROM_DIALOG	1


typedef struct _LOG_INFO {
	DWORD dwDetail;			 // Logging Detail
	DWORD dwLevel;           // Logging Level
	DWORD dwMode;            // Logging Mode
	DWORD dwTruncateOnBoot;  // Truncate on Boot
	DWORD dwClearLogOnBoot;  // Clear Log on Boot
	DWORD dwMaxSize;         // Max Log size
	DWORD dwLogToDebugger;   // Log to Debugger
	TCHAR szKeyName[64];	 // Module Name / Key Name
} LOG_INFO;

#include "registry.h"
#include "LogViewer.h"

/////////////////////////////////////////////////////////////////////////////
// CWiaLogCFGDlg dialog

class CWiaLogCFGDlg : public CDialog
{
// Construction
public:
	BOOL m_bColorCodeLogViewerText;
	void CheckGlobalServiceSettings();
	void ShowProgress(BOOL bShow);
	CProgCtrl m_ProgCtrl;
	LONG m_CurrentSelection;
	void InitializeDialogSettings(ULONG ulFlags = SETTINGS_TO_DIALOG);
	HINSTANCE m_hInstance;
	LOG_INFO  m_LogInfo;
	void RegistryOperation(ULONG  ulFlags);
	CWiaLogCFGDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaLogCFGDlg)
	enum { IDD = IDD_WIALOGCFG_DIALOG };
	CButton	m_ColorCodeLogViewerTextCheckBox;
	CButton	m_LogToDebuggerCheckBox;
	CButton	m_ClearLogOnBootCheckBox;
	CProgressCtrl	m_ProgressCtrl;
	CButton	m_AddTimeCheckBox;
	CButton	m_AddThreadIDCheckBox;
	CButton	m_AddModuleCheckBox;
	CButton	m_TruncateOnBootCheckBox;
	CComboBox	m_ModuleComboBox;
	CButton	m_WarningCheckBox;
	CButton	m_ErrorCheckBox;
	CButton	m_TraceCheckBox;
	CButton m_FilterOff;
	CButton	m_Filter1;
	CButton	m_Filter2;
	CButton	m_Filter3;
	CButton	m_FilterCustom;
	DWORD	m_dwCustomLevel;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaLogCFGDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWiaLogCFGDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnAddModuleButton();
	afx_msg void OnDeleteModuleButton();		
	virtual void OnOK();
	afx_msg void OnWriteSettingsButton();
	afx_msg void OnSelchangeSelectModuleCombobox();
	afx_msg void OnClearlogButton();
	afx_msg void OnViewLogButton();
	afx_msg void OnSetfocusSelectModuleCombobox();
	afx_msg void OnDropdownSelectModuleCombobox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIALOGCFGDLG_H__361D7213_DFA2_4525_81A7_5F9B180FEFB7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\msgwrap.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "msgwrap.h"
#include "clistbox.h"

#ifdef _OVERRIDE_LIST_BOXES

//////////////////////////////////////////////////////////////////////////
//
// extern global functions
// Details:  DeviceListBox()  - Controls the WIA device list box
//           EventListBox()   - Controls the WIA event list box
//
//////////////////////////////////////////////////////////////////////////

extern LRESULT CALLBACK DeviceListBox(HWND, UINT, WPARAM, LPARAM);
extern WNDPROC DefDeviceListBox;

#endif

#define _REGISTER_ON

//////////////////////////////////////////////////////////////////////////
//
// Function: CMessageWrapper()
// Details:  Constructor
//
//
//////////////////////////////////////////////////////////////////////////

CMessageWrapper::CMessageWrapper()
{
	m_hInstance = NULL;
	m_hSmallIcon = NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: ~CMessageWrapper()
// Details:  Destructor
//
//
//////////////////////////////////////////////////////////////////////////

CMessageWrapper::~CMessageWrapper()
{
	//
	// free Icon??? (m_hSmallIcon)
	//
}

//////////////////////////////////////////////////////////////////////////
//
// Function: Initialize()
// Details:  This function handles all initialization for the message wrapper
//
// hInstance      - handle to the application's instance
//
//////////////////////////////////////////////////////////////////////////

VOID CMessageWrapper::Initialize(HINSTANCE hInstance)
{
	m_hInstance = hInstance;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnInitDialog()
// Details:  This function handles all initialization for the dialog.
//           This includes control initialization.
//
// hDlg          - handle to the dialog's window
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnInitDialog(HWND hDlg)
{	
	TCHAR szString[255];

	//
	// Set dialog's title
	//

	if(!SetWindowText(hDlg,GetResourceString(IDS_DIALOG_TITLE, szString))) {
		Trace(TEXT("Could not set dialog's window title."));
	}

	//
	// Set dialog's small icon
	//

	m_hSmallIcon = LoadIcon(m_hInstance,MAKEINTRESOURCE(IDI_SMALL));
	if(m_hSmallIcon) {
		SendMessage(hDlg,WM_SETICON,(WPARAM)ICON_SMALL,(LPARAM)m_hSmallIcon);
	} else {
		Trace(TEXT("Could not load Small icon from dialog resource."));
	}

    //
    // Initialize WIA Device List box
    //

    if(!OnRefreshDeviceListBox(hDlg)){
        EnableAllControls(hDlg,FALSE);
    } else {
        EnableAllControls(hDlg,TRUE);
    }

#ifdef _OVERRIDE_LIST_BOXES

    HWND hListBox = NULL;
    hListBox = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
    if(NULL != hListBox) {

        DefDeviceListBox = (WNDPROC)GetWindowLongPtr(hListBox,GWL_WNDPROC);
        SetWindowLongPtr(hListBox,GWL_WNDPROC,(LONG_PTR)DeviceListBox);
        OnRefreshDeviceListBox(hDlg);
    }

#endif
    
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnAbout()
// Details:  This function handles the "About" information for the dialog.
//
// hDlg          - handle to the dialog's window
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnAbout(HWND hDlg)
{
	TCHAR szString[255];
	TCHAR szStringTitle[255];
	MessageBox(hDlg,GetResourceString(IDS_DIALOG_ABOUT_TEXT, szString),
		            GetResourceString(IDS_DIALOG_ABOUT_TITLE, szStringTitle),MB_OK);
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnExit()
// Details:  This function handles the exiting for the dialog.
//
// hDlg          - handle to the dialog's window
// wParam        - WPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnExit(HWND hDlg, WPARAM wParam)
{

	//
	// clean up any things here, and exit using the Window's API EndDialog()
	//

	return EndDialog(hDlg, LOWORD(wParam));	
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnBrowse()
// Details:  This function handles the Browse functionality for the dialog.
//
// hDlg                   - handle to the dialog's window
// szApplicationFilePath  - File path to selected application
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnBrowse(HWND hDlg, LPTSTR szApplicationFilePath)
{
    OPENFILENAME ofn;      // common dialog box structure
    TCHAR szString[255];   // string for title display
    // Initialize OPENFILENAME

    char szFile[260];              // buffer for file name
    char szBrowseDialogTitle[260]; // buffer for dialog title
    
    ZeroMemory(szFile,sizeof(szFile));
    ZeroMemory(szBrowseDialogTitle,sizeof(szBrowseDialogTitle));
    
    GetResourceString(IDS_DIALOG_BROWSE_TITLE,szBrowseDialogTitle,sizeof(szBrowseDialogTitle));

    HWND hListBox = NULL;
    hListBox = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
    if(NULL != hListBox) {        
        CListBoxUtil DevListBox(hListBox);
        BSTR bstrDeviceID = NULL;
        DevListBox.GetCurSelTextAndData(szString,(void**)&bstrDeviceID);
        lstrcat(szBrowseDialogTitle,szString);        
    } else {
        return FALSE;
    }

    ZeroMemory(&ofn, sizeof(OPENFILENAME));
    ofn.lStructSize     = sizeof(OPENFILENAME);
    ofn.hwndOwner       = hDlg;
    ofn.lpstrFile       = szFile;
    ofn.nMaxFile        = sizeof(szFile);
    ofn.lpstrFilter     = "*.EXE\0*.EXE\0";
    ofn.nFilterIndex    = 1;
    ofn.lpstrFileTitle  = NULL;
    ofn.nMaxFileTitle   = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle      = szBrowseDialogTitle;
    ofn.Flags           = 0;
    
    //
    // Display the Open dialog box. 
    //
    
    if (GetOpenFileName(&ofn) == TRUE){
        lstrcpy(szApplicationFilePath, szFile);    
    } else {
        return FALSE;
    }
        
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnRefreshDeviceListBox()
// Details:  This function handles refreshing the WIA device ListBox for the dialog.
//
// hDlg          - handle to the dialog's window
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnRefreshDeviceListBox(HWND hDlg)
{
    HWND hListBox = NULL;
    int iDeviceCount = 0;
    
    //
    // grab the WIA device list box
    //

    hListBox      = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
    
    if(NULL != hListBox) {

        //
        // setup utils, and continue
        //

        CListBoxUtil DevListBox(hListBox);
        
        //
        // clean device listbox
        //
            
        DevListBox.ResetContent();

        HRESULT hr               = S_OK;
        ULONG ulFetched          = 0;
        IWiaDevMgr  *pIWiaDevMgr = NULL;
        hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
        if(SUCCEEDED(hr)){
            if(NULL != pIWiaDevMgr){
                IWiaPropertyStorage    *pIWiaPropStg    = NULL;
                IEnumWIA_DEV_INFO      *pWiaEnumDevInfo = NULL;
                
                //
                // enumerate WIA devices
                //

                hr = pIWiaDevMgr->EnumDeviceInfo(WIA_DEVINFO_ENUM_LOCAL,&pWiaEnumDevInfo);
                if (SUCCEEDED(hr)){

                    //
                    // call reset, just in case
                    //

                    hr = pWiaEnumDevInfo->Reset();
                    if (SUCCEEDED(hr)) {
                        do {

                            //
                            // call NEXT()
                            //

                            hr = pWiaEnumDevInfo->Next(1,&pIWiaPropStg,&ulFetched);
                            if (hr == S_OK) {
                                if(ulFetched > 0){                                                                                            
                                    
                                    //
                                    // we have a device, so increment the
                                    // device counter
                                    //

                                    iDeviceCount++;

                                    PROPSPEC        PropSpec[2];
                                    PROPVARIANT     PropVar [2];
                                    
                                    //
                                    // clean the propvar
                                    //

                                    memset(PropVar,0,sizeof(PropVar));
                                    
                                    PropSpec[0].ulKind = PRSPEC_PROPID;
                                    PropSpec[0].propid = WIA_DIP_DEV_ID;
                                    
                                    PropSpec[1].ulKind = PRSPEC_PROPID;
                                    PropSpec[1].propid = WIA_DIP_DEV_NAME;
                                    
                                    //
                                    // read the device name, and device ID
                                    //

                                    hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                        PropSpec,
                                        PropVar);
                                    
                                    if (hr == S_OK) {

                                        //
                                        // write device name to the listbox, and save the
                                        // device ID for later use (EVENT ENUMERATION)
                                        //

                                        Trace(TEXT("Device Name: %ws"),PropVar[1].bstrVal);
                                        Trace(TEXT("Device ID:   %ws"),PropVar[0].bstrVal);

                                        //
                                        // convert the BSTR to a CHAR, and copy the BSTR
                                        // for later use (DEVICE CREATION)
                                        //

                                        TCHAR szString[255];
                                        sprintf(szString,TEXT("%ws"),PropVar[1].bstrVal);
                                        BSTR bstrDeviceID = SysAllocString(PropVar[0].bstrVal);
                                        
                                        //
                                        // add information to the listbox
                                        //

                                        DevListBox.AddStringAndData(szString,(void*)bstrDeviceID);
                                        
                                        //
                                        // free propvariant array
                                        //

                                        FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);
                                                                                
                                        //
                                        // release property storage
                                        //

                                        pIWiaPropStg->Release();
                                        pIWiaPropStg = NULL;

                                    } else
                                        Trace(TEXT("ReadMultiple() Failed while reading device name,server,and deviceID"));
                                } else {

                                    //
                                    // force enumeration to exit cleanly
                                    //

                                    hr = S_FALSE;
                                }
                            } else if (hr == S_FALSE) {                            

                                //
                                // end of enumeration
                                //

                            } else
                                Trace(TEXT("Next() Failed requesting 1 item"));                        
                        } while (hr == S_OK);                    
                    } else
                        Trace(TEXT("Reset() Failed"));
                } else{
                    Trace(TEXT("EnumDeviceInfo Failed"));
                    return FALSE;
                }
            } else {
                Trace(TEXT("WIA Device Manager is NULL"));
                return FALSE;
            }
            
            //
            // release WIA device manager
            //

            if(pIWiaDevMgr){
                pIWiaDevMgr->Release();
                pIWiaDevMgr = NULL;
            }
        }
        
        //
        // if no WIA devices were found during enumeration
        // set a nice message inthe list box for the users to 
        // see.
        //

        if(iDeviceCount == 0){
            TCHAR szString[255];
            GetResourceString(IDS_NO_WIA_DEVICES, szString, sizeof(szString));            
            DevListBox.AddStringAndData(szString,NULL);

            //
            // always default to the first selection in the listbox
            //
            
            DevListBox.SetCurSel(0);
            return FALSE; // no devices
        }

        //
        // always default to the first selection in the listbox
        //

        DevListBox.SetCurSel(0);
        return TRUE;
    }            
    return FALSE;    
}

//////////////////////////////////////////////////////////////////////////
//
// Function: EnableAllControls()
// Details:  This function enables/disables buttons, on the main dialog.
//
// bEnable     - Resource ID of the Error Code string
// hDlg        - Handle to parent window
//
//////////////////////////////////////////////////////////////////////////

VOID CMessageWrapper::EnableAllControls(HWND hDlg, bool bEnable)
{
    HWND hWindow = NULL;    
}

//////////////////////////////////////////////////////////////////////////
//
// Function: DisplayError()
// Details:  This function fills a string, loaded from the application's
//           resource, and display's it as an error dialog to the user.
//
// ErrorCode     - Resource ID of the Error Code string
//
//////////////////////////////////////////////////////////////////////////

VOID CMessageWrapper::DisplayError(INT ErrorCode)
{
	TCHAR szString[255];
	GetResourceString(ErrorCode, szString);

#ifdef _ERROR_POPUP	
	TCHAR szStringTitle[255];
	MessageBox(NULL,szString,
		            GetResourceString(IDS_DIALOG_ERROR_TITLE, szStringTitle),
					MB_OK|MB_ICONERROR);
#endif

	Trace(TEXT("Error Dialog: %s\n"),szString);
}

//////////////////////////////////////////////////////////////////////////
//
// Function: GetResourceString()
// Details:  This function fills a string, loaded from the application's
//           resource.
//
// ResourceID    - Resource ID of the error code's text
// szString      - String to be filled with the resource value
// isize         - Size of the string buffer, in BYTES
//
//////////////////////////////////////////////////////////////////////////

LPTSTR CMessageWrapper::GetResourceString(INT ResourceID, LPTSTR szString, INT isize)
{
	LoadString(m_hInstance,ResourceID,szString,isize);
	return szString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\tools.h ===
#ifndef _TOOLS_H
#define _TOOLS_H

VOID Trace(LPCTSTR Format, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\wiapeek.h ===
#ifndef _WIAPEEK_H
#define _WIAPEEK_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "resource.h"

#define _ERROR_POPUP // Error dialogs will popup to the user

LRESULT CALLBACK MainDlg(HWND, UINT, WPARAM, LPARAM);

#ifdef _OVERRIDE_LIST_BOXES // to override the list box functionality

LRESULT CALLBACK DeviceListBox(HWND, UINT, WPARAM, LPARAM);

WNDPROC DefDeviceListBox;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\tools.cpp ===
#include "stdafx.h"
#include "Tools.h"
#include "msgwrap.h"

extern CMessageWrapper g_MsgWrapper;

//////////////////////////////////////////////////////////////////////////
//
// Function: Trace()
// Details:  This function displays a string to the debugger, (for tracing)
// Remarks:  The Trace() function compiles to nothing, when building release.
//
// format        - String to display to the debugger
//
//////////////////////////////////////////////////////////////////////////

VOID Trace(LPCTSTR format,...)
{
    
#ifdef _DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Windows Header Files:
#include <windows.h>

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <stdio.h>

#include "tools.h"
#include "wia.h"

#ifndef STRICT
#define WNDPROC FARPROC
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaperf\classes.h ===
#ifndef _CLASSES_H_
#define _CLASSES_H_

#include <wtypes.h>
struct TESTSETTINGS
{
    BSTR *pstrDevices; // array of device IDs, NULL terminated
    LONG fLogMask;     // what to log
    TCHAR szLogFile[MAX_PATH]; // where to log
    UINT nIter;// number of iterations to run
    HWND hEdit; // edit window for logging
    BOOL bExit; // exit when complete
    BOOL bManual; // whether to wait for user input
};

#define LOG_WINDOW_ONLY      0
#define LOG_APIS             1
#define LOG_FILE             2
#define LOG_TIME             4
//
// log settings

#define TESTFUNC(x) static VOID (x)(CTest *pThis, BSTR strDeviceId);
class CTest
{
public:
    CTest (TESTSETTINGS *pSettings);
    // LIST TESTS HERE
    TESTFUNC( TstCreateDevice)
    TESTFUNC( TstShowThumbs )
    TESTFUNC( TstEnumCmds )
    TESTFUNC( TstDownload )
    TESTFUNC( TstBandedDownload)
    // END TESTS LIST
    void LogTime (LPTSTR szAction, LARGE_INTEGER &liTimeElapsed);
    void LogString (LPTSTR sz, ...);
    void LogAPI (LPTSTR szApi, HRESULT hr);
    void LogDevInfo (BSTR strDeviceId);
    ~CTest ();
    private:
    void OpenLogFile ();
    void CloseLogFile ();

    void RecursiveDownload (IWiaItem *pFolder, DWORD &dwPix, ULONG &ulSize, bool bBanded=false);
    void DownloadItem (IWiaItem *pItem, DWORD &dwPix, ULONG &ulSize, bool bBanded=false);

    HANDLE m_hLogFile;
    TESTSETTINGS *m_pSettings;

};

typedef VOID (*TESTPROC)(CTest* pTest, BSTR strDeviceId);



class CPerfTest
{
public:
    bool Init (HINSTANCE hInst);
    CPerfTest ();
    ~CPerfTest () {};
private:
    HWND m_hwnd;
    HWND m_hEdit;
    HINSTANCE m_hInst;
    TESTSETTINGS m_settings;
    VOID RunTests ();
    VOID GetSettings ();
    static LRESULT CALLBACK WndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    LRESULT RealWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    LRESULT OnCreate ();
    LRESULT OnCommand (WPARAM wp, LPARAM lp);
};

// These functions manage the settings dialog
INT_PTR CALLBACK SettingsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
VOID InitControls (HWND hwnd, TESTSETTINGS *pSettings);
VOID FillSettings (HWND hwnd, TESTSETTINGS *pSettings);
VOID FreeDialogData (HWND hwnd) ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\clistbox.cpp ===
#include "stdafx.h"
#include "clistbox.h"

CListBoxUtil::CListBoxUtil(HWND hListBox)
{
    m_hWnd = hListBox;
}

CListBoxUtil::~CListBoxUtil()
{

}

void CListBoxUtil::ResetContent()
{
    SendMessage(m_hWnd,LB_RESETCONTENT,(WPARAM)0,(LPARAM)0);
}

void CListBoxUtil::AddStringAndData(LPTSTR szString, void* pData)
{
    int InsertIndex = (int)SendMessage(m_hWnd,LB_ADDSTRING,(WPARAM)0,(LPARAM)szString);
    SendMessage(m_hWnd,LB_SETITEMDATA,(WPARAM)InsertIndex,(LPARAM)pData);
}

int CListBoxUtil::GetCurSelTextAndData(LPTSTR szString, void** pData)
{
    int CurSel = 0;
    *pData  = NULL;

    //
    // get current selected index
    //

    CurSel = (int)SendMessage(m_hWnd,LB_GETCURSEL,(WPARAM)0,(LPARAM)0);

    //
    // get string at that index, if one is selected
    //

    if(CurSel > -1) {
        SendMessage(m_hWnd,LB_GETTEXT,(WPARAM)CurSel,(LPARAM)szString);
        *pData = (void*)SendMessage(m_hWnd,LB_GETITEMDATA,(WPARAM)CurSel,(LPARAM)0);
    }

    return CurSel;
}

void CListBoxUtil::SetCurSel(int NewCurSel)
{
    SendMessage(m_hWnd,LB_SETCURSEL,(WPARAM)NewCurSel,(LPARAM)0);
}

int CListBoxUtil::GetCount()
{
    return (int)SendMessage(m_hWnd,LB_GETCOUNT,(WPARAM)0,(LPARAM)0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaperf\download.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "resource.h"
#include "wia.h"
#include "classes.h"

#include "commctrl.h"

extern CComPtr<IWiaDevMgr> g_pDevMgr;
LPCTSTR cszFilePath = TEXT("%temp%\\foobar.img");
TCHAR szFilePath[MAX_PATH] = TEXT("\0");

class CDataCallback : public IWiaDataCallback
{
public:
    HRESULT STDMETHODCALLTYPE BandedDataCallback(LONG lMessage,
                                                 LONG lStatus,
                                                 LONG lPercentComplete,
                                                 LONG lOffset,
                                                 LONG lLength,
                                                 LONG lReserved,
                                                 LONG lResLength,
                                                 BYTE *pbBuffer);

    HRESULT STDMETHODCALLTYPE QueryInterface(THIS_ REFIID riid, OUT PVOID *ppvObj)
    {
        *ppvObj = NULL;
        if (IsEqualGUID(riid, IID_IUnknown))
        {
            *ppvObj = static_cast<IUnknown*>(this);
        }
        else if (IsEqualGUID(riid, IID_IWiaDataCallback))
        {
            *ppvObj = static_cast<IWiaDataCallback*>(this);
        }
        else return E_NOINTERFACE;
        AddRef();
        return S_OK;
    }
    ULONG STDMETHODCALLTYPE AddRef(THIS) {
        return InterlockedIncrement (reinterpret_cast<LONG*>(&m_cRef));
    }

    ULONG STDMETHODCALLTYPE Release(void) {
        ULONG ulRet = InterlockedDecrement (reinterpret_cast<LONG*>(&m_cRef));
        if (!ulRet)
        {
            delete this;
        }
        return ulRet;
    }

    CDataCallback () : m_cRef(1), m_pBits(NULL) {};

private:
    ~CDataCallback () {if (m_pBits) delete [] m_pBits;}

    ULONG m_cRef;
    PBYTE m_pBits;
    PBYTE m_pWrite;
    LONG m_lSize;

};

STDMETHODIMP
CDataCallback::BandedDataCallback(LONG lMessage,
                                  LONG lStatus,
                                  LONG lPercentComplete,
                                  LONG lOffset,
                                  LONG lLength,
                                  LONG lReserved,
                                  LONG lResLength,
                                  BYTE *pbData)
{
    switch (lMessage)
    {
        case IT_MSG_DATA_HEADER:
        {

            WIA_DATA_CALLBACK_HEADER *pHead= reinterpret_cast<WIA_DATA_CALLBACK_HEADER*>(pbData);
            m_pBits = new BYTE[pHead->lBufferSize];
            if (!m_pBits)
            {
                return E_OUTOFMEMORY;
            }
            m_lSize = pHead->lBufferSize;
            m_pWrite = m_pBits;

        }
        break;
        case IT_MSG_DATA:
        {
            CopyMemory (m_pWrite, pbData, lLength);
            m_pWrite+=lLength;

        }
        break;
        case IT_MSG_TERMINATION:
        {
            if (m_pBits)
            {
                HANDLE hFile = CreateFile (szFilePath, GENERIC_WRITE,
                                           FILE_SHARE_READ,
                                           NULL,
                                           CREATE_ALWAYS,
                                           0,
                                           NULL);
                if (INVALID_HANDLE_VALUE != hFile)
                {
                    DWORD dw = 0;
                    WriteFile (hFile, m_pBits, static_cast<DWORD>(m_lSize), &dw, NULL);
                    CloseHandle (hFile);
                }
            }
        }
        break;
    }
    return S_OK;
}
VOID
CTest::DownloadItem (IWiaItem *pItem, DWORD &dwPix, ULONG &ulSize, bool bBanded)
{
    HRESULT hr;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    STGMEDIUM stg;
    PROPSPEC ps[2];
    PROPVARIANT pv[2];
    GUID guidFmt;
    WIA_DATA_TRANSFER_INFO wdti;
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);
    CComQIPtr<IWiaDataTransfer, &IID_IWiaDataTransfer> pXfer;
    CDataCallback *pDataCallback = NULL;

    QueryPerformanceCounter (&liStart);
    PropVariantInit (&pv[0]);
    if (!bBanded)
    {
        ZeroMemory (&stg, sizeof(stg));
        stg.pUnkForRelease = NULL;
        stg.tymed = TYMED_FILE;
        #ifdef UNICODE
        stg.lpszFileName = szFilePath;
        #else
        WCHAR szPath[MAX_PATH];
        MultiByteToWideChar (CP_ACP, 0, szFilePath, -1, szPath, MAX_PATH);
        stg.lpszFileName = szPath;
        #endif
//        stg.lpszFileName = NULL;

    }
    else
    {
        ZeroMemory (&wdti, sizeof(wdti));
        wdti.ulSize = sizeof(wdti);
        ps[0].ulKind = PRSPEC_PROPID;
        ps[0].propid = WIA_IPA_MIN_BUFFER_SIZE;

        hr = pps->ReadMultiple (1, &ps[0], &pv[0]);
        LogAPI (TEXT("IWiaPropertyStorage::ReadMultiple (WIA_IPA_MIN_BUFFER_SIZE)"), hr);
        if (hr == NOERROR)
        {
            wdti.ulBufferSize = 2*pv[0].ulVal;

        }
        else
        {
            wdti.ulBufferSize = 65536;
        }
        wdti.bDoubleBuffer = TRUE;
        PropVariantClear (&pv[0]);
        pDataCallback = new CDataCallback;
    }
    ps[0].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_IPA_PREFERRED_FORMAT;

    hr = pps->ReadMultiple (1, &ps[0], &pv[0]);
    LogAPI (TEXT("IWiaPropertyStorage::ReadMultiple (WIA_IPA_PREFERRED_FORMAT)"), hr);
    if (NOERROR == hr)
    {
        guidFmt = *(pv[0].puuid);
        PropVariantClear (&pv[0]);
        ps[0].propid = WIA_IPA_FORMAT;
        ps[1].ulKind = PRSPEC_PROPID;
        ps[1].propid = WIA_IPA_TYMED;
        pv[0].vt = VT_CLSID;
        pv[0].puuid = &guidFmt;
        pv[1].vt = VT_I4;
        pv[1].intVal = bBanded?TYMED_CALLBACK:TYMED_FILE;
        hr = pps->WriteMultiple (2, ps, pv, 2);
        LogAPI (TEXT("IWiaPropertyStorage::WriteMultiple(WIA_IPA_FORMAT, WIA_IPA_TYMED)"), hr);
        ps[0].propid = WIA_IPA_ITEM_SIZE;
        PropVariantInit (&pv[0]);
        hr = pps->ReadMultiple (1, &ps[0], &pv[0]);
        LogAPI (TEXT("IWiaPropertyStorage::ReadMultiple(WIA_IPA_ITEM_SIZE)"), hr);
        ulSize += pv[0].ulVal;
        dwPix++;
        pXfer = pItem;
        if (!pXfer)
        {
            LogString (TEXT("Unable to QI for IWiaDataTransfer!"));
        }
        else if (!bBanded)
        {
            hr = pXfer->idtGetData (&stg, NULL);
            LogAPI (TEXT("IWiaDataTransfer::idtGetData"), hr);
        }
        else if (pDataCallback)
        {
            CComQIPtr<IWiaDataCallback, &IID_IWiaDataCallback> pcb(pDataCallback);
            hr = pXfer->idtGetBandedData (&wdti, pcb);
            LogAPI (TEXT("IWiaDataTransfer::idtGetBandedData"), hr);
        }
    }
    QueryPerformanceCounter (&liEnd);
    if (!bBanded)
    {
        DeleteFileW (const_cast<LPCWSTR>(stg.lpszFileName));

    }
    DeleteFile (const_cast<LPCTSTR>(szFilePath));
    liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
    LogTime (TEXT("Download time for image "), liEnd);
    if (pDataCallback)
    {
        pDataCallback->Release();
    }
}


VOID
CTest::RecursiveDownload (IWiaItem *pFolder, DWORD &dwPix, ULONG &ulSize, bool bBanded)
{
    HRESULT hr;
    CComPtr<IEnumWiaItem> pEnum;
    DWORD dw;
    CComPtr<IWiaItem> pItem;
    LONG lItemType;
    hr = pFolder->EnumChildItems(&pEnum);
    LogAPI(TEXT("IWiaItem::EnumChildItems"), hr);
    while (NOERROR == hr)
    {
        hr = pEnum->Next (1,&pItem, &dw);
        if (dw)
        {
            hr = pItem->GetItemType (&lItemType);
            LogAPI (TEXT("IWiaItem::GetItemType"), hr);
            if (lItemType & WiaItemTypeFolder)
            {
                RecursiveDownload (pItem, dwPix, ulSize);
            }
            else
            {
                DownloadItem (pItem, dwPix, ulSize, bBanded);
            }
        }
    }
}
VOID
CTest::TstDownload (CTest *pThis, BSTR strDeviceId)
{
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    ULONG ulTotalSize = 0;
    DWORD dwPix = 0;
    HRESULT hr;
    TCHAR sz[200];
    CComPtr<IWiaItem> pRoot;
    ExpandEnvironmentStrings (cszFilePath, szFilePath, MAX_PATH);
    pThis->LogString (TEXT("--> Start test for idtGetData (no callback)"));
    pThis->LogString (TEXT("Note that the total log time in this test includes time for logging!"));
    QueryPerformanceCounter (&liStart);
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    pThis->LogAPI(TEXT("IWiaDevMgr::CreateDevice"), hr);
    if (SUCCEEDED(hr))
    {

        pThis->RecursiveDownload (pRoot, dwPix, ulTotalSize);


    }
    QueryPerformanceCounter (&liEnd);
    liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
    wsprintf (sz, TEXT("Total pix:%d, Total size:%d kilobytes"), dwPix, ulTotalSize/1024);
    pThis->LogTime (sz, liEnd);
}

VOID
CTest::TstBandedDownload (CTest *pThis, BSTR strDeviceId)
{
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    ULONG ulTotalSize = 0;
    DWORD dwPix = 0;
    HRESULT hr;
    TCHAR sz[200];
    CComPtr<IWiaItem> pRoot;
    ExpandEnvironmentStrings (cszFilePath, szFilePath, MAX_PATH);
    pThis->LogString (TEXT("--> Start test for idtGetBandedData "));
    pThis->LogString (TEXT("Note that the total log time in this test includes time for logging!"));
    QueryPerformanceCounter (&liStart);
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    pThis->LogAPI(TEXT("IWiaDevMgr::CreateDevice"), hr);
    if (SUCCEEDED(hr))
    {

        pThis->RecursiveDownload (pRoot, dwPix, ulTotalSize, true);


    }
    QueryPerformanceCounter (&liEnd);
    liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
    wsprintf (sz, TEXT("Total pix:%d, Total size:%d kilobytes"), dwPix, ulTotalSize/1024);
    pThis->LogTime (sz, liEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\clistbox.h ===
#ifndef _CLISTBOX
#define _CLISTBOX

class CListBoxUtil {
public:
    CListBoxUtil(HWND hListBox);
    ~CListBoxUtil();
    
    // helper functions
    void ResetContent();
    void AddStringAndData(LPTSTR szString, void* pData);    
    int  GetCurSelTextAndData(LPTSTR szString, void** pData);
    void SetCurSel(int NewCurSel);
    int  GetCount();
private:
    HWND m_hWnd;
protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaperf\resource.h ===
#define IDD_OPTIONS                 100
#define IDC_TESTALL                 101
#define IDC_TESTLIST                102
#define IDC_LOGALL                  103
#define IDC_LOGTIMES                104
#define IDC_LOGFILE                 105
#define IDC_GETFILE                 106
#define IDC_LOGFILENAME             107
#define IDC_TESTS                   109
#define ID_ITERATIONS               110
#define IDC_EXIT                    111

#define IDM_MAINMENU               1001
#define IDM_TESTS_OPTIONS          1002
#define IDM_TESTS_EXECUTE          1003
#define IDM_EXIT                   1004

#define IDD_SHOWTHUMBS              201
#define IDC_THUMBS                 2000

#define IDI_APPICON                10
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiapeek\wiapeek.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "wiapeek.h"
#include "msgwrap.h"

CMessageWrapper g_MsgWrapper;

//////////////////////////////////////////////////////////////////////////
//
// Function: WinMain()
// Details:  This function is WinMain... enough said. ;) It creates a Modal
//           dialog as the main application window.
//
// hInstance     - instance of this application
// hPrevInstance - Previous instance of this applcation (already running)
// lpCmdLine     - command line arguments
// nCmdShow      - show state, specifies how the window should be shown
//
//////////////////////////////////////////////////////////////////////////

INT APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    CoInitialize(NULL);
    g_MsgWrapper.Initialize(hInstance);
    DialogBox(hInstance, (LPCTSTR)IDD_MAIN_DIALOG, NULL, (DLGPROC)MainDlg);
    CoUninitialize();
    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: MainDlg()
// Details:  This function is the Window Proc for this dialog.  It
//           dispatches messages to their correct handlers.  If there is
//           handler, we let Windows handle the message for us.
//
// hDlg          - handle to the dialog's window
// message       - windows message (incoming from system)
// wParam        - WPARAM parameter (used for windows data/argument passing)
// lParam        - LPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MainDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT wmId    = 0;
    INT wmEvent = 0;

    TCHAR szApplicationFilePath[1024];
    HWND  hApplicationPathEditBox = NULL;

    switch (message)
    {
        //
        // We want first crack at processing any messages
        //

        case WM_INITDIALOG:            
            return g_MsgWrapper.OnInitDialog(hDlg);        
            break;
        case WM_COMMAND:
            wmId    = LOWORD(wParam);
            wmEvent = HIWORD(wParam);

            switch(wmId)
            {
                //
                // Trap Button IDs, and Menu IDs
                //
                
                case IDC_WIA_DEVICE_LIST:
                    if(wmEvent == LBN_SELCHANGE){
                        /*
                        if(!g_MsgWrapper.OnRefreshEventListBox(hDlg)){
                            g_MsgWrapper.EnableAllControls(hDlg, FALSE);
                        } else {
                            g_MsgWrapper.EnableAllControls(hDlg, TRUE);
                        }
                        */
                    }
                    break;
                case IDCANCEL:                        // CANCEL       (Button)
                case IDM_EXIT:                        // FILE | EXIT  (Menu)
                    return g_MsgWrapper.OnExit(hDlg,wParam);
                    break;
                case IDM_ABOUT:                       // HELP | ABOUT (Menu)
                    g_MsgWrapper.OnAbout(hDlg);
                    break;
                default:
                    break;
            }
            break;
        default:

            //
            // Let windows take care of it (DefWindowProc(hDlg,message,wParam,lParam))
            //

            break;
    }
    return FALSE;
}

#ifdef _OVERRIDE_LIST_BOXES

//////////////////////////////////////////////////////////////////////////
//
// Function: DeviceListBox()
// Details:  This function is the Window Proc for the Device ListBox.  It
//           dispatches messages to their correct handlers.  If there is
//           handler, we let Windows handle the message for us.
//
// hDlg          - handle to the dialog's window
// message       - windows message (incoming from system)
// wParam        - WPARAM parameter (used for windows data/argument passing)
// lParam        - LPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK DeviceListBox(HWND hListBox, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT wmId    = 0;
    INT wmEvent = 0;

    return DefDeviceListBox(hListBox,message,wParam,lParam);
}

//////////////////////////////////////////////////////////////////////////
//
// Function: EventListBox()
// Details:  This function is the Window Proc for the Event ListBox.  It
//           dispatches messages to their correct handlers.  If there is
//           handler, we let Windows handle the message for us.
//
// hDlg          - handle to the dialog's window
// message       - windows message (incoming from system)
// wParam        - WPARAM parameter (used for windows data/argument passing)
// lParam        - LPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK EventListBox(HWND hListBox, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT wmId    = 0;
    INT wmEvent = 0;

    return DefEventListBox(hListBox,message,wParam,lParam);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaperf\wmain.cpp ===
#include <windows.h>
#include "wia.h"
#include "classes.h"

#include "atlbase.h"


extern CComPtr<IWiaDevMgr> g_pDevMgr;
INT WINAPI
WinMain (HINSTANCE hInstance, HINSTANCE hUnused, LPSTR pCmdLine, int nCmdShow)
{
    CPerfTest TestObj;

    MSG msg;
    CoInitialize (NULL);
    if (TestObj.Init (hInstance))
    {
        while (GetMessage (&msg, NULL, 0, 0) > 0)
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }
    g_pDevMgr=NULL;
    CoUninitialize ();
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// Windows Header Files:
#include <windows.h>

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <stdio.h>

#include "tools.h"
#include "wia.h"

#ifndef STRICT
#define WNDPROC FARPROC
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaperf\tests.cpp ===
#include <windows.h>
#include "resource.h"
#include "wia.h"
#include <atlbase.h>
#include "classes.h"
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

CComPtr<IWiaDevMgr> g_pDevMgr;
LARGE_INTEGER liTimerFreq;

struct TESTENTRY
{
    LPCTSTR szName;
    TESTPROC pfnTest;
    bool  bRunMe;
} TESTLIST[] =
{
    {TEXT("CreateDevice only"), CTest::TstCreateDevice, false},
    {TEXT("Display Thumbnails"), CTest::TstShowThumbs, false},
    {TEXT("Enum device commands"), CTest::TstEnumCmds, false},
    {TEXT("idtGetData for all images"), CTest::TstDownload, false},
    {TEXT("idtGetBandedData for all images"), CTest::TstBandedDownload, false},

};


CPerfTest::CPerfTest () : m_hwnd(NULL), m_hEdit(NULL)
{
    ZeroMemory (&m_settings, sizeof(m_settings));
}


static TCHAR cszWndClass[] = TEXT("TestWindow");
static TCHAR cszWndName[] = TEXT("WIA Perf Measurement");

bool
CPerfTest::Init (HINSTANCE hInst)
{
    WNDCLASS wc;
    m_hInst = hInst;

    // make sure WIA is around
    if (FAILED(CoCreateInstance (CLSID_WiaDevMgr,
                  NULL,
                  CLSCTX_LOCAL_SERVER,
                  IID_IWiaDevMgr,
                  reinterpret_cast<LPVOID*>(&g_pDevMgr))))
    {
        MessageBox (NULL,
                    TEXT("Unable to create WIA!"),
                    TEXT("WiaPerf Error"),
                    MB_OK | MB_ICONSTOP);
        return false;
    }

    // verify high resolution timer available
    if (!QueryPerformanceFrequency(&liTimerFreq))
    {
        MessageBox (NULL,
                    TEXT("No performance counter available."),
                    TEXT("WiaPerf Error"),
                    MB_OK | MB_ICONSTOP);
        return false;
    }

    ZeroMemory (&wc, sizeof(wc));
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.hCursor = LoadCursor (NULL, IDC_ARROW);
    wc.hInstance = m_hInst;
    wc.lpfnWndProc = WndProc;
    wc.hIcon = LoadIcon (m_hInst, MAKEINTRESOURCE(IDI_APPICON));
    wc.lpszClassName = cszWndClass;
    wc.lpszMenuName = MAKEINTRESOURCE(IDM_MAINMENU);


    RegisterClass (&wc);

    m_hwnd = CreateWindow (cszWndClass,
                           cszWndName,
                           WS_OVERLAPPEDWINDOW | WS_VISIBLE |WS_CLIPCHILDREN,
                           CW_USEDEFAULT, 0,
                           CW_USEDEFAULT, 0,
                           NULL,
                           NULL,
                           m_hInst,
                           reinterpret_cast<LPVOID>(this));
   if (IsWindow (m_hwnd))
   {
       ShowWindow (m_hwnd, SW_SHOW);
       UpdateWindow (m_hwnd);
       return true;
   }
   return false;

}


LRESULT CALLBACK
CPerfTest::WndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CPerfTest *pThis;

    if (WM_CREATE == msg)
    {
        // store our "this" pointer
        SetWindowLongPtr (hwnd,
                          GWLP_USERDATA,
                          reinterpret_cast<LONG_PTR>(reinterpret_cast<LPCREATESTRUCT>(lp)->lpCreateParams));

    }
    pThis = reinterpret_cast<CPerfTest*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    return pThis->RealWndProc (hwnd, msg, wp, lp);
}

LRESULT
CPerfTest::RealWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{

    switch (msg)
    {
        case WM_CREATE:
            m_hwnd = hwnd;
            return OnCreate ();

        case WM_COMMAND:
            return OnCommand (wp, lp);

        case WM_DESTROY:
            PostQuitMessage (0);
            return 0;

        case WM_SIZE:
            // size the edit control to match
            MoveWindow (m_hEdit, 0,0,LOWORD(lp), HIWORD(lp), TRUE);
            break;
        default:
            break;
    }
    return CallWindowProc (DefWindowProc, hwnd, msg, wp, lp);
}

LRESULT
CPerfTest::OnCreate ()
{
    // Create our child edit control. Used to display logging output
    m_hEdit = CreateWindow (TEXT("edit"), TEXT(""),
                            WS_BORDER | ES_READONLY | WS_CHILD|WS_VISIBLE|ES_MULTILINE | WS_VSCROLL | WS_HSCROLL,
                            0,0,0,0,m_hwnd,
                            reinterpret_cast<HMENU>(1),
                            m_hInst,NULL);

    GetSettings ();
    return 0;
}

LRESULT
CPerfTest::OnCommand (WPARAM wp, LPARAM lp)
{
    switch (LOWORD(wp))
    {
        case IDM_TESTS_OPTIONS:
            GetSettings ();
            return 0;

        case IDM_TESTS_EXECUTE:
            RunTests ();
            return 0;

        case IDM_EXIT:
            DestroyWindow (m_hwnd);
            return 0;

    }
    return 1;
}

VOID
CPerfTest::RunTests ()
{
    UINT nRun;
    size_t nTest;
    UINT nDevice;
    CTest TheTest(&m_settings);
    for (nDevice=0; m_settings.pstrDevices[nDevice];nDevice++)

    {
        for (nRun = 0;nRun < m_settings.nIter; nRun++)
        {
            for (nTest=0;nTest<ARRAYSIZE(TESTLIST);nTest++)
            {
                if (TESTLIST[nTest].bRunMe)
                {
                    (TESTLIST[nTest].pfnTest)(&TheTest, m_settings.pstrDevices[nDevice]);
                }
            }
        }
        TheTest.LogDevInfo (m_settings.pstrDevices[nDevice]);
    }
}

VOID
CPerfTest::GetSettings ()
{
    m_settings.hEdit = m_hEdit;
    if (m_settings.pstrDevices)
    {
        delete [] m_settings.pstrDevices;
        m_settings.pstrDevices = NULL;
    }
    DialogBoxParam (m_hInst,
                    MAKEINTRESOURCE(IDD_OPTIONS),
                    m_hwnd,
                    SettingsDlgProc,
                    reinterpret_cast<LPARAM>(&m_settings));
    // hide or show "Execute!" depending on settings
    HMENU hmenu = GetSubMenu (GetMenu(m_hwnd), 0);
    if (m_settings.nIter)
    {
        EnableMenuItem (hmenu, IDM_TESTS_EXECUTE, MF_BYCOMMAND|MF_ENABLED);
    }
    else
    {
        EnableMenuItem (hmenu, IDM_TESTS_EXECUTE, MF_BYCOMMAND|MF_DISABLED);
    }

}

INT_PTR CALLBACK
SettingsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    TESTSETTINGS *pSettings;
    pSettings = reinterpret_cast<TESTSETTINGS*>(GetWindowLongPtr(hwnd, DWLP_USER));

    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);
            pSettings = reinterpret_cast<TESTSETTINGS*>(lp);
            InitControls (hwnd, pSettings);
            return TRUE;

        case WM_COMMAND:
            if (IDOK == LOWORD(wp))
            {
                FillSettings (hwnd, pSettings);

            }
            if (IDOK == LOWORD(wp) || IDCANCEL == LOWORD(wp))
            {
                FreeDialogData (hwnd);
                EndDialog (hwnd, 1);
                return TRUE;
            }
            if (IDC_GETFILE == LOWORD(wp))
            {
                TCHAR szFileName[MAX_PATH];
                OPENFILENAME ofn;
                ZeroMemory (&ofn, sizeof(ofn));
                ofn.hInstance = GetModuleHandle (NULL);
                ofn.hwndOwner = hwnd;
                ofn.lpstrFile = szFileName;
                ofn.lpstrFilter = TEXT("LOG file\0*.log\0Text file\0*.txt\0");
                ofn.lpstrDefExt = TEXT("log");
                ofn.lStructSize = sizeof(ofn);
                ofn.nMaxFile = MAX_PATH;
                if (GetOpenFileName(&ofn))
                {
                    SetDlgItemText (hwnd, IDC_LOGFILENAME, szFileName);
                }
                return TRUE;
            }
            return FALSE;
    }
    return FALSE;
}

VOID
InitControls (HWND hwnd, TESTSETTINGS *pSettings)
{
    //
    // First, enum the WIA devices available and put their names in the listbox
    //

    CComPtr<IEnumWIA_DEV_INFO> pEnum;
    CComPtr<IWiaPropertyStorage> pStg;
    PROPVARIANT pv[2];
    PROPSPEC ps[2];
    ULONG ul;
    BSTR strID;
    TCHAR szName[MAX_PATH];
    LRESULT lItem;

    if (FAILED(g_pDevMgr->EnumDeviceInfo(0, &pEnum)))
    {
        MessageBox (hwnd,
                    TEXT("Unable to enum WIA devices!"),
                    TEXT("WiaPerf Error"),
                    MB_OK | MB_ICONSTOP);
        return;
    }
    ps[0].ulKind = ps[1].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_DIP_DEV_NAME;
    ps[1].propid = WIA_DIP_DEV_ID;

    while (NOERROR == pEnum->Next (1, &pStg, &ul))
    {
        if (NOERROR == pStg->ReadMultiple (2, ps, pv))
        {
            strID = SysAllocString (pv[1].pwszVal);
            #ifdef UNICODE
            wcscpy (szName, pv[0].pwszVal);
            #else
            WideCharToMultiByte (CP_ACP, 0, pv[0].pwszVal, -1,
                                 szName, MAX_PATH, NULL, NULL);
            #endif
            lItem = SendDlgItemMessage (hwnd,
                                        IDC_TESTLIST,
                                        CB_ADDSTRING,
                                        0,
                                        reinterpret_cast<LPARAM>(szName));
            if (lItem >= 0)
            {
                SendDlgItemMessage (hwnd,
                                    IDC_TESTLIST,
                                    CB_SETITEMDATA,
                                    lItem,
                                    reinterpret_cast<LPARAM>(strID));
            }
        }
    }

    SendDlgItemMessage (hwnd,
                        IDC_TESTLIST,
                        CB_SETCURSEL,
                        0, 0);


    // Fill the test names listbox
    for (INT i=0;i<ARRAYSIZE(TESTLIST);i++)
    {
        lItem = SendDlgItemMessage (hwnd,
                                    IDC_TESTS,
                                    LB_ADDSTRING,
                                    0,
                                    reinterpret_cast<LPARAM>(TESTLIST[i].szName));
        SendDlgItemMessage (hwnd,
                            IDC_TESTS,
                            LB_SETITEMDATA,
                            lItem,
                            reinterpret_cast<LPARAM>(TESTLIST[i].pfnTest));

    }
    CheckDlgButton (hwnd, IDC_EXIT, pSettings->bExit);

    //
    // Set some defaults
    CheckDlgButton (hwnd, IDC_LOGFILE, pSettings->fLogMask & LOG_FILE);
    SetDlgItemText (hwnd, IDC_LOGFILENAME, pSettings->szLogFile);
    CheckDlgButton (hwnd, IDC_LOGTIMES, pSettings->fLogMask & LOG_TIME);
    SetDlgItemInt (hwnd, ID_ITERATIONS,pSettings->nIter ? pSettings->nIter : 1, FALSE);
}


VOID
FillSettings (HWND hwnd, TESTSETTINGS *pSettings)
{
    //
    // Read the list of device id's selected
    //
    BOOL bAddAll = IsDlgButtonChecked (hwnd, IDC_TESTALL);
    if (bAddAll)
    {
        LRESULT lDevices = SendDlgItemMessage (hwnd, IDC_TESTLIST,
                                               CB_GETCOUNT, 0, 0);
        if (lDevices > 0)
        {
            pSettings->pstrDevices = new BSTR[lDevices+1];

            for (LRESULT i=0;i<lDevices;i++)
            {
                pSettings->pstrDevices[i] = reinterpret_cast<BSTR>(SendDlgItemMessage (
                                                                        hwnd,
                                                                        IDC_TESTLIST,
                                                                        CB_GETITEMDATA,
                                                                        i, 0));
            }
            pSettings->pstrDevices[i] = NULL;
        }
    }
    else
    {
        LRESULT lItem = SendDlgItemMessage (hwnd, IDC_TESTLIST, CB_GETCURSEL, 0, 0);
        if (lItem >=0 )
        {
            pSettings->pstrDevices = new BSTR[2];
            pSettings->pstrDevices[0] = reinterpret_cast<BSTR>(SendDlgItemMessage (
                                                                  hwnd,
                                                                  IDC_TESTLIST,
                                                                  CB_GETITEMDATA,
                                                                  lItem,
                                                                  0));
            pSettings->pstrDevices[1] = NULL;
        }
    }

    //
    // Get the log settings
    //
    pSettings->fLogMask = LOG_WINDOW_ONLY;
    if (IsDlgButtonChecked (hwnd, IDC_LOGALL))
    {
        pSettings->fLogMask |= LOG_APIS;
    }
    if (IsDlgButtonChecked (hwnd, IDC_LOGTIMES))
    {
        pSettings->fLogMask |= LOG_TIME;
    }
    if (IsDlgButtonChecked (hwnd, IDC_LOGFILE))
    {
        pSettings->fLogMask |= LOG_FILE;
    }
    // get the file path
    GetDlgItemText (hwnd, IDC_LOGFILENAME, pSettings->szLogFile, MAX_PATH);
    // how many times to run
    pSettings->nIter = GetDlgItemInt (hwnd, ID_ITERATIONS, NULL, FALSE);
    // Whether to exit on test complete
    pSettings->bExit = IsDlgButtonChecked (hwnd, IDC_EXIT);

    //
    // Cycle through the tests in the list and check which ones to run
    for (size_t i=0;i<ARRAYSIZE(TESTLIST);i++)
    {
        if (SendDlgItemMessage (hwnd, IDC_TESTS, LB_GETSEL, i, 0) > 0)
        {
            TESTLIST[i].bRunMe = true;
        }
        else
        {
            TESTLIST[i].bRunMe = false;
        }
    }
}


VOID FreeDialogData (HWND hwnd)
{
    LRESULT lDevices = SendDlgItemMessage (hwnd, IDC_TESTLIST,
                                               CB_GETCOUNT, 0, 0);
    BSTR str;
    if (lDevices > 0)
    {

        for (LRESULT i=0;i<lDevices;i++)
        {
        str = reinterpret_cast<BSTR>(SendDlgItemMessage (hwnd,
                                                         IDC_TESTLIST,
                                                         CB_GETITEMDATA,
                                                         i, 0));
        SysFreeString (str);
        }
    }
}



CTest::CTest (TESTSETTINGS *pSettings)
{
    m_pSettings = pSettings;
    OpenLogFile ();
}

CTest::~CTest ()
{
    CloseLogFile ();
}

void
CTest::OpenLogFile ()
{

    m_hLogFile = CreateFile (m_pSettings->szLogFile,
                             GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
    #ifdef UNICODE
    // write the UNICODE header
    if (m_hLogFile != INVALID_HANDLE_VALUE)
    {
        WCHAR bom = 0xFEFF;
        DWORD dw;
        WriteFile (m_hLogFile, &bom, sizeof(WCHAR), &dw, NULL);
    }
    #endif
    LogString (TEXT("******* WIA Perf Test Starting. ********"));
}

void
CTest::CloseLogFile ()
{
    LogString (TEXT("******* WIA Perf Test Ending. *******"));
    if (INVALID_HANDLE_VALUE != m_hLogFile)
    {
        CloseHandle (m_hLogFile);
    }

}

// LogTime assumes the number of seconds will fit in a long
//
void
CTest::LogTime (LPTSTR szAction,LARGE_INTEGER &liTimeElapsed)
{
    LARGE_INTEGER liSeconds;
    if (m_pSettings->fLogMask & LOG_TIME)
    {
        liSeconds.QuadPart = (1000*liTimeElapsed.QuadPart)/liTimerFreq.QuadPart;
        LogString (TEXT("Time for %s:%lu milliseconds"), szAction, liSeconds.LowPart);
    }
}

void
CTest::LogAPI (LPTSTR szAPI, HRESULT hr)
{
    if (m_pSettings->fLogMask & LOG_APIS)
    {
        if (FAILED(hr))
        {
            LogString (TEXT("API call: %s failed %x"), szAPI, hr);
        }
        else
        {
            LogString (TEXT("API call: %s succeeded %x"), szAPI, hr);
        }
    }
}

void
CTest::LogString (LPTSTR sz, ...)
{
    TCHAR szOut[1024];
    va_list args;

    va_start (args, sz);
    wvsprintf (szOut, sz, args);
    va_end(args);

    // Note that we can write past the end of this buffer.
    lstrcat (szOut, TEXT("\r\n"));

    SendMessage (m_pSettings->hEdit,
                 EM_REPLACESEL,
                 0,
                 reinterpret_cast<LPARAM>(szOut));



    if (m_pSettings->fLogMask & LOG_FILE && INVALID_HANDLE_VALUE != m_hLogFile)
    {
        DWORD dw;
        WriteFile (m_hLogFile, szOut, sizeof(TCHAR)*(lstrlen(szOut)+1), &dw, NULL);
    }
}

VOID
CTest::TstCreateDevice (CTest *pThis, BSTR strDeviceId)
{

    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    HRESULT hr;
    CComPtr<IWiaItem> pRoot;
    pThis->LogString (TEXT("--> Start test for CreateDevice"));

    QueryPerformanceCounter (&liStart);
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    QueryPerformanceCounter (&liEnd);
    pRoot = NULL;
    liEnd.QuadPart = liEnd.QuadPart-liStart.QuadPart;
    pThis->LogTime (TEXT("CreateDevice"), liEnd);
    pThis->LogAPI (TEXT("IWiaDevMgr::CreateDevice"), hr);

    pThis->LogString (TEXT("<-- End test for CreateDevice"));
}

VOID
CTest::LogDevInfo(BSTR strDeviceId)
{
    CComPtr<IWiaItem> pRoot;
    if (SUCCEEDED(g_pDevMgr->CreateDevice (strDeviceId, &pRoot)))
    {
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pstg(pRoot);
        PROPVARIANT pv[3];
        PROPSPEC    ps[3];
        ps[0].ulKind = ps[1].ulKind = ps[2].ulKind = PRSPEC_PROPID;
        ps[0].propid = WIA_DIP_DEV_NAME;
        ps[1].propid = WIA_DPC_PICTURES_TAKEN;
        ps[2].propid = WIA_DIP_PORT_NAME;
        if (NOERROR == pstg->ReadMultiple (3, ps, pv))
        {
            LogString (TEXT("Device ID : %ls"), strDeviceId);
            LogString (TEXT("Device Name : %ls"), pv[0].pwszVal);
            LogString (TEXT("On Port : %ls"), pv[2].pwszVal);
            LogString (TEXT("Number of stored images : %d"), pv[1].ulVal);
        }
    }
}

// Enumerate commands supported by the device
VOID
CTest::TstEnumCmds (CTest *pThis, BSTR strDeviceId)
{
    LARGE_INTEGER liStart;
    LARGE_INTEGER liEnd;
    HRESULT hr;
    CComPtr<IWiaItem> pRoot;
    pThis->LogString (TEXT("--> Start test for EnumWIA_DEV_CAPS(WIA_DEVICE_COMMANDS)"));
    hr = g_pDevMgr->CreateDevice (strDeviceId, &pRoot);
    pThis->LogAPI(TEXT("IWiaDevMgr::CreateDevice"), hr);
    if (SUCCEEDED(hr))
    {
        CComPtr<IEnumWIA_DEV_CAPS> pCaps;
        WIA_DEV_CAP wdc;
        TCHAR sz[200];
        DWORD dwCmds = 0;
        DWORD dw;
        QueryPerformanceCounter (&liStart);
        hr = pRoot->EnumDeviceCapabilities (WIA_DEVICE_COMMANDS, &pCaps);
        QueryPerformanceCounter (&liEnd);
        liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
        pThis->LogTime (TEXT("IWiaItem::EnumDeviceCapabilities (WIA_DEVICE_COMMANDS)"), liEnd);
        pThis->LogAPI (TEXT("IWiaItem::EnumDeviceCapabilities (WIA_DEVICE_COMMANDS)"), hr);
        QueryPerformanceCounter (&liStart);
        while (NOERROR == hr)
        {
            hr = pCaps->Next (1, &wdc, &dw);
            dwCmds+=dw;
            if (wdc.bstrCommandline)
            {
                SysFreeString (wdc.bstrCommandline);
            }
            if (wdc.bstrDescription)
            {
                SysFreeString (wdc.bstrDescription);
            }
            if (wdc.bstrIcon)
            {
                SysFreeString (wdc.bstrIcon);
            }
        }
        QueryPerformanceCounter (&liEnd);
        liEnd.QuadPart = liEnd.QuadPart - liStart.QuadPart;
        wsprintf (sz, TEXT("%d commands from IEnumWIA_DEV_CAPS::Next"), dwCmds);
        pThis->LogTime (sz, liEnd);

    }
    pThis->LogString (TEXT("<-- End test for EnumWIA_DEV_CAPS(WIA_DEVICE_COMMANDS)"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaperf\thumbs.cpp ===
#include <windows.h>
#include <atlbase.h>
#include "resource.h"
#include "wia.h"
#include "classes.h"

#include "commctrl.h"

extern CComPtr<IWiaDevMgr> g_pDevMgr;

LARGE_INTEGER li1;
LARGE_INTEGER li2;
LARGE_INTEGER li3;
LARGE_INTEGER liDiff;

struct DRAWINFO
{
    HBITMAP hbmp;
    LPVOID  pBitmap;
    INT iWidth;
    INT iHeight;
};
#define GETDIFF(x,y) (liDiff.QuadPart = (x).QuadPart -(y).QuadPart)

class CThumbsDlg
{
public:
    CThumbsDlg (CTest *pTest, BSTR strDeviceId);
    VOID ShowDlg ();


private:
    INT m_iWidth;
    INT m_iHeight;

    HWND m_hwnd;
    HIMAGELIST m_himl;
    CTest *m_pTest;
    CComPtr<IWiaItem> m_pDevice;
    BSTR m_strDeviceId;
    VOID TimeEnumThumbnails ();
    static INT_PTR CALLBACK ShowThumbsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    INT_PTR RealDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    VOID RenderThumbnail ();
};

VOID
GetThumbSize (IWiaItem *pItem, INT *piWidth, INT *piHeight)
{
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage>  pstg(pItem);
    PROPVARIANT pv[2];
    PROPSPEC    ps[2];

    ps[0].ulKind = ps[1].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_DPC_THUMB_WIDTH;
    ps[1].propid = WIA_DPC_THUMB_HEIGHT;


    if (SUCCEEDED( pstg->ReadMultiple (2, ps, pv)))
    {

        *piWidth = pv[0].ulVal;
        *piHeight = pv[1].ulVal;
    }
    else
    {
        *piWidth = 0;
        *piHeight = 0;
    }
    FreePropVariantArray (2, pv);
}
HRESULT
GetNameAndThumbnail (IWiaItem *pItem, LPTSTR szName, DRAWINFO *pInfo)
{
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage>  pstg(pItem);
    PROPVARIANT pv[4];
    PROPSPEC    ps[4];
    HRESULT hr;
    BITMAPINFO bmi;
    HWND hwnd;
    HDC hdc;

    ps[0].ulKind = ps[1].ulKind = ps[2].ulKind = ps[3].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_IPA_ITEM_NAME;
    ps[1].propid = WIA_IPC_THUMBNAIL;
    ps[2].propid = WIA_IPC_THUMB_WIDTH;
    ps[3].propid = WIA_IPC_THUMB_HEIGHT;


    hr = pstg->ReadMultiple (4, ps, pv);
    if (SUCCEEDED(hr))
    {
        #ifdef UNICODE
        lstrcpy (szName, pv[0].pwszVal);
        #else
        WideCharToMultiByte (CP_ACP, 0, pv[0].pwszVal, -1, szName, MAX_PATH,
                             NULL,NULL);
        #endif
        bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth           = pv[2].ulVal;
        bmi.bmiHeader.biHeight          = pv[3].ulVal;
        bmi.bmiHeader.biPlanes          = 1;
        bmi.bmiHeader.biBitCount        = 24;
        bmi.bmiHeader.biCompression     = BI_RGB;
        bmi.bmiHeader.biSizeImage       = 0;
        bmi.bmiHeader.biXPelsPerMeter   = 0;
        bmi.bmiHeader.biYPelsPerMeter   = 0;
        bmi.bmiHeader.biClrUsed         = 0;
        bmi.bmiHeader.biClrImportant    = 0;

        hwnd   = GetDesktopWindow();
        hdc    = GetDC( hwnd );
        pInfo->hbmp = CreateDIBSection( hdc, &bmi, DIB_RGB_COLORS, &pInfo->pBitmap, NULL, 0 );
        pInfo->iHeight = bmi.bmiHeader.biHeight;
        pInfo->iWidth = bmi.bmiHeader.biWidth;

        //
        // Transfer thumbnail bits to bitmap bits
        //

        CopyMemory( pInfo->pBitmap, pv[1].caub.pElems, pv[1].caub.cElems );
        FreePropVariantArray (4, pv);
        ReleaseDC (hwnd, hdc);

    }
    return hr;
}

VOID
CThumbsDlg::TimeEnumThumbnails ()
{

    CComPtr<IEnumWiaItem> pEnum;
    HWND hList = GetDlgItem (m_hwnd, IDC_THUMBS);



    QueryPerformanceCounter (&li3);

    if (SUCCEEDED(m_pDevice->EnumChildItems (&pEnum)))
    {
        ULONG ul;

        CComPtr<IWiaItem> pItem;
        LVITEM lvi;
        TCHAR szName[MAX_PATH];
        HBITMAP hbmp;
        DRAWINFO *pInfo;
        QueryPerformanceCounter (&li2);
        GETDIFF(li2, li3);
        m_pTest->LogTime(TEXT("IWiaItem::EnumChildItems"), liDiff);
        m_pTest->LogAPI(TEXT("IWiaItem::EnumChildItems"), NOERROR);
        ZeroMemory (&lvi, sizeof(lvi));
        lvi.mask = LVIF_IMAGE | LVIF_TEXT;
        QueryPerformanceCounter (&li2);
        while (NOERROR == pEnum->Next (1, &pItem, &ul))
        {

            DRAWINFO Info;
            if (SUCCEEDED(GetNameAndThumbnail (pItem, szName, &Info)))
            {

                lvi.pszText = szName;
                lvi.iImage = ImageList_Add (m_himl, Info.hbmp, NULL);

                ListView_InsertItem (hList, &lvi);
                DeleteObject (Info.hbmp);
            }
            pItem = NULL;
        }
        ListView_SetIconSpacing (hList, m_iWidth+16, m_iHeight+32);
        ListView_SetImageList (hList, m_himl, LVSIL_NORMAL);
        QueryPerformanceCounter (&li3);
        GETDIFF (li3, li2);
        m_pTest->LogTime(TEXT("Add thumbnails to listview"), liDiff);

    }

}



INT_PTR CALLBACK
CThumbsDlg::ShowThumbsDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);

            break;

    }
    CThumbsDlg *pThis = reinterpret_cast<CThumbsDlg*>(GetWindowLongPtr(hwnd, DWLP_USER));
    return pThis->RealDlgProc (hwnd, msg ,wp ,lp);

}

INT_PTR
CThumbsDlg::RealDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{

    switch (msg)
    {
        case WM_INITDIALOG:
            m_hwnd = hwnd;
            PostMessage (hwnd, WM_USER+10, 0, 0);

            return TRUE;

        case WM_USER+10:
            TimeEnumThumbnails ();
            PostMessage (hwnd, WM_CLOSE, 0, 0);

            return TRUE;

        case WM_CLOSE:

            EndDialog (hwnd, 0);
            return TRUE;
    }
    return FALSE;
}

VOID
CThumbsDlg::ShowDlg()
{

    HRESULT hr;
    QueryPerformanceCounter (&li1);

    hr = g_pDevMgr->CreateDevice (m_strDeviceId, &m_pDevice);
    if (SUCCEEDED(hr))
    {
        QueryPerformanceCounter (&li2);
        GETDIFF (li2, li1);
        m_pTest->LogTime(TEXT("IWiaDevMgr::CreateDevice"), liDiff);
    }

    m_pTest->LogAPI (TEXT("IWiaDevMgr::CreateDevice"), hr);

    GetThumbSize (m_pDevice, &m_iWidth, &m_iHeight);

    m_himl = ImageList_Create (m_iWidth, m_iHeight, ILC_COLOR24, 10, 50);

    DialogBoxParam (GetModuleHandle (NULL),
                    MAKEINTRESOURCE (IDD_SHOWTHUMBS),
                    NULL,
                    ShowThumbsDlgProc,
                    reinterpret_cast<LPARAM>(this));
    QueryPerformanceCounter (&li2);
    GETDIFF (li2, li1);
    m_pTest->LogTime (TEXT("Complete enumeration of thumbnails"), liDiff);
}

CThumbsDlg::CThumbsDlg(CTest *pTest, BSTR strDeviceId)
{
    m_pTest = pTest;
    m_strDeviceId = strDeviceId;

}
VOID
CTest::TstShowThumbs(CTest *pThis, BSTR strDeviceId)
{
    INITCOMMONCONTROLSEX ice;

    CThumbsDlg dlg(pThis, strDeviceId);
    ice.dwSize = sizeof(ice);
    ice.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx (&ice);
    pThis->LogString(TEXT("-->Begin thumbnail enumeration test"));

    dlg.ShowDlg ();
    pThis->LogString(TEXT("<--End thumbnail enumeration test"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\tools.h ===
#ifndef _TOOLS_H
#define _TOOLS_H

VOID Trace(LPCTSTR Format, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\tools.cpp ===
#include "stdafx.h"
#include "Tools.h"
#include "msgwrap.h"

extern CMessageWrapper g_MsgWrapper;

//////////////////////////////////////////////////////////////////////////
//
// Function: Trace()
// Details:  This function displays a string to the debugger, (for tracing)
// Remarks:  The Trace() function compiles to nothing, when building release.
//
// format        - String to display to the debugger
//
//////////////////////////////////////////////////////////////////////////

VOID Trace(LPCTSTR format,...)
{
    
#ifdef _DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\sources.inc ===
#
# Builds a simple windows-based test program
#

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiaregme
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMTYPE=windows

INCLUDES=$(INCLUDES)

SOURCES= \
        ..\wiaregme.cpp \
        ..\msgwrap.cpp  \
        ..\clistbox.cpp \
        ..\tools.cpp    \
        ..\wiaregme.rc

USE_NATIVE_EH=1
USE_MSVCRT=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\comctl32.lib \
            $(SDK_LIB_PATH)\wiaguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\msgwrap.h ===
#ifndef _MSGWRAPPER_H
#define _MSGWRAPPER_H

class CMessageWrapper {
public:
	CMessageWrapper();
	~CMessageWrapper();

	VOID Initialize(HINSTANCE hInstance);
	
	BOOL OnInitDialog(HWND hDlg);
	BOOL OnAbout(HWND hDlg);
	BOOL OnExit(HWND hDlg, WPARAM wParam);
    BOOL OnBrowse(HWND hDlg, LPTSTR szApplicationFilePath);
    BOOL Register(HWND hDlg, long lFlags);
    BOOL OnRefreshDeviceListBox(HWND hDlg);
    BOOL OnRefreshEventListBox(HWND hDlg);
	LPTSTR GetResourceString(INT ResourceID, LPTSTR szString, INT isize = 255);
    VOID EnableAllControls(HWND hDlg, bool bEnable);
private:
	VOID DisplayError(INT ErrorCode);	
protected:
	HINSTANCE m_hInstance;
	HICON m_hSmallIcon;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiaregme.rc
//
#define IDC_MYICON                      2
#define IDD_DIALOG_DIALOG               102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   104
#define IDM_ABOUT                       105
#define IDM_EXIT                        106
#define IDS_HELLO                       107
#define IDI_DIALOG                      108
#define IDI_SMALL                       109
#define IDC_DIALOG                      110
#define IDC_DIALOG_MENU                 111
#define IDS_DIALOG_TITLE                112
#define IDS_DIALOG_ABOUT_TEXT           113
#define IDS_DIALOG_ABOUT_TITLE          114
#define IDS_DIALOG_ERROR_TITLE          115
#define IDS_DIALOG_BROWSE_TITLE         116
#define IDS_NO_WIA_DEVICES              117
#define IDS_NO_WIA_EVENTS               118
#define IDS_SUCCESSFUL_REGISTER         119
#define IDS_UNSUCCESSFUL_REGISTER       120
#define IDR_MAINFRAME                   128
#define IDD_MAIN_DIALOG                 129
#define IDC_WIA_DEVICE_LIST             1000
#define IDC_BROWSE_BUTTON               1001
#define IDC_WIA_EVENT_LIST              1002
#define IDC_COMMAND_LINE_ARGS_EDITBOX   1003
#define IDC_APPLICATION_LAUNCH_PATH_EDITBOX 1004
#define IDC_REGISTER_BUTTON             1005
#define IDC_UNREGISTER_BUTTON           1006
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           116
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\wiaregme.h ===
#ifndef _WIAREGME_H
#define _WIAREGME_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "resource.h"

#define _ERROR_POPUP // Error dialogs will popup to the user

LRESULT CALLBACK MainDlg(HWND, UINT, WPARAM, LPARAM);

#ifdef _OVERRIDE_LIST_BOXES // to override the list box functionality

LRESULT CALLBACK DeviceListBox(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK EventListBox(HWND, UINT, WPARAM, LPARAM);

WNDPROC DefDeviceListBox;
WNDPROC DefEventListBox;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\msgwrap.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "msgwrap.h"
#include "clistbox.h"

#ifdef _OVERRIDE_LIST_BOXES

//////////////////////////////////////////////////////////////////////////
//
// extern global functions
// Details:  DeviceListBox()  - Controls the WIA device list box
//           EventListBox()   - Controls the WIA event list box
//
//////////////////////////////////////////////////////////////////////////

extern LRESULT CALLBACK DeviceListBox(HWND, UINT, WPARAM, LPARAM);
extern LRESULT CALLBACK EventListBox(HWND, UINT, WPARAM, LPARAM);
extern WNDPROC DefDeviceListBox;
extern WNDPROC DefEventListBox;

#endif

#define _REGISTER_ON

//////////////////////////////////////////////////////////////////////////
//
// Function: CMessageWrapper()
// Details:  Constructor
//
//
//////////////////////////////////////////////////////////////////////////

CMessageWrapper::CMessageWrapper()
{
	m_hInstance = NULL;
	m_hSmallIcon = NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: ~CMessageWrapper()
// Details:  Destructor
//
//
//////////////////////////////////////////////////////////////////////////

CMessageWrapper::~CMessageWrapper()
{
	//
	// free Icon??? (m_hSmallIcon)
	//
}

//////////////////////////////////////////////////////////////////////////
//
// Function: Initialize()
// Details:  This function handles all initialization for the message wrapper
//
// hInstance      - handle to the application's instance
//
//////////////////////////////////////////////////////////////////////////

VOID CMessageWrapper::Initialize(HINSTANCE hInstance)
{
	m_hInstance = hInstance;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnInitDialog()
// Details:  This function handles all initialization for the dialog.
//           This includes control initialization.
//
// hDlg          - handle to the dialog's window
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnInitDialog(HWND hDlg)
{	
	TCHAR szString[255];

	//
	// Set dialog's title
	//

	if(!SetWindowText(hDlg,GetResourceString(IDS_DIALOG_TITLE, szString))) {
		Trace(TEXT("Could not set dialog's window title."));
	}

	//
	// Set dialog's small icon
	//

	m_hSmallIcon = LoadIcon(m_hInstance,MAKEINTRESOURCE(IDI_SMALL));
	if(m_hSmallIcon) {
		SendMessage(hDlg,WM_SETICON,(WPARAM)ICON_SMALL,(LPARAM)m_hSmallIcon);
	} else {
		Trace(TEXT("Could not load Small icon from dialog resource."));
	}

    //
    // Initialize WIA Device List box
    //

    if(!OnRefreshDeviceListBox(hDlg)){
        EnableAllControls(hDlg,FALSE);
    } else {
        EnableAllControls(hDlg,TRUE);
    }

#ifdef _OVERRIDE_LIST_BOXES

    HWND hListBox = NULL;
    hListBox = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
    if(NULL != hListBox) {

        DefDeviceListBox = (WNDPROC)GetWindowLongPtr(hListBox,GWL_WNDPROC);
        SetWindowLongPtr(hListBox,GWL_WNDPROC,(LONG_PTR)DeviceListBox);
        OnRefreshDeviceListBox(hDlg);
    }

#endif

    //
    // Initialize WIA Device Event List box
    //

    if(!OnRefreshEventListBox(hDlg)){
        EnableAllControls(hDlg,FALSE);
    } else {
        EnableAllControls(hDlg,TRUE);
    }

#ifdef _OVERRIDE_LIST_BOXES

    HWND hEventListBox = NULL;
    hEventListBox      = GetDlgItem(hDlg,IDC_WIA_EVENT_LIST);
    if(NULL != hEventListBox) {
        DefEventListBox = (WNDPROC)GetWindowLongPtr(hEventListBox,GWL_WNDPROC);
        SetWindowLongPtr(hEventListBox,GWL_WNDPROC,(LONG_PTR)EventListBox);
        OnRefreshEventListBox(hDlg);
    }

#endif
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnAbout()
// Details:  This function handles the "About" information for the dialog.
//
// hDlg          - handle to the dialog's window
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnAbout(HWND hDlg)
{
	TCHAR szString[255];
	TCHAR szStringTitle[255];
	MessageBox(hDlg,GetResourceString(IDS_DIALOG_ABOUT_TEXT, szString),
		            GetResourceString(IDS_DIALOG_ABOUT_TITLE, szStringTitle),MB_OK);
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnExit()
// Details:  This function handles the exiting for the dialog.
//
// hDlg          - handle to the dialog's window
// wParam        - WPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnExit(HWND hDlg, WPARAM wParam)
{

	//
	// clean up any things here, and exit using the Window's API EndDialog()
	//

	return EndDialog(hDlg, LOWORD(wParam));	
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnBrowse()
// Details:  This function handles the Browse functionality for the dialog.
//
// hDlg                   - handle to the dialog's window
// szApplicationFilePath  - File path to selected application
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnBrowse(HWND hDlg, LPTSTR szApplicationFilePath)
{
    OPENFILENAME ofn;      // common dialog box structure
    TCHAR szString[255];   // string for title display
    // Initialize OPENFILENAME

    char szFile[260];              // buffer for file name
    char szBrowseDialogTitle[260]; // buffer for dialog title
    
    ZeroMemory(szFile,sizeof(szFile));
    ZeroMemory(szBrowseDialogTitle,sizeof(szBrowseDialogTitle));
    
    GetResourceString(IDS_DIALOG_BROWSE_TITLE,szBrowseDialogTitle,sizeof(szBrowseDialogTitle));

    HWND hListBox = NULL;
    hListBox = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
    if(NULL != hListBox) {        
        CListBoxUtil DevListBox(hListBox);
        BSTR bstrDeviceID = NULL;
        DevListBox.GetCurSelTextAndData(szString,(void**)&bstrDeviceID);
        lstrcat(szBrowseDialogTitle,szString);        
    } else {
        return FALSE;
    }

    ZeroMemory(&ofn, sizeof(OPENFILENAME));
    ofn.lStructSize     = sizeof(OPENFILENAME);
    ofn.hwndOwner       = hDlg;
    ofn.lpstrFile       = szFile;
    ofn.nMaxFile        = sizeof(szFile);
    ofn.lpstrFilter     = "*.EXE\0*.EXE\0";
    ofn.nFilterIndex    = 1;
    ofn.lpstrFileTitle  = NULL;
    ofn.nMaxFileTitle   = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle      = szBrowseDialogTitle;
    ofn.Flags           = 0;
    
    //
    // Display the Open dialog box. 
    //
    
    if (GetOpenFileName(&ofn) == TRUE){
        lstrcpy(szApplicationFilePath, szFile);    
    } else {
        return FALSE;
    }
        
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: Register()
// Details:  This function handles the Application Registration for the dialog.
//
// hDlg          - handle to the dialog's window
// lFlags        - WIA_REGISTER_EVENT_CALLBACK, or WIA_UNREGISTER_EVENT_CALLBACK
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::Register(HWND hDlg, long lFlags)
{    
    TCHAR szCommandLine[1024];
    TCHAR szArgs[1024];
    memset(szCommandLine,0,sizeof(szCommandLine));
    memset(szArgs,0,sizeof(szArgs));
    
    BSTR bstrDeviceID    = NULL;                        
    BSTR bstrCommandline = NULL;
    BSTR bstrName        = NULL;
    BSTR bstrDescription = NULL;
    
    GUID *pEventGUID     = NULL;    
    
    HWND hCommandLineEditBox = NULL;
    hCommandLineEditBox = GetDlgItem(hDlg,IDC_APPLICATION_LAUNCH_PATH_EDITBOX);
    if(NULL != hCommandLineEditBox){
        GetWindowText(hCommandLineEditBox,szCommandLine,sizeof(szCommandLine));
        if(lstrlen(szCommandLine) > 0) {
            
            //
            // add any additional command-line arguments, if needed to 
            // the command line.
            //
            
            HWND hCommandLineArgumentsEditBox = NULL;
            hCommandLineArgumentsEditBox = GetDlgItem(hDlg,IDC_COMMAND_LINE_ARGS_EDITBOX);
            if(NULL != hCommandLineArgumentsEditBox){
                GetWindowText(hCommandLineArgumentsEditBox,szArgs,sizeof(szArgs));
                if(lstrlen(szArgs) > 0){
                    lstrcat(szCommandLine,TEXT(" "));
                    lstrcat(szCommandLine,szArgs);
                }
            }
            
            //
            // we have a command-line, so lets use it to register the
            // application.
            //
            
            HRESULT hr               = S_OK;
            IWiaDevMgr  *pIWiaDevMgr = NULL;
            
            hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
                IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
            if(SUCCEEDED(hr)){
                if(NULL != pIWiaDevMgr){
                    
                    //
                    // Get EVENT GUID
                    //
                    
                    HWND hEventListBox = NULL;
                    hEventListBox      = GetDlgItem(hDlg,IDC_WIA_EVENT_LIST);
                    if(NULL != hEventListBox) {
                        CListBoxUtil EvListBox(hEventListBox);                       
                        TCHAR szEventName[255];
                        EvListBox.GetCurSelTextAndData(szEventName,(void**)&pEventGUID);
                        if(*pEventGUID != GUID_NULL){

                            //
                            // Get DEVICE ID
                            //
                            
                            HWND hListBox = NULL;
                            hListBox = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
                            if(NULL != hListBox) {
                                CListBoxUtil DevListBox(hListBox);                                                                        
                                TCHAR szDeviceName[255];
                                DevListBox.GetCurSelTextAndData(szDeviceName,(void**)&bstrDeviceID);
                                
                                if(bstrDeviceID != NULL){                            
#ifdef UNICODE              
                                    WCHAR wszAppName[255];
                                    memset(wszAppName,0,sizeof(wszAppName));
                                    bstrCommandline = SysAllocString(szCommandLine);
                                    _wsplitpath(szCommandLine, NULL, NULL, wszAppName, NULL);
                                    bstrName        = SysAllocString(wszAppName);
#else
                                    //
                                    // convert char to wchar, so we can create a BSTRs properly
                                    //
                                    
                                    WCHAR wszCommandLine[1024];
                                    WCHAR wszAppName[255];
                                    memset(wszCommandLine,0,sizeof(wszCommandLine));
                                    memset(wszAppName,0,sizeof(wszAppName));
                                    
                                    MultiByteToWideChar(CP_ACP, 0,szCommandLine,-1,wszCommandLine,sizeof(wszCommandLine));                            
                                    _wsplitpath(wszCommandLine, NULL, NULL, wszAppName, NULL);
                                    bstrCommandline = SysAllocString(wszCommandLine);
                                    bstrName        = SysAllocString(wszAppName);
#endif                            
                                    Trace(TEXT("Register This command Line: %ws"),bstrCommandline);
                                    Trace(TEXT("Register with this Name: %ws"),bstrName);
                                    WCHAR *pszGUID = NULL;                                    
                                    StringFromCLSID(*pEventGUID,&pszGUID);
                                    if(NULL != pszGUID) {
                                        Trace(TEXT("Register with this GUID: %ws"),pszGUID);
                                        CoTaskMemFree(pszGUID);
                                    } else {
                                        Trace(TEXT("Register with this GUID: BAD GUID!!"));
                                    }
#ifdef _REGISTER_ON
                                    hr = pIWiaDevMgr->RegisterEventCallbackProgram(
                                        lFlags,
                                        bstrDeviceID,
                                        pEventGUID,
                                        bstrCommandline,
                                        bstrName,
                                        bstrName,
                                        bstrCommandline);                        
                                                                        
                                    TCHAR szText[255];
                                    TCHAR szCaption[255];
                                    memset(szText,0,sizeof(szText));
                                    memset(szCaption,0,sizeof(szCaption));

                                    if(SUCCEEDED(hr)){
                                        GetResourceString(IDS_SUCCESSFUL_REGISTER,szText,sizeof(szText));
                                        GetResourceString(IDS_DIALOG_TITLE,szCaption,sizeof(szCaption));
                                        MessageBox(hDlg,szText,szCaption,MB_OK);                                        
                                    } else {                                        
                                        TCHAR szErrorCode[255];
                                        memset(szErrorCode,0,sizeof(szErrorCode));
                                        GetResourceString(IDS_UNSUCCESSFUL_REGISTER,szText,sizeof(szText));
                                        sprintf(szErrorCode,TEXT(" hr = 0x%X"),hr);
                                        lstrcat(szText,szErrorCode);
                                        GetResourceString(IDS_DIALOG_ERROR_TITLE,szCaption,sizeof(szCaption));
                                        MessageBox(hDlg,szText,szCaption,MB_ICONERROR);
                                    }
#endif                                    
                                    //
                                    // free and allocated strings
                                    //
                                    
                                    if(NULL != bstrCommandline){
                                        SysFreeString(bstrCommandline);
                                    }
                                    
                                    if(NULL != bstrName){
                                        SysFreeString(bstrName);
                                    }
                                }
                            }
                        }
                    }
                                                            
                    pIWiaDevMgr->Release();
                    pIWiaDevMgr = NULL;
                }
            } else {
                return FALSE;
            }
            
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//
// Function: OnRefreshDeviceListBox()
// Details:  This function handles refreshing the WIA device ListBox for the dialog.
//
// hDlg          - handle to the dialog's window
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnRefreshDeviceListBox(HWND hDlg)
{
    HWND hListBox = NULL;
    int iDeviceCount = 0;
    
    //
    // grab the WIA device list box
    //

    hListBox      = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
    
    if(NULL != hListBox) {

        //
        // setup utils, and continue
        //

        CListBoxUtil DevListBox(hListBox);
        
        //
        // clean device listbox
        //
            
        DevListBox.ResetContent();

        HRESULT hr               = S_OK;
        ULONG ulFetched          = 0;
        IWiaDevMgr  *pIWiaDevMgr = NULL;
        hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
        if(SUCCEEDED(hr)){
            if(NULL != pIWiaDevMgr){
                IWiaPropertyStorage    *pIWiaPropStg    = NULL;
                IEnumWIA_DEV_INFO      *pWiaEnumDevInfo = NULL;
                
                //
                // enumerate WIA devices
                //

                hr = pIWiaDevMgr->EnumDeviceInfo(WIA_DEVINFO_ENUM_LOCAL,&pWiaEnumDevInfo);
                if (SUCCEEDED(hr)){

                    //
                    // call reset, just in case
                    //

                    hr = pWiaEnumDevInfo->Reset();
                    if (SUCCEEDED(hr)) {
                        do {

                            //
                            // call NEXT()
                            //

                            hr = pWiaEnumDevInfo->Next(1,&pIWiaPropStg,&ulFetched);
                            if (hr == S_OK) {
                                if(ulFetched > 0){                                                                                            
                                    
                                    //
                                    // we have a device, so increment the
                                    // device counter
                                    //

                                    iDeviceCount++;

                                    PROPSPEC        PropSpec[2];
                                    PROPVARIANT     PropVar [2];
                                    
                                    //
                                    // clean the propvar
                                    //

                                    memset(PropVar,0,sizeof(PropVar));
                                    
                                    PropSpec[0].ulKind = PRSPEC_PROPID;
                                    PropSpec[0].propid = WIA_DIP_DEV_ID;
                                    
                                    PropSpec[1].ulKind = PRSPEC_PROPID;
                                    PropSpec[1].propid = WIA_DIP_DEV_NAME;
                                    
                                    //
                                    // read the device name, and device ID
                                    //

                                    hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                        PropSpec,
                                        PropVar);
                                    
                                    if (hr == S_OK) {

                                        //
                                        // write device name to the listbox, and save the
                                        // device ID for later use (EVENT ENUMERATION)
                                        //

                                        Trace(TEXT("Device Name: %ws"),PropVar[1].bstrVal);
                                        Trace(TEXT("Device ID:   %ws"),PropVar[0].bstrVal);

                                        //
                                        // convert the BSTR to a CHAR, and copy the BSTR
                                        // for later use (DEVICE CREATION)
                                        //

                                        TCHAR szString[255];
                                        sprintf(szString,TEXT("%ws"),PropVar[1].bstrVal);
                                        BSTR bstrDeviceID = SysAllocString(PropVar[0].bstrVal);
                                        
                                        //
                                        // add information to the listbox
                                        //

                                        DevListBox.AddStringAndData(szString,(void*)bstrDeviceID);
                                        
                                        //
                                        // free propvariant array
                                        //

                                        FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);
                                                                                
                                        //
                                        // release property storage
                                        //

                                        pIWiaPropStg->Release();
                                        pIWiaPropStg = NULL;

                                    } else
                                        Trace(TEXT("ReadMultiple() Failed while reading device name,server,and deviceID"));
                                } else {

                                    //
                                    // force enumeration to exit cleanly
                                    //

                                    hr = S_FALSE;
                                }
                            } else if (hr == S_FALSE) {                            

                                //
                                // end of enumeration
                                //

                            } else
                                Trace(TEXT("Next() Failed requesting 1 item"));                        
                        } while (hr == S_OK);                    
                    } else
                        Trace(TEXT("Reset() Failed"));
                } else{
                    Trace(TEXT("EnumDeviceInfo Failed"));
                    return FALSE;
                }
            } else {
                Trace(TEXT("WIA Device Manager is NULL"));
                return FALSE;
            }
            
            //
            // release WIA device manager
            //

            if(pIWiaDevMgr){
                pIWiaDevMgr->Release();
                pIWiaDevMgr = NULL;
            }
        }
        
        //
        // if no WIA devices were found during enumeration
        // set a nice message inthe list box for the users to 
        // see.
        //

        if(iDeviceCount == 0){
            TCHAR szString[255];
            GetResourceString(IDS_NO_WIA_DEVICES, szString, sizeof(szString));            
            DevListBox.AddStringAndData(szString,NULL);

            //
            // always default to the first selection in the listbox
            //
            
            DevListBox.SetCurSel(0);
            return FALSE; // no devices
        }

        //
        // always default to the first selection in the listbox
        //

        DevListBox.SetCurSel(0);
        return TRUE;
    }            
    return FALSE;    
}

//////////////////////////////////////////////////////////////////////////
//
// Function: OnRefreshEventListBox()
// Details:  This function handles the WIA event ListBox for the dialog.
//
// hDlg          - handle to the dialog's window
//
//////////////////////////////////////////////////////////////////////////

BOOL CMessageWrapper::OnRefreshEventListBox(HWND hDlg)
{    
    HWND hListBox    = NULL;
    HWND hDevListBox = NULL;
    int iEventCount = 0;

    //
    // grab both list box windows
    //

    hListBox = GetDlgItem(hDlg,IDC_WIA_EVENT_LIST);    
    hDevListBox = GetDlgItem(hDlg,IDC_WIA_DEVICE_LIST);
    
    if((NULL != hListBox)&&NULL != hDevListBox) {

        //
        // setup utils, and continue
        //

        CListBoxUtil EvListBox(hListBox);
        CListBoxUtil DevListBox(hDevListBox);
                    
        //
        // clean event listbox
        //
            
        EvListBox.ResetContent();
        
        HRESULT hr               = S_OK;
        ULONG ulFetched          = 0;
        IWiaDevMgr  *pIWiaDevMgr = NULL;
        IWiaItem    *pIWiaDevice = NULL;
        BSTR bstrDeviceID        = NULL;
        TCHAR szDeviceName[255];
        hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
        if(SUCCEEDED(hr)){
            if(NULL != pIWiaDevMgr){                
                DevListBox.GetCurSelTextAndData(szDeviceName,(void**)&bstrDeviceID);
                if(NULL != bstrDeviceID) {
                    hr = pIWiaDevMgr->CreateDevice(bstrDeviceID,&pIWiaDevice);
                    if(SUCCEEDED(hr)){
                        IEnumWIA_DEV_CAPS   *pIEnumDeviceCaps = NULL;
                        hr = pIWiaDevice->EnumDeviceCapabilities(WIA_DEVICE_EVENTS, &pIEnumDeviceCaps);
                        if(SUCCEEDED(hr)){

                            //
                            // enumerate EVENTS onlym looking specifically for
                            // action events..
                            //

                            do {
                                
                                //
                                // clean DEV info structure
                                //

                                WIA_DEV_CAP DevInfo;
                                memset(&DevInfo,0,sizeof(WIA_DEV_CAP));

                                //
                                // call NEXT()
                                //

                                hr = pIEnumDeviceCaps->Next(1,&DevInfo,&ulFetched);
                                if (hr == S_OK) {
                                    if(ulFetched > 0){

                                        //
                                        // are we an ACTION event??
                                        //

                                        if(DevInfo.ulFlags & WIA_ACTION_EVENT){
                                            TCHAR szString[255];
                                            sprintf(szString,TEXT("%ws"),DevInfo.bstrName);
                                            GUID *pEventGUID = new GUID;
                                            memcpy(pEventGUID, &DevInfo.guid, sizeof(GUID));
                                            EvListBox.AddStringAndData(szString,(void*)pEventGUID);

                                            //
                                            // since we have an ACTION event, increment
                                            // the event counter
                                            //

                                            iEventCount++;
                                        }                                        
                                    } else {

                                        //
                                        // force enumeration to exit cleanly
                                        //

                                        hr = S_FALSE;
                                    }
                                } else if (hr == S_FALSE) {

                                    //
                                    // end  of enumeration
                                    //
                                    
                                } else {
                                    Trace(TEXT("Next() Failed requesting 1 item"));
                                }
                            } while (hr == S_OK);                            
                        }

                        //
                        // release WIA device
                        //

                        pIWiaDevice->Release();
                        pIWiaDevice = NULL;
                    }
                }

                //
                // release WIA device manager
                //

                pIWiaDevMgr->Release();
                pIWiaDevMgr = NULL;                                                
            }            
        }

        //
        // if no ACTION events were found during enumeration
        // set a nice message inthe list box for the users to 
        // see.
        //

        if(iEventCount == 0){
            TCHAR szString[255];
            GetResourceString(IDS_NO_WIA_EVENTS, szString, sizeof(szString));            
            EvListBox.AddStringAndData(szString,NULL);

            //
            // always default to the first selection in the listbox
            //
            
            EvListBox.SetCurSel(0);
            return FALSE; // no devices
        }

        //
        // always default to the first selection in the listbox
        //

        EvListBox.SetCurSel(0);
        return TRUE;
    }            
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: EnableAllControls()
// Details:  This function enables/disables buttons, on the main dialog.
//
// bEnable     - Resource ID of the Error Code string
// hDlg        - Handle to parent window
//
//////////////////////////////////////////////////////////////////////////

VOID CMessageWrapper::EnableAllControls(HWND hDlg, bool bEnable)
{
    HWND hWindow = NULL;
    
    hWindow = GetDlgItem(hDlg,IDC_BROWSE_BUTTON);
    if(NULL != hWindow){
        EnableWindow(hWindow,bEnable);
    }
    hWindow = GetDlgItem(hDlg,IDC_REGISTER_BUTTON);
    if(NULL != hWindow){
        EnableWindow(hWindow,bEnable);
    }
    hWindow = GetDlgItem(hDlg,IDC_UNREGISTER_BUTTON);
    if(NULL != hWindow){
        EnableWindow(hWindow,bEnable);
    }
}

//////////////////////////////////////////////////////////////////////////
//
// Function: DisplayError()
// Details:  This function fills a string, loaded from the application's
//           resource, and display's it as an error dialog to the user.
//
// ErrorCode     - Resource ID of the Error Code string
//
//////////////////////////////////////////////////////////////////////////

VOID CMessageWrapper::DisplayError(INT ErrorCode)
{
	TCHAR szString[255];
	GetResourceString(ErrorCode, szString);

#ifdef _ERROR_POPUP	
	TCHAR szStringTitle[255];
	MessageBox(NULL,szString,
		            GetResourceString(IDS_DIALOG_ERROR_TITLE, szStringTitle),
					MB_OK|MB_ICONERROR);
#endif

	Trace(TEXT("Error Dialog: %s\n"),szString);
}

//////////////////////////////////////////////////////////////////////////
//
// Function: GetResourceString()
// Details:  This function fills a string, loaded from the application's
//           resource.
//
// ResourceID    - Resource ID of the error code's text
// szString      - String to be filled with the resource value
// isize         - Size of the string buffer, in BYTES
//
//////////////////////////////////////////////////////////////////////////

LPTSTR CMessageWrapper::GetResourceString(INT ResourceID, LPTSTR szString, INT isize)
{
	LoadString(m_hInstance,ResourceID,szString,isize);
	return szString;
}

/*

  //
  // get Device ID
  //

  BSTR bstrDeviceID = NULL;
  DevListBox.GetCurSelTextAndData(szString,(void**)&bstrDeviceID);
  Trace(TEXT("Device ID String = %ws"),bstrDeviceID);

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiaregme\wiaregme.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "wiaregme.h"
#include "msgwrap.h"

CMessageWrapper g_MsgWrapper;

//////////////////////////////////////////////////////////////////////////
//
// Function: WinMain()
// Details:  This function is WinMain... enough said. ;) It creates a Modal
//           dialog as the main application window.
//
// hInstance     - instance of this application
// hPrevInstance - Previous instance of this applcation (already running)
// lpCmdLine     - command line arguments
// nCmdShow      - show state, specifies how the window should be shown
//
//////////////////////////////////////////////////////////////////////////

INT APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    CoInitialize(NULL);
    g_MsgWrapper.Initialize(hInstance);
    DialogBox(hInstance, (LPCTSTR)IDD_MAIN_DIALOG, NULL, (DLGPROC)MainDlg);
    CoUninitialize();
    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// Function: MainDlg()
// Details:  This function is the Window Proc for this dialog.  It
//           dispatches messages to their correct handlers.  If there is
//           handler, we let Windows handle the message for us.
//
// hDlg          - handle to the dialog's window
// message       - windows message (incoming from system)
// wParam        - WPARAM parameter (used for windows data/argument passing)
// lParam        - LPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MainDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT wmId    = 0;
    INT wmEvent = 0;

    TCHAR szApplicationFilePath[1024];
    HWND  hApplicationPathEditBox = NULL;

    switch (message)
    {
        //
        // We want first crack at processing any messages
        //

        case WM_INITDIALOG:            
            return g_MsgWrapper.OnInitDialog(hDlg);        
            break;
        case WM_COMMAND:
            wmId    = LOWORD(wParam);
            wmEvent = HIWORD(wParam);

            switch(wmId)
            {
                //
                // Trap Button IDs, and Menu IDs
                //
                
                case IDC_WIA_DEVICE_LIST:
                    if(wmEvent == LBN_SELCHANGE){
                        if(!g_MsgWrapper.OnRefreshEventListBox(hDlg)){
                            g_MsgWrapper.EnableAllControls(hDlg, FALSE);
                        } else {
                            g_MsgWrapper.EnableAllControls(hDlg, TRUE);
                        }
                    }
                    break;
                case IDC_BROWSE_BUTTON:               // BROWSE       (Button)
                    if(g_MsgWrapper.OnBrowse(hDlg,szApplicationFilePath)){

                        //
                        // register this Application Path
                        //
                        
                        hApplicationPathEditBox = GetDlgItem(hDlg,IDC_APPLICATION_LAUNCH_PATH_EDITBOX);
                        SetWindowText(hApplicationPathEditBox,szApplicationFilePath);
                    }
                    break;
                case IDC_REGISTER_BUTTON:             // REGISTER     (Button)
                    if(g_MsgWrapper.Register(hDlg,WIA_REGISTER_EVENT_CALLBACK)){

                    }
                    break;
                case IDC_UNREGISTER_BUTTON:           // UNREGISTER   (Button)
                    if(g_MsgWrapper.Register(hDlg,WIA_UNREGISTER_EVENT_CALLBACK)){

                    }
                    break;
                case IDCANCEL:                        // CANCEL       (Button)
                case IDM_EXIT:                        // FILE | EXIT  (Menu)
                    return g_MsgWrapper.OnExit(hDlg,wParam);
                    break;
                case IDM_ABOUT:                       // HELP | ABOUT (Menu)
                    g_MsgWrapper.OnAbout(hDlg);
                    break;
                default:
                    break;
            }
            break;
        default:

            //
            // Let windows take care of it (DefWindowProc(hDlg,message,wParam,lParam))
            //

            break;
    }
    return FALSE;
}

#ifdef _OVERRIDE_LIST_BOXES

//////////////////////////////////////////////////////////////////////////
//
// Function: DeviceListBox()
// Details:  This function is the Window Proc for the Device ListBox.  It
//           dispatches messages to their correct handlers.  If there is
//           handler, we let Windows handle the message for us.
//
// hDlg          - handle to the dialog's window
// message       - windows message (incoming from system)
// wParam        - WPARAM parameter (used for windows data/argument passing)
// lParam        - LPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK DeviceListBox(HWND hListBox, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT wmId    = 0;
    INT wmEvent = 0;

    return DefDeviceListBox(hListBox,message,wParam,lParam);
}

//////////////////////////////////////////////////////////////////////////
//
// Function: EventListBox()
// Details:  This function is the Window Proc for the Event ListBox.  It
//           dispatches messages to their correct handlers.  If there is
//           handler, we let Windows handle the message for us.
//
// hDlg          - handle to the dialog's window
// message       - windows message (incoming from system)
// wParam        - WPARAM parameter (used for windows data/argument passing)
// lParam        - LPARAM parameter (used for windows data/argument passing)
//
//////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK EventListBox(HWND hListBox, UINT message, WPARAM wParam, LPARAM lParam)
{
    INT wmId    = 0;
    INT wmEvent = 0;

    return DefEventListBox(hListBox,message,wParam,lParam);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\argv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    argv.h

Abstract:

    Implementation of CommandLineToArgv() API

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef __ARGV_H
#define __ARGV_H

#include <assert.h>

#ifndef ASSERT
#define ASSERT assert
#endif //ASSERT

PTSTR * 
CommandLineToArgv(
    PCTSTR  pCmdLine,
    int    *pNumArgs
);

#ifdef IMPLEMENT_ARGV

//////////////////////////////////////////////////////////////////////////
//
// Parse_Cmdline
//
// Stolen directly from NT sources
//

void Parse_Cmdline (
    LPCTSTR cmdstart,
    LPTSTR*argv,
    LPTSTR lpstr,
    INT *numargs,
    INT *numbytes
)
{
    LPCTSTR p;
    TCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(TCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(TCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(TCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = (TCHAR) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(TCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(TCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(TCHAR);
    }

}

//////////////////////////////////////////////////////////////////////////
//
// CommandLineToArgv
//

PTSTR * 
CommandLineToArgv(
    PCTSTR  pCmdLine,
    int    *pNumArgs
)
{	
    ASSERT(pNumArgs);

    INT numbytes = 0;

    Parse_Cmdline(pCmdLine, 0, 0, pNumArgs, &numbytes);

    PTSTR *argv = (PTSTR *) LocalAlloc( 
	    LMEM_FIXED | LMEM_ZEROINIT,
        *pNumArgs * sizeof(PTSTR) + numbytes
    );

    if (argv) 
    {
	    Parse_Cmdline(
		    pCmdLine, 
		    argv,
            (PTSTR) ((PBYTE) argv + *pNumArgs * sizeof(PTSTR)),
            pNumArgs, 
		    &numbytes
	    );
    }

    return argv;
}		

#endif //IMPLEMENT_ARGV

#endif //__ARGV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\conv.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef __CONV_H__
#define __CONV_H__

//////////////////////////////////////////////////////////////////////////
//
// cross dependencies
//

#include <winnt.h>
#include <winbase.h>
#include <winnls.h>
#include <malloc.h>

//////////////////////////////////////////////////////////////////////////
//
// in case MFC or ATL conversion helpers are already defined, undef these
//

#undef USES_CONVERSION
#undef W2A
#undef A2W
#undef T2A
#undef A2T
#undef T2W
#undef W2T
#undef T2O
#undef O2T
#undef T2DA
#undef A2DT
#undef T2DW
#undef W2DT
#undef _wcsdupa
#undef _strdupa
#undef _tcsdupa

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    lstrcpyW((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))  \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    lstrcpyA((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))      \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T, T2O, O2T, T2DA, A2DT, T2DW, W2DT
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr)   W2A(pStr)
	#define A2T(pStr)   A2W(pStr)
	#define T2W(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
	#define T2O(pStr)   W2A(pStr)
	#define O2T(pStr)   A2W(pStr)
	#define T2DA(pStr)  W2A(pStr)
	#define A2DT(pStr)  A2W(pStr)
	#define T2DW(pStr)  _wcsdupa(pStr)
	#define W2DT(pStr)  _wcsdupa(pStr)
    typedef CHAR        OCHAR, *LPOSTR, *POSTR;
    typedef CONST CHAR  *LPCOSTR, *PCOSTR;
#else //UNICODE
	#define T2A(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr)   A2W(pStr)
	#define W2T(pStr)   W2A(pStr)
	#define T2O(pStr)   A2W(pStr)
	#define O2T(pStr)   W2A(pStr)
	#define T2DA(pStr)  _strdupa(pStr)
	#define A2DT(pStr)  _strdupa(pStr)
	#define T2DW(pStr)  A2W(pStr)
	#define W2DT(pStr)  W2A(pStr)
    typedef WCHAR       OCHAR, *LPOSTR, *POSTR;
    typedef CONST WCHAR *LPCOSTR, *PCOSTR;
#endif //UNICODE

#endif //__CONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\comwrappers.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    COMWrappers.h

Abstract:

    Wrapper objects for COM 

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _COM_WRAPPERS_H_
#define _COM_WRAPPERS_H_

//////////////////////////////////////////////////////////////////////////
//
// cross-references
//

#include "Wrappers.h"

//////////////////////////////////////////////////////////////////////////
//
// vt_traits
//
// Traits class for mapping value types to the vt field and value offsets

#define VT_F2O(field)                  FIELD_OFFSET(PROPVARIANT, field)
#define VT_O2F(address, type, offset)  (*(type *)((PBYTE) address + offset))

template <class T> struct vt_traits { };

template <> struct vt_traits<CHAR>                { enum { vt = VT_I1,       ofs = VT_F2O(cVal)      }; };
template <> struct vt_traits<UCHAR>               { enum { vt = VT_UI1,      ofs = VT_F2O(bVal)      }; };
template <> struct vt_traits<SHORT>               { enum { vt = VT_I2,       ofs = VT_F2O(iVal)      }; };
template <> struct vt_traits<USHORT>              { enum { vt = VT_UI2,      ofs = VT_F2O(uiVal)     }; };
template <> struct vt_traits<LONG>                { enum { vt = VT_I4,       ofs = VT_F2O(lVal)      }; };
template <> struct vt_traits<ULONG>               { enum { vt = VT_UI4,      ofs = VT_F2O(ulVal)     }; };
template <> struct vt_traits<INT>                 { enum { vt = VT_INT,      ofs = VT_F2O(intVal)    }; };
template <> struct vt_traits<UINT>                { enum { vt = VT_UINT,     ofs = VT_F2O(uintVal)   }; };
template <> struct vt_traits<LARGE_INTEGER>       { enum { vt = VT_I8,       ofs = VT_F2O(hVal)      }; };
template <> struct vt_traits<ULARGE_INTEGER>      { enum { vt = VT_UI8,      ofs = VT_F2O(uhVal)     }; };
template <> struct vt_traits<FLOAT>               { enum { vt = VT_R4,       ofs = VT_F2O(fltVal)    }; };
template <> struct vt_traits<DOUBLE>              { enum { vt = VT_R8,       ofs = VT_F2O(dblVal)    }; };
template <> struct vt_traits<bool>                { enum { vt = VT_BOOL,     ofs = VT_F2O(boolVal)   }; };
//template <> struct vt_traits<SCODE>               { enum { vt = VT_ERROR,    ofs = VT_F2O(scode)     }; };
template <> struct vt_traits<CY>                  { enum { vt = VT_CY,       ofs = VT_F2O(cyVal)     }; };
//template <> struct vt_traits<DATE>                { enum { vt = VT_DATE,     ofs = VT_F2O(date)      }; };
template <> struct vt_traits<FILETIME>            { enum { vt = VT_FILETIME, ofs = VT_F2O(filetime)  }; };
//template <> struct vt_traits<CLSID *>             { enum { vt = VT_CLSID,    ofs = VT_F2O(puuid)     }; };
template <> struct vt_traits<CLIPDATA *>          { enum { vt = VT_CF,       ofs = VT_F2O(pclipdata) }; };
template <> struct vt_traits<CComBSTR>            { enum { vt = VT_BSTR,     ofs = VT_F2O(bstrVal)   }; };

//?template <> struct vt_traits<BSTRBLOB>            { enum { vt = VT_,         ofs = VT_F2O(bstrblobVal)   }; };
template <> struct vt_traits<BLOB>                { enum { vt = VT_BLOB,     ofs = VT_F2O(blob)     }; };
template <> struct vt_traits<LPSTR>               { enum { vt = VT_LPSTR,    ofs = VT_F2O(pszVal)   }; };
template <> struct vt_traits<LPWSTR>              { enum { vt = VT_LPWSTR,   ofs = VT_F2O(pwszVal)  }; };
template <> struct vt_traits<CComPtr<IUnknown> >  { enum { vt = VT_UNKNOWN,  ofs = VT_F2O(punkVal)  }; };
template <> struct vt_traits<CComPtr<IDispatch> > { enum { vt = VT_DISPATCH, ofs = VT_F2O(pdispVal) }; };
template <> struct vt_traits<CComPtr<IStream> >   { enum { vt = VT_STREAM,   ofs = VT_F2O(pStream)  }; };
template <> struct vt_traits<CComPtr<IStorage> >  { enum { vt = VT_STORAGE,  ofs = VT_F2O(pStorage) }; };
//?template <> struct vt_traits<LPVERSIONEDSTREAM>   { enum { vt = VT_,         ofs = VT_F2O(pVersionedStream) }; };
//?template <> struct vt_traits<LPSAFEARRAY>         { enum { vt = VT_ARRAY | VT_, ofs = VT_F2O(parray) }; };

template <> struct vt_traits<CAC>                 { enum { vt = VT_VECTOR | VT_I1,       ofs = VT_F2O(cac)        }; };
template <> struct vt_traits<CAUB>                { enum { vt = VT_VECTOR | VT_UI1,      ofs = VT_F2O(caub)       }; };
template <> struct vt_traits<CAI>                 { enum { vt = VT_VECTOR | VT_I2,       ofs = VT_F2O(cai)        }; };
template <> struct vt_traits<CAUI>                { enum { vt = VT_VECTOR | VT_UI2,      ofs = VT_F2O(caui)       }; };
template <> struct vt_traits<CAL>                 { enum { vt = VT_VECTOR | VT_I4,       ofs = VT_F2O(cal)        }; };
template <> struct vt_traits<CAUL>                { enum { vt = VT_VECTOR | VT_UI4,      ofs = VT_F2O(caul)       }; };
template <> struct vt_traits<CAH>                 { enum { vt = VT_VECTOR | VT_I8,       ofs = VT_F2O(cah)        }; };
template <> struct vt_traits<CAUH>                { enum { vt = VT_VECTOR | VT_UI8,      ofs = VT_F2O(cauh)       }; };
template <> struct vt_traits<CAFLT>               { enum { vt = VT_VECTOR | VT_R4,       ofs = VT_F2O(caflt)      }; };
template <> struct vt_traits<CADBL>               { enum { vt = VT_VECTOR | VT_R8,       ofs = VT_F2O(cadbl)      }; };
template <> struct vt_traits<CABOOL>              { enum { vt = VT_VECTOR | VT_BOOL,     ofs = VT_F2O(cabool)     }; };
template <> struct vt_traits<CASCODE>             { enum { vt = VT_VECTOR | VT_ERROR,    ofs = VT_F2O(cascode)    }; };
template <> struct vt_traits<CACY>                { enum { vt = VT_VECTOR | VT_CY,       ofs = VT_F2O(cacy)       }; };
template <> struct vt_traits<CADATE>              { enum { vt = VT_VECTOR | VT_DATE,     ofs = VT_F2O(cadate)     }; };
template <> struct vt_traits<CAFILETIME>          { enum { vt = VT_VECTOR | VT_FILETIME, ofs = VT_F2O(cafiletime) }; };
template <> struct vt_traits<CACLSID>             { enum { vt = VT_VECTOR | VT_CLSID,    ofs = VT_F2O(cauuid)     }; };
template <> struct vt_traits<CACLIPDATA>          { enum { vt = VT_VECTOR | VT_CF,       ofs = VT_F2O(caclipdata) }; };
template <> struct vt_traits<CABSTR>              { enum { vt = VT_VECTOR | VT_BSTR,     ofs = VT_F2O(cabstr)     }; };
//?template <> struct vt_traits<CABSTRBLOB>          { enum { vt = VT_VECTOR | VT_,        ofs = VT_F2O(cabstrblob)        }; };
template <> struct vt_traits<CALPSTR>             { enum { vt = VT_VECTOR | VT_LPSTR,    ofs = VT_F2O(calpstr)    }; };
template <> struct vt_traits<CALPWSTR>            { enum { vt = VT_VECTOR | VT_LPWSTR,   ofs = VT_F2O(calpwstr)   }; };
template <> struct vt_traits<CAPROPVARIANT>       { enum { vt = VT_VECTOR | VT_VARIANT,  ofs = VT_F2O(capropvar)  }; };

//template <> struct vt_traits<CHAR *>              { enum { vt = VT_BYREF | VT_I1,       ofs = VT_F2O(cVal)      }; };
template <> struct vt_traits<UCHAR *>             { enum { vt = VT_BYREF | VT_UI1,      ofs = VT_F2O(bVal)      }; };
template <> struct vt_traits<SHORT *>             { enum { vt = VT_BYREF | VT_I2,       ofs = VT_F2O(iVal)      }; };
//template <> struct vt_traits<USHORT *>            { enum { vt = VT_BYREF | VT_UI2,      ofs = VT_F2O(uiVal)     }; };
template <> struct vt_traits<LONG *>              { enum { vt = VT_BYREF | VT_I4,       ofs = VT_F2O(lVal)      }; };
template <> struct vt_traits<ULONG *>             { enum { vt = VT_BYREF | VT_UI4,      ofs = VT_F2O(ulVal)     }; };
template <> struct vt_traits<INT *>               { enum { vt = VT_BYREF | VT_INT,      ofs = VT_F2O(intVal)    }; };
template <> struct vt_traits<UINT *>              { enum { vt = VT_BYREF | VT_UINT,     ofs = VT_F2O(uintVal)   }; };
template <> struct vt_traits<FLOAT *>             { enum { vt = VT_BYREF | VT_R4,       ofs = VT_F2O(fltVal)    }; };
template <> struct vt_traits<DOUBLE *>            { enum { vt = VT_BYREF | VT_R8,       ofs = VT_F2O(dblVal)    }; };
//template <> struct vt_traits<VARIANT_BOOL *>      { enum { vt = VT_BYREF | VT_BOOL,     ofs = VT_F2O(boolVal)   }; };
template <> struct vt_traits<DECIMAL *>           { enum { vt = VT_BYREF | VT_DECIMAL,  ofs = VT_F2O(scode)     }; };
//template <> struct vt_traits<SCODE *>             { enum { vt = VT_BYREF | VT_ERROR,    ofs = VT_F2O(scode)     }; };
template <> struct vt_traits<CY *>                { enum { vt = VT_BYREF | VT_CY,       ofs = VT_F2O(cyVal)     }; };
//template <> struct vt_traits<DATE *>              { enum { vt = VT_BYREF | VT_DATE,     ofs = VT_F2O(date)      }; };
template <> struct vt_traits<BSTR *>              { enum { vt = VT_BYREF | VT_BSTR,     ofs = VT_F2O(bstrVal)   }; };
template <> struct vt_traits<IUnknown **>         { enum { vt = VT_BYREF | VT_UNKNOWN,  ofs = VT_F2O(bstrVal)   }; };
template <> struct vt_traits<IDispatch **>        { enum { vt = VT_BYREF | VT_DISPATCH, ofs = VT_F2O(bstrVal)   }; };
//?template <> struct vt_traits<LPSAFEARRAY *>       { enum { vt = VT_BYREF | VT_ARRAY | VT_, ofs = VT_F2O(bstrVal)   }; };
template <> struct vt_traits<PROPVARIANT *>       { enum { vt = VT_BYREF | VT_VARIANT,  ofs = VT_F2O(bstrVal)   }; };

template <> struct vt_traits<DECIMAL>             { enum { vt = VT_DECIMAL, ofs = VT_F2O(decVal) }; };

//////////////////////////////////////////////////////////////////////////
//
// CPropVariant
//
// Wrapper class for the PROPVARIANT struct
//

class CPropVariant : public PROPVARIANT
{

// Constructors

public:
	CPropVariant()
	{
        PropVariantInit(this);
	}

    ~CPropVariant()
	{
        PropVariantClear(this);
	}

	template <> 
	CPropVariant(const CPropVariant &rhs)
	{
        PropVariantCopy(this, &rhs); 
	}

    template <class T>
    CPropVariant(const T &rhs)
    {
        PropVariantInit(this);
        vt = vt_traits<T>::vt;
        VT_O2F(this, T, vt_traits<T>::ofs) = rhs;
    }
	
	template <> 
    CPropVariant(const PROPVARIANT &rhs)
	{
        PropVariantCopy(this, &rhs); 
	}

	template <> 
    CPropVariant(const CLSID &rhs)
	{
        PropVariantInit(this);
        vt = VT_CLSID;
        puuid = (CLSID *) CoTaskMemAlloc(sizeof(CLSID));
        *puuid = rhs;
	}

// Assignment Operators

public:
	CPropVariant& operator =(const CPropVariant &rhs)
	{
        if (&rhs != this)
        {
            PropVariantClear(this);
            PropVariantCopy(this, &rhs); 
        }

		return *this;
	}
	
    template <class T>
	CPropVariant& operator =(const T &rhs)
    {
        PropVariantClear(this);
        vt = vt_traits<T>::vt;
        VT_O2F(this, T, vt_traits<T>::ofs) = rhs;
		return *this;
    }

    template <>
    CPropVariant& operator =(const PROPVARIANT& rhs)
	{
        PropVariantClear(this);
        PropVariantCopy(this, &rhs); 
		return *this;
	}

    template <>
    CPropVariant& operator =(const CLSID &rhs)
	{
        PropVariantClear(this);
        vt = VT_CLSID;
        puuid = (CLSID *) CoTaskMemAlloc(sizeof(CLSID));
        *puuid = rhs;
		return *this;
	}

// Comparison Operators

public:
    bool operator==(const PROPVARIANT& rhs) const
    {
        if (vt != rhs.vt)
        {
            return false;
        }
        
        switch (vt)
        {
        case VT_I1:       return cVal == rhs.cVal;
        case VT_UI1:      return bVal == rhs.bVal;
        case VT_I2:       return iVal == rhs.iVal;
        case VT_UI2:      return uiVal == rhs.uiVal;
        case VT_I4:       return lVal == rhs.lVal;
        case VT_UI4:      return ulVal == rhs.ulVal;
        case VT_INT:      return intVal == rhs.intVal;
        case VT_UINT:     return uintVal == rhs.uintVal;
        case VT_I8:       return hVal.QuadPart == rhs.hVal.QuadPart;
        case VT_UI8:      return uhVal.QuadPart == rhs.uhVal.QuadPart;
        case VT_R4:       return fltVal == rhs.fltVal;
        case VT_R8:       return dblVal == rhs.dblVal;
        case VT_BOOL:     return boolVal == rhs.boolVal;
        case VT_ERROR:    return scode == rhs.scode;
        case VT_CY:       return cyVal.int64 == rhs.cyVal.int64;
        case VT_DATE:     return date == rhs.date;
        case VT_FILETIME: return StructCmp(&filetime, &rhs.filetime) == 0;
        case VT_CLSID:    return StructCmp(puuid, rhs.puuid) == 0;
        case VT_CF:       return StructCmp(pclipdata, rhs.pclipdata) == 0;
        case VT_BSTR:     return wcssafecmp(bstrVal, rhs.bstrVal) == 0;
        case VT_LPSTR:    return strsafecmp(pszVal, rhs.pszVal) == 0;
        case VT_LPWSTR:   return wcssafecmp(pwszVal, rhs.pwszVal) == 0;
        };

        ASSERT(FALSE);
        return false;
    }

    bool operator!=(const PROPVARIANT& rhs) const 
    {
        return !(*this == rhs);
    }

// Operations

public:
	HRESULT Clear() 
    { 
        return PropVariantClear(this); 
    }

	HRESULT Copy(const PROPVARIANT &rhs) 
    { 
        return PropVariantCopy(this, &rhs); 
    }

	HRESULT ChangeType(VARTYPE vtNew)
	{
        // bugbug: VariantChangeType() cannot do all the work...

        return vt == vtNew ? S_OK : 
            VariantChangeType((VARIANT*) this, (VARIANT*) this, 0, vtNew);
	}
};


//////////////////////////////////////////////////////////////////////////
//
// CPropSpec
//
// Wrapper class for the PROPSPEC struct
//

class CPropSpec : public PROPSPEC
{
public:
    CPropSpec()
    {
    }

    CPropSpec(LPOLESTR _lpwstr)
    {
        ulKind = PRSPEC_LPWSTR;
        lpwstr = _lpwstr;
    }

    CPropSpec(PROPID _propid)
    {
        ulKind = PRSPEC_PROPID;
        propid = _propid;
    }

    CPropSpec &operator =(LPOLESTR _lpwstr)
    {
        ulKind = PRSPEC_LPWSTR;
        lpwstr = _lpwstr;
        return *this;
    }

    CPropSpec &operator =(PROPID _propid)
    {
        ulKind = PRSPEC_PROPID;
        propid = _propid;
        return *this;
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CStgMedium
//
// Wrapper class for the STGMEDIUM
//

class CStgMedium : public STGMEDIUM
{
    DISABLE_COPY_CONTRUCTION(CStgMedium);

public:
    CStgMedium()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CStgMedium()
    {
        ReleaseStgMedium(this);
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CStatPropStg
//
// Wrapper class for the STATPROPSTG struct
//

class CStatPropStg : public STATPROPSTG
{
    DISABLE_COPY_CONTRUCTION(CStatPropStg);

public:
    CStatPropStg()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CStatPropStg()
    {
        CoTaskMemFree(lpwstrName);
    }

    bool operator ==(const CStatPropStg &rhs)
    {
        return 
            vt == rhs.vt &&
            propid == rhs.propid &&
            wcssafecmp(lpwstrName, rhs.lpwstrName) == 0;
    }

    bool operator !=(const CStatPropStg &rhs)
    {
        return !(*this == rhs);
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CComPtrArray
//
// Helper class for automatically releasing an array of interface pointers
//

template <class T>
class CComPtrArray
{
    DISABLE_COPY_CONTRUCTION(CComPtrArray);

public:
    CComPtrArray()
    {
  	    m_pArray = 0;
        m_nItemCount = 0;
    }

	~CComPtrArray() 
    {
        Release();
    }

	void Release()
	{
        if (m_pArray) 
        {
            for (int i = 0; i < m_nItemCount; ++i) 
            {
                if (m_pArray[i]) 
                {
                    m_pArray[i]->Release();
                }
            }

            CoTaskMemFree(m_pArray);

            m_pArray = 0;
        }

        m_nItemCount = 0;
	}

    operator T**() 
    { 
        return m_pArray; 
    }

    bool operator!()
    { 
        return m_pArray == 0;
    }

    T*** operator&() 
    { 
        ASSERT(m_pArray == 0); 
        return &m_pArray; 
    }

    LONG &ItemCount() 
    { 
        ASSERT(m_nItemCount == 0); 
        return m_nItemCount; 
    }

private:
  	T**  m_pArray;
    LONG m_nItemCount;
};


//////////////////////////////////////////////////////////////////////////

#endif //_COM_WRAPPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\checkbmp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CheckBmp.h

Abstract:

    BMP file format checking routines

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _CHECKBMP_H_
#define _CHECKBMP_H_

class CCheckBmp
{
public:
    BOOL Check(PVOID pDIB, DWORD dwDIBSize, BOOL  bSkipFileHeader);

private:
    BOOL CheckFileHeader();
    BOOL CheckBitmapInfo();
    BOOL CheckBitmapCoreHeader();
    BOOL CheckBitmapInfoHeader();
    BOOL CheckBitmapV4Header();
    BOOL CheckBitmapV5Header();
    BOOL CheckPalette();
    BOOL CheckPixelData();

private:
    PVOID m_pDIB;
    DWORD m_nDIBSize;

    PVOID m_pFileHeader;
    DWORD m_nFileHeaderSize;
    
    PVOID m_pInfoHeader;
    DWORD m_nInfoHeaderSize;
    
    PVOID m_pPalette;
    DWORD m_nPaletteSize;
    
    PVOID m_pProfile;
    DWORD m_nProfileSize;
    
    PVOID m_pPixelData;
    DWORD m_nPixelDataSize;
};

BOOL CheckBmp(PVOID pDIB, DWORD dwDIBSize, BOOL bSkipFileHeader);
BOOL CheckBmp(PCTSTR pszFileName);

#endif //_CHECKBMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\checkbmp.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    CheckBmp.cpp

Abstract:

    BMP file format checking routines

Author:

    Hakki T. Bostanci (hakkib) 17-Dec-1999

Revision History:

--*/

#include "stdafx.h"

#include "Wrappers.h"
#include "LogWindow.h"
#include "LogWrappers.h"
#include "Argv.h"

#include "CheckBmp.h"

#ifdef _CONSOLE

TCHAR szDecVal[] = _T("%-15s = %d");
TCHAR szHexVal[] = _T("%-15s = 0x%08x");
TCHAR szStrVal[] = _T("%-15s = %s");
TCHAR szDblVal[] = _T("%-15s = %.4lf");

#else //_CONSOLE

TCHAR szDecVal[] = _T("%s = %d");
TCHAR szHexVal[] = _T("%s = 0x%08x");
TCHAR szStrVal[] = _T("%s = %s");
TCHAR szDblVal[] = _T("%s = %.4lf");

#endif //_CONSOLE

//////////////////////////////////////////////////////////////////////////
//
// HeaderSize
//
// Routine Description:
//   returns the size of the bitmap header
//
// Arguments:
//
// Return Value:
//

inline 
DWORD
HeaderSize(
    const VOID *pBitmapInfo
)
{
    return *(PDWORD)pBitmapInfo;
}

//////////////////////////////////////////////////////////////////////////
//
// WidthBytes
//
// Routine Description:
//   calculates the number of bytes in a BMP row (that should be DWORD aligned)
//
// Arguments:
//
// Return Value:
//

inline 
DWORD
WidthBytes(
    DWORD dwWidth,
    DWORD dwBitCount
)
{
    return (((dwWidth * dwBitCount) + 31) & ~31) >> 3;
}

//////////////////////////////////////////////////////////////////////////
//
// FXPT_TO_FLPT, FXPT2DOT30_TO_FLPT, FXPT16DOT16_TO_FLPT
//
// Routine Description:
//   floating point to fixed point conversion macros
//
// Arguments:
//
// Return Value:
//

inline
double
FXPT_TO_FLPT(
    long nFixed,
    int  nPoint
)
{
    double nInteger  = nFixed >> nPoint;
    double nFraction = ldexp(nFixed & ((1 << nPoint) - 1), -nPoint);

    return nInteger + nFraction;
}

inline
double
FXPT2DOT30_TO_FLPT(
    FXPT2DOT30 nFixed
)
{
    return FXPT_TO_FLPT(nFixed, 30);
}

inline
double
FXPT16DOT16_TO_FLPT(
    FXPT16DOT16 nFixed
)
{
    return FXPT_TO_FLPT(nFixed, 16);
}


//////////////////////////////////////////////////////////////////////////
//
// Contiguous
//
// Routine Description:
//   Tests whether the 1's are contiguous in an integers, i.e. 00000111,
//   00011100, 11100000, 00000000, 11111111 are OK but 00101100 is not
//
// Arguments:
//
// Return Value:
//

template <class T> 
BOOL Contiguous(T Bits)
{
    const NumBits = sizeof(T) * 8;

    T i = 0;

    while (i < NumBits && (Bits & (1 << i)) == 0) ++i;
    while (i < NumBits && (Bits & (1 << i)) != 0) ++i;
    while (i < NumBits && (Bits & (1 << i)) == 0) ++i;

    return i == NumBits;
}

//////////////////////////////////////////////////////////////////////////
//
// CheckColorMasks
//
// Routine Description:
//   checks the validity of the color masks in a bitfields type bmp.
//   the masks should not overlap and the bits should be contiguous
//   within each map
//
// Arguments:
//
// Return Value:
//

BOOL 
CheckColorMasks(
    DWORD dwRedMask, 
    DWORD dwGreenMask, 
    DWORD dwBlueMask
)
{
    return
        (dwRedMask   & dwGreenMask) == 0 &&
        (dwRedMask   & dwBlueMask)  == 0 &&
        (dwGreenMask & dwBlueMask)  == 0 &&
        Contiguous(dwRedMask)   &&
        Contiguous(dwGreenMask) &&
        Contiguous(dwBlueMask);
}

//////////////////////////////////////////////////////////////////////////
//
// 
//
// Routine Description:
//   compares two RGBTRIPLE's
//
// Arguments:
//
// Return Value:
//

inline bool __cdecl operator <(const RGBTRIPLE &lhs, const RGBTRIPLE &rhs)
{
    return 
        RGB(lhs.rgbtRed, lhs.rgbtGreen, lhs.rgbtBlue) <
        RGB(rhs.rgbtRed, rhs.rgbtGreen, rhs.rgbtBlue);
}

//////////////////////////////////////////////////////////////////////////
//
// 
//
// Routine Description:
//   
//
// Arguments:
//
// Return Value:
//

inline void __cdecl LOG_INFO(PCTSTR pFormat, ...)
{
    va_list arglist;
    va_start(arglist, pFormat);

    g_pLog->LogV(TLS_INFO | TLS_VARIATION, 0, 0, pFormat, arglist);
}

inline void __cdecl LOG_ERROR(DWORD dwLogLevel, PCTSTR pFormat, ...)
{
    va_list arglist;
    va_start(arglist, pFormat);

    g_pLog->LogV(dwLogLevel | TLS_VARIATION, 0, 0, pFormat, arglist);
}

//////////////////////////////////////////////////////////////////////////
//
// CheckBmp
//
// Routine Description:
//   Main entry point for this module. Checks the validity of a BMP
//   file or an in-memory image.
//
// Arguments:
//
// Return Value:
//

BOOL CheckBmp(PVOID pDIB, DWORD dwDIBSize, BOOL bSkipFileHeader)
{
    return CCheckBmp().Check(pDIB, dwDIBSize, bSkipFileHeader);
}

BOOL CheckBmp(PCTSTR pszFileName)
{
    CInFile TheFile(pszFileName);

    CFileMapping TheMap(TheFile, 0, PAGE_READONLY);

    CMapViewOfFile<VOID> TheData(TheMap, FILE_MAP_READ);

    return CCheckBmp().Check(TheData, GetFileSize(TheFile, 0), FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::Check
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//

CCheckBmp::Check(PVOID pDIB, DWORD dwDIBSize, BOOL bSkipFileHeader)   
{
    ZeroMemory(this, sizeof(*this));

    LOG_INFO(szDecVal, _T("DibSize"), dwDIBSize);

    m_pDIB     = pDIB;
    m_nDIBSize = dwDIBSize;

    return 
        (bSkipFileHeader || CheckFileHeader()) &&
        CheckBitmapInfo() &&
        CheckPalette()    &&
        CheckPixelData();
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckFileHeader
//
// Routine Description:
//   Checks BITMAPFILEHEADER
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckFileHeader()
{
    BOOL bResult = TRUE;

    m_pFileHeader     = m_pDIB;
    m_nFileHeaderSize = sizeof(BITMAPFILEHEADER);

    PBITMAPFILEHEADER pbmfh = (PBITMAPFILEHEADER) m_pDIB;

    // bfType
    // should read "BM"

    LOG_INFO(szHexVal, _T("Type"), pbmfh->bfType);

    if (LOBYTE(pbmfh->bfType) != 'B' || HIBYTE(pbmfh->bfType) != 'M') 
    {
	    LOG_ERROR(TLS_SEV2, _T("Unexpected bitmap file type"));
        bResult = FALSE;
    }

    // bfSize
    // should equal file size

    LOG_INFO(szDecVal, _T("Size"), pbmfh->bfSize);

    if (pbmfh->bfSize != m_nDIBSize) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected bitmap file size"));
        bResult = FALSE;
    }

    // bfReserved1, bfReserved2
    // should be zero

    LOG_INFO(szDecVal, _T("Reserved1"), pbmfh->bfReserved1);
    LOG_INFO(szDecVal, _T("Reserved2"), pbmfh->bfReserved2);

    if (pbmfh->bfReserved1 != 0 || pbmfh->bfReserved2 != 0) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Reserved value"));
        bResult = FALSE;
    }

    // bfOffBits
    // will be checked in CheckPixelData

    LOG_INFO(szDecVal, _T("OffBits"), pbmfh->bfOffBits);

    m_pPixelData = (PBYTE) pbmfh + pbmfh->bfOffBits;

    return bResult;
}
    
//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckBitmapInfo
//
// Routine Description:
//   Checks the bitmap header according to the header size
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckBitmapInfo()
{
    BOOL bResult = TRUE;

    m_pInfoHeader = (PBYTE) m_pDIB + m_nFileHeaderSize;

    PBITMAPINFO pbmi = (PBITMAPINFO) m_pInfoHeader;

    m_nInfoHeaderSize = pbmi->bmiHeader.biSize;

    LOG_INFO(szDecVal, _T("Size"), pbmi->bmiHeader.biSize);

    switch (pbmi->bmiHeader.biSize) 
    {
    case sizeof(BITMAPCOREHEADER):
        bResult = CheckBitmapCoreHeader();
        break;

    case sizeof(BITMAPINFOHEADER):
        bResult = CheckBitmapInfoHeader();
        break;

    case sizeof(BITMAPV4HEADER):
        bResult = CheckBitmapV4Header();
        break;

    case sizeof(BITMAPV5HEADER):
        bResult = CheckBitmapV5Header();
        break;

    default:
        LOG_ERROR(TLS_SEV2, _T("Unexpected header size"));
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckPalette
//
// Routine Description:
//   Checks the bitmap color palette
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckPalette()
{
    BOOL bResult = TRUE;

    m_pPalette = (PBYTE) m_pInfoHeader + m_nInfoHeaderSize;

    std::set<RGBTRIPLE> UsedColors;

    if (m_nInfoHeaderSize == sizeof(BITMAPCOREHEADER)) 
    {
        RGBTRIPLE *prgbt = (RGBTRIPLE *) m_pPalette;

        for (int i = 0; i < m_nPaletteSize / sizeof(RGBTRIPLE); ++i) 
        {
            /*LOG_INFO(
                _T("Color %3d: R=%02x G=%02x B=%02x"), 
                i, 
                prgbt[i].rgbtRed, 
                prgbt[i].rgbtGreen, 
                prgbt[i].rgbtBlue
            );*/

            if (!UsedColors.insert(prgbt[i]).second) 
            {
                LOG_ERROR(
                    TLS_SEV3, 
                    _T("Repeated palette entry %3d: R=%02x G=%02x B=%02x"),
                    i, 
                    prgbt[i].rgbtRed, 
                    prgbt[i].rgbtGreen, 
                    prgbt[i].rgbtBlue
                );

                bResult = FALSE;
            } 
        }
    } 
    else 
    {
        LPRGBQUAD prgbq = (LPRGBQUAD) m_pPalette;

        for (int i = 0; i < m_nPaletteSize / sizeof(RGBQUAD); ++i) 
        {
            /*LOG_INFO(
                _T("Color %3d: R=%02x G=%02x B=%02x A=%02x"), 
                i, 
                prgbq[i].rgbRed, 
                prgbq[i].rgbGreen, 
                prgbq[i].rgbBlue,
                prgbq[i].rgbReserved
            );*/

            if (prgbq[i].rgbReserved != 0) 
            {
                LOG_ERROR(
                    TLS_SEV3, 
                    _T("Unexpected rgbReserved value in palette entry %3d: R=%02x G=%02x B=%02x A=%02x"), 
                    i, 
                    prgbq[i].rgbRed, 
                    prgbq[i].rgbGreen, 
                    prgbq[i].rgbBlue,
                    prgbq[i].rgbReserved
                );

                bResult = FALSE;
            }

            RGBTRIPLE rgbt;

            rgbt.rgbtRed   = prgbq[i].rgbRed;
            rgbt.rgbtGreen = prgbq[i].rgbGreen;
            rgbt.rgbtBlue  = prgbq[i].rgbBlue;

            if (!UsedColors.insert(rgbt).second) 
            {
                LOG_ERROR(
                    TLS_SEV3, 
                    _T("Repeated palette entry %3d: R=%02x G=%02x B=%02x A=%02x"), 
                    i, 
                    prgbq[i].rgbRed, 
                    prgbq[i].rgbGreen, 
                    prgbq[i].rgbBlue,
                    prgbq[i].rgbReserved
                );

                bResult = FALSE;
            } 
        }
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckPixelData
//
// Routine Description:
//   Checks the bitmap color palette
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckPixelData()
{
    BOOL bResult = TRUE;

    PVOID pExpectedPixelData = (PBYTE) m_pPalette + m_nPaletteSize;

    if (m_pProfile != 0 && m_pProfile <= pExpectedPixelData) 
    {
        pExpectedPixelData = (PBYTE) m_pProfile + m_nProfileSize;
    }

    if (m_pPixelData != 0 && m_pPixelData != pExpectedPixelData) 
    {
        LOG_ERROR(TLS_SEV3, _T("Unexpected OffBits value"));
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckBitmapCoreHeader
//
// Routine Description:
//   Checks BITMAPCOREHEADER
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckBitmapCoreHeader()
{
    BOOL bResult = TRUE;

    PBITMAPCOREHEADER pbih = (PBITMAPCOREHEADER) m_pInfoHeader;

    // bcWidth 
    // should be positive

    LOG_INFO(szDecVal, _T("Width"), pbih->bcWidth);

    if (pbih->bcWidth <= 0) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Width value"));
        bResult = FALSE;
    }

    // bcHeight
    // should be positive

    LOG_INFO(szDecVal, _T("Height"), pbih->bcHeight);

    if (pbih->bcHeight <= 0) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Height value"));
        bResult = FALSE;
    }

    // bcPlanes 
    // should be 1

    LOG_INFO(szDecVal, _T("Planes"), pbih->bcPlanes);

    if (pbih->bcPlanes != 1) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Planes value"));
    }

    // bcBitCount
    // can be 1, 4, 8 or 24

    LOG_INFO(szDecVal, _T("BitCount"), pbih->bcBitCount);

    switch (pbih->bcBitCount) 
    {
    case 1:
    case 4:
    case 8:
        m_nPaletteSize = (1 << pbih->bcBitCount) * sizeof(RGBTRIPLE);
        break;

    case 24:
        m_nPaletteSize = 0;
        break;

    default:
        LOG_ERROR(TLS_SEV2, _T("Unexpected BitCount value"));
        bResult = FALSE;
        break;
    }

    m_nPixelDataSize = 
        WidthBytes(pbih->bcWidth, pbih->bcBitCount) * pbih->bcHeight;

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckBitmapInfoHeader
//
// Routine Description:
//   Checks BITMAPINFOHEADER
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckBitmapInfoHeader()
{
    PBITMAPINFOHEADER pbih = (PBITMAPINFOHEADER) m_pInfoHeader;

    BOOL bResult = TRUE;

    // biWidth
    // should be positive

    LOG_INFO(szDecVal, _T("Width"), pbih->biWidth);

    if (pbih->biWidth <= 0) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Width value"));
        bResult = FALSE;
    }

    // biHeight
    // should not be zero, if negative, should be BI_RGB or BI_BITFIELDS

    LOG_INFO(szDecVal, _T("Height"), pbih->biHeight);

    if (pbih->biHeight == 0) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Height value"));
        bResult = FALSE;
    }

    if (pbih->biHeight < 0) 
    {
        switch (pbih->biCompression) 
        { 
        case BI_RGB:
        case BI_BITFIELDS:
        case BI_JPEG:
        case BI_PNG:
            break;

        default:
            LOG_ERROR(TLS_SEV2, _T("Unexpected Compression value for negative Height"));
            bResult = FALSE;
            break;
        }
    }

    // biPlanes
    // should be 1

    LOG_INFO(szDecVal, _T("Planes"), pbih->biPlanes);

    if (pbih->biPlanes != 1) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Planes value"));
    }

    // biBitCount
    // can be 0 (only for BI_JPEG or BI_PNG), 1, 4, 8, 16, 24 or 32

    LOG_INFO(szDecVal, _T("BitCount"), pbih->biBitCount);

    switch (pbih->biBitCount) 
    {
    case 0:
        switch (pbih->biCompression) 
        { 
        case BI_JPEG:
        case BI_PNG:
            break;

        default:
            LOG_ERROR(TLS_SEV2, _T("Unexpected Compression value for zero BitCount"));
            bResult = FALSE;
            break;
        }
        break;

    case 1:
    case 4:
    case 8:
        m_nPaletteSize = (1 << pbih->biBitCount) * sizeof(RGBQUAD);
        break;

    case 16:
    case 24:
    case 32:
        m_nPaletteSize = 0;
        break;

    default:
        LOG_ERROR(TLS_SEV2, _T("Unexpected BitCount value"));
        bResult = FALSE;
        break;
    }

    // biCompression

    switch (pbih->biCompression) 
    {
    case BI_RGB:
        LOG_INFO(szStrVal, _T("Compression"), _T("BI_RGB"));
        break;

    case BI_RLE8:

        LOG_INFO(szStrVal, _T("Compression"), _T("BI_RLE8"));

        if (pbih->biBitCount != 8) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected BitCount value for BI_RLE8"));
            bResult = FALSE;
        }

        break;

    case BI_RLE4:

        LOG_INFO(szStrVal, _T("Compression"), _T("BI_RLE4"));

        if (pbih->biBitCount != 4) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected BitCount value for BI_RLE4"));
            bResult = FALSE;
        }

        break;

    case BI_BITFIELDS: 
    {
        LOG_INFO(szStrVal, _T("Compression"), _T("BI_BITFIELDS"));

        DWORD dwRedMask   = ((PDWORD)(pbih + 1))[0];
        DWORD dwGreenMask = ((PDWORD)(pbih + 1))[1];
        DWORD dwBlueMask  = ((PDWORD)(pbih + 1))[2];

        if (pbih->biSize == sizeof(BITMAPINFOHEADER)) 
        {
            m_nInfoHeaderSize += 3 * sizeof(DWORD);

            LOG_INFO(szHexVal, _T("RedMask"), dwRedMask);
            LOG_INFO(szHexVal, _T("GreenMask"), dwGreenMask);
            LOG_INFO(szHexVal, _T("BlueMask"), dwBlueMask);
        }

        switch (pbih->biBitCount) 
        {    
        case 16: 

            if (
                (dwRedMask != 0x7C00 || dwGreenMask != 0x03E0 || dwBlueMask != 0x001F) &&
                (dwRedMask != 0xF800 || dwGreenMask != 0x07E0 || dwBlueMask != 0x001F)
            ) 
            {
                LOG_ERROR(TLS_WARN, _T("Unexpected color masks for Win9x BI_BITFIELDS"));
            } 
            else 
            {
                if ((dwRedMask | dwGreenMask | dwBlueMask) & 0xFFFF0000) 
                {
                    LOG_ERROR(TLS_SEV2, _T("Unexpected color masks for 16-bit BI_BITFIELDS"));
                    bResult = FALSE;
                }

                if (!CheckColorMasks(dwRedMask, dwGreenMask, dwBlueMask)) 
                {
                    LOG_ERROR(TLS_SEV2, _T("Unexpected color masks for BI_BITFIELDS"));
                    bResult = FALSE;
                }
            }
            
            break;

        case 32:

            if (dwRedMask != 0x00FF0000 || dwGreenMask != 0x0000FF00 || dwBlueMask != 0x000000FF) 
            {
                LOG_ERROR(TLS_WARN, _T("Unexpected color masks for Win9x BI_BITFIELDS"));
            } 
            else 
            {
                if (!CheckColorMasks(dwRedMask, dwGreenMask, dwBlueMask)) 
                {
                    LOG_ERROR(TLS_SEV2, _T("Unexpected color masks for BI_BITFIELDS"));
                    bResult = FALSE;
                }
            }

            break;

        default:
            LOG_ERROR(TLS_SEV2, _T("Unexpected BitCount for BI_BITFIELDS"));
            bResult = FALSE;
            break;
        }
        break;
    }

    case BI_JPEG:
        LOG_INFO(szStrVal, _T("Compression"), _T("BI_JPEG"));
        break;

    case BI_PNG:
        LOG_INFO(szStrVal, _T("Compression"), _T("BI_PNG"));
        break;

    default:
        LOG_INFO(szDecVal, _T("Compression"), pbih->biCompression);
        LOG_ERROR(TLS_SEV2, _T("Unexpected Compression value"));
        bResult = FALSE;
        break;
    }

    // biSizeImage
    // should not be negative, can be zero only for BI_RGB

    LOG_INFO(szDecVal, _T("SizeImage"), pbih->biSizeImage);

    if ((LONG) pbih->biSizeImage < 0) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected SizeImage value"));
        bResult = FALSE;
    }

    m_nPixelDataSize = 
        WidthBytes(Abs(pbih->biWidth), pbih->biBitCount) * Abs(pbih->biHeight);

    if (pbih->biSizeImage != 0) 
    {
        if (pbih->biCompression == BI_RGB && m_nPixelDataSize != pbih->biSizeImage) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected SizeImage value"));
            bResult = FALSE;
        }

        m_nPixelDataSize = pbih->biSizeImage;
    }
    else 
    {
        if (pbih->biCompression != BI_RGB) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected SizeImage value for non BI_RGB bitmap"));
            bResult = FALSE;
        }
    }

    // biClrUsed
    // should not be greater than the max number of bitdepth colors

    LOG_INFO(szDecVal, _T("ClrUsed"), pbih->biClrUsed);

    if (pbih->biClrUsed != 0) 
    {
        if (pbih->biBitCount < 16 && pbih->biClrUsed * sizeof(RGBQUAD) > m_nPaletteSize) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected ClrUsed value for the BitCount"));
            bResult = FALSE;
        } 
        else 
        {
            m_nPaletteSize = pbih->biClrUsed * sizeof(RGBQUAD);
        }
    }
    
    // biClrImportant
    // should be equal to or less than biClrUsed

    LOG_INFO(szDecVal, _T("ClrImportant"), pbih->biClrImportant);

    if (pbih->biClrUsed != 0 && pbih->biClrImportant > pbih->biClrUsed) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected ClrImportant value"));
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckBitmapV4Header
//
// Routine Description:
//   Checks BITMAPV4HEADER
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckBitmapV4Header()
{
    BOOL bResult = CheckBitmapInfoHeader();

    PBITMAPV4HEADER pbih = (PBITMAPV4HEADER) m_pInfoHeader;

    // bV4RedMask, bV4GreenMask, bV4BlueMask, bV4AlphaMask
    // already checked in the info header

    LOG_INFO(szHexVal, _T("RedMask"), pbih->bV4RedMask);
    LOG_INFO(szHexVal, _T("GreenMask"), pbih->bV4GreenMask);
    LOG_INFO(szHexVal, _T("BlueMask"), pbih->bV4BlueMask);
    LOG_INFO(szHexVal, _T("AlphaMask"), pbih->bV4AlphaMask);

    // bV4CSType
    // should be one of LCS_ types

    switch (pbih->bV4CSType) 
    {
    case LCS_CALIBRATED_RGB:
        LOG_INFO(szStrVal, _T("CSType"), _T("LCS_CALIBRATED_RGB"));
        break;

    case LCS_sRGB:
        LOG_INFO(szStrVal, _T("CSType"), _T("LCS_sRGB"));
        break;

    case LCS_WINDOWS_COLOR_SPACE:
        LOG_INFO(szStrVal, _T("CSType"), _T("LCS_WINDOWS_COLOR_SPACE"));
        break;

    case PROFILE_LINKED:
        LOG_INFO(szStrVal, _T("CSType"), _T("PROFILE_LINKED"));
        break;

    case PROFILE_EMBEDDED:
        LOG_INFO(szStrVal, _T("CSType"), _T("PROFILE_EMBEDDED"));
        break;

    default:
        LOG_ERROR(TLS_SEV2, _T("Unexpected CSType value"));
        bResult = FALSE;
        break;
    }

    // bV4Endpoints, bV4GammaRed, bV4GammaGreen, bV4GammaBlue
    // should be present only for LCS_CALIBRATED_RGB

    LOG_INFO(szDblVal, _T("EndpointRedX"),   FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzRed.ciexyzX));
    LOG_INFO(szDblVal, _T("EndpointRedY"),   FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzRed.ciexyzY));
    LOG_INFO(szDblVal, _T("EndpointRedZ"),   FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzRed.ciexyzZ));
    LOG_INFO(szDblVal, _T("EndpointGreenX"), FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzGreen.ciexyzX));
    LOG_INFO(szDblVal, _T("EndpointGreenY"), FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzGreen.ciexyzY));
    LOG_INFO(szDblVal, _T("EndpointGreenZ"), FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzGreen.ciexyzZ));
    LOG_INFO(szDblVal, _T("EndpointBlueX"),  FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzBlue.ciexyzX));
    LOG_INFO(szDblVal, _T("EndpointBlueY"),  FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzBlue.ciexyzY));
    LOG_INFO(szDblVal, _T("EndpointBlueZ"),  FXPT2DOT30_TO_FLPT(pbih->bV4Endpoints.ciexyzBlue.ciexyzZ));

    LOG_INFO(szDblVal, _T("GammaRed"),   FXPT16DOT16_TO_FLPT(pbih->bV4GammaRed));
    LOG_INFO(szDblVal, _T("GammaGreen"), FXPT16DOT16_TO_FLPT(pbih->bV4GammaGreen));
    LOG_INFO(szDblVal, _T("GammaBlue"),  FXPT16DOT16_TO_FLPT(pbih->bV4GammaBlue));

    if (pbih->bV4CSType != LCS_CALIBRATED_RGB) 
    {
        // bugbug: how can I check a valid colorspace?

        if (
            pbih->bV4Endpoints.ciexyzRed.ciexyzX != 0 ||
            pbih->bV4Endpoints.ciexyzRed.ciexyzY != 0 ||
            pbih->bV4Endpoints.ciexyzRed.ciexyzZ != 0 ||
            pbih->bV4Endpoints.ciexyzGreen.ciexyzX != 0 ||
            pbih->bV4Endpoints.ciexyzGreen.ciexyzY != 0 ||
            pbih->bV4Endpoints.ciexyzGreen.ciexyzZ != 0 ||
            pbih->bV4Endpoints.ciexyzBlue.ciexyzX != 0 ||
            pbih->bV4Endpoints.ciexyzBlue.ciexyzY != 0 ||
            pbih->bV4Endpoints.ciexyzBlue.ciexyzZ != 0 ||
            pbih->bV4GammaRed != 0 ||
            pbih->bV4GammaGreen != 0 ||
            pbih->bV4GammaBlue != 0
        ) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected colorspace values for CSType"));
            bResult = FALSE;
        }
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// CCheckBmp::CheckBitmapV5Header
//
// Routine Description:
//   Checks BITMAPV5HEADER
//
// Arguments:
//
// Return Value:
//

BOOL CCheckBmp::CheckBitmapV5Header()
{
    BOOL bResult = CheckBitmapV4Header();

    PBITMAPV5HEADER pbih = (PBITMAPV5HEADER) m_pInfoHeader;

    // bV5Intent
    // should be one of the LCS_ values

    switch (pbih->bV5Intent) 
    {
    case LCS_GM_BUSINESS:
        LOG_INFO(szStrVal, _T("Intent"), _T("LCS_GM_BUSINESS"));
        break;

    case LCS_GM_GRAPHICS:
        LOG_INFO(szStrVal, _T("Intent"), _T("LCS_GM_GRAPHICS"));
        break;

    case LCS_GM_IMAGES:
        LOG_INFO(szStrVal, _T("Intent"), _T("LCS_GM_IMAGES"));
        break;

    case LCS_GM_ABS_COLORIMETRIC:
        LOG_INFO(szStrVal, _T("Intent"), _T("LCS_GM_ABS_COLORIMETRIC"));
        break;

    default:
        LOG_ERROR(TLS_SEV2, _T("Unexpected Intent value"));
        bResult = FALSE;
        break;
    }

    // bV5ProfileData, bV5ProfileSize
    // check profile data 

    LOG_INFO(szDecVal, _T("ProfileData"), pbih->bV5ProfileData);
    LOG_INFO(szDecVal, _T("ProfileSize"), pbih->bV5ProfileSize);

    switch (pbih->bV5CSType) 
    {
    case LCS_CALIBRATED_RGB:
    case LCS_sRGB:
    case LCS_WINDOWS_COLOR_SPACE:

        if (pbih->bV5ProfileData != 0 || pbih->bV5ProfileSize != 0) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected profile info for CSType"));
            bResult = FALSE;
        }

        break;

    case PROFILE_LINKED: 
    {
        PCSTR pName = (PCSTR) ((PBYTE) pbih + pbih->bV5ProfileData);

        if (MultiByteToWideChar(1252, MB_ERR_INVALID_CHARS, pName, -1, 0, 0) == 0) 
        {

            LOG_ERROR(TLS_SEV2, _T("Unexpected profile name for PROFILE_LINKED"));
            bResult = FALSE;
        }

        // continue,
    }

    case PROFILE_EMBEDDED:

        if (pbih->bV5ProfileData == 0 || pbih->bV5ProfileSize == 0) 
        {
            LOG_ERROR(TLS_SEV2, _T("Unexpected profile info for CSType"));
            bResult = FALSE;
        }

        m_pProfile     = (PBYTE) pbih + pbih->bV5ProfileData;
        m_nProfileSize = pbih->bV5ProfileSize;

        break;
    }

    // Reserved
    // should be zero

    LOG_INFO(szHexVal, _T("Reserved"), pbih->bV5Reserved);

    if (pbih->bV5Reserved != 0) 
    {
        LOG_ERROR(TLS_SEV2, _T("Unexpected Reserved value"));
        bResult = FALSE;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// CheckBMPMain
//
// Routine Description:
//   _tmain() function in case someone runs this as a standalone program
//
// Arguments:
//
// Return Value:
//

void CheckBMPMain()
{
    AllocCRTConsole();

    INT   argc;
    CGlobalMem<PTSTR> argv(CommandLineToArgv(GetCommandLine(), &argc));

    CFullPathName FileName(argv[1]);

    for (
        CFindFile FindFile(FileName);
        FindFile.Found();
        FindFile.FindNextFile()
    ) 
    {
        FileName.SetFileName(FindFile.cFileName);

        LOG_INFO(FileName);

        CheckBmp((PCTSTR) FileName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\datacallback.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DataCallback.cpp

Abstract:

    WIA data callback class

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "StdAfx.h"

#include "WiaStress.h"

#include "DataCallback.h"
#include "ToStr.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

CDataCallback::CDataCallback()
{
    m_cRef        = 0;
    m_pBuffer     = 0;
    m_lBufferSize = 0;

    m_TimeDeviceBegin.QuadPart  = 0;
    m_TimeDeviceEnd.QuadPart    = 0;
    m_TimeProcessBegin.QuadPart = 0;
    m_TimeProcessEnd.QuadPart   = 0;
    m_TimeClientBegin.QuadPart  = 0;
    m_TimeClientEnd.QuadPart    = 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CDataCallback::~CDataCallback()
{
    PrintTimes();

    delete [] m_pBuffer;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CDataCallback::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
	    return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
	    AddRef();
	    *ppvObj = (IUnknown*) this;
	    return S_OK;
    }

    if (iid == IID_IWiaDataCallback)
    {
	    AddRef();
	    *ppvObj = (IWiaDataCallback *) this;
	    return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CDataCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CDataCallback::Release()
{
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP 
CDataCallback::BandedDataCallback(
    LONG  lReason,
    LONG  lStatus,
    LONG  lPercentComplete,
    LONG  lOffset,
    LONG  lLength,
    LONG  lReserved,
    LONG  lResLength,
    PBYTE pbBuffer 
)
{
    OutputDebugStringF(
        _T("DataCallback: Reason=%s Stat=%s %d%% Offset=%d Length=%d (%dK) Buf=%p\n"), 
        (PCTSTR) WiaCallbackReasonToStr(lReason), 
        (PCTSTR) WiaCallbackStatusToStr(lStatus), 
        lPercentComplete, 
        lOffset, 
        lLength, 
        lLength / 1024, 
        pbBuffer
    );

	switch (lReason) 
    {
	case IT_MSG_DATA_HEADER: 
    {
        // allocate memory for the image

		PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER) pbBuffer;

        m_lBufferSize = pHeader->lBufferSize;

        ASSERT(m_pBuffer == 0); //bugbug

        m_pBuffer = new BYTE[m_lBufferSize];

        if (m_pBuffer == 0) 
        {
            return S_FALSE;
        }

        break;
	}

    case IT_MSG_DATA: 
    {
        // copy the transfer buffer

        QueryStartTimes(lStatus, lPercentComplete);

        if (pbBuffer != 0 && lOffset + lLength <= m_lBufferSize) 
        {
            CopyMemory(m_pBuffer + lOffset, pbBuffer, lLength);
        }
        else 
        {
        }

        QueryStopTimes(lStatus, lPercentComplete);

        break;
    }
	    
    case IT_MSG_STATUS: 
    {
        QueryStartTimes(lStatus, lPercentComplete);

        QueryStopTimes(lStatus, lPercentComplete);

        break;
    }

    case IT_MSG_TERMINATION:
        break;

    case IT_MSG_NEW_PAGE:
        break;
    
    default:
        break;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CDataCallback::QueryStartTimes(LONG lStatus, LONG  lPercentComplete) 
{
    if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE && 
        (lPercentComplete == 0 || m_TimeDeviceBegin.QuadPart == 0)) 
    {
        QueryPerformanceCounter(&m_TimeDeviceBegin);
    }

    if (lStatus & IT_STATUS_PROCESSING_DATA && 
        (lPercentComplete == 0 || m_TimeProcessBegin.QuadPart == 0)) 
    {
        QueryPerformanceCounter(&m_TimeProcessBegin);
    }

    if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT && 
        (lPercentComplete == 0 || m_TimeClientBegin.QuadPart == 0)) 
    {
        QueryPerformanceCounter(&m_TimeClientBegin);
    }
}

void CDataCallback::QueryStopTimes(LONG lStatus, LONG  lPercentComplete)
{
    if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE && lPercentComplete == 100) 
    {
        QueryPerformanceCounter(&m_TimeDeviceEnd);
    }

    if (lStatus & IT_STATUS_PROCESSING_DATA && lPercentComplete == 100) 
    {
        QueryPerformanceCounter(&m_TimeProcessEnd);
    }

    if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT && lPercentComplete == 100) 
    {
        QueryPerformanceCounter(&m_TimeClientEnd);
    }
}

void CDataCallback::PrintTimes() 
{
    LARGE_INTEGER Freq;
    QueryPerformanceFrequency(&Freq);

    double nTimeDevice = 
        (double) (m_TimeDeviceEnd.QuadPart - m_TimeDeviceBegin.QuadPart) /
        (double) Freq.QuadPart;

    double nTimeProcess = 
        (double) (m_TimeProcessEnd.QuadPart - m_TimeProcessBegin.QuadPart) /
        (double) Freq.QuadPart;

    double nTimeClient = 
        (double) (m_TimeClientEnd.QuadPart - m_TimeClientBegin.QuadPart) /
        (double) Freq.QuadPart;

    OutputDebugStringF(
        _T("TRANSFER_FROM_DEVICE = %.02lf secs\n")
        _T("PROCESSING_DATA      = %.02lf secs\n")
        _T("TRANSFER_TO_CLIENT   = %.02lf secs\n")
        _T("\n"),
        nTimeDevice,
        nTimeProcess,
        nTimeClient
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\datacallback.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DataCallback.h

Abstract:

    WIA data callback class

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _DATACALLBACK_H_
#define _DATACALLBACK_H_

//////////////////////////////////////////////////////////////////////////
//
//
//

class CDataCallback : public IWiaDataCallback
{
public:
    CDataCallback();
    ~CDataCallback();

    // IUnknown interface

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IWiaDataCallback interface

    STDMETHOD(BandedDataCallback) (
        LONG  lReason,
        LONG  lStatus,
        LONG  lPercentComplete,
        LONG  lOffset,
        LONG  lLength,
        LONG  lReserved,
        LONG  lResLength,
        PBYTE pbBuffer 
    );

    // Debugging / performance functions

    void QueryStartTimes(LONG lStatus, LONG lPercentComplete);
    void QueryStopTimes(LONG lStatus, LONG lPercentComplete);
    void PrintTimes();

    PBYTE          m_pBuffer;
    LONG           m_lBufferSize;

    LONG           m_cRef;

    LARGE_INTEGER  m_TimeDeviceBegin;
    LARGE_INTEGER  m_TimeDeviceEnd;
    LARGE_INTEGER  m_TimeProcessBegin;
    LARGE_INTEGER  m_TimeProcessEnd;
    LARGE_INTEGER  m_TimeClientBegin;
    LARGE_INTEGER  m_TimeClientEnd;
};

#endif //_DATACALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\eventcallback.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    EventCallback.cpp

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "StdAfx.h"

#include "WiaStress.h"

#include "EventCallback.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

CEventCallback::CEventCallback()
{
    m_cRef = 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CEventCallback::~CEventCallback()
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP CEventCallback::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
    if (ppvObj == 0)
    {
	    return E_POINTER;
    }

    if (iid == IID_IUnknown)
    {
	    AddRef();
	    *ppvObj = (IUnknown*) this;
	    return S_OK;
    }

    if (iid == IID_IWiaEventCallback)
    {
	    AddRef();
	    *ppvObj = (IWiaEventCallback *) this;
	    return S_OK;
    }

    *ppvObj = 0;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CEventCallback::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP_(ULONG) CEventCallback::Release()
{
    LONG cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP 
CEventCallback::ImageEventCallback(
    LPCGUID pEventGUID,
    BSTR    bstrEventDescription,
    BSTR    bstrDeviceID,
    BSTR    bstrDeviceDescription,
    DWORD   dwDeviceType,
    BSTR    bstrFullItemName,
    ULONG  *pulEventType,
    ULONG   ulReserved
)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\eventcallback.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    EventCallback.h

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _EVENTCALLBACK_H_
#define _EVENTCALLBACK_H_

//////////////////////////////////////////////////////////////////////////
//
//
//

class CEventCallback : public IWiaEventCallback
{
public:
    CEventCallback();
    ~CEventCallback();

    // IUnknown interface

    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IWiaEventCallback interface

    STDMETHOD(ImageEventCallback)(
        LPCGUID pEventGUID,
        BSTR    bstrEventDescription,
        BSTR    bstrDeviceID,
        BSTR    bstrDeviceDescription,
        DWORD   dwDeviceType,
        BSTR    bstrFullItemName,
        ULONG  *pulEventType,
        ULONG   ulReserved
    );

private:
    LONG           m_cRef;
};

#endif //_EVENTCALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\globals.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Global.cpp

Abstract:

    Contains the implementions of the common headers and global variable 
    declarations

Author:

    Hakki T. Bostanci (hakkib) 17-Dec-1999

Revision History:

--*/

#include "stdafx.h"

#define IMPLEMENT_GUARDALLOC
#include "GuardAlloc.h"

#define IMPLEMENT_LOGWINDOW
#include "LogWindow.h"

#define IMPLEMENT_ARGV
#include "Argv.h"

#include "WiaStress.h"

CNtLog::CNtLogDLL   CNtLog::m_Dll;
CLorLog::CLorLogDLL CLorLog::m_Dll;

CMyHeap<>           g_MyHeap;
CGuardAllocator     g_GuardAllocator;
CCppMem<CLog>       g_pLog = new CLog;
CLogWindow          g_LogWindow;

CMyCriticalSection  CWiaStressThread::s_PropWriteCritSect;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\logcollect.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    LogCollect.h

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _LOGCOLLECT_H_
#define _LOGCOLLECT_H_

//////////////////////////////////////////////////////////////////////////
//
//
//

extern CLogWindow g_LogWindow;

//////////////////////////////////////////////////////////////////////////
//
// 
//

class CLogCollector
{
public:
    CLogCollector(
        PCTSTR pLocalLogFileName,
        PCTSTR pRemoteBaseDirName
    )
    {
        // store the local log file name

        m_pLocalLogFile = _tcsdupc(pLocalLogFileName);

        // produce a remote file name based on time, user, machine name

        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        m_pRemoteLogFile = bufprintf(
            //LONG_PATH 
            _T("%s\\%02d-%02d-%04d_%02d-%02d-%02d_%s_%s.log"),
            pRemoteBaseDirName,
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            (PCTSTR) CUserName(),
            (PCTSTR) CComputerName()
        );

        // create the worker thread 
        // we don't want a test thread to crash while a log copy is in progress,
        // so make sure this thread runs in highest priority class

        m_Thread = CThread(
            CopyLogFileThreadProc, 
            this, 
            0, 
            0, 
            CREATE_SUSPENDED
        );

        SetThreadPriority(m_Thread, THREAD_PRIORITY_HIGHEST);

        ResumeThread(m_Thread);
    }

    ~CLogCollector()
    {
        // flush the log

        g_pLog = new CLog;

        // copy it to the server

        CopyLogFile();

        // wait for the worker thread to die

        m_Thread.WaitForSingleObject();
    }

private:
    void CopyLogFile()
    {
        try 
        {
            // copy (the last 8k of) the log file to the remote location

            CInFile InFile(m_pLocalLogFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE);

            COutFile OutFile(m_pRemoteLogFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE);

            SetFilePointer(InFile, -1 * 8 * 1024, 0, FILE_END);

            CopyFileContents(InFile, OutFile);

            // get the current time

            SYSTEMTIME st;

            GetSystemTime(&st);

            FILETIME ft;

            SystemTimeToFileTime(&st, &ft);

            // update the remote log file time

            SetFileTime(OutFile, &ft, &ft, &ft);
        }
        catch (...)
        {
            // don't die on any exception...
        }       
    }

    static DWORD WINAPI CopyLogFileThreadProc(PVOID pThreadParameter)
    {
        // copy the log file every 5 minutes until the app is closed

        CLogCollector *that = (CLogCollector *) pThreadParameter;

        do
        {
            that->CopyLogFile();
        }
        while (g_LogWindow.WaitForSingleObject(5 * 60 * 1000) == WAIT_TIMEOUT);

        return TRUE;
    }

private:
    CCppMem<TCHAR> m_pLocalLogFile;
    CCppMem<TCHAR> m_pRemoteLogFile;
    CThread        m_Thread;
};

#endif //_LOGCOLLECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\pushdlgbutton.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    PushDlgButton.h

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _PUSHDLGBUTTON_H_
#define _PUSHDLGBUTTON_H_

//////////////////////////////////////////////////////////////////////////
//
//
//

class CPushDlgButton
{
public:
    CPushDlgButton(
        DWORD  dwWatchThread,
        PCTSTR pszTitle,
        int    nButtonId
    ) :
        m_dwWatchThread(dwWatchThread),
        m_pszTitle(pszTitle),
        m_nButtonId(nButtonId),
        m_StopEvent(TRUE, FALSE),
        m_Thread(ThreadProc, this),
        m_nMatchingWindows(0),
        m_nMatchingButtons(0),
        m_nListItems(0)
    {
    }

    ~CPushDlgButton()
    {
        m_StopEvent.Set();
        m_Thread.WaitForSingleObject();
    }

private:
    static DWORD WINAPI ThreadProc(PVOID pParameter)
    {
        CPushDlgButton *that = (CPushDlgButton *) pParameter;

        try 
        {
            while (that->m_StopEvent.WaitForSingleObject(1000) == WAIT_TIMEOUT)
            {
                EnumThreadWindows(that->m_dwWatchThread, EnumThreadWndProc, (LPARAM) that);
            }
        }
        catch (const CError &)
        {
        }

        return TRUE;
    }

    static BOOL CALLBACK EnumThreadWndProc(HWND hWnd, LPARAM lParam)
    {
        CPushDlgButton *that = (CPushDlgButton *) lParam;

        if (_tcscmp(CSafeWindowText(hWnd), that->m_pszTitle) == 0)
        {
            ++that->m_nMatchingWindows;

            EnumChildWindows(hWnd, EnumChildProc, lParam);

            if (that->m_nMatchingButtons)
            {
                PostMessage(hWnd, WM_COMMAND, that->m_nButtonId, 0);
            }

            while (IsWindow(hWnd))
            {
                Sleep(100);
            }
        }

	    return TRUE;
    }

    static BOOL CALLBACK EnumChildProc(HWND hWnd, LPARAM lParam)
    {
        CPushDlgButton *that = (CPushDlgButton *) lParam;

        if (GetDlgCtrlID(hWnd) == that->m_nButtonId) 
        {
            ++that->m_nMatchingButtons;
	    }
        else if (_tcscmp(CClassName(hWnd), _T("SysListView32")) == 0) 
        {
            that->m_nListItems = ListView_GetItemCount(hWnd);
        }

        return TRUE;
    }

public:
    int     m_nMatchingWindows;
    int     m_nMatchingButtons;
    int     m_nListItems;

private:
    DWORD   m_dwWatchThread;
    PCTSTR  m_pszTitle;
    int     m_nButtonId;
    Event   m_StopEvent;
    CThread m_Thread;
};

#endif //_PUSHDLGBUTTON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\logwindow.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    LogWindow.h

Abstract:

    Implementation of the log window

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef LOGWINDOW_H
#define LOGWINDOW_H

//////////////////////////////////////////////////////////////////////////
//
//

#include <assert.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <commctrl.h>
#include <lmcons.h>
#include <set>

#pragma comment(lib, "user32")
#pragma comment(lib, "advapi32")
#pragma comment(lib, "comctl32")

#include "Conv.h"
#include "Wrappers.h"
#include "MyHeap.h"

//////////////////////////////////////////////////////////////////////////
//
//

#define ID_EDIT_COMMENT                 1132
#define ID_COPY_MESSAGE                 1133
#define ID_PAUSE_OUTPUT                 1134
#define IDB_STATES                      999


#ifndef LOG_LEVELS
#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.
#endif //LOG_LEVELS

//////////////////////////////////////////////////////////////////////////
//
//

class CLogWindow
{
private:
    CLogWindow(const CLogWindow &) {} 
    CLogWindow &operator =(const CLogWindow &) { return *this; } 

public:
    CLogWindow();
    ~CLogWindow();

    void Create(PCTSTR pTitle, HWND hWndParent, HICON hIcon, ULONG nMaxNumMessages = -1);
    void Destroy();

    PCTSTR
    Log(
        int    nLogLevel,
        PCTSTR pszFileName,
        int    nCode,
        PCTSTR pszMessage,
        PCTSTR pszStatus
    ) const;

    void SetTitle(PCTSTR pTitle)
    {
        m_pTitle = pTitle;
        SetWindowText(m_hWnd, pTitle);
    }

    DWORD 
    WaitForSingleObject(
        DWORD dwMilliseconds = INFINITE,
        BOOL  bAlertable = FALSE
    ) const
    {
        return m_Closed.WaitForSingleObject(dwMilliseconds, bAlertable);
    }

    BOOL IsClosed() const
    {
        return m_bIsClosed;
    }

    void Close(bool bClose = true)
    {
        if (bClose)
        {
            InterlockedExchange(&m_bIsClosed, TRUE);
            m_Closed.Set();
        }
        else
        {
            InterlockedExchange(&m_bIsClosed, FALSE);
            m_Closed.Reset();
        }
    }

    BOOL IsDirty() const
    {   
        return m_bIsDirty;
    }

    HWND GetSafeHwnd() const
    {
        return m_hWnd;
    }

    HANDLE GetWaitHandle() const
    {
        return m_Closed;
    }

    class CSavedData;

    struct CListData 
    {
        CMyStr m_strMsgNum;
        CMyStr m_strLogLevel;
        CMyStr m_strFileName;
        CMyStr m_strCode;
        CMyStr m_strMessage;
        CMyStr m_strComment;

        CListData(
            PCTSTR pszMsgNum,
            PCTSTR pszLogLevel,
            PCTSTR pszFileName,
            PCTSTR pszCode,
            PCTSTR pszMessage,
            const  CSavedData &rSavedData
        );

        explicit CListData(PTSTR pszLine);

        void * operator new(size_t, void *pPlacement)
        {
            return pPlacement;
        }

#if _MSC_VER >= 1200
        void operator delete(void *, void *)
        {
        }
#endif

        void * operator new(size_t nSize)
        {
            return g_MyHeap.allocate(nSize);
        }

        void operator delete(void *pMem)
        {
            g_MyHeap.deallocate(pMem);
        }

        bool operator ==(const CListData &rhs) const;
        bool operator <(const CListData &rhs) const;

        void Write(FILE *fOut) const;

        static PCTSTR GetArg(PTSTR *pszStr);
    };

    class CSavedData : public std::set<CListData, std::less<CListData>, CMyAlloc<CListData> >
    {
    public:
        void Read(FILE *fIn);
        void Write(FILE *fOut, PCTSTR pComments = 0) const;

        void
        Merge(
            const CSavedData &rNewData,
            CSavedData       &rCollisions
        );

        CMyStr m_strUserName;
    };

    BOOL ReadSavedData(PCTSTR pFileName);
    BOOL WriteSavedData(PCTSTR pFileName, PCTSTR pComments = 0);
    BOOL WriteModifiedData(PCTSTR pFileName, PCTSTR pComments = 0);

    static
    BOOL
    FindNtLogLevel(
        DWORD   dwLogLevel,
        PCTSTR *ppszText,
        int    *piImage
    );

private:
    typedef enum 
    { 
        ID_FIRSTCOLUMN = 0,
        ID_LOGLEVEL    = 0, 
        ID_MSGNUM      = 1, 
        ID_CODE        = 2, 
        ID_FILENAME    = 3, 
        ID_MESSAGE     = 4, 
        ID_COMMENT     = 5,
        ID_LASTCOLUMN  = 5
    };

    static CLogWindow *This(HWND hWnd)
    {
        return (CLogWindow *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    }

    CListData *GetItemData(int nItem) const
    {
        return (CListData *) ListView_GetItemData(m_hList, nItem);
    }

    static DWORD WINAPI ThreadProc(PVOID pParameter);

    static ATOM RegisterLogWindow(HICON hIcon);

    static 
    LRESULT
    CALLBACK 
    DialogProc(
        HWND   hWnd,
        UINT   uMsg,
        WPARAM wParam,
        LPARAM lParam
    );

    LRESULT OnCreate(HWND hWnd);

    LRESULT OnClose();

    LRESULT OnSize(UINT nType, int nW, int nH);

    LRESULT OnCopyToClipboard() const;

    BOOL 
    CopySelectedItemsToBuffer(
        HANDLE hMem,
        PDWORD pdwBufferSize
    ) const;

    LRESULT OnEditComment() const;

    LRESULT OnPauseOutput();

    void PlaceEditControlOnEditedItem(HWND hEdit) const;

    LRESULT OnGetDispInfo(NMLVDISPINFO *pnmv);

    LRESULT OnColumnClick(LPNMLISTVIEW pnmv);

    static
    int 
    CALLBACK 
    CompareFunc(
        LPARAM lParam1, 
        LPARAM lParam2, 
        LPARAM lParamSort
    );

    LRESULT OnBeginLabelEdit(NMLVDISPINFO *pdi);

    LRESULT OnEndLabelEdit(NMLVDISPINFO *pdi);

    LRESULT OnKeyDown(LPNMLVKEYDOWN pnkd);

    LRESULT OnRButtonDown();

public: 
    CSavedData   m_SavedData;

private:
    PCTSTR          m_pTitle;
    HWND            m_hWndParent;
    HICON           m_hIcon;
    Event           m_InitComplete;
    CThread         m_Thread;
    HWND            m_hWnd;
    HWND            m_hList;
    HWND            m_hStatWnd;
    LONG            m_bIsClosed;
    Event           m_Closed;
    int             m_SortByHistory[ID_LASTCOLUMN - ID_FIRSTCOLUMN + 1];
    mutable LONG    m_nMsgNum;
    int             m_nEditedItem;
    int             m_bIsDirty;
    LONG            m_bIsPaused;
    Event           m_Resume;
    ULONG           m_nMaxNumMessages;

    mutable CMySimpleCriticalSection m_cs;
};

#ifdef IMPLEMENT_LOGWINDOW

//////////////////////////////////////////////////////////////////////////
//
// 
//

CLogWindow::CLogWindow() : 
    m_bIsClosed(TRUE),
    m_Closed(TRUE, TRUE), 
    m_bIsPaused(FALSE),
    m_Resume(TRUE, TRUE)
{
    m_hWndParent     = 0;
    m_hWnd           = 0;

    m_nMsgNum        = 0;

    for (int i = 0; i < COUNTOF(m_SortByHistory); ++i) 
    {
        m_SortByHistory[i] = 0;
    }

    m_bIsDirty  = FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

CLogWindow::~CLogWindow()
{
    Destroy();
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CLogWindow::Create(PCTSTR pTitle, HWND hWndParent, HICON hIcon, ULONG nMaxNumMessages /*= -1*/)
{
    m_pTitle          = pTitle;
    m_hWndParent      = hWndParent;
    m_hIcon           = hIcon;
    m_nMaxNumMessages = nMaxNumMessages;
    m_InitComplete    = Event(TRUE, FALSE);
    m_Thread          = CThread(ThreadProc, this);

    m_InitComplete.WaitForSingleObject();
    m_InitComplete.Detach();
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CLogWindow::Destroy()
{
    //bugbug: this should be handled in WM_DESTROY

    int nCount = ListView_GetItemCount(m_hList);

    for (int i = 0; i < nCount; ++i) 
    {
        CListData *pData = GetItemData(i);
        ListView_SetItemData(m_hList, i, 0);
        delete pData;
    }

    if (m_Thread.IsAttached()) 
    {
        PostThreadMessage(m_Thread, WM_QUIT, 0, 0);
        m_Thread.WaitForSingleObject();
        m_Thread.Detach();
    }

    m_hWnd    = 0;

    m_nMsgNum = 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

PCTSTR
CLogWindow::Log(
    int    nLogLevel,
    PCTSTR pszFileName,
    int    nCode,
    PCTSTR pszMessage,
    PCTSTR pszStatus
) const
{
    if (m_bIsPaused)
    {
        m_Resume.WaitForSingleObject();
    }

    // get a new entry number for this item

    LONG nMsgNum = InterlockedIncrement(&m_nMsgNum);

    if ((ULONG) nMsgNum >= m_nMaxNumMessages)
    {
        m_cs.Enter();
        CListData *pData = GetItemData(0);
        ListView_DeleteItem(m_hList, 0);
        m_cs.Leave();
        delete pData;
    }

    // prepare the CListData entry for this item

    PCTSTR pszLogLevelText;
    int    nLogLevelImage;

    FindNtLogLevel(nLogLevel, &pszLogLevelText, &nLogLevelImage);

    TCHAR szMsgNum[48];
    _itot(nMsgNum, szMsgNum, 10);

    TCHAR szCode[48];
    _itot(nCode, szCode, 10);

    CListData *pData = new CListData(
        szMsgNum, 
        pszLogLevelText, 
        pszFileName, 
        szCode, 
        pszMessage,
        m_SavedData
    );

    // insert this new item

    LVITEM item;
	item.mask     = LVIF_IMAGE | LVIF_PARAM | LVIF_TEXT; 
	item.iItem    = nMsgNum - 1;
	item.iSubItem = 0;
	item.iImage   = nLogLevelImage;
    item.lParam   = (LPARAM) pData;
    item.pszText  = LPSTR_TEXTCALLBACK;

    int iItem = ListView_InsertItem(m_hList, &item);
    ListView_EnsureVisible(m_hList, iItem, TRUE);

    SendMessage(m_hStatWnd, SB_SETTEXT, (WPARAM) SB_SIMPLEID, (LPARAM) pszStatus);

    return pData->m_strComment;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL
CLogWindow::FindNtLogLevel(
    DWORD   dwLogLevel,
    PCTSTR *ppszText,
    int    *piImage
) 
{
    dwLogLevel &= ~(
        TLS_CALLTREE | TLS_BREAK | TLS_SYSTEM | TLS_TESTDEBUG | 
        TLS_TEST | TLS_VARIATION
    );

    switch (dwLogLevel) 
    {
    case TLS_INFO:
        *ppszText = _T("Info");
        *piImage  = 5;
        return TRUE;

    case TLS_ABORT:
        *ppszText = _T("Abort");
        *piImage  = 0;
        return TRUE;

    case TLS_SEV1:
        *ppszText = _T("Sev1");
        *piImage  = 1;
        return TRUE;

    case TLS_SEV2:
        *ppszText = _T("Sev2");
        *piImage  = 2;
        return TRUE;

    case TLS_SEV3:
        *ppszText = _T("Sev3");
        *piImage  = 3;
        return TRUE;

    case TLS_WARN:
        *ppszText = _T("Warn");
        *piImage  = 4;
        return TRUE;

    case TLS_PASS:
        *ppszText = _T("Pass");
        *piImage  = 0;
        return TRUE;

    case TLS_BLOCK:
        *ppszText = _T("Block");
        *piImage  = 0;
        return TRUE;
    }

    *ppszText = 0;
    *piImage  = 0;
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

DWORD WINAPI CLogWindow::ThreadProc(PVOID pParameter)
{
    CLogWindow *that = (CLogWindow *) pParameter;

    static ATOM pClassName = RegisterLogWindow(that->m_hIcon);

    CreateWindow(
        (PCTSTR) pClassName,
        that->m_pTitle,
        WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        785, 
        560,
        that->m_hWndParent,
        0,
        GetModuleHandle(0),
        that
    );

    MSG msg;

    while (GetMessage(&msg, 0, 0, 0)) 
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}                  

//////////////////////////////////////////////////////////////////////////
//
// 
//

ATOM CLogWindow::RegisterLogWindow(HICON hIcon)
{
    WNDCLASSEX wcex = { 0 };

    wcex.cbSize         = sizeof(WNDCLASSEX);
    wcex.lpfnWndProc    = DialogProc;
    wcex.hInstance      = GetModuleHandle(0);
    wcex.hIcon			= hIcon;
    wcex.hCursor		= LoadCursor(0, IDC_ARROW);
    wcex.lpszClassName  = _T("LOGWINDOW");

    return RegisterClassEx(&wcex);
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT
CALLBACK 
CLogWindow::DialogProc(
    HWND   hWnd,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg) 
    {
    case WM_CREATE:
        return ((CLogWindow *)((LPCREATESTRUCT)lParam)->lpCreateParams)->OnCreate(hWnd);

    case WM_CLOSE:
        return This(hWnd)->OnClose();

    case WM_SIZE:
        return This(hWnd)->OnSize((UINT)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_COMMAND: 
    {
        CLogWindow *that = This(hWnd);

        HWND hEdit = ListView_GetEditControl(that->m_hList);
	    
        if (hEdit != 0 && hEdit == (HWND) lParam) 
        {
            that->PlaceEditControlOnEditedItem(hEdit);
        } 
        else 
        {
            switch (LOWORD(wParam)) 
            {
            case ID_COPY_MESSAGE:
                return that->OnCopyToClipboard();
            
            case ID_EDIT_COMMENT:
                return that->OnEditComment();

            case ID_PAUSE_OUTPUT:
                return that->OnPauseOutput();
            }
        }

        break;
    }

    case WM_USER + 1: 
    {
        CLogWindow *that = This(hWnd);

        HWND hEdit = ListView_GetEditControl(that->m_hList);
	    
	    if (hEdit != 0) 
        {
            that->PlaceEditControlOnEditedItem(hEdit);
	    }

        break;
    }

    case WM_NOTIFY:
        switch (((LPNMHDR) lParam)->code) 
        {
        case LVN_GETDISPINFO:
            return This(hWnd)->OnGetDispInfo((NMLVDISPINFO *) lParam);

        case LVN_COLUMNCLICK:
            return This(hWnd)->OnColumnClick((LPNMLISTVIEW) lParam);

        case LVN_BEGINLABELEDIT:
            return This(hWnd)->OnBeginLabelEdit((NMLVDISPINFO *) lParam);

        case LVN_ENDLABELEDIT:
            return This(hWnd)->OnEndLabelEdit((NMLVDISPINFO *) lParam);

        case LVN_KEYDOWN:
            return This(hWnd)->OnKeyDown((LPNMLVKEYDOWN) lParam);

        case NM_RCLICK:
            return This(hWnd)->OnRButtonDown();
        }
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnCreate(HWND hWnd)
{
    m_hWnd = hWnd;
    SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (LONG_PTR) this);

    m_hStatWnd = CreateStatusWindow(WS_CHILD | WS_VISIBLE, 0, m_hWnd, 0);

    SendMessage(m_hStatWnd, SB_SIMPLE, (WPARAM) TRUE, (LPARAM) 0);

    m_hList = CreateWindow(
        _T("SysListView32"),
        0,
        WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_EDITLABELS,
        0,
        0,
        0,
        0,
        m_hWnd,
        0,
        GetModuleHandle(0),
        0
    );

    ListView_SetExtendedListViewStyle(
        m_hList, 
        LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP 
    );

    HIMAGELIST hImgList = ImageList_LoadBitmap(
        GetModuleHandle(0),
        MAKEINTRESOURCE(IDB_STATES),
        16,
        0,
        RGB(255, 255, 255)
    );
	
    if (hImgList) 
    {
        ListView_SetImageList(m_hList, hImgList, LVSIL_SMALL);
    }

    ListView_InsertColumn2(m_hList, 0, _T("Type"),    LVCFMT_LEFT,  60, ID_LOGLEVEL);
    ListView_InsertColumn2(m_hList, 1, _T("#"),       LVCFMT_LEFT,  40, ID_MSGNUM);
	ListView_InsertColumn2(m_hList, 2, _T("Code"),    LVCFMT_LEFT,  40, ID_CODE);
	ListView_InsertColumn2(m_hList, 3, _T("File"),    LVCFMT_LEFT, 100, ID_FILENAME);
	ListView_InsertColumn2(m_hList, 4, _T("Message"), LVCFMT_LEFT, 420, ID_MESSAGE);
	ListView_InsertColumn2(m_hList, 5, _T("Comment"), LVCFMT_LEFT, 100, ID_COMMENT);

    SetForegroundWindow(m_hList);

    InterlockedExchange(&m_bIsClosed, FALSE);
    m_Closed.Reset();

    m_InitComplete.Set();

    return 0;
}


//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnClose()
{
    if (!m_bIsClosed)
    {
        InterlockedExchange(&m_bIsClosed, TRUE);
        m_Closed.Set();

        if (m_bIsPaused)
        {
            InterlockedExchange(&m_bIsPaused, FALSE);
            m_Resume.Set();
        }

        TCHAR szNewTitle[MAX_PATH];
        _tcscpy(szNewTitle, m_pTitle);
        _tcscat(szNewTitle, _T(" <closing>"));;
        SetWindowText(m_hWnd, szNewTitle);
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnSize(UINT nType, int nW, int nH)
{
    RECT r;

    GetWindowRect(m_hStatWnd, &r);

    int nStatWndH = r.bottom - r.top;

    MoveWindow(m_hList, 0, 0, nW, nH - nStatWndH, TRUE);

    TCHAR szBuffer[1024]; // ***bugbug: figure out why the statwnd forgets its caption

    SendMessage(m_hStatWnd, SB_GETTEXT, (WPARAM) SB_SIMPLEID, (LPARAM) szBuffer);

    MoveWindow(m_hStatWnd, 0, nH - nStatWndH, nW, nStatWndH, TRUE);

    SendMessage(m_hStatWnd, SB_SETTEXT, (WPARAM) SB_SIMPLEID, (LPARAM) szBuffer);

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnCopyToClipboard() const
{
    HANDLE hMem = 0;

    for (
        DWORD dwSize = 4 * 1024;
        (hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, dwSize)) != 0 &&
        !CopySelectedItemsToBuffer(hMem, &dwSize);
        GlobalFree(hMem)
    ) 
    {
        // start with a 4KB buffer size
        // if buffer allocation fails, exit
        // if CopySelectedItemsToBuffer succeeds, exit
        // otherwise, delete the buffer and retry
    }

    if (hMem) 
    {
        BOOL bResult = FALSE;

        if (OpenClipboard(m_hWnd)) 
        {
            if (EmptyClipboard()) 
            {
                if (SetClipboardData(CF_TEXT, hMem)) 
                {
                    bResult = TRUE;
                }
            }

            CloseClipboard();
        }

        if (!bResult) 
        {
            GlobalFree(hMem);
        }
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL 
CLogWindow::CopySelectedItemsToBuffer(
    HANDLE hMem,
    PDWORD pdwBufferSize
) const
{
    PSTR pMem = (PSTR) GlobalLock(hMem);

    CBufferFill Buffer(pMem, *pdwBufferSize);

    if (pMem) 
    {
        int nItem = -1; 

        while ((nItem = ListView_GetNextItem(m_hList, nItem, LVNI_SELECTED)) != -1) 
        {
            USES_CONVERSION;

            CListData *pData = GetItemData(nItem);

            if (pData->m_strFileName && *pData->m_strFileName) 
            {
                Buffer.AddTop(CStrBlob(T2A(pData->m_strFileName)));
                Buffer.AddTop(CStrBlob(": "));
            }

            Buffer.AddTop(CStrBlob(T2A(pData->m_strMessage)));

            if (pData->m_strComment && *pData->m_strComment) 
            {
                Buffer.AddTop(CStrBlob(" ("));
                Buffer.AddTop(CStrBlob(T2A(pData->m_strComment)));
                Buffer.AddTop(CStrBlob(")"));
            }

            Buffer.AddTop(CStrBlob("\r\n"));
        }

        Buffer.AddTop(CSzBlob("")); // terminating NULL

        GlobalUnlock(hMem);
    }

    *pdwBufferSize -= (DWORD) Buffer.BytesLeft();

    return Buffer.BytesLeft() >= 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnEditComment() const
{
    if (m_nEditedItem != -1) 
    {
        ListView_EditLabel(m_hList, m_nEditedItem);
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnPauseOutput() 
{
    if (m_bIsPaused)
    {
        InterlockedExchange(&m_bIsPaused, FALSE);
        m_Resume.Set();

        SetWindowText(m_hWnd, m_pTitle);
    }
    else
    {
        InterlockedExchange(&m_bIsPaused, TRUE);
        m_Resume.Reset();

        TCHAR szNewTitle[MAX_PATH];
        _tcscpy(szNewTitle, m_pTitle);
        _tcscat(szNewTitle, _T(" <paused>"));;
        SetWindowText(m_hWnd, szNewTitle);
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CLogWindow::PlaceEditControlOnEditedItem(HWND hEdit) const
{
    RECT r;

    ListView_GetSubItemRect(
        m_hList,
        m_nEditedItem,
        ID_COMMENT,
        LVIR_LABEL,
        &r
    );

    MoveWindow(
        hEdit, 
        r.left, 
        r.top, 
        r.right - r.left, 
        r.bottom - r.top, 
        TRUE
    );
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnGetDispInfo(NMLVDISPINFO *pnmv)
{
    ASSERT(pnmv->item.mask == LVIF_TEXT);

    CListData *pData = (CListData *) pnmv->item.lParam;

    if (pData)
    {
        switch (pnmv->item.iSubItem) 
        {
        case ID_LOGLEVEL: pnmv->item.pszText = pData->m_strLogLevel; break;
        case ID_MSGNUM:   pnmv->item.pszText = pData->m_strMsgNum;   break;
        case ID_CODE:     pnmv->item.pszText = pData->m_strCode;     break;
        case ID_FILENAME: pnmv->item.pszText = pData->m_strFileName; break;
        case ID_MESSAGE:  pnmv->item.pszText = pData->m_strMessage;  break;
        case ID_COMMENT:  pnmv->item.pszText = pData->m_strComment;  break;
        default:          ASSERT(FALSE);
        }

        ASSERT(pnmv->item.pszText);
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnColumnClick(LPNMLISTVIEW pnmv)
{
    // convert zero based column number to one based, as
    // we will use negative numbers to indicate sort direction

    int nColumn = pnmv->iSubItem + 1;

    if (Abs(m_SortByHistory[0]) == nColumn) 
    {
        // if the user has pressed a column header twice, 
        // reverse the sort direction

        m_SortByHistory[0] *= -1;
    } 
    else 
    {
        // if the user has selected a new column, slide down
        // the history list and enter the new column to the top
        // position. Also keep the last entry, that will eventually 
        // end the recursive CompareFunc in the worst case

        for (int i = COUNTOF(m_SortByHistory) - 2; i >= 1; --i) 
        {
            m_SortByHistory[i] = m_SortByHistory[i-1];
        }

        m_SortByHistory[0] = nColumn;
    }

    // sort the items

    ListView_SortItems(m_hList, CompareFunc, m_SortByHistory);

    // ensure that the selected item is visible

    ListView_EnsureVisible(
        m_hList, 
        ListView_GetNextItem(m_hList, -1, LVNI_SELECTED), 
        TRUE
    );

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

int 
CALLBACK 
CLogWindow::CompareFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    CListData *pData1  = (CListData *) lParam1;
    CListData *pData2  = (CListData *) lParam2;
    int *SortByHistory = (int *) lParamSort;

    ASSERT(pData1);
    ASSERT(pData2);
    ASSERT(SortByHistory);

	int nSortDir = 1;
    int nColumn  = SortByHistory[0];

	if (nColumn < 0) 
    {
		nSortDir *= -1;
		nColumn  *= -1;
	}

    int nResult = 0;

    switch (nColumn) 
    {
    case 0:
        nResult = -1;
        break;

    case ID_MSGNUM + 1:
        nResult = Cmp(_ttoi(pData1->m_strMsgNum), _ttoi(pData2->m_strMsgNum));
        break;

    case ID_LOGLEVEL + 1:
        nResult = _tcscmp(pData1->m_strLogLevel, pData2->m_strLogLevel);
        break;

    case ID_FILENAME + 1:
        nResult = _tcscmp(pData1->m_strFileName, pData2->m_strFileName);
        break;

    case ID_CODE + 1:
        nResult = Cmp(_ttoi(pData1->m_strCode), _ttoi(pData2->m_strCode));
        break;

    case ID_MESSAGE + 1:
        nResult = _tcscmp(pData1->m_strMessage, pData2->m_strMessage);
        break;

    case ID_COMMENT + 1:
        nResult = _tcscmp(pData1->m_strComment, pData2->m_strComment);
        break;

    default:
        ASSERT(FALSE);
    }

    // in case of equality, go on with the comparison using the next 
    // column in the history list

    return nResult != 0 ? 
        nSortDir * nResult : 
        CompareFunc(lParam1, lParam2, (LPARAM) (SortByHistory + 1));
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnBeginLabelEdit(NMLVDISPINFO *pdi)
{
    HWND hEdit = ListView_GetEditControl(m_hList);

    if (hEdit) 
    {
        CListData *pData = GetItemData(pdi->item.iItem); 

        SetWindowText(hEdit, pData->m_strComment);

        m_nEditedItem = pdi->item.iItem;

        PostMessage(m_hWnd, WM_USER + 1, 0, 0);
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnEndLabelEdit(NMLVDISPINFO *pdi) 
{
    if (pdi->item.iItem != -1 && pdi->item.pszText != 0) 
    {
        CListData *pData = GetItemData(pdi->item.iItem); 

        if (_tcscmp(pData->m_strComment, pdi->item.pszText) != 0) 
        {
            // save the comment

            pData->m_strComment = pdi->item.pszText;

            // replace the tabs (if any) with space, we use tabs as 
            // the column delimiter character

            for (
                PTSTR pszTab = _tcschr(pData->m_strComment, _T('\t'));
                pszTab;
                pszTab = _tcschr(pszTab + 1, _T('\t'))
            ) 
            {
                *pszTab = _T(' ');
            }

            ListView_SetItemText(m_hList, pdi->item.iItem, ID_COMMENT, pData->m_strComment);

            // save this new entry

            m_SavedData.erase(*pData);
            m_SavedData.insert(*pData);

            m_bIsDirty = TRUE;
        }
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnKeyDown(LPNMLVKEYDOWN pnkd)
{
    if (pnkd->wVKey == VK_INSERT && GetKeyState(VK_CONTROL) < 0) // CTRL+INS
    {
        return OnCopyToClipboard();
    } 
    else if (pnkd->wVKey == VK_RETURN) 
    {
        m_nEditedItem = ListView_GetSelectionMark(m_hList);

        return OnEditComment();
    }
    else if (pnkd->wVKey == VK_PAUSE) 
    {
        return OnPauseOutput();
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

LRESULT CLogWindow::OnRButtonDown() 
{
    POINT p;
    GetCursorPos(&p);

    LVHITTESTINFO lvHitTestInfo;

    lvHitTestInfo.pt = p;

    ScreenToClient(m_hList, &lvHitTestInfo.pt);

    ListView_HitTest(m_hList, &lvHitTestInfo);

    m_nEditedItem = lvHitTestInfo.iItem;

    HMENU hMenu = CreatePopupMenu();

    if (hMenu) 
    {
        AppendMenu(hMenu, MF_STRING, ID_EDIT_COMMENT, _T("&Edit\tEnter"));

        AppendMenu(hMenu, MF_STRING, ID_COPY_MESSAGE, _T("&Copy\tCtrl+Ins"));

        AppendMenu(hMenu, MF_STRING, ID_PAUSE_OUTPUT, m_bIsPaused ? _T("&Resume") : _T("&Pause"));

        TrackPopupMenu(
            hMenu,
            TPM_LEFTALIGN | TPM_TOPALIGN,
            p.x,
            p.y,
            0,
            m_hWnd,
            0
        );

        DestroyMenu(hMenu);
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

CLogWindow::CListData::CListData(
    PCTSTR pszMsgNum,
    PCTSTR pszLogLevel,
    PCTSTR pszFileName,
    PCTSTR pszCode,
    PCTSTR pszMessage,
    const  CSavedData &rSavedData
) :
    m_strMsgNum(pszMsgNum),
    m_strLogLevel(pszLogLevel),
    m_strFileName(pszFileName),
    m_strCode(pszCode),
    m_strMessage(pszMessage)
{
    CSavedData::const_iterator itData = rSavedData.find(*this);
    m_strComment = itData != rSavedData.end() ? itData->m_strComment : _T("");
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

CLogWindow::CListData::CListData(
    PTSTR pszLine
) :
    m_strLogLevel(GetArg(&pszLine)),
    m_strFileName(GetArg(&pszLine)),
    m_strCode(GetArg(&pszLine)),
    m_strMessage(GetArg(&pszLine)),
    m_strComment(GetArg(&pszLine))
{
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

bool CLogWindow::CListData::operator ==(const CListData &rhs) const
{
    return
        _tcscmp(m_strMessage,  rhs.m_strMessage)  == 0 &&
        _tcscmp(m_strCode,     rhs.m_strCode)     == 0 &&
        _tcscmp(m_strFileName, rhs.m_strFileName) == 0 &&
        _tcscmp(m_strLogLevel, rhs.m_strLogLevel) == 0;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

bool CLogWindow::CListData::operator <(const CListData &rhs) const
{
    int nCmpMessage, nCmpCode, nCmpFileName, nCmpLogLevel;

    return 
        ((nCmpMessage = _tcscmp(m_strMessage, rhs.m_strMessage)) < 0 ||
            (nCmpMessage == 0 && 
                ((nCmpCode = _tcscmp(m_strCode, rhs.m_strCode)) < 0 ||
                    (nCmpCode == 0 &&
                        ((nCmpFileName = _tcscmp(m_strFileName, rhs.m_strFileName)) < 0 || 
                            (nCmpFileName == 0 &&
                                ((nCmpLogLevel = _tcscmp(m_strLogLevel, rhs.m_strLogLevel)) < 0)
                            )
                        )
                    )
                )
            )
        );
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CLogWindow::CListData::Write(FILE *fOut) const
{
    _ftprintf(
        fOut,
        _T("%s\t%s\t%s\t%s\t%s\r\n"),
        m_strLogLevel,
        m_strFileName,
        m_strCode,
        m_strMessage,
        m_strComment
    );
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

PCTSTR CLogWindow::CListData::GetArg(PTSTR *pszStr)
{
    PTSTR pszStart = *pszStr;
    PTSTR pszEnd   = pszStart;

    while (
        *pszEnd != '\t' && 
        *pszEnd != '\n' && 
        *pszEnd != '\r' && 
        *pszEnd != '\0'
    ) 
    {
        pszEnd = CharNext(pszEnd);
    }

    *pszStr = CharNext(pszEnd);

    while (
        **pszStr == '\n' || 
        **pszStr == '\r'
    ) 
    {
        *pszStr = CharNext(*pszStr);
    }

    *pszEnd = '\0';

    return pszStart;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CLogWindow::CSavedData::Read(FILE *fIn)
{
    TCHAR szLine[4096];

    while (_fgetts(szLine, COUNTOF(szLine), fIn)) 
    {
        if (szLine[0] == _T('#')) 
        {
            *FindEol(szLine) = '\0';
            m_strUserName = szLine + 2;
        }
        else
        {
            insert(CListData(szLine));
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CLogWindow::CSavedData::Write(FILE *fOut, PCTSTR pComments /*= 0*/) const
{
    CUserName UserName;
    CComputerName ComputerName;

    _ftprintf(
        fOut, 
        pComments && *pComments ? _T("# %s@%s %s\n") : _T("# %s@%s\n"), 
        (PCTSTR) UserName, 
        (PCTSTR) ComputerName,
        pComments
    );

    for (
        const_iterator itData = begin(); 
        itData != end(); 
        ++itData
    ) 
    {
        itData->Write(fOut);
    }
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void
CLogWindow::CSavedData::Merge(
    const CSavedData &rNewData,
    CSavedData       &rCollisions
)
{
    rCollisions.clear();

    for (
        const_iterator itData = rNewData.begin(); 
        itData != rNewData.end(); 
        ++itData
    ) 
    {
        const_iterator itMatch = find(*itData);

        if (
            itMatch != end() && 
            _tcscmp(itMatch->m_strComment, itData->m_strComment) != 0
        ) 
        {
            rCollisions.insert(*itMatch);
            erase(itMatch);
        }

        insert(*itData);
    }
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL CLogWindow::ReadSavedData(PCTSTR pFileName)
{
    BOOL bResult = FALSE;

    try 
    {
        m_SavedData.Read(CCFile(pFileName, _T("rt")));

        bResult = TRUE;
    } 
    catch (const CError &) 
    {
        MessageBox(
            0,
            _T("Cannot download the comments from the central database. ")
            _T("Previous comments will not be available on the results window."), 
            0,
            MB_ICONERROR | MB_OK
        );
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL CLogWindow::WriteSavedData(PCTSTR pFileName, PCTSTR pComments /*= 0*/)
{
    BOOL bResult = FALSE;

    HANDLE hFile = CreateFile(  
		pFileName,
		GENERIC_WRITE,
		FILE_SHARE_READ,
		0,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		0
    );

    if (hFile != INVALID_HANDLE_VALUE)
    {
        FILE *fFile = OpenOSHandle(hFile, _O_TEXT, _T("wt"));

        m_SavedData.Write(fFile, pComments);

        bResult = fclose(fFile) == 0;
    }

    return bResult;

    /*BOOL bResult = FALSE;

    try 
    {
        m_SavedData.Write(CCFile(pFileName, _T("wt")), PCTSTR pComments);

        bResult = TRUE;
    } 
    catch (const CError &) 
    {
        //
    }

    return bResult;*/
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL CLogWindow::WriteModifiedData(PCTSTR pFileName, PCTSTR pComments /*= 0*/)
{
    BOOL bResult = TRUE;

    if (
        IsDirty() &&
        MessageBox(
            0,
            _T("You have changed some of the comments on the results window. ")
            _T("Do you want to save these changes to the central database?"), 
            m_pTitle,
            MB_ICONQUESTION | MB_YESNO
        ) == IDYES
    ) 
    {
        bResult = FALSE;

        do 
        { 
            try 
            {
                m_SavedData.Write(CCFile(pFileName, _T("wt")), pComments);

                MessageBox(
                    0,
                    _T("Comments database updated successfully."), 
                    m_pTitle,
                    MB_ICONINFORMATION | MB_OK
                );

                bResult = TRUE;
            } 
            catch (const CError &) 
            {
                // bResult remains FALSE;
            }
        } 
        while (
            !bResult && 
            MessageBox(
                0, 
                _T("Cannot update the results. Do you want to try again?"), 
                0, 
                MB_ICONQUESTION | MB_YESNO
            ) == IDYES
        );
    }

    return bResult;
}

#endif //IMPLEMENT_LOGWINDOW

#endif //PROGRESSDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\guardalloc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    GuardAlloc.h

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _GUARDALLOC_H_
#define _GUARDALLOC_H_

#include <dbghelp.h>
#include <malloc.h>

//////////////////////////////////////////////////////////////////////////
//
//
//

#ifdef _WIN32
#undef  ALIGNMENT
#define ALIGNMENT 8
#endif //WIN32

#ifdef _WIN64
#undef  ALIGNMENT
#define ALIGNMENT 16
#endif //WIN64

//////////////////////////////////////////////////////////////////////////
//
//
//

inline size_t Align(size_t nDataSize, size_t nBlockSize)
{
    return (nDataSize + (nBlockSize-1)) & ~(nBlockSize-1);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

#define MAX_STACK_DEPTH   32
#define MAX_SYMBOL_LENGTH 256

template <int N>
struct CImagehlpSymbol : public IMAGEHLP_SYMBOL 
{
    CImagehlpSymbol()
    {
        ZeroMemory(this, sizeof(*this));
        SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
        MaxNameLength = N;
    }

private:
    CHAR NameData[N-1];
};

struct CImagehlpLine : public IMAGEHLP_LINE
{
    CImagehlpLine()
    {
        ZeroMemory(this, sizeof(*this));
        SizeOfStruct = sizeof(IMAGEHLP_LINE);
    }
};

struct CImagehlpModule : public IMAGEHLP_MODULE
{
    CImagehlpModule()
    {
        ZeroMemory(this, sizeof(*this));
        SizeOfStruct = sizeof(IMAGEHLP_MODULE);
    }
};


//////////////////////////////////////////////////////////////////////////
//
//
//

inline PSTR GetFileNameA(PCSTR pPathName)
{
    PCSTR pFileName = pPathName ? strrchr(pPathName, '\\') : 0;
	return (PSTR) (pFileName ? pFileName + 1 : pPathName);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

inline void GetExceptionContext(LPEXCEPTION_POINTERS pExceptionPointers, CONTEXT *pContext)
{
    *pContext = *pExceptionPointers->ContextRecord;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

inline DWORD GetCurrentMachineType()
{
#if defined(_X86_)
    return IMAGE_FILE_MACHINE_I386;
#elif defined(_MIPS_)
    return IMAGE_FILE_MACHINE_R4000;
#elif defined(_ALPHA_)
    return IMAGE_FILE_MACHINE_ALPHA;
#elif defined(_PPC_)
    return IMAGE_FILE_MACHINE_POWERPC;
#elif defined(_IA64_)
    return IMAGE_FILE_MACHINE_IA64;
#elif defined(_AXP64_)
    return IMAGE_FILE_MACHINE_AXP64;
#else
    return 0;
#endif
}

//////////////////////////////////////////////////////////////////////////
//
//
//

class CStackFrame : public STACKFRAME
{
public:
    CStackFrame()
    {
    }

    CStackFrame(CONTEXT *pContext)
    {
        ZeroMemory(this, sizeof(*this));

    #if defined(_X86_)
        AddrPC.Offset    = pContext->Eip;
        AddrFrame.Offset = pContext->Ebp;
        AddrStack.Offset = pContext->Esp;
    #elif defined(_MIPS_)
        AddrPC.Offset    = pContext->Fir;
        AddrFrame.Offset = pContext->IntS6;
        AddrStack.Offset = pContext->IntSp;
    #elif defined(_ALPHA_)
        AddrPC.Offset    = pContext->Fir;
        AddrFrame.Offset = pContext->IntFp;
        AddrStack.Offset = pContext->IntSp;
    #elif defined(_PPC_)
        AddrPC.Offset    = pContext->Iar;
        AddrFrame.Offset = pContext->IntFp;
        AddrStack.Offset = pContext->Gpr1;
    #endif

        AddrPC.Mode      = AddrModeFlat;
        AddrFrame.Mode   = AddrModeFlat;
        AddrStack.Mode   = AddrModeFlat;
    }

    BOOL
    Walk(
        DWORD                           MachineType                = GetCurrentMachineType(),
        HANDLE                          hProcess                   = GetCurrentProcess(),
        HANDLE                          hThread                    = GetCurrentThread(),
        PVOID                           ContextRecord              = 0,
        PREAD_PROCESS_MEMORY_ROUTINE    ReadMemoryRoutine          = 0,
        PFUNCTION_TABLE_ACCESS_ROUTINE  FunctionTableAccessRoutine = SymFunctionTableAccess,
        PGET_MODULE_BASE_ROUTINE        GetModuleBaseRoutine       = SymGetModuleBase,
        PTRANSLATE_ADDRESS_ROUTINE      TranslateAddress           = 0
    )
    {
        return StackWalk(
            MachineType,
            hProcess,
            hThread,
            this,
            ContextRecord,
            ReadMemoryRoutine,  
            FunctionTableAccessRoutine,  
            GetModuleBaseRoutine,              
            TranslateAddress
        );
    }

    int Dump(HANDLE hProcess, PSTR pBuffer, int nBufferSize)
    {
        int nLength = 0;

        CImagehlpModule Module;
        SymGetModuleInfo(hProcess, AddrPC.Offset, &Module);

        ULONG_PTR dwDisplacement = 0;
        CImagehlpSymbol<MAX_SYMBOL_LENGTH> Symbol;
        SymGetSymFromAddr(hProcess, AddrPC.Offset, &dwDisplacement, &Symbol);

        CHAR szUnDSymbol[MAX_SYMBOL_LENGTH] = "";
        SymUnDName(&Symbol, szUnDSymbol, sizeof(szUnDSymbol));

        DWORD dwLineDisplacement = 0;
        CImagehlpLine Line;
        SymGetLineFromAddr(hProcess, AddrPC.Offset, &dwLineDisplacement, &Line);

        if (IsDebuggerPresent())
        {
            nLength = _snprintf(
                pBuffer, 
                nBufferSize, 
                "%s(%d) : %s!%s+0x%x (%p, %p, %p, %p)\n",
                Line.FileName, 
                Line.LineNumber,
                Module.ModuleName,
                szUnDSymbol,
                dwDisplacement,
                Params[0],
                Params[1],
                Params[2],
                Params[3]
            );
        }
        else
        {
            nLength = _snprintf(
                pBuffer, 
                nBufferSize, 
                Line.FileName ? "%p %p %p %p %s!%s+0x%x (%s:%d)\n" : "%p %p %p %p %s!%s+0x%x\n",
                Params[0],
                Params[1],
                Params[2],
                Params[3],
                Module.ModuleName,
                szUnDSymbol,
                dwDisplacement,
                GetFileNameA(Line.FileName), 
                Line.LineNumber
            );
        }

        return nLength;
    }
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CGuardAllocator
{
public:
    typedef enum 
    { 
        GUARD_NONE = 0, 
        GUARD_TAIL = 1, 
        GUARD_HEAD = 2,
        GUARD_FLAGS = GUARD_NONE | GUARD_TAIL | GUARD_HEAD,
        SAVE_STACK_FRAMES = 4
    } GUARD_TYPE;

    CGuardAllocator(LONG lFlags = GUARD_NONE)
    {
        Create(lFlags);
    }

    ~CGuardAllocator()
    {
        Destroy();
    }

    void Create(LONG lFlags = GUARD_NONE);
    void Destroy();

    void SetGuardType(LONG lFlags);

    void Walk(FILE *fout);
    
    HANDLE TakeSnapShot();
    void   DeleteSnapShot(HANDLE hSnapShot);
    void   Diff(HANDLE hSnapShot, FILE *fout);

    void  *Alloc(DWORD dwFlags, size_t nSize);
    BOOL   Free(DWORD dwFlags, void *pMem);
    size_t Size(DWORD dwFlags, const void *pMem);
    void  *Realloc(DWORD dwFlags, void *pMem, size_t nSize);
    BOOL   Validate(DWORD dwFlags, const void *pMem);

private:
    void *(CGuardAllocator::*pfnAlloc)(size_t nSize);
    BOOL  (CGuardAllocator::*pfnFree)(void *pMem);

    void *AllocGuardNone(size_t nSize);
    BOOL  FreeGuardNone(void *pMem);

    void *AllocGuardTail(size_t nSize);
    BOOL  FreeGuardTail(void *pMem);

    void *AllocGuardHead(size_t nSize);
    BOOL  FreeGuardHead(void *pMem);

private:
    struct CAllocation
    {
        DWORD        m_dwMagic1;
        BOOL (CGuardAllocator::*pfnFree)(void *pMem);
        CAllocation *m_pPrev;
        CAllocation *m_pNext;
        size_t       m_nSize;
        UINT         m_nStackFrames;
        UINT         m_nID;
        DWORD        m_dwMagic2;

        int Dump(HANDLE hProcess, PSTR pBuffer, int nBufferSize) const;

        bool IsValid() const
        {
            return m_dwMagic1 == '>>>>' && m_dwMagic2 == '<<<<';
        }
    };

private:
    LONG             m_nInitCount;
    LONG             m_lFlags;
    size_t           m_nPageSize;
    HANDLE           m_hProcess;
    HANDLE           m_hProcessHeap;
    DWORD            m_dwOsVersion;
    CAllocation      m_Head;
    UINT             m_nAllocations;
    UINT             m_nNextID;
    CRITICAL_SECTION m_HeapLock;
    PCSTR            m_pLeaksFileName;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

extern CGuardAllocator g_GuardAllocator;

//////////////////////////////////////////////////////////////////////////
//
//
//

#ifdef IMPLEMENT_GUARDALLOC

//////////////////////////////////////////////////////////////////////////
//
//
//

#include <pshpack1.h>

struct CRelativeJmp
{
    CRelativeJmp(PBYTE pFromAddr, PBYTE pToAddr)
    {
        jmp  = 0xE9;
        addr = pToAddr - (pFromAddr + 5);
    }

    BYTE    jmp;
    INT_PTR addr;
};

#include <poppack.h>

BOOL ReplaceProc(FARPROC pOldProc, FARPROC pNewProc)
{
    CRelativeJmp Code((PBYTE) pOldProc, (PBYTE) pNewProc);

    DWORD dwNumberOfBytesWritten;

    return WriteProcessMemory(
        GetCurrentProcess(), 
        pOldProc, 
        &Code, 
        sizeof(Code), 
        &dwNumberOfBytesWritten
    );
}

inline PVOID FindPtr(PVOID pBase, UINT_PTR pOffset, PIMAGE_SECTION_HEADER psh)
{
//***	return (PBYTE) pBase + pOffset - psh->VirtualAddress + psh->PointerToRawData;
	return (PBYTE) pBase + pOffset;
}

PIMAGE_FILE_HEADER FindImageFileHeader(PVOID pBase)
{
    WORD wMagic = *(WORD *) pBase;

    if (wMagic == IMAGE_DOS_SIGNATURE) 
    {
	    PIMAGE_DOS_HEADER pdh = (PIMAGE_DOS_HEADER) pBase;

	    if (pdh->e_lfanew) 
        {
	        DWORD dwMagic = *(DWORD *) ((PBYTE) pBase + pdh->e_lfanew);

            if (dwMagic == IMAGE_NT_SIGNATURE) 
            {
	            return (PIMAGE_FILE_HEADER) ((PBYTE) pBase + pdh->e_lfanew + sizeof(DWORD));
            }
        }
    }

    return 0;
}

PVOID 
FindImageDirectoryEntry(
    PVOID                  pBase, 
    int                    nDirectory, 
    PIMAGE_SECTION_HEADER &psh
)
{
	PIMAGE_FILE_HEADER pfh = FindImageFileHeader(pBase);

    if (pfh && pfh->SizeOfOptionalHeader) 
    {
	    PIMAGE_OPTIONAL_HEADER poh = (PIMAGE_OPTIONAL_HEADER)(pfh + 1); 

	    if (poh->Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) 
        {
	        DWORD VADirectory = poh->DataDirectory[nDirectory].VirtualAddress; 

            if (VADirectory)
            {
	            psh = (PIMAGE_SECTION_HEADER) ((PBYTE) poh + pfh->SizeOfOptionalHeader);

	            for (int nSection = 0; nSection < pfh->NumberOfSections; ++nSection) 
                {    
		            if ( 
			            psh->VirtualAddress                      <= VADirectory && 
			            psh->VirtualAddress + psh->SizeOfRawData >  VADirectory
		            ) 
                    {    
                        return FindPtr(pBase, VADirectory, psh);
		            }

		            ++psh;
	            } 
            }
        }
    }

    return 0;
}

FARPROC *FindImport(PBYTE pBase, PCSTR pDllName, PCSTR pProcName)
{
    PIMAGE_SECTION_HEADER psh; 

    PIMAGE_IMPORT_DESCRIPTOR pImportDir = 
        (PIMAGE_IMPORT_DESCRIPTOR) FindImageDirectoryEntry(pBase, IMAGE_DIRECTORY_ENTRY_IMPORT, psh);

    if (pImportDir)
    {
        while (pImportDir->Name) 
        {
            PCSTR pName = (PCSTR) FindPtr(pBase, pImportDir->Name, psh);

            if (stricmp(pName, pDllName) == 0)
            {
                PINT_PTR pHintNameArray = (PINT_PTR) FindPtr(pBase, pImportDir->Characteristics, psh);

                PINT_PTR ppImportByName = pHintNameArray;

                while (*ppImportByName)
                {
                    if (*ppImportByName > 0)
                    {
                        PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME) FindPtr(pBase, *ppImportByName, psh);

                        if (strcmp((PCSTR) pImportByName->Name, pProcName) == 0)
                        {
                            FARPROC *pImportAddressTable = (FARPROC *) FindPtr(pBase, pImportDir->FirstThunk, psh);

                            return pImportAddressTable + (ppImportByName - pHintNameArray);
                        }
                    }

                    ++ppImportByName;
                }
            }

            ++pImportDir;
        }
    }

    return 0;
}

BOOL ReplaceImport(HMODULE hModule, PCSTR pDllName, PCSTR pProcName, FARPROC pNewProc, FARPROC pExpected)
{
    FARPROC *pImport = FindImport((PBYTE) hModule, pDllName, pProcName);

    if (pImport == 0)
    {
        return FALSE;
    }

    if (*pImport != pExpected)
    {
        //DebugBreak();
    }

    DWORD dwNumberOfBytesWritten;

    return WriteProcessMemory(
        GetCurrentProcess(), 
        pImport, 
        &pNewProc, 
        sizeof(pNewProc), 
        &dwNumberOfBytesWritten
    );
}

class CModules
{
public:
    CModules()
    {
        m_nModules = 0;
        InitializeCriticalSection(&m_LoadLibraryLock);
    }

    ~CModules()
    {
        DeleteCriticalSection(&m_LoadLibraryLock);
    }

    BOOL Add(PCSTR pName, HMODULE hModule)
    {
        EnterCriticalSection(&m_LoadLibraryLock);

        int nModule = Find(hModule);
        
        if (nModule == -1)
        {
            PCSTR pModuleName = GetFileNameA(pName);

            strcpy(m_Modules[m_nModules].szName, pModuleName);

            if (strchr(pModuleName, '.') == 0)
            {
                strcat(m_Modules[m_nModules].szName, ".dll");
            }

            m_Modules[m_nModules].hModule = hModule;

            m_Modules[m_nModules].nRefs = 1;

            ++m_nModules;
        }
        else
        {
            ++m_Modules[nModule].nRefs;
        }

        LeaveCriticalSection(&m_LoadLibraryLock);

        return nModule == -1;
    }

    void Free(HMODULE hModule)
    {
        EnterCriticalSection(&m_LoadLibraryLock);

        int nModule = Find(hModule);

        if (nModule == -1)
        {
            OutputDebugStringA("*** Trying to free unloaded dll\n"); 
            DebugBreak();
        }
        else
        {
            if (--m_Modules[nModule].nRefs == 0)
            {
                --m_nModules;

                for (int i = nModule; i < m_nModules; ++i)
                {
                    m_Modules[i] = m_Modules[i + 1];
                }
            }
        }

        LeaveCriticalSection(&m_LoadLibraryLock);
    }

private:
    int Find(PCSTR pName)
    {
        for (int i = 0; i < m_nModules; ++i)
        {
            if (stricmp(m_Modules[i].szName, pName) == 0)
            {
                return i;
            }
        }

        return -1;
    }

    int Find(HMODULE hModule)
    {
        for (int i = 0; i < m_nModules; ++i)
        {
            if (m_Modules[i].hModule == hModule)
            {
                return i;
            }
        }

        return -1;
    }

private:
    struct CModule
    {
        CHAR    szName[32];
        HMODULE hModule;
        int     nRefs;
    };

private:
    int              m_nModules;
    CModule          m_Modules[1000]; //bugbug
    CRITICAL_SECTION m_LoadLibraryLock;
};

typedef BOOL (*PFNENUMIMAGEMODULESPROC)(PCSTR pName, HMODULE pBase);

VOID EnumImageModules(PCSTR pName, HMODULE pBase, PFNENUMIMAGEMODULESPROC pfnCallback)
{
    if (pfnCallback(pName, pBase))
    {
        PIMAGE_SECTION_HEADER psh; 

        PIMAGE_IMPORT_DESCRIPTOR pImportDir = 
            (PIMAGE_IMPORT_DESCRIPTOR) FindImageDirectoryEntry((PBYTE) pBase, IMAGE_DIRECTORY_ENTRY_IMPORT, psh);

        if (pImportDir)
        {
            while (pImportDir->Name) 
            {
                PSTR pModuleName = (PSTR) FindPtr((PBYTE) pBase, pImportDir->Name, psh);

                HMODULE hModuleBase = GetModuleHandleA(pModuleName);

                EnumImageModules(pModuleName, hModuleBase, pfnCallback);

                ++pImportDir;
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

PVOID (WINAPI *g_pfnHeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T nSize);

PVOID WINAPI SysHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T nSize)
{
    return g_pfnHeapAlloc(hHeap, dwFlags, nSize);
}

BOOL (WINAPI *g_pfnHeapFree)(HANDLE hHeap, DWORD dwFlags, PVOID pMem);

BOOL WINAPI SysHeapFree(HANDLE hHeap, DWORD dwFlags, PVOID pMem)
{
    return g_pfnHeapFree(hHeap, dwFlags, pMem);
}

SIZE_T (WINAPI *g_pfnHeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID pMem);

SIZE_T WINAPI SysHeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID pMem)
{
    return g_pfnHeapSize(hHeap, dwFlags, pMem);
}

PVOID (WINAPI *g_pfnHeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID pMem, SIZE_T nSize);

PVOID WINAPI SysHeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID pMem, SIZE_T nSize)
{
    return g_pfnHeapReAlloc(hHeap, dwFlags, pMem, nSize);
}

BOOL (WINAPI *g_pfnHeapValidate)(HANDLE hHeap, DWORD dwFlags, LPCVOID pMem);

BOOL WINAPI SysHeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID pMem)
{
    return g_pfnHeapValidate(hHeap, dwFlags, pMem);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

__declspec(thread) static g_bDisable = FALSE;

LPVOID WINAPI MyHeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T nSize)
{
    return g_GuardAllocator.Alloc(dwFlags, nSize);
}

BOOL WINAPI MyHeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID pMem)
{
    return g_GuardAllocator.Free(dwFlags, pMem);
}

SIZE_T WINAPI MyHeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID pMem)
{
    return g_GuardAllocator.Size(dwFlags, pMem);
}

LPVOID WINAPI MyHeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID pMem, SIZE_T nSize)
{
    return g_GuardAllocator.Realloc(dwFlags, pMem, nSize);
}

BOOL WINAPI MyHeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID pMem)
{
    return g_GuardAllocator.Validate(dwFlags, pMem);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CModules *g_pModules = 0;

BOOL EnumImageModulesProc(PCSTR pName, HMODULE pBase);

HMODULE (WINAPI *g_pfnLoadLibraryA)(LPCSTR lpLibFileName);

HMODULE WINAPI MyLoadLibraryA(LPCSTR lpLibFileNameA)
{
    HMODULE hModule = g_pfnLoadLibraryA(lpLibFileNameA);

    EnumImageModules(lpLibFileNameA, hModule, EnumImageModulesProc);

    return hModule;
}

HMODULE (WINAPI *g_pfnLoadLibraryW)(LPCWSTR lpLibFileName);

HMODULE WINAPI MyLoadLibraryW(LPCWSTR lpLibFileNameW)
{
    HMODULE hModule = g_pfnLoadLibraryW(lpLibFileNameW);

    int nSize = WideCharToMultiByte(CP_ACP, 0, lpLibFileNameW, -1, 0, 0, 0, 0);

    PSTR lpLibFileNameA = (PSTR) _alloca(nSize);

    WideCharToMultiByte(CP_ACP, 0, lpLibFileNameW, -1, lpLibFileNameA, nSize, 0, 0);

    EnumImageModules(lpLibFileNameA, hModule, EnumImageModulesProc);

    return hModule;
}

HMODULE (WINAPI *g_pfnLoadLibraryExA)(LPCSTR lpLibFileNameA, HANDLE hFile, DWORD dwFlags);

HMODULE WINAPI MyLoadLibraryExA(LPCSTR lpLibFileNameA, HANDLE hFile, DWORD dwFlags)
{
    HMODULE hModule = g_pfnLoadLibraryExA(lpLibFileNameA, hFile, dwFlags);

    EnumImageModules(lpLibFileNameA, hModule, EnumImageModulesProc);

    return hModule;
}

HMODULE (WINAPI *g_pfnLoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);

HMODULE WINAPI MyLoadLibraryExW(LPCWSTR lpLibFileNameW, HANDLE hFile, DWORD dwFlags)
{
    HMODULE hModule = g_pfnLoadLibraryExW(lpLibFileNameW, hFile, dwFlags);

    int nSize = WideCharToMultiByte(CP_ACP, 0, lpLibFileNameW, -1, 0, 0, 0, 0);

    PSTR lpLibFileNameA = (PSTR) _alloca(nSize);

    WideCharToMultiByte(CP_ACP, 0, lpLibFileNameW, -1, lpLibFileNameA, nSize, 0, 0);

    EnumImageModules(lpLibFileNameA, hModule, EnumImageModulesProc);

    return hModule;
}

BOOL (WINAPI *g_pfnFreeLibrary)(HMODULE hLibModule);

BOOL WINAPI MyFreeLibrary(HMODULE hLibModule)
{
    g_pModules->Free(hLibModule);
    return g_pfnFreeLibrary(hLibModule);
}

BOOL EnumImageModulesProc(PCSTR pName, HMODULE pBase)
{
    if (!pBase || !g_pModules->Add(pName, pBase))
    {
        return FALSE;
    }

    //if (stricmp(pName, "user32.dll") == 0 || stricmp(pName, "user32") == 0)//***
    //{
    //    return TRUE;
    //}

    OutputDebugStringA("Patching "); //***
    OutputDebugStringA(pName); //***
    OutputDebugStringA("\n"); //***

    ReplaceImport(pBase, "kernel32.dll", "LoadLibraryA",   (FARPROC) MyLoadLibraryA,   (FARPROC) g_pfnLoadLibraryA);
    ReplaceImport(pBase, "kernel32.dll", "LoadLibraryW",   (FARPROC) MyLoadLibraryW,   (FARPROC) g_pfnLoadLibraryW);
    ReplaceImport(pBase, "kernel32.dll", "LoadLibraryExA", (FARPROC) MyLoadLibraryExA, (FARPROC) g_pfnLoadLibraryExA);
    ReplaceImport(pBase, "kernel32.dll", "LoadLibraryExW", (FARPROC) MyLoadLibraryExW, (FARPROC) g_pfnLoadLibraryExW);
    ReplaceImport(pBase, "kernel32.dll", "FreeLibrary",    (FARPROC) MyFreeLibrary,    (FARPROC) g_pfnFreeLibrary);

    ReplaceImport(pBase, "kernel32.dll", "HeapAlloc",    (FARPROC) MyHeapAlloc,    (FARPROC) g_pfnHeapAlloc);
    ReplaceImport(pBase, "kernel32.dll", "HeapReAlloc",  (FARPROC) MyHeapReAlloc,  (FARPROC) g_pfnHeapReAlloc);
    ReplaceImport(pBase, "kernel32.dll", "HeapFree",     (FARPROC) MyHeapFree,     (FARPROC) g_pfnHeapFree);
    ReplaceImport(pBase, "kernel32.dll", "HeapSize",     (FARPROC) MyHeapSize,     (FARPROC) g_pfnHeapSize);
    ReplaceImport(pBase, "kernel32.dll", "HeapValidate", (FARPROC) MyHeapValidate, (FARPROC) g_pfnHeapValidate);

    return TRUE;
}

void CGuardAllocator::Create(LONG lFlags)
{
    SetGuardType(lFlags);

    if (m_nInitCount++ == 0)
    {
        OutputDebugStringA("Initializing debug heap\n");

        SYSTEM_INFO si;

        GetSystemInfo(&si);

        m_nPageSize = si.dwPageSize;

        m_Head.m_pNext = &m_Head;
        m_Head.m_pPrev = &m_Head;

        m_nAllocations = 0;
        m_nNextID      = 0;

        InitializeCriticalSection(&m_HeapLock);

        m_hProcess     = GetCurrentProcess();
        m_hProcessHeap = GetProcessHeap();
        m_dwOsVersion  = GetVersion();

        HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

        *(FARPROC*)& g_pfnLoadLibraryA   = GetProcAddress(hKernel32, "LoadLibraryA");
        *(FARPROC*)& g_pfnLoadLibraryW   = GetProcAddress(hKernel32, "LoadLibraryW");
        *(FARPROC*)& g_pfnLoadLibraryExA = GetProcAddress(hKernel32, "LoadLibraryExA");
        *(FARPROC*)& g_pfnLoadLibraryExW = GetProcAddress(hKernel32, "LoadLibraryExW");
        *(FARPROC*)& g_pfnFreeLibrary    = GetProcAddress(hKernel32, "FreeLibrary");

        *(FARPROC*)& g_pfnHeapAlloc    = GetProcAddress(hKernel32, "HeapAlloc");
        *(FARPROC*)& g_pfnHeapReAlloc  = GetProcAddress(hKernel32, "HeapReAlloc");
        *(FARPROC*)& g_pfnHeapFree     = GetProcAddress(hKernel32, "HeapFree");
        *(FARPROC*)& g_pfnHeapSize     = GetProcAddress(hKernel32, "HeapSize");
        *(FARPROC*)& g_pfnHeapValidate = GetProcAddress(hKernel32, "HeapValidate");

        g_pModules = new CModules;

        if (m_dwOsVersion & 0x80000000 == 0)
        {
            CHAR szModuleName[MAX_PATH];

            GetModuleFileNameA(0, szModuleName, MAX_PATH);

            EnumImageModules(
                szModuleName, 
                GetModuleHandle(0), 
                EnumImageModulesProc
            );

            /*ReplaceProc((FARPROC) g_pfnHeapAlloc,   (FARPROC) MyHeapAlloc);
            ReplaceProc((FARPROC) g_pfnHeapReAlloc, (FARPROC) MyHeapReAlloc);
            ReplaceProc((FARPROC) g_pfnHeapSize,    (FARPROC) MyHeapSize);
            ReplaceProc((FARPROC) g_pfnHeapFree,    (FARPROC) MyHeapFree);
            ReplaceProc((FARPROC) g_pfnHeapFree,    (FARPROC) MyHeapValidate);*/
        }

        m_pLeaksFileName = 0;
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CGuardAllocator::Destroy()
{
    if (m_pLeaksFileName)
    {
        FILE *fout = fopen(m_pLeaksFileName, "wt");

        Walk(fout);

        fclose(fout);
    }

    if (--m_nInitCount == 0)
    {
        DeleteCriticalSection(&m_HeapLock);

        delete g_pModules;
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CGuardAllocator::SetGuardType(LONG lFlags)
{
    //bugbug: this is not MT safe

    m_lFlags = lFlags;

    switch (m_lFlags & GUARD_FLAGS) 
    {
    case GUARD_NONE:
        pfnAlloc = AllocGuardNone;
        pfnFree  = FreeGuardNone;
        break;

    case GUARD_TAIL:
        pfnAlloc = AllocGuardTail;
        pfnFree  = FreeGuardTail;
        break;

    case GUARD_HEAD:
        pfnAlloc = AllocGuardHead;
        pfnFree  = FreeGuardHead;
        break;
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CGuardAllocator::Walk(FILE *fout)
{
    g_bDisable = TRUE;

    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);
    SymInitialize(m_hProcess, 0, TRUE);

    const int nBufferSize = 16*1024;
    CHAR Buffer[nBufferSize];

    int    nLeakedAllocs = 0;
    size_t nLeakedBytes = 0;

    EnterCriticalSection(&m_HeapLock);

    for (
        CAllocation *pAllocation = m_Head.m_pNext;
        pAllocation != &m_Head;
        pAllocation = pAllocation->m_pNext
    )
    {
        int nLength = pAllocation->Dump(m_hProcess, Buffer, nBufferSize);

        fwrite(Buffer, 1, nLength, fout);
        //OutputDebugStringA(Buffer);

        nLeakedAllocs += 1;
        nLeakedBytes  += pAllocation->m_nSize;
    }

    if (nLeakedAllocs != 0)
    {
        int nLength = _snprintf(
            Buffer, 
            nBufferSize, 
            "\nLeaked %d bytes in %d allocations (%d total)\n",
            nLeakedBytes,
            nLeakedAllocs,
            m_nAllocations
        );

        fwrite(Buffer, 1, nLength, fout);
        //OutputDebugStringA(Buffer);
    }

    LeaveCriticalSection(&m_HeapLock);

    SymCleanup(m_hProcess);

    g_bDisable = FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

int CGuardAllocator::CAllocation::Dump(HANDLE hProcess, PSTR pBuffer, int nBufferSize) const
{
    int nLength = _snprintf(
        pBuffer, 
        nBufferSize, 
        "\nAllocation @%p, %d bytes\n",
        this,
        m_nSize
    );

    size_t nStackFramesSize = Align(m_nStackFrames * sizeof(CStackFrame), ALIGNMENT);

    CStackFrame *pStackFrame = (CStackFrame *) ((PBYTE) this - nStackFramesSize); 

    for (UINT i = 0; i < m_nStackFrames; ++i, ++pStackFrame)
    {
        nLength += pStackFrame->Dump(
            hProcess, 
            pBuffer + nLength, 
            nBufferSize - nLength
        );
    }

    return nLength;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HANDLE CGuardAllocator::TakeSnapShot()
{
    g_bDisable = TRUE;

    UINT *pSnapShot = (UINT *) Alloc(0, m_nAllocations * sizeof(UINT));

    int nAllocation = 0;

    for (
        CAllocation *pAllocation = m_Head.m_pNext;
        pAllocation != &m_Head;
        pAllocation = pAllocation->m_pNext
    )
    {
        pSnapShot[nAllocation++] = pAllocation->m_nID;
    }

    g_bDisable = FALSE;

    return (HANDLE) pSnapShot;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CGuardAllocator::DeleteSnapShot(HANDLE hSnapShot)
{
    g_bDisable = TRUE;

    Free(0, hSnapShot);

    g_bDisable = FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CGuardAllocator::Diff(HANDLE hSnapShot, FILE *fout)
{
    g_bDisable = TRUE;

    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);
    SymInitialize(m_hProcess, 0, TRUE);

    const int nBufferSize = 16*1024;
    CHAR Buffer[nBufferSize];

    UINT *pSnapShot = (UINT *) hSnapShot;

    int nAllocation = 0;

    for (
        CAllocation *pAllocation = m_Head.m_pNext;
        pAllocation != &m_Head;
        pAllocation = pAllocation->m_pNext
    )
    {
        while (pAllocation->m_nID < pSnapShot[nAllocation])
        {
            ++nAllocation;
        }

        if (pAllocation->m_nID != pSnapShot[nAllocation])
        {
            int nLength = pAllocation->Dump(m_hProcess, Buffer, nBufferSize);

            fwrite(Buffer, 1, nLength, fout);
            //OutputDebugStringA(Buffer);
        }
    }

    SymCleanup(m_hProcess);

    g_bDisable = FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

template <int> struct static_assert { enum { is_non_zero }; };
template <> struct static_assert<0> { enum { is_zero }; };

void *CGuardAllocator::Alloc(DWORD dwFlags, size_t nSize)
{
    if (m_nInitCount == 0)
    {
        OutputDebugStringA("Heap call before initialization\n");
        DebugBreak();
    }

    if (g_bDisable)
    {
        return SysHeapAlloc(m_hProcessHeap, dwFlags, nSize);
    }

    g_bDisable = TRUE;

    const int   nMaxStackDepth = 20;
    CStackFrame StackFrames[nMaxStackDepth + 1];
    int         nStackFrames = 0;

    if (m_lFlags & SAVE_STACK_FRAMES)
    {
        // get the context of the current thread

        CONTEXT Context;

        if (m_dwOsVersion & 0x80000000)
        {
            __try 
            {
                RaiseException(0, 0, 0, 0);
            }
            __except(GetExceptionContext(GetExceptionInformation(), &Context))
            {
            }
        }
        else
        {
            Context.ContextFlags = CONTEXT_CONTROL;

            GetThreadContext(GetCurrentThread(), &Context);
        }

        // bugbug: putting the above block in a function like 
        // GetCurrentThreadContext(&Context); doesn't seem to work

        // capture the stack frames

        CStackFrame StackFrame(&Context);

        while (nStackFrames < nMaxStackDepth && StackFrame.Walk())
        {
            StackFrames[nStackFrames++] = StackFrame;
        }
    }

    //static_assert<sizeof(CAllocation) % ALIGNMENT>::is_zero;
    
    size_t nStackFramesSize = Align(nStackFrames * sizeof(CStackFrame), ALIGNMENT);

    // allocate memory (large enough for the stack frames + allocation data size + requested size)
    // bugbug: putting CAllocation at front doesn't make sense for GUARD_HEAD

    void *pMem = (this->*pfnAlloc)(nStackFramesSize + sizeof(CAllocation) + nSize);

    g_bDisable = FALSE;

    if (pMem == 0)
    {
        OutputDebugStringA("*** Out of memory in alloc()\n");
        return 0;
    }

    // copy the stack frames first

    CopyMemory(pMem, StackFrames, nStackFramesSize);

    // next, fill in the allocation data

    CAllocation *pAllocation = (CAllocation *) ((PBYTE)pMem + nStackFramesSize);

    pAllocation->m_dwMagic1 = '>>>>';

    pAllocation->m_nSize = nSize;
    pAllocation->m_nStackFrames = nStackFrames;

    pAllocation->pfnFree = pfnFree;

    pAllocation->m_dwMagic2 = '<<<<';

    EnterCriticalSection(&m_HeapLock);

    pAllocation->m_pPrev = &m_Head;
    pAllocation->m_pNext = m_Head.m_pNext;

    pAllocation->m_pPrev->m_pNext = pAllocation;
    pAllocation->m_pNext->m_pPrev = pAllocation;

    pAllocation->m_nID = m_nNextID++;

    ++m_nAllocations;

    LeaveCriticalSection(&m_HeapLock);

    // return the end of allocation data struct as the allocated memory

    return pAllocation + 1;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

BOOL CGuardAllocator::Free(DWORD dwFlags, void *pMem)
{
    if (m_nInitCount == 0)
    {
        OutputDebugStringA("Heap call before initialization\n");
        DebugBreak();
    }

    if (g_bDisable)
    {
        return SysHeapFree(m_hProcessHeap, dwFlags, pMem);
    }

    if (pMem == 0)
    {
        return TRUE;
    }

    // get to the allocation data, it comes just before the pointer

    CAllocation *pAllocation = (CAllocation *) pMem - 1;

    if (!pAllocation->IsValid())
    {
        OutputDebugStringA("*** Invalid pointer passed to free()\n");
        //***DebugBreak();
        return FALSE;
    }

    // unlink this block

    EnterCriticalSection(&m_HeapLock);

    pAllocation->m_pPrev->m_pNext = pAllocation->m_pNext;
    pAllocation->m_pNext->m_pPrev = pAllocation->m_pPrev;

    --m_nAllocations;

    LeaveCriticalSection(&m_HeapLock);

    // get to head of the real allocated block and call the appropriate deallocator

    size_t nStackFramesSize = Align(pAllocation->m_nStackFrames * sizeof(CStackFrame), ALIGNMENT);

    return (this->*pAllocation->pfnFree)((PBYTE)pAllocation - nStackFramesSize);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

size_t CGuardAllocator::Size(DWORD dwFlags, const void *pMem)
{
    if (m_nInitCount == 0)
    {
        OutputDebugStringA("Heap call before initialization\n");
        DebugBreak();
    }

    if (g_bDisable)
    {
        return SysHeapSize(m_hProcessHeap, dwFlags, pMem);        
    }

    CAllocation *pAllocation = (CAllocation *) pMem - 1;

    return pAllocation->m_nSize;
}
     
//////////////////////////////////////////////////////////////////////////
//
//
//

void *CGuardAllocator::Realloc(DWORD dwFlags, void *pMem, size_t nSize)
{
    if (m_nInitCount == 0)
    {
        OutputDebugStringA("Heap call before initialization\n");
        DebugBreak();
    }

    if (g_bDisable)
    {
        return SysHeapReAlloc(m_hProcessHeap, dwFlags, pMem, nSize);        
    }

    CAllocation *pAllocation = (CAllocation *) pMem - 1;

    if (!pAllocation->IsValid())
    {
        OutputDebugStringA("*** Invalid pointer passed to realloc()\n");
        DebugBreak();
        return 0;
    }

    void *pNewMem = Alloc(0, nSize);

    CopyMemory(pNewMem, pMem, Size(0, pMem));

    Free(0, pMem);

    return pNewMem;
}
     
//////////////////////////////////////////////////////////////////////////
//
//
//

BOOL CGuardAllocator::Validate(DWORD dwFlags, const void *pMem)
{
    if (m_nInitCount == 0)
    {
        OutputDebugStringA("Heap call before initialization\n");
        DebugBreak();
    }

    if (g_bDisable)
    {
        return SysHeapValidate(m_hProcessHeap, dwFlags, pMem);        
    }

    BOOL bValid = TRUE;

    EnterCriticalSection(&m_HeapLock);

    __try 
    {
        if (pMem)
        {
            CAllocation *pAllocation = (CAllocation *) pMem - 1;

            if (!pAllocation->IsValid())
            {
                bValid = FALSE;
            }
        }
        else
        {
            for (
                CAllocation *pAllocation = m_Head.m_pNext;
                pAllocation != &m_Head && bValid;
                pAllocation = pAllocation->m_pNext
            )
            {
                if (!pAllocation->IsValid())
                {
                    bValid = FALSE;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bValid = FALSE;
    }

    LeaveCriticalSection(&m_HeapLock);

    return bValid;
}
     
//////////////////////////////////////////////////////////////////////////
//
//
//

void *CGuardAllocator::AllocGuardNone(size_t nSize)
{
    return SysHeapAlloc(m_hProcessHeap, HEAP_ZERO_MEMORY, nSize);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

BOOL CGuardAllocator::FreeGuardNone(void *pMem)
{
    return SysHeapFree(m_hProcessHeap, 0, pMem);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void *CGuardAllocator::AllocGuardTail(size_t nSize)
{
    const size_t nAllocSize = Align(nSize, ALIGNMENT);

    const size_t nTotalSize = Align(nAllocSize + m_nPageSize, m_nPageSize);

    // reserve/allocate the memory 

    void *pBase = VirtualAlloc(
        0,
        nTotalSize,
        MEM_RESERVE,
        PAGE_NOACCESS
    );

    if (!pBase)
    {
        return 0;
    }

    // commit the r/w memory

    void *pAlloc = VirtualAlloc(
        pBase,
        nTotalSize - m_nPageSize,
        MEM_COMMIT,
        PAGE_EXECUTE_READWRITE
    );

    if (!pAlloc)
    {
        VirtualFree(pBase, 0, MEM_RELEASE);
        return 0;
    }

    // commit the guard page

    void *pGuard = VirtualAlloc(
        (PBYTE) pBase + nTotalSize - m_nPageSize,
        m_nPageSize,
        MEM_COMMIT,
        PAGE_NOACCESS
    );

    if (!pGuard)
    {
        VirtualFree(pAlloc, 0, MEM_DECOMMIT);
        VirtualFree(pBase, 0, MEM_RELEASE);
        return 0;
    }

    return (PBYTE) pBase + nTotalSize - m_nPageSize - nAllocSize;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

BOOL CGuardAllocator::FreeGuardTail(void *pMem)
{
    PVOID pBase = (PVOID) ((UINT_PTR) pMem & ~(m_nPageSize-1));

    return VirtualFree(pBase, 0, MEM_RELEASE);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void *CGuardAllocator::AllocGuardHead(size_t nSize)
{
    const size_t nAllocSize = Align(nSize, ALIGNMENT);

    const size_t nTotalSize = Align(nAllocSize + m_nPageSize, m_nPageSize);

    // reserve/allocate the memory 

    void *pBase = VirtualAlloc(
        0,
        nTotalSize,
        MEM_RESERVE,
        PAGE_NOACCESS
    );

    if (!pBase)
    {
        return 0;
    }

    // commit the r/w memory

    void *pAlloc = VirtualAlloc(
        (PBYTE) pBase + m_nPageSize,
        nTotalSize - m_nPageSize,
        MEM_COMMIT,
        PAGE_EXECUTE_READWRITE
    );

    if (!pAlloc)
    {
        VirtualFree(pBase, 0, MEM_RELEASE);
        return 0;
    }

    // commit the guard page

    void *pGuard = VirtualAlloc(
        pBase,
        m_nPageSize,
        MEM_COMMIT,
        PAGE_NOACCESS
    );

    if (!pGuard)
    {
        VirtualFree(pAlloc, 0, MEM_DECOMMIT);
        VirtualFree(pBase, 0, MEM_RELEASE);
        return 0;
    }

    return (PBYTE) pBase + m_nPageSize;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

BOOL CGuardAllocator::FreeGuardHead(void *pMem)
{
    PVOID pBase = (PVOID) ((UINT_PTR) pMem - m_nPageSize);

    return VirtualFree(pBase, 0, MEM_RELEASE);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

#ifdef _DLL

#pragma message("Need to link with static CRT libs to be able to replace malloc/free")

#else //_DLL

//////////////////////////////////////////////////////////////////////////
//
//
//

void * __cdecl ::operator new(size_t nSize)
{
    return g_GuardAllocator.Alloc(0, nSize);
}

#ifdef _DEBUG

void* __cdecl operator new(size_t nSize, int, LPCSTR, int)
{
    return g_GuardAllocator.Alloc(0, nSize);
}

#endif //_DEBUG

void __cdecl ::operator delete(void *pMem)
{
    g_GuardAllocator.Free(0, pMem);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

extern "C" 
{

#undef _malloc_dbg
#undef _free_dbg
#undef _msize_dbg
#undef _realloc_dbg
#undef _expand_dbg

void * __cdecl malloc(size_t nSize)
{
    return g_GuardAllocator.Alloc(0, nSize);
}

void * __cdecl _malloc_dbg(size_t nSize, int, const char *, int)
{
    return g_GuardAllocator.Alloc(0, nSize);
}

void __cdecl free(void *pMem)
{
    g_GuardAllocator.Free(0, pMem);
}

void __cdecl _free_dbg(void *pMem, int)
{
    g_GuardAllocator.Free(0, pMem);
}

size_t __cdecl _msize(void *pMem)
{
    return g_GuardAllocator.Size(0, pMem);
}

size_t __cdecl _msize_dbg(void *pMem, int)
{
    return g_GuardAllocator.Size(0, pMem);
}

void * __cdecl realloc(void *pMem, size_t nSize)
{
    return g_GuardAllocator.Realloc(0, pMem, nSize);
}

void * __cdecl _realloc_dbg(void *pMem, size_t nSize, int, const char *, int)
{
    return g_GuardAllocator.Realloc(0, pMem, nSize);
}

void *  __cdecl _expand(void *, size_t)
{
    return 0;
}

void * __cdecl _expand_dbg(void *, size_t, int, const char *, int)
{
    return 0;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

void __cdecl wWinMainCRTStartup();
void __cdecl WinMainCRTStartup();
void __cdecl wmainCRTStartup();
void __cdecl mainCRTStartup();

void __cdecl ModuleEntry()
{
    g_GuardAllocator.Create();

#ifdef _CONSOLE

    #ifdef UNICODE
        wmainCRTStartup();
    #else //UNICODE
        mainCRTStartup();
    #endif

#else //_CONSOLE

    #ifdef UNICODE
        wWinMainCRTStartup();
    #else //UNICODE
        WinMainCRTStartup();
    #endif

#endif //_CONSOLE

    g_GuardAllocator.Destroy();
}

}

//////////////////////////////////////////////////////////////////////////
//
//
//

#pragma comment(linker, "/force:multiple")
#pragma comment(linker, "/entry:ModuleEntry")

#endif //_DLL

#pragma comment(lib, "dbghelp")

#endif IMPLEMENT_GUARDALLOC

#endif //_GUARDALLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\instdev.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    InstDev.cpp

Abstract:

    Routines for installing a device by programatically playing with 
    the add driver wizard

Author:

    Hakki T. Bostanci (hakkib) 17-Dec-1999

Revision History:

--*/

#include "stdafx.h"

#include "Wrappers.h"

#include "WindowSearch.h"
#include "StolenIds.h"

//////////////////////////////////////////////////////////////////////////
//
// structs for manipulating resources in NE (Win 3.1 style exe) files
//

#include <pshpack1.h>   // Assume byte packing throughout

typedef struct 
{
    WORD  Type;
    WORD  NumEntries;
    DWORD Reserved;
} RES_TYPE_INFO, *PRES_TYPE_INFO;

typedef struct 
{
    WORD  Offset;
    WORD  Length;
    WORD  Flags;
    WORD  Id;
    WORD  Handle;
    WORD  Usage;
} RES_NAME_INFO, *PRES_NAME_INFO;

typedef struct 
{
    WORD           Align;
    RES_TYPE_INFO  TypeInfo[ANYSIZE_ARRAY];
} RES_TABLE, *PRES_TABLE;

#include <poppack.h>

//////////////////////////////////////////////////////////////////////////
//
// IsEqualId
//
// Routine Description:
//   compares two resource id's
//
// Arguments:
//
// Return Value:
//

BOOL
IsEqualId(
    PCTSTR     pResName,
    WORD       wResId,
    PRES_TABLE pResTable
)
{
    if (HIWORD(pResName) == 0)
    {
        // pResName is numerical

        return wResId == ((WORD) pResName | 0x8000);
    }
    
    if (pResName[0] == _T('#'))
    {
        // pResName is a string numerical

        return wResId == (_ttoi(pResName + 1) | 0x8000);
    }

    if (wResId & 0x8000)
    {
        // pResName is a string but wResId is numerical

        return FALSE;
    }

    // compare the pascal-style string in the resource table
    // with the C-style string we have

    PSTR pStr    = (PSTR) ((PBYTE) pResTable + wResId);
    int  nStrLen = *pStr++;

    if (pResName[nStrLen] != 0)
    {
        // string lengths do not match

        return FALSE;
    }

    int i = 0;

    while (i < nStrLen && tolower(pStr[i]) == tolower(pResName[i]))
    {
        ++i;
    }

    return i == nStrLen;
}


//////////////////////////////////////////////////////////////////////////
//
// FindResource16
//
// Routine Description:
//   finds a resource in a 16-bit NE format file
//
// Arguments:
//
// Return Value:
//

PVOID
FindResource16(
    PVOID  pImageBase,
    PCTSTR pName,
    PCTSTR pType
)
{
    // locate the dos header

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) pImageBase;

    if (pDosHeader == 0 || pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)
    {
        SetLastError(ERROR_BAD_FORMAT);
        return 0;
    }

    // locate the NE header

    PIMAGE_OS2_HEADER pOs2Header = 
        (PIMAGE_OS2_HEADER) ((PBYTE)pDosHeader + pDosHeader->e_lfanew);

    if (pOs2Header->ne_magic != IMAGE_OS2_SIGNATURE)
    {
        SetLastError(ERROR_BAD_FORMAT);
        return 0;
    }

    // locate the resources table

    PRES_TABLE pResTable = 
        (PRES_TABLE) ((PBYTE)pOs2Header + pOs2Header->ne_rsrctab);

    // go through the resources until we reach to the string table

    PRES_TYPE_INFO pTypeInfo = pResTable->TypeInfo;

    while (
        pTypeInfo->Type != 0 && 
        !IsEqualId(pType, pTypeInfo->Type, pResTable)
    )
    {
        pTypeInfo = (PRES_TYPE_INFO) 
            ((PRES_NAME_INFO) (pTypeInfo + 1) + pTypeInfo->NumEntries);
    }

    if (pTypeInfo->Type == 0)
    {
        SetLastError(ERROR_NOT_FOUND);
        return 0;
    }

    // go through the resource table searching for our resource id

    PRES_NAME_INFO pNameInfo = (PRES_NAME_INFO) (pTypeInfo + 1);

    WORD nResource = 0;
    
    while (
        nResource < pTypeInfo->NumEntries && 
        !IsEqualId(pName, pNameInfo->Id, pResTable)
    )
    {
        ++nResource;
        ++pNameInfo;
    }

    if (nResource == pTypeInfo->NumEntries)
    {
        SetLastError(ERROR_NOT_FOUND);
        return 0;
    }

    // return the offset of the resource

    return (PBYTE) pDosHeader + (pNameInfo->Offset << pResTable->Align);
}

//////////////////////////////////////////////////////////////////////////
//
// LoadString16
//
// Routine Description:
//   loads a string resource from a 16-bit NE format file
//
// Arguments:
//
// Return Value:
//

int
LoadString16(
    PVOID pImageBase,
    UINT  uID,
    PTSTR pBuffer,
    int   nBufferMax
)
{
    ASSERT(pBuffer != 0);

    // get the resource id and the index of the string

    WORD nBlockId  = uID / 16 + 1;
    int  nStrIndex = uID % 16;

    PSTR pszStr = (PSTR) FindResource16(
        pImageBase, 
        MAKEINTRESOURCE(nBlockId), 
        RT_STRING
    );

    if (pszStr == 0)
    {
        return 0;
    }

    // go through the string resource until we find our string index

    for (int nStr = 0; nStr < 16; ++nStr)
    {
        int nStrLen = *pszStr++;

        if (nStr == nStrIndex)
        {
            int nCopied = min(nBufferMax - 1, nStrLen);

#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, pszStr, nCopied, pBuffer, nBufferMax);
#else //UNICODE
            strncpy(pBuffer, pszStr, nCopied);
#endif //UNICODE

            pBuffer[nCopied] = _T('\0');

            return nCopied;
        }

        pszStr += nStrLen;
    }

    // we cannot reach here but still...

    SetLastError(ERROR_NOT_FOUND);
    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

BOOL CALLBACK EnumProcCancel(HWND hWnd, LPARAM /*lParam*/)
{
    SendMessage(hWnd, WM_COMMAND, IDCANCEL, 0);
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// InstallImageDeviceFromInf
//
// Routine Description:
//   installs an imaging device from an inf file
//
// Arguments:
//
// Return Value:
//


BOOL 
InstallImageDeviceFromInf(
    PCTSTR pInfFileName,
    PCTSTR pDeviceName /*= 0*/
)
{
    static TCHAR szWizardTitle[256];
    static TCHAR szOemDiskTitle[256];
    static LONG  bInitStrings = TRUE;
    
    // read localizable strings

    if (bInitStrings)
    {
        CSystemDirectory SystemDirectory;

        SystemDirectory.SetFileName(_T("sti_ci.dll"));
        CMapFile<VOID, FILE_MAP_READ> sti_ci_dll(SystemDirectory);

        LoadString16(
            sti_ci_dll,
            MessageTitle,
            szWizardTitle, 
            COUNTOF(szWizardTitle)
        );

        SystemDirectory.SetFileName(_T("setupx.dll"));
        CMapFile<VOID, FILE_MAP_READ> setupx_dll(SystemDirectory);

        LoadString16(
            setupx_dll,
            IDS_OEMTITLE,
            szOemDiskTitle, 
            COUNTOF(szOemDiskTitle)
        );

        InterlockedExchange(&bInitStrings, FALSE);
    }

#if 0
    // for the general case, read class name from the inf
    // (but the UI steps in this procedure are specific to image class
    // installs anyway, so don't bother...)

    GUID  ClassGuid;
    TCHAR ClassName[MAX_CLASS_NAME_LEN];

    CHECK(SetupDiGetINFClass(
        pInfFileName,
        &ClassGuid,
        ClassName,
        MAX_CLASS_NAME_LEN,
        0
    ));

    TCHAR szRunDevManager[256];

    _stprintf(
        szRunDevManager, 
        _T("rundll sysdm.cpl,InstallDevice_RunDLL %s,,"),
        ClassName
    );

#endif

    // enter a system wide "playing with device manager" critical section
    // (for the unlikely case that two or more WIAStress'es are running)

    Mutex DevManagerMutex(FALSE, _T("5AFD932E-AC4B-11d3-97B6-00C04F797DBB"));

    DevManagerMutex.WaitForSingleObject();

    // give the installation 2 minutes to be complete. If it is not complete
    // within this period, then probably there is some error dialog (that 
    // we are not expecting) waiting for us. bugbug: this is a terrible
    // way for error handling...

    CWaitableTimer TimeOut(TRUE);

    TimeOut.Set(-1i64 * 2 * 60 * 1000 * 1000 * 10);

    // launch the add driver wizard 

    CProcess DevManager(_T("rundll sysdm.cpl,InstallDevice_RunDLL Image,,"));

    DWORD dwThreadId = ((PROCESS_INFORMATION &)DevManager).dwThreadId;

    // find the wizard window

    HWND hWizardWnd = WaitForThreadWindow(
        dwThreadId, 
        CWindowSearchByText(szWizardTitle), 
        TimeOut
    );

    // find the "next" button

    HWND hNext = WaitForChildWindow(
        hWizardWnd, 
        CWindowSearchById(IDD_NEXT), 
        TimeOut
    );

    PushButton(hNext);

    // find the "have disk" button

    HWND hHaveDisk = WaitForChildWindow(
        hWizardWnd, 
        CWindowSearchById(IDC_NDW_PICKDEV_HAVEDISK), 
        TimeOut
    );

    PushButton(hHaveDisk);

    // wait for the oem disk selection dialog

    HWND hOemDiskWnd = WaitForThreadWindow(
        dwThreadId, 
        CWindowSearchByText(szOemDiskTitle), 
        TimeOut
    );

    // enter the directory name for the inf

    HWND hDirName = WaitForChildWindow(
        hOemDiskWnd, 
        CWindowSearchByClass(_T("Edit")), 
        TimeOut
    );

    CFullPathName InfPathName(pInfFileName);
    InfPathName.StripFileName();

    SetText(hDirName, InfPathName);

    // press ok's and next's and finish'es until the device is installed

    HWND hOk = WaitForChildWindow(
        hOemDiskWnd, 
        CWindowSearchById(IDOK), 
        TimeOut
    );

    PushButton(hOk);

    PushButton(hNext);

    PushButton(hNext);

    // if we have a name, rename the device 

    if (pDeviceName)
    {
        HWND hDeviceName = WaitForChildWindow(
            hWizardWnd, 
            CWindowSearchById(DeviceFriendlyName), 
            TimeOut
        );

        SetText(hDeviceName, pDeviceName);
    }

    PushButton(hNext);

    HWND hFinish = WaitForChildWindow(
        hWizardWnd, 
        CWindowSearchById(IDD_FINISH), 
        TimeOut
    );

    PushButton(hFinish);

    while (DevManager.WaitForSingleObject(250) == WAIT_TIMEOUT)
    {
        // if time is up, destroy all windows

        if (TimeOut.IsSignaled())
        {
            EnumThreadWindows(dwThreadId, EnumProcCancel, 0);
        }
    }

    DevManagerMutex.Release();

    if (TimeOut.IsSignaled())
    {
        SetLastError(ERROR_INSTALL_FAILURE);
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// InstallDeviceFromInf
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//

BOOL 
InstallDeviceFromInf(
    PCTSTR pInfFileName,
    PCTSTR pDeviceName,
    PCTSTR pSourceRootPath = 0
)
{
    BOOL bResult = FALSE;

    GUID  ClassGuid;
    TCHAR ClassName[MAX_CLASS_NAME_LEN];

    bResult = SetupDiGetINFClass(
        pInfFileName,
        &ClassGuid,
        ClassName,
        MAX_CLASS_NAME_LEN,
        0
    ); 

    HDEVINFO hDevInfo = SetupDiCreateDeviceInfoList(&ClassGuid, 0);

    SP_DEVINFO_DATA DeviceInfoData;
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    bResult = SetupDiCreateDeviceInfo(
        hDevInfo, 
        pDeviceName, 
        &ClassGuid, 
        0, 
        0, 
        DICD_GENERATE_ID, 
        &DeviceInfoData
    );

    bResult = SetupDiCallClassInstaller(
        DIF_INSTALLDEVICE, 
        hDevInfo, 
        &DeviceInfoData
    );

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\myheap.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    MyHeap.h

Abstract:

    Implementation of a (dumb and) fast heap allocator

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef MYHEAP_H
#define MYHEAP_H

//////////////////////////////////////////////////////////////////////////
//
//
//

#ifdef _WIN32
#undef  ALIGNMENT
#define ALIGNMENT 8
#endif //WIN32

#ifdef _WIN64
#undef  ALIGNMENT
#define ALIGNMENT 16
#endif //WIN64

//////////////////////////////////////////////////////////////////////////
//
//
//

typedef enum { nAllocBlockSize = 64*1024 };    

//////////////////////////////////////////////////////////////////////////
//
//
//

template <size_t nBucketSize = nAllocBlockSize>
class CMyHeap
{
public:
    CMyHeap()
    {
        InitializeCriticalSection(&m_cs);

        m_pBucket   = 0;
        m_pNextFree = 0;
    }

    ~CMyHeap()
    {
        DumpAllocations();
        FreeAllBuckets();

        DeleteCriticalSection(&m_cs);
    }

    void *allocate(size_t nSize, ULONG uFlags = 0)
    {
        int nAllocSize = AllocSize(nSize);

        if (nAllocSize < 0)
        {
            if (uFlags & HEAP_GENERATE_EXCEPTIONS)
            {
                RaiseException(STATUS_NO_MEMORY, 0, 0, 0);
            }

            return 0;
        }

        if (!(uFlags & HEAP_NO_SERIALIZE))
        {
            EnterCriticalSection(&m_cs);
        }

        // do we have enough buffer space?

        if (m_pBucket == 0 || 
            m_pNextFree + nAllocSize > (PBYTE) m_pBucket + nBucketSize) 
        {
            // if we can manage the requested allocation size, 
            // try to allocate a new bucket

            if (nAllocSize > nBucketSize || AllocNewBucket() == false)
            {
                // if we fail the allocation, return 0 or raise an exception

                if (!(uFlags & HEAP_NO_SERIALIZE))
                {
                    LeaveCriticalSection(&m_cs);
                }

                if (uFlags & HEAP_GENERATE_EXCEPTIONS)
                {
                    RaiseException(STATUS_NO_MEMORY, 0, 0, 0);
                }

                return 0;
            }
        }

        // ok, we have enough space, allocate and initialize a block

        ASSERT(m_pBucket->Contains(m_pNextFree));

        CAllocation *pAllocation = (CAllocation *) m_pNextFree;
        pAllocation->m_nRefCount = 1;
        pAllocation->m_nDataSize = nSize;

        m_pNextFree += nAllocSize;
        m_pBucket->m_nAllocated += nAllocSize;

        ASSERT(m_pBucket->m_nAllocated < nBucketSize);

        // we are done

        if (!(uFlags & HEAP_NO_SERIALIZE))
        {
            LeaveCriticalSection(&m_cs);
        }

        if (uFlags & HEAP_ZERO_MEMORY)
        {
            // virtual alloc has already given us zero-init memory
        }

        return pAllocation->m_Data;
    }

    template <class T>
    T *allocate_array(size_t nItems, ULONG uFlags = 0)
    {
        return (T *) g_MyHeap.allocate(nItems * sizeof(T), uFlags);
    }

    void AddRef(void *pMem)
    {
        if (pMem)
        {
            CAllocation *pAllocation = CONTAINING_RECORD(pMem, CAllocation, m_Data);

            ASSERT(pAllocation->m_nRefCount != 0);

            InterlockedIncrement(&pAllocation->m_nRefCount);
        }
    }

    void deallocate(void *pMem, ULONG uFlags = 0)
    {
        if (!(uFlags & HEAP_NO_SERIALIZE))
        {
            EnterCriticalSection(&m_cs);
        }

        // find which bucket this allocation belongs to 

        CBucket *pBucket;

        if (nBucketSize == nAllocBlockSize)
        {
            // if the bucket size is aligned with the VirtualAlloc block size,
            // then simply zero the lower WORD to reach to the base address

            pBucket = (CBucket *) ((UINT_PTR)pMem & ~(nAllocBlockSize-1));
        }
        else
        {
            // the general case: find the bucket by walking though each one

            for (
                pBucket = m_pBucket;
                pBucket != 0 && !pBucket->Contains(pMem);
                pBucket = pBucket->m_pNextBucket
            );
        }

        // if we have found the container bucket, release the allocation 

        if (pBucket) 
        {
            CAllocation *pAllocation = CONTAINING_RECORD(pMem, CAllocation, m_Data);

            pAllocation->m_nRefCount -= 1;

            ASSERT(pAllocation->m_nRefCount >= 0);

            // delete the allocation if the reference count is zero

            if (pAllocation->m_nRefCount == 0)
            {
                pBucket->m_nAllocated -= AllocSize(pAllocation->m_nDataSize);

                ASSERT(pBucket->m_nAllocated >= 0);
    
                // if all the allocation units in this bucket are freed, 
                // free the bucket

                if (pBucket->m_nAllocated == 0)
                {
                    FreeBucket(pBucket);
                }
            }
        }

        if (!(uFlags & HEAP_NO_SERIALIZE))
        {
            LeaveCriticalSection(&m_cs);
        }
    }

    size_t max_size() const
    {
        return nBucketSize;
    }

    bool DumpAllocations() const
    {
        bool bResult = true;

        CBucket *pBucket = m_pBucket;

        while (pBucket) 
        {
            CAllocation *pAllocation = (CAllocation *) pBucket->m_Data;

            while (pAllocation->m_nDataSize != 0)
            {
                if (pAllocation->m_nRefCount != 0)
                {
                    OutputDebugStringF(
                        _T("0x%p, DataSize=%d, RefCount=%d; %s\n"), 
                        pAllocation->m_Data,
                        pAllocation->m_nDataSize,
                        pAllocation->m_nRefCount,
                        pAllocation->m_Data
                    );
                }

                pAllocation = (CAllocation *) 
                    ((PBYTE)pAllocation + AllocSize(pAllocation->m_nDataSize));
            }

            pBucket = pBucket->m_pNextBucket;
        }

        return bResult;
    }

private:
    struct CBucket 
    {
        CBucket *m_pNextBucket;
        LONG     m_nAllocated;
        BYTE     m_Data[ANYSIZE_ARRAY];

        bool Contains(const void *pMem) const
        {
            return 
                (PBYTE)pMem >= (PBYTE)m_Data &&
                (PBYTE)pMem <  (PBYTE)this + nBucketSize;
        }
    };

    struct CAllocation
    {
        size_t   m_nDataSize;
        LONG     m_nRefCount;
        BYTE     m_Data[ANYSIZE_ARRAY];
    };

private:
    static size_t AllocSize(int nDataSize)
    {
        return (nDataSize + FIELD_OFFSET(CAllocation, m_Data) + (ALIGNMENT-1)) & ~(ALIGNMENT-1);
    }

    bool AllocNewBucket()
    {
        CBucket *pBucket = (CBucket *) VirtualAlloc(
            0,
            nBucketSize,
            MEM_COMMIT,
            PAGE_READWRITE
        );

        if (pBucket) 
        {
            pBucket->m_pNextBucket = m_pBucket;

            m_pBucket   = pBucket;
            m_pNextFree = pBucket->m_Data;

            return true;
        }

        return false;
    }

    void FreeBucket(CBucket *pThisBucket)
    {
        CBucket **ppBucket = &m_pBucket;
        ASSERT(*ppBucket != 0);

        while (*ppBucket != pThisBucket) 
        {
            ppBucket = &((*ppBucket)->m_pNextBucket);
            ASSERT(*ppBucket != 0);
        }

        *ppBucket = pThisBucket->m_pNextBucket;

        VirtualFree(pThisBucket, 0, MEM_RELEASE);
    }

    void FreeAllBuckets()
    {
        CBucket *pBucket = m_pBucket;

        while (pBucket) 
        {
            CBucket *pThisBucket = pBucket;
            pBucket = pBucket->m_pNextBucket;
            VirtualFree(pThisBucket, 0, MEM_RELEASE);
        }

        m_pBucket   = 0;
        m_pNextFree = 0;
    }

private:
    CRITICAL_SECTION m_cs;
    CBucket         *m_pBucket;
    PBYTE            m_pNextFree;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

extern CMyHeap<> g_MyHeap;

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class T>
class CMyAlloc //: public allocator<T>
{
public:
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef T *pointer;
	typedef const T *const_pointer;
	typedef T &reference;
	typedef const T &const_reference;
	typedef T value_type;

    pointer allocate(size_type N, const void *)
    {
        return (pointer) g_MyHeap.allocate(N); 
    }

	char *_Charalloc(size_type N)
    {
        return (char *) g_MyHeap.allocate(N); 
    }

    void deallocate(void *P, size_type)
	{
        g_MyHeap.deallocate(P);
    }

    size_type max_size() const
	{
		return g_MyHeap.max_size();
    }
};

template<class T, class U> 
inline bool operator ==(const CMyAlloc<T>&, const CMyAlloc<U>&)
{
    return true; 
}

template<class T, class U> 
inline bool operator !=(const CMyAlloc<T>&, const CMyAlloc<U>&)
{
    return false; 
}

//////////////////////////////////////////////////////////////////////////
//
//
//

class CMyStr
{
public:
    CMyStr()
    {
        m_pStr = 0;
    }

    ~CMyStr()
    {
        g_MyHeap.deallocate(m_pStr);
    }

    explicit CMyStr(int nLength)
    {
        m_pStr = (PTSTR) g_MyHeap.allocate(nLength * sizeof(TCHAR));
        m_pStr[0] = _T('\0');
    }

    CMyStr(PCTSTR pStr)
    {
        DupStr(pStr);
    }

    CMyStr(const CMyStr &rhs)
    {
        g_MyHeap.AddRef(rhs.m_pStr);
        m_pStr = rhs.m_pStr;
    }

    CMyStr &operator =(PCTSTR pStr)
    {
        g_MyHeap.deallocate(m_pStr);
        DupStr(pStr);
        return *this;
    }

    CMyStr &operator =(const CMyStr &rhs)
    {
        g_MyHeap.AddRef(rhs.m_pStr);
        g_MyHeap.deallocate(m_pStr);
        m_pStr = rhs.m_pStr;
        return *this;
    }

    operator PTSTR()
    {
        return m_pStr;
    }

    operator PCTSTR() const
    {
        return m_pStr;
    }

private:
    void DupStr(PCTSTR pStr)
    {
        if (!pStr) 
        {
            pStr = _T("");
        }

        m_pStr = (PTSTR) g_MyHeap.allocate((_tcslen(pStr) + 1) * sizeof(TCHAR));

        if (m_pStr) 
        {
            _tcscpy(m_pStr, pStr);
        }
    }

private:
    PTSTR m_pStr;
};


#endif //MYHEAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\logwrappers.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    LogWrappers.h

Abstract:

    Helper classes for logging APIs

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef LOGWRAPPERS_H
#define LOGWRAPPERS_H

#include <map>

#include "LogWindow.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

#define TLS_NOCONSOLE 0x04000000L

//////////////////////////////////////////////////////////////////////////
//
//
//

#define LOG_LEVELS    0x0000FFFFL    // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L    // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL    // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L    // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L    // Log information.
#define TLS_ABORT     0x00000001L    // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L    // Log at Severity 1 level
#define TLS_SEV2      0x00000004L    // Log at Severity 2 level
#define TLS_SEV3      0x00000008L    // Log at Severity 3 level
#define TLS_WARN      0x00000010L    // Log at Warn level
#define TLS_PASS      0x00000020L    // Log at Pass level
#define TLS_BLOCK     0x00000400L    // Block the variation.
#define TLS_BREAK     0x00000800L    // Debugger break;
#define TLS_CALLTREE  0x00000040L    // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L    // Log System debug.
#define TLS_TESTDEBUG 0x00001000L    // Debug level.
#define TLS_TEST      0x00000100L    // Log Test information (user).
#define TLS_VARIATION 0x00000200L    // Log testcase level.

#define TLS_REFRESH   0x00010000L    // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L    // Sort file output by instance.
#define TLS_DEBUG     0x00040000L    // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L    // Output to 2nd screen.
#define TLS_PROLOG    0x00200000L    // Prolog line information.
#define TLS_WINDOW    0x00400000L    // Log to windows.
#define TLS_ACCESSON  0x00800000L    // Keep log-file open.
#define TLS_DIFFABLE  0x01000000L    // make log file windiff'able (no dates..)
#define TLS_NOHEADER  0x02000000L    // suppress headers so it is more diffable

#define TL_LOG       TLS_LOG      ,_T(__FILE__),(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,_T(__FILE__),(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,_T(__FILE__),(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,_T(__FILE__),(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,_T(__FILE__),(int)__LINE__
#define TL_WARN      TLS_WARN     ,_T(__FILE__),(int)__LINE__
#define TL_PASS      TLS_PASS     ,_T(__FILE__),(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,_T(__FILE__),(int)__LINE__
#define TL_INFO      TLS_INFO     ,_T(__FILE__),(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,_T(__FILE__),(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,_T(__FILE__),(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,_T(__FILE__),(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,_T(__FILE__),(int)__LINE__
#define TL_TEST      TLS_TEST     ,_T(__FILE__),(int)__LINE__
#define TL_VARIATION TLS_VARIATION,_T(__FILE__),(int)__LINE__

//////////////////////////////////////////////////////////////////////////
//
//
//

class CLog
{
protected:
    struct CResults
    {
        UINT   nTotal;
        UINT   nPassed;
        UINT   nWarned;
        UINT   nFailedSev3;
        UINT   nFailedSev2;
        UINT   nFailedSev1;
        UINT   nBlocked;
        UINT   nAborted;
        DWORD  dwStartTime;

        CResults()
        {
            ZeroMemory(this, sizeof(*this));
            dwStartTime = GetTickCount();
        }

        void Update(DWORD dwLogLevel)
        {
            if (dwLogLevel & TLS_PASS) ++nPassed;
            if (dwLogLevel & TLS_WARN) ++nWarned;
            if (dwLogLevel & TLS_SEV3) ++nFailedSev3;
            if (dwLogLevel & TLS_SEV2) ++nFailedSev2;
            if (dwLogLevel & TLS_SEV1) ++nFailedSev1;
            if (dwLogLevel & TLS_BLOCK) ++nBlocked;
            if (dwLogLevel & TLS_ABORT) ++nAborted;
        }

        PCTSTR Report(PTSTR pBuffer, SIZE_T nBufferLen) const
        {
            DWORD dwUpTime = GetTickCount() - dwStartTime;

            _sntprintf(
                pBuffer, 
                nBufferLen, 
                _T("%d total, ")
                _T("%d passed, ")
                _T("%d warned, ")
                _T("%d failed sev1, ")
                _T("%d failed sev2, ")
                _T("%d failed sev3, ")
                _T("%d blocked, ")
                _T("%d aborted tests in ")
                _T("%d hours, ")
                _T("%d mins, ")
                _T("%d secs"),
                nTotal,
                nPassed,
                nWarned,
                nFailedSev3,
                nFailedSev2,
                nFailedSev1,
                nBlocked,
                nAborted,
                dwUpTime / (1000 * 60 * 60),
                (dwUpTime / (1000 * 60)) % 60,
                (dwUpTime / 1000) % 60
            );

            return pBuffer;
        }

        PCTSTR Summary() const
        {
            if (nAborted)
            {
                return _T("TIMEOUT");
            }

            if (nBlocked)
            {
                return _T("NOCONFIG");
            }

            if (nFailedSev3 || nFailedSev2 || nFailedSev1)
            {
                return _T("FAIL");
            }

            return _T("PASS");
        }
    };

public:
	CLog()
	{
        m_pLogWindow = 0;
        m_bMute      = false;
	}

    virtual ~CLog()
    {
    }

    VOID
    SetLogWindow(
        CLogWindow *pLogWindow
    )
    {
        m_pLogWindow = pLogWindow;
    }

    VOID
    Mute(bool bMute = true)
    {
        m_bMute = bMute;
    }

	PCTSTR
    __cdecl
	Log(
		DWORD  dwLogLevel,
		PCTSTR pFile,
		int    nLine,
		PCTSTR pFormat,
        ...
	)
	{
        va_list arglist;
        va_start(arglist, pFormat);

        return LogV(dwLogLevel, pFile, nLine, pFormat, arglist);
	}

    PCTSTR 
	LogV(
		DWORD   dwLogLevel,
		PCTSTR  pFile,
		int     nLine,
		PCTSTR  pFormat,
        va_list arglist
	)
	{
        CCppMem<TCHAR> pszStr(bufvprintf(pFormat, arglist));

        PCTSTR pszComment = _T("");

        if (!m_bMute) 
        {
            if (dwLogLevel & TLS_TEST)
            {
                m_TestResults.Update(dwLogLevel);
            }

            if (dwLogLevel & TLS_VARIATION)
            {
                if (dwLogLevel & (TLS_WARN | TLS_SEV1 | TLS_SEV2 | TLS_SEV3 | TLS_ABORT))
                {
                    DWORD &rResult = m_ThreadResult[GetCurrentThreadId()];

                    if (rResult < dwLogLevel)
                    {
                        rResult = dwLogLevel;
                    }
                }
            }

		    if (dwLogLevel & TLS_NOCONSOLE) 
            {
                dwLogLevel &= ~TLS_NOCONSOLE;
            } 
            else 
            {
                if (dwLogLevel & TLS_DEBUG)
                {
                    if (pFile)
                    {
                        OutputDebugString(pFile);
                        OutputDebugString(_T(" ")); 
                    }

                    OutputDebugString(pszStr);
                    OutputDebugString(_T("\n")); //bugbug: talk about inefficiency...

                    dwLogLevel &= ~TLS_DEBUG;
                }

                if (m_pLogWindow) 
                {
                    TCHAR Buffer[1024];

                    pszComment = m_pLogWindow->Log(
                        dwLogLevel, 
                        pFile, 
                        nLine, 
                        pszStr,
                        m_VarResults.Report(Buffer, COUNTOF(Buffer))
                    );
                } 
                else 
                {
                    _ftprintf(
                        dwLogLevel & TLS_INFO ? stdout : stderr, 
                        _T("%s\n"), 
                        pszStr
                    );
                }
		    }

	        LogStr(
		        dwLogLevel,
		        pFile,
		        nLine,
		        pszStr,
		        pszComment
	        );
        }

        return pszComment;
	}

    virtual
    VOID   
	LogStr(
		DWORD  dwLogLevel,
		PCTSTR pFile,
		int    nLine,
		PCTSTR pStr,
		PCTSTR pComment
	)
    {
    }

	virtual
    VOID 
	StartVariation()
	{
        ++m_VarResults.nTotal;
        m_ThreadResult[GetCurrentThreadId()] = TLS_PASS;
	}

	virtual
	DWORD 
	EndVariation()
	{
        DWORD dwResult = m_ThreadResult[GetCurrentThreadId()];
        m_VarResults.Update(dwResult);
		return dwResult;
	}

    virtual
    VOID
    InitThread()
    {
    }

    virtual
    VOID
    DoneThread()
    {
    }

    virtual
	VOID
	StartBlock(PCTSTR pBlockName, BOOL bStamp = TRUE)
    {
    }

    virtual
	VOID
	EndBlock(PCTSTR pBlockName, BOOL bStamp = TRUE)
    {
    }

private:
    CLogWindow  *m_pLogWindow;
    bool         m_bMute;
    
protected:
    CResults     m_TestResults;
    CResults     m_VarResults;

    std::map<DWORD, DWORD> m_ThreadResult;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CNtLog : public CHandle<HANDLE, CNtLog>, public CLog
{
	typedef CHandle<HANDLE, CNtLog> handle_type;

public:
    CNtLog()
    {
    }

	CNtLog(
		PCTSTR     pszLogFile, 
		DWORD      dwLogInfo,
		LPSECURITY_ATTRIBUTES lpSecAttrs = 0
    ) :
        handle_type((*m_Dll.CreateLogEx)(
		    pszLogFile, 
		    dwLogInfo, 
		    lpSecAttrs
		))
	{
		InitThread();
	}

	void Destroy()
	{
		(*m_Dll.ReportStats)(*this);
		(*m_Dll.RemoveParticipant)(*this);
		(*m_Dll.DestroyLog)(*this);
	}

	bool IsValid()
	{
		return (HANDLE) *this != INVALID_HANDLE_VALUE;
	}

    VOID
    InitThread()
    {
        AddParticipant();
    }

    VOID
    DoneThread()
    {
        RemoveParticipant();
    }

	VOID
	AddParticipant(
		DWORD dwLevels = 0,
		int nMachineID = 0
	) const
	{
	    (*m_Dll.AddParticipant)(
			*this, 
			dwLevels, 
			nMachineID
		);
	}

	VOID
	RemoveParticipant() const
	{
        (*m_Dll.RemoveParticipant)(*this);
	}

	static
	DWORD  
	ParseCmdLine(
		PCTSTR pszCmdLine
	)
	{
        return (*m_Dll.ParseCmdLine)(pszCmdLine);
	}

	int    
	GetLogFileName(
		PTSTR pszFileName
	) const
	{
		return (*m_Dll.GetLogFileName)(*this, pszFileName);
	}

	VOID    
	SetLogFileName(
		PTSTR pszFileName
	) const
	{
		(*m_Dll.SetLogFileName)(*this, pszFileName);
	}

	DWORD  
	GetLogInfo() const
	{
		return (*m_Dll.GetLogInfo)(*this);
	}

	DWORD  
	SetLogInfo(
		DWORD dwInfo
	) const
	{
		return (*m_Dll.SetLogInfo)(*this, dwInfo);
	}

	VOID
	PromptLog(
		HWND hWnd = 0
	) const
	{
		(*m_Dll.PromptLog)(hWnd, *this);
	}

	int
	GetTestStat(
		DWORD dwLevel
	) const
	{
		return (*m_Dll.GetTestStat)(*this, dwLevel);
	}

	int
	GetVariationStat(
		DWORD dwLevel
	) const
	{
		return (*m_Dll.GetVariationStat)(*this, dwLevel);
	}

	VOID   
	ClearTestStats() const
	{
		(*m_Dll.ClearTestStats)(*this);
	}

	VOID   
	ClearVariationStats() const
	{
		(*m_Dll.ClearVariationStats)(*this);
	}

	VOID
	StartVariation()
	{
        CLog::StartVariation();
		(*m_Dll.StartVariation)(*this);
	}

	DWORD  
	EndVariation()
	{
        CLog::EndVariation();
		return (*m_Dll.EndVariation)(*this);
	}

	VOID   
	ReportStats() const
	{
		(*m_Dll.ReportStats)(*this);
	}

    VOID   
	LogStr(
		DWORD  dwLogLevel,
		PCTSTR pFile,
		int    nLine,
		PCTSTR pStr,
		PCTSTR pComment
	)
	{
		(*m_Dll.Log)(
			*this, 
			dwLogLevel, 
			pFile, 
			nLine,
            pComment && *pComment ? _T("%s (%s)") : _T("%s"),
			pStr,
            pComment
		);
	}

private:
    class CNtLogDLL
	{
	public:
		CNtLogDLL()
		{
		    try 
            {
			    m_NtLog = CLibrary(_T("ntlog.dll"));

			    CreateLog			 = CCreateLog          (m_NtLog, "tlCreateLog_"_AW);
			    CreateLogEx		     = CCreateLogEx        (m_NtLog, "tlCreateLogEx_"_AW);
			    ParseCmdLine		 = CParseCmdLine       (m_NtLog, "tlParseCmdLine_"_AW);
			    GetLogFileName		 = CGetLogFileName     (m_NtLog, "tlGetLogFileName_"_AW);
			    SetLogFileName		 = CSetLogFileName     (m_NtLog, "tlSetLogFileName_"_AW);
			    LogX				 = CLogX               (m_NtLog, "tlLogX_"_AW);
			    Log				     = CLog                (m_NtLog, "tlLog_"_AW);
			    DestroyLog			 = CDestroyLog         (m_NtLog, "tlDestroyLog");
			    AddParticipant		 = CAddParticipant     (m_NtLog, "tlAddParticipant");
			    RemoveParticipant	 = CRemoveParticipant  (m_NtLog, "tlRemoveParticipant");
			    GetLogInfo			 = CGetLogInfo         (m_NtLog, "tlGetLogInfo");
			    SetLogInfo			 = CSetLogInfo         (m_NtLog, "tlSetLogInfo");
			    PromptLog			 = CPromptLog          (m_NtLog, "tlPromptLog");
			    GetTestStat		     = CGetTestStat        (m_NtLog, "tlGetTestStat");
			    GetVariationStat	 = CGetVariationStat   (m_NtLog, "tlGetVariationStat");
			    ClearTestStats		 = CClearTestStats     (m_NtLog, "tlClearTestStats");
			    ClearVariationStats  = CClearVariationStats(m_NtLog, "tlClearVariationStats");
			    StartVariation		 = CStartVariation     (m_NtLog, "tlStartVariation");
			    EndVariation		 = CEndVariation       (m_NtLog, "tlEndVariation");
			    ReportStats		     = CReportStats        (m_NtLog, "tlReportStats");
		    } 
            catch (...) 
            {    
			    //_tprintf(_T("*** Cannot load NTLOG.DLL, no log file will be generated ***\n"));
		    }
        }

	private:
        CLibrary m_NtLog;

	public:
        DECL_CWINAPI(HANDLE, APIENTRY, CreateLog, (LPCTSTR, DWORD));
        DECL_CWINAPI(HANDLE, APIENTRY, CreateLogEx, (LPCTSTR, DWORD, LPSECURITY_ATTRIBUTES));
        DECL_CWINAPI(DWORD,  APIENTRY, ParseCmdLine, (LPCTSTR));
        DECL_CWINAPI(int,    APIENTRY, GetLogFileName, (HANDLE, LPTSTR));
        DECL_CWINAPI(BOOL,   APIENTRY, SetLogFileName, (HANDLE, LPCTSTR));
        DECL_CWINAPI(BOOL,   APIENTRY, LogX, (HANDLE, DWORD, LPCTSTR, int, LPCTSTR));
        DECL_CWINAPI(BOOL,   __cdecl,  Log, (HANDLE, DWORD, LPCTSTR, int, LPCTSTR, ...));
        DECL_CWINAPI(BOOL,   APIENTRY, DestroyLog, (HANDLE));
        DECL_CWINAPI(BOOL,   APIENTRY, AddParticipant, (HANDLE, DWORD, int));
        DECL_CWINAPI(BOOL,   APIENTRY, RemoveParticipant, (HANDLE));
        DECL_CWINAPI(DWORD,  APIENTRY, GetLogInfo, (HANDLE));
        DECL_CWINAPI(DWORD,  APIENTRY, SetLogInfo, (HANDLE, DWORD));
        DECL_CWINAPI(HANDLE, APIENTRY, PromptLog, (HWND, HANDLE));
        DECL_CWINAPI(int,    APIENTRY, GetTestStat, (HANDLE, DWORD));
        DECL_CWINAPI(int,    APIENTRY, GetVariationStat, (HANDLE, DWORD));
        DECL_CWINAPI(BOOL,   APIENTRY, ClearTestStats, (HANDLE));
        DECL_CWINAPI(BOOL,   APIENTRY, ClearVariationStats, (HANDLE));
        DECL_CWINAPI(BOOL,   APIENTRY, StartVariation, (HANDLE));
        DECL_CWINAPI(DWORD,  APIENTRY, EndVariation, (HANDLE));
        DECL_CWINAPI(BOOL,   APIENTRY, ReportStats, (HANDLE));
	};

private:
	static CNtLogDLL m_Dll;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

// Invalid Log handle define
#define INVALID_LOGHANDLE			-1

// Log file and debug output flags
#define NO_LOG			0x000000
#define STAT_LOG		0x000001	// Local logging operation
#define SUM_LOG			0x000002
#define	ERR_LOG			0x000004
#define DBG_LOG			0x000008
#define SVR_STAT_LOG	0x010000
#define SVR_SUM_LOG		0x020000	// Lormaster Server logging operation
#define	SVR_ERR_LOG		0x040000
#define SVR_DBG_LOG		0x080000
#define SVR_SQL_LOG		0x100000	// Perform SQL logging

// LogFile Creation flags
#define LOG_NEW			0x001
#define LOG_APPEND		0x002
#define LOG_NOCREATE	0x004

// Test result type
#define RESULT_INFO		0
#define RESULT_TESTPASS	1
#define RESULT_TESTFAIL	2
#define RESULT_TESTNA	3
#define RESULT_SUMMARY	4
#define RESULT_DEBUG	5
#define RESULT_ERRINFO  6

//////////////////////////////////////////////////////////////////////////
//
//
//

class CLorLog : public CHandle<unsigned long, CLorLog>, public CLog
{
	typedef CHandle<unsigned long, CLorLog> handle_type;

public:
    CLorLog()
    {
    }

	CLorLog(
		const char *pTest_Name,
		const char *pLog_Path,
		unsigned long dwCreate_Flags,
		unsigned long dwLog_Flags,
		unsigned long dwDebug_Flags
    ) :
        handle_type((*m_Dll.RegisterTest)(
		    pTest_Name,
		    pLog_Path,
		    dwCreate_Flags,
		    dwLog_Flags,
		    dwDebug_Flags
        ))
	{
	}

	CLorLog(
		const char *pTest_Name,
		const char *pLog_Path,
		DWORD Create_Flags,
		DWORD Log_Flags,
		DWORD Debug_Flags,
		DWORD dwProcessID
    ) :
        handle_type((*m_Dll.RegisterTest_ProcID)(
		    pTest_Name,
		    pLog_Path,
		    Create_Flags,
		    Log_Flags,
		    Debug_Flags,
            dwProcessID
        ))
	{
	}

	void Destroy()
	{
        (*m_Dll.UnRegisterTest)(*this);
	}

	bool IsValid()
	{
		return *this != INVALID_LOGHANDLE;
	}

    VOID   
	LogStr(
		DWORD  dwLogLevel,
		PCTSTR pFile,
		int    nLine,
		PCTSTR pStr,
		PCTSTR pComment
	)
    {
        DWORD dwType;

        if (dwLogLevel & TLS_INFO)
        {
            dwType = RESULT_INFO;
        }
        else if (dwLogLevel & (TLS_WARN | TLS_SEV1 | TLS_SEV2 | TLS_SEV3 | TLS_ABORT))
        {
            dwType = RESULT_ERRINFO;
        }
        else
        {
            dwType = RESULT_INFO;
        }

        USES_CONVERSION;

		(*m_Dll.TestResultEx)(
			*this, 
			dwType, 
            pComment && *pComment ? "%1: %2!d!: %3 (%4)" : "%1: %2!d!: %3",
			T2A(pFile), 
			nLine,
			T2A(pStr),
            T2A(pComment)
		);
	}

private:
    class CLorLogDLL
	{
	public:
		CLorLogDLL()
		{
		    try 
            {
			    m_LorLog = CLibrary(_T("loglog32.dll"));

			    RegisterTest    	 = CRegisterTest       (m_LorLog, "RegisterTest");
			    RegisterTest_ProcID  = CRegisterTest_ProcID(m_LorLog, "RegisterTest_ProcID");
			    TestResult           = CTestResult         (m_LorLog, "TestResult");
			    TestResultEx         = CTestResultEx       (m_LorLog, "TestResultEx");
			    UnRegisterTest       = CUnRegisterTest     (m_LorLog, "UnRegisterTest");
			    QueryTestResults     = CQueryTestResults   (m_LorLog, "QueryTestResults");
		    } 
            catch (...) 
            {    
			    //_tprintf(_T("*** Cannot load LORLOG32.DLL, no log file will be generated ***\n"));
		    }
        }

	private:
        CLibrary m_LorLog;

	public:
        DECL_CWINAPI(unsigned long, WINAPI,  RegisterTest, (const char *, const char *, unsigned long, unsigned long, unsigned long));
        DECL_CWINAPI(unsigned long, WINAPI,  RegisterTest_ProcID, (const char *, const char *, DWORD, DWORD, DWORD, DWORD));
        DECL_CWINAPI(int,           WINAPI,  TestResult, (unsigned long, unsigned long, const char *));
        DECL_CWINAPI(int,           __cdecl, TestResultEx, (unsigned long, unsigned long, const char *, ...));
        DECL_CWINAPI(int,           WINAPI,  UnRegisterTest, (unsigned long));
        DECL_CWINAPI(int,           WINAPI,  QueryTestResults, (unsigned long, unsigned long *, unsigned long *, unsigned long *));
	};

private:
	static CLorLogDLL m_Dll;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

#define TIME_TO_STR_FORMAT              \
    _T("%d/%d/%02d %d:%02d:%02d %cM")

#define TIME_TO_STR_ARGS(st)            \
    st.wMonth,                          \
    st.wDay,                            \
    st.wYear % 100,                     \
    st.wHour % 12,                      \
    st.wMinute,                         \
    st.wSecond,                         \
    st.wHour / 12 ? _T('P') : _T('A')   \

//////////////////////////////////////////////////////////////////////////
//
//
//

class CBvtLog : public CLog
{
public:
    struct COwners
    {
        PCTSTR pTestName;
        PCTSTR pContactName;
        PCTSTR pMgrName;
        PCTSTR pDevPrimeName;
        PCTSTR pDevAltName;
        PCTSTR pTestPrimeName;
        PCTSTR pTestAltName;
    };

public:
    CBvtLog()
    {
    }

	CBvtLog(
        COwners *pOwners,
        PCTSTR   filename, 
        PCTSTR   mode = _T("at"),
        int      shflag = _SH_DENYWR
    ) :
        m_nIntent(0),
        m_nBlock(0),
        m_pOwners(pOwners),
        m_LogFile(filename, mode, shflag)
	{
        setvbuf(m_LogFile, 0, _IONBF, 0);

        GetLocalTime(&m_StartTime);

        StartBlock(_T("TESTRESULT"), FALSE);
	}

    ~CBvtLog()
    {
        GetLocalTime(&m_EndTime);

        ReportStats();

        EndBlock(_T("TESTRESULT"), FALSE);
    }

	VOID   
	ReportStats() const
    {
        _ftprintf(
            m_LogFile,
            _T("\n")
            _T("%*sTEST:         %s\n")
            _T("%*sRESULT:       %s\n")
            _T("%*sBUILD:        %d\n")
            _T("%*sMACHINE:      %s\n")
            _T("%*sCONTACT:      %s\n")
            _T("%*sMGR CONTACT:  %s\n")
            _T("%*sDEV PRIME:    %s\n")
            _T("%*sDEV ALT:      %s\n")
            _T("%*sTEST PRIME:   %s\n")
            _T("%*sTEST ALT:     %s\n")
            _T("%*sSTART TIME:   ") TIME_TO_STR_FORMAT _T("\n")
            _T("%*sEND TIME:     ") TIME_TO_STR_FORMAT _T("\n")
            _T("\n"),
            m_nIntent, _T(""), m_pOwners->pTestName,
            m_nIntent, _T(""), m_VarResults.Summary(), //bugbug
            m_nIntent, _T(""), COSVersionInfo().dwBuildNumber,
            m_nIntent, _T(""), (PCTSTR) CComputerName(TRUE),
            m_nIntent, _T(""), m_pOwners->pContactName,
            m_nIntent, _T(""), m_pOwners->pMgrName,
            m_nIntent, _T(""), m_pOwners->pDevPrimeName,
            m_nIntent, _T(""), m_pOwners->pDevAltName,
            m_nIntent, _T(""), m_pOwners->pTestPrimeName,
            m_nIntent, _T(""), m_pOwners->pTestAltName,
            m_nIntent, _T(""), TIME_TO_STR_ARGS(m_StartTime),
            m_nIntent, _T(""), TIME_TO_STR_ARGS(m_EndTime)
        );
	}

    VOID   
	LogStr(
		DWORD  dwLogLevel,
		PCTSTR pFile,
		int    nLine,
		PCTSTR pStr,
		PCTSTR pComment
	) 
    {
        PCTSTR pszText;
        int    iImage;
        
        CLogWindow::FindNtLogLevel(dwLogLevel, &pszText, &iImage);

        _ftprintf(
            m_LogFile,
            pComment && *pComment ? _T("%*s%s: %s (%s)\n") : _T("%*s%s: %s\n"),
            m_nIntent, _T(""),
            pszText,
			pStr,
            pComment
		);
	}

	VOID
	StartBlock(PCTSTR pBlockName, BOOL bStamp /*= TRUE*/)
	{
        SYSTEMTIME st;
        GetLocalTime(&st);

        _ftprintf(
            m_LogFile, 
            bStamp ? _T("%*s[%s %d - ") TIME_TO_STR_FORMAT _T("]\n") : _T("%*s[%s]\n"),
            m_nIntent, _T(""), pBlockName,
            InterlockedIncrement(&m_nBlock),
            TIME_TO_STR_ARGS(st)
        );
        
        m_nIntent += 4;
    }

	VOID
	EndBlock(PCTSTR pBlockName, BOOL bStamp /*= TRUE*/)
	{
        m_nIntent -= 4;

        SYSTEMTIME st;
        GetLocalTime(&st);

        _ftprintf(
            m_LogFile, 
            bStamp ? _T("%*s[/%s - ") TIME_TO_STR_FORMAT _T("]\n\n") : _T("%*s[/%s]\n\n"),
            m_nIntent, _T(""), pBlockName,
            TIME_TO_STR_ARGS(st)
        );
    }

private:
public:
    COwners   *m_pOwners;

	CCFile     m_LogFile;
    
    SYSTEMTIME m_StartTime;
    SYSTEMTIME m_EndTime;

    int        m_nIntent; //bugbug

    LONG       m_nBlock;
};


//////////////////////////////////////////////////////////////////////////
//
//
//

extern CCppMem<CLog> g_pLog;

//////////////////////////////////////////////////////////////////////////
//
//
//

template <DWORD dwLogLevel> 
struct CLogHelper
{
	PCTSTR
    __cdecl
	operator ()(
		PCTSTR pFormat,
        ...
	)
	{
        va_list arglist;
        va_start(arglist, pFormat);

		return g_pLog->LogV(dwLogLevel, _T(""), 0, pFormat, arglist);
	}
};

#endif LOGWRAPPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\resource.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiastress.rc
//
#define IDB_STATES                      999

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\result.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    result.h

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef RESULT_H
#define RESULT_H

#ifndef ASSERT
#define ASSERT assert
#endif

#ifndef PCTSTR
#define PCTSTR LPCTSTR
#endif //PCTSTR

#if defined(_X86_)
    #define CURRENT_MACHINE_TYPE  IMAGE_FILE_MACHINE_I386
#elif defined(_MIPS_)
    #define CURRENT_MACHINE_TYPE  IMAGE_FILE_MACHINE_R4000
#elif defined(_ALPHA_)
    #define CURRENT_MACHINE_TYPE  IMAGE_FILE_MACHINE_ALPHA
#elif defined(_PPC_)
    #define CURRENT_MACHINE_TYPE  IMAGE_FILE_MACHINE_POWERPC
#elif defined(_AXP64_)
    #define CURRENT_MACHINE_TYPE  IMAGE_FILE_MACHINE_ALPHA64
#elif defined(_IA64_)
    #define CURRENT_MACHINE_TYPE  IMAGE_FILE_MACHINE_IA64
    #ifndef CONTEXT_CONTROL
        #pragma message("CONTEXT_CONTROL was not defined!!!")
        #define CONTEXT_CONTROL CONTEXT86_CONTROL
    #endif CONTEXT_CONTROL
#else
    #undef CURRENT_MACHINE_TYPE
#endif

//
// The CHECK() macro can be used to evaluate the result of APIs that use
// LastError. These APIs typically return a non-zero value if there is 
// no error and if there is an error, they return zero and SetLastError()
// with the extended error information.
//

#define CHECK(Expression)                                           \
	{															    \
		if ((Expression) == 0) {						            \
																    \
			throw CError(GetLastError() STAMP(_T(#Expression)));    \
		}														    \
	}															    \

//
// CHECK0 macro deals with the API functions that do not use the LastError 
// value. Typically registry APIs fall into this category, they directly 
// return the error code, or ERROR_SUCCESS if there is no error.
//

#define CHECK_REG(Expression)                                       \
	{															    \
		DWORD __dwResult = (DWORD) (Expression);				    \
																    \
		if (__dwResult != ERROR_SUCCESS) {						    \
																    \
			throw CError(__dwResult STAMP(_T(#Expression)));        \
		}														    \
	}															    \

//
// CHECK0 macro deals with the API functions that do not use the LastError 
// value. Typically registry APIs fall into this category, they directly 
// return the error code, or ERROR_SUCCESS if there is no error.
//

#define CHECK_HR(Expression)                                        \
	{															    \
		HRESULT __hr = Expression;				                    \
																    \
        if (__hr != S_OK)                                           \
        {														    \
			throw CError(__hr STAMP(_T(#Expression)));              \
		}														    \
	}															    \

//
// CHECK_LSA macro deals with the LSA API functions.
//

#define CHECK_LSA(Expression) \
	{															    \
		DWORD __dwResult = (DWORD) (Expression);				    \
																    \
		if (__dwResult != ERROR_SUCCESS) 						    \
        {                                                           \
            __dwResult = LsaNtStatusToWinError(__dwResult);         \
																    \
			throw CError(__dwResult STAMP(_T(#Expression)));        \
		}														    \
	}															    \

//
// On DEBUG builds, we include the location STAMP on the error message popup,
// i.e. we display the expression that raised the error, the module name and
// the line number 
//

#ifdef _CONSOLE
    #define ENDL _T("\n")
#else //_CONSOLE
    #define ENDL _T(", ")
#endif //_CONSOLE

#if defined(DEBUG) || defined(_DEBUG) || defined(DBG)
	#define STAMP(pExpr)	, pExpr, _T(__FILE__), __LINE__
	#define STAMP_DECL		, PCTSTR pExpr = _T(""), PCTSTR pFile = _T(""), INT nLine = 0
	#define STAMP_INIT      , m_pExpr(pExpr), m_pFile(pFile), m_nLine(nLine)
	#define STAMP_ARGS		, m_pExpr, m_pFile, (PCTSTR) m_nLine 
	#define STAMP_DEFINE	PCTSTR m_pExpr; PCTSTR m_pFile; INT m_nLine; mutable CONTEXT m_Context;
	#define STAMP_FORMAT	_T("%s") ENDL _T("%s: %d") ENDL
    #define STAMP_IOS	    << std::endl << rhs.m_pExpr << std::endl << rhs.m_pFile << _T(": ") << rhs.m_nLine
	#define STAMP_LENGTH	_tcslen(pExpr) + _tcslen(pFile) + 8
#else //DEBUG
	#define STAMP(pExpr)
	#define STAMP_DECL
	#define STAMP_INIT
	#define STAMP_ARGS
	#define STAMP_DEFINE
	#define STAMP_FORMAT
    #define STAMP_IOS
	#define STAMP_LENGTH 0
#endif //DEBUG


inline PTSTR _tcsdupl(LPCTSTR pStrSource)
{
    if (!pStrSource) {

        pStrSource = _T("");
    }

    PTSTR pStrDest = (PTSTR) ::LocalAlloc(
        LMEM_FIXED, 
        (_tcslen(pStrSource) + 1) * sizeof(TCHAR)
    );

    if (pStrDest) {

        _tcscpy(pStrDest, pStrSource);
    }

    return pStrDest;
}

inline PTSTR FormatMessageFromSystem(DWORD nNum)
{
    PTSTR pText = 0;

    DWORD dwResult = ::FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS |
		FORMAT_MESSAGE_MAX_WIDTH_MASK,
		0,
		nNum,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
		(PTSTR) &pText,
		0,
		0
	);

    if (pText == 0) {

        pText = _tcsdupl(_T("Unknown Error"));
    }

    return pText;
}

#ifdef _IOSTREAM_

// workaround for VC6 compiler bug (Q192539)

class CError;
std::ostream &operator <<(std::ostream &os, const CError &rhs);

#endif //_IOSTREAM_


//////////////////////////////////////////////////////////////////////////
//
// CError
//

class CError
{
public:
	CError(
		PTSTR pText
		STAMP_DECL
	) :
		m_nNum(0),
		m_pText(pText),
        m_bFree(false)
		STAMP_INIT
	{
#if (defined(DEBUG) || defined(_DEBUG) || defined(DBG)) && defined(CURRENT_MACHINE_TYPE)
        m_Context.ContextFlags = CONTEXT_CONTROL;
		GetThreadContext(GetCurrentThread(), &m_Context);
#endif
	}

	CError(
		DWORD nNum
		STAMP_DECL
	) :
		m_nNum(nNum),
		m_pText(0),
        m_bFree(false)
		STAMP_INIT
	{
#if (defined(DEBUG) || defined(_DEBUG) || defined(DBG)) && defined(CURRENT_MACHINE_TYPE)
        m_Context.ContextFlags = CONTEXT_CONTROL;
		GetThreadContext(GetCurrentThread(), &m_Context);
#endif
	}

    ~CError()
    {
        if (m_bFree) {
        
            LocalFree(m_pText);
        }
    }

    DWORD 
	Num() const 
	{
		return m_nNum;
	}

	PCTSTR 
	Text() const 
	{
        if (!m_pText) {

            m_pText = FormatMessageFromSystem(m_nNum);
            m_bFree = true;
        }

        return m_pText;
	}

    static
    void 
    AskDebugBreak()
    {
        if (MessageBox(
            0, 
            _T("Do you want to break into the debugger?"), 
            0, 
            MB_ICONQUESTION | MB_YESNO
        ) == IDYES) {

            DebugBreak();
        }
    }

#if (defined(DEBUG) || defined(_DEBUG) || defined(DBG)) && defined(CURRENT_MACHINE_TYPE) && defined(_IMAGEHLP_)

#define MAX_STACK_DEPTH   32
#define MAX_SYMBOL_LENGTH 256

    template <int N>
    struct CImagehlpSymbol : public IMAGEHLP_SYMBOL 
    {
        CImagehlpSymbol()
        {
            ZeroMemory(this, sizeof(*this));
            SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL);
            MaxNameLength = N;
        }

    private:
        CHAR NameData[N-1];
    };

    struct CImagehlpLine : public IMAGEHLP_LINE
    {
        CImagehlpLine()
        {
            ZeroMemory(this, sizeof(*this));
            SizeOfStruct = sizeof(IMAGEHLP_LINE);
        }
    };

    struct CImagehlpModule : public IMAGEHLP_MODULE
    {
        CImagehlpModule()
        {
            ZeroMemory(this, sizeof(*this));
            SizeOfStruct = sizeof(IMAGEHLP_MODULE);
        }
    };

    void DumpStack(FILE *fout = stdout) const
    {
        PCONTEXT pContext = &m_Context;
        HANDLE   hProcess = GetCurrentProcess();
        HANDLE   hThread  = GetCurrentThread();

        SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);
        SymInitialize(hProcess, 0, TRUE);

        STACKFRAME StackFrame = { 0 }; 

#if defined(_X86_)
        StackFrame.AddrPC.Offset       = pContext->Eip;
        StackFrame.AddrFrame.Offset    = pContext->Ebp;
        StackFrame.AddrStack.Offset    = pContext->Esp;
#elif defined(_MIPS_)
        StackFrame.AddrPC.Offset       = pContext->Fir;
        StackFrame.AddrFrame.Offset    = pContext->IntS6;
        StackFrame.AddrStack.Offset    = pContext->IntSp;
#elif defined(_ALPHA_)
        StackFrame.AddrPC.Offset       = pContext->Fir;
        StackFrame.AddrFrame.Offset    = pContext->IntFp;
        StackFrame.AddrStack.Offset    = pContext->IntSp;
#elif defined(_PPC_)
        StackFrame.AddrPC.Offset       = pContext->Iar;
        StackFrame.AddrFrame.Offset    = pContext->IntFp;
        StackFrame.AddrStack.Offset    = pContext->Gpr1;
#endif

        StackFrame.AddrPC.Mode         = AddrModeFlat;
        StackFrame.AddrFrame.Mode      = AddrModeFlat;
        StackFrame.AddrStack.Mode      = AddrModeFlat;

        for (
            int nStackWalkLevel = 0;
            nStackWalkLevel < MAX_STACK_DEPTH &&
            StackWalk(
                CURRENT_MACHINE_TYPE,
                hProcess,
                hThread,
                &StackFrame,                         
                pContext,                             
                0,  
                SymFunctionTableAccess,  
                SymGetModuleBase,              
                0
            );
            ++nStackWalkLevel
        ) {

            CImagehlpModule Module;
            SymGetModuleInfo(hProcess, StackFrame.AddrPC.Offset, &Module);

            DWORD dwDisplacement = 0;
            CImagehlpSymbol<MAX_SYMBOL_LENGTH> Symbol;
            SymGetSymFromAddr(hProcess, StackFrame.AddrPC.Offset, &dwDisplacement, &Symbol);

            CHAR szUnDSymbol[MAX_SYMBOL_LENGTH] = "";
            SymUnDName(&Symbol, szUnDSymbol, sizeof(szUnDSymbol));

            DWORD dwLineDisplacement = 0;
            CImagehlpLine Line;
            SymGetLineFromAddr(hProcess, StackFrame.AddrPC.Offset, &dwLineDisplacement, &Line);

            fprintf(
                fout,
                "%08x %08x %08x %08x %s!%s+0x%x (%s:%d)\n",
                StackFrame.Params[0],
                StackFrame.Params[1],
                StackFrame.Params[2],
                StackFrame.Params[3],
                Module.ModuleName,
                szUnDSymbol,
                dwDisplacement,
                Line.FileName, 
                Line.LineNumber
            );
        }

        SymCleanup(hProcess);
    }

#else
    
    void 
    DumpStack(PVOID pVoid = 0) const
    {
    }

#endif

	template <class F>
	int
	Print(F OutputFunction) const
	{
		OutputFunction(
			_T("Error 0x%08x: %s") ENDL STAMP_FORMAT, 
			Num(), 
			Text()
			STAMP_ARGS
		);

        return 1;
	}

#ifdef _IOSTREAM_

    friend std::ostream &operator <<(std::ostream &os, const CError &rhs)
    {
		return os <<
            _T("Error ") << rhs.Num() << _T(": ") << rhs.Text() 
            STAMP_IOS << std::endl;
    }

#endif //_IOSTREAM_

private:
	DWORD m_nNum;
	mutable PTSTR m_pText;
	mutable bool  m_bFree;
	STAMP_DEFINE;
};

#endif //RESULT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\stdafx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StdAfx.cpp

Abstract:

    Precompiled headers file

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\stolenids.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    StolenIds.h

Abstract:


Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _STOLENIDS_H_
#define _STOLENIDS_H_

//////////////////////////////////////////////////////////////////////////
//
// stolen ID's
//

#define IDD_CHOOSEWIADEVICE             3000
#define IDS_CAMERADLG_TITLE             4209
#define IDS_DIALOG_TITLE                4012
#define IDD_CAPTURE_DIALOG              5000
#define MessageTitle                    1
#define DeviceFriendlyName              102
#define IDS_OEMTITLE                    309
#define IDC_NDW_PICKDEV_HAVEDISK        1567
#define IDD_NEXT		                0x3024
#define IDD_FINISH		                0x3025
#define IDS_VIDDLG_BUSY_TITLE           5407
//bugbug: remove this when defined in wia.h
#define StiDeviceTypeStreamingVideo     3


#endif //_STOLENIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\testiwiadevmgr.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    TestIWiaDevMgr.cpp

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "stdafx.h"

#include "WiaStress.h"

#include "StolenIds.h"
#include "EventCallback.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestEnumDeviceInfo()
{
    LOG_INFO(_T("Testing EnumDeviceInfo()"));

    // test valid cases

    CComPtr<IEnumWIA_DEV_INFO> pEnumWIA_DEV_INFO;

    if (LOG_HR(m_pWiaDevMgr->EnumDeviceInfo(0, &pEnumWIA_DEV_INFO), == S_OK))
    {
        TestEnum(pEnumWIA_DEV_INFO, _T("EnumDeviceInfo"));
    }

    // test invalid cases

    if (m_bRunBadParamTests)
    {
        LOG_HR(m_pWiaDevMgr->EnumDeviceInfo(0, 0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestCreateDevice()
{
    CComPtr<IEnumWIA_DEV_INFO> pEnumWIA_DEV_INFO;

    CHECK_HR(m_pWiaDevMgr->EnumDeviceInfo(0, &pEnumWIA_DEV_INFO));

    ULONG nDevices;

    CHECK_HR(pEnumWIA_DEV_INFO->GetCount(&nDevices));

    FOR_SELECTED(i, nDevices)
    {
        CComPtr<CMyWiaPropertyStorage> pProp;

        CHECK_HR(pEnumWIA_DEV_INFO->Next(1, (IWiaPropertyStorage **) &pProp, 0));

        CPropVariant varDeviceID;

        CHECK_HR(pProp->ReadSingle(WIA_DIP_DEV_ID, &varDeviceID, VT_BSTR));

        LOG_INFO(_T("Testing CreateDevice() DeviceID=%ws"), varDeviceID.bstrVal);

        // test with valid parameters

        CComPtr<IWiaItem> pWiaRootItem;

        LOG_HR(m_pWiaDevMgr->CreateDevice(varDeviceID.bstrVal, &pWiaRootItem), == S_OK);

        // test with invalid parameters

        if (m_bRunBadParamTests)
        {
            LOG_HR(m_pWiaDevMgr->CreateDevice(varDeviceID.bstrVal, 0), != S_OK);
        }
    }

    // test with invalid parameters

    if (m_bRunBadParamTests)
    {
        CComPtr<IWiaItem> pWiaRootItem;

        LOG_HR(m_pWiaDevMgr->CreateDevice(0, &pWiaRootItem), != S_OK);

        LOG_HR(m_pWiaDevMgr->CreateDevice(0, 0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestSelectDeviceDlg()
{
    static FLAG_AND_NAME<LONG> AllDeviceTypes[] = 
    { 
        MAKE_FLAG_AND_NAME(StiDeviceTypeDefault),
        MAKE_FLAG_AND_NAME(StiDeviceTypeScanner),
        MAKE_FLAG_AND_NAME(StiDeviceTypeDigitalCamera),
        MAKE_FLAG_AND_NAME(StiDeviceTypeStreamingVideo)
    };

    static FLAG_AND_NAME<LONG> AllFlags[] = 
    { 
        MAKE_FLAG_AND_NAME(0),
        MAKE_FLAG_AND_NAME(WIA_SELECT_DEVICE_NODEFAULT)
    };

    static FLAG_AND_NAME<LONG> AllButtonIds[] = 
    { 
        MAKE_FLAG_AND_NAME(IDOK),
        MAKE_FLAG_AND_NAME(IDCANCEL)
    };

    static FLAG_AND_NAME<LONG> AllAPIs[] = 
    { 
        { 0, _T("SelectDeviceDlg") },
        { 1, _T("SelectDeviceDlgID") },
    };

    FOR_SELECTED(lDeviceType, COUNTOF(AllDeviceTypes))
    {
        FOR_SELECTED(lFlags, COUNTOF(AllFlags))
        {
            FOR_SELECTED(nButtonId, COUNTOF(AllButtonIds))
            {
                FOR_SELECTED(nAPI, COUNTOF(AllAPIs))
                {
		            LOG_INFO(
		                _T("Testing %s(), lDeviceType=%s, lFlags=%s, Push %s"),
                        AllAPIs[nAPI].pszName, 
                        AllDeviceTypes[lDeviceType].pszName, 
                        AllFlags[lFlags].pszName, 
                        AllButtonIds[nButtonId].pszName
                    );

                    SubTestSelectDeviceDlg(
                        AllDeviceTypes[lDeviceType].Value, 
                        AllFlags[lFlags].Value, 
                        AllButtonIds[nButtonId].Value,
                        AllAPIs[nButtonId].Value
                    );
                }
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void
CWiaStressThread::SubTestSelectDeviceDlg(
    LONG        lDeviceType,
    LONG        lFlags,
    LONG        nButtonId,
    BOOL        bGetIDOnly
)
{
    // read the (localizable) dialog name from the system DLL

    static TCHAR szSelectDeviceTitle[256];
    static LONG  bInitStrings = TRUE;
    
    if (bInitStrings)
    {
        CLibrary wiadefui_dll(_T("wiadefui.dll"), LOAD_LIBRARY_AS_DATAFILE);

        CDialogResource DlgFileProgress(
            wiadefui_dll, 
            MAKEINTRESOURCE(IDD_CHOOSEWIADEVICE)
        );

        USES_CONVERSION;

        lstrcpyn(
            szSelectDeviceTitle, 
            W2T(DlgFileProgress.title), 
            COUNTOF(szSelectDeviceTitle)
        );

        InterlockedExchange(&bInitStrings, FALSE);
    }


    // get the number of devices from the device manager

    CComPtr<IEnumWIA_DEV_INFO> pEnumWIA_DEV_INFO;

    CHECK_HR(m_pWiaDevMgr->EnumDeviceInfo(0, &pEnumWIA_DEV_INFO));

    ULONG nDevices = 0;
        
    CPropVariant varFirstDeviceID;

    if (lDeviceType == StiDeviceTypeDefault)
    {
        CHECK_HR(pEnumWIA_DEV_INFO->GetCount(&nDevices));

        if (nDevices > 0)
        {
            CComPtr<CMyWiaPropertyStorage> pProp;

            CHECK_HR(pEnumWIA_DEV_INFO->Next(1, (IWiaPropertyStorage **) &pProp, 0));

            CHECK_HR(pProp->ReadSingle(WIA_DIP_DEV_ID, &varFirstDeviceID, VT_BSTR));
        }
    }
    else
    {
        while (1)
        {
            CComPtr<CMyWiaPropertyStorage> pProp;

            HRESULT hr = pEnumWIA_DEV_INFO->Next(1, (IWiaPropertyStorage **) &pProp, 0);

            if (hr != S_OK)
            {
                break;
            }

            CPropVariant varDeviceType;

            CHECK_HR(pProp->ReadSingle(WIA_DIP_DEV_TYPE, &varDeviceType, VT_I4));

            if (GET_STIDEVICE_TYPE(varDeviceType.lVal) == lDeviceType)
            {
                ++nDevices;

                CHECK_HR(pProp->ReadSingle(WIA_DIP_DEV_ID, &varFirstDeviceID, VT_BSTR));
            }
        }
    }

    // we expect to see the dialog if there are more than one devices or
    // WIA_SELECT_DEVICE_NODEFAULT switch is set

    int nExpectedNumWindows = 
        nDevices > 1 || 
        ((nDevices == 1) && (lFlags & WIA_SELECT_DEVICE_NODEFAULT)) ? 1 : 0;


    // start the thread that'll push the button for us

    CPushDlgButton PushDlgButton(
        GetCurrentThreadId(), 
        szSelectDeviceTitle, 
        nButtonId
    );
    
    // open the select device dialog

    CComBSTR          bstrDeviceID;
    CComPtr<IWiaItem> pWiaItem;

    HRESULT hrAPI;

    if (bGetIDOnly)
    {
        hrAPI = m_pWiaDevMgr->SelectDeviceDlgID(
            0,
            lDeviceType,
            lFlags,
            &bstrDeviceID
        ); 
    }
    else
    {
        hrAPI = m_pWiaDevMgr->SelectDeviceDlg(
            0,
            lDeviceType,
            lFlags,
            &bstrDeviceID,
            &pWiaItem
        ); 
    }

    if (hrAPI == S_OK)
    {
        // when we press the <OK> button, the UI should select the first item

        if (wcssafecmp(bstrDeviceID, varFirstDeviceID.bstrVal) != 0) 
        {
            LOG_ERROR(
                _T("bstrDeviceID=%ws, expected %ws"),
                bstrDeviceID, 
                varFirstDeviceID.bstrVal 
            );
        }

        if (!bGetIDOnly && pWiaItem == 0) 
        {
            LOG_ERROR(_T("pWiaItem == 0, expected non-NULL when hr == S_OK"));
        }
    }
    else
    {
        if (bstrDeviceID.Length() != 0) 
        {
            LOG_ERROR(
                _T("bstrDeviceID == %ws, expected NULL when hr != S_OK"),
                bstrDeviceID
            );
        }

        if (!bGetIDOnly && pWiaItem != 0) 
        {
            LOG_ERROR(
                _T("pWiaItem == %p, expected NULL when hr != S_OK"),
                (IWiaItem *) pWiaItem
            );
        }
    }

    if (PushDlgButton.m_nMatchingWindows < nExpectedNumWindows) 
    {
        LOG_ERROR(_T("Select device dialog did not show up"));
    }   

    if (nDevices == 0)
    {
        LOG_HR(hrAPI, == WIA_S_NO_DEVICE_AVAILABLE);
    }

    if (nExpectedNumWindows > 0)
    {
        if (nButtonId == IDOK)
        {
            LOG_HR(hrAPI, == S_OK);
        }

        if (nButtonId == IDCANCEL)
        {
            LOG_HR(hrAPI, == S_FALSE);
        }

        // we expect to see only one matching button

        if (PushDlgButton.m_nMatchingButtons < 1)
        {
            LOG_ERROR(_T("No buttons with Id=%d"), (PCTSTR) ButtonIdToStr(nButtonId));
        }

        // number of listed items should equal the number of devices

        if (PushDlgButton.m_nListItems != nDevices)
        {
            LOG_ERROR(
                _T("ListedItems=%d, expected %d (from EnumDeviceInfo)"),
                PushDlgButton.m_nListItems,
                nDevices
            );
        }   
    }

    // bad param testing

    if (m_bRunBadParamTests)
    {
        if (bGetIDOnly)
        {
            LOG_HR(m_pWiaDevMgr->SelectDeviceDlgID(0, lDeviceType, lFlags, 0), != S_OK); 
        }
        else
        {
            bstrDeviceID.Empty();

            LOG_HR(m_pWiaDevMgr->SelectDeviceDlg(0, lDeviceType, lFlags, &bstrDeviceID, 0), != S_OK); 
        
            LOG_HR(m_pWiaDevMgr->SelectDeviceDlg(0, lDeviceType, lFlags, 0, 0), != S_OK); 
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestGetImageDlg()
{
    static FLAG_AND_NAME<LONG> AllDeviceTypes[] = 
    { 
        MAKE_FLAG_AND_NAME(StiDeviceTypeDefault),
        MAKE_FLAG_AND_NAME(StiDeviceTypeScanner),
        MAKE_FLAG_AND_NAME(StiDeviceTypeDigitalCamera),
        MAKE_FLAG_AND_NAME(StiDeviceTypeStreamingVideo)
    };

    static FLAG_AND_NAME<LONG> AllFlags[] = 
    { 
        MAKE_FLAG_AND_NAME(0),
        MAKE_FLAG_AND_NAME(WIA_SELECT_DEVICE_NODEFAULT)
    };

    FOR_SELECTED(lDeviceType, COUNTOF(AllDeviceTypes))
    {
        FOR_SELECTED(lFlags, COUNTOF(AllFlags))
        {
#if 0
            FOR_SELECTED(nButtonId, COUNTOF(AllButtonIds))
            {
                FOR_SELECTED(nAPI, COUNTOF(AllAPIs))
                {
		            LOG_INFO(
		                _T("Testing %s(), lDeviceType=%s, lFlags=%s, Push %s"),
                        AllAPIs[nAPI].pszName, 
                        AllDeviceTypes[lDeviceType].pszName, 
                        AllFlags[lFlags].pszName, 
                        AllButtonIds[nButtonId].pszName
                    );

                virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetImageDlg( 
                    /* [in] */ HWND hwndParent,
                    /* [in] */ LONG lDeviceType,
                    /* [in] */ LONG lFlags,
                    /* [in] */ LONG lIntent,
                    /* [in] */ IWiaItem __RPC_FAR *pItemRoot,
                    /* [in] */ BSTR bstrFilename,
                    /* [out][in] */ GUID __RPC_FAR *pguidFormat) = 0;
                }
            }
#endif 0
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestRegisterEventCallbackInterface()
{
	LOG_INFO(_T("Testing RegisterEventCallbackInterface()"));

    CEventCallback *pEventCallback = new CEventCallback;

    CHECK(pEventCallback != 0);

    CComQIPtr<IWiaEventCallback> pWiaEventCallback(pEventCallback);

    CComPtr<IUnknown> pEventObject;

    LOG_HR(m_pWiaDevMgr->RegisterEventCallbackInterface(
        WIA_REGISTER_EVENT_CALLBACK, 
        0, 
        &WIA_EVENT_DEVICE_CONNECTED, 
        pWiaEventCallback, 
        &pEventObject
    ), == S_OK);

    CComBSTR bstrDeviceId;

// bugbug:
    InstallTestDevice(
        m_pWiaDevMgr, 
        _T("\\\\hakkib2183\\cam\\testcam.inf"), 
        &bstrDeviceId
    );

    //bugbug: ****
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=WiaStress
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMTYPE=console
UMENTRYABS=ModuleEntry

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h

!undef USE_MSVCRT
USE_LIBCMT=1
USE_NATIVE_EH=1
USE_STL=1
USE_STATIC_ATL=1
ATL_VER=30

INCLUDES=..;..\..\y2k\inc;$(INCLUDES)

SOURCES= \
	..\CheckBmp.cpp \
	..\DataCallback.cpp \
	..\EventCallback.cpp \
	..\Globals.cpp \
	..\InstDev.cpp \
	..\TestIWiaDataTransfer.cpp \
	..\TestIWiaDevMgr.cpp \
	..\TestIWiaEnumXXX.cpp \
	..\TestIWiaItem.cpp \
	..\TestIWiaPropertyStorage.cpp \
	..\ToStr.cpp \
	..\WiaHelpers.cpp \
	..\WiaStress.rc \
	..\WiaStress.cpp \

TARGETLIBS= \
	$(TARGETLIBS) \
        $(SDK_LIB_PATH)\oldnames.lib \
        $(SDK_LIB_PATH)\ole32.lib    \
        $(SDK_LIB_PATH)\comctl32.lib \
        $(SDK_LIB_PATH)\setupapi.lib \
        $(SDK_LIB_PATH)\dbghelp.lib  \
        $(SDK_LIB_PATH)\wiaguid.lib  \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\testiwiadatatransfer.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    TestWiaDataTransfer.cpp

Abstract:

    Test routines for the WIA IWiaDataTransfer interface

Author:

    Hakki T. Bostanci (hakkib) 17-Dec-1999

Revision History:

--*/

#include "stdafx.h"

#include "WiaStress.h"

#include "DataCallback.h"
#include "CheckBmp.h"

//////////////////////////////////////////////////////////////////////////
//
// CWiaStressThread::TestGetData
//
// Routine Description:
//   tests IWiaDataTransfer::idtGetData and IWiaDataTransfer::idtGetBandedData
//
// Arguments:
//
// Return Value:
//

void CWiaStressThread::TestGetData(CWiaItemData *pItemData)
{
    if (!(pItemData->lItemType & (WiaItemTypeFile | WiaItemTypeImage)))
    {
        return;
    }

    // get the interface pointers

    CComQIPtr<IWiaDataTransfer> pWiaDataTransfer(pItemData->pWiaItem);

    CHECK(pWiaDataTransfer != 0);

    CComQIPtr<CMyWiaPropertyStorage, &IID_IWiaPropertyStorage> pProp(pItemData->pWiaItem);

    CHECK(pProp != 0);

    // transfer the data in basic formats

    CWiaFormatInfo MemoryBmp(&WiaImgFmt_MEMORYBMP, TYMED_CALLBACK);

    CWiaFormatInfo FileBmp(&WiaImgFmt_BMP, TYMED_FILE);

    SubTestGetData(MemoryBmp, pProp, pWiaDataTransfer, pItemData->bstrFullName);

    SubTestGetData(FileBmp, pProp, pWiaDataTransfer, pItemData->bstrFullName);

    if (!m_bBVTMode)
    {
        // get all available transfer formats

        CComPtr<IEnumWIA_FORMAT_INFO> pEnumWIA_FORMAT_INFO;

        CHECK_HR(pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pEnumWIA_FORMAT_INFO));

        ULONG nFormats = -1;

        CHECK_HR(pEnumWIA_FORMAT_INFO->GetCount(&nFormats));

        FOR_SELECTED(i, nFormats)
        {
            CWiaFormatInfo WiaFormatInfo;

            CHECK_HR(pEnumWIA_FORMAT_INFO->Next(1, &WiaFormatInfo, 0));

            if (WiaFormatInfo != MemoryBmp && WiaFormatInfo != FileBmp)
            {
                SubTestGetData(WiaFormatInfo, pProp, pWiaDataTransfer, pItemData->bstrFullName);
            }
        }
    }

    // test invalid cases

    // todo:
}

//////////////////////////////////////////////////////////////////////////
//
// CWiaStressThread::SubTestGetData
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//

void
CWiaStressThread::SubTestGetData(
    CWiaFormatInfo        &WiaFormatInfo,
    CMyWiaPropertyStorage *pProp,
    IWiaDataTransfer      *pWiaDataTransfer,
    BSTR                   bstrFullName
)
{
    // we don't want any other thread to mess with the image trasfer properties

    s_PropWriteCritSect.Enter();

    // set the image transfer properties

    CHECK_HR(pProp->WriteVerifySingle(WIA_IPA_FORMAT, WiaFormatInfo.guidFormatID));

    CHECK_HR(pProp->WriteVerifySingle(WIA_IPA_TYMED, WiaFormatInfo.lTymed));

    // transfer the item

    switch (WiaFormatInfo.lTymed)
    {
    case TYMED_CALLBACK:
    {
        FOR_SELECTED(bCreateSharedSection, 2)
        {
            FOR_SELECTED(bDoubleBuffered, 2)
            {
                LOG_INFO(
                    _T("Testing idtGetBandedData() on %ws, Format=%s, Tymed=%s, %s created section, %s buffered"),
                    bstrFullName,
                    (PCTSTR) GuidToStr(WiaFormatInfo.guidFormatID),
                    (PCTSTR) TymedToStr((TYMED) WiaFormatInfo.lTymed),
                    bCreateSharedSection ? _T("client") : _T("WIA"),
                    bDoubleBuffered ? _T("double") : _T("single")
                );

                // determine the transfer buffer size

                CPropVariant varBufferSize;

                HRESULT hr = pProp->ReadSingle(WIA_IPA_MIN_BUFFER_SIZE, &varBufferSize, VT_UI4);

                ULONG ulBufferSize = hr == S_OK ? varBufferSize.ulVal : 64*1024;

                // create the section

                CFileMapping Section(
                    INVALID_HANDLE_VALUE,
                    0,
                    PAGE_READWRITE,
                    0,
                    (bDoubleBuffered ? 2 * ulBufferSize : ulBufferSize)
                );

                ULONG ulSection = PtrToUlong((HANDLE)Section);

                // initiate the transfer

                CWiaDataTransferInfo WiaDataTransferInfo(
                    bCreateSharedSection ? ulSection : 0,
                    ulBufferSize,
                    bDoubleBuffered
                );

                CComPtr<CDataCallback> pDataCallback(new CDataCallback);

                CHECK(pDataCallback != 0);

                if (LOG_HR(pWiaDataTransfer->idtGetBandedData(&WiaDataTransferInfo, pDataCallback), == S_OK))
                {
                    // check the results if we understand the format

                    if (WiaFormatInfo.guidFormatID == WiaImgFmt_MEMORYBMP)
                    {
                        CheckBmp(
                            pDataCallback->m_pBuffer,
                            pDataCallback->m_lBufferSize,
                            TRUE
                        );
                    }
                    else if (WiaFormatInfo.guidFormatID == WiaImgFmt_BMP)
                    {
                        CheckBmp(
                            pDataCallback->m_pBuffer,
                            pDataCallback->m_lBufferSize,
                            TRUE //FALSE bug 123640
                        );
                    }
                    else if (WiaFormatInfo.guidFormatID == WiaImgFmt_JPEG)
                    {
                        // todo: write a jpeg checker
                    }
                    else if (WiaFormatInfo.guidFormatID == WiaImgFmt_TIFF)
                    {
                        // todo: write a tiff checker
                    }
                }

                LOG_CMP(pDataCallback->m_cRef, ==, 1);
            }
        }

        break;
    }

    case TYMED_FILE:
    {
        LOG_INFO(
            _T("Testing idtGetData() on %ws, Format=%s, Tymed=%s"),
            bstrFullName,
            (PCTSTR) GuidToStr(WiaFormatInfo.guidFormatID),
            (PCTSTR) TymedToStr((TYMED) WiaFormatInfo.lTymed)
        );

        CStgMedium StgMedium;

        StgMedium.tymed = TYMED_FILE;

        CComPtr<CDataCallback> pDataCallback(new CDataCallback);

        CHECK(pDataCallback != 0);

        if (LOG_HR(pWiaDataTransfer->idtGetData(&StgMedium, pDataCallback), == S_OK))
        {
            USES_CONVERSION;

            PCTSTR pszFileName = W2T(StgMedium.lpszFileName);

            // check the results if we understand the format

            if (WiaFormatInfo.guidFormatID == WiaImgFmt_BMP)
            {
                CheckBmp(pszFileName);
            }
            else if (WiaFormatInfo.guidFormatID == WiaImgFmt_JPEG)
            {
                // todo: write a jpeg checker
            }
            else if (WiaFormatInfo.guidFormatID == WiaImgFmt_TIFF)
            {
                // todo: write a tiff checker
            }

            DeleteFile(pszFileName);
        }

        LOG_CMP(pDataCallback->m_cRef, ==, 1);

        break;
    }

    default:
        OutputDebugStringF(_T("Unhandled tymed %s"), (PCTSTR) TymedToStr((TYMED) WiaFormatInfo.lTymed));
        ASSERT(FALSE);
        break;
    }

    s_PropWriteCritSect.Leave();
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestQueryData(CWiaItemData *pItemData)
{
    if (!(pItemData->lItemType & (WiaItemTypeImage | WiaItemTypeFile)))
    {
        return;
    }

    LOG_INFO(_T("Testing idtQueryData() on %ws"), pItemData->bstrFullName);

    CComQIPtr<IWiaDataTransfer> pWiaDataTransfer(pItemData->pWiaItem);

    CHECK(pWiaDataTransfer != 0);

    // these two should be supported by all devices

    LOG_HR(pWiaDataTransfer->idtQueryGetData(&CWiaFormatInfo(&WiaImgFmt_MEMORYBMP, TYMED_CALLBACK)), == S_OK);

    LOG_HR(pWiaDataTransfer->idtQueryGetData(&CWiaFormatInfo(&WiaImgFmt_BMP, TYMED_FILE)), == S_OK);

    // ask the device for the formats it supports and verify each format

    CComPtr<IEnumWIA_FORMAT_INFO> pEnumWIA_FORMAT_INFO;

    CHECK_HR(pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pEnumWIA_FORMAT_INFO));

    ULONG nFormats;

    CHECK_HR(pEnumWIA_FORMAT_INFO->GetCount(&nFormats));

    for (int i = 0; i < nFormats; ++i)
    {
        CWiaFormatInfo WiaFormatInfo;

        CHECK_HR(pEnumWIA_FORMAT_INFO->Next(1, &WiaFormatInfo, 0));

        LOG_HR(pWiaDataTransfer->idtQueryGetData(&WiaFormatInfo), == S_OK);
    }

    // test invalid cases

    if (m_bRunBadParamTests)
    {
        LOG_HR(pWiaDataTransfer->idtQueryGetData(&CWiaFormatInfo(&GUID_NULL, TYMED_FILE)), == E_INVALIDARG);

        LOG_HR(pWiaDataTransfer->idtQueryGetData(&CWiaFormatInfo(&WiaImgFmt_BMP, 0)), == DV_E_TYMED);

        LOG_HR(pWiaDataTransfer->idtQueryGetData(&CWiaFormatInfo(&GUID_NULL, 0)), == DV_E_TYMED);

        LOG_HR(pWiaDataTransfer->idtQueryGetData(0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestEnumWIA_FORMAT_INFO(CWiaItemData *pItemData)
{
    if (!(pItemData->lItemType & (WiaItemTypeImage | WiaItemTypeFile)))
    {
        return;
    }

    LOG_INFO(_T("Testing idtEnumWIA_FORMAT_INFO() on %ws"), pItemData->bstrFullName);

    CComQIPtr<IWiaDataTransfer> pWiaDataTransfer(pItemData->pWiaItem);

    CHECK(pWiaDataTransfer != 0);

    // test valid cases

    CComPtr<IEnumWIA_FORMAT_INFO> pEnumWIA_FORMAT_INFO;

    if (LOG_HR(pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pEnumWIA_FORMAT_INFO), == S_OK))
    {
        TestEnum(pEnumWIA_FORMAT_INFO, _T("idtEnumWIA_FORMAT_INFO"));
    }

    // test invalid cases

    if (m_bRunBadParamTests)
    {
        LOG_HR(pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(0), != S_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\testiwiaenumxxx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    TestIWiaEnumXXX.cpp

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "stdafx.h"

//
// This is not a real .cpp module, it is meant to be included in .h
//

#ifdef DEFINE_TEMPLATES

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class> struct storage_traits { };

template <> struct storage_traits<CComPtr<IEnumWIA_DEV_INFO> >    { typedef CIWiaPropertyStoragePtr storage_type; };
template <> struct storage_traits<CComPtr<IEnumWIA_DEV_CAPS> >    { typedef CWiaDevCap              storage_type; };
template <> struct storage_traits<CComPtr<IEnumWIA_FORMAT_INFO> > { typedef CWiaFormatInfo          storage_type; };
template <> struct storage_traits<CComPtr<IEnumWiaItem> >         { typedef CIWiaItemPtr            storage_type; };
template <> struct storage_traits<CComPtr<CMyEnumSTATPROPSTG> >   { typedef CStatPropStg            storage_type; };

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class interface_type>
void TestEnum(interface_type &pEnum, PCTSTR pInterfaceName)
{
    m_pszContext = pInterfaceName;

    TestGetCount(pEnum);
    TestReset(pEnum);
    TestNext(pEnum);
    TestSkip(pEnum);
    TestClone(pEnum);

    m_pszContext = 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class interface_type>
void TestNext(interface_type &pEnum)
{
    typedef storage_traits<interface_type>::storage_type storage_type;

    ULONG nItems = -1;

    CHECK_HR(pEnum->GetCount(&nItems));

    if (nItems == 0)
    {
        return;
    }

    // try to get items; first, last, all, one more than all, past the last

    SubTestNext(pEnum, 0, 1, 1, S_OK);

    SubTestNext(pEnum, nItems-1, 1, 1, S_OK);

    SubTestNext(pEnum, 0, nItems, nItems, S_OK);

    SubTestNext(pEnum, 0, nItems+1, nItems, S_FALSE);

    SubTestNext(pEnum, nItems-1, 2, 1, S_FALSE);

    //SubTestNext(pEnum, nItems, 1, 0, S_FALSE);

    //SubTestNext(pEnum, 0, nItems, UINT_MAX, nItems);

    // try to pass 0 for celtFetched, 
    // this should be allowed when fetching one item 

    CHECK_HR(pEnum->Reset());

    CCppMem<storage_type> pOneItem(1);

    LOG_HR(pEnum->Next(1, &pOneItem[0], 0), == S_OK);

    if (m_bRunBadParamTests)
    {
        // try to pass 0 for celtFetched, 
        // this should not be allowed when fetching more than one item 

        CHECK_HR(pEnum->Reset());

        CCppMem<storage_type> pTwoItems(2);

        LOG_HR(pEnum->Next(2, &pTwoItems[0], 0), != S_OK);

        // try to pass 0 for the element array
        // this should not be allowed

        CHECK_HR(pEnum->Reset());

        ULONG nFetched = -1;

        LOG_HR(pEnum->Next(0, 0, &nFetched), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class interface_type>
void 
SubTestNext(
    interface_type &pEnum, 
    ULONG           nToBeSkipped, 
    ULONG           nAskedToBeFetched, 
    ULONG           nExpectedToBeFetched, 
    HRESULT         hrExpected
)
{
    typedef storage_traits<interface_type>::storage_type storage_type;

    CHECK_HR(pEnum->Reset());

    if (nToBeSkipped)
    {
        CHECK_HR(pEnum->Skip(nToBeSkipped));
    }

    CCppMem<storage_type> pItems(nAskedToBeFetched);
    ULONG                 nFetched = -1;

    HRESULT hrAPI = pEnum->Next(nAskedToBeFetched, &pItems[0], &nFetched);

    if (hrAPI != hrExpected)
    {
        LOG_ERROR(
            _T("pEnum->Next(%d, &pItems[0], &nFetched) == %s, expected %s"),
            nAskedToBeFetched,
            (PCTSTR) HResultToStr(hrAPI),
            (PCTSTR) HResultToStr(hrExpected)
        );
    }

    LOG_CMP(nFetched, ==, nExpectedToBeFetched);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class interface_type>
void TestReset(interface_type &pEnum)
{
    typedef storage_traits<interface_type>::storage_type storage_type;

    ULONG nItems = -1;

    CHECK_HR(pEnum->GetCount(&nItems));

    if (nItems == 0)
    {
        return;
    }

    // reset and read the first element

    CHECK_HR(pEnum->Reset());

    if (!m_bBVTMode)
    {
        storage_type FirstItemBeforeQueryingAll;
        CHECK_HR(pEnum->Next(1, &FirstItemBeforeQueryingAll, 0));

        // go to the last item

        HRESULT hr;

        do 
        {
            storage_type Item;
            hr = pEnum->Next(1, &Item, 0);
        } 
        while (hr == S_OK);

        // reset the enumerator and read the first element again

        CHECK_HR(pEnum->Reset());

        storage_type FirstItemAfterQueryingAll;
        CHECK_HR(pEnum->Next(1, &FirstItemAfterQueryingAll, 0));

        if (FirstItemBeforeQueryingAll != FirstItemAfterQueryingAll) 
        {
            LOG_ERROR(_T("FirstItemBeforeQueryingAll != FirstItemAfterQueryingAll"));
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class interface_type>
void TestSkip(interface_type &pEnum)
{
    typedef storage_traits<interface_type>::storage_type storage_type;

    // get the item count

    ULONG nItems = -1;

    CHECK_HR(pEnum->GetCount(&nItems));

    if (nItems == 0)
    {
        return;
    }

    // read and store each item

    CHECK_HR(pEnum->Reset());

    CCppMem<storage_type> pItems(nItems);

    for (int i = 0; i < nItems; ++i)
    {
        CHECK_HR(pEnum->Next(1, &pItems[i], 0));
    }

    // test valid cases

    for (int nToBeSkipped = 0; nToBeSkipped < nItems; ++nToBeSkipped)
    {
        CHECK_HR(pEnum->Reset());

        for (int nItem = nToBeSkipped; nItem < nItems; nItem += nToBeSkipped + 1) 
        {
            CHECK_HR(pEnum->Skip(nToBeSkipped));

            storage_type Item;

            CHECK_HR(pEnum->Next(1, &Item, 0));

            if (Item != pItems[nItem])
            {
	            LOG_ERROR(_T("Item != pItems[nItem] after skipping %d"), nToBeSkipped);
            }
        }
    }

    // test invalid cases

    if (m_bRunBadParamTests)
    {
        CHECK_HR(pEnum->Reset());

        LOG_HR(pEnum->Skip(nItems+1), == S_FALSE);

        CHECK_HR(pEnum->Reset());

        LOG_HR(pEnum->Skip(-1), == S_FALSE);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class interface_type>
void TestClone(interface_type &pEnum, bool bRecurse = true)
{
    typedef storage_traits<interface_type>::storage_type storage_type;

    // make the clone

    interface_type pClone;
    
    if (LOG_HR(pEnum->Clone(&pClone), == S_OK) && !m_bBVTMode)
    {
        // reset both the original and the clone enumerators, then iterate 
        // through each element one by one and compare them

        CHECK_HR(pEnum->Reset());

        CHECK_HR(pClone->Reset());

        HRESULT hr, hr1, hr2;

        while (1)
        {
            // also, make a clone of the current state and check that 
            // the state is captured in the clone

            interface_type pClone2;
            CHECK_HR(pEnum->Clone(&pClone2));

            // get the next item from the original interface

            storage_type Item;

            hr = pEnum->Next(1, &Item, 0);

            // get the next item from the first clone

            storage_type Item1;

            hr1 = pClone->Next(1, &Item1, 0);

            // get the next item from the second clone

            storage_type Item2;

            hr2 = pClone2->Next(1, &Item2, 0);

            if (hr != S_OK || hr1 != S_OK || hr2 != S_OK)
            {
                break;
            }

            if (Item != Item1 || Item1 != Item2)
            {
    		    LOG_ERROR(_T("Clone states are not equal"));
            }
        } 

        if (hr != S_FALSE || hr1 != S_FALSE || hr2 != S_FALSE)
        {
		    LOG_ERROR(_T("After enumeration, clone states are not equal"));
        }

        // test the clone

        TestNext(pClone);

        TestReset(pClone);

        TestSkip(pClone);

        if (bRecurse)
        {
            TestClone(pClone, false);
        }

        TestGetCount(pClone);
    }

    // test bad param

    if (m_bRunBadParamTests)
    {
        LOG_HR(pEnum->Clone(0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class interface_type>
void TestGetCount(interface_type &pEnum)
{
    typedef storage_traits<interface_type>::storage_type storage_type;

    // First, get the item count using GetCount()

    ULONG cItemsFromGetCount = 0;

    if (LOG_HR(pEnum->GetCount(&cItemsFromGetCount), == S_OK) && !m_bBVTMode)
    {
        // Now, find the item count by first resetting the enumerator 
        // and then querying for each item one by one using Next()

        ULONG cItemsFromNext = 0;

        CHECK_HR(pEnum->Reset());

        HRESULT hr;

        do 
        {
            // verify that GetCount returns the same result after a Next or Reset

            ULONG cItemsFromGetCountNow = 0;

            LOG_HR(pEnum->GetCount(&cItemsFromGetCountNow), == S_OK);

            LOG_CMP(cItemsFromGetCountNow, ==, cItemsFromGetCount);

            // get the next item

            storage_type Item;
            ULONG        cFetched = 0;

            hr = pEnum->Next(1, &Item, &cFetched);

            cItemsFromNext += cFetched;
        } 
        while (hr == S_OK);

        LOG_HR(hr, == S_FALSE);

        // verify that the two counts are equal

        LOG_CMP(cItemsFromNext, ==, cItemsFromGetCount);
    }

    // test bad param

    if (m_bRunBadParamTests)
    {
        LOG_HR(pEnum->GetCount(0), != S_OK);
    }
}

#endif //DEFINE_TEMPLATES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\testiwiapropertystorage.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    TestIWiaPropertyStorage.cpp

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "stdafx.h"

#ifdef DEFINE_TEMPLATES

template <class T, class U>
void 
SubTestValidValuesRange(
    CMyWiaPropertyStorage *pProp, 
    const CPropSpec       &rPropSpec, 
    VARTYPE                vt, 
    T                     &Range, 
    U                     &CurrentValue,
    BOOL                   bReadOnly
)
{
    if (LOG_CMP(Range.cElems, ==, WIA_RANGE_NUM_ELEMS))
    {
        // minimum value must be lower than the maximum value

        LOG_CMP(Range.pElems[WIA_RANGE_MIN], <, Range.pElems[WIA_RANGE_MAX]);

        // nominal value must be in the given range

        LOG_CMP(Range.pElems[WIA_RANGE_NOM], >=, Range.pElems[WIA_RANGE_MIN]);
        LOG_CMP(Range.pElems[WIA_RANGE_NOM], <=, Range.pElems[WIA_RANGE_MAX]);

        // current value must be in the given range

        LOG_CMP(CurrentValue, >=, Range.pElems[WIA_RANGE_MIN]);
        LOG_CMP(CurrentValue, <=, Range.pElems[WIA_RANGE_MAX]);

        // the step must be greater than zero

        LOG_CMP(Range.pElems[WIA_RANGE_STEP], >, 0);

        // skip changing values if another thread is in image transfer mode

        if (!bReadOnly && s_PropWriteCritSect.TryEnter())
        {
            // try to write the min, max, nom values and a random value

            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Range.pElems[WIA_RANGE_MIN])
            ), == S_OK);

            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Range.pElems[WIA_RANGE_MAX])
            ), == S_OK);
       
            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Range.pElems[WIA_RANGE_NOM])
            ), == S_OK);
       
            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Range.pElems[WIA_RANGE_MIN] + Range.pElems[WIA_RANGE_STEP])
            ), == S_OK);
       
            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Range.pElems[WIA_RANGE_MAX] - Range.pElems[WIA_RANGE_STEP])
            ), == S_OK);
       
            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Range.pElems[WIA_RANGE_MIN] - Range.pElems[WIA_RANGE_STEP])
            ), != S_OK);
       
            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Range.pElems[WIA_RANGE_MAX] + Range.pElems[WIA_RANGE_STEP])
            ), != S_OK);

            if (Range.pElems[WIA_RANGE_STEP] > 1)
            {
                LOG_HR(pProp->WriteVerifySingle(
                    rPropSpec, 
                    CPropVariant(Range.pElems[WIA_RANGE_MIN] + 1)
                ), != S_OK);
       
                LOG_HR(pProp->WriteVerifySingle(
                    rPropSpec, 
                    CPropVariant(Range.pElems[WIA_RANGE_MAX] - 1)
                ), != S_OK);
            }
       
            // write back the current value

            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(CurrentValue)
            ), == S_OK);

            s_PropWriteCritSect.Leave();
        }
    }
}

template <class T, class U>
void 
SubTestValidValuesList(
    CMyWiaPropertyStorage *pProp, 
    const CPropSpec       &rPropSpec, 
    VARTYPE                vt, 
    T                     &List, 
    U                     &CurrentValue,
    BOOL                   bReadOnly
)
{
    if (LOG_CMP(List.cElems, >=, WIA_LIST_NUM_ELEMS))
    {
        // compare WIA_LIST_COUNT entry against the value we expect

        ULONG ulNumValues = List.cElems - WIA_LIST_NUM_ELEMS;

        //LOG_CMP((ULONG) List.pElems[WIA_LIST_COUNT], ==, ulNumValues);

        // search the list for any duplicates and find the indices of
        // the nominal value and the current value

        ULONG nNomIndex = -1;
        ULONG nCurIndex = -1;

        for (int i = WIA_LIST_VALUES; i < ulNumValues + WIA_LIST_VALUES; ++i)
        {
            for (int j = i + 1; j < ulNumValues + WIA_LIST_VALUES; ++j)
            {
                LOG_CMP(List.pElems[i], !=, List.pElems[j]);
            }

            if (IsEqual(List.pElems[i], List.pElems[WIA_LIST_NOM]))
            {
                nNomIndex = i;
            }            

            if (IsEqual(List.pElems[i], CurrentValue))
            {
                nCurIndex = i;
            }
        }

        // the nominal value must be one of the legal values

        if (nNomIndex == -1)
        {
            LOG_ERROR(
                _T("List.pElems[WIA_LIST_NOM] == (%s) %s not found in list"), 
                (PCTSTR) VarTypeToStr(vt),
                (PCTSTR) ToStr((PVOID) &List.pElems[WIA_LIST_NOM], vt)
            );
        }

        // the current value must be set to one of the legal values

        if (nCurIndex == -1)
        {
            LOG_ERROR(
                _T("Current value == (%s) %s not found in list"), 
                (PCTSTR) VarTypeToStr(vt),
                (PCTSTR) ToStr((PVOID) &CurrentValue, vt)
            );
        }

        // skip changing values if another thread is in image transfer mode

        if (!bReadOnly && s_PropWriteCritSect.TryEnter())
        {
            // try to write each property in the list

            for (int j = WIA_LIST_VALUES; j < ulNumValues + WIA_LIST_VALUES; ++j)
            {
                LOG_HR(pProp->WriteVerifySingle(
                    rPropSpec, 
                    CPropVariant(List.pElems[j])
                ), == S_OK);
            }
       
            // write back the current value

            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(CurrentValue)
            ), == S_OK);

            s_PropWriteCritSect.Leave();
        }
    }
}

template <class T, class U>
void 
SubTestValidValuesFlags(
    CMyWiaPropertyStorage *pProp, 
    const CPropSpec       &rPropSpec, 
    VARTYPE                vt, 
    T                     &Flags, 
    U                     &CurrentValue,
    BOOL                   bReadOnly
)
{
    if (LOG_CMP(Flags.cElems, ==, WIA_FLAG_NUM_ELEMS))
    {
        // the nominal and current values should have no unallowed bits set

        LOG_CMP(Flags.pElems[WIA_FLAG_NOM] & ~Flags.pElems[WIA_FLAG_VALUES], ==, 0);

        LOG_CMP(CurrentValue & ~Flags.pElems[WIA_FLAG_VALUES], ==, 0);

        // skip changing values if another thread is in image transfer mode

        if (!bReadOnly && s_PropWriteCritSect.TryEnter())
        {
            // try to write all allowed flags, no flags

            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(Flags.pElems[WIA_FLAG_VALUES])
            ), == S_OK);

            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(0)
            ), == S_OK);
       
            if (~Flags.pElems[WIA_FLAG_VALUES] != 0)
            {
                LOG_HR(pProp->WriteVerifySingle(
                    rPropSpec, 
                    CPropVariant(~Flags.pElems[WIA_FLAG_VALUES])
                ), != S_OK);
            }

            // write back the current value

            LOG_HR(pProp->WriteVerifySingle(
                rPropSpec, 
                CPropVariant(CurrentValue)
            ), == S_OK);

            s_PropWriteCritSect.Leave();
        }
    }
}
   
#else //DEFINE_TEMPLATES

#include "WiaStress.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

void 
CWiaStressThread::TestValidValuesRange(
    CMyWiaPropertyStorage *pProp, 
    const CPropSpec       &rPropSpec, 
    CPropVariant          &varRange, 
    CPropVariant          &varValue,
    BOOL                   bReadOnly
)
{
    switch (varRange.vt) 
    {
    case VT_VECTOR | VT_I1:  
        SubTestValidValuesRange(pProp, rPropSpec, VT_I1, varRange.cac, varValue.cVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_UI1: 
        SubTestValidValuesRange(pProp, rPropSpec, VT_UI1, varRange.caub, varValue.bVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_I2:  
        SubTestValidValuesRange(pProp, rPropSpec, VT_I2, varRange.cai, varValue.iVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_UI2: 
        SubTestValidValuesRange(pProp, rPropSpec, VT_UI2, varRange.caui, varValue.uiVal, bReadOnly);  
        break;

    case VT_VECTOR | VT_I4:  
        SubTestValidValuesRange(pProp, rPropSpec, VT_I4, varRange.cal, varValue.lVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_UI4: 
        SubTestValidValuesRange(pProp, rPropSpec, VT_UI4, varRange.caul, varValue.ulVal, bReadOnly);  
        break;

    case VT_VECTOR | VT_R4:  
        SubTestValidValuesRange(pProp, rPropSpec, VT_R4, varRange.caflt, varValue.fltVal, bReadOnly); 
        break;

    case VT_VECTOR | VT_R8:  
        SubTestValidValuesRange(pProp, rPropSpec, VT_R8, varRange.cadbl, varValue.dblVal, bReadOnly); 
        break;

    default: 
        LOG_ERROR(_T("Illegal values type %d for WIA_PROP_RANGE"), varValue.vt);
        break;
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void 
CWiaStressThread::TestValidValuesList(
    CMyWiaPropertyStorage *pProp, 
    const CPropSpec       &rPropSpec, 
    CPropVariant          &varList, 
    CPropVariant          &varValue, 
    BOOL                   bReadOnly
)
{
    switch (varList.vt) 
    {
    case VT_VECTOR | VT_I1:     
        SubTestValidValuesList(pProp, rPropSpec, VT_I1, varList.cac, varValue.cVal, bReadOnly);
        break;

    case VT_VECTOR | VT_UI1:    
        SubTestValidValuesList(pProp, rPropSpec, VT_UI1, varList.caub, varValue.bVal, bReadOnly);          
        break;

    case VT_VECTOR | VT_I2:     
        SubTestValidValuesList(pProp, rPropSpec, VT_I2, varList.cai, varValue.iVal, bReadOnly);          
        break;

    case VT_VECTOR | VT_UI2:    
        SubTestValidValuesList(pProp, rPropSpec, VT_UI2, varList.caui, varValue.uiVal, bReadOnly);         
        break;

    case VT_VECTOR | VT_I4:     
        SubTestValidValuesList(pProp, rPropSpec, VT_I4, varList.cal, varValue.lVal, bReadOnly);          
        break;

    case VT_VECTOR | VT_UI4:    
        SubTestValidValuesList(pProp, rPropSpec, VT_UI4, varList.caul, varValue.ulVal, bReadOnly);         
        break;

    case VT_VECTOR | VT_R4:     
        SubTestValidValuesList(pProp, rPropSpec, VT_R4, varList.caflt, varValue.fltVal, bReadOnly);        
        break;

    case VT_VECTOR | VT_R8:     
        SubTestValidValuesList(pProp, rPropSpec, VT_R8, varList.cadbl, varValue.dblVal, bReadOnly);        
        break;

    case VT_VECTOR | VT_BSTR:   
        SubTestValidValuesList(pProp, rPropSpec, VT_BSTR, varList.cabstr, varValue.bstrVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_LPSTR:  
        SubTestValidValuesList(pProp, rPropSpec, VT_LPSTR, varList.calpstr, varValue.pszVal, bReadOnly);    
        break;

    case VT_VECTOR | VT_LPWSTR: 
        SubTestValidValuesList(pProp, rPropSpec, VT_LPWSTR, varList.calpwstr, varValue.pwszVal, bReadOnly); 
        break;

    case VT_VECTOR | VT_CLSID:  
        SubTestValidValuesList(pProp, rPropSpec, VT_CLSID, varList.cauuid, *varValue.puuid, bReadOnly);        
        break;

    default:
        LOG_ERROR(_T("Illegal values type %d for WIA_PROP_LIST"), varValue.vt);
        break;
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void 
CWiaStressThread::TestValidValuesFlags(
    CMyWiaPropertyStorage *pProp, 
    const CPropSpec       &rPropSpec, 
    CPropVariant          &varFlags, 
    CPropVariant          &varValue, 
    BOOL                   bReadOnly
)
{
    switch (varFlags.vt) 
    {
    case VT_VECTOR | VT_I1:  
        SubTestValidValuesFlags(pProp, rPropSpec, VT_I1, varFlags.cac, varValue.cVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_UI1: 
        SubTestValidValuesFlags(pProp, rPropSpec, VT_UI1, varFlags.caub, varValue.bVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_I2:  
        SubTestValidValuesFlags(pProp, rPropSpec, VT_I2, varFlags.cai, varValue.iVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_UI2: 
        SubTestValidValuesFlags(pProp, rPropSpec, VT_UI2, varFlags.caui, varValue.uiVal, bReadOnly);  
        break;

    case VT_VECTOR | VT_I4:  
        SubTestValidValuesFlags(pProp, rPropSpec, VT_I4, varFlags.cal, varValue.lVal, bReadOnly);   
        break;

    case VT_VECTOR | VT_UI4: 
        SubTestValidValuesFlags(pProp, rPropSpec, VT_UI4, varFlags.caul, varValue.ulVal, bReadOnly);  
        break;

    default: 
        LOG_ERROR(_T("Illegal values type %d for WIA_PROP_FLAG"), varFlags.vt);
        break;
    }
}

//////////////////////////////////////////////////////////////////////////
//
// test GetPropertyAttributes, ReadMultiple, WriteMultiple
//

void CWiaStressThread::TestPropStorage(CWiaItemData *pItemData)
{
    LOG_INFO(_T("Testing IWiaPropertyStorage on %ws"), pItemData->bstrFullName);

    CComQIPtr<CMyWiaPropertyStorage, &IID_IWiaPropertyStorage> pProp(pItemData->pWiaItem);

    CComPtr<CMyEnumSTATPROPSTG> pEnumSTATPROPSTG;

    CHECK_HR(pProp->Enum((IEnumSTATPROPSTG **) &pEnumSTATPROPSTG));

    // find the number of properties

    ULONG ulNumProps = -1;

    CHECK_HR(pProp->GetCount(&ulNumProps));

    if (ulNumProps == 0)
    {
        return;
    }

    // read the property names

    CCppMem<CStatPropStg> pStatPropStg(ulNumProps);

    ULONG celtFetched = -1;

    CHECK_HR(pEnumSTATPROPSTG->Next(ulNumProps, pStatPropStg, &celtFetched));

    // 

    CCppMem<CPropSpec> pPropSpec(ulNumProps);

    for (int i = 0; i < ulNumProps; ++i)
    {
        if (rand() % 8 < 4) // bugbug: cover all str, all propid and mixed cases...
        {
            pPropSpec[i] = pStatPropStg[i].lpwstrName;
        }
        else
        {
            pPropSpec[i] = pStatPropStg[i].propid;
        }
    }

    // 

    CPropSpec InvalidPropSpec = L"invalid property name";

    // 

    CCppMem<ULONG>        pulAccessRights(ulNumProps);
    CCppMem<CPropVariant> pvarValidValues(ulNumProps);

    if (LOG_HR(pProp->GetPropertyAttributes(ulNumProps, pPropSpec, pulAccessRights, pvarValidValues), == S_OK))
    {
        CCppMem<CPropVariant> pvarValue(ulNumProps);

        if (LOG_HR(pProp->ReadMultiple(ulNumProps, pPropSpec, pvarValue), == S_OK))
        {
            FOR_SELECTED(i, ulNumProps)
            {
                USES_CONVERSION;
                m_pszContext = W2T(pStatPropStg[i].lpwstrName);

                // examine R/W rights and legal values separately

                ULONG ulReadWriteRights = 
                    pulAccessRights[i] & (WIA_PROP_READ | WIA_PROP_WRITE);

                ULONG ulLegalValues = 
                    pulAccessRights[i] & (WIA_PROP_NONE | WIA_PROP_RANGE | WIA_PROP_LIST | WIA_PROP_FLAG);

                // at least one of the R/W rights should be set

                if (ulReadWriteRights == 0)
                {
                    LOG_ERROR(_T("WIA_PROP_READ and/or WIA_PROP_WRITE should be specified"));
                }

                // if this is a read only item, a list of legal values is not necessary

                BOOL bReadOnly = !(ulReadWriteRights & WIA_PROP_WRITE);

                // check that the type of the returned value is the same as the advertised

                LOG_CMP(pvarValue[i].vt, ==, pStatPropStg[i].vt);

                // check that the type of the legal values are the same as the advertised

                if (ulLegalValues != WIA_PROP_NONE)
                {
                    LOG_CMP(pvarValidValues[i].vt, ==, VT_VECTOR | pStatPropStg[i].vt);
                }

                switch (ulLegalValues)
                {
                case WIA_PROP_NONE:
                    break;

                case WIA_PROP_RANGE:
                    TestValidValuesRange(pProp, pPropSpec[i], pvarValidValues[i], pvarValue[i], bReadOnly);
                    break;

                case WIA_PROP_LIST:
                    TestValidValuesList(pProp, pPropSpec[i], pvarValidValues[i], pvarValue[i], bReadOnly);
                    break;

                case WIA_PROP_FLAG:
                    TestValidValuesFlags(pProp, pPropSpec[i], pvarValidValues[i], pvarValue[i], bReadOnly);
                    break;

                default:
                    LOG_ERROR(_T("Unrecognized legal values flag 0x%p"), ulLegalValues);
                    break;
                }

                m_pszContext = 0;
            }
        }

        // bad parameter tests for ReadMultiple

        if (m_bRunBadParamTests)
        {
            // pass NULL propspecs

            FreePropVariantArray(ulNumProps, pvarValue);

            LOG_HR(pProp->ReadMultiple(ulNumProps, 0, pvarValue), != S_OK);

            for (i = 0; i < ulNumProps; ++i)
            {
                LOG_CMP(pvarValue[i].vt, ==, VT_EMPTY);
            }

           // pass invalid propspec

            FreePropVariantArray(ulNumProps, pvarValue);

            LOG_HR(pProp->ReadMultiple(1, &InvalidPropSpec, pvarValue), != S_OK);

            for (i = 0; i < ulNumProps; ++i)
            {
                LOG_CMP(pvarValue[i].vt, ==, VT_EMPTY);
            }

            // pass NULL pvarValue

            LOG_HR(pProp->ReadMultiple(ulNumProps, pPropSpec, 0), != S_OK);

            for (i = 0; i < ulNumProps; ++i)
            {
                LOG_CMP(pvarValue[i].vt, ==, VT_EMPTY);
            }


            // bad parameter test for WriteMultiple

            FreePropVariantArray(ulNumProps, pvarValue);

            // pass NULL propspecs

            LOG_HR(pProp->WriteMultiple(ulNumProps, 0, pvarValue, WIA_IPA_FIRST), != S_OK);

            // pass NULL pvarValue

            LOG_HR(pProp->WriteMultiple(ulNumProps, pPropSpec, 0, WIA_IPA_FIRST), != S_OK);
        }
    }

    // bad parameter tests for GetPropertyAttributes

    if (m_bRunBadParamTests)
    {
        // try to read 0 properties

        FreePropVariantArray(ulNumProps, pvarValidValues);

        LOG_HR(pProp->GetPropertyAttributes(0, pPropSpec, pulAccessRights, pvarValidValues), == S_FALSE);

        for (i = 0; i < ulNumProps; ++i)
        {
            LOG_CMP(pvarValidValues[i].vt, ==, VT_EMPTY);
        }

        // pass NULL propspecs

        FreePropVariantArray(ulNumProps, pvarValidValues);

        LOG_HR(pProp->GetPropertyAttributes(ulNumProps, 0, pulAccessRights, pvarValidValues), != S_OK);

        for (i = 0; i < ulNumProps; ++i)
        {
            LOG_CMP(pvarValidValues[i].vt, ==, VT_EMPTY);
        }

        // pass invalid propspec

        FreePropVariantArray(ulNumProps, pvarValidValues);

        LOG_HR(pProp->GetPropertyAttributes(1, &InvalidPropSpec, pulAccessRights, pvarValidValues), == S_FALSE);

        for (i = 0; i < ulNumProps; ++i)
        {
            LOG_CMP(pvarValidValues[i].vt, ==, VT_EMPTY);
        }

        // pass NULL access rights array

        FreePropVariantArray(ulNumProps, pvarValidValues);

        LOG_HR(pProp->GetPropertyAttributes(ulNumProps, pPropSpec, 0, pvarValidValues), != S_OK);

        for (i = 0; i < ulNumProps; ++i)
        {
            LOG_CMP(pvarValidValues[i].vt, ==, VT_EMPTY);
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CWiaStressThread::TestPropGetCount(CWiaItemData *pItemData)
{
    LOG_INFO(_T("Testing GetCount() on %ws"), pItemData->bstrFullName);

    CComQIPtr<IWiaPropertyStorage> pProp(pItemData->pWiaItem);

    CHECK(pProp != 0);

    CComPtr<IEnumSTATPROPSTG> pEnum;

    CHECK_HR(pProp->Enum(&pEnum));

    // First, get the item count using GetCount()

    ULONG cItemsFromGetCount = 0;

    if (LOG_HR(pProp->GetCount(&cItemsFromGetCount), == S_OK))
    {
        // Now, find the item count by first resetting the enumerator 
        // and then querying for each item one by one using Next()

        ULONG cItemsFromNext = 0;

        CHECK_HR(pEnum->Reset());

        HRESULT hr;

        do 
        {
            // verify that GetCount returns the same result after a Next or Reset

            ULONG cItemsFromGetCountNow = 0;

            LOG_HR(pProp->GetCount(&cItemsFromGetCountNow), == S_OK);

            LOG_CMP(cItemsFromGetCountNow, ==, cItemsFromGetCount);

            // get the next item

            CStatPropStg Item;
            ULONG        cFetched = 0;

            hr = pEnum->Next(1, &Item, &cFetched);

            cItemsFromNext += cFetched;
        } 
        while (hr == S_OK);

        LOG_HR(hr, == S_FALSE);

        // verify that the two counts are equal

        LOG_CMP(cItemsFromNext, ==, cItemsFromGetCount);
    }

    // test bad param

    if (m_bRunBadParamTests)
    {
        LOG_HR(pProp->GetCount(0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CWiaStressThread::TestReadPropertyNames(CWiaItemData *pItemData)
{
    LOG_INFO(_T("Testing ReadPropertyNames() on %ws"), pItemData->bstrFullName);

    int i;

    CComQIPtr<CMyWiaPropertyStorage, &IID_IWiaPropertyStorage> pProp(pItemData->pWiaItem);

    CComPtr<CMyEnumSTATPROPSTG> pEnumSTATPROPSTG;

    CHECK_HR(pProp->Enum((IEnumSTATPROPSTG **) &pEnumSTATPROPSTG));

    // find the number of properties

    ULONG ulNumProps = -1;

    CHECK_HR(pProp->GetCount(&ulNumProps));

    if (ulNumProps == 0)
    {
        return;
    }

    // read the property names and id's using the enum interface

    CCppMem<CStatPropStg> pStatPropStg(ulNumProps);

    ULONG celtFetched = -1;

    CHECK_HR(pEnumSTATPROPSTG->Next(ulNumProps, pStatPropStg, &celtFetched));

    // test legal case

    CCppMem<PROPID> pPropId(ulNumProps);
    CCppMem<LPOLESTR> ppwstrName(ulNumProps, TRUE);

    for (i = 0; i < ulNumProps; ++i)
    {
        pPropId[i] = pStatPropStg[i].propid;
    }

    LOG_HR(pProp->ReadPropertyNames(ulNumProps, pPropId, ppwstrName), == S_OK);

    // cross check the results

    for (i = 0; i < ulNumProps; ++i)
    {
        if (wcssafecmp(ppwstrName[i], pStatPropStg[i].lpwstrName) != 0)
        {
            LOG_ERROR(
                _T("ReadPropertyNames() %ws != Enum() %ws for PROPID=%d"), 
                ppwstrName[i], 
                pStatPropStg[i].lpwstrName, 
                pPropId[i]
            );
        }
    }

    for (i = 0; i < ulNumProps; ++i)
    {
        CoTaskMemFree(ppwstrName[i]);
        ppwstrName[i] = 0;
    }

    // test illegal cases

    // if we try to read 0 properties, ReadPropertyNames() should
    // return S_FALSE and should not touch ppwstrName

    LOG_HR(pProp->ReadPropertyNames(0, pPropId, ppwstrName), == S_FALSE);

    for (i = 0; i < ulNumProps; ++i)
    {
        if (ppwstrName[i] != 0)
        {
            LOG_ERROR(_T("ReadPropertyNames() hr == S_FALSE but ppwstrName[%d]=%ws"), i, ppwstrName[i]);
        }
    }

    // pass invalid ppwstrName pointer

    LOG_HR(pProp->ReadPropertyNames(ulNumProps, pPropId, 0), != S_OK);

    // pass invalid pPropId pointer

    LOG_HR(pProp->ReadPropertyNames(ulNumProps, 0, ppwstrName), != S_OK);

    // try to read non-existent name

    PROPID   PropId = -1;
    LPOLESTR pwstrName = 0;

    LOG_HR(pProp->ReadPropertyNames(1, &PropId, &pwstrName), == S_FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

void CWiaStressThread::TestEnumSTATPROPSTG(CWiaItemData *pItemData)
{
    LOG_INFO(_T("Testing EnumSTATPROPSTG() on %ws"), pItemData->bstrFullName);

    CComQIPtr<IWiaPropertyStorage> pProp(pItemData->pWiaItem);

    CHECK(pProp != 0);

    // test valid cases

    CComPtr<CMyEnumSTATPROPSTG> pEnumSTATPROPSTG;

    if (LOG_HR(pProp->Enum((IEnumSTATPROPSTG **) &pEnumSTATPROPSTG), == S_OK))
    {
        TestEnum(pEnumSTATPROPSTG, _T("EnumSTATPROPSTG"));
    }

    // test invalid cases

    LOG_HR(pProp->Enum(0), != S_OK);
}

//////////////////////////////////////////////////////////////////////////
//
// 
//


#endif //DEFINE_TEMPLATES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\testiwiaitem.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    TestIWiaItem.cpp

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "stdafx.h"

#include "WiaStress.h"

#include "StolenIds.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestGetItemType(CWiaItemData *pItemData)
{
    LOG_INFO(_T("Testing GetItemType() on %ws"), pItemData->bstrFullName);

    // good parameter test

    LONG lItemType = -1;

    if (LOG_HR(pItemData->pWiaItem->GetItemType(&lItemType), == S_OK))
    {
        if (lItemType & ~WiaItemTypeMask)
        {
            LOG_ERROR(
                _T("GetItemType() returned unrecognized type bits; 0x%x"),
                lItemType & ~WiaItemTypeMask
            );
        }
    }

    // bad parameter test

    if (m_bRunBadParamTests)
    {
        LOG_HR(pItemData->pWiaItem->GetRootItem(0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestEnumChildItems(CWiaItemData *pItemData)
{
    if (!(pItemData->lItemType & WiaItemTypeFolder))
    {
        return;
    }

    LOG_INFO(_T("Testing EnumChildItems() on %ws"), pItemData->bstrFullName);

    // good parameter test

    CComPtr<IEnumWiaItem> pEnumWiaItem;

    if (LOG_HR(pItemData->pWiaItem->EnumChildItems(&pEnumWiaItem), == S_OK))
    {
        TestEnum(pEnumWiaItem, _T("EnumChildItems"));
    }

    // bad parameter test

    if (m_bRunBadParamTests)
    {
        LOG_HR(pItemData->pWiaItem->EnumChildItems(0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestDeleteItem(CWiaItemData *pItemData)
{
    LOG_INFO(_T("Testing DeleteItem() on %ws"), pItemData->bstrFullName);

    if (LOG_HR(pItemData->pWiaItem->DeleteItem(0), == S_OK) && !m_bBVTMode)
    {
        // enumerate the parent item's children to ensure this item is deleted

        IWiaItem *pParent = pItemData->ParentsList.back();

        CComPtr<IWiaItem> pChild;

        LOG_HR(pParent->FindItemByName(0, pItemData->bstrFullName, &pChild), == S_FALSE);

        // if there are no children left, WiaItemTypeFolder bit should be clear

#if 0 //bugbug: find out why EnumChildItems fails

        CComPtr<IEnumWiaItem> pEnumWiaItem;

        CHECK_HR(pParent->EnumChildItems(&pEnumWiaItem));

        ULONG nChildren = -1;

        CHECK_HR(pEnumWiaItem->GetCount(&nChildren));

        if (nChildren == 0)
        {
            LONG lParentItemType = -1;

            CHECK_HR(pItemData->pWiaItem->GetItemType(&lParentItemType));

            LOG_CMP(lParentItemType & WiaItemTypeFolder, ==, 0);
        }
#endif
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestCreateChildItem(CWiaItemData *pItemData)
{
    SubTestCreateChildItem(pItemData, 1);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::SubTestCreateChildItem(CWiaItemData *pItemData, int nLevel)
{
    // not meaningful to run this on root item

    if ((pItemData->lItemType & WiaItemTypeRoot))
    {
        return;
    }

    LOG_INFO(_T("Testing CreateChildItem() on %ws"), pItemData->bstrFullName);

    // good parameter test

    GUID guid;

    CHECK_HR(CoCreateGuid(&guid));

    CComBSTR bstrChildItemName(MAX_GUID_STRING_LEN);

    CHECK(StringFromGUID2(guid, bstrChildItemName, MAX_GUID_STRING_LEN));

    CComBSTR bstrFullChildItemName(pItemData->bstrFullName.Length() + 1 + MAX_GUID_STRING_LEN + 1);

    swprintf(bstrFullChildItemName, L"%s\\%s", pItemData->bstrFullName, bstrChildItemName);

    CComPtr<IWiaItem> pChildWiaItem;

    if (
        LOG_HR(pItemData->pWiaItem->CreateChildItem(
            WiaItemTypeFile, 
            bstrChildItemName, 
            bstrFullChildItemName, 
            &pChildWiaItem
        ), == S_OK)
    )
    {
        CParentsList ParentsListForChild = pItemData->ParentsList;

        ParentsListForChild.push_back(pItemData->pWiaItem);

        CWiaItemData ItemData(pChildWiaItem, ParentsListForChild);

        if (!m_bBVTMode)
        {
            // check that the flags are modified properly

            // parent should have the WiaItemTypeFolder bit set

            LONG lParentItemType = -1;

            CHECK_HR(pItemData->pWiaItem->GetItemType(&lParentItemType));

            LOG_CMP(lParentItemType & WiaItemTypeFolder, !=, 0);

            // child should have the WiaItemTypeGenerated bit set

            LONG lChildItemType = -1;

            CHECK_HR(pChildWiaItem->GetItemType(&lChildItemType));

            LOG_CMP(lChildItemType & WiaItemTypeGenerated, !=, 0);


            // check that minimal properties are there

            //bugbug

            // fully test the child item

            TestGetData(&ItemData);
            TestQueryData(&ItemData);
            TestEnumWIA_FORMAT_INFO(&ItemData);
            TestGetItemType(&ItemData);
            TestEnumChildItems(&ItemData);
            TestFindItemByName(&ItemData);
            TestGetRootItem(&ItemData);
            TestPropStorage(&ItemData);
            TestPropGetCount(&ItemData);
            TestReadPropertyNames(&ItemData);
            TestEnumSTATPROPSTG(&ItemData);

            // recursively create another level of child items

            if (nLevel < 1)
            {
                SubTestCreateChildItem(pItemData, nLevel);
                SubTestCreateChildItem(&ItemData, nLevel + 1);
            }
        }

        // finally "test" DeleteItem

        TestDeleteItem(&ItemData);
    }

    // bad parameter test

    if (m_bRunBadParamTests)
    {
        LOG_HR(pItemData->pWiaItem->CreateChildItem(0, bstrChildItemName, bstrFullChildItemName, 0), != S_OK);

        CComPtr<IWiaItem> pChildWiaItem1;

        LOG_HR(pItemData->pWiaItem->CreateChildItem(0, bstrChildItemName, 0, &pChildWiaItem1), != S_OK);

        CComPtr<IWiaItem> pChildWiaItem2;

        LOG_HR(pItemData->pWiaItem->CreateChildItem(0, 0, bstrFullChildItemName, &pChildWiaItem2), != S_OK);

        LOG_HR(pItemData->pWiaItem->CreateChildItem(0, 0, 0, 0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestEnumRegisterEventInfo(CWiaItemData *pItemData)
{
    // good parameter test

    static FLAG_AND_NAME<LPCGUID> AllGuids[] =
    {
        MAKE_FLAG_AND_NAME(&WIA_EVENT_DEVICE_DISCONNECTED),
        MAKE_FLAG_AND_NAME(&WIA_EVENT_DEVICE_CONNECTED),
        MAKE_FLAG_AND_NAME(&WIA_EVENT_ITEM_DELETED),
        MAKE_FLAG_AND_NAME(&WIA_EVENT_ITEM_CREATED),
        //bugbug: MAKE_FLAG_AND_NAME(&WIA_EVENT_VOLUME_REMOVE),
        MAKE_FLAG_AND_NAME(&WIA_EVENT_VOLUME_INSERT)
    };

    FOR_SELECTED(nGuid, COUNTOF(AllGuids))
    {
        LOG_INFO(_T("Testing EnumRegisterEventInfo(%s) on %ws"), AllGuids[nGuid].pszName, pItemData->bstrFullName);

        CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;

        if (LOG_HR(pItemData->pWiaItem->EnumRegisterEventInfo(0, AllGuids[nGuid].Value, &pEnumWIA_DEV_CAPS), == S_OK))
        {
            TestEnum(pEnumWIA_DEV_CAPS, _T("EnumDeviceInfo"));
        }
    }

    // bad parameter test

    if (m_bRunBadParamTests)
    {
        CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;

        LOG_HR(pItemData->pWiaItem->EnumRegisterEventInfo(0, 0, &pEnumWIA_DEV_CAPS), != S_OK);

        LOG_HR(pItemData->pWiaItem->EnumRegisterEventInfo(0, &WIA_EVENT_DEVICE_CONNECTED, 0), != S_OK);

        LOG_HR(pItemData->pWiaItem->EnumRegisterEventInfo(0, 0, 0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestFindItemByName(CWiaItemData *pItemData)
{
    IWiaItem *pParent = pItemData->ParentsList.back();

    if (pParent == 0)
    {
        return;
    }

    LOG_INFO(_T("Testing FindItemByName() on %ws"), pItemData->bstrFullName);

    // good parameter test; initiate the search starting from each of the parents

    for (
        CParentsList::iterator itParent = pItemData->ParentsList.begin();
        itParent != pItemData->ParentsList.end();
        ++itParent
    )
    {
        CComPtr<IWiaItem> pFoundItem;

        if (LOG_HR((*itParent)->FindItemByName(0, pItemData->bstrFullName, &pFoundItem), == S_OK))
        {
            if (*pFoundItem != *pItemData->pWiaItem)
            {
                LOG_ERROR(_T("FindItemByName did not find correct item"));
            }
        }
    }

    // bad parameter tests

    if (m_bRunBadParamTests)
    {
        LOG_HR(pParent->FindItemByName(0, pItemData->bstrFullName, 0), != S_OK);

        CComPtr<IWiaItem> pFoundItem;

        LOG_HR(pParent->FindItemByName(0, 0, &pFoundItem), != S_OK);

        LOG_HR(pParent->FindItemByName(0, 0, 0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestDeviceDlg(CWiaItemData *pItemData)
{
    // test valid cases

    static FLAG_AND_NAME<LONG> AllIntents[] = 
    { 
        MAKE_FLAG_AND_NAME(WIA_INTENT_NONE),
        MAKE_FLAG_AND_NAME(WIA_INTENT_IMAGE_TYPE_COLOR),
        MAKE_FLAG_AND_NAME(WIA_INTENT_IMAGE_TYPE_GRAYSCALE),
        MAKE_FLAG_AND_NAME(WIA_INTENT_IMAGE_TYPE_TEXT)
    };

    static FLAG_AND_NAME<LONG> AllFlags[] = 
    { 
        MAKE_FLAG_AND_NAME(0),
        MAKE_FLAG_AND_NAME(WIA_DEVICE_DIALOG_SINGLE_IMAGE)
    };

    FOR_SELECTED(lIntents, COUNTOF(AllIntents))
    {
        FOR_SELECTED(lFlags, COUNTOF(AllFlags))
        {
            LOG_INFO(
		        _T("Testing DeviceDlg(), lFlags=%s, lIntent=%s"),
                AllFlags[lFlags].pszName, 
                AllIntents[lIntents].pszName
            );

            SubTestDeviceDlg(
                pItemData->pWiaItem, 
                AllFlags[lFlags].Value, 
                AllIntents[lIntents].Value
            );
        }
    }

    // test invalid cases

    // todo:
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void
CWiaStressThread::SubTestDeviceDlg(
    IWiaItem *pRootItem,
    LONG      lFlags,
    LONG      lIntent
)
{
    // this test only verifies that the device dialogs show up, it does not
    // target a through test of the dialogs. So we'll just press cancel as
    // soon as the dialog pops up.

    LONG nButtonId = IDCANCEL;

    // read the (localizable) dialog names from the system DLLs

    static TCHAR szCameraDlgTitle[256];
    static TCHAR szScanDlgTitle[256];
    static TCHAR szVideoDlgTitle[256];
    static TCHAR szBusy[256];
    static LONG  bInitStrings = TRUE;
    
    if (bInitStrings)
    {
        USES_CONVERSION;

        CLibrary wiadefui_dll(_T("wiadefui.dll"), LOAD_LIBRARY_AS_DATAFILE);

        // read camera dlg title

        CResourceString<256> CameraDlgTitle(IDS_CAMERADLG_TITLE, wiadefui_dll);

        lstrcpyn(
            szCameraDlgTitle, 
            CameraDlgTitle, 
            COUNTOF(szCameraDlgTitle)
        );

        // read scanner dlg title

        CResourceString<256> ScanDlgTitle(IDS_DIALOG_TITLE, wiadefui_dll);

        lstrcpyn(
            szScanDlgTitle, 
            ScanDlgTitle, 
            COUNTOF(szScanDlgTitle)
        );

        // read video dlg title

        CDialogResource DlgVideo(wiadefui_dll, MAKEINTRESOURCE(IDD_CAPTURE_DIALOG));

        lstrcpyn(
            szVideoDlgTitle, 
            W2T(DlgVideo.title), 
            COUNTOF(szVideoDlgTitle)
        );

        // read video busy dlg title

        CResourceString<256> VideoBusyDlgTitle(IDS_VIDDLG_BUSY_TITLE, wiadefui_dll);

        lstrcpyn(
            szBusy, 
            VideoBusyDlgTitle, 
            COUNTOF(szBusy)
        );

        // set the 'we are done' switch

        InterlockedExchange(&bInitStrings, FALSE);
    }

    // select the title to search for according to device type

    CPropVariant varDevName;

    CHECK_HR(ReadWiaItemProperty(pRootItem, WIA_DIP_DEV_NAME, &varDevName, VT_BSTR));

    CPropVariant varDevType;

    CHECK_HR(ReadWiaItemProperty(pRootItem, WIA_DIP_DEV_TYPE, &varDevType, VT_I4));

    USES_CONVERSION;
    TCHAR szDlgTitle[4096]; //bugbug

    switch (GET_STIDEVICE_TYPE(varDevType.lVal))
    {
    case StiDeviceTypeScanner: 
        _stprintf(szDlgTitle, szScanDlgTitle, W2T(varDevName.bstrVal));
        break;

    case StiDeviceTypeDigitalCamera:
        _stprintf(szDlgTitle, szCameraDlgTitle, varDevName.bstrVal);
        break;

    case StiDeviceTypeStreamingVideo:
        _tcscpy(szDlgTitle, szVideoDlgTitle);
        break;

    default:
        OutputDebugStringF(_T("Unknown device type %d"), GET_STIDEVICE_TYPE(varDevType.lVal));
        ASSERT(FALSE);
        break;
    }

    // start the thread that'll push the button for us
    
    CPushDlgButton PushDlgButton(
        GetCurrentThreadId(), 
        szDlgTitle, 
        nButtonId
    );

    CPushDlgButton CreateAnotherWatchForVideoBusyDialog( // bugbug
        GetCurrentThreadId(), 
        szBusy,
        IDCANCEL
    );

    // open the select device dialog

    CComPtrArray<IWiaItem> ppWiaItem;

    HRESULT hrAPI;

    hrAPI = pRootItem->DeviceDlg(
        0,
        lFlags,
        lIntent,
        &ppWiaItem.ItemCount(), 
        &ppWiaItem
    ); 

    if (hrAPI == S_OK)
    {
        // for now, we are always cancelling so it won't ever return S_OK...
    }
    else
    {
        if (ppWiaItem != 0) 
        {
            LOG_ERROR(
                _T("ppWiaItem=%p, expected NULL when hr != S_OK"),
                (IWiaItem **) ppWiaItem
            );
        }

        if (ppWiaItem.ItemCount() != 0) 
        {
            LOG_ERROR(
                _T("lItemCount=%d, expected 0 when hr != S_OK"),
                ppWiaItem.ItemCount()
            );
        }
    }

    if (!PushDlgButton.m_nMatchingWindows)
    {
        LOG_ERROR(_T("Select device dialog did not show up"));
    }   

    if (CreateAnotherWatchForVideoBusyDialog.m_nMatchingWindows)
    {
        LOG_ERROR(_T("Preview failed - device busy"));
    }

    if (nButtonId == IDOK)
    {
        LOG_HR(hrAPI, == S_OK);
    }

    if (nButtonId == IDCANCEL)
    {
        LOG_HR(hrAPI, == S_FALSE);
    }

    // we expect to see only one matching button

    if (PushDlgButton.m_nMatchingButtons < 1)
    {
        LOG_ERROR(_T("No buttons with Id=%d"), (PCTSTR) ButtonIdToStr(nButtonId));
    }

#if 0 //***bugbug
    // bad parameter tests

    if (m_bRunBadParamTests)
    {
        ppWiaItem.Release();

        LOG_HR(pRootItem->DeviceDlg(0, lFlags, lIntent, 0, &ppWiaItem), != S_OK); 

        ppWiaItem.Release();

        LOG_HR(pRootItem->DeviceDlg(0, lFlags, lIntent, &ppWiaItem.ItemCount(), 0), != S_OK); 

        ppWiaItem.Release();

        LOG_HR(pRootItem->DeviceDlg(0, lFlags, lIntent, 0, 0), != S_OK); 
    }

#endif //***bugbug
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestGetRootItem(CWiaItemData *pItemData)
{
    LOG_INFO(_T("Testing GetRootItem() on %ws"), pItemData->bstrFullName);

    // good parameter test

    CComPtr<IWiaItem> pRootItem;

    if (LOG_HR(pItemData->pWiaItem->GetRootItem(&pRootItem), == S_OK))
    {
        IWiaItem *pExpectedRootItem;

        if (pItemData->lItemType & WiaItemTypeRoot)
        {
            // if the item itself was the root, GetRootItem() should return self

            pExpectedRootItem = pItemData->pWiaItem;
        }
        else
        {
            // else, get the root item pointer from the cached parents list

            pExpectedRootItem = pItemData->ParentsList.front();
        }

        if (*pRootItem != *pExpectedRootItem)
        {
            LOG_ERROR(_T("GetRootItem() did not return root item"));
        }
    }

    // bad parameter test

    if (m_bRunBadParamTests)
    {
        LOG_HR(pItemData->pWiaItem->GetRootItem(0), != S_OK);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::TestEnumDeviceCapabilities(CWiaItemData *pItemData)
{
    // good parameter test

    static FLAG_AND_NAME<LONG> AllFlags[] =
    {
        MAKE_FLAG_AND_NAME(WIA_DEVICE_COMMANDS),
        MAKE_FLAG_AND_NAME(WIA_DEVICE_EVENTS),
        MAKE_FLAG_AND_NAME(WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS)
    };

    FOR_SELECTED(lFlags, COUNTOF(AllFlags))
    {
        CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;

        LOG_INFO(_T("Testing TestEnumDeviceCapabilities(%s) on %ws"), AllFlags[lFlags].pszName, pItemData->bstrFullName);

        if (LOG_HR(pItemData->pWiaItem->EnumDeviceCapabilities(AllFlags[lFlags].Value, &pEnumWIA_DEV_CAPS), == S_OK))
        {
            TestEnum(pEnumWIA_DEV_CAPS, _T("EnumDeviceCapabilities"));
        }
    }

    // bad parameter test

    /***bugbugif (m_bRunBadParamTests)
    {
        CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;

        LOG_HR(pItemData->pWiaItem->EnumDeviceCapabilities(0, &pEnumWIA_DEV_CAPS), != S_OK);

        LOG_HR(pItemData->pWiaItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS, 0), != S_OK);

        LOG_HR(pItemData->pWiaItem->EnumDeviceCapabilities(0, 0), != S_OK);
    }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\tostr.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ToStr.cpp

Abstract:



Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "StdAfx.h"

#include "ToStr.h"

//////////////////////////////////////////////////////////////////////////
//
// bugbug: remove this when defined in wia.h
//

#define StiDeviceTypeStreamingVideo     3

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr IntToStr(int Value)
{
    CAutoStr szValue(34); // 34 = max for _itot

    _itot(Value, szValue, 10);

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr Int64ToStr(__int64 Value)
{
    CAutoStr szValue(64); //bugbug

    _stprintf(szValue, _T("%i64d"), Value);

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr FloatToStr(float Value)
{
    CAutoStr szValue(64); //bugbug

    _stprintf(szValue, _T("%f"), Value);

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr DoubleToStr(double Value)
{
    CAutoStr szValue(34); //bugbug

    _stprintf(szValue, _T("%lf"), Value);

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr SzToStr(PCSTR Value)
{
    CAutoStr szValue(strlen(Value) + 1);

    _stprintf(szValue, _T("%hs"), Value);

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr WSzToStr(PCWSTR Value)
{
    CAutoStr szValue(wcslen(Value) + 1);

    _stprintf(szValue, _T("%ws"), Value);

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr ToStr(const void *Value, VARTYPE vt)
{
    CAutoStr szValue(1024);

    switch (vt)
    {
    case VT_EMPTY:   return _T("<EMPTY>");                                    break;
    case VT_NULL:    return _T("<NULL>");                                     break;
    case VT_I2:      return IntToStr(*(SHORT*)Value);                         break;
    case VT_I4:      return IntToStr(*(ULONG*)Value);                         break;
    case VT_R4:      return FloatToStr(*(FLOAT*)Value);                       break;
    case VT_R8:      return DoubleToStr(*(DOUBLE*)Value);                     break;
    case VT_BSTR:    return WSzToStr((PCWSTR)Value);                          break;
    case VT_BOOL:    return *(VARIANT_BOOL*)Value ? _T("TRUE") : _T("FALSE"); break;
    case VT_I1:      return IntToStr(*(CHAR*)Value);                          break;
    case VT_UI1:     return IntToStr(*(BYTE*)Value);                          break;
    case VT_UI2:     return IntToStr(*(USHORT*)Value);                        break;
    case VT_UI4:     return IntToStr(*(ULONG*)Value);                         break;
    case VT_I8:      return Int64ToStr(*(__int64*)Value);                     break;
    case VT_UI8:     return Int64ToStr(*(__int64*)Value);                     break;
    case VT_INT:     return IntToStr(*(INT*)Value);                           break;
    case VT_UINT:    return IntToStr(*(UINT*)Value);                          break;
    case VT_LPSTR:   return SzToStr((PCSTR)Value);                            break;
    case VT_LPWSTR:  return WSzToStr((PCWSTR)Value);                          break;
    case VT_CLSID:   return GuidToStr(*(CLSID*)Value);                        break;
    default:         return _T("<UNKNOWN>");                                  break;
    };

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr PropVariantToStr(const PROPVARIANT &Value)
{
    switch (Value.vt)
    {
    case VT_EMPTY:   return _T("<EMPTY>");                              break;
    case VT_NULL:    return _T("<NULL>");                               break;
    case VT_I2:      return IntToStr(Value.iVal);                       break;
    case VT_I4:      return IntToStr(Value.lVal);                       break;
    case VT_R4:      return FloatToStr(Value.fltVal);                   break;
    case VT_R8:      return DoubleToStr(Value.dblVal);                  break;
    case VT_BSTR:    return WSzToStr(Value.bstrVal);                    break;
    case VT_BOOL:    return Value.boolVal ? _T("TRUE") : _T("FALSE");   break;
    case VT_I1:      return IntToStr(Value.cVal);                       break;
    case VT_UI1:     return IntToStr(Value.bVal);                       break;
    case VT_UI2:     return IntToStr(Value.uiVal);                      break;
    case VT_UI4:     return IntToStr(Value.ulVal);                      break;
    case VT_I8:      return Int64ToStr(*(__int64*)&Value.hVal);         break;
    case VT_UI8:     return Int64ToStr(*(__int64*)&Value.uhVal);        break;
    case VT_INT:     return IntToStr(Value.intVal);                     break;
    case VT_UINT:    return IntToStr(Value.uintVal);                    break;
    case VT_LPSTR:   return SzToStr(Value.pszVal);                      break;
    case VT_LPWSTR:  return WSzToStr(Value.pwszVal);                    break;
    case VT_CLSID:   return GuidToStr(*Value.puuid);                    break;
    default:         return _T("<UNKNOWN>");                            break;
    };
}


//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr GuidToStr(REFGUID Value)
{
         if (Value == GUID_NULL)        return _T("GUID_NULL");
    else if (Value == WiaImgFmt_UNDEFINED) return _T("WiaImgFmt_UNDEFINED");
    else if (Value == WiaImgFmt_MEMORYBMP) return _T("WiaImgFmt_MEMORYBMP");
    else if (Value == WiaImgFmt_BMP)       return _T("WiaImgFmt_BMP");
    else if (Value == WiaImgFmt_EMF)       return _T("WiaImgFmt_EMF");
    else if (Value == WiaImgFmt_WMF)       return _T("WiaImgFmt_WMF");
    else if (Value == WiaImgFmt_JPEG)      return _T("WiaImgFmt_JPEG");
    else if (Value == WiaImgFmt_PNG)       return _T("WiaImgFmt_PNG");
    else if (Value == WiaImgFmt_GIF)       return _T("WiaImgFmt_GIF");
    else if (Value == WiaImgFmt_TIFF)      return _T("WiaImgFmt_TIFF");
    else if (Value == WiaImgFmt_EXIF)      return _T("WiaImgFmt_EXIF");
    else if (Value == WiaImgFmt_PHOTOCD)   return _T("WiaImgFmt_PHOTOCD");
    else if (Value == WiaImgFmt_FLASHPIX)  return _T("WiaImgFmt_FLASHPIX");
    else if (Value == WiaImgFmt_ICO)       return _T("WiaImgFmt_ICO");

    CAutoStr szValue(MAX_GUID_STRING_LEN);

#ifdef UNICODE

    StringFromGUID2(Value, szValue, MAX_GUID_STRING_LEN);

#else //UNICODE

    WCHAR wszValue[MAX_GUID_STRING_LEN];

    StringFromGUID2(Value, wszValue, MAX_GUID_STRING_LEN);

    WideCharToMultiByte(
        CP_ACP,
        0,
        wszValue,
        MAX_GUID_STRING_LEN,
        szValue,
        MAX_GUID_STRING_LEN,
        0,
        0
    );

#endif //UNICODE

    return szValue;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr TymedToStr(TYMED Value)
{
    switch (Value)
    {
        case (TYMED) TYMED_HGLOBAL:  return _T("TYMED_HGLOBAL");
        case (TYMED) TYMED_FILE:     return _T("TYMED_FILE");
        case (TYMED) TYMED_ISTREAM:  return _T("TYMED_ISTREAM");
        case (TYMED) TYMED_ISTORAGE: return _T("TYMED_ISTORAGE");
        case (TYMED) TYMED_GDI:      return _T("TYMED_GDI");
        case (TYMED) TYMED_MFPICT:   return _T("TYMED_MFPICT");
        case (TYMED) TYMED_ENHMF:    return _T("TYMED_ENHMF");
        case (TYMED) TYMED_NULL:     return _T("TYMED_NULL");
        case (TYMED) TYMED_CALLBACK: return _T("TYMED_CALLBACK");
    };

    return IntToStr((int) Value);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr DeviceTypeToStr(STI_DEVICE_MJ_TYPE Value)
{
    switch (Value)
    {
        case (STI_DEVICE_MJ_TYPE) StiDeviceTypeDefault:        return _T("StiDeviceTypeDefault");
        case (STI_DEVICE_MJ_TYPE) StiDeviceTypeScanner:        return _T("StiDeviceTypeScanner");
        case (STI_DEVICE_MJ_TYPE) StiDeviceTypeDigitalCamera:  return _T("StiDeviceTypeDigitalCamera");
        case (STI_DEVICE_MJ_TYPE) StiDeviceTypeStreamingVideo: return _T("StiDeviceTypeStreamingVideo");
    };

    return IntToStr((int) Value);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr ButtonIdToStr(int Value)
{
    switch (Value)
    {
        case IDOK:        return _T("IDOK");
        case IDCANCEL:    return _T("IDCANCEL");
        case IDABORT:     return _T("IDABORT");
        case IDRETRY:     return _T("IDRETRY");
        case IDIGNORE:    return _T("IDIGNORE");
        case IDYES:       return _T("IDYES");
        case IDNO:        return _T("IDNO");
        case IDCLOSE:     return _T("IDCLOSE");
        case IDHELP:      return _T("IDHELP");
        case IDTRYAGAIN:  return _T("IDTRYAGAIN");
        case IDCONTINUE:  return _T("IDCONTINUE");
    };

    return IntToStr((int) Value);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr HResultToStr(HRESULT Value)
{
    switch (Value)
    {
    case S_OK:                           return _T("S_OK");
    case S_FALSE:                        return _T("S_FALSE");
    case E_UNEXPECTED:                   return _T("E_UNEXPECTED");
    case E_NOTIMPL:                      return _T("E_NOTIMPL");
    case E_OUTOFMEMORY:                  return _T("E_OUTOFMEMORY");
    case E_INVALIDARG:                   return _T("E_INVALIDARG");
    case E_NOINTERFACE:                  return _T("E_NOINTERFACE");
    case E_POINTER:                      return _T("E_POINTER");
    case E_HANDLE:                       return _T("E_HANDLE");
    case E_ABORT:                        return _T("E_ABORT");
    case E_FAIL:                         return _T("E_FAIL");
    case E_ACCESSDENIED:                 return _T("E_ACCESSDENIED");
    case DV_E_TYMED:                     return _T("DV_E_TYMED");
    case WIA_S_NO_DEVICE_AVAILABLE:      return _T("WIA_S_NO_DEVICE_AVAILABLE");
    case WIA_ERROR_GENERAL_ERROR:        return _T("WIA_ERROR_GENERAL_ERROR");
    case WIA_ERROR_PAPER_JAM:            return _T("WIA_ERROR_PAPER_JAM");
    case WIA_ERROR_PAPER_EMPTY:          return _T("WIA_ERROR_PAPER_EMPTY");
    case WIA_ERROR_PAPER_PROBLEM:        return _T("WIA_ERROR_PAPER_PROBLEM");
    case WIA_ERROR_OFFLINE:              return _T("WIA_ERROR_OFFLINE");
    case WIA_ERROR_BUSY:                 return _T("WIA_ERROR_BUSY");
    case WIA_ERROR_WARMING_UP:           return _T("WIA_ERROR_WARMING_UP");
    case WIA_ERROR_USER_INTERVENTION:    return _T("WIA_ERROR_USER_INTERVENTION");
    case WIA_ERROR_ITEM_DELETED:         return _T("WIA_ERROR_ITEM_DELETED");
    case WIA_ERROR_DEVICE_COMMUNICATION: return _T("WIA_ERROR_DEVICE_COMMUNICATION");
    case WIA_ERROR_INVALID_COMMAND:      return _T("WIA_ERROR_INVALID_COMMAND");
    };

    return IntToStr((int) Value);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr VarTypeToStr(VARTYPE Value)
{
    CAutoStr szValue(256);

    if (Value & VT_VECTOR)    _tcscat(szValue, _T("VT_VECTOR | "));
    if (Value & VT_ARRAY)     _tcscat(szValue, _T("VT_ARRAY | "));
    if (Value & VT_BYREF)     _tcscat(szValue, _T("VT_BYREF | "));

    TCHAR szNum[34];

    PCTSTR pTypeName;

    switch (Value & VT_TYPEMASK)
    {
    case VT_EMPTY:            pTypeName = _T("VT_EMPTY");            break;
    case VT_NULL:             pTypeName = _T("VT_NULL");             break;
    case VT_I2:               pTypeName = _T("VT_I2");               break;
    case VT_I4:               pTypeName = _T("VT_I4");               break;
    case VT_R4:               pTypeName = _T("VT_R4");               break;
    case VT_R8:               pTypeName = _T("VT_R8");               break;
    case VT_CY:               pTypeName = _T("VT_CY");               break;
    case VT_DATE:             pTypeName = _T("VT_DATE");             break;
    case VT_BSTR:             pTypeName = _T("VT_BSTR");             break;
    case VT_DISPATCH:         pTypeName = _T("VT_DISPATCH");         break;
    case VT_ERROR:            pTypeName = _T("VT_ERROR");            break;
    case VT_BOOL:             pTypeName = _T("VT_BOOL");             break;
    case VT_VARIANT:          pTypeName = _T("VT_VARIANT");          break;
    case VT_UNKNOWN:          pTypeName = _T("VT_UNKNOWN");          break;
    case VT_DECIMAL:          pTypeName = _T("VT_DECIMAL");          break;
    case VT_I1:               pTypeName = _T("VT_I1");               break;
    case VT_UI1:              pTypeName = _T("VT_UI1");              break;
    case VT_UI2:              pTypeName = _T("VT_UI2");              break;
    case VT_UI4:              pTypeName = _T("VT_UI4");              break;
    case VT_I8:               pTypeName = _T("VT_I8");               break;
    case VT_UI8:              pTypeName = _T("VT_UI8");              break;
    case VT_INT:              pTypeName = _T("VT_INT");              break;
    case VT_UINT:             pTypeName = _T("VT_UINT");             break;
    case VT_VOID:             pTypeName = _T("VT_VOID");             break;
    case VT_HRESULT:          pTypeName = _T("VT_HRESULT");          break;
    case VT_PTR:              pTypeName = _T("VT_PTR");              break;
    case VT_SAFEARRAY:        pTypeName = _T("VT_SAFEARRAY");        break;
    case VT_CARRAY:           pTypeName = _T("VT_CARRAY");           break;
    case VT_USERDEFINED:      pTypeName = _T("VT_USERDEFINED");      break;
    case VT_LPSTR:            pTypeName = _T("VT_LPSTR");            break;
    case VT_LPWSTR:           pTypeName = _T("VT_LPWSTR");           break;
    case VT_RECORD:           pTypeName = _T("VT_RECORD");           break;
    case VT_FILETIME:         pTypeName = _T("VT_FILETIME");         break;
    case VT_BLOB:             pTypeName = _T("VT_BLOB");             break;
    case VT_STREAM:           pTypeName = _T("VT_STREAM");           break;
    case VT_STORAGE:          pTypeName = _T("VT_STORAGE");          break;
    case VT_STREAMED_OBJECT:  pTypeName = _T("VT_STREAMED_OBJECT");  break;
    case VT_STORED_OBJECT:    pTypeName = _T("VT_STORED_OBJECT");    break;
    case VT_BLOB_OBJECT:      pTypeName = _T("VT_BLOB_OBJECT");      break;
    case VT_CF:               pTypeName = _T("VT_CF");               break;
    case VT_CLSID:            pTypeName = _T("VT_CLSID");            break;
    case VT_VERSIONED_STREAM: pTypeName = _T("VT_VERSIONED_STREAM"); break;
    default:                  pTypeName = _itot(Value, szNum, 10);   break;
    };

    _tcscat(szValue, pTypeName);

    return szValue;
}


//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr WiaCallbackReasonToStr(ULONG Value)
{
    switch (Value)
    {
    case IT_MSG_DATA_HEADER: return _T("IT_MSG_DATA_HEADER");
    case IT_MSG_DATA:        return _T("IT_MSG_DATA");
    case IT_MSG_STATUS:      return _T("IT_MSG_STATUS");
    case IT_MSG_TERMINATION: return _T("IT_MSG_TERMINATION");
    case IT_MSG_NEW_PAGE:    return _T("IT_MSG_NEW_PAGE");
    };

    return IntToStr((int) Value);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr WiaCallbackStatusToStr(ULONG Value)
{
    CAutoStr szValue(256);

         if (Value & IT_STATUS_TRANSFER_FROM_DEVICE) _tcscat(szValue, _T("IT_STATUS_TRANSFER_FROM_DEVICE "));
    else if (Value & IT_STATUS_PROCESSING_DATA)      _tcscat(szValue, _T("IT_STATUS_PROCESSING_DATA "));
    else if (Value & IT_STATUS_TRANSFER_TO_CLIENT)   _tcscat(szValue, _T("IT_STATUS_TRANSFER_TO_CLIENT "));

    return szValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\wiahelpers.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    WiaHelpers.h

Abstract:


Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _WIAHELPERS_H_
#define _WIAHELPERS_H_

//////////////////////////////////////////////////////////////////////////
//
// cross references
//

#include "ComWrappers.h"
#include "WiaWrappers.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

class CMyWiaPropertyStorage : public IWiaPropertyStorage
{
public:
    HRESULT 
    ReadSingle(
        const CPropSpec &PropSpec, 
        CPropVariant    *pPropVariant
    )
    {
        return ReadMultiple(1, &PropSpec, pPropVariant);
    }

    HRESULT 
    WriteSingle(
        const CPropSpec    &PropSpec, 
        const CPropVariant &PropVariant,
        PROPID              propidNameFirst = WIA_IPA_FIRST
    )
    {
        return WriteMultiple(1, &PropSpec, &PropVariant, propidNameFirst);
    }

    HRESULT 
    ReadSingle(
        const CPropSpec &PropSpec, 
        CPropVariant    *pPropVariant,
        VARTYPE          vtNew
    );

    HRESULT 
    WriteVerifySingle(
        const CPropSpec    &PropSpec, 
        const CPropVariant &PropVariant,
        PROPID              propidNameFirst = WIA_IPA_FIRST
    );
};

HRESULT
ReadWiaItemProperty(
    IWiaItem        *pWiaItem,
    const CPropSpec &PropSpec, 
    CPropVariant    *pPropVariant,
    VARTYPE          vtNew
);

HRESULT
WriteWiaItemProperty(
    IWiaItem           *pWiaItem,
    const CPropSpec    &PropSpec, 
    const CPropVariant &PropVariant
);

//////////////////////////////////////////////////////////////////////////
//
//
//
bool operator ==(IWiaPropertyStorage &lhs, IWiaPropertyStorage &rhs);

inline bool operator !=(IWiaPropertyStorage &lhs, IWiaPropertyStorage &rhs)
{
    return !(lhs == rhs);
}

bool operator ==(IWiaItem &lhs, IWiaItem &rhs);

inline bool operator !=(IWiaItem &lhs, IWiaItem &rhs)
{
    return !(lhs == rhs);
}

//////////////////////////////////////////////////////////////////////////
//
// define these classes to be able to overload the == and != operators 
//

class CIWiaPropertyStoragePtr : public CComPtr<IWiaPropertyStorage>
{
public:
    bool operator ==(CIWiaPropertyStoragePtr &rhs)
    {
        return **this == *rhs;
    }

    bool operator !=(CIWiaPropertyStoragePtr &rhs)
    {
        return !(**this == *rhs);
    }
};

class CIWiaItemPtr : public CComPtr<IWiaItem>
{
public:
    bool operator ==(CIWiaItemPtr &rhs)
    {
        return **this == *rhs;
    }

    bool operator !=(CIWiaItemPtr &rhs)
    {
        return !(**this == *rhs);
    }
};

//////////////////////////////////////////////////////////////////////////
//
// 
//

class CMyEnumSTATPROPSTG : public IEnumSTATPROPSTG
{
public:
    HRESULT GetCount(ULONG *pcelt);
    HRESULT Clone(CMyEnumSTATPROPSTG **ppenum);
};

//////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL 
InstallImageDeviceFromInf(
    PCTSTR pInfFileName,
    PCTSTR pDeviceName = 0
);

HRESULT
InstallTestDevice(
    IWiaDevMgr *pWiaDevMgr, 
    PCTSTR      pInfFileName, 
    BSTR       *pbstrDeviceId
);

#endif //_WIAHELPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\tostr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ToStr.h

Abstract:


Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _TOSTR_H_
#define _TOSTR_H_

#include "Wrappers.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

class CAutoStr : public CHandle<PTSTR, CAutoStr>
{
public:
    explicit CAutoStr(int nLength)
    {
        Attach(new TCHAR[nLength]);
        m_bShouldFree = TRUE;
    }

    CAutoStr(PCTSTR pszStr)
    {
        Attach(const_cast<PTSTR>(pszStr));
        m_bShouldFree = FALSE;
    }

	void Destroy()
	{
        if (m_bShouldFree)
        {
            delete [] *this;
        }
	}

	bool IsValid() 
	{
		return *this != 0;
	}

private:
    BOOL  m_bShouldFree;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

CAutoStr ToStr(const void *Value, VARTYPE vt);
CAutoStr IntToStr(int Value);
CAutoStr Int64ToStr(__int64 Value);
CAutoStr FloatToStr(float Value);
CAutoStr DoubleToStr(double Value);
CAutoStr SzToStr(PCSTR Value);
CAutoStr WSzToStr(PCWSTR Value);
CAutoStr GuidToStr(REFGUID Value);
CAutoStr TymedToStr(TYMED Value);
CAutoStr DeviceTypeToStr(STI_DEVICE_MJ_TYPE Value);
CAutoStr ButtonIdToStr(int Value);
CAutoStr HResultToStr(HRESULT Value);
CAutoStr VarTypeToStr(VARTYPE Value);
CAutoStr PropVariantToStr(PROPVARIANT Value);
CAutoStr WiaCallbackReasonToStr(ULONG Value);
CAutoStr WiaCallbackStatusToStr(ULONG Value);

//////////////////////////////////////////////////////////////////////////
//
//
//

template <class T> inline CAutoStr ToStr(const T &Value)
{
    ASSERT(FALSE);
    return _T("");
}

template <> inline CAutoStr ToStr(const int &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const unsigned int &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const long &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const unsigned long &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const short &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const unsigned short &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const char &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const unsigned char &Value)
{
    return IntToStr(Value);
}

template <> inline CAutoStr ToStr(const float &Value)
{
    return FloatToStr(Value);
}

template <> inline CAutoStr ToStr(const double &Value)
{
    return DoubleToStr(Value);
}

template <> inline CAutoStr ToStr(const PCSTR &Value)
{
    return SzToStr(Value);
}

template <> inline CAutoStr ToStr(const PCWSTR &Value)
{
    return WSzToStr(Value);
}

template <> inline CAutoStr ToStr(const GUID &Value)
{
    return GuidToStr(Value);
}

template <> inline CAutoStr ToStr(const PROPVARIANT &Value)
{
    return PropVariantToStr(Value);
}



#endif //_TOSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\wiawrappers.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    WiaWrappers.h

Abstract:


Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _WIAWRAPPERS_H_
#define _WIAWRAPPERS_H_

//////////////////////////////////////////////////////////////////////////
//
//
//

class CWiaDevCap : public WIA_DEV_CAP
{
public:
    CWiaDevCap()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CWiaDevCap()
    {
        SysFreeString(bstrName);
        SysFreeString(bstrDescription);
        SysFreeString(bstrIcon);
        SysFreeString(bstrCommandline);
    }

public:
    bool operator ==(const CWiaDevCap &rhs)
    {
        return
            ulFlags == rhs.ulFlags &&
            guid    == rhs.guid    &&
            wcssafecmp(bstrName,        rhs.bstrName)        == 0 &&
            wcssafecmp(bstrDescription, rhs.bstrDescription) == 0 &&
            wcssafecmp(bstrIcon,        rhs.bstrIcon)        == 0 &&
            wcssafecmp(bstrCommandline, rhs.bstrCommandline) == 0;
    }

    bool operator !=(const CWiaDevCap &rhs)
    {
        return !(*this == rhs);
    }
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CWiaFormatInfo : public WIA_FORMAT_INFO
{
public:
    CWiaFormatInfo()
    {
        guidFormatID = GUID_NULL;
        lTymed       = TYMED_NULL;
    }

    CWiaFormatInfo(
        const GUID *pguidFormatID,
        LONG        _lTymed
    )
    {
        guidFormatID = pguidFormatID ? *pguidFormatID : GUID_NULL;
        lTymed       = _lTymed;
    }

public:
    bool operator ==(const CWiaFormatInfo &rhs)
    {
        return
            lTymed       == rhs.lTymed &&
            guidFormatID == rhs.guidFormatID;
    }

    bool operator !=(const CWiaFormatInfo &rhs)
    {
        return !(*this == rhs);
    }
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CWiaDataTransferInfo : public WIA_DATA_TRANSFER_INFO
{
public:
    CWiaDataTransferInfo(
        ULONG _ulSection,
        ULONG _ulBufferSize,
        BOOL  _bDoubleBuffer
    )
    {
        ulSize        = sizeof(WIA_DATA_TRANSFER_INFO);
        ulSection     = _ulSection;
        ulBufferSize  = _ulBufferSize;
        bDoubleBuffer = _bDoubleBuffer;
        ulReserved1   = 0;
        ulReserved2   = 0;
        ulReserved3   = 0;
    }
};


#endif //_WIAWRAPPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\wiastress.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    WiaStress.cpp

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "stdafx.h"

#include "WiaStress.h"

//////////////////////////////////////////////////////////////////////////
//
// 
//

#define DEFAULT_WIASTRESS_TIMEOUT (1i64 * 3 * 60 * 1000 * 1000 * 10)

//////////////////////////////////////////////////////////////////////////
//
// bugbug: hardcoded globals
//

TCHAR g_szGetResultsPipeName[] = _T("\\\\hakkib\\pipe\\WIAStress_GetResults");
TCHAR g_szSetResultsPipeName[] = _T("\\\\hakkib\\pipe\\WIAStress_SetResults");
TCHAR g_szCollectLogsDirName[] = _T("\\\\hakkib\\WIAStressLogs");

CBvtLog::COwners g_Owners = 
{
    /*PCTSTR pTestName      = */ _T("WiaStress"),
    /*PCTSTR pContactName   = */ _T("hakkib"),
    /*PCTSTR pMgrName       = */ _T("hakkib"),
    /*PCTSTR pDevPrimeName  = */ _T("hakkib"),
    /*PCTSTR pDevAltName    = */ _T("hakkib"),
    /*PCTSTR pTestPrimeName = */ _T("hakkib"),
    /*PCTSTR pTestAltName   = */ _T("hakkib")
};

//////////////////////////////////////////////////////////////////////////
//
// Usage string
//

TCHAR g_szUsage[] = 
    _T("Optional command line arguments:\n")
    _T("\n")
    _T("/s\t\tRun in stress test mode\n")
    _T("/bvt\t\tRun in BVT mode\n")
    _T("/threads <#>\tNumber of threads (default = 1)\n")
    _T("/wait <#>\t\tMilliseconds to wait between tests (default = 0)\n")
    _T("/case <#>\tRun only specified test case\n")
    _T("/good\t\tRun only good parameter tests\n")
    _T("/repeat\t\tRepeat the tests in a loop\n")
    _T("/noui\t\tDo no display the UI, output to console only\n")
    _T("/frames\t\tSave stack frame on memory allocations\n")
    _T("/alloc <#>\tMemory allocation scheme\n")
    _T("\t\t(0=no guard, 1=guard tail, 2=guard head)\n")
    _T("/ntlog <file>\tLog using ntlog.dll\n")
    _T("/lorlog <file>\tLog using lorlog32.dll\n")
    _T("/bvtlog <file>\tLog in Windows 2000 BVT format\n")
    _T("");

//////////////////////////////////////////////////////////////////////////
//
// 
//

BOOL WINAPI ControlHandler(DWORD dwCtrlType)
{
    g_LogWindow.Close();

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

int
RunWiaStress()
{
    // parse the command line arguments (if any)

    BOOL    bStressMode       = FALSE;
    BOOL    bBVTMode          = FALSE;
    BOOL    bRunBadParamTests = TRUE;
    BOOL    bRepeatTest       = FALSE;
    int     nThreads          = 1;
    int     nSleepAmount      = 0;
    int     nRunSingle        = 0;
    int     nGuardFlags       = CGuardAllocator::GUARD_TAIL;
    BOOL    bDisplayUI        = TRUE;
    PCTSTR  pLogFileName      = 0;

    INT argc;
    CGlobalMem<PTSTR> argv = CommandLineToArgv(GetCommandLine(), &argc);

    for (int i = 1; i < argc; ++i)
    {
        if (_tcsicmp(argv[i], _T("/s")) == 0)
        {
            bStressMode = TRUE;
            bRepeatTest = TRUE;
        }
        else if (_tcsicmp(argv[i], _T("/bvt")) == 0)
        {
            bBVTMode = TRUE;
            bRunBadParamTests = FALSE;
        }
        else if (_tcsicmp(argv[i], _T("/threads")) == 0)
        {
            nThreads = Min(_ttoi(argv[++i]), (MAXIMUM_WAIT_OBJECTS - 1) / 2);
        }
        else if (_tcsicmp(argv[i], _T("/wait")) == 0)
        {
            nSleepAmount = _ttoi(argv[++i]);
        }
        else if (_tcsicmp(argv[i], _T("/case")) == 0)
        {
            nRunSingle = _ttoi(argv[++i]);
        }
        else if (_tcsicmp(argv[i], _T("/good")) == 0)
        {
            bRunBadParamTests = FALSE;
        }
        else if (_tcsicmp(argv[i], _T("/repeat")) == 0)
        {
            bRepeatTest = TRUE;
        }
        else if (_tcsicmp(argv[i], _T("/noui")) == 0)
        {
            bDisplayUI = FALSE;
        }
        else if (_tcsicmp(argv[i], _T("/frames")) == 0)
        {
            nGuardFlags |= CGuardAllocator::SAVE_STACK_FRAMES;
        }
        else if (_tcsicmp(argv[i], _T("/alloc")) == 0)
        {
            nGuardFlags &= ~CGuardAllocator::GUARD_FLAGS;
            nGuardFlags |= _ttoi(argv[++i]);
        }
        else if (_tcsicmp(argv[i], _T("/ntlog")) == 0)
        {
            pLogFileName = argv[++i];
            g_pLog = (CLog *) new CNtLog(pLogFileName, TLS_LOGALL);
        }
        else if (_tcsicmp(argv[i], _T("/lorlog")) == 0)
        {
            USES_CONVERSION;

            pLogFileName = argv[++i];
            g_pLog = (CLog *) new CLorLog(T2A(pLogFileName), ".", LOG_NEW, 0, 0);
        }
        else if (_tcsicmp(argv[i], _T("/bvtlog")) == 0)
        {
            pLogFileName = argv[++i];
            g_pLog = (CLog *) new CBvtLog(&g_Owners, pLogFileName);
        }
        else
        {
            return MessageBox(0, g_szUsage, _T("WiaStress"), MB_ICONINFORMATION | MB_OK);
        }
    }


    // initialize memory allocation scheme

    g_GuardAllocator.SetGuardType(nGuardFlags);

    // set up the output window / logging system

    g_LogWindow.ReadSavedData(g_szGetResultsPipeName);

    if (bDisplayUI)
    {
        g_LogWindow.Create(
            _T("WIA Stress"),
            GetConsoleHwnd(), 
            LoadIcon(0, IDI_APPLICATION),
            3000
        );

        g_pLog->SetLogWindow(&g_LogWindow);
    }
    else
    {
        g_LogWindow.Close(false);

    	SetConsoleCtrlHandler(ControlHandler, TRUE);
    }

    // set up the who-run-when logging

    if (bStressMode && pLogFileName)
    {
        static CLogCollector RunInBackground(pLogFileName, g_szCollectLogsDirName);
    }


    // launch the threads

    CCppMem<CWiaStressThread> Threads(nThreads);
    CMultipleWait             Handles(1 + nThreads + nThreads);

    Handles[0] = g_LogWindow.GetWaitHandle();

    for (int nThread = 0; nThread < nThreads; ++nThread) 
    {
        Threads[nThread] = CWiaStressThread(
            bStressMode, 
            bBVTMode, 
            bRunBadParamTests, 
            bRepeatTest,
            nSleepAmount, 
            nRunSingle, 
            nThread
        );

        Handles[1 + nThread] = Threads[nThread].m_ThreadObject;

        Handles[1 + nThreads + nThread] = Threads[nThread].m_TimeoutTimer;
    }


    // wait until all threads have terminated and the user has closed the window

    Event NotSignalled(TRUE, FALSE);

    int nRunningThreads = nThreads;

    while (nRunningThreads > 0 || bDisplayUI == TRUE)
    {
        DWORD dwWaitResult = Handles.WaitFor(FALSE);

        if (dwWaitResult == WAIT_OBJECT_0)
        {
            // user has closed the window or pressed ctrl+c

            Handles[dwWaitResult - WAIT_OBJECT_0] = NotSignalled;

            bDisplayUI = FALSE;
        }
        else if (dwWaitResult < 1 + nThreads + WAIT_OBJECT_0)
        {
            // one of the test threads has exited

            Handles[dwWaitResult - WAIT_OBJECT_0] = NotSignalled;

            nRunningThreads -= 1;
        }
        else if (dwWaitResult < 1 + 2 * nThreads + WAIT_OBJECT_0)
        {
            // one of the test threads has timed out

            int nHungThread = dwWaitResult - WAIT_OBJECT_0 - nThreads - 1;

            //***bugbug:TerminateThread(Threads[nHungThread].m_ThreadObject, 0);

            g_pLog->Log(
                TLS_ABORT | TLS_DEBUG | TLS_VARIATION, 
                0, 
                nHungThread, 
                _T("Thread was not responding, terminated")
            );

            // forget about this thread

            Handles[1 + nHungThread] = NotSignalled;

            nRunningThreads -= 1;
        }
    }


    // write the modified comments (if any) to the central database

    g_LogWindow.WriteModifiedData(g_szSetResultsPipeName);

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CWiaStressThread::CWiaStressThread(
    BOOL    bStressMode,
    BOOL    bBVTMode,
    BOOL    bRunBadParamTests,
    BOOL    bRepeatTest,
    DWORD   nSleepAmount,
    int     nRunSingle,
    LONG    nThread
) : 
    m_bStressMode(bStressMode),
    m_bBVTMode(bBVTMode),
    m_bRunBadParamTests(bRunBadParamTests),
    m_bRepeatTest(bRepeatTest),
    m_nSleepAmount(nSleepAmount),
    m_nRunSingle(nRunSingle),
    m_nThread(nThread),
    m_pszContext(0),
    m_TimeoutTimer(FALSE),
    m_ThreadObject(ThreadProc, this)
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//

unsigned WINAPI CWiaStressThread::ThreadProc(PVOID pVoid)
{
    CWiaStressThread *that = (CWiaStressThread *) pVoid;

    // init

    g_pLog->InitThread();

	that->LOG_INFO(_T("Starting thread"));

    srand(GetTickCount());

    HRESULT hr = CoInitializeEx(0, COINIT_APARTMENTTHREADED);

    if (hr != S_OK) 
    {
        return FALSE;
    }

    // run

    do 
    {
        try 
        {
            CHECK_HR(that->m_pWiaDevMgr.CoCreateInstance(CLSID_WiaDevMgr));

            that->RunAllTests();
        } 
        catch (const CError &Error) 
        {
            if (Error.Num() == WIA_ERROR_BUSY)
            {
                that->LOG_INFO(_T("Device busy, test aborted"));
            }
            else
            {
                Error.Print(CLogHelper<TLS_SEV1 | TLS_DEBUG | TLS_VARIATION>());
            }

            that->m_pszContext = 0;
        }

        that->m_pWiaDevMgr.Release();
    }
    while (
        that->m_bRepeatTest && 
        g_LogWindow.WaitForSingleObject(that->m_nSleepAmount) == WAIT_TIMEOUT
    );

    // uninit

    CoUninitialize();

	that->LOG_INFO(_T("Exiting thread"));

    g_pLog->DoneThread();

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::RunAllTests()
{
    CheckWiaDeviceAvailibility();

    INIT_STRESS(18);

    //
    // TestIWiaDevMgr
    //

    IF_SELECTED RunTest(TestEnumDeviceInfo); 
    IF_SELECTED RunTest(TestCreateDevice);
    IF_SELECTED RunTest(TestSelectDeviceDlg);
    //IF_SELECTED RunTest(TestRegisterEventCallbackInterface);

    //
    // TestIWiaDataTransfer
    //

    IF_SELECTED RunTestForEachDevice(TestGetData, TRUE); 
    IF_SELECTED RunTestForEachDevice(TestQueryData, TRUE);
    IF_SELECTED RunTestForEachDevice(TestEnumWIA_FORMAT_INFO, TRUE);

    //
    // TestIWiaItem
    //

    IF_SELECTED RunTestForEachDevice(TestGetItemType, TRUE);
    IF_SELECTED RunTestForEachDevice(TestEnumChildItems, TRUE);
    IF_SELECTED RunTestForEachDevice(TestCreateChildItem, TRUE);
    IF_SELECTED RunTestForEachDevice(TestEnumRegisterEventInfo, FALSE);
    IF_SELECTED RunTestForEachDevice(TestFindItemByName, TRUE);
    IF_SELECTED RunTestForEachDevice(TestDeviceDlg, FALSE);
    IF_SELECTED RunTestForEachDevice(TestGetRootItem, TRUE);
    IF_SELECTED RunTestForEachDevice(TestEnumDeviceCapabilities, FALSE);

    //
    // TestIWiaPropertyStorage
    //

    IF_SELECTED RunTestForEachDevice(TestPropStorage, TRUE);
    IF_SELECTED RunTestForEachDevice(TestPropGetCount, TRUE);
    IF_SELECTED RunTestForEachDevice(TestReadPropertyNames, TRUE);
    IF_SELECTED RunTestForEachDevice(TestEnumSTATPROPSTG, TRUE);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

BOOL CWiaStressThread::CheckWiaDeviceAvailibility()
{
    CComPtr<IEnumWIA_DEV_INFO> pEnumWIA_DEV_INFO;

    CHECK_HR(m_pWiaDevMgr->EnumDeviceInfo(0, &pEnumWIA_DEV_INFO));

    ULONG nDevices = -1;

    CHECK_HR(pEnumWIA_DEV_INFO->GetCount(&nDevices));

    if (nDevices == 0)
    {
        if (
            m_bStressMode || 
            MessageBox(
                0, 
                _T("No WIA devices available.\n")
                _T("Do you want to install a test device?"), 
                0, 
                MB_ICONQUESTION | MB_YESNO
            ) == IDYES
        )
        {
            LOG_INFO(_T("No WIA devices available, installing test device"));

            CModuleFileName strPathName(0);

            PTSTR pszExeName = FindFileNamePortion(strPathName);

            _tcscpy(pszExeName, _T("scanner\\testscan.inf"));

            CHECK_HR(InstallTestDevice(m_pWiaDevMgr, strPathName, 0));
        }
        else
        {
            g_pLog->Log(
                TLS_BLOCK | TLS_VARIATION, 
                0, 
                0, 
                _T("No WIA devices available, test results will not be meaningful")
            );
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void CWiaStressThread::RunTest(PFNWIACALLBACK Callback)
{
    if (g_LogWindow.IsClosed())
    {
        return;
    }

    g_pLog->StartBlock(_T("TEST CASE"));

    g_pLog->StartVariation();

    if (m_bStressMode)
    {
        m_TimeoutTimer.Set(-DEFAULT_WIASTRESS_TIMEOUT);
    }

    try
    {
        (this->*Callback)();
    }
    catch (const CError &Error)
    {
        if (Error.Num() == WIA_ERROR_BUSY)
        {
            LOG_INFO(_T("Device busy, test aborted"));
        }
        else
        {
            Error.Print(CLogHelper<TLS_SEV1 | TLS_DEBUG | TLS_VARIATION>());
        }

        m_pszContext = 0;
    }

    g_pLog->Log(
        TLS_NOCONSOLE | TLS_VARIATION | g_pLog->EndVariation(), 
        m_pszContext, 
        m_nThread, 
        _T("Test complete")
    );

    g_pLog->EndBlock(_T("TEST CASE"));

    m_TimeoutTimer.Cancel();
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void
CWiaStressThread::RunTestForEachDevice(
    PFNWIAITEMCALLBACK  Callback, 
    BOOL                bEnumChildItems
)
{
    if (g_LogWindow.IsClosed())
    {
        return;
    }

    g_pLog->StartBlock(_T("TEST CASE"));

    g_pLog->StartVariation();
     
    try
    {
         // enumerate all devices

        CComPtr<IEnumWIA_DEV_INFO> pEnumWIA_DEV_INFO;

        CHECK_HR(m_pWiaDevMgr->EnumDeviceInfo(StiDeviceTypeDefault, &pEnumWIA_DEV_INFO));

        ULONG nDevices;

        CHECK_HR(pEnumWIA_DEV_INFO->GetCount(&nDevices));

        // for the stress tests, use a random device. Otherwise, try all devices

        ULONG __nSelected = m_bStressMode && nDevices ? rand() % nDevices : 0;
        ULONG __nFrom     = m_bStressMode ? __nSelected : 0;
        ULONG __nTo       = m_bStressMode ? Min(__nSelected + 1, nDevices) : nDevices;
    
        for (ULONG i = __nFrom; i < __nTo; ++i)
        {
            // get the next device

            CComPtr<CMyWiaPropertyStorage> pProp;

            CHECK_HR(pEnumWIA_DEV_INFO->Next(1, (IWiaPropertyStorage **) &pProp, 0));

            // read the device id

            CPropVariant varDeviceID;

            CHECK_HR(pProp->ReadSingle(WIA_DIP_DEV_ID, &varDeviceID, VT_BSTR));

            // create the wiaitem

            CComPtr<IWiaItem> pWiaRootItem;

            CHECK_HR(m_pWiaDevMgr->CreateDevice(varDeviceID.bstrVal, &pWiaRootItem));

            // invoke the callback function

            CParentsList ParentsList;

            CWiaItemData ItemData(pWiaRootItem, ParentsList);

            RunTest(&ItemData, Callback);

            // continue enumeration with child items

            if (bEnumChildItems)
            {
                RunTestForEachChildItem(pWiaRootItem, Callback, ParentsList);
            }
        }
    }
    catch (const CError &Error)
    {
        if (Error.Num() == WIA_ERROR_BUSY)
        {
            LOG_INFO(_T("Device busy, test aborted"));
        }
        else
        {
            Error.Print(CLogHelper<TLS_SEV1 | TLS_DEBUG | TLS_VARIATION>());
        }
    }

    g_pLog->Log(
        TLS_NOCONSOLE | TLS_VARIATION | g_pLog->EndVariation(), 
        m_pszContext, 
        m_nThread, 
        _T("Test complete")
    );

    g_pLog->EndBlock(_T("TEST CASE"));
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void
CWiaStressThread::RunTestForEachChildItem(
    IWiaItem           *pWiaItem, 
    PFNWIAITEMCALLBACK  Callback, 
    CParentsList        ParentsList
)
{
    ParentsList.push_back(pWiaItem);

    // enumerate all child items

    CComPtr<IEnumWiaItem> pEnumWiaItem;

    CHECK_HR(pWiaItem->EnumChildItems(&pEnumWiaItem));

    ULONG nChildItems;

    CHECK_HR(pEnumWiaItem->GetCount(&nChildItems));

    FOR_SELECTED(i, nChildItems) 
    {
        // get next item

        CComPtr<IWiaItem> pWiaItem;

        CHECK_HR(pEnumWiaItem->Next(1, &pWiaItem, 0));

        // invoke the callback function

        CWiaItemData ItemData(pWiaItem, ParentsList);

        RunTest(&ItemData, Callback);

        // continue enumeration if this is a folder

        if (ItemData.lItemType & WiaItemTypeFolder)
        {
            RunTestForEachChildItem(pWiaItem, Callback, ParentsList);
        }
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

void
CWiaStressThread::RunTest(
    CWiaItemData       *pItemData,
    PFNWIAITEMCALLBACK  Callback
)
{
    if (m_bStressMode)
    {
        m_TimeoutTimer.Set(-DEFAULT_WIASTRESS_TIMEOUT);
    }

    try
    {
        (this->*Callback)(pItemData);
    }
    catch (const CError &Error)
    {
        if (Error.Num() == WIA_ERROR_BUSY)
        {
            LOG_INFO(_T("Device busy, test aborted"));
        }
        else
        {
            Error.Print(CLogHelper<TLS_SEV1 | TLS_DEBUG | TLS_VARIATION>());
        }

        m_pszContext = 0;
    }

    m_TimeoutTimer.Cancel();
}

//////////////////////////////////////////////////////////////////////////
//
//
//

CWiaStressThread::CWiaItemData::CWiaItemData(
    IWiaItem           *_pWiaItem,
    const CParentsList &_ParentsList
) :
    pWiaItem(_pWiaItem),
    ParentsList(_ParentsList)
{
    // get item type

    CHECK_HR(pWiaItem->GetItemType(&lItemType));

    // get the full item name

    CPropVariant varFullItemName;

    CHECK_HR(ReadWiaItemProperty(
        pWiaItem, 
        WIA_IPA_FULL_ITEM_NAME, 
        &varFullItemName, 
        VT_BSTR
    ));

    bstrFullName = varFullItemName.bstrVal;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

int
RunProgram()
{
    try
    {
        return RunWiaStress();
    }
    catch (const CError &Error)
    {
        return Error.Print(CLogHelper<TLS_SEV1 | TLS_DEBUG | TLS_VARIATION>());
    }
}

//////////////////////////////////////////////////////////////////////////
//
//
//

VOID
DumpStack(LPEXCEPTION_POINTERS pExceptionPointers)
{
    HANDLE hProcess = GetCurrentProcess();

    SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_LINES);
    SymInitialize(hProcess, 0, TRUE);

    const int nBufferSize = 4096;
    CHAR Buffer[nBufferSize];

    CStackFrame StackFrame(pExceptionPointers->ContextRecord);

    for (int i = 0; i < 30 && StackFrame.Walk(); ++i)
    {
        StackFrame.Dump(hProcess, Buffer, nBufferSize);

        OutputDebugStringA(Buffer);
    }

    SymCleanup(hProcess);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

int
RunProgramSEH()
{
    __try
    {
        RunProgram();
    }
    __except(DumpStack(GetExceptionInformation()), EXCEPTION_CONTINUE_SEARCH)
    {
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

extern "C"
int 
WINAPI 
_tWinMain(
    HINSTANCE /*hInstance*/,
    HINSTANCE /*hPrevInstance*/,
    PSTR      /*pCmdLine*/,
    int       /*nCmdShow*/
)
{
    return RunProgram();
}

//////////////////////////////////////////////////////////////////////////
//
//
//

extern "C" int __cdecl _tmain()
{
    return RunProgram();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\wiahelpers.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    WiaHelpers.cpp

Abstract:

    

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#include "StdAfx.h"

#include "WiaHelpers.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT 
CMyWiaPropertyStorage::ReadSingle(
    const CPropSpec &PropSpec, 
    CPropVariant    *pPropVariant,
    VARTYPE          vtNew
)
{
    HRESULT hr;

    hr = ReadSingle(PropSpec, pPropVariant);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = pPropVariant->ChangeType(vtNew);

    if (hr != S_OK)
    {
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT 
CMyWiaPropertyStorage::WriteVerifySingle(
    const CPropSpec    &PropSpec, 
    const CPropVariant &PropVariant,
    PROPID              propidNameFirst /*= WIA_IPA_FIRST*/
)
{
    HRESULT hr;

    hr = WriteSingle(PropSpec, PropVariant, propidNameFirst);

    if (hr != S_OK)
    {
        return hr;
    }

    CPropVariant var;

    hr = ReadSingle(PropSpec, &var, PropVariant.vt);

    if (hr != S_OK)
    {
        return hr;
    }

    if (PropVariant != var)
    {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
ReadWiaItemProperty(
    IWiaItem        *pWiaItem,
    const CPropSpec &PropSpec, 
    CPropVariant    *pPropVariant,
    VARTYPE          vtNew
)
{
    CComQIPtr<CMyWiaPropertyStorage, &IID_IWiaPropertyStorage> pProp(pWiaItem);

    if (pProp == 0) 
    {
        return E_NOINTERFACE;
    }

    return pProp->ReadSingle(PropSpec, pPropVariant, vtNew);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
WriteWiaItemProperty(
    IWiaItem           *pWiaItem,
    const CPropSpec    &PropSpec, 
    const CPropVariant &PropVariant
)
{
    CComQIPtr<CMyWiaPropertyStorage, &IID_IWiaPropertyStorage> pProp(pWiaItem);

    if (pProp == 0) 
    {
        return E_NOINTERFACE;
    }

    return pProp->WriteSingle(PropSpec, PropVariant);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

bool operator ==(IWiaPropertyStorage &lhs, IWiaPropertyStorage &rhs)
{
    // if their interface pointers are equal, the objects are equal

    if (&lhs == &rhs)
    {
        return true;
    }

    // if not, we'll enumerate and compare each property

    HRESULT hr;

    CComPtr<IEnumSTATPROPSTG> pEnumSTATPROPSTG;

    hr = lhs.Enum(&pEnumSTATPROPSTG);

    if (hr != S_OK)
    {
        return false;
    }

    while (1)
    {
        // get next property name

        CStatPropStg StatPropStg;

        hr = pEnumSTATPROPSTG->Next(1, &StatPropStg, 0);

        if (hr != S_OK)
        {
            break;
        }

        // read that property from the left object

        CPropSpec PropSpec(StatPropStg.propid);

        CPropVariant varLhs;

        hr = lhs.ReadMultiple(1, &PropSpec, &varLhs);

        if (hr != S_OK)
        {
            return false;
        }

        // read that property from the right object

        CPropVariant varRhs;

        hr = rhs.ReadMultiple(1, &PropSpec, &varRhs);

        if (hr != S_OK)
        {
            return false;
        }

        // those two should be equal

        if (varLhs != varRhs)
        {
            return false;
        }
    }

    // the enumeration should have ended with S_FALSE

    if (hr != S_FALSE)
    {
        return false;
    }

    // bugbug: this compares each property on the lhs against each one on the rhs
    // We should maybe do another pass and compare the other way; each property 
    // on the rhs against each one on the lhs...

    return true;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

bool operator ==(IWiaItem &lhs, IWiaItem &rhs)
{
    // if their interface pointers are equal, the objects are equal

    if (&lhs == &rhs)
    {
        return true;
    }

    // if not, we will compare the properties of the items
    // bugbug: is this good enough?

    HRESULT hr;

    CComPtr<IWiaPropertyStorage> pLhsPropertyStorage;
    hr = lhs.QueryInterface(IID_IWiaPropertyStorage, (void **)&pLhsPropertyStorage);

    if (hr != S_OK) 
    {
        return false;
    }

    CComPtr<IWiaPropertyStorage> pRhsPropertyStorage;
    hr = rhs.QueryInterface(IID_IWiaPropertyStorage, (void **)&pRhsPropertyStorage);

    if (hr != S_OK) 
    {
        return false;
    }

    return *pLhsPropertyStorage == *pRhsPropertyStorage;
}

//////////////////////////////////////////////////////////////////////////
//
//
//

HRESULT
InstallTestDevice(
    IWiaDevMgr *pWiaDevMgr, 
    PCTSTR      pInfFileName, 
    BSTR       *pbstrDeviceId
)
{
    try
    {
        // get the model name of the device 

        CInf InfFile(pInfFileName);

        INFCONTEXT InfContext;

        CHECK(SetupFindFirstLine(InfFile, _T("Manufacturer"), 0, &InfContext));

        TCHAR szModelsSectionName[MAX_DEVICE_ID_LEN];

        CHECK(SetupGetStringField(&InfContext, 1, szModelsSectionName, COUNTOF(szModelsSectionName), 0));

        CHECK(SetupFindFirstLine(InfFile, szModelsSectionName, 0, &InfContext));

        TCHAR szModelName[MAX_DEVICE_ID_LEN];

        CHECK(SetupGetStringField(&InfContext, 0, szModelName, COUNTOF(szModelName), 0));

        GUID guid;

        CHECK_HR(CoCreateGuid(&guid));

        WCHAR szGuid[MAX_GUID_STRING_LEN];

        CHECK(StringFromGUID2(guid, szGuid, COUNTOF(szGuid)));

        TCHAR szDeviceName[1024]; //bugbug: fixed size buffer

        _stprintf(szDeviceName, _T("WIA Stress %ws"), szGuid);

        USES_CONVERSION;

        PCWSTR pwszDeviceName = T2W(szDeviceName);

        // install the device

        CHECK(InstallImageDeviceFromInf(pInfFileName, szDeviceName));

        BOOL bFoundDeviceInstance = FALSE;
        BOOL nRetries = 3;

        for (;;)
        {
            // find this device among the installed WIA devices

            CComPtr<IEnumWIA_DEV_INFO> pEnumWIA_DEV_INFO;

            CHECK_HR(pWiaDevMgr->EnumDeviceInfo(0, &pEnumWIA_DEV_INFO));

            ULONG nDevices = -1;

            CHECK_HR(pEnumWIA_DEV_INFO->GetCount(&nDevices));

            for (int i = 0; i < nDevices; ++i) 
            {
                CComPtr<CMyWiaPropertyStorage> pProp;

                CHECK_HR(pEnumWIA_DEV_INFO->Next(1, (IWiaPropertyStorage **) &pProp, 0));

                CPropVariant varDeviceDesc;

                CHECK_HR(pProp->ReadSingle(WIA_DIP_DEV_DESC, &varDeviceDesc, VT_BSTR));

                if (wcscmp(varDeviceDesc.bstrVal, pwszDeviceName) == 0)
                {
                    bFoundDeviceInstance = TRUE;

                    if (pbstrDeviceId != 0)
                    {
                        CPropVariant varDeviceID;

                        CHECK_HR(pProp->ReadSingle(WIA_DIP_DEV_ID, &varDeviceID, VT_BSTR));

                        *pbstrDeviceId = SysAllocString(varDeviceID.bstrVal);
                    }
                }
            }

            if (bFoundDeviceInstance)
            {
                return S_OK;
            }

            if (--nRetries == 0)
            {
                return E_FAIL;
            }

            Sleep(2500);
        }
    }
    catch (const CError &Error)
    {
        return HRESULT_FROM_WIN32(Error.Num());
    }
}


//////////////////////////////////////////////////////////////////////////
//
// 
//

HRESULT CMyEnumSTATPROPSTG::GetCount(ULONG *pcelt)
{
    if (pcelt == 0)
    {
        return E_INVALIDARG;
    }

    *pcelt = 0;

    HRESULT hr;

    CComPtr<CMyEnumSTATPROPSTG> pClone;

    hr = Clone(&pClone);

    if (hr != S_OK)
    {
        return hr;
    }

    hr = pClone->Reset();

    if (hr != S_OK)
    {
        return hr;
    }

    while (1)
    {
        CStatPropStg StatPropStg;

        hr = pClone->Next(1, &StatPropStg, 0);

        if (hr != S_OK)
        {
            break;
        }

        ++*pcelt;
    } 

    if (hr != S_FALSE)
    {
        return hr;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
// 
//

HRESULT CMyEnumSTATPROPSTG::Clone(CMyEnumSTATPROPSTG **ppenum)
{
    return ((IEnumSTATPROPSTG *)this)->Clone((IEnumSTATPROPSTG **)ppenum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\windowsearch.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    WindowSearch.h

Abstract:


Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _WINDOWSEARCH_H_
#define _WINDOWSEARCH_H_

//////////////////////////////////////////////////////////////////////////
//
//
//

class CWindowSearch
{
public:
    CWindowSearch()
    {
        m_nMatches = -1;
        //m_hWnd = 0;
    }

    friend HWND FindChildWindow(HWND hWnd, CWindowSearch &rWindowSearch)
    {
        rWindowSearch.m_nMatches = 0;

	    EnumChildWindows(hWnd, EnumProc, (LPARAM) &rWindowSearch);

        return rWindowSearch.Result();
    }

    friend HWND WaitForChildWindow(HWND hWnd, CWindowSearch &rWindowSearch, HANDLE hBreak)
    {
        rWindowSearch.m_nMatches = 0;

        do
        {
    	    EnumChildWindows(hWnd, EnumProc, (LPARAM) &rWindowSearch);
        }
        while (rWindowSearch.m_nMatches == 0 && WaitForSingleObject(hBreak, 250) == WAIT_TIMEOUT);

        return rWindowSearch.Result();
    }

    friend HWND FindThreadWindow(DWORD dwThreadId, CWindowSearch &rWindowSearch)
    {
        rWindowSearch.m_nMatches = 0;

        EnumThreadWindows(dwThreadId, EnumProc, (LPARAM) &rWindowSearch);
        
        return rWindowSearch.Result();
    }

    friend HWND WaitForThreadWindow(DWORD dwThreadId, CWindowSearch &rWindowSearch, HANDLE hBreak)
    {
        rWindowSearch.m_nMatches = 0;

        do
        {
    	    EnumThreadWindows(dwThreadId, EnumProc, (LPARAM) &rWindowSearch);
        }
        while (rWindowSearch.m_nMatches == 0 && WaitForSingleObject(hBreak, 250) == WAIT_TIMEOUT);

        return rWindowSearch.Result();
    }

    HWND Result() const
    {
        switch (m_nMatches)
        {
        case -1:
            SetLastError(ERROR_NOT_FOUND);//ERROR_NOT_STARTED);
            return 0;

        case 0:
            SetLastError(ERROR_NOT_FOUND);
            return 0;

        case 1:
            return m_hWnd;

        default:
            SetLastError(ERROR_NOT_FOUND);//ERROR_MULTIPLE_FOUND);
            return 0;
        }        
    }

private:
    virtual BOOL TestWindow(HWND hWnd) = 0;

    static BOOL CALLBACK EnumProc(HWND hWnd, LPARAM lParam)
    {
        return ((CWindowSearch *)lParam)->TestWindow(hWnd);
    }

protected:
    int  m_nMatches;
    HWND m_hWnd;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CWindowSearchByText : public CWindowSearch
{
public:
    explicit CWindowSearchByText(PCTSTR pszText)
    {
        m_pszText = pszText;
    }

    virtual BOOL TestWindow(HWND hWnd)
    {
        if (_tcscmp(CWindowText(hWnd), m_pszText) == 0) 
        {
            ++m_nMatches;
            m_hWnd = hWnd;
        }

        return TRUE;
    }

private:
    PCTSTR m_pszText;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CWindowSearchByClass : public CWindowSearch
{
public:
    explicit CWindowSearchByClass(PCTSTR pszClass)
    {
        m_pszClass = pszClass;
    }

    virtual BOOL TestWindow(HWND hWnd)
    {
        if (_tcscmp(CClassName(hWnd), m_pszClass) == 0) 
        {
            ++m_nMatches;
            m_hWnd = hWnd;
        }

        return TRUE;
    }

private:
    PCTSTR m_pszClass;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

class CWindowSearchById : public CWindowSearch
{
public:
    explicit CWindowSearchById(int nId)
    {
        m_nId = nId;
    }

    virtual BOOL TestWindow(HWND hWnd)
    {
        if (GetDlgCtrlID(hWnd) == m_nId) 
        {
            ++m_nMatches;
            m_hWnd = hWnd;
        }

        return TRUE;
    }

private:
    int m_nId;
};

//////////////////////////////////////////////////////////////////////////
//
//
//

inline BOOL PushButton(HWND hWnd)
{
    return 
		PostMessage(hWnd, WM_LBUTTONDOWN, 0, 0) && 
		PostMessage(hWnd, WM_LBUTTONUP,   0, 0);
}

//////////////////////////////////////////////////////////////////////////
//
//
//

inline BOOL SetText(HWND hWnd, PCTSTR pText)
{
    return SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM) pText);
}

#endif //_WINDOWSEARCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\cdib.h ===
// cdib.h

#ifndef _INC_DIB
#define _INC_DIB

#define BMP_IMAGE	0
#define TIFF_IMAGE	1
//////////////////////////////////////////
//////// DIB/BMP HEADER DEFINES //////////
//////////////////////////////////////////

#define PALVERSION   0x300
#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')

// macros
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

// WIDTHBYTES performs DWORD-aligning of DIB scanlines.  The "bits"
// parameter is the bit count for the scanline (biWidth * biBitCount),
// and this macro returns the number of DWORD-aligned bytes needed
// to hold those bits.
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)

//////////////////////////////////////////
//////////////////////////////////////////

//////////////////////////////////////////
////////// TIFF HEADER DEFINES ///////////
//////////////////////////////////////////

typedef struct TIFFFILEHEADERtag {
	char	tfByteOrder[2];
	short	tfType;
	long	tfOffset;
}TIFFFILEHEADER;

typedef struct TIFFTAGtag {
	short	ttTag;
	short	ttType;
	long	ttCount;
	long	ttOffset;
}TIFFTAG;

#define TIFFBYTE unsigned int
#define TIFFASCII char*

typedef struct TIFFRATIONALtag {
	long	trNumerator;
	long	trDenominator;
}TIFFRATIONAL;

typedef struct TIFFTODIBDATAtag {
	BITMAPINFOHEADER	bmiHeader;
	TIFFRATIONAL		xResolution;
	TIFFRATIONAL		yResolution;
	long				ResolutionUnit;
	long				RowsPerStrip;
	long				StripOffsets;
	long				StripByteCounts;
	long				ColorsUsed;
	char				Software[30];
	char				Author[30];
	char				Description[30];
	long				CompressionType;
	long				*pStripOffsets;
	long				*pStripByteCountsOffsets;
	int					OffsetCount;
}TIFFTODIBDATA;

#define TIFF_NEWSUBFILETYPE		254 // long
#define TIFF_IMAGEWIDTH			256	// short or long
#define TIFF_LENGTH				257	// short or long
#define TIFF_BITSPERSAMPLE		258	// short
#define TIFF_COMPRESSION		259	// short
#define TIFF_PHOTOINTERP		262	// short
#define	TIFF_IMAGEDESCRIPTION	270	// ASCII
#define TIFF_STRIPOFFSETS		273	// short or long
#define	TIFF_ORIENTATION		274	// short
#define TIFF_SAMPLESPERPIXEL	277	// short
#define TIFF_ROWSPERSTRIP		278	// short or long
#define TIFF_STRIPBYTECOUNTS	279	// short or long
#define TIFF_XRESOLUTION		282	// TIFFRATIONAL
#define TIFF_YRESOLUTION		283	// TIFFRATIONAL
#define TIFF_RESOLUTIONUNIT		296	// short
#define TIFF_SOFTWARE			305	// ASCII

//////////////////////////////////////////
//////////////////////////////////////////

class CDib : public CObject
{
	DECLARE_DYNAMIC(CDib)

// Constructors
public:
	CDib();
	int change;

// Attributes
protected:
	LPBYTE m_pBits;
	LPBITMAPINFO m_pBMI;
public:	
	CPalette* m_pPalette;

public:
	DWORD Width()     const;
	DWORD Height()    const;
	WORD  NumColors() const;
	BOOL  IsValid()   const { return (m_pBMI != NULL); }

// Operations
public:
	BOOL  Paint(HDC, LPRECT, LPRECT) const;
	HGLOBAL CopyToHandle()           const;
	DWORD Save(CFile& file)          const;
	DWORD Read(CFile& file,int FileType);
	DWORD ReadFromHandle(HGLOBAL hGlobal);
	void Invalidate() { Free(); }

	virtual void Serialize(CArchive& ar);

// Implementation
public:
	virtual ~CDib();

protected:
	BOOL  CreatePalette();
	WORD  PaletteSize() const;
	void Free();
	BOOL Flip(BYTE* pSrcData);

public:
	void ReadFromTIFFFile(CString filename);
	void ReadFromBMPFile(LPSTR filename);
	void ReadFromBMPFile(CString filename);
	BOOL GotImage();
	BOOL ReadFromHGLOBAL(HGLOBAL hGlobal,int FileType);
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CDib& operator = (CDib& dib);
};

#endif //!_INC_DIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\cdib.cpp ===
//  Cdib.cpp
//

#include "stdafx.h"
#include "cdib.h"
#include <windowsx.h>
#include <afxadv.h>
#include <io.h>
#include <errno.h>
#include <math.h>

/////////////////////////////////////////////////////////////////////////////
// CDib

IMPLEMENT_DYNAMIC(CDib, CObject)

/**************************************************************************\
* CDib::CDib()
*
*   Constructor for CDib class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CDib::CDib()
{
    m_pBMI = NULL;
    m_pBits = NULL;
    m_pPalette = NULL;
}

/**************************************************************************\
* CDib::~CDib
*
*   Destructor for CDib class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CDib::~CDib()
{
    Free();
}

/**************************************************************************\
* CDib::Free()
*
*   Cleans the stored DIB from memory
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDib::Free()
{
    // Make sure all member data that might have been allocated is freed.
    if (m_pBits) {
        GlobalFreePtr(m_pBits);
        m_pBits = NULL;
    }
    if (m_pBMI) {
        GlobalFreePtr(m_pBMI);
        m_pBMI = NULL;
    }
    if (m_pPalette) {
        m_pPalette->DeleteObject();
        delete m_pPalette;
        m_pPalette = NULL;
    }
}

/**************************************************************************\
* CDib::Paint()
*
*   Draws a DIB to the target DC
*
*
* Arguments:
*
*   hDC - Target DC
*       lpDCRect - DC window rect
*       lpDIBRect - DIB's rect
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDib::Paint(HDC hDC, LPRECT lpDCRect, LPRECT lpDIBRect) const
{
    float lWidthVal  = 1;
    float lHeightVal = 1;

    if (!m_pBMI)
        return FALSE;

    HPALETTE hPal = NULL;           // Our DIB's palette
    HPALETTE hOldPal = NULL;        // Previous palette

    // Get the DIB's palette, then select it into DC
    if (m_pPalette != NULL) {
        hPal = (HPALETTE) m_pPalette->m_hObject;

        // Select as background since we have
        // already realized in forground if needed
        hOldPal = ::SelectPalette(hDC, hPal, TRUE);
    }

    // Make sure to use the stretching mode best for color pictures
    ::SetStretchBltMode(hDC, COLORONCOLOR);

    // Determine whether to call StretchDIBits() or SetDIBitsToDevice()
    BOOL bSuccess;
    if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDIBRect)) &&
        (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDIBRect)))
        bSuccess = ::SetDIBitsToDevice(hDC,        // hDC
                                       lpDCRect->left,             // DestX
                                       lpDCRect->top,              // DestY
                                       RECTWIDTH(lpDCRect),        // nDestWidth
                                       RECTHEIGHT(lpDCRect),       // nDestHeight
                                       lpDIBRect->left,            // SrcX
                                       (int)Height() - lpDIBRect->top - RECTHEIGHT(lpDIBRect),
                                       // SrcY
                                       0,                          // nStartScan
                                       (WORD)Height(),             // nNumScans
                                       m_pBits,                    // lpBits
                                       m_pBMI,                     // lpBitsInfo
                                       DIB_RGB_COLORS);            // wUsage
    else {
        //Window width becomes smaller than original image width
        if (RECTWIDTH(lpDIBRect) > lpDCRect->right - lpDCRect->left) {
            lWidthVal = (float)(lpDCRect->right - lpDCRect->left)/RECTWIDTH(lpDIBRect);
        }
        //Window height becomes smaller than original image height
        if (RECTHEIGHT(lpDIBRect) > lpDCRect->bottom - lpDCRect->top) {
            lHeightVal = (float)(lpDCRect->bottom - lpDCRect->top)/RECTHEIGHT(lpDIBRect);
        }
        long ScaledWidth = (int)(RECTWIDTH(lpDIBRect) * min(lWidthVal,lHeightVal));
        long ScaledHeight = (int)(RECTHEIGHT(lpDIBRect) * min(lWidthVal,lHeightVal));
        bSuccess = ::StretchDIBits(hDC,            // hDC
                                   lpDCRect->left,               // DestX
                                   lpDCRect->top,                // DestY
                                   ScaledWidth,                  // nDestWidth
                                   ScaledHeight,                 // nDestHeight
                                   lpDIBRect->left,              // SrcX
                                   lpDIBRect->top,               // SrcY
                                   RECTWIDTH(lpDIBRect),         // wSrcWidth
                                   RECTHEIGHT(lpDIBRect),        // wSrcHeight
                                   m_pBits,                      // lpBits
                                   m_pBMI,                       // lpBitsInfo
                                   DIB_RGB_COLORS,               // wUsage
                                   SRCCOPY);                     // dwROP

        // update outline areas
        // Invalidated right side rect
        RECT WindowRect;
        WindowRect.top = lpDCRect->top;
        WindowRect.left = lpDCRect->left + ScaledWidth;
        WindowRect.right = lpDCRect->right;
        WindowRect.bottom = lpDCRect->bottom;

        HBRUSH hBrush = CreateSolidBrush(GetBkColor(hDC));
        FillRect(hDC,&WindowRect,hBrush);

        // Invalidated bottom rect
        WindowRect.top = lpDCRect->top + ScaledHeight;
        WindowRect.left = lpDCRect->left;
        WindowRect.right = lpDCRect->left + ScaledWidth;
        WindowRect.bottom = lpDCRect->bottom;

        FillRect(hDC,&WindowRect,hBrush);
        DeleteObject(hBrush);
    }
    // Reselect old palette
    if (hOldPal != NULL) {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
    return bSuccess;
}

/**************************************************************************\
* CDib::CreatePalette()
*
*   Creates a valid palette using the current DIB data
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDib::CreatePalette()
{
    if (!m_pBMI)
        return FALSE;

    //get the number of colors in the DIB
    WORD wNumColors = NumColors();

    if (wNumColors != 0) {
        // allocate memory block for logical palette
        HANDLE hLogPal = ::GlobalAlloc(GHND, sizeof(LOGPALETTE) + sizeof(PALETTEENTRY)*wNumColors);

        // if not enough memory, clean up and return NULL
        if (hLogPal == 0)
            return FALSE;

        LPLOGPALETTE lpPal = (LPLOGPALETTE)::GlobalLock((HGLOBAL)hLogPal);

        // set version and number of palette entries
        lpPal->palVersion = PALVERSION;
        lpPal->palNumEntries = (WORD)wNumColors;

        for (int i = 0; i < (int)wNumColors; i++) {
            lpPal->palPalEntry[i].peRed = m_pBMI->bmiColors[i].rgbRed;
            lpPal->palPalEntry[i].peGreen = m_pBMI->bmiColors[i].rgbGreen;
            lpPal->palPalEntry[i].peBlue = m_pBMI->bmiColors[i].rgbBlue;
            lpPal->palPalEntry[i].peFlags = 0;
        }

        // create the palette and get handle to it
        if (m_pPalette) {
            m_pPalette->DeleteObject();
            delete m_pPalette;
        }
        m_pPalette = new CPalette;
        BOOL bResult = m_pPalette->CreatePalette(lpPal);
        ::GlobalUnlock((HGLOBAL) hLogPal);
        ::GlobalFree((HGLOBAL) hLogPal);
        return bResult;
    }

    return TRUE;
}

/**************************************************************************\
* CDib::Width
*
*   Returns DIB's width in pixels
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    DWORD
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
DWORD CDib::Width() const
{
    if (!m_pBMI)
        return 0;
    return m_pBMI->bmiHeader.biWidth;
}

/**************************************************************************\
* CDib::Height()
*
*   Returns DIB's height in pixels
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    DWORD
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
DWORD CDib::Height() const
{
    if (!m_pBMI)
        return 0;
    return m_pBMI->bmiHeader.biHeight;
}

/**************************************************************************\
* CDib::PaletteSize()
*
*   Returns the size of the DIB's palette
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    WORD - Palette size in bytes
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
WORD CDib::PaletteSize() const
{
    if (!m_pBMI)
        return 0;
    return NumColors() * sizeof(RGBQUAD);
}

/**************************************************************************\
* CDib::NumColors()
*
*   Returns the number of colors in DIB's palette
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    WORD - Number of colors used
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
WORD CDib::NumColors() const
{
    if (!m_pBMI)
        return 0;

    WORD wBitCount;  // DIB bit count

    //  The number of colors in the color table can be less than
    //  the number of bits per pixel allows for (i.e. lpbi->biClrUsed
    //  can be set to some value).
    //  If this is the case, return the appropriate value.

    DWORD dwClrUsed;

    dwClrUsed = m_pBMI->bmiHeader.biClrUsed;
    if (dwClrUsed != 0)
        return(WORD)dwClrUsed;

    //  Calculate the number of colors in the color table based on
    //  the number of bits per pixel for the DIB.
    wBitCount = m_pBMI->bmiHeader.biBitCount;

    // return number of colors based on bits per pixel
    switch (wBitCount) {
    case 1:
        return 2;

    case 4:
        return 16;

    case 8:
        return 256;

    default:
        return 0;
    }
}

/**************************************************************************\
* CDib::Save()
*
*   Saves the DIB to a file.
*       note: the CFile must be opened before this call is made!
*
*
* Arguments:
*
*   CFile& - Open CFile
*
* Return Value:
*
*    DWORD - Number of Bytes saved in the file
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
DWORD CDib::Save(CFile& file) const
{
    BITMAPFILEHEADER bmfHdr; // Header for Bitmap file
    DWORD dwDIBSize;

    if (m_pBMI == NULL)
        return 0;

    // Fill in the fields of the file header

    // Fill in file type (first 2 bytes must be "BM" for a bitmap)
    bmfHdr.bfType = DIB_HEADER_MARKER;  // "BM"

    // Calculating the size of the DIB is a bit tricky (if we want to
    // do it right).  The easiest way to do this is to call GlobalSize()
    // on our global handle, but since the size of our global memory may have
    // been padded a few bytes, we may end up writing out a few too
    // many bytes to the file (which may cause problems with some apps).
    //
    // So, instead let's calculate the size manually (if we can)
    //
    // First, find size of header plus size of color table.  Since the
    // first DWORD in both BITMAPINFOHEADER and BITMAPCOREHEADER conains
    // the size of the structure, let's use this.
    dwDIBSize = *(LPDWORD)&m_pBMI->bmiHeader + PaletteSize();  // Partial Calculation

    // Now calculate the size of the image
    if ((m_pBMI->bmiHeader.biCompression == BI_RLE8) || (m_pBMI->bmiHeader.biCompression == BI_RLE4)) {
        // It's an RLE bitmap, we can't calculate size, so trust the
        // biSizeImage field
        dwDIBSize += m_pBMI->bmiHeader.biSizeImage;
    } else {
        DWORD dwBmBitsSize;  // Size of Bitmap Bits only

        // It's not RLE, so size is Width (DWORD aligned) * Height
        dwBmBitsSize = WIDTHBYTES((m_pBMI->bmiHeader.biWidth)*((DWORD)m_pBMI->bmiHeader.biBitCount)) * m_pBMI->bmiHeader.biHeight;
        dwDIBSize += dwBmBitsSize;

        // Now, since we have calculated the correct size, why don't we
        // fill in the biSizeImage field (this will fix any .BMP files which
        // have this field incorrect).
        m_pBMI->bmiHeader.biSizeImage = dwBmBitsSize;
    }

    // Calculate the file size by adding the DIB size to sizeof(BITMAPFILEHEADER)
    bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER);
    bmfHdr.bfReserved1 = 0;
    bmfHdr.bfReserved2 = 0;

    // Now, calculate the offset the actual bitmap bits will be in
    // the file -- It's the Bitmap file header plus the DIB header,
    // plus the size of the color table.

    bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + m_pBMI->bmiHeader.biSize + PaletteSize();

    // Write the file header
    file.Write((LPSTR)&bmfHdr, sizeof(BITMAPFILEHEADER));
    DWORD dwBytesSaved = sizeof(BITMAPFILEHEADER);

    // Write the DIB header
    UINT nCount = sizeof(BITMAPINFO) + (NumColors()-1)*sizeof(RGBQUAD);
    dwBytesSaved += nCount;
    file.Write(m_pBMI, nCount);

    // Write the DIB bits
    DWORD dwBytes = m_pBMI->bmiHeader.biBitCount * Width();
    // Calculate the number of bytes per line
    if (dwBytes%32 == 0)
        dwBytes /= 8;
    else
        dwBytes = dwBytes/8 + (32-dwBytes%32)/8 + (((32-dwBytes%32)%8 > 0) ? 1 : 0);
    nCount = dwBytes * Height();
    dwBytesSaved += nCount;
    file.WriteHuge(m_pBits, nCount);
    return dwBytesSaved;
}

/**************************************************************************\
* CDib::Read()
*
*   Reads from a File into DIB form
*       Note: the CFile must be opened before this call is made!
*
* Arguments:
*
*   CFile& - Open CFile
*       FileType - BMP_IMAGE, TIFF_IMAGE
*
* Return Value:
*
*   DWORD - Number of bytes read from the CFile
*
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
DWORD CDib::Read(CFile& file,int FileType)
{
    DWORD dwReadBytes = 0;

    // Ensures no memory leaks will occur
    Free();
    if (FileType == TIFF_IMAGE) {
        DWORD dwCurrentFileOffset = 0;
        DWORD dwStripByteCountOffset = 0;
        DWORD dwStripOffset = 0;

        // TIFF variables
        TIFFFILEHEADER tfHeader;
        TIFFTAG tTag;
        short TagCount = 0;

        dwReadBytes = file.Read(&tfHeader,sizeof(TIFFFILEHEADER));
        if (dwReadBytes != sizeof(TIFFFILEHEADER)) {
            AfxMessageBox("Error reading TIFF file header");
            return 0;
        }
        dwCurrentFileOffset += dwReadBytes;

        if (tfHeader.tfType != 42) {
            AfxMessageBox("Invalid TIFF format");
            return 0;
        }

        if (tfHeader.tfByteOrder[0] != 'I' && tfHeader.tfByteOrder[1] != 'I') {
            AfxMessageBox("Invalid TIFF format not 'II'");
            return 0;
        }

        //
        // move file pointer to TAG offset
        //
        dwCurrentFileOffset = file.Seek(tfHeader.tfOffset,CFile::begin);

        dwReadBytes = file.Read(&TagCount,sizeof(short));
        if (dwReadBytes != sizeof(short)) {
            AfxMessageBox("Error reading Number of TIFF TAGS");
            return 0;
        }
        dwCurrentFileOffset += dwReadBytes;

        if (TagCount <=0) {
            AfxMessageBox("Number of TIFF TAGS must be 1 or more..");
            return 0;
        }

        TIFFTODIBDATA TiffToDIBData;
        long tempOffset = 0;
        int ValueCount = 0;


        memset(&TiffToDIBData,0,sizeof(TIFFTODIBDATA));
        for (int i = 1;i<=TagCount;i++) {
            dwReadBytes = file.Read(&tTag,sizeof(TIFFTAG));
            if (dwReadBytes != sizeof(TIFFTAG)) {
                AfxMessageBox("Error reading TIFF TAGS");
                return 0;
            }
            switch (tTag.ttTag) {
            case TIFF_NEWSUBFILETYPE:
                break;
            case TIFF_IMAGEWIDTH:
                TiffToDIBData.bmiHeader.biWidth = tTag.ttOffset;
                break;
            case TIFF_LENGTH:
                TiffToDIBData.bmiHeader.biHeight = tTag.ttOffset;
                break;
            case TIFF_BITSPERSAMPLE:
                if (tTag.ttCount == 3)
                    TiffToDIBData.bmiHeader.biBitCount = 24;
                else
                    TiffToDIBData.bmiHeader.biBitCount = (unsigned short)tTag.ttOffset;
                break;
            case TIFF_COMPRESSION:
                TiffToDIBData.CompressionType = tTag.ttOffset;
                break;
            case TIFF_PHOTOINTERP:
                break;
            case TIFF_IMAGEDESCRIPTION:
                tempOffset = dwCurrentFileOffset;
                file.Seek(tTag.ttOffset,CFile::begin);
                file.Read(TiffToDIBData.Description,sizeof(tTag.ttCount));
                file.Seek(tempOffset,CFile::begin);
                break;
            case TIFF_STRIPOFFSETS:
                TiffToDIBData.StripOffsets = tTag.ttOffset;
                TiffToDIBData.OffsetCount = tTag.ttCount;
                TiffToDIBData.pStripOffsets = (long*)GlobalAlloc(GPTR,sizeof(long) * tTag.ttCount);
                if (tTag.ttCount == 1) {
                    //
                    // we only have one huge strip
                    //
                    TiffToDIBData.pStripOffsets[0] = tTag.ttOffset;
                } else {
                    //
                    // we have multiple strips
                    //
                    tempOffset = dwCurrentFileOffset;
                    file.Seek(tTag.ttOffset,CFile::begin);
                    file.Read(TiffToDIBData.pStripOffsets,sizeof(long) * tTag.ttCount);
                    file.Seek(tempOffset,CFile::begin);
                }
                break;
            case TIFF_ORIENTATION:
                break;
            case TIFF_SAMPLESPERPIXEL:
                break;
            case TIFF_ROWSPERSTRIP:
                TiffToDIBData.RowsPerStrip = tTag.ttOffset;
                break;
            case TIFF_STRIPBYTECOUNTS:
                TiffToDIBData.StripByteCounts = tTag.ttOffset;
                TiffToDIBData.pStripByteCountsOffsets = (long*)GlobalAlloc(GPTR,sizeof(long) * tTag.ttCount);
                if (tTag.ttCount == 1) {
                    //
                    // we only have one huge strip
                    //
                    TiffToDIBData.pStripByteCountsOffsets[0] = tTag.ttOffset;
                } else {
                    //
                    // we have multiple strips
                    //
                    tempOffset = dwCurrentFileOffset;
                    file.Seek(tTag.ttOffset,CFile::begin);
                    file.Read(TiffToDIBData.pStripByteCountsOffsets,sizeof(long) * tTag.ttCount);
                    file.Seek(tempOffset,CFile::begin);
                }
                break;
            case TIFF_XRESOLUTION:
                tempOffset = dwCurrentFileOffset;
                file.Seek(tTag.ttOffset,CFile::begin);
                file.Read(&TiffToDIBData.xResolution,sizeof(TIFFRATIONAL));
                file.Seek(tempOffset,CFile::begin);
                break;
            case TIFF_YRESOLUTION:
                tempOffset = dwCurrentFileOffset;
                file.Seek(tTag.ttOffset,CFile::begin);
                file.Read(&TiffToDIBData.yResolution,sizeof(TIFFRATIONAL));
                file.Seek(tempOffset,CFile::begin);
                break;
            case TIFF_RESOLUTIONUNIT:
                TiffToDIBData.ResolutionUnit = tTag.ttOffset;
                break;
            case TIFF_SOFTWARE:
                tempOffset = dwCurrentFileOffset;
                file.Seek(tTag.ttOffset,CFile::begin);
                file.Read(TiffToDIBData.Software,sizeof(tTag.ttCount));
                file.Seek(tempOffset,CFile::begin);
                break;
            default:
                break;
            }
            dwCurrentFileOffset += dwReadBytes;
        }

        //
        // read next Tagcount to see if there are more TAGS
        //
        dwReadBytes = file.Read(&TagCount,sizeof(short));
        if (dwReadBytes != sizeof(short)) {
            AfxMessageBox("Error reading Number of TIFF TAGS");
            return 0;
        }

        //
        // if there are more tags exit for now..
        //
        if (TagCount >0) {
            //AfxMessageBox("There are more TIFF TAGS in this file");
            //return;
        }

        //
        // calculate the rest of the TiffToDIBData
        //
        int BytesPerPixel = 0;
        //
        // 8-bit DATA
        //
        if (TiffToDIBData.bmiHeader.biBitCount == 8) {
            BytesPerPixel = 1;
            if (TiffToDIBData.ColorsUsed == 0)
                TiffToDIBData.bmiHeader.biClrUsed = 256;
            else
                TiffToDIBData.bmiHeader.biClrUsed = TiffToDIBData.ColorsUsed;
        }
        //
        // 24-bit DATA
        //
        else if (TiffToDIBData.bmiHeader.biBitCount == 24) {
            BytesPerPixel = 3;
            TiffToDIBData.bmiHeader.biClrUsed = 0;
        }
        //
        // 4-bit DATA
        //
        else if (TiffToDIBData.bmiHeader.biBitCount == 4) {
            BytesPerPixel = 2;
            TiffToDIBData.bmiHeader.biClrUsed = 256;
        }
        //
        // 1-bit DATA
        //
        else {
            BytesPerPixel = 0;
            TiffToDIBData.bmiHeader.biClrUsed = 2;
        }
        TiffToDIBData.bmiHeader.biSizeImage = WIDTHBYTES((TiffToDIBData.bmiHeader.biWidth)*((DWORD)TiffToDIBData.bmiHeader.biBitCount)) * TiffToDIBData.bmiHeader.biHeight;
        TiffToDIBData.bmiHeader.biPlanes = 1;
        TiffToDIBData.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        //
        //      create Palette size if one exists
        //
        RGBQUAD* pPalette = NULL;
        long PaletteSize = 0;
        if (TiffToDIBData.bmiHeader.biClrUsed != 0) {
            PaletteSize = TiffToDIBData.bmiHeader.biClrUsed * sizeof(RGBQUAD);
            pPalette = (RGBQUAD*)GlobalAllocPtr(GHND, PaletteSize);
            if (pPalette == NULL) {
                AfxMessageBox("Failed to Create Palette");
                return 0;
            }
            if (TiffToDIBData.bmiHeader.biBitCount == 8) {
                if (TiffToDIBData.ColorsUsed == 0) {
                    //
                    // create a grayscale palette
                    //
                    for (int i = 0;i<(int)TiffToDIBData.bmiHeader.biClrUsed;i++) {
                        pPalette[i].rgbRed = (BYTE)i;
                        pPalette[i].rgbBlue = (BYTE)i;
                        pPalette[i].rgbGreen = (BYTE)i;
                        pPalette[i].rgbReserved = 0;
                    }
                } else {
                    //
                    // create the color palette from colormap
                    //
                    TiffToDIBData.bmiHeader.biClrUsed = TiffToDIBData.ColorsUsed;
                }
            }
            if (TiffToDIBData.bmiHeader.biBitCount == 1) {
                //
                // create a black and white palette
                //
                pPalette[0].rgbRed = 0;
                pPalette[0].rgbBlue = 0;
                pPalette[0].rgbGreen = 0;
                pPalette[0].rgbReserved = 0;

                pPalette[1].rgbRed = 255;
                pPalette[1].rgbBlue = 255;
                pPalette[1].rgbGreen = 255;
                pPalette[1].rgbReserved = 255;
            }
        }

        BITMAPFILEHEADER bmfHeader;
        memset(&bmfHeader,0,sizeof(BITMAPFILEHEADER));
        bmfHeader.bfType = DIB_HEADER_MARKER;
        bmfHeader.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + PaletteSize + TiffToDIBData.bmiHeader.biSizeImage;
        bmfHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)+ PaletteSize;

        // Allocate memory for DIB info header and possible palette
        m_pBMI = (LPBITMAPINFO)GlobalAllocPtr(GHND, bmfHeader.bfOffBits-sizeof(BITMAPFILEHEADER) + (PaletteSize*2));
        if (m_pBMI == 0)
            return 0;

        DWORD dwLength = file.GetLength();
        m_pBits = (LPBYTE)GlobalAllocPtr(GHND, TiffToDIBData.bmiHeader.biSizeImage + PaletteSize);
        if (m_pBits == 0) {
            GlobalFreePtr(m_pBMI);
            m_pBMI = NULL;
            return 0;
        }
        BYTE* pData = m_pBits;

        //
        // set line width (DWORD aligned length)
        //
        long LineWidth = TiffToDIBData.bmiHeader.biSizeImage/TiffToDIBData.bmiHeader.biHeight;

        DWORD ImageByteCount = 0;
        for (i = 0;i < TiffToDIBData.OffsetCount;i++) {
            //
            // seek to strip
            //
            file.Seek(TiffToDIBData.pStripOffsets[i],CFile::begin);
            //
            // read strip data (numbytes from pStripBytesCounts.
            //
            file.ReadHuge(pData,TiffToDIBData.pStripByteCountsOffsets[i]);
            pData += TiffToDIBData.pStripByteCountsOffsets[i];
            ImageByteCount+= TiffToDIBData.pStripByteCountsOffsets[i];
        }
        BYTE  ColorValue = 0;
        int LineCount = 1;
        pData = m_pBits;

        //
        // Swap Red and Blue values if the data is 24-BIT
        //

        if (TiffToDIBData.bmiHeader.biClrUsed == 0) {
            for (LONG i = 0; i < (LONG)TiffToDIBData.bmiHeader.biSizeImage; i += 3) {
                BYTE bTemp = pData[i];
                pData[i]     = pData[i + 2];
                pData[i + 2] = bTemp;
            }
        }

        // Write BITMAPINFOHEADER to member
        memmove(m_pBMI,&TiffToDIBData.bmiHeader,sizeof(BITMAPINFOHEADER));

        if (TiffToDIBData.bmiHeader.biClrUsed >0) {
            memmove(m_pBMI->bmiColors,pPalette,PaletteSize);
        }

        if (TiffToDIBData.bmiHeader.biBitCount == 1)
            LineWidth = (long)ceil((float)TiffToDIBData.bmiHeader.biWidth/8.0f);
        else
            LineWidth = TiffToDIBData.bmiHeader.biWidth * BytesPerPixel;

        pData = m_pBits;
        //
        // check DWORD alignment of data
        //
        if ((LineWidth % sizeof(DWORD))) {
            //
            // Pad data
            //
            int PaddedBytes = sizeof(DWORD) - (LineWidth % sizeof(DWORD));
            LineCount = 1;
            BYTE* pCurrent = NULL;
            BYTE* pDest = NULL;
            for (LineCount = TiffToDIBData.bmiHeader.biHeight;LineCount > 1;LineCount--) {
                pCurrent = pData + (LineWidth*(LineCount - 1));
                pDest = pCurrent + (PaddedBytes*(LineCount - 1));
                memmove(pDest,pCurrent,(LineWidth + PaddedBytes));
            }
        }

        if (pPalette)
            GlobalFreePtr(pPalette);
        if (TiffToDIBData.pStripByteCountsOffsets != NULL)
            GlobalFree(TiffToDIBData.pStripByteCountsOffsets);
        if (TiffToDIBData.pStripOffsets != NULL)
            GlobalFree(TiffToDIBData.pStripOffsets);
        //
        // flip the data because we are converting it
        // to DIB form
        //
        Flip(m_pBits);
        CreatePalette();
    } else {
        BITMAPFILEHEADER bmfHeader;

        // Go read the DIB file header and check if it's valid.
        if (file.Read((LPSTR)&bmfHeader, sizeof(bmfHeader)) != sizeof(bmfHeader))
            return 0;
        if (bmfHeader.bfType != DIB_HEADER_MARKER)
            return 0;
        dwReadBytes = sizeof(bmfHeader);

        // Allocate memory for DIB info header and possible palette
        m_pBMI = (LPBITMAPINFO)GlobalAllocPtr(GHND, bmfHeader.bfOffBits-sizeof(BITMAPFILEHEADER) + 256*sizeof(RGBQUAD));
        if (m_pBMI == 0)
            return 0;

        // Read header.
        if (file.Read(m_pBMI, bmfHeader.bfOffBits-sizeof(BITMAPFILEHEADER)) != (UINT)(bmfHeader.bfOffBits-sizeof(BITMAPFILEHEADER))) {
            GlobalFreePtr(m_pBMI);
            m_pBMI = NULL;
            return 0;
        }
        dwReadBytes += bmfHeader.bfOffBits-sizeof(BITMAPFILEHEADER);

        DWORD dwLength = file.GetLength();
        // Go read the bits.
        m_pBits = (LPBYTE)GlobalAllocPtr(GHND, dwLength - bmfHeader.bfOffBits);
        if (m_pBits == 0) {
            GlobalFreePtr(m_pBMI);
            m_pBMI = NULL;
            return 0;
        }

        if (file.ReadHuge(m_pBits, dwLength-bmfHeader.bfOffBits) != (dwLength - bmfHeader.bfOffBits)) {
            GlobalFreePtr(m_pBMI);
            m_pBMI = NULL;
            GlobalFreePtr(m_pBits);
            m_pBits = NULL;
            return 0;
        }
        dwReadBytes += dwLength - bmfHeader.bfOffBits;

        CreatePalette();
    }
    return dwReadBytes;
}

/**************************************************************************\
* CDib::ReadFromHGLOBAL()
*
*   Reads a global chunk of memory into DIB form
*
*
* Arguments:
*
*   hGlobal - Global block of memory
*   FileType - BMP_IMAGE, TIFF_IMAGE
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDib::ReadFromHGLOBAL(HGLOBAL hGlobal,int FileType)
{
    Free();
    if (hGlobal == NULL)
        return FALSE;
    if (FileType == TIFF_IMAGE) {
        LPBYTE pSrcDib = (LPBYTE)GlobalLock(hGlobal);

        TIFFFILEHEADER* ptfHeader = NULL;
        ptfHeader = (TIFFFILEHEADER*)pSrcDib;
        LPBYTE pPtr = pSrcDib;
        LPBYTE ptempPtr = NULL;
        DWORD dwCurrentFileOffset = 0;
        DWORD dwStripByteCountOffset = 0;
        DWORD dwStripOffset = 0;

        // TIFF variables
        TIFFTAG tTag;
        short TagCount = 0;

        if (ptfHeader->tfType != 42) {
            AfxMessageBox("Invalid TIFF format");
            return 0;
        }

        if (ptfHeader->tfByteOrder[0] != 'I' && ptfHeader->tfByteOrder[1] != 'I') {
            AfxMessageBox("Invalid TIFF format not 'II'");
            return 0;
        }

        //
        // move pointer to TAG offset
        //
        pPtr += ptfHeader->tfOffset;

        memmove(&TagCount,pPtr,sizeof(short));
        pPtr += sizeof(short);

        if (TagCount <=0) {
            AfxMessageBox("Number of TIFF TAGS must be 1 or more..");
            return 0;
        }

        TIFFTODIBDATA TiffToDIBData;
        long tempOffset = 0;
        int ValueCount = 0;

        memset(&TiffToDIBData,0,sizeof(TIFFTODIBDATA));
        for (int i = 1;i<=TagCount;i++) {
            memmove(&tTag,pPtr,sizeof(TIFFTAG));
            pPtr += sizeof(TIFFTAG);

            switch (tTag.ttTag) {
            case TIFF_NEWSUBFILETYPE:
                break;
            case TIFF_IMAGEWIDTH:
                TiffToDIBData.bmiHeader.biWidth = tTag.ttOffset;
                break;
            case TIFF_LENGTH:
                TiffToDIBData.bmiHeader.biHeight = tTag.ttOffset;
                break;
            case TIFF_BITSPERSAMPLE:
                if (tTag.ttCount == 3)
                    TiffToDIBData.bmiHeader.biBitCount = 24;
                else
                    TiffToDIBData.bmiHeader.biBitCount = (unsigned short)tTag.ttOffset;
                break;
            case TIFF_COMPRESSION:
                TiffToDIBData.CompressionType = tTag.ttOffset;
                break;
            case TIFF_PHOTOINTERP:
                break;
            case TIFF_IMAGEDESCRIPTION:
                ptempPtr = pPtr; // save current pointer
                pPtr = pSrcDib;  // move pointer to start of data
                pPtr += tTag.ttOffset; // seek to offset
                memmove(TiffToDIBData.Description,pPtr,sizeof(tTag.ttCount)); // read data
                pPtr = ptempPtr; // move pointer back to org. position
                break;
            case TIFF_STRIPOFFSETS:
                TiffToDIBData.StripOffsets = tTag.ttOffset;
                TiffToDIBData.OffsetCount = tTag.ttCount;
                TiffToDIBData.pStripOffsets = (long*)GlobalAlloc(GPTR,sizeof(long) * tTag.ttCount);
                if (tTag.ttCount == 1) {
                    //
                    // we only have one huge strip
                    //
                    TiffToDIBData.pStripOffsets[0] = tTag.ttOffset;
                } else {
                    //
                    // we have multiple strips
                    //
                    ptempPtr = pPtr; // save current pointer
                    pPtr = pSrcDib;  // move pointer to start of data
                    pPtr += tTag.ttOffset; // seek to offset
                    memmove(TiffToDIBData.pStripOffsets,pPtr,sizeof(long) * tTag.ttCount); // read data
                    pPtr = ptempPtr; // move pointer back to org. position
                }
                break;
            case TIFF_ORIENTATION:
                break;
            case TIFF_SAMPLESPERPIXEL:
                break;
            case TIFF_ROWSPERSTRIP:
                TiffToDIBData.RowsPerStrip = tTag.ttOffset;
                break;
            case TIFF_STRIPBYTECOUNTS:
                TiffToDIBData.StripByteCounts = tTag.ttOffset;
                TiffToDIBData.pStripByteCountsOffsets = (long*)GlobalAlloc(GPTR,sizeof(long) * tTag.ttCount);
                if (tTag.ttCount == 1) {
                    //
                    // we only have one huge strip
                    //
                    TiffToDIBData.pStripByteCountsOffsets[0] = tTag.ttOffset;
                } else {
                    //
                    // we have multiple strips
                    //
                    ptempPtr = pPtr; // save current pointer
                    pPtr = pSrcDib;  // move pointer to start of data
                    pPtr += tTag.ttOffset; // seek to offset
                    memmove(TiffToDIBData.pStripByteCountsOffsets,pPtr,sizeof(long) * tTag.ttCount); // read data
                    pPtr = ptempPtr; // move pointer back to org. position
                }
                break;
            case TIFF_XRESOLUTION:
                ptempPtr = pPtr; // save current pointer
                pPtr = pSrcDib;  // move pointer to start of data
                pPtr += tTag.ttOffset; // seek to offset
                memmove(&TiffToDIBData.xResolution,pPtr,sizeof(TIFFRATIONAL)); // read data
                pPtr = ptempPtr; // move pointer back to org. position
                break;
            case TIFF_YRESOLUTION:
                ptempPtr = pPtr; // save current pointer
                pPtr = pSrcDib;  // move pointer to start of data
                pPtr += tTag.ttOffset; // seek to offset
                memmove(&TiffToDIBData.yResolution,pPtr,sizeof(TIFFRATIONAL)); // read data
                pPtr = ptempPtr; // move pointer back to org. position
                break;
            case TIFF_RESOLUTIONUNIT:
                TiffToDIBData.ResolutionUnit = tTag.ttOffset;
                break;
            case TIFF_SOFTWARE:
                ptempPtr = pPtr; // save current pointer
                pPtr = pSrcDib;  // move pointer to start of data
                pPtr += tTag.ttOffset; // seek to offset
                memmove(TiffToDIBData.Software,pPtr,sizeof(tTag.ttCount)); // read data
                pPtr = ptempPtr; // move pointer back to org. position
                break;
            default:
                break;
            }
        }

        //
        // read next Tagcount to see if there are more TAGS
        //
        //dwReadBytes = file.Read(&TagCount,sizeof(short));
        //if(dwReadBytes != sizeof(short))
        //{
        //      AfxMessageBox("Error reading Number of TIFF TAGS");
        //      return 0;
        //}

        //
        // if there are more tags exit for now..
        //
        //if(TagCount >0)
        //{
        //AfxMessageBox("There are more TIFF TAGS in this file");
        //return;
        //}

        //
        // calculate the rest of the TiffToDIBData
        //
        int BytesPerPixel = 0;
        //
        // 8-bit DATA
        //
        if (TiffToDIBData.bmiHeader.biBitCount == 8) {
            BytesPerPixel = 1;
            if (TiffToDIBData.ColorsUsed == 0)
                TiffToDIBData.bmiHeader.biClrUsed = 256;
            else
                TiffToDIBData.bmiHeader.biClrUsed = TiffToDIBData.ColorsUsed;
        }
        //
        // 24-bit DATA
        //
        else if (TiffToDIBData.bmiHeader.biBitCount == 24) {
            BytesPerPixel = 3;
            TiffToDIBData.bmiHeader.biClrUsed = 0;
        }
        //
        // 4-bit DATA
        //
        else if (TiffToDIBData.bmiHeader.biBitCount == 4) {
            BytesPerPixel = 2;
            TiffToDIBData.bmiHeader.biClrUsed = 256;
        }
        //
        // 1-bit DATA
        //
        else {
            BytesPerPixel = 0;
            TiffToDIBData.bmiHeader.biClrUsed = 2;
        }
        TiffToDIBData.bmiHeader.biSizeImage = WIDTHBYTES((TiffToDIBData.bmiHeader.biWidth)*((DWORD)TiffToDIBData.bmiHeader.biBitCount)) * TiffToDIBData.bmiHeader.biHeight;
        TiffToDIBData.bmiHeader.biPlanes = 1;
        TiffToDIBData.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        //
        //      create Palette size if one exists
        //
        RGBQUAD* pPalette = NULL;
        long PaletteSize = 0;
        if (TiffToDIBData.bmiHeader.biClrUsed != 0) {
            PaletteSize = TiffToDIBData.bmiHeader.biClrUsed * sizeof(RGBQUAD);
            pPalette = (RGBQUAD*)GlobalAllocPtr(GHND, PaletteSize);
            if (pPalette == NULL) {
                AfxMessageBox("Failed to Create Palette");
                return 0;
            }
            if (TiffToDIBData.bmiHeader.biBitCount == 8) {
                if (TiffToDIBData.ColorsUsed == 0) {
                    //
                    // create a grayscale palette
                    //
                    for (int i = 0;i<(int)TiffToDIBData.bmiHeader.biClrUsed;i++) {
                        pPalette[i].rgbRed = (BYTE)i;
                        pPalette[i].rgbBlue = (BYTE)i;
                        pPalette[i].rgbGreen = (BYTE)i;
                        pPalette[i].rgbReserved = 0;
                    }
                } else {
                    //
                    // create the color palette from colormap
                    //
                    TiffToDIBData.bmiHeader.biClrUsed = TiffToDIBData.ColorsUsed;
                }
            }
            if (TiffToDIBData.bmiHeader.biBitCount == 1) {
                //
                // create a black and white palette
                //
                pPalette[0].rgbRed = 0;
                pPalette[0].rgbBlue = 0;
                pPalette[0].rgbGreen = 0;
                pPalette[0].rgbReserved = 0;

                pPalette[1].rgbRed = 255;
                pPalette[1].rgbBlue = 255;
                pPalette[1].rgbGreen = 255;
                pPalette[1].rgbReserved = 255;
            }
        }

        BITMAPFILEHEADER bmfHeader;
        memset(&bmfHeader,0,sizeof(BITMAPFILEHEADER));
        bmfHeader.bfType = DIB_HEADER_MARKER;
        bmfHeader.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + PaletteSize + TiffToDIBData.bmiHeader.biSizeImage;
        bmfHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)+ PaletteSize;

        // Allocate memory for DIB info header and possible palette
        m_pBMI = (LPBITMAPINFO)GlobalAllocPtr(GHND, bmfHeader.bfOffBits-sizeof(BITMAPFILEHEADER) + (PaletteSize*2));
        if (m_pBMI == 0)
            return 0;

        m_pBits = (LPBYTE)GlobalAllocPtr(GHND, TiffToDIBData.bmiHeader.biSizeImage + PaletteSize);
        if (m_pBits == 0) {
            GlobalFreePtr(m_pBMI);
            m_pBMI = NULL;
            return 0;
        }
        BYTE* pData = m_pBits;

        //
        // set line width (DWORD aligned length)
        //
        long LineWidth = TiffToDIBData.bmiHeader.biSizeImage/TiffToDIBData.bmiHeader.biHeight;

        DWORD ImageByteCount = 0;
        for (i = 0;i < TiffToDIBData.OffsetCount;i++) {
            //
            // seek to strip
            //
            pPtr = pSrcDib;  // move pointer to start of data
            pPtr += TiffToDIBData.pStripOffsets[i]; // seek to offset
            //
            // read strip data (numbytes from pStripBytesCounts.
            //
            CopyMemory(pData,pPtr,TiffToDIBData.pStripByteCountsOffsets[i]); // read data

            pData += TiffToDIBData.pStripByteCountsOffsets[i];
            ImageByteCount+= TiffToDIBData.pStripByteCountsOffsets[i];
        }
        BYTE  ColorValue = 0;
        int LineCount = 1;
        pData = m_pBits;

        if (TiffToDIBData.bmiHeader.biClrUsed ==0) {
            while (LineCount <= TiffToDIBData.bmiHeader.biHeight) {
                //
                // swap red and blue values
                // if the data is 24-bit
                //
                for (int i = 0;i<LineWidth;i+=3) {
                    ColorValue = pData[i];
                    pData[i] = pData[i+2];
                    pData[i+2] = ColorValue;
                }

                pData += LineWidth;
                LineCount++;
            }
        }

        // Write BITMAPINFOHEADER to member
        memmove(m_pBMI,&TiffToDIBData.bmiHeader,sizeof(BITMAPINFOHEADER));

        if (TiffToDIBData.bmiHeader.biClrUsed >0) {
            memmove(m_pBMI->bmiColors,pPalette,PaletteSize);
        }

        if (TiffToDIBData.bmiHeader.biBitCount == 1)
            LineWidth = (long)ceil((float)TiffToDIBData.bmiHeader.biWidth/8.0f);
        else
            LineWidth = TiffToDIBData.bmiHeader.biWidth * BytesPerPixel;

        pData = m_pBits;
        //
        // check DWORD alignment of data
        //
        if ((LineWidth % sizeof(DWORD))) {
            //
            // Pad data
            //
            int PaddedBytes = sizeof(DWORD) - (LineWidth % sizeof(DWORD));
            LineCount = 1;
            BYTE* pCurrent = NULL;
            BYTE* pDest = NULL;
            for (LineCount = TiffToDIBData.bmiHeader.biHeight;LineCount > 1;LineCount--) {
                pCurrent = pData + (LineWidth*(LineCount - 1));
                pDest = pCurrent + (PaddedBytes*(LineCount - 1));
                memmove(pDest,pCurrent,(LineWidth + PaddedBytes));
            }
        }

        if (pPalette)
            GlobalFreePtr(pPalette);
        if (TiffToDIBData.pStripByteCountsOffsets != NULL)
            GlobalFree(TiffToDIBData.pStripByteCountsOffsets);
        if (TiffToDIBData.pStripOffsets != NULL)
            GlobalFree(TiffToDIBData.pStripOffsets);
        //
        // flip the data because we are converting it
        // to DIB form
        //
        Flip(m_pBits);
        CreatePalette();

    } else {
        BOOL bTopDown = FALSE;
        LPBYTE pSrcDib = (LPBYTE)GlobalLock(hGlobal);
        LPBITMAPINFO pbmi = NULL;
        pbmi = (LPBITMAPINFO)pSrcDib;

        // Allocate memory for DIB
        m_pBMI = (LPBITMAPINFO)GlobalAllocPtr(GHND, (sizeof(BITMAPINFO) + pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD)));
        if (m_pBMI == 0)
            return 0;

        // copy header.
        memmove(m_pBMI,pbmi,(sizeof(BITMAPINFO) + pbmi->bmiHeader.biClrUsed * sizeof(RGBQUAD)));

        DWORD dwLength = m_pBMI->bmiHeader.biSizeImage;

        // if a TOP_DOWN_DIB comes in..adjust it to be displayed
        // this is not a normal thing to do here. It is only so that the
        // image can be displayed for debug reasons.
        if (m_pBMI->bmiHeader.biHeight < 1) {
            bTopDown = TRUE;
            m_pBMI->bmiHeader.biHeight = -m_pBMI->bmiHeader.biHeight;
        }

        // Alloc memory for bits
        m_pBits = (LPBYTE)GlobalAllocPtr(GHND, dwLength);
        if (m_pBits == 0) {
            GlobalFreePtr(m_pBMI);
            m_pBMI = NULL;
            return 0;
        }
        // move pointer past BITMAPINFOHEADER to bits
        pSrcDib+=sizeof(BITMAPINFOHEADER);
        pSrcDib+=(m_pBMI->bmiHeader.biClrUsed * sizeof(RGBQUAD));

        if (bTopDown) {
            // flip bitmap and copy bits
            Flip(pSrcDib);
            memmove(m_pBits,pSrcDib,dwLength);
        } else
            // copy bits
            memmove(m_pBits,pSrcDib,dwLength);

        CreatePalette();
        GlobalUnlock(hGlobal);
    }
    return TRUE;
}

/**************************************************************************\
* CDib::GotImage()
*
*   Check DIB to see is memory has been allocated and used.
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDib::GotImage()
{
    // Make sure all member data that might have been allocated exist.
    if (m_pBits)
        if (m_pBMI)
            return TRUE;
    return FALSE;
}

/**************************************************************************\
* CDib::ReadFromBMPFile()
*
*   Opens and Reads data from a BMP file into DIB form
*
*
* Arguments:
*
*   LPSTR- filename (Filename to be opened and read)
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/

void CDib::ReadFromBMPFile(LPSTR filename)
{
    CFile ImageFile;
    // open & read image file
    ImageFile.Open(filename,CFile::modeRead,NULL);
    Read(ImageFile,BMP_IMAGE);
    // close image file
    ImageFile.Close();
}

/**************************************************************************\
* CDib::ReadFromBMPFile()
*
*   Opens and Reads data from a BMP file into DIB form
*
*
* Arguments:
*
*   CString- filename (Filename to be opened and read)
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDib::ReadFromBMPFile(CString filename)
{
    CFile ImageFile;
    // open & read image file
    ImageFile.Open(filename,CFile::modeRead,NULL);
    Read(ImageFile,BMP_IMAGE);
    // close image file
    ImageFile.Close();
}
/**************************************************************************\
* CDib::ReadFromTIFFFile()
*
*   Opens and Reads data from a TIFF file into DIB form
*
*
* Arguments:
*
*   CString- filename (Filename to be opened and read)
*
* Return Value:
*
*    void
*
* History:
*
*    4/14/1999 Original Version
*
\**************************************************************************/
void CDib::ReadFromTIFFFile(CString filename)
{
    CFile ImageFile;
    // open & read image file
    ImageFile.Open(filename,CFile::modeRead,NULL);

    Read(ImageFile,TIFF_IMAGE);
    // close image file
    ImageFile.Close();
}
/**************************************************************************\
* CDib::Flip()
*
*   Flips a DIB, TOPDOWN to DIB conversion
*
*
* Arguments:
*
*   pSrcData - TOPDOWN DIB to be flipped
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDib::Flip(BYTE* pSrcData)
{
    LONG Width = 0;
    LONG Height = 0;
    LONG Linelength = 0;
    LONG BitCount = 0;

    Width = m_pBMI->bmiHeader.biWidth;
    Height = m_pBMI->bmiHeader.biHeight;
    BitCount = m_pBMI->bmiHeader.biBitCount;

    Linelength = (((Width*BitCount+31)/32)*4);

    LONG nLineWidthInBytes = Linelength;
    PBYTE pLine = new BYTE[nLineWidthInBytes];
    for (int i=0;i<Height/2;i++) {
        PBYTE pSrc = pSrcData + (i * nLineWidthInBytes);
        PBYTE pDst = pSrcData + ((Height-i-1) * nLineWidthInBytes);
        CopyMemory( pLine, pSrc, nLineWidthInBytes );
        CopyMemory( pSrc, pDst, nLineWidthInBytes );
        CopyMemory( pDst, pLine, nLineWidthInBytes );
    }
    delete[] pLine;
    return TRUE;
}

/**************************************************************************\
* CDib::Dump(), CopyToHandle(), ReadFromHandle(), and Serialize()
*
*   Misc. member functions that are not used at this time
*
*
* Arguments:
*
*   -
*
* Return Value:
*
*    -
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/

#ifdef _DEBUG
// Dump
void CDib::Dump(CDumpContext& dc) const
{
    CObject::Dump(dc);
}
#endif

// CopyToHandle
HGLOBAL CDib::CopyToHandle() const
{
    CSharedFile file;
    try {
        if (Save(file)==0)
            return 0;
    } catch (CFileException* e) {
        e->Delete();
        return 0;
    }

    return file.Detach();
}

// ReadFromHandle
DWORD CDib::ReadFromHandle(HGLOBAL hGlobal)
{
    CSharedFile file;
    file.SetHandle(hGlobal, FALSE);
    DWORD dwResult = Read(file,BMP_IMAGE);
    file.Detach();
    return dwResult;
}

// Serialize
void CDib::Serialize(CArchive& ar)
{
    CFile* pFile = ar.GetFile();
    ASSERT(pFile != NULL);
    if (ar.IsStoring()) {   // storing code
        Save(*pFile);
    } else {   // loading code
        Read(*pFile,BMP_IMAGE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\cwia.cpp ===
// WIA.cpp: implementation of the CWIA class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "CWIA.h"

#ifdef _DEBUG
    #undef THIS_FILE
static char THIS_FILE[]=__FILE__;
    #define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
/**************************************************************************\
* CWIA::CWIA
*
*   Constructor for WIA object
*
*
* Arguments:
*
* none
*
* Return Value:
*
*    none
*
* History:
*
*    4/20/1999 Original Version
*
\**************************************************************************/
CWIA::CWIA()
{
    //
    // initialize members
    //

    m_pIWiaDevMgr = NULL;
    m_pRootIWiaItem = NULL;
    m_pDIB = NULL;
    m_FileName = "image.bmp";
    m_bMessageBoxReport = TRUE;
    m_ApplicationName = "WIA - Error Return";

    //
    // Initialize the Enumerator POSITIONS
    //
    m_CurrentActiveTreeListPosition = NULL;
    m_CurrentDeviceListPosition = NULL;
    m_CurrentFormatEtcListPosition = NULL;
    m_CurrentItemProperyInfoListPosition = NULL;
    m_hPreviewWnd = NULL;
}
/**************************************************************************\
* CWIA::~CWIA()
*
*   Destructor, deletes allocated lists, and Releases Interface pointers
*
*
* Arguments:
*
* none
*
* Return Value:
*
*    none
*
* History:
*
*    4/20/1999 Original Version
*
\**************************************************************************/

CWIA::~CWIA()
{
    //
    // delete all Lists, and release Interface pointers
    //
    Cleanup();
}
/**************************************************************************\
* CWIA::StressStatus
*
*   Reports status to user via status list box
*
* Arguments:
*
*   status - CString value to be displayed in the list box
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::StressStatus(CString status)
{
    OutputDebugString(status + "\n");
}
/**************************************************************************\
* CWIA::StressStatus
*
*   Reports status, and hResult to user via status list box
*
* Arguments:
*
*   status - CString value to be displayed in the list box
*       hResult - hResult to be translated
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::StressStatus(CString status, HRESULT hResult)
{
    CString msg;
    ULONG ulLen = MAX_PATH;
    LPTSTR  pMsgBuf = (char*)LocalAlloc(LPTR,MAX_PATH);

    //
    // attempt to handle WIA custom errors first
    //

    switch (hResult) {
    case WIA_ERROR_GENERAL_ERROR:
        sprintf(pMsgBuf,"There was a general device failure.");
        break;
    case WIA_ERROR_PAPER_JAM:
        sprintf(pMsgBuf,"The paper path is jammed.");
        break;
    case WIA_ERROR_PAPER_EMPTY:
        sprintf(pMsgBuf,"There are no documents in the input tray to scan.");
        break;
    case WIA_ERROR_PAPER_PROBLEM:
        sprintf(pMsgBuf,"There is a general problem with an input document.");
        break;
    case WIA_ERROR_OFFLINE:
        sprintf(pMsgBuf,"The device is offline.");
        break;
    case WIA_ERROR_BUSY:
        sprintf(pMsgBuf,"The device is busy.");
        break;
    case WIA_ERROR_WARMING_UP:
        sprintf(pMsgBuf,"The device is warming up.");
        break;
    case WIA_ERROR_USER_INTERVENTION:
        sprintf(pMsgBuf,"The user has paused or stopped the device.");
        break;
    case WIA_ERROR_ITEM_DELETED:
        sprintf(pMsgBuf,"An operation has been performed on a deleted item.");
        break;
    case WIA_ERROR_DEVICE_COMMUNICATION:
        sprintf(pMsgBuf,"There is a problem communicating with the device.");
        break;
    case WIA_ERROR_INVALID_COMMAND:
        sprintf(pMsgBuf,"An invalid command has been issued.");
        break;
    default:

        //
        // free temp buffer, because FormatMessage() will allocate it for me
        //

        LocalFree(pMsgBuf);
        ulLen = 0;
        ulLen = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, hResult, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPTSTR)&pMsgBuf, 0, NULL);
        break;
    }

    if (ulLen) {
        msg = pMsgBuf;
        msg.TrimRight();
        LocalFree(pMsgBuf);
    } else {
        // use sprintf to write to buffer instead of .Format member of
        // CString.  This conversion works better for HEX
        char buffer[255];
        sprintf(buffer,"hResult = 0x%08X",hResult);
        msg = buffer;
    }
    StressStatus(status + ", " + msg);
    if (m_bMessageBoxReport)
        MessageBox(NULL,status + ", " + msg,m_ApplicationName,MB_OK|MB_ICONINFORMATION);
}

/**************************************************************************\
* CWIA::ReadPropStr
*
*   Reads a BSTR value of a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       pbstr - returned BSTR read from property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::ReadPropStr(PROPID propid,IWiaPropertyStorage  *pIWiaPropStg,BSTR *pbstr)
{
    HRESULT     hResult = S_OK;
    PROPSPEC    PropSpec[1];
    PROPVARIANT PropVar[1];
    UINT        cbSize = 0;

    *pbstr = NULL;
    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hResult = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hResult)) {
        if (PropVar[0].pwszVal) {
            *pbstr = SysAllocString(PropVar[0].pwszVal);
        } else {
            *pbstr = SysAllocString(L"");
        }
        if (*pbstr == NULL) {
            StressStatus("* ReadPropStr, SysAllocString failed");
            hResult = E_OUTOFMEMORY;
        }
        PropVariantClear(PropVar);
    } else {
        CString msg;
        msg.Format("* ReadPropStr, ReadMultiple of propid: %d, Failed", propid);
        StressStatus(msg);
    }
    return hResult;
}
/**************************************************************************\
* CWIA::WritePropStr
*
*   Writes a BSTR value to a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       pbstr - BSTR to write to target property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::WritePropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, BSTR bstr)
{
    HRESULT     hResult = S_OK;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt      = VT_BSTR;
    propvar[0].pwszVal = bstr;

    hResult = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hResult;
}

/**************************************************************************\
* CWIA::WritePropLong
*
*   Writes a LONG value of a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       lVal - LONG to be written to target property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::WritePropLong(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LONG lVal)
{
    HRESULT     hResult;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_I4;
    propvar[0].lVal = lVal;

    hResult = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hResult;
}
/**************************************************************************\
* CWIA::ReadPropLong
*
*   Reads a long value from a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       plval - returned long read from property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::ReadPropLong(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, LONG *plval)
{
    HRESULT           hResult = S_OK;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize = 0;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hResult = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hResult)) {
        *plval = PropVar[0].lVal;
    }
    return hResult;
}

/**************************************************************************\
* CWIA::WritePropGUID
*
*   Writes a GUID value of a target property
*
*
* Arguments:
*
*   propid - property ID
*   pIWiaPropStg - property storage
*   guidVal - GUID to be written to target property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal)
{
    HRESULT     hResult;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_CLSID;
    propvar[0].puuid = &guidVal;

    hResult = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hResult;
}
/**************************************************************************\
* CWIA::MoveTempFile()
*
*   Copies the temporary file created by WIA to a new location, and
*   deletes the old temp file after copy is complete
*
*
* Arguments:
*
*   pTempFileName - Temporary file created by WIA
*       pTargetFileName - New file
*
* Return Value:
*
*   status
*
* History:
*
*    6/10/1999 Original Version
*
\**************************************************************************/
BOOL CWIA::MoveTempFile(LPWSTR pwszTempFileName, LPCTSTR szTargetFileName)
{
    char buffer[MAX_PATH];
    sprintf(buffer,"%ws",pwszTempFileName);
    if(CopyFile(buffer,szTargetFileName,FALSE)){
        DeleteFile(buffer);
    }
    else{
        StressStatus(" Failed to copy temp file..");
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************\
* CWIA::IsValidItem
*
*   Determines if the item is valid is disconnected, or destroyed
*
*
* Arguments:
*
*   pIWiaItem - target item
*
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIA::IsValidItem(IWiaItem   *pIWiaItem)
{
    LONG lType = 0;
    pIWiaItem->GetItemType(&lType);

    if(lType & WiaItemTypeDisconnected)
        return FALSE;

    if(lType & WiaItemTypeDeleted)
        return FALSE;

    return TRUE;
}
/**************************************************************************\
* CWIA::DoIWiaDataBandedTransfer
*
*   Executes an IWiaData Transfer on an item
*
*
* Arguments:
*
*   pIWiaItem - target item
*       Tymed - TYMED value
*       ClipboardFormat - current clipboard format
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::DoIWiaDataBandedTransfer(IWiaItem *pIWiaItem, DWORD Tymed, GUID ClipboardFormat)
{
    HRESULT hResult = S_OK;

    //
    // Check Item pointer
    //

    if (pIWiaItem == NULL) {
        StressStatus("* pIWiaItem is NULL");
        return S_FALSE;
    }

    if(!IsValidItem(pIWiaItem)) {
        StressStatus("* pIWiaItem is invalid");
        return S_FALSE;
    }

    //
    // set the two properties (TYMED, and CF_ )
    //
    IWiaPropertyStorage *pIWiaPropStg;
    PROPSPEC PropSpec;
    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (hResult != S_OK) {
        StressStatus("* pIWiaItem->QueryInterface() Failed",hResult);
        return hResult;
    } else {

        //
        // Write property value for TYMED
        //
        PropSpec.propid = WIA_IPA_TYMED;
        hResult = WritePropLong(WIA_IPA_TYMED,pIWiaPropStg,Tymed);
        if (SUCCEEDED(hResult))
            StressStatus("tymed Successfully written");
        else
            StressStatus("* WritePropLong(WIA_IPA_TYMED) Failed",hResult);

        //
        // Write property value for SUPPORTED WIA FORMAT
        //
        hResult = WritePropGUID(WIA_IPA_FORMAT,pIWiaPropStg,ClipboardFormat);
        if (hResult == S_OK)
            StressStatus("Format Successfully written");
        else
            StressStatus("* WritePropLong(WIA_IPA_FORMAT) Failed",hResult);

    }

    StressStatus("Executing an idtGetBandedData Transfer...");

    CWaitCursor cwc;
    if (pIWiaItem == NULL) {
        StressStatus("* pIWiaItem is NULL");
        return S_FALSE;
    }

    //
    // get IWiaDatatransfer interface
    //

    IWiaDataTransfer *pIBandTran = NULL;
    hResult = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIBandTran);
    if (SUCCEEDED(hResult)) {

        //
        // create Banded callback
        //

        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback* pCBandedCB = new CWiaDataCallback();
        if (pCBandedCB) {
            hResult = pCBandedCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (hResult == S_OK) {
                WIA_DATA_TRANSFER_INFO  wiaDataTransInfo;

                pCBandedCB->Initialize(m_hPreviewWnd);

                ZeroMemory(&wiaDataTransInfo, sizeof(WIA_DATA_TRANSFER_INFO));
                wiaDataTransInfo.ulSize = sizeof(WIA_DATA_TRANSFER_INFO);
                wiaDataTransInfo.ulBufferSize = (GetMinBufferSize(pIWiaItem) * 4);

                hResult = pIBandTran->idtGetBandedData(&wiaDataTransInfo, pIWiaDataCallback);
                pIBandTran->Release();
                if (hResult == S_OK) {

                    //
                // Display data (only BMP, and single page TIFF supported so far for display..)
                //

                    /*if (ClipboardFormat == WiaImgFmt_UNDEFINED)
                        return "WiaImgFmt_UNDEFINED";
                    else if (ClipboardFormat == WiaImgFmt_MEMORYBMP)
                        return "WiaImgFmt_MEMORYBMP";*/
                    if (ClipboardFormat == WiaImgFmt_BMP)
                        m_pDIB->ReadFromHGLOBAL(pCBandedCB->GetDataPtr(),BMP_IMAGE);
                    else if (ClipboardFormat == WiaImgFmt_MEMORYBMP)
                        m_pDIB->ReadFromHGLOBAL(pCBandedCB->GetDataPtr(),BMP_IMAGE);
                    /*else if (ClipboardFormat == WiaImgFmt_EMF)
                        return "WiaImgFmt_EMF";
                    else if (ClipboardFormat == WiaImgFmt_WMF)
                        return "WiaImgFmt_WMF";
                    else if (ClipboardFormat == WiaImgFmt_JPEG)
                        return "WiaImgFmt_JPEG";
                    else if (ClipboardFormat == WiaImgFmt_PNG)
                        return "WiaImgFmt_PNG";
                    else if (ClipboardFormat == WiaImgFmt_GIF)
                        return "WiaImgFmt_GIF";*/
                    else if (ClipboardFormat == WiaImgFmt_TIFF)
                        m_pDIB->ReadFromHGLOBAL(pCBandedCB->GetDataPtr(),TIFF_IMAGE);
                    /*else if (ClipboardFormat == WiaImgFmt_EXIF)
                        return "WiaImgFmt_EXIF";
                    else if (ClipboardFormat == WiaImgFmt_PHOTOCD)
                        return "WiaImgFmt_PHOTOCD";
                    else if (ClipboardFormat == WiaImgFmt_FLASHPIX)
                        return "WiaImgFmt_FLASHPIX";
                    else
                        return "** UNKNOWN **";*/


                    StressStatus("IWiaData Transfer.(CALLBACK)..Success");
                } else
                    StressStatus("* idtGetBandedData() Failed", hResult);
                pCBandedCB->Release();
            } else
                StressStatus("* pCBandedCB->QueryInterface(IID_IWiaDataCallback) Failed", hResult);
        } else
            StressStatus("* pCBandedCB failed to create..");
    } else
        StressStatus("* pIWiaItem->QueryInterface(IID_IWiaDataTransfer) Failed", hResult);
    return hResult;
}

/**************************************************************************\
* CWIA::GetMinBufferSize
*
*   Returns the minimum buffer size for an Item transfer
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    buffer size
*
* History:
*
*    6/21/1999 Original Version
*
\**************************************************************************/
long CWIA::GetMinBufferSize(IWiaItem *pIWiaItem)
{
    HRESULT hResult = S_OK;
    long MINBufferSize = 65535;
    IWiaPropertyStorage* pIWiaPropStg = NULL;
    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (SUCCEEDED(hResult)) {
        if (pIWiaPropStg != NULL) {
            hResult = ReadPropLong(WIA_IPA_MIN_BUFFER_SIZE,pIWiaPropStg,&MINBufferSize);
            if (SUCCEEDED(hResult)) {
                // whoopie!
            }

            //
            // Release IWiaPropertyStorage
            //

            pIWiaPropStg->Release();
        }
    }
    return MINBufferSize;
}


/**************************************************************************\
* CWIA::SetPreviewWindow
*
*   Sets the target painting preview window
*
*
* Arguments:
*
*    hWnd - Handle to preview window
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::SetPreviewWindow(HWND hPreviewWindow)
{
    m_hPreviewWnd = hPreviewWindow;
}
/**************************************************************************\
* CWIA::DoIWiaDataGetDataTransfer
*
*   Executes an IWiaData Transfer on an item
*
*
* Arguments:
*
*   pIWiaItem - target item
*       Tymed - TYMED value
*       ClipboardFormat - current clipboard format
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::DoIWiaDataGetDataTransfer(IWiaItem *pIWiaItem, DWORD Tymed, GUID ClipboardFormat)
{
    HRESULT hResult = S_OK;

    //
    // Check Item pointer
    //

    if (pIWiaItem == NULL) {
        StressStatus("* pIWiaItem is NULL");
        return S_FALSE;
    }

    if(!IsValidItem(pIWiaItem)) {
        StressStatus("* pIWiaItem is invalid");
        return S_FALSE;
    }

    //
    // set the two properties (TYMED, and CF_ )
    //
    IWiaPropertyStorage *pIWiaPropStg;
    PROPSPEC PropSpec;
    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (hResult != S_OK) {
        StressStatus("* pIWiaItem->QueryInterface() Failed",hResult);
        return hResult;
    } else {

        //
        // Write property value for TYMED
        //
        PropSpec.propid = WIA_IPA_TYMED;
        hResult = WritePropLong(WIA_IPA_TYMED,pIWiaPropStg,Tymed);
        if (SUCCEEDED(hResult))
            StressStatus("tymed Successfully written");
        else
            StressStatus("* WritePropLong(WIA_IPA_TYMED) Failed",hResult);

        //
        // Write property value for SUPPORTED WIA FORMAT
        //
        hResult = WritePropGUID(WIA_IPA_FORMAT,pIWiaPropStg,ClipboardFormat);
        if (hResult == S_OK)
            StressStatus("Format Successfully written");
        else
            StressStatus("* WritePropLong(WIA_IPA_FORMAT) Failed",hResult);

    }

    StressStatus("Executing an IWiaData Transfer...");

    // get IWiaDatatransfer interface
    IWiaDataTransfer *pIBandTran = NULL;
    hResult = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIBandTran);
    if (SUCCEEDED(hResult)) {

        STGMEDIUM StgMedium;
        StgMedium.tymed    = Tymed;
        StgMedium.lpszFileName   = NULL;
        StgMedium.pUnkForRelease = NULL;
        StgMedium.hGlobal        = NULL;

        //
        // create Data callback
        //

        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback* pCWiaDataCB = new CWiaDataCallback();
        if (pCWiaDataCB) {
            hResult = pCWiaDataCB->QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (hResult == S_OK) {
                pCWiaDataCB->Initialize();
                hResult = pIBandTran->idtGetData(&StgMedium,pIWiaDataCallback);
                pIBandTran->Release();
                pCWiaDataCB->Release();
                if (SUCCEEDED(hResult)) {
                    if (Tymed == TYMED_HGLOBAL)
                        MessageBox(NULL,"HGLOBAL SHOULD BE REMOVED","WIATEST BUSTED!",MB_OK);
                    else if (Tymed == TYMED_FILE) {

                        //
                        // Rename file using set file name from UI
                        //

                        if (MoveTempFile(StgMedium.lpszFileName,m_FileName)) {

                            StressStatus("IWiaData Transfer ( Saving " + m_FileName + " )");

                            //
                            // Display data (only BMP, and single page TIFF supported so far for display..)
                            //

                            /*if (ClipboardFormat == WiaImgFmt_UNDEFINED)
                                return "WiaImgFmt_UNDEFINED";
                            else if (ClipboardFormat == WiaImgFmt_MEMORYBMP)
                                return "WiaImgFmt_MEMORYBMP";*/
                            if (ClipboardFormat == WiaImgFmt_BMP)
                                m_pDIB->ReadFromBMPFile(m_FileName);
                            /*else if (ClipboardFormat == WiaImgFmt_EMF)
                                return "WiaImgFmt_EMF";
                            else if (ClipboardFormat == WiaImgFmt_WMF)
                                return "WiaImgFmt_WMF";
                            else if (ClipboardFormat == WiaImgFmt_JPEG)
                                return "WiaImgFmt_JPEG";
                            else if (ClipboardFormat == WiaImgFmt_PNG)
                                return "WiaImgFmt_PNG";
                            else if (ClipboardFormat == WiaImgFmt_GIF)
                                return "WiaImgFmt_GIF";*/
                            else if (ClipboardFormat == WiaImgFmt_TIFF)
                                m_pDIB->ReadFromTIFFFile(m_FileName);
                            /*else if (ClipboardFormat == WiaImgFmt_EXIF)
                                return "WiaImgFmt_EXIF";
                            else if (ClipboardFormat == WiaImgFmt_PHOTOCD)
                                return "WiaImgFmt_PHOTOCD";
                            else if (ClipboardFormat == WiaImgFmt_FLASHPIX)
                                return "WiaImgFmt_FLASHPIX";
                            else
                                return "** UNKNOWN **";*/
                        }
                    }
                    ReleaseStgMedium(&StgMedium);
                } else
                    StressStatus("* idtGetData() Failed",hResult);
            } else
                StressStatus("* pCWiaDataCB->QueryInterface(IID_IWiaDataCallback)",hResult);
        } else
            StressStatus("* pCWiaDataCB failed to create..");
    } else
        StressStatus("* pIWiaItem->QueryInterface(IID_IWiaDataTransfer) Failed",hResult);
    return hResult;
}
/**************************************************************************\
* CWIA::DoGetImageDlg()
*
*   Execute an Image transfer using the WIA Default User Interface
*
*
* Arguments:
*
*   hParentWnd - Parent Window
*       DeviceType - device type (scanner, camera etc..)
*   Flags - special Flags
*   Intent - Current Intent
*       Tymed - TYMED value
*       ClipboardFormat - current clipboard format
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::DoGetImageDlg(HWND hParentWnd, long DeviceType,long Flags,long Intent, long Tymed, GUID ClipboardFormat)
{
    HRESULT hResult = S_OK;

    if(!IsValidItem(m_pRootIWiaItem)) {
        StressStatus("* pRootIWiaItem is invalid");
        return S_FALSE;
    }

    STGMEDIUM StgMedium;
    WIA_FORMAT_INFO   format;
    DVTARGETDEVICE dvDev;

    // Fill in the storage medium spec and get the image.

    memset(&StgMedium, 0, sizeof(STGMEDIUM));
    memset(&dvDev,0,sizeof(DVTARGETDEVICE));
    memset(&format,0,sizeof(WIA_FORMAT_INFO));

    dvDev.tdSize = sizeof(DVTARGETDEVICE);

    hResult = m_pIWiaDevMgr->GetImageDlg(hParentWnd,DeviceType,Flags,Intent,m_pRootIWiaItem,m_FileName.AllocSysString(),&ClipboardFormat);
    if (hResult == S_OK) {
        if (Tymed == TYMED_HGLOBAL) {
            MessageBox(NULL,"HGLOBAL SHOULD BE REMOVED","WIATEST BUSTED!",MB_OK);
        } else if (Tymed == TYMED_FILE) {

            StressStatus("GetImageDlg Transfer ( Saving " + m_FileName + " )");

            //
            // Display data (only BMP, and single page TIFF supported so far for display..)
            //


            if (ClipboardFormat == WiaImgFmt_BMP)
                m_pDIB->ReadFromBMPFile(m_FileName);
            else if (ClipboardFormat == WiaImgFmt_TIFF)
                m_pDIB->ReadFromTIFFFile(m_FileName);
        }
        ReleaseStgMedium(&StgMedium);
    } else if (hResult == S_FALSE) {
        StressStatus("* User canceled Dialog");
    } else
        StressStatus("* pIWiaDevMgr->GetImageDlg() Failed", hResult);

    return hResult;
}
/**************************************************************************\
* CWIA::CreateWIADeviceManager()
*
*   Creates the IWiaDevMgr for WIA operations
*
* Arguments:
*
* none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::CreateWIADeviceManager()
{
    HRESULT hResult = S_OK;
    if (m_pIWiaDevMgr != NULL)
        m_pIWiaDevMgr->Release();

    hResult = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
                               IID_IWiaDevMgr,(void**)&m_pIWiaDevMgr);
    if (hResult != S_OK)
        StressStatus("* CoCreateInstance failed - m_pIWiaDevMgr not created");
    else
        StressStatus("CoCreateInstance Successful - m_pIWiaDevMgr created");

    return hResult;
}
/**************************************************************************\
* CWIA::Initialize()
*
*   Called by the application to Initialize the WIA object, resulting in
*   Device manager creation, and a Device Enumeration.
*   The DIB data pointer is also initialized.
*
* Arguments:
*
* none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::Initialize()
{
    HRESULT hResult = S_OK;
    hResult = ::OleInitialize(NULL);
    if (FAILED(hResult))
        return hResult;
    //
    // create a WIA device manager
    //
    hResult = CreateWIADeviceManager();
    if (FAILED(hResult))
        return hResult;

    //
    // enumerate WIA devices
    //
    hResult = EnumerateAllWIADevices();
    if (FAILED(hResult))
        return hResult;

    //
    // new DIB data pointer
    //
    if (m_pDIB == NULL)
        m_pDIB = new CDib;
    return hResult;
}
/**************************************************************************\
* CWIA::Cleanup()
*
*   Deletes allocated Enumerator lists, and releases all Interface pointers
*
* Arguments:
*
* none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::Cleanup()
{
    //
    // Free IWiaItem* list (Active Tree list)
    //
    DeleteActiveTreeList();

    //
    // Free DeviceID list (Device list)
    //
    DeleteWIADeviceList();

    //
    // Free Supported Formats list (FormatEtc list)
    //
    DeleteSupportedFormatList();

    //
    // Free Property Info list (Item Property Info list)
    //
    DeleteItemPropertyInfoList();

    //
    // release WIA Device Manager
    //
    if (m_pIWiaDevMgr)
        m_pIWiaDevMgr->Release();

    //
    // delete dib pointer, if exists
    //
    if (m_pDIB != NULL)
        delete m_pDIB;

    ::OleUninitialize();
}
/**************************************************************************\
* CWIA::EnumeratAllWIADevices()
*
*   Enumerates all WIA devices, and creates a list of WIADEVICENODES
*   A device node contains - DeviceID, used for Device creation
*                            Device Name, used for display only
*                            Server Name, used for display only
*
* Arguments:
*
* none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::EnumerateAllWIADevices()
{
    HRESULT hResult = S_OK;
    LONG cItemRoot = 0;
    BOOL bRet = FALSE;
    IEnumWIA_DEV_INFO   *pWiaEnumDevInfo;
    int DeviceIndex = 0;

    DeleteWIADeviceList();
    //
    // attempt to enumerate WIA devices
    //

    if (m_pIWiaDevMgr)
        hResult = m_pIWiaDevMgr->EnumDeviceInfo(0,&pWiaEnumDevInfo);
    else {
        StressStatus("* m_pIWiaDevMgr->EnumDeviceInfo() failed", hResult);
        return hResult;
    }
    if (hResult == S_OK) {
        do {
            IWiaPropertyStorage  *pIWiaPropStg;
            hResult = pWiaEnumDevInfo->Next(1,&pIWiaPropStg, NULL);
            if (hResult == S_OK) {
                PROPSPEC        PropSpec[3];
                PROPVARIANT     PropVar[3];

                memset(PropVar,0,sizeof(PropVar));

                PropSpec[0].ulKind = PRSPEC_PROPID;
                PropSpec[0].propid = WIA_DIP_DEV_ID;

                PropSpec[1].ulKind = PRSPEC_PROPID;
                PropSpec[1].propid = WIA_DIP_DEV_NAME;

                PropSpec[2].ulKind = PRSPEC_PROPID;
                PropSpec[2].propid = WIA_DIP_SERVER_NAME;

                hResult = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC),
                                                  PropSpec,
                                                  PropVar);

                if (hResult == S_OK) {
                    IWiaItem *pWiaItemRoot = NULL;
                    //
                    // create a new WIADevice node
                    //
                    WIADEVICENODE* pWIADevice = new WIADEVICENODE;

                    pWIADevice->bstrDeviceID = ::SysAllocString(PropVar[0].bstrVal);
                    pWIADevice->bstrDeviceName = ::SysAllocString(PropVar[1].bstrVal);
                    pWIADevice->bstrServerName = ::SysAllocString(PropVar[2].bstrVal);
                    m_WIADeviceList.AddTail(pWIADevice);

                    StressStatus((CString)pWIADevice->bstrDeviceName + " located on ( " + (CString)pWIADevice->bstrServerName + " ) server found");
                    DeviceIndex++;
                    FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);
                } else
                    StressStatus("* pIWiaPropStg->ReadMultiple() Failed", hResult);
                cItemRoot++;
            }
        } while (hResult == S_OK);
    }

    //
    // No devices found during enumeration?
    //
    if (DeviceIndex == 0)
        StressStatus("* No WIA Devices Found");
    return  hResult;
}
/**************************************************************************\
* CWIA::EnumerateSupportedFormats()
*
*   Enumerates the supported WIAFormatInfo for the target Root Item
*
* Arguments:
*
* pIRootItem - Target Root Item for enumeration
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::EnumerateSupportedFormats(IWiaItem* pIRootItem)
{
    if(!IsValidItem(pIRootItem)) {
        StressStatus("* pIRootItem is invalid");
        return S_FALSE;
    }

    DeleteSupportedFormatList();
    HRESULT hResult = S_OK;
    IWiaDataTransfer *pIWiaDataTransfer = NULL;
    hResult = pIRootItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
    if (hResult == S_OK) {
        IEnumWIA_FORMAT_INFO *pIEnumWIA_FORMAT_INFO;
        WIA_FORMAT_INFO      pfe;
        int i = 0;
        WIA_FORMAT_INFO      *pSupportedFormat = NULL;

        hResult = pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pIEnumWIA_FORMAT_INFO);
        if (SUCCEEDED(hResult)) {
            do {

                //
                // enumerate supported format structs
                //

                hResult = pIEnumWIA_FORMAT_INFO->Next(1, &pfe, NULL);
                if (hResult == S_OK) {
                    pSupportedFormat = new WIA_FORMAT_INFO;
                    memcpy(pSupportedFormat,&pfe,sizeof(WIA_FORMAT_INFO));

                    //
                    // Add supported format to the supported format list
                    //

                    m_SupportedFormatList.AddTail(pSupportedFormat);
                } else {
                    if (FAILED(hResult)) {
                        StressStatus("* pIEnumWIA_FORMAT_INFO->Next Failed",hResult);
                        return hResult;
                    }
                }
            } while (hResult == S_OK);

            //
            // Release supported format enumerator interface
            //

            pIEnumWIA_FORMAT_INFO->Release();

            //
            // Release data transfer interface
            //

            pIWiaDataTransfer->Release();
        } else
            StressStatus("* EnumWIAFormatInfo Failed",hResult);
    }
    return hResult;
}
/**************************************************************************\
* CWIA::DeleteActiveTreeList()
*
*   Deletes the active Tree list which contains Item Interface pointers,
*   including the ROOT item. All Items are Released before the list is
*   destroyed.
*
* Arguments:
*
* none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::DeleteActiveTreeList()
{
    if (m_ActiveTreeList.GetCount() == 0)
        return;

    POSITION Position = m_ActiveTreeList.GetHeadPosition();
    IWiaItem* pIWiaItem = NULL;
    while (Position) {
        WIAITEMTREENODE* pWiaItemTreeNode = (WIAITEMTREENODE*)m_ActiveTreeList.GetNext(Position);
        pIWiaItem = pWiaItemTreeNode->pIWiaItem;
        pIWiaItem->Release();
        //delete pWiaItemTreeNode;
    }
    m_ActiveTreeList.RemoveAll();
}
/**************************************************************************\
* CWIA::DeleteWIADeviceList()
*
*   Deletes the Device list of WIADEVICENODES.
*
* Arguments:
*
* none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::DeleteWIADeviceList()
{
    if (m_WIADeviceList.GetCount() == 0)
        return;

    POSITION Position = m_WIADeviceList.GetHeadPosition();
    while (Position) {
        WIADEVICENODE* pWiaDeviceNode = (WIADEVICENODE*)m_WIADeviceList.GetNext(Position);
        ::SysFreeString(pWiaDeviceNode->bstrDeviceID);
        ::SysFreeString(pWiaDeviceNode->bstrDeviceName);
        ::SysFreeString(pWiaDeviceNode->bstrServerName);
        delete pWiaDeviceNode;
    }
    m_WIADeviceList.RemoveAll();
}

/**************************************************************************\
* CWIA::DeleteItemPropertyInfoList()
*
*   Deletes the WIAITEMINFONODE list.
*
* Arguments:
*
* none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::DeleteItemPropertyInfoList()
{
    if (m_ItemPropertyInfoList.GetCount() == 0)
        return;

    POSITION Position = m_ItemPropertyInfoList.GetHeadPosition();
    while (Position) {
        WIAITEMINFONODE* pWiaItemInfoNode = (WIAITEMINFONODE*)m_ItemPropertyInfoList.GetNext(Position);
        ::SysFreeString(pWiaItemInfoNode->bstrPropertyName);
        PropVariantClear(&pWiaItemInfoNode->PropVar);
        delete pWiaItemInfoNode;
    }
    m_ItemPropertyInfoList.RemoveAll();
}
/**************************************************************************\
* CWIA::DeleteSupportedFormatList()
*
*  Deletes the FORMATECT list.
*
* Arguments:
*
* none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::DeleteSupportedFormatList()
{
    if (m_SupportedFormatList.GetCount() == 0)
        return;

    POSITION Position = m_SupportedFormatList.GetHeadPosition();
    while (Position) {
        WIA_FORMAT_INFO* pWIAFormatInfo = (WIA_FORMAT_INFO*)m_SupportedFormatList.GetNext(Position);
        delete pWIAFormatInfo;
    }
    m_SupportedFormatList.RemoveAll();
}
/**************************************************************************\
* CWIA::GetWIADeviceCount()
*
*   Return the number of Enumerated WIA Devices. (list item count)
*
* Arguments:
*
* none
*
* Return Value:
*
*    long - Number of WIA Devices
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
long CWIA::GetWIADeviceCount()
{
    return (long)m_WIADeviceList.GetCount();
}
/**************************************************************************\
* CWIA::SetFileName()
*
*   Sets the Filename for a TYMED_FILE transfer
*
* Arguments:
*
* none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::SetFileName(CString Filename)
{
    m_FileName = Filename;
}
/**************************************************************************\
* CWIA::Auto_ResetItemEnumerator()
*
*   Resets the ActiveTreeList position pointer to the top for a top-down
*   enumeration by an application.
*
* Arguments:
*
* none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::Auto_ResetItemEnumerator()
{
    m_CurrentActiveTreeListPosition = m_ActiveTreeList.GetHeadPosition();
}
/**************************************************************************\
* CWIA::Auto_GetNextItem()
*
*   Returns a IWiaItem* pointer, next Item in the ActiveTreeList
*
* Arguments:
*
* none
*
* Return Value:
*
*   IWiaItem* - IWiaItem Interface pointer
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
IWiaItem* CWIA::Auto_GetNextItem()
{
    IWiaItem* pIWiaItem = NULL;
    if (m_CurrentItemProperyInfoListPosition) {
        WIAITEMTREENODE* pWiaItemTreeNode = (WIAITEMTREENODE*)m_ActiveTreeList.GetNext(m_CurrentActiveTreeListPosition);
        pIWiaItem = pWiaItemTreeNode->pIWiaItem;
    }
    return pIWiaItem;
}
/**************************************************************************\
* CWIA::Auto_ResetDeviceEnumerator()
*
*   Resets the Device List position pointer to the top for a top-down
*   enumeration by an application.
*
* Arguments:
*
* none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::Auto_ResetDeviceEnumerator()
{
    m_CurrentDeviceListPosition = m_WIADeviceList.GetHeadPosition();
}
/**************************************************************************\
* CWIA::Auto_GetNextDevice()
*
*   Returns a WIADEVICENODE* pointer, next Device in the WIA Device List
*
* Arguments:
*
* none
*
* Return Value:
*
*   WIADEVICENODE* - Wia Device Node pointer
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
WIADEVICENODE* CWIA::Auto_GetNextDevice()
{
    WIADEVICENODE* pWiaDeviceNode = NULL;
    if (m_CurrentDeviceListPosition)
        pWiaDeviceNode = (WIADEVICENODE*)m_WIADeviceList.GetNext(m_CurrentDeviceListPosition);
    return pWiaDeviceNode;
}
/**************************************************************************\
* CWIA::Auto_GetNextFormatEtc()
*
*   Returns a WIA_FORMAT_INFO* pointer, next WIAFormatInfo in the supported WIAFormatInfo List
*
* Arguments:
*
* none
*
* Return Value:
*
*   WIA_FORMAT_INFO* - WIAFormatInfo pointer
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
WIA_FORMAT_INFO* CWIA::Auto_GetNextFormatEtc()
{
    WIA_FORMAT_INFO* pWIAFormatInfo = NULL;
    if (m_CurrentFormatEtcListPosition)
        WIA_FORMAT_INFO* pWIAFormatInfo = (WIA_FORMAT_INFO*)m_SupportedFormatList.GetNext(m_CurrentFormatEtcListPosition);
    return pWIAFormatInfo;
}
/**************************************************************************\
* CWIA::Auto_ResetFormatEtcEnumerator()
*
*   Resets the Supported Format Etc List position pointer to the top for a top-down
*   enumeration by an application.
*
* Arguments:
*
* none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::Auto_ResetFormatEtcEnumerator()
{
    m_CurrentFormatEtcListPosition = m_SupportedFormatList.GetHeadPosition();
}
/**************************************************************************\
* CWIA::CreateWIADevice()
*
*   Creates a WIA Device, Initializing the WIA object to operate on that
*   device.  Initialization includes the following:
*   Destruction of Old Items tree.
*   Destruction of old supported formats
*   Recreation of Items tree.
*   Recreation of supported formats
*
* Arguments:
*
* none
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::CreateWIADevice(BSTR bstrDeviceID)
{
    //
    // clean up old lists
    //
    DeleteActiveTreeList();
    DeleteSupportedFormatList();
    HRESULT hResult = S_OK;
    hResult = m_pIWiaDevMgr->CreateDevice(bstrDeviceID, &m_pRootIWiaItem);
    if (SUCCEEDED(hResult)) {
        hResult = EnumerateAllItems(m_pRootIWiaItem);
        if (FAILED(hResult))
            StressStatus("* EnumerateAllItems Failed",hResult);
        hResult = EnumerateSupportedFormats(m_pRootIWiaItem);
        if (FAILED(hResult))
            StressStatus("* EnumerateSupportedFormats Failed",hResult);
    } else if (hResult == WAIT_TIMEOUT) {
        for (int TryCount = 1;TryCount <=5;TryCount++) {
            int msWait = ((rand() % 100) + 10);
            Sleep(msWait);
            hResult = m_pIWiaDevMgr->CreateDevice(bstrDeviceID, &m_pRootIWiaItem);
            if (SUCCEEDED(hResult)) {
                TryCount = 6;
                hResult = EnumerateAllItems(m_pRootIWiaItem);
                if (FAILED(hResult))
                    StressStatus("* EnumerateAllItems Failed",hResult);
                hResult = EnumerateSupportedFormats(m_pRootIWiaItem);
                if (FAILED(hResult))
                    StressStatus("* EnumerateSupportedFormats Failed",hResult);
            }
        }
    } else
        StressStatus("* CreateDevice Failed",hResult);
    return hResult;
}
/**************************************************************************\
* CWIA::GetWIAItemCount()
*
*   Returns the number of Items for the current device
*
* Arguments:
*
*   none
*
* Return Value:
*
*   long - number of items
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
long CWIA::GetWIAItemCount()
{
    return (long)m_ActiveTreeList.GetCount();
}
/**************************************************************************\
* CWIA::Auto_GetNextItemPropertyInfo()
*
*   Returns the next WIAITEMINFONODE pointer in the Property information list
*
* Arguments:
*
*   none
*
* Return Value:
*
*   WIAITEMINFONODE* - WIA Item node pointer
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
WIAITEMINFONODE* CWIA:: Auto_GetNextItemPropertyInfo()
{
    WIAITEMINFONODE* pWiaItemPropertyInfoNode = NULL;
    if (m_CurrentItemProperyInfoListPosition)
        pWiaItemPropertyInfoNode = (WIAITEMINFONODE*)m_ItemPropertyInfoList.GetNext(m_CurrentItemProperyInfoListPosition);
    return pWiaItemPropertyInfoNode;

}
/**************************************************************************\
* CWIA::Auto_ResetItemPropertyInfoEnumerator()
*
*   Resets the Item Property enumerator to the Head of the
*   Item Property list
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA:: Auto_ResetItemPropertyInfoEnumerator()
{
    m_CurrentItemProperyInfoListPosition = m_ItemPropertyInfoList.GetHeadPosition();
}
/**************************************************************************\
* CWIA::GetItemPropertyInfoCount()
*
*   returns the number of Properties for the current Item
*
* Arguments:
*
*   none
*
* Return Value:
*
*   long - Number of properties for the current item
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
long CWIA::GetWIAItemProperyInfoCount()
{
    return (long)m_ItemPropertyInfoList.GetCount();
}
/**************************************************************************\
* CWIA::CreateItemPropertyInformationList()
*
*   Constructs a list of WIAITEMINFONODEs that contain information about
*   the target item.
*   A Item Property info node contains - PropSpec, used for read/writes
*                                        PropVar, used for read/write
*                                        bstrPropertyName, used for display only
*                                        AccessFlags, access rights/flags
*
* Arguments:
*
*   pIWiaItem - target item
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::CreateItemPropertyInformationList(IWiaItem *pIWiaItem)
{
    if(!IsValidItem(pIWiaItem)) {
        StressStatus("* pIWiaItem is invalid");
        return S_FALSE;
    }

    DeleteItemPropertyInfoList();

    HRESULT hResult = S_OK;
    IWiaPropertyStorage *pIWiaPropStg = NULL;

    if (pIWiaItem == NULL)
        return E_FAIL;

    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (hResult == S_OK) {
        //
        // Start Enumeration
        //
        IEnumSTATPROPSTG    *pIPropEnum;
        hResult = pIWiaPropStg->Enum(&pIPropEnum);
        if (hResult == S_OK) {
            STATPROPSTG StatPropStg;
            do {
                hResult = pIPropEnum->Next(1,&StatPropStg, NULL);
                if (hResult == S_OK) {
                    if (StatPropStg.lpwstrName != NULL) {
                        //
                        // read property value
                        //
                        WIAITEMINFONODE* pWiaItemInfoNode = new WIAITEMINFONODE;
                        memset(pWiaItemInfoNode,0,sizeof(WIAITEMINFONODE));
                        pWiaItemInfoNode->bstrPropertyName = ::SysAllocString(StatPropStg.lpwstrName);
                        pWiaItemInfoNode->PropSpec.ulKind = PRSPEC_PROPID;
                        pWiaItemInfoNode->PropSpec.propid = StatPropStg.propid;

                        hResult = pIWiaPropStg->ReadMultiple(1,&pWiaItemInfoNode->PropSpec,&pWiaItemInfoNode->PropVar);
                        if (hResult == S_OK) {
                            PROPVARIANT     AttrPropVar; // not used at this time
                            hResult = pIWiaPropStg->GetPropertyAttributes(1, &pWiaItemInfoNode->PropSpec,&pWiaItemInfoNode->AccessFlags,&AttrPropVar);
                            if (hResult != S_OK) {
                                StressStatus("* pIWiaItem->GetPropertyAttributes() Failed",hResult);
                                hResult = S_OK; // do this to continue property traversal
                            }
                            m_ItemPropertyInfoList.AddTail(pWiaItemInfoNode);
                        } else
                            StressStatus("* ReadMultiple Failed",hResult);
                    } else {
                        CString msg;
                        msg.Format("* Property with NULL name, propid = %li\n",StatPropStg.propid);
                        StressStatus(msg);
                    }
                }
                //
                // clean up property name
                //
                CoTaskMemFree(StatPropStg.lpwstrName);
            } while (hResult == S_OK);

        }
        if (pIPropEnum != NULL)
            pIPropEnum->Release();
        if (pIWiaPropStg != NULL)
            pIWiaPropStg->Release();
    }
    return S_OK;
}
/**************************************************************************\
* CWIA::ReEnumeratetems()
*
*   ReCreates an Active Tree list of all items using the target Root Item
*
* Arguments:
*
* none
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::ReEnumerateItems()
{
    HRESULT hResult = S_OK;
    if (m_ActiveTreeList.GetCount() == 0)
        return E_FAIL;

    POSITION Position = m_ActiveTreeList.GetHeadPosition();
    //
    // skip root item
    //
    m_ActiveTreeList.GetNext(Position);
    IWiaItem* pIWiaItem = NULL;
    while (Position) {
        WIAITEMTREENODE* pWiaItemTreeNode = (WIAITEMTREENODE*)m_ActiveTreeList.GetNext(Position);
        pIWiaItem = pWiaItemTreeNode->pIWiaItem;
        pIWiaItem->Release();
    }
    hResult = EnumerateAllItems(m_pRootIWiaItem);
    return hResult;
}
/**************************************************************************\
* CWIA::EnumerateAllItems()
*
*   Creates an Active Tree list of all items using the target Root Item
*
* Arguments:
*
* pRootItem - target root item
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::EnumerateAllItems(IWiaItem *pIRootItem)
{
    HRESULT hResult = S_OK;

    if(!IsValidItem(pIRootItem)) {
        StressStatus("* pIRootItem is invalid");
        return S_FALSE;
    }

    IEnumWiaItem* pEnumItem = NULL;
    IWiaItem* pIWiaItem = NULL;
    WIAITEMTREENODE* pWiaItemTreeNode = NULL;
    int ParentID = 0;
    //
    // clean existing list
    //

    m_ActiveTreeList.RemoveAll();
    if (pIRootItem != NULL) {
        // add Root to list
        pWiaItemTreeNode = (WIAITEMTREENODE*)GlobalAlloc(GPTR,sizeof(WIAITEMTREENODE));
        pWiaItemTreeNode->pIWiaItem = pIRootItem;
        pWiaItemTreeNode->ParentID = ParentID;
        m_ActiveTreeList.AddTail(pWiaItemTreeNode);
        hResult = pIRootItem->EnumChildItems(&pEnumItem);
        //
        // we have children so continue to enumerate them
        //
        if (hResult == S_OK && pEnumItem != NULL) {
            EnumNextLevel(pEnumItem,ParentID);
            pEnumItem->Release();
        }
    } else {
        //
        // pRootItem is NULL!!
        //
        StressStatus("* pRootItem is NULL");
        return E_INVALIDARG;
    }
    return  hResult;
}
/**************************************************************************\
* CWIA::EnumNextLevel()
*
*   Continues the Active Tree list creation of all items using a target Root Item
*
* Arguments:
*
* pEnumItem - Item Enumerator
* ParentID - Parent ID (Recursive tracking for display only)
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::EnumNextLevel(IEnumWiaItem *pEnumItem,int ParentID)
{
    IWiaItem *pIWiaItem;
    long      lType;
    HRESULT   hResult;
    WIAITEMTREENODE* pWiaItemTreeNode = NULL;

    while (pEnumItem->Next(1,&pIWiaItem,NULL) == S_OK) {
        if (pIWiaItem != NULL) {
            pWiaItemTreeNode = (WIAITEMTREENODE*)GlobalAlloc(GPTR,sizeof(WIAITEMTREENODE));
            pWiaItemTreeNode->pIWiaItem = pIWiaItem;
            pWiaItemTreeNode->ParentID = ParentID;
            m_ActiveTreeList.AddTail(pWiaItemTreeNode);
        } else
            return E_FAIL;

        // find out if the item is a folder, if it is,
        // recursive enumerate
        pIWiaItem->GetItemType(&lType);
        if (lType & WiaItemTypeFolder) {
            IEnumWiaItem *pEnumNext;
            hResult = pIWiaItem->EnumChildItems(&pEnumNext);
            if (hResult == S_OK) {
                EnumNextLevel(pEnumNext,ParentID + 1);
                pEnumNext->Release();
            }
        }
    }
    return S_OK;
}
/**************************************************************************\
* CWIA::GetItemTreeList()
*
*   Returns a pointer to the Active Tree list containing all items.
*   note:   Some Applications need to make list operations using previously
*           stored POSITIONS in the list. Applications should not destroy
*           this list. The WIA object controls the destruction.
*
* Arguments:
*
* none
*
* Return Value:
*
*   CPtrList* - pointer to the Active Tree list
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CPtrList* CWIA::GetItemTreeList()
{
    return &m_ActiveTreeList;
}
/**************************************************************************\
* CWIA::GetRootIWiaItem()
*
* Returns the Root item for the current WIA session
*
* Arguments:
*
* pRootItem - target root item
*
* Return Value:
*
*   IWiaItem* pRootItem;
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
IWiaItem* CWIA::GetRootIWiaItem()
{
    return m_pRootIWiaItem;
}
/**************************************************************************\
* CWIA::IsRoot()
*
*   Checks the POSITION against with the Head POSITION in the list.
*   if the POSITIONS match then it's the Root Item.
*
* Arguments:
*
*  Position - Position to test
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIA::IsRoot(POSITION Position)
{
    if (m_ActiveTreeList.GetHeadPosition() == Position)
        return TRUE;
    else
        return FALSE;
}
/**************************************************************************\
* CWIA::IsFolder()
*
*   Checks the item at the target POSITION about it's type.
*
* Arguments:
*
*  Position - Position to test
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIA::IsFolder(POSITION Position)
{
    IWiaItem* pIWiaItem = NULL;
    long lVal = 0;
    if (Position) {
        WIAITEMTREENODE* pWiaItemTreeNode = (WIAITEMTREENODE*)m_ActiveTreeList.GetAt(Position);
        pIWiaItem = pWiaItemTreeNode->pIWiaItem;
    }
    if (pIWiaItem != NULL) {
        IWiaPropertyStorage *pIWiaPropStg;
        HRESULT hResult = S_OK;
        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (hResult == S_OK) {
            //
            // read Item's Type
            //
            hResult = ReadPropLong(WIA_IPA_ITEM_FLAGS, pIWiaPropStg, &lVal);
            if (hResult != S_OK)
                StressStatus("* ReadPropLong(WIA_IPA_ITEM_FLAGS) Failed",hResult);
            else
                pIWiaPropStg->Release();
            if (lVal == WiaItemTypeFolder) {
                return TRUE;
            } else {
                return FALSE;
            }
        }
    } else
        return FALSE;
    return FALSE;
}
/**************************************************************************\
* CWIA::GetAt()
*
*   Returns the WIAITEMTREENODE* at the target position
*
* Arguments:
*
*  Position - target Position
*
* Return Value:
*
*   WIAITEMTREENODE* pWiaItemTreeNode - requested node
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
WIAITEMTREENODE* CWIA::GetAt(POSITION Position)
{
    POSITION TestPosition = m_ActiveTreeList.GetHeadPosition();
    if (TestPosition == Position)
        return(m_ActiveTreeList.GetAt(Position));
    while (TestPosition) {
        m_ActiveTreeList.GetNext(TestPosition);
        if (TestPosition == Position)
            return(m_ActiveTreeList.GetAt(Position));
    }
    return NULL;
}
/**************************************************************************\
* CWIA::GetRootItemType()
*
*  Returns the Root item's type
*
* Arguments:
*
*  none
*
* Return Value:
*
*   Root Item's Type (device type)
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
int CWIA::GetRootItemType()
{
    long lVal = 0;
    if (m_pRootIWiaItem != NULL) {
        IWiaPropertyStorage *pIWiaPropStg;
        HRESULT hResult = S_OK;
        hResult = m_pRootIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (hResult == S_OK) {
            //
            // read Root Item's Type
            //
            hResult = ReadPropLong(WIA_DIP_DEV_TYPE, pIWiaPropStg, &lVal);
            if (hResult != S_OK)
                StressStatus("* ReadPropLong(WIA_DIP_DEV_TYPE) Failed",hResult);
            else
                pIWiaPropStg->Release();
        }
    }
    return(GET_STIDEVICE_TYPE(lVal));
}
/**************************************************************************\
* CWIA::RemoveAt()
*
*  Removes the WIAITEMTREENODE* at the target position
*
* Arguments:
*
*  Position - target Position
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::RemoveAt(POSITION Position)
{
    m_ActiveTreeList.RemoveAt(Position);
}
/**************************************************************************\
* CWIA::GetDIB()
*
*   Returns the CDIB pointer for display
*
* Arguments:
*
*  none
*
* Return Value:
*
*   CDib* - Pointer to a CDIB object
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/

CDib* CWIA::GetDIB()
{
    return m_pDIB;
}
/**************************************************************************\
* CWIA::GetSupportedFormatList()
*
*   Returns a pointer to the supported format list
*
* Arguments:
*
*  none
*
* Return Value:
*
*   CPtrList* - pointer to Supported FormatEtc list
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CPtrList* CWIA::GetSupportedFormatList()
{
    return &m_SupportedFormatList;
}
/**************************************************************************\
* CWIA::RegisterForConnectEvents()
*
*   Registers an application for Connect events only
*
* Arguments:
*
*   pConnectEventCB - pointer to a callback
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::RegisterForConnectEvents(CEventCallback* pConnectEventCB)
{
    HRESULT hResult = S_OK;
    IWiaEventCallback* pIWiaEventCallback = NULL;
    IUnknown*       pIUnkRelease;

    // register connected event
    pConnectEventCB->Initialize(ID_WIAEVENT_CONNECT);
    pConnectEventCB->QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);

    GUID guidConnect = WIA_EVENT_DEVICE_CONNECTED;
    hResult = m_pIWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                            NULL,
                                                            &guidConnect,
                                                            pIWiaEventCallback,
                                                            &pIUnkRelease);

    pConnectEventCB->m_pIUnkRelease = pIUnkRelease;
    return hResult;
}
/**************************************************************************\
* CWIA::UnRegisterForConnectEvents()
*
*   UnRegisters an application from Connect events only.
*   note: callback interface is released, and deleted by
*         this routine.
*
* Arguments:
*
*   pConnectEventCB - pointer to a callback
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/

HRESULT CWIA::UnRegisterForConnectEvents(CEventCallback* pConnectEventCB)
{
    if (pConnectEventCB) {
        //IWiaEventCallback* pIWiaEventCallback = NULL;
        //pConnectEventCB->QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);
        //
        // unregister connected
        //GUID guidConnect = WIA_EVENT_DEVICE_CONNECTED;
        //hResult = m_pIWiaDevMgr->RegisterEventCallbackInterface(WIA_UNREGISTER_EVENT_CALLBACK,
        //                                                        NULL,
        //                                                        &guidConnect,
        //                                                        pIWiaEventCallback);
        //if (hResult == S_OK)
        //    StressStatus("ConnectEventCB unregistered successfully...");
        //else
        //    StressStatus("* ConnectEventCB failed to unregister..",hResult);

        pConnectEventCB->m_pIUnkRelease->Release();
        pConnectEventCB->m_pIUnkRelease = NULL;
        pConnectEventCB->Release();
    }


    return S_OK;
}
/**************************************************************************\
* CWIA::RegisterForDisConnectEvents()
*
*   Registers an application for disconnect events only
*
* Arguments:
*
*   pDisConnectEventCB - pointer to a callback
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::RegisterForDisConnectEvents(CEventCallback* pDisConnectEventCB)
{
    HRESULT hResult = S_OK;

    IWiaEventCallback* pIWiaEventCallback = NULL;
    IUnknown*       pIUnkRelease;

    // register disconnected event
    pDisConnectEventCB->Initialize(ID_WIAEVENT_DISCONNECT);
    pDisConnectEventCB->QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);

    GUID guidDisconnect = WIA_EVENT_DEVICE_DISCONNECTED;
    hResult = m_pIWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                            NULL,
                                                            &guidDisconnect,
                                                            pIWiaEventCallback,
                                                            &pIUnkRelease);

    pDisConnectEventCB->m_pIUnkRelease = pIUnkRelease;

    return hResult;
}
/**************************************************************************\
* CWIA::UnRegisterForDisConnectEvents()
*
*   UnRegisters an application from disconnect events only.
*   note: callback interface is released, and deleted by
*         this routine.
*
* Arguments:
*
*   pDisConnectEventCB - pointer to a callback
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::UnRegisterForDisConnectEvents(CEventCallback* pDisConnectEventCB)
{
    if (pDisConnectEventCB) {
        //IWiaEventCallback* pIWiaEventCallback = NULL;
        //pDisConnectEventCB->QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);
        //
        //// unregister disconnected
        //GUID guidDisconnect = WIA_EVENT_DEVICE_DISCONNECTED;
        //hResult = m_pIWiaDevMgr->RegisterEventCallbackInterface(WIA_UNREGISTER_EVENT_CALLBACK,
        //                                                        NULL,
        //                                                        &guidDisconnect,
        //                                                        pIWiaEventCallback);
        //if (hResult == S_OK)
        //    StressStatus("DisConnectEventCB unregistered successfully...");
        //else
        //    StressStatus("* DisConnectEventCB failed to unregister..",hResult);

        pDisConnectEventCB->m_pIUnkRelease->Release();
        pDisConnectEventCB->m_pIUnkRelease = NULL;
        pDisConnectEventCB->Release();
    }

    return S_OK;
}
/**************************************************************************\
* CWIA::Shutdown()
*
*   Forces a temporary shut down of the WIA object
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::Shutdown()
{
    //
    // Free IWiaItem* list (Active Tree list)
    //
    DeleteActiveTreeList();

    //
    // Free DeviceID list (Device list)
    //
    DeleteWIADeviceList();

    //
    // Free Supported Formats list (FormatEtc list)
    //
    DeleteSupportedFormatList();

    //
    // release WIA Device Manager
    //
    if (m_pIWiaDevMgr) {
        m_pIWiaDevMgr->Release();
        m_pIWiaDevMgr = NULL;
    }
}
/**************************************************************************\
* CWIA::Restart()
*
*   Forces a reintialization from a Previous ShutDown() call
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::Restart()
{
    HRESULT hResult = S_OK;
    //
    // create a WIA device manager
    //
    hResult = CreateWIADeviceManager();
    if (FAILED(hResult))
        StressStatus("* CreateWIADeviceManager Failed",hResult);

    //
    // enumerate WIA devices
    //
    hResult = EnumerateAllWIADevices();
    if (FAILED(hResult))
        StressStatus("*  EnumerateAllWIADevices Failed",hResult);
}
/**************************************************************************\
* CWIA::EnableMessageBoxErrorReport()
*
*   Enables, disables MessageBox reporting to the user
*
* Arguments:
*
*   bEnable - (TRUE = enable) (FALSE = disable)
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIA::EnableMessageBoxErrorReport(BOOL bEnable)
{
    m_bMessageBoxReport = bEnable;
}

/**************************************************************************\
* CWIA::SavePropStreamToFile()
*
*   Saves a property stream from an IWiaItem to a file
*
* Arguments:
*
*   pFileName - Property Stream file name
*   pIWiaItem - Item, to save stream from
*
* Return Value:
*
*   status
*
* History:
*
*    6/8/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::SavePropStreamToFile(char* pFileName, IWiaItem* pIWiaItem)
{
    IStream     *pIStrm  = NULL;

    CFile               StreamFile;
    CFileException      Exception;
    HRESULT             hResult = S_OK;
    IWiaPropertyStorage *pIWiaPropStg;
    GUID                guidCompatId;

    if (pIWiaItem != NULL) {

        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropStg);
        if (FAILED(hResult)) {
            StressStatus("* QI for IWiaPropertySTorage Failed",hResult);
            return hResult;
        }

        hResult = pIWiaPropStg->GetPropertyStream(&guidCompatId, &pIStrm);
        if (SUCCEEDED(hResult)) {

            //
            // Save Property Stream to File (propstrm.wia).  We choose to ignore the CompatID
            //

            //
            // open file, this will create a new file every time (overwriting the original)
            //

            if ( StreamFile.Open(pFileName,CFile::modeCreate|CFile::modeWrite,&Exception)) {

                //
                // Get stream size.
                //

                ULARGE_INTEGER uliSize;
                LARGE_INTEGER  liOrigin = {0,0};

                pIStrm->Seek(liOrigin, STREAM_SEEK_END, &uliSize);

                DWORD dwSize = uliSize.u.LowPart;

                if (dwSize) {

                    //
                    // write stream size in first 4 byte location
                    //

                    StreamFile.Write(&dwSize, sizeof(long));

                    //
                    // Read the stream data into a buffer.
                    //

                    PBYTE pBuf = (PBYTE) LocalAlloc(0, dwSize);
                    if (pBuf) {
                        pIStrm->Seek(liOrigin, STREAM_SEEK_SET, NULL);

                        ULONG ulRead;

                        pIStrm->Read(pBuf, dwSize, &ulRead);

                        //
                        // write stream to file
                        //

                        StreamFile.Write(pBuf, ulRead);
                        LocalFree(pBuf);
                    }
                }

                StreamFile.Close();
            } else {

                //
                // Throw an Exception for Open Failure
                //

                AfxThrowFileException(Exception.m_cause);
            }

            pIStrm->Release();
        } else {
            StressStatus("* GetPropertyStream Failed",hResult);
        }
        pIWiaPropStg->Release();
    }
    return hResult;
}

/**************************************************************************\
* CWIA::ReadPropStreamFromFile()
*
*   Reads a property stream from an a previously saved file
*   and writes this stream to the pIWiaItem
*
* Arguments:
*
*   pFileName - Property Stream file name
*   pIWiaItem - Item, to save stream to
*
* Return Value:
*
*   status
*
* History:
*
*    6/8/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::ReadPropStreamFromFile(char* pFileName, IWiaItem* pIWiaItem)
{
    HGLOBAL             hMem         = NULL;
    LPSTREAM            pstmProp     = NULL;
    LPBYTE              pStreamData  = NULL;
    CFile               StreamFile;
    CFileException      Exception;
    HRESULT             hResult = S_OK;
    IWiaPropertyStorage *pIWiaPropStg;

    if (pIWiaItem != NULL) {

        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropStg);
        if (FAILED(hResult)) {
            StressStatus("* QI for IWiaPropertySTorage Failed",hResult);
            return hResult;
        }

        //
        // Open stream data file
        //

        if ( StreamFile.Open(pFileName,CFile::modeRead,&Exception)) {

            //
            // read the size of the stream from stream data file
            //

            DWORD dwSize = 0;
            StreamFile.Read(&dwSize,sizeof(long));
            if (dwSize) {

                //
                // allocate memory for hMem, which will be Locked to
                // create pStreamData
                //

                hMem = GlobalAlloc(GMEM_MOVEABLE, dwSize);
                if (hMem) {

                    pStreamData = (LPBYTE)GlobalLock(hMem);
                    if (pStreamData != NULL) {

                        //
                        // Read stored stream data from stream file
                        //

                        if (StreamFile.Read(pStreamData,dwSize) != dwSize) {
                            StressStatus("File contains different amount of data than specified by header...");

                            //
                            // clean up and bail
                            //

                            GlobalUnlock(hMem);
                            GlobalFree(pStreamData);

                            //
                            // close file
                            //

                            StreamFile.Close();
                            return E_FAIL;
                        } else {

                            //
                            // Create the hStream
                            //

                            hResult = CreateStreamOnHGlobal(hMem, TRUE, &pstmProp);
                            if (SUCCEEDED(hResult)) {

                                //
                                // Set stored property stream back to IWiaItem.  Use
                                // GUID_NULL for CompatId since we didn't store it.
                                //

                                hResult = pIWiaPropStg->SetPropertyStream((GUID*) &GUID_NULL, pstmProp);
                                if (SUCCEEDED(hResult))
                                    StressStatus("Stream was successfully written....");
                                else
                                    StressStatus("* SetPropertyStream Failed",hResult);

                                //
                                // Release stream (IStream*)
                                //

                                pstmProp->Release();

                            } else{
                                StressStatus("* CreateStreamOnHGlobal() failed",hResult);
                            }
                        }
                        GlobalUnlock(hMem);
                    } else{
                        StressStatus("* GlobalLock() Failed");
                    }
                } else{
                    StressStatus("* GlobalAlloc Failed");
                }
            } else {
                StressStatus("* Stream size read from file was 0 bytes");
            }

            //
            // close file
            //

            StreamFile.Close();
        } else {

            //
            // Throw an Exception for Open Failure
            //

            AfxThrowFileException(Exception.m_cause);
        }
        pIWiaPropStg->Release();
    }
    return hResult;
}

/**************************************************************************\
* CWIA::GetSetPropStreamTest()
*
*   Gets the property stream from the item, and
*   Sets it back to the same item.
*
* Arguments:
*
*   pIWiaItem - Item, to Test
*
* Return Value:
*
*   status
*
* History:
*
*    6/8/1999 Original Version
*
\**************************************************************************/
HRESULT CWIA::GetSetPropStreamTest(IWiaItem* pIWiaItem)
{
    HGLOBAL             hStream = NULL;
    LPSTREAM            pstmProp = NULL;
    CFile               StreamFile;
    CFileException      Exception;
    HRESULT             hResult = S_OK;
    IWiaPropertyStorage *pIWiaPropStg;
    GUID                guidCompatId;

    if (pIWiaItem != NULL) {
        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropStg);
        if (FAILED(hResult)) {
            StressStatus("* QI for IWiaPropertySTorage Failed",hResult);
            return hResult;
        }

        hResult = pIWiaPropStg->GetPropertyStream(&guidCompatId, &pstmProp);
        if (SUCCEEDED(hResult)) {
            hResult = pIWiaPropStg->SetPropertyStream(&guidCompatId, pstmProp);
            if (SUCCEEDED(hResult))
                MessageBox(NULL,"Successful GET - SET stream call","WIATest Debug Status",MB_OK);
            else
                StressStatus("* SetPropertyStream() Failed",hResult);

            //
            // Free the stream
            //

            pstmProp->Release();
        } else
            StressStatus("* GetPropertyStream() Failed",hResult);
        pIWiaPropStg->Release();
    }
    return hResult;
}

/**************************************************************************\
* CWIA::AnalyzeItem()
*
*   Runs the AnalyzeItem method from the specified IWiaItem.
*
* Arguments:
*
*   pIWiaItem - Item, to run analysis on
*
* Return Value:
*
*   status
*
* History:
*
*    01/13/2000 Original Version
*
\**************************************************************************/
HRESULT CWIA::AnalyzeItem(IWiaItem* pIWiaItem)
{
    return pIWiaItem->AnalyzeItem(0);
}

/**************************************************************************\
* CWIA::CreateChildItem()
*
*   Runs the CreateChildItem method from the specified IWiaItem.
*
* Arguments:
*
*   pIWiaItem - Item, to run CreateChildItem on
*
* Return Value:
*
*   status
*
* History:
*
*    01/13/2000 Original Version
*
\**************************************************************************/
HRESULT CWIA::CreateChildItem(IWiaItem *pIWiaItem)
{
    HRESULT             hr              = E_FAIL;
    IWiaItem            *pNewIWiaItem   = NULL;
    IWiaPropertyStorage *pIWiaPropStg   = NULL;
    BSTR                bstrName        = NULL;
    BSTR                bstrFullName    = NULL;
    WCHAR               wszName[MAX_PATH];
    WCHAR               wszFullName[MAX_PATH];

    //
    //  Get the property storage so we can read the full item name.
    //

    hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,
                                   (VOID**)&pIWiaPropStg);
    if (SUCCEEDED(hr)) {

        hr = ReadPropStr(WIA_IPA_FULL_ITEM_NAME,
                         pIWiaPropStg,
                         &bstrFullName);
        if (SUCCEEDED(hr)) {

            //
            //  Fill in the item name and full item name.
            //

            wcscpy(wszName, L"WiaTestItem");
            wcscpy(wszFullName, bstrFullName);
            wcscat(wszFullName, L"\\");
            wcscat(wszFullName, wszName);

            SysFreeString(bstrFullName);
            bstrFullName = SysAllocString(wszFullName);
            bstrName = SysAllocString(wszName);

            if (bstrFullName && bstrName) {
                hr = pIWiaItem->CreateChildItem(WiaItemTypeTransfer |
                                                WiaItemTypeImage |
                                                WiaItemTypeFile,
                                                bstrName,
                                                bstrFullName,
                                                &pNewIWiaItem);
                if (SUCCEEDED(hr)) {

                    //
                    //  Release the newly created item which was returned
                    //  to us.
                    //

                    pNewIWiaItem->Release();
                } else {
                    StressStatus("* CreateChildItem call failed");
                }
            } else {
                hr = E_OUTOFMEMORY;
                StressStatus("* Could not allocate name strings");
            }
        } else {
            StressStatus("* Could not read full item name");
        }

        pIWiaPropStg->Release();
    } else {
        StressStatus("* QI for IWiaPropertyStorage failed");
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiastress\wrappers.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Wrappers.h

Abstract:

    Contains some commonly used macros, inline utility functions and
    wrapper/helper classes

Author:

    Hakki T. Bostanci (hakkib) 06-Apr-2000

Revision History:

--*/

#ifndef _WRAPPERS_H_
#define _WRAPPERS_H_

//////////////////////////////////////////////////////////////////////////
//
// Cross references
//

#include <assert.h>

#include "Conv.h"
#include "Result.h"

//////////////////////////////////////////////////////////////////////////
//
//
//

#ifndef ASSERT
#define ASSERT assert
#endif

typedef CONST TCHAR *PCTSTR;

#if !defined(NDEBUG) || defined(_DEBUG) || defined(DBG)
#ifndef DEBUG
#define DEBUG
#endif //DEBUG
#endif

#ifdef 