Object( &handle,
                                      DIRECTORY_ALL_ACCESS,
                                      &objectAttributes );
    if (!NT_SUCCESS( status )) {
        return FALSE;
    } else {
        (VOID) ObCloseHandle( handle , KernelMode);
    }

    return TRUE;
}

NTSTATUS
IopInitializeAttributesAndCreateObject(
    IN PUNICODE_STRING ObjectName,
    IN OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PDRIVER_OBJECT *DriverObject
    )

/*++

Routine Description:

    This routine is invoked to initialize a set of object attributes and
    to create a driver object.

Arguments:

    ObjectName - Supplies the name of the driver object.

    ObjectAttributes - Supplies a pointer to the object attributes structure
        to be initialized.

    DriverObject - Supplies a variable to receive a pointer to the resultant
        created driver object.

Return Value:

    The function value is the final status of the operation.

--*/

{
    NTSTATUS status;

    //
    // Simply initialize the object attributes and create the driver object.
    //

    InitializeObjectAttributes( ObjectAttributes,
                                ObjectName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ObCreateObject( KeGetPreviousMode(),
                             IoDriverObjectType,
                             ObjectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) (sizeof( DRIVER_OBJECT ) + sizeof ( DRIVER_EXTENSION )),
                             0,
                             0,
                             (PVOID *)DriverObject );
    return status;
}

NTSTATUS
IopInitializeBuiltinDriver(
    IN PUNICODE_STRING DriverName,
    IN PUNICODE_STRING RegistryPath,
    IN PDRIVER_INITIALIZE DriverInitializeRoutine,
    IN PKLDR_DATA_TABLE_ENTRY DriverEntry,
    IN BOOLEAN IsFilter,
    IN PDRIVER_OBJECT *Result
    )

/*++

Routine Description:

    This routine is invoked to initialize a built-in driver.

Arguments:

    DriverName - Specifies the name to be used in creating the driver object.

    RegistryPath - Specifies the path to be used by the driver to get to
        the registry.

    DriverInitializeRoutine - Specifies the initialization entry point of
        the built-in driver.

    DriverEntry - Specifies the driver data table entry to determine if the
        driver is a wdm driver.

Return Value:

    The function returns a pointer to a DRIVER_OBJECT if the built-in
    driver successfully initialized.  Otherwise, a value of NULL is returned.

--*/

{
    HANDLE handle;
    PDRIVER_OBJECT driverObject;
    PDRIVER_OBJECT tmpDriverObject;
    OBJECT_ATTRIBUTES objectAttributes;
    PWSTR buffer;
    NTSTATUS status;
    HANDLE serviceHandle;
    PWSTR pserviceName;
    USHORT serviceNameLength;
    PDRIVER_EXTENSION driverExtension;
    PIMAGE_NT_HEADERS ntHeaders;
    PVOID imageBase;
#if DBG
    LARGE_INTEGER stime, etime;
    ULONG dtime;
#endif
    PLIST_ENTRY entry;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;

    *Result = NULL;
    //
    // Log the file name
    //
    HeadlessKernelAddLogEntry(HEADLESS_LOG_LOADING_FILENAME, DriverName);

    //
    // Begin by creating the driver object.
    //

    status = IopInitializeAttributesAndCreateObject( DriverName,
                                                     &objectAttributes,
                                                     &driverObject );
    if (!NT_SUCCESS( status )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_FAILED, NULL);
        return status;
    }

    //
    // Initialize the driver object.
    //

    InitializeDriverObject( driverObject );
    driverObject->DriverInit = DriverInitializeRoutine;

    //
    // Insert the driver object into the object table.
    //

    status = ObInsertObject( driverObject,
                             NULL,
                             FILE_READ_DATA,
                             0,
                             (PVOID *) NULL,
                             &handle );

    if (!NT_SUCCESS( status )) {
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_FAILED, NULL);
        return status;
    }

    //
    // Reference the handle and obtain a pointer to the driver object so that
    // the handle can be deleted without the object going away.
    //

    status = ObReferenceObjectByHandle( handle,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode,
                                        (PVOID *) &tmpDriverObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    ASSERT(status == STATUS_SUCCESS);
    //
    // Fill in the DriverSection so the image will be automatically unloaded on
    // failures. We should use the entry from the PsModuleList.
    //

    entry = PsLoadedModuleList.Flink;
    while (entry != &PsLoadedModuleList && DriverEntry) {
        DataTableEntry = CONTAINING_RECORD(entry,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);
        if (RtlEqualString((PSTRING)&DriverEntry->BaseDllName,
                    (PSTRING)&DataTableEntry->BaseDllName,
                    TRUE
                    )) {
            driverObject->DriverSection = DataTableEntry;
            break;
        }
        entry = entry->Flink;
    }

    //
    // The boot process takes a while loading drivers.   Indicate that
    // progress is being made.
    //

    InbvIndicateProgress();

    //
    // Get start and sice for the DriverObject.
    //

    if (DriverEntry) {
        imageBase = DriverEntry->DllBase;
        ntHeaders = RtlImageNtHeader(imageBase);
        driverObject->DriverStart = imageBase;
        driverObject->DriverSize = ntHeaders->OptionalHeader.SizeOfImage;
        if (!(ntHeaders->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_WDM_DRIVER)) {
            driverObject->Flags |= DRVO_LEGACY_DRIVER;
        }
    } else {
        ntHeaders = NULL;
        imageBase = NULL;
        driverObject->Flags |= DRVO_LEGACY_DRIVER;
    }

    //
    // Save the name of the driver so that it can be easily located by functions
    // such as error logging.
    //

    buffer = ExAllocatePool( PagedPool, DriverName->MaximumLength + 2 );

    if (buffer) {
        driverObject->DriverName.Buffer = buffer;
        driverObject->DriverName.MaximumLength = DriverName->MaximumLength;
        driverObject->DriverName.Length = DriverName->Length;

        RtlCopyMemory( driverObject->DriverName.Buffer,
                       DriverName->Buffer,
                       DriverName->MaximumLength );
        buffer[DriverName->Length >> 1] = (WCHAR) '\0';
    }

    //
    // Save the name of the service key so that it can be easily located by PnP
    // mamager.
    //

    driverExtension = driverObject->DriverExtension;
    if (RegistryPath && RegistryPath->Length != 0) {
        pserviceName = RegistryPath->Buffer + RegistryPath->Length / sizeof (WCHAR) - 1;
        if (*pserviceName == OBJ_NAME_PATH_SEPARATOR) {
            pserviceName--;
        }
        serviceNameLength = 0;
        while (pserviceName != RegistryPath->Buffer) {
            if (*pserviceName == OBJ_NAME_PATH_SEPARATOR) {
                pserviceName++;
                break;
            } else {
                serviceNameLength += sizeof(WCHAR);
                pserviceName--;
            }
        }
        if (pserviceName == RegistryPath->Buffer) {
            serviceNameLength += sizeof(WCHAR);
        }
        buffer = ExAllocatePool( NonPagedPool, serviceNameLength + sizeof(UNICODE_NULL) );

        if (buffer) {
            driverExtension->ServiceKeyName.Buffer = buffer;
            driverExtension->ServiceKeyName.MaximumLength = serviceNameLength + sizeof(UNICODE_NULL);
            driverExtension->ServiceKeyName.Length = serviceNameLength;

            RtlCopyMemory( driverExtension->ServiceKeyName.Buffer,
                           pserviceName,
                           serviceNameLength );
            buffer[driverExtension->ServiceKeyName.Length >> 1] = UNICODE_NULL;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            driverExtension->ServiceKeyName.Buffer = NULL;
            driverExtension->ServiceKeyName.Length = 0;
            goto exit;
        }

        //
        // Prepare driver initialization
        //

        status = IopOpenRegistryKeyEx( &serviceHandle,
                                       NULL,
                                       RegistryPath,
                                       KEY_ALL_ACCESS
                                       );
        if (NT_SUCCESS(status)) {
            status = IopPrepareDriverLoading(&driverExtension->ServiceKeyName,
                                             serviceHandle,
                                             imageBase,
                                             IsFilter);
            NtClose(serviceHandle);
            if (!NT_SUCCESS(status)) {
                goto exit;
            }
        } else {
            goto exit;
        }
    } else {
        driverExtension->ServiceKeyName.Buffer = NULL;
        driverExtension->ServiceKeyName.MaximumLength = 0;
        driverExtension->ServiceKeyName.Length = 0;
    }

    //
    // Load the Registry information in the appropriate fields of the device
    // object.
    //

    driverObject->HardwareDatabase = &CmRegistryMachineHardwareDescriptionSystemName;

#if DBG
    KeQuerySystemTime (&stime);
#endif

    //
    // Now invoke the driver's initialization routine to initialize itself.
    //


    status = driverObject->DriverInit( driverObject, RegistryPath );


#if DBG

    //
    // If DriverInit took longer than 5 seconds or the driver did not load,
    // print a message.
    //

    KeQuerySystemTime (&etime);
    dtime  = (ULONG) ((etime.QuadPart - stime.QuadPart) / 1000000);

    if (dtime > 50  ||  !NT_SUCCESS( status )) {
        if (dtime < 10) {
            DbgPrint( "IOINIT: Built-in driver %wZ failed to initialize - %lX\n",
                DriverName, status );

        } else {
            DbgPrint( "IOINIT: Built-in driver %wZ took %d.%ds to ",
                DriverName, dtime/10, dtime%10 );

            if (NT_SUCCESS( status )) {
                DbgPrint ("initialize\n");
            } else {
                DbgPrint ("fail initialization - %lX\n", status);
            }
        }
    }
#endif
exit:

    NtClose( handle );

    if (NT_SUCCESS( status )) {
        IopReadyDeviceObjects( driverObject );
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_SUCCESSFUL, NULL);
        *Result = driverObject;
        return status;
    } else {
        if (status != STATUS_PLUGPLAY_NO_DEVICE) {

            //
            // if STATUS_PLUGPLAY_NO_DEVICE, the driver was disable by hardware profile.
            //

            IopDriverLoadingFailed(NULL, &driverObject->DriverExtension->ServiceKeyName);
        }
        HeadlessKernelAddLogEntry(HEADLESS_LOG_LOAD_FAILED, NULL);
        ObMakeTemporaryObject(driverObject);
        ObDereferenceObject (driverObject);
        return status;
    }
}

BOOLEAN
IopMarkBootPartition(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine is invoked to locate and mark the boot partition device object
    as a boot device so that subsequent operations can fail more cleanly and
    with a better explanation of why the system failed to boot and run properly.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block created
        by the OS Loader during the boot process.  This structure contains
        the various system partition and boot device names and paths.

Return Value:

    The function value is TRUE if everything worked, otherwise FALSE.

Notes:

    If the boot partition device object cannot be found, then the system will
    bugcheck.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    STRING deviceNameString;
    CHAR deviceNameBuffer[256];
    UNICODE_STRING deviceNameUnicodeString;
    NTSTATUS status;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    PFILE_OBJECT fileObject;
    CHAR ArcNameFmt[12];

    ArcNameFmt[0] = '\\';
    ArcNameFmt[1] = 'A';
    ArcNameFmt[2] = 'r';
    ArcNameFmt[3] = 'c';
    ArcNameFmt[4] = 'N';
    ArcNameFmt[5] = 'a';
    ArcNameFmt[6] = 'm';
    ArcNameFmt[7] = 'e';
    ArcNameFmt[8] = '\\';
    ArcNameFmt[9] = '%';
    ArcNameFmt[10] = 's';
    ArcNameFmt[11] = '\0';
    //
    // Open the ARC boot device object. The boot device driver should have
    // created the object.
    //

    sprintf( deviceNameBuffer,
             ArcNameFmt,
             LoaderBlock->ArcBootDeviceName );

    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );

    status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                           &deviceNameString,
                                           TRUE );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &deviceNameUnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = ZwOpenFile( &fileHandle,
                         FILE_READ_ATTRIBUTES,
                         &objectAttributes,
                         &ioStatus,
                         0,
                         FILE_NON_DIRECTORY_FILE );
    if (!NT_SUCCESS( status )) {
        KeBugCheckEx( INACCESSIBLE_BOOT_DEVICE,
                      (ULONG_PTR) &deviceNameUnicodeString,
                      status,
                      0,
                      0 );
    }

    //
    // Convert the file handle into a pointer to the device object itself.
    //

    status = ObReferenceObjectByHandle( fileHandle,
                                        0,
                                        IoFileObjectType,
                                        KernelMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        RtlFreeUnicodeString( &deviceNameUnicodeString );
        return FALSE;
    }

    //
    // Mark the device object represented by the file object.
    //

    fileObject->DeviceObject->Flags |= DO_SYSTEM_BOOT_PARTITION;

    //
    // Save away the characteristics of boot device object for later
    // use in WinPE mode
    //
    if (InitIsWinPEMode) {
        if (fileObject->DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA) {
            InitWinPEModeType |= INIT_WINPEMODE_REMOVABLE_MEDIA;
        }

        if (fileObject->DeviceObject->Characteristics & FILE_READ_ONLY_DEVICE) {
            InitWinPEModeType |= INIT_WINPEMODE_READONLY_MEDIA;
        }
    }

    //
    // Reference the device object and store the reference.
    //
    ObReferenceObject(fileObject->DeviceObject);

    IopErrorLogObject =  fileObject->DeviceObject;

    RtlFreeUnicodeString( &deviceNameUnicodeString );

    //
    // Finally, close the handle and dereference the file object.
    //

    ObCloseHandle( fileHandle, KernelMode);
    ObDereferenceObject( fileObject );

    return TRUE;
}

BOOLEAN
IopReassignSystemRoot(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    OUT PSTRING NtDeviceName
    )

/*++

Routine Description:

    This routine is invoked to reassign \SystemRoot from being an ARC path
    name to its NT path name equivalent.  This is done by looking up the
    ARC device name as a symbolic link and determining which NT device object
    is referred to by it.  The link is then replaced with the new name.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block created
        by the OS Loader during the boot process.  This structure contains
        the various system partition and boot device names and paths.

    NtDeviceName - Specifies a pointer to a STRING to receive the NT name of
        the device from which the system was booted.

Return Value:

    The function value is a BOOLEAN indicating whether or not the ARC name
    was resolved to an NT name.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    CHAR deviceNameBuffer[256];
    WCHAR arcNameUnicodeBuffer[64];
    CHAR arcNameStringBuffer[256];
    STRING deviceNameString;
    STRING arcNameString;
    STRING linkString;
    UNICODE_STRING linkUnicodeString;
    UNICODE_STRING deviceNameUnicodeString;
    UNICODE_STRING arcNameUnicodeString;
    HANDLE linkHandle;

#if DBG

    CHAR debugBuffer[256];
    STRING debugString;
    UNICODE_STRING debugUnicodeString;

#endif
    CHAR ArcNameFmt[12];

    ArcNameFmt[0] = '\\';
    ArcNameFmt[1] = 'A';
    ArcNameFmt[2] = 'r';
    ArcNameFmt[3] = 'c';
    ArcNameFmt[4] = 'N';
    ArcNameFmt[5] = 'a';
    ArcNameFmt[6] = 'm';
    ArcNameFmt[7] = 'e';
    ArcNameFmt[8] = '\\';
    ArcNameFmt[9] = '%';
    ArcNameFmt[10] = 's';
    ArcNameFmt[11] = '\0';

    //
    // Open the ARC boot device symbolic link object. The boot device
    // driver should have created the object.
    //

    sprintf( deviceNameBuffer,
             ArcNameFmt,
             LoaderBlock->ArcBootDeviceName );

    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );

    status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                           &deviceNameString,
                                           TRUE );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &deviceNameUnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = NtOpenSymbolicLinkObject( &linkHandle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &objectAttributes );

    if (!NT_SUCCESS( status )) {

#if DBG

        sprintf( debugBuffer, "IOINIT: unable to resolve %s, Status == %X\n",
                 deviceNameBuffer,
                 status );

        RtlInitAnsiString( &debugString, debugBuffer );

        status = RtlAnsiStringToUnicodeString( &debugUnicodeString,
                                               &debugString,
                                               TRUE );

        if (NT_SUCCESS( status )) {
            ZwDisplayString( &debugUnicodeString );
            RtlFreeUnicodeString( &debugUnicodeString );
        }

#endif // DBG

        RtlFreeUnicodeString( &deviceNameUnicodeString );
        return FALSE;
    }

    //
    // Get handle to \SystemRoot symbolic link.
    //

    arcNameUnicodeString.Buffer = arcNameUnicodeBuffer;
    arcNameUnicodeString.Length = 0;
    arcNameUnicodeString.MaximumLength = sizeof( arcNameUnicodeBuffer );

    status = NtQuerySymbolicLinkObject( linkHandle,
                                        &arcNameUnicodeString,
                                        NULL );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    arcNameString.Buffer = arcNameStringBuffer;
    arcNameString.Length = 0;
    arcNameString.MaximumLength = sizeof( arcNameStringBuffer );

    status = RtlUnicodeStringToAnsiString( &arcNameString,
                                           &arcNameUnicodeString,
                                           FALSE );

    arcNameStringBuffer[arcNameString.Length] = '\0';

    ObCloseHandle( linkHandle, KernelMode );
    RtlFreeUnicodeString( &deviceNameUnicodeString );

    RtlInitAnsiString( &linkString, INIT_SYSTEMROOT_LINKNAME );

    status = RtlAnsiStringToUnicodeString( &linkUnicodeString,
                                           &linkString,
                                           TRUE);

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &linkUnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = NtOpenSymbolicLinkObject( &linkHandle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &objectAttributes );

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    NtMakeTemporaryObject( linkHandle );
    ObCloseHandle( linkHandle, KernelMode );

    sprintf( deviceNameBuffer,
             "%Z%s",
             &arcNameString,
             LoaderBlock->NtBootPathName );

    //
    // Get NT device name for \SystemRoot assignment.
    //

    RtlCopyString( NtDeviceName, &arcNameString );

    deviceNameBuffer[strlen(deviceNameBuffer)-1] = '\0';

    RtlInitAnsiString(&deviceNameString, deviceNameBuffer);

    InitializeObjectAttributes( &objectAttributes,
                                &linkUnicodeString,
                                OBJ_CASE_INSENSITIVE | OBJ_PERMANENT|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = RtlAnsiStringToUnicodeString( &arcNameUnicodeString,
                                           &deviceNameString,
                                           TRUE);

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    status = NtCreateSymbolicLinkObject( &linkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &objectAttributes,
                                         &arcNameUnicodeString );

    RtlFreeUnicodeString( &arcNameUnicodeString );
    RtlFreeUnicodeString( &linkUnicodeString );
    ObCloseHandle( linkHandle, KernelMode );

#if DBG

    if (NT_SUCCESS( status )) {

        sprintf( debugBuffer,
                 "INIT: Reassigned %s => %s\n",
                 INIT_SYSTEMROOT_LINKNAME,
                 deviceNameBuffer );

    } else {

        sprintf( debugBuffer,
                 "INIT: unable to create %s => %s, Status == %X\n",
                 INIT_SYSTEMROOT_LINKNAME,
                 deviceNameBuffer,
                 status );
    }

    RtlInitAnsiString( &debugString, debugBuffer );

    status = RtlAnsiStringToUnicodeString( &debugUnicodeString,
                                           &debugString,
                                           TRUE );

    if (NT_SUCCESS( status )) {

        ZwDisplayString( &debugUnicodeString );
        RtlFreeUnicodeString( &debugUnicodeString );
    }

#endif // DBG

    return TRUE;
}

VOID
IopStoreSystemPartitionInformation(
    IN     PUNICODE_STRING NtSystemPartitionDeviceName,
    IN OUT PUNICODE_STRING OsLoaderPathName
    )

/*++

Routine Description:

    This routine writes two values to the registry (under HKLM\SYSTEM\Setup)--one
    containing the NT device name of the system partition and the other containing
    the path to the OS loader.  These values will later be migrated into a
    Win95-compatible registry location (NT path converted to DOS path), so that
    installation programs (including our own setup) have a rock-solid way of knowing
    what the system partition is, on both ARC and x86.

    ERRORS ENCOUNTERED IN THIS ROUTINE ARE NOT CONSIDERED FATAL.

Arguments:

    NtSystemPartitionDeviceName - supplies the NT device name of the system partition.
        This is the \Device\Harddisk<n>\Partition<m> name, which used to be the actual
        device name, but now is a symbolic link to a name of the form \Device\Volume<x>.
        We open up this symbolic link, and retrieve the name that it points to.  The
        target name is the one we store away in the registry.

    OsLoaderPathName - supplies the path (on the partition specified in the 1st parameter)
        where the OS loader is located.  Upon return, this path will have had its trailing
        backslash removed (if present, and path isn't root).

Return Value:

    None.

--*/

{
    NTSTATUS status;
    HANDLE linkHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE systemHandle, setupHandle;
    UNICODE_STRING nameString, volumeNameString;
    WCHAR voumeNameStringBuffer[256];
    //
    // Declare a unicode buffer big enough to contain the longest string we'll be using.
    // (ANSI string in 'sizeof()' below on purpose--we want the number of chars here.)
    //
    WCHAR nameBuffer[sizeof("SystemPartition")];

    //
    // Both UNICODE_STRING buffers should be NULL-terminated.
    //

    ASSERT( NtSystemPartitionDeviceName->MaximumLength >= NtSystemPartitionDeviceName->Length + sizeof(WCHAR) );
    ASSERT( NtSystemPartitionDeviceName->Buffer[NtSystemPartitionDeviceName->Length / sizeof(WCHAR)] == L'\0' );

    ASSERT( OsLoaderPathName->MaximumLength >= OsLoaderPathName->Length + sizeof(WCHAR) );
    ASSERT( OsLoaderPathName->Buffer[OsLoaderPathName->Length / sizeof(WCHAR)] == L'\0' );

    //
    // Open the NtSystemPartitionDeviceName symbolic link, and find out the volume device
    // it points to.
    //

    InitializeObjectAttributes(&objectAttributes,
                               NtSystemPartitionDeviceName,
                               OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL
                              );

    status = NtOpenSymbolicLinkObject(&linkHandle,
                                      SYMBOLIC_LINK_QUERY,
                                      &objectAttributes
                                     );

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't open symbolic link %wZ - %x\n",
                 NtSystemPartitionDeviceName,
                 status
                );
#endif // DBG
        return;
    }

    volumeNameString.Buffer = voumeNameStringBuffer;
    volumeNameString.Length = 0;
    //
    // Leave room at the end of the buffer for a terminating null, in case we need to add one.
    //
    volumeNameString.MaximumLength = sizeof(voumeNameStringBuffer) - sizeof(WCHAR);

    status = NtQuerySymbolicLinkObject(linkHandle,
                                       &volumeNameString,
                                       NULL
                                      );

    //
    // We don't need the handle to the symbolic link any longer.
    //

    ObCloseHandle(linkHandle, KernelMode);

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't query symbolic link %wZ - %x\n",
                 NtSystemPartitionDeviceName,
                 status
                );
#endif // DBG
        return;
    }

    //
    // Make sure the volume name string is null-terminated.
    //

    volumeNameString.Buffer[volumeNameString.Length / sizeof(WCHAR)] = L'\0';

    //
    // Open HKLM\SYSTEM key.
    //

    status = IopOpenRegistryKeyEx( &systemHandle,
                                   NULL,
                                   &CmRegistryMachineSystemName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't open \\REGISTRY\\MACHINE\\SYSTEM - %x\n", status);
#endif // DBG
        return;
    }

    //
    // Now open/create the setup subkey.
    //

    ASSERT( sizeof(L"Setup") <= sizeof(nameBuffer) );

    nameBuffer[0] = L'S';
    nameBuffer[1] = L'e';
    nameBuffer[2] = L't';
    nameBuffer[3] = L'u';
    nameBuffer[4] = L'p';
    nameBuffer[5] = L'\0';

    nameString.MaximumLength = sizeof(L"Setup");
    nameString.Length        = sizeof(L"Setup") - sizeof(WCHAR);
    nameString.Buffer        = nameBuffer;

    status = IopCreateRegistryKeyEx( &setupHandle,
                                     systemHandle,
                                     &nameString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    ObCloseHandle(systemHandle, KernelMode);  // Don't need the handle to the HKLM\System key anymore.

    if (!NT_SUCCESS(status)) {
#if DBG
        DbgPrint("IopStoreSystemPartitionInformation: couldn't open Setup subkey - %x\n", status);
#endif // DBG
        return;
    }

    ASSERT( sizeof(L"SystemPartition") <= sizeof(nameBuffer) );

    nameBuffer[0]  = L'S';
    nameBuffer[1]  = L'y';
    nameBuffer[2]  = L's';
    nameBuffer[3]  = L't';
    nameBuffer[4]  = L'e';
    nameBuffer[5]  = L'm';
    nameBuffer[6]  = L'P';
    nameBuffer[7]  = L'a';
    nameBuffer[8]  = L'r';
    nameBuffer[9]  = L't';
    nameBuffer[10] = L'i';
    nameBuffer[11] = L't';
    nameBuffer[12] = L'i';
    nameBuffer[13] = L'o';
    nameBuffer[14] = L'n';
    nameBuffer[15] = L'\0';

    nameString.MaximumLength = sizeof(L"SystemPartition");
    nameString.Length        = sizeof(L"SystemPartition") - sizeof(WCHAR);



    status = NtSetValueKey(setupHandle,
                            &nameString,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            volumeNameString.Buffer,
                            volumeNameString.Length + sizeof(WCHAR)
                           );


#if DBG
    if (!NT_SUCCESS(status)) {
        DbgPrint("IopStoreSystemPartitionInformation: couldn't write SystemPartition value - %x\n", status);
    }
#endif // DBG

    ASSERT( sizeof(L"OsLoaderPath") <= sizeof(nameBuffer) );

    nameBuffer[0]  = L'O';
    nameBuffer[1]  = L's';
    nameBuffer[2]  = L'L';
    nameBuffer[3]  = L'o';
    nameBuffer[4]  = L'a';
    nameBuffer[5]  = L'd';
    nameBuffer[6]  = L'e';
    nameBuffer[7]  = L'r';
    nameBuffer[8]  = L'P';
    nameBuffer[9]  = L'a';
    nameBuffer[10] = L't';
    nameBuffer[11] = L'h';
    nameBuffer[12] = L'\0';

    nameString.MaximumLength = sizeof(L"OsLoaderPath");
    nameString.Length        = sizeof(L"OsLoaderPath") - sizeof(WCHAR);

    //
    // Strip off the trailing backslash from the path (unless, of course, the path is a
    // single backslash).
    //

    if ((OsLoaderPathName->Length > sizeof(WCHAR)) &&
        (*(PWCHAR)((PCHAR)OsLoaderPathName->Buffer + OsLoaderPathName->Length - sizeof(WCHAR)) == L'\\')) {

        OsLoaderPathName->Length -= sizeof(WCHAR);
        *(PWCHAR)((PCHAR)OsLoaderPathName->Buffer + OsLoaderPathName->Length) = L'\0';
    }

    status = NtSetValueKey(setupHandle,
                           &nameString,
                           TITLE_INDEX_VALUE,
                           REG_SZ,
                           OsLoaderPathName->Buffer,
                           OsLoaderPathName->Length + sizeof(WCHAR)
                           );
#if DBG
    if (!NT_SUCCESS(status)) {
        DbgPrint("IopStoreSystemPartitionInformation: couldn't write OsLoaderPath value - %x\n", status);
    }
#endif // DBG

    ObCloseHandle(setupHandle, KernelMode);
}

NTSTATUS
IopLogErrorEvent(
    IN ULONG            SequenceNumber,
    IN ULONG            UniqueErrorValue,
    IN NTSTATUS         FinalStatus,
    IN NTSTATUS         SpecificIOStatus,
    IN ULONG            LengthOfInsert1,
    IN PWCHAR           Insert1,
    IN ULONG            LengthOfInsert2,
    IN PWCHAR           Insert2
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:
    SequenceNumber - A value that is unique to an IRP over the life of the irp in
    this driver. - 0 generally means an error not associated with an IRP

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    STATUS_SUCCESS - Success
    STATUS_INVALID_HANDLE - Uninitialized error log device object
    STATUS_NO_DATA_DETECTED - NULL Error log entry

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PUCHAR ptrToFirstInsert;
    PUCHAR ptrToSecondInsert;

    if (!IopErrorLogObject) {
        return(STATUS_INVALID_HANDLE);
    }


    errorLogEntry = IoAllocateErrorLogEntry(
                        IopErrorLogObject,
                        (UCHAR)( sizeof(IO_ERROR_LOG_PACKET) +
                                LengthOfInsert1 +
                                LengthOfInsert2) );

   if ( errorLogEntry != NULL ) {

      errorLogEntry->ErrorCode = SpecificIOStatus;
      errorLogEntry->SequenceNumber = SequenceNumber;
      errorLogEntry->MajorFunctionCode = 0;
      errorLogEntry->RetryCount = 0;
      errorLogEntry->UniqueErrorValue = UniqueErrorValue;
      errorLogEntry->FinalStatus = FinalStatus;
      errorLogEntry->DumpDataSize = 0;

      ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

      ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

      if (LengthOfInsert1) {

         errorLogEntry->NumberOfStrings = 1;
         errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                (PUCHAR)errorLogEntry);
         RtlCopyMemory(
                      ptrToFirstInsert,
                      Insert1,
                      LengthOfInsert1
                      );

         if (LengthOfInsert2) {

            errorLogEntry->NumberOfStrings = 2;
            RtlCopyMemory(
                         ptrToSecondInsert,
                         Insert2,
                         LengthOfInsert2
                         );

         } //LenghtOfInsert2

      } // LenghtOfInsert1

      IoWriteErrorLogEntry(errorLogEntry);
      return(STATUS_SUCCESS);

   }  // errorLogEntry != NULL

    return(STATUS_NO_DATA_DETECTED);

} //IopLogErrorEvent

BOOLEAN
IopInitializeReserveIrp(
    PIOP_RESERVE_IRP_ALLOCATOR  Allocator
    )
/*++

Routine Description:

    This routine initializes the reserve IRP allocator for paging reads.

Arguments:

    Allocator - Pointer to the reserve IRP allocator structure.
        created by the OS Loader.

Return Value:

    The function value is a BOOLEAN indicating whether or not the reserver allocator
    was successfully initialized.

--*/
{
    Allocator->ReserveIrpStackSize = MAX_RESERVE_IRP_STACK_SIZE;
    Allocator->ReserveIrp = IoAllocateIrp(MAX_RESERVE_IRP_STACK_SIZE, FALSE);
    if (Allocator->ReserveIrp == NULL) {
        return FALSE;
    }

    Allocator->IrpAllocated = FALSE;
    KeInitializeEvent(&Allocator->Event, SynchronizationEvent, FALSE);

    return TRUE;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\iomgr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    iomgr.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

--*/

#ifndef _IOMGR_
#define _IOMGR_
//
// Define Information fields values for the return value from popups when a
// volume mount is in progress but failed.
//

#define IOP_ABORT                       1

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment within conditional expression

#include "ntos.h"
#include "ntdddisk.h"
#include "ntddscsi.h"
#include "mountmgr.h"
#include "ntiolog.h"
#include "ntiologc.h"
#include "ntseapi.h"
#include "fsrtl.h"
#include "zwapi.h"

#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "safeboot.h"
#include "ioverifier.h"

#include "iopcmn.h"

#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'  oI')
#undef ExAllocatePoolWithQuota
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'  oI')
#endif

typedef struct _DUMP_CONTROL_BLOCK DUMP_CONTROL_BLOCK, *PDUMP_CONTROL_BLOCK;

//
// Define the type for entries placed on the driver reinitialization queue.
// These entries are entered onto the tail when the driver requests that
// it be reinitialized, and removed from the head by the code that actually
// performs the reinitialization.
//

typedef struct _REINIT_PACKET {
    LIST_ENTRY ListEntry;
    PDRIVER_OBJECT DriverObject;
    PDRIVER_REINITIALIZE DriverReinitializationRoutine;
    PVOID Context;
} REINIT_PACKET, *PREINIT_PACKET;


//
// Define transfer types for process counters.
//

typedef enum _TRANSFER_TYPE {
    ReadTransfer,
    WriteTransfer,
    OtherTransfer
} TRANSFER_TYPE, *PTRANSFER_TYPE;

//
// Define the maximum amount of memory that can be allocated for all
// outstanding error log packets.
//

#define IOP_MAXIMUM_LOG_ALLOCATION (100*PAGE_SIZE)

//
// Define an error log entry.
//

typedef struct _ERROR_LOG_ENTRY {
    USHORT Type;
    USHORT Size;
    LIST_ENTRY ListEntry;
    PDEVICE_OBJECT DeviceObject;
    PDRIVER_OBJECT DriverObject;
    LARGE_INTEGER TimeStamp;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

//
//  Define both the global IOP_HARD_ERROR_QUEUE and IOP_HARD_ERROR_PACKET
//  structures.   Also set the maximum number of outstanding hard error
//  packets allowed.
//

typedef struct _IOP_HARD_ERROR_QUEUE {
    WORK_QUEUE_ITEM ExWorkItem;
    LIST_ENTRY WorkQueue;
    KSPIN_LOCK WorkQueueSpinLock;
    KSEMAPHORE WorkQueueSemaphore;
    BOOLEAN ThreadStarted;
    LONG   NumPendingApcPopups;
} IOP_HARD_ERROR_QUEUE, *PIOP_HARD_ERROR_QUEUE;

typedef struct _IOP_HARD_ERROR_PACKET {
    LIST_ENTRY WorkQueueLinks;
    NTSTATUS ErrorStatus;
    UNICODE_STRING String;
} IOP_HARD_ERROR_PACKET, *PIOP_HARD_ERROR_PACKET;

typedef struct _IOP_APC_HARD_ERROR_PACKET {
    WORK_QUEUE_ITEM Item;
    PIRP Irp;
    PVPB Vpb;
    PDEVICE_OBJECT RealDeviceObject;
} IOP_APC_HARD_ERROR_PACKET, *PIOP_APC_HARD_ERROR_PACKET;

typedef
NTSTATUS
(FASTCALL *PIO_CALL_DRIVER) (
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress
    );

typedef
VOID
(FASTCALL *PIO_COMPLETE_REQUEST) (
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

typedef
VOID
(*PIO_FREE_IRP) (
    IN struct _IRP *Irp
    );

typedef
PIRP
(*PIO_ALLOCATE_IRP) (
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota
    );

extern IOP_HARD_ERROR_QUEUE IopHardError;
extern PIOP_HARD_ERROR_PACKET IopCurrentHardError;

#define IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS 25

typedef struct _IO_WORKITEM {
    WORK_QUEUE_ITEM WorkItem;
    PIO_WORKITEM_ROUTINE Routine;
    PDEVICE_OBJECT DeviceObject;
    PVOID Context;
#if DBG
    ULONG Size;
#endif
} IO_WORKITEM;

//
// Define the global data for the error logger and I/O system.
//

extern WORK_QUEUE_ITEM IopErrorLogWorkItem;
extern BOOLEAN IopErrorLogPortPending;
extern BOOLEAN IopErrorLogDisabledThisBoot;
extern ALIGNED_SPINLOCK IopErrorLogLock;
extern LIST_ENTRY IopErrorLogListHead;
extern LONG IopErrorLogAllocation;
extern KSPIN_LOCK IopErrorLogAllocationLock;
extern const GENERIC_MAPPING IopFileMapping;

//
// Define a dummy file object for use on stack for fast open operations.
//

typedef struct _DUMMY_FILE_OBJECT {
    OBJECT_HEADER ObjectHeader;
    CHAR FileObjectBody[ sizeof( FILE_OBJECT ) ];
} DUMMY_FILE_OBJECT, *PDUMMY_FILE_OBJECT;

//
// Define the structures private to the I/O system.
//

#define OPEN_PACKET_PATTERN  0xbeaa0251

//
// Define an Open Packet (OP).  An OP is used to communicate information
// between the NtCreateFile service executing in the context of the caller
// and the device object parse routine.  It is the parse routine who actually
// creates the file object for the file.
//

typedef struct _OPEN_PACKET {
    CSHORT Type;
    CSHORT Size;
    PFILE_OBJECT FileObject;
    NTSTATUS FinalStatus;
    ULONG_PTR Information;
    ULONG ParseCheck;
    PFILE_OBJECT RelatedFileObject;

    //
    // The following are the open-specific parameters.  Notice that the desired
    // access field is passed through to the parse routine via the object
    // management architecture, so it does not need to be repeated here.  Also
    // note that the same is true for the file name.
    //

    LARGE_INTEGER AllocationSize;
    ULONG CreateOptions;
    USHORT FileAttributes;
    USHORT ShareAccess;
    PVOID EaBuffer;
    ULONG EaLength;
    ULONG Options;
    ULONG Disposition;

    //
    // The following is used when performing a fast query during open to get
    // back the file attributes for a file.
    //

    PFILE_BASIC_INFORMATION BasicInformation;

    //
    // The following is used when performing a fast network query during open
    // to get back the network file attributes for a file.
    //

    PFILE_NETWORK_OPEN_INFORMATION NetworkInformation;

    //
    // The type of file to create.
    //

    CREATE_FILE_TYPE CreateFileType;

    //
    // The following pointer provides a way of passing the parameters
    // specific to the file type of the file being created to the parse
    // routine.
    //

    PVOID ExtraCreateParameters;

    //
    // The following is used to indicate that an open of a device has been
    // performed and the access check for the device has already been done,
    // but because of a reparse, the I/O system has been called again for
    // the same device.  Since the access check has already been made, the
    // state cannot handle being called again (access was already granted)
    // and it need not anyway since the check has already been made.
    //

    BOOLEAN Override;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of querying its attributes.  This causes a considerable
    // number of shortcuts to be taken in the parse, query, and close paths.
    //

    BOOLEAN QueryOnly;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of deleting it.  This causes a considerable number of
    // shortcurs to be taken in the parse and close paths.
    //

    BOOLEAN DeleteOnly;

    //
    // The following is used to indicate that a file being opened for a query
    // only is being opened to query its network attributes rather than just
    // its FAT file attributes.
    //

    BOOLEAN FullAttributes;

    //
    // The following pointer is used when a fast open operation for a fast
    // delete or fast query attributes call is being made rather than a
    // general file open.  The dummy file object is actually stored on the
    // the caller's stack rather than allocated pool to speed things up.
    //

    PDUMMY_FILE_OBJECT LocalFileObject;

    //
    // The following is used to indicate we passed through a mount point while
    // parsing the filename. We use this to do an extra check on the device type
    // for the final file
    //

    BOOLEAN TraversedMountPoint;

    //
    // Device object where the create should start if present on the stack
    // Applicable for kernel opens only.
    //

    ULONG           InternalFlags;      // Passed from IopCreateFile
    PDEVICE_OBJECT  TopDeviceObjectHint;

} OPEN_PACKET, *POPEN_PACKET;

//
// Define a Load Packet (LDP).  An LDP is used to communicate load and unload
// driver information between the appropriate system services and the routine
// that actually performs the work.  This is implemented using a packet
// because various drivers need to be initialized in the context of THE
// system process because they create threads within its context which open
// handles to objects that henceforth are only valid in the context of that
// process.
//

typedef struct _LOAD_PACKET {
    WORK_QUEUE_ITEM WorkQueueItem;
    KEVENT Event;
    PDRIVER_OBJECT DriverObject;
    PUNICODE_STRING DriverServiceName;
    NTSTATUS FinalStatus;
} LOAD_PACKET, *PLOAD_PACKET;

//
// Define a Link Tracking Packet.  A link tracking packet is used to open the
// user-mode link tracking service's LPC port so that information about objects
// which have been moved can be tracked.
//

typedef struct _LINK_TRACKING_PACKET {
    WORK_QUEUE_ITEM WorkQueueItem;
    KEVENT Event;
    NTSTATUS FinalStatus;
} LINK_TRACKING_PACKET, *PLINK_TRACKING_PACKET;


//
// Define the type for entries placed on the driver shutdown notification queue.
// These entries represent those drivers that would like to be notified that the
// system is begin shutdown before it actually goes down.
//

typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;
    PDEVICE_OBJECT DeviceObject;
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;

//
// Define the type for entries placed on the file system registration change
// notification queue.
//

typedef struct _NOTIFICATION_PACKET {
    LIST_ENTRY ListEntry;
    PDRIVER_OBJECT DriverObject;
    PDRIVER_FS_NOTIFICATION NotificationRoutine;
} NOTIFICATION_PACKET, *PNOTIFICATION_PACKET;

//
// Define I/O completion packet types.
//

typedef enum _COMPLETION_PACKET_TYPE {
    IopCompletionPacketIrp,
    IopCompletionPacketMini,
    IopCompletionPacketQuota
} COMPLETION_PACKET_TYPE, *PCOMPLETION_PACKET_TYPE;

//
// Define the type for completion packets inserted onto completion ports when
// there is no full I/O request packet that was used to perform the I/O
// operation.  This occurs when the fast I/O path is used, and when the user
// directly inserts a completion message.
//
typedef struct _IOP_MINI_COMPLETION_PACKET {

    //
    // The following unnamed structure must be exactly identical
    // to the unnamed structure used in the IRP overlay section used
    // for completion queue entries.
    //

    struct {

        //
        // List entry - used to queue the packet to completion queue, among
        // others.
        //

        LIST_ENTRY ListEntry;

        union {

            //
            // Current stack location - contains a pointer to the current
            // IO_STACK_LOCATION structure in the IRP stack.  This field
            // should never be directly accessed by drivers.  They should
            // use the standard functions.
            //

            struct _IO_STACK_LOCATION *CurrentStackLocation;

            //
            // Minipacket type.
            //

            ULONG PacketType;
        };
    };

    PVOID KeyContext;
    PVOID ApcContext;
    NTSTATUS IoStatus;
    ULONG_PTR IoStatusInformation;
} IOP_MINI_COMPLETION_PACKET, *PIOP_MINI_COMPLETION_PACKET;

typedef struct _IO_UNLOAD_SAFE_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PVOID Context;
    PIO_COMPLETION_ROUTINE CompletionRoutine;
} IO_UNLOAD_SAFE_COMPLETION_CONTEXT, *PIO_UNLOAD_SAFE_COMPLETION_CONTEXT;

typedef struct  _IOP_RESERVE_IRP_ALLOCATOR {
    PIRP    ReserveIrp;
    LONG    IrpAllocated;
    KEVENT  Event;
    CCHAR   ReserveIrpStackSize;
} IOP_RESERVE_IRP_ALLOCATOR, *PIOP_RESERVE_IRP_ALLOCATOR;

//
// This structure is the extension to a fileobject if the flag
// FO_FILE_OBJECT_HAS_EXTENSION is set in the fileobject.
//

typedef struct _IOP_FILE_OBJECT_EXTENSION {
    ULONG           FileObjectExtensionFlags;
    PDEVICE_OBJECT  TopDeviceObjectHint;
    PVOID           FilterContext;          // Pointer where filter keeps its context
} IOP_FILE_OBJECT_EXTENSION, *PIOP_FILE_OBJECT_EXTENSION;

//
// Structure to bookkeep stack profiler.
//

#define MAX_LOOKASIDE_IRP_STACK_COUNT  20   // Highest value for a lookaside stack count

typedef struct  _IOP_IRP_STACK_PROFILER {
    ULONG   Profile[MAX_LOOKASIDE_IRP_STACK_COUNT];
    KTIMER  Timer;
    KDPC    Dpc;
    ULONG   Flags;
    ULONG   TriggerCount;
    ULONG   ProfileDuration;
} IOP_IRP_STACK_PROFILER, *PIOP_IRP_STACK_PROFILER;


#define IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT   0x1 // Define for internal flags to IopCreateFile
#define IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK    0x2
#define IOP_CREATE_DEVICE_OBJECT_EXTENSION      0x4

// Extension Flag definitions.

#define FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK  0x1 // Ignore share access check.

//
// Define the global data for the I/O system.
//

#define IOP_FIXED_SIZE_MDL_PFNS        0x17

#define MAX_RESERVE_IRP_STACK_SIZE     20   // Define 20 as the number of stacks needed for the reserve IRP
#define IOP_PROFILE_TIME_PERIOD        60   // 60 seconds
#define NUM_SAMPLE_IRPS                2000
#define MIN_IRP_THRESHOLD              400  // At least 20 % should be allocated from a given stack location

//
// Define the default number of I/O stack locations a large IRP should
// have if not specified by the registry.
//

#define DEFAULT_LARGE_IRP_LOCATIONS     8
#define BASE_STACK_COUNT                DEFAULT_LARGE_IRP_LOCATIONS

//
// Defines for IopIrpAllocatorFlags.
//

#define IOP_ENABLE_AUTO_SIZING              0x1
#define IOP_PROFILE_STACK_COUNT             0x2
#define IOP_PROFILE_DURATION                1   // 1*60 seconds
#define IOP_PROFILE_TRIGGER_INTERVAL        10  // 10*60 seconds

extern ERESOURCE IopDatabaseResource;
extern ERESOURCE IopDriverLoadResource;
extern ERESOURCE IopSecurityResource;
extern ERESOURCE IopCrashDumpLock;
extern LIST_ENTRY IopDiskFileSystemQueueHead;
extern LIST_ENTRY IopCdRomFileSystemQueueHead;
extern LIST_ENTRY IopNetworkFileSystemQueueHead;
extern LIST_ENTRY IopTapeFileSystemQueueHead;
extern LIST_ENTRY IopBootDriverReinitializeQueueHead;
extern LIST_ENTRY IopNotifyShutdownQueueHead;
extern LIST_ENTRY IopNotifyLastChanceShutdownQueueHead;
extern LIST_ENTRY IopFsNotifyChangeQueueHead;
extern ALIGNED_SPINLOCK IoStatisticsLock;
extern ALIGNED_SPINLOCK IopTimerLock;
extern LIST_ENTRY IopTimerQueueHead;
extern KDPC IopTimerDpc;
extern KTIMER IopTimer;
extern ULONG IopTimerCount;
extern ULONG IopLargeIrpStackLocations;
extern ULONG IopFailZeroAccessCreate;
extern ULONG    IopFsRegistrationOps;

extern POBJECT_TYPE IoAdapterObjectType;
extern POBJECT_TYPE IoCompletionObjectType;
extern POBJECT_TYPE IoControllerObjectType;
extern POBJECT_TYPE IoDeviceHandlerObjectType;

extern GENERAL_LOOKASIDE IopLargeIrpLookasideList;
extern GENERAL_LOOKASIDE IopSmallIrpLookasideList;
extern GENERAL_LOOKASIDE IopMdlLookasideList;
extern GENERAL_LOOKASIDE IopCompletionLookasideList;

extern const UCHAR IopQueryOperationLength[];
extern const UCHAR IopSetOperationLength[];
extern const ULONG IopQueryOperationAccess[];
extern const ULONG IopSetOperationAccess[];
extern const UCHAR IopQuerySetAlignmentRequirement[];
extern const UCHAR IopQueryFsOperationLength[];
extern const UCHAR IopSetFsOperationLength[];
extern const ULONG IopQueryFsOperationAccess[];
extern const ULONG IopSetFsOperationAccess[];
extern const UCHAR IopQuerySetFsAlignmentRequirement[];

extern UNICODE_STRING IoArcHalDeviceName;
extern PUCHAR IoLoaderArcBootDeviceName;


extern LONG IopUniqueDeviceObjectNumber;

extern PVOID IopLinkTrackingServiceObject;
extern PKEVENT IopLinkTrackingServiceEvent;
extern HANDLE IopLinkTrackingServiceEventHandle;
extern KEVENT IopLinkTrackingPortObject;
extern LINK_TRACKING_PACKET IopLinkTrackingPacket;

extern UNICODE_STRING IoArcBootDeviceName;
extern PDUMP_CONTROL_BLOCK IopDumpControlBlock;
extern ULONG IopDumpControlBlockChecksum;

extern LIST_ENTRY IopDriverReinitializeQueueHead;

extern BOOLEAN  IopVerifierOn;

extern PIO_CALL_DRIVER        pIofCallDriver;
extern PIO_COMPLETE_REQUEST   pIofCompleteRequest;
extern PIO_FREE_IRP           pIoFreeIrp;
extern PIO_ALLOCATE_IRP       pIoAllocateIrp;
extern IOP_RESERVE_IRP_ALLOCATOR IopReserveIrpAllocator;
extern IOP_IRP_STACK_PROFILER  IopIrpStackProfiler;
//
// The following declaration cannot go in EX.H since POBJECT_TYPE is not defined
// until OB.H, which depends on EX.H.  Hence, it is not exported by the EX
// component at all.
//

extern POBJECT_TYPE ExEventObjectType;


//
// Define routines private to the I/O system.
//

VOID
IopAbortRequest(
    IN PKAPC Apc
    );

//+
//
// BOOLEAN
// IopAcquireFastLock(
//     IN PFILE_OBJECT FileObject
// )
//
// Routine Description:
//
//     This routine is invoked to acquire the fast lock for a file object.
//     This lock protects the busy indicator in the file object resource.
//
// Arguments:
//
//     FileObject - Pointer to the file object to be locked.
//
// Return Values:
//
//      FALSE - the fileobject was not locked (it was busy)
//      TRUE  - the fileobject was locked & the busy flag has been set to TRUE
//
//-

static  FORCEINLINE BOOLEAN
IopAcquireFastLock(
    IN  PFILE_OBJECT    FileObject
    )
{
    UNREFERENCED_PARAMETER(FileObject);

    if ( InterlockedExchange( (PLONG) &FileObject->Busy, (ULONG) TRUE ) == FALSE ) {
         ObReferenceObject(FileObject);
        return TRUE;
    }

    return FALSE;
}

#define IopAcquireCancelSpinLockAtDpcLevel()    \
    KiAcquireQueuedSpinLock ( &KeGetCurrentPrcb()->LockQueue[LockQueueIoCancelLock] )

#define IopReleaseCancelSpinLockFromDpcLevel()  \
    KiReleaseQueuedSpinLock ( &KeGetCurrentPrcb()->LockQueue[LockQueueIoCancelLock] )

#define IopAllocateIrp(StackSize, ChargeQuota) \
        IoAllocateIrp((StackSize), (ChargeQuota))

#define IsIoVerifierOn()    IopVerifierOn


static __inline  VOID
IopProbeAndLockPages(
     IN OUT PMDL MemoryDescriptorList,
     IN KPROCESSOR_MODE AccessMode,
     IN LOCK_OPERATION Operation,
     IN PDEVICE_OBJECT DeviceObject,
     IN ULONG          MajorFunction
     )
{
    extern LOGICAL  MmTrackLockedPages;

    MmProbeAndLockPages(MemoryDescriptorList, AccessMode, Operation);
    if (MmTrackLockedPages) {
        PVOID   DriverRoutine;

        DriverRoutine = (PVOID)(ULONG_PTR)DeviceObject->DriverObject->MajorFunction[MajorFunction];
        MmUpdateMdlTracker(MemoryDescriptorList, DriverRoutine, DeviceObject);
    }
}

#define IopIsReserveIrp(Irp)    ((Irp) == (IopReserveIrpAllocator.ReserveIrp))

//
// Bump the stack profile.
//

#define IopProfileIrpStackCount(StackSize)  \
            ((StackSize < MAX_LOOKASIDE_IRP_STACK_COUNT) ? \
                IopIrpStackProfiler.Profile[StackSize]++ : 0)

//
// True if auto sizing is enabled.
//
#define IopIrpAutoSizingEnabled()   ((IopIrpStackProfiler.Flags & IOP_ENABLE_AUTO_SIZING))

//
// True if stack profiling is enabled.
//

#define IopIrpProfileStackCountEnabled() \
    ((IopIrpStackProfiler.Flags & (IOP_PROFILE_STACK_COUNT|IOP_ENABLE_AUTO_SIZING)) \
            == (IOP_PROFILE_STACK_COUNT|IOP_ENABLE_AUTO_SIZING))

//
// Definitions for SecurityDescriptorFlavor.
//

#define IO_SD_LEGACY                             0  // Sets per WIN2K settings.
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_E            1  // WORLD:E, Admins:ALL, System:ALL
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_E_RES_E      2  // WORLD:E, Admins:ALL, System:ALL, Restricted:E
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE          3  // WORLD:RWE, Admins:ALL, System:ALL
#define IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE   4  // WORLD:RWE, Admins:ALL, System:ALL, Restricted:RE
#define IO_SD_SYS_ALL_ADM_RE                     5  // System:ALL, Admins:RE


NTSTATUS
IopAcquireFileObjectLock(
    IN PFILE_OBJECT FileObject,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN Alertable,
    OUT PBOOLEAN Interrupted
    );


VOID
IopAllocateIrpCleanup(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT EventObject OPTIONAL
    );

PIRP
IopAllocateIrpMustSucceed(
    IN CCHAR StackSize
    );

VOID
IopApcHardError(
    IN PVOID StartContext
    );

VOID
IopCancelAlertedRequest(
    IN PKEVENT Event,
    IN PIRP Irp
    );

VOID
IopCheckBackupRestorePrivilege(
    IN PACCESS_STATE AccessState,
    IN OUT PULONG CreateOptions,
    IN KPROCESSOR_MODE PreviousMode,
    IN ULONG Disposition
    );

NTSTATUS
IopCheckGetQuotaBufferValidity(
    IN PFILE_GET_QUOTA_INFORMATION QuotaBuffer,
    IN ULONG QuotaLength,
    OUT PULONG_PTR ErrorOffset
    );

VOID
IopCloseFile(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ULONG GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

VOID
IopCompleteUnloadOrDelete(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN OnCleanStack,
    IN KIRQL Irql
    );

VOID
IopCompletePageWrite(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
IopCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

BOOLEAN
IopConfigureCrashDump(
    IN HANDLE HandlePagingFile
    );

VOID
IopConnectLinkTrackingPort(
    IN PVOID Parameter
    );

NTSTATUS
IopCreateVpb (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopDeallocateApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
IopDecrementDeviceObjectRef(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AlwaysUnload,
    IN BOOLEAN OnCleanStack
    );

VOID
IopDeleteDriver(
    IN PVOID    Object
    );

VOID
IopDeleteDevice(
    IN PVOID    Object
    );

VOID
IopDeleteFile(
    IN PVOID    Object
    );

VOID
IopDeleteIoCompletion(
    IN PVOID    Object
    );

//+
//
// VOID
// IopDequeueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine dequeues the specified I/O Request Packet (IRP) from the
//     thread IRP queue which it is currently queued.
//
//     In checked we set Flink == Blink so we can assert free's of queue'd IRPs
//
// Arguments:
//
//     Irp - Specifies the IRP that is dequeued.
//
// Return Value:
//
//     None.
//
//-

#define IopDequeueThreadIrp( Irp ) \
   { \
   RemoveEntryList( &Irp->ThreadListEntry ); \
   InitializeListHead( &Irp->ThreadListEntry ) ; \
   }


#ifdef  _WIN64
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT((ULONG_PTR)(ApcRoutine) & ~1)
#define IopIsIosb32(ApcRoutine)                ((ULONG_PTR)(ApcRoutine) & 1)
#define IopMarkApcRoutineIfAsyncronousIo32(Iosb,ApcRoutine,synchronousIo)   \
{                                                                           \
    if (PsGetCurrentProcess()->Wow64Process != NULL) {                      \
        if (!synchronousIo) {                                               \
            ApcRoutine = (PIO_APC_ROUTINE)((ULONG_PTR)ApcRoutine | 1);      \
            Iosb = UlongToPtr (Iosb->Status);                               \
            ProbeForWriteIoStatusEx(Iosb,(ULONG64)ApcRoutine);              \
        }                                                                   \
    }                                                                       \
}

#else
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT(ApcRoutine)
#define IopMarkApcRoutineIfAsyncronousIo32(Iosb,ApcRoutine,synchronousIo)
#endif

VOID
IopDisassociateThreadIrp(
    VOID
    );

BOOLEAN
IopDmaDispatch(
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    );

VOID
IopDropIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

LONG
IopExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers,
    OUT PNTSTATUS ExceptionCode
    );

VOID
IopExceptionCleanup(
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PKEVENT EventObject OPTIONAL,
    IN PKEVENT KernelEvent OPTIONAL
    );

VOID
IopErrorLogThread(
    IN PVOID StartContext
    );

VOID
IopFreeIrpAndMdls(
    IN PIRP Irp
    );

PDEVICE_OBJECT
IopGetDeviceAttachmentBase(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopGetFileInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

BOOLEAN
IopGetMountFlag(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopGetRegistryValues(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_FULL_INFORMATION *ValueList
    );

NTSTATUS
IopGetSetObjectId(
    IN PFILE_OBJECT FileObject,
    IN OUT PVOID Buffer,
    IN ULONG Length,
    IN ULONG OperationFlags
    );

NTSTATUS
IopGetSetSecurityObject(
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    );

NTSTATUS
IopGetVolumeId(
    IN PFILE_OBJECT FileObject,
    IN OUT PLINK_TRACKING_INFORMATION ObjectId,
    IN ULONG Length
    );

VOID
IopHardErrorThread(
    PVOID StartContext
    );

VOID
IopInsertRemoveDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Insert
    );

//
// Interlocked list manipulation functions using queued spin locks.
//

PLIST_ENTRY
FASTCALL
IopInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

PLIST_ENTRY
FASTCALL
IopInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

PLIST_ENTRY
FASTCALL
IopInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead
    );

LOGICAL
IopIsSameMachine(
    IN PFILE_OBJECT SourceFile,
    IN HANDLE TargetFile
    );

VOID
IopLoadFileSystemDriver(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopLoadUnloadDriver(
    IN PVOID Parameter
    );

#if defined(_WIN64)
BOOLEAN
IopIsNotNativeDriverImage(
    IN PUNICODE_STRING ImageFileName
    );

BOOLEAN
IopCheckIfNotNativeDriver(
    IN NTSTATUS InitialDriverLoadStatus,
    IN PUNICODE_STRING ImageFileName
    );

VOID
IopLogBlockedDriverEvent (
    IN PUNICODE_STRING ImageFileName,
    IN NTSTATUS NtMessageStatus,
    IN NTSTATUS NtErrorStatus);
#endif

NTSTATUS
IopLogErrorEvent(
    IN ULONG            SequenceNumber,
    IN ULONG            UniqueErrorValue,
    IN NTSTATUS         FinalStatus,
    IN NTSTATUS         SpecificIOStatus,
    IN ULONG            LengthOfInsert1,
    IN PWCHAR           Insert1,
    IN ULONG            LengthOfInsert2,
    IN PWCHAR           Insert2
    );

NTSTATUS
IopLookupBusStringFromID (
    IN  HANDLE KeyHandle,
    IN  INTERFACE_TYPE InterfaceType,
    OUT PWCHAR Buffer,
    IN  ULONG Length,
    OUT PULONG BusFlags OPTIONAL
    );

NTSTATUS
IopMountVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount,
    IN BOOLEAN DeviceLockAlreadyHeld,
    IN BOOLEAN Alertable,
    OUT PVPB    *Vpb
    );


NTSTATUS
IopOpenLinkOrRenameTarget(
    OUT PHANDLE TargetHandle,
    IN PIRP Irp,
    IN PVOID RenameBuffer,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

NTSTATUS
IopParseDevice(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    );

BOOLEAN
IopProtectSystemPartition(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );


NTSTATUS
IopQueryName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    );

NTSTATUS
IopQueryNameInternal(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    IN BOOLEAN UseDosDeviceName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE  Mode
    );

NTSTATUS
IopQueryXxxInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    IN KPROCESSOR_MODE Mode,
    OUT PVOID Information,
    OUT PULONG ReturnedLength,
    IN BOOLEAN FileInformation
    );

VOID
IopQueueWorkRequest(
    IN PIRP Irp
    );

VOID
IopRaiseHardError(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IopRaiseInformationalHardError(
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IopReadyDeviceObjects(
    IN PDRIVER_OBJECT DriverObject
    );

//+
//
// VOID
// IopReleaseFileObjectLock(
//     IN PFILE_OBJECT FileObject
// )
//
// Routine Description:
//
//     This routine is invoked to release ownership of the file object lock.
//     Dereference the fileobject acquired during the lock.
//
// Arguments:
//
//     FileObject - Pointer to the file object whose ownership is to be
//         released.
//
// Return Value:
//
//     None.
//
//-

#define IopReleaseFileObjectLock( FileObject ) {    \
    ULONG Result;                                   \
    Result = InterlockedExchange( (PLONG) &FileObject->Busy, FALSE ); \
    ASSERT(Result != FALSE);                        \
    if (FileObject->Waiters != 0) {                 \
        KeSetEvent( &FileObject->Lock, 0, FALSE );  \
    }                                               \
    ObDereferenceObject(FileObject);                \
}

#if _WIN32_WINNT >= 0x0500
NTSTATUS
IopSendMessageToTrackService(
    IN PLINK_TRACKING_INFORMATION SourceVolumeId,
    IN PFILE_OBJECTID_BUFFER SourceObjectId,
    IN PFILE_TRACKING_INFORMATION TargetObjectInformation
    );
#endif

NTSTATUS
IopSetEaOrQuotaInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN SetEa
    );

NTSTATUS
IopSetRemoteLink(
    IN PFILE_OBJECT FileObject,
    IN PFILE_OBJECT DestinationFileObject OPTIONAL,
    IN PFILE_TRACKING_INFORMATION FileInformation OPTIONAL
    );

VOID
IopStartApcHardError(
    IN PVOID StartContext
    );

NTSTATUS
IopSynchronousApiServiceTail(
    IN NTSTATUS ReturnedStatus,
    IN PKEVENT Event,
    IN PIRP Irp,
    IN KPROCESSOR_MODE RequestorMode,
    IN PIO_STATUS_BLOCK LocalIoStatus,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
IopSynchronousServiceTail(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DeferredIoCompletion,
    IN KPROCESSOR_MODE RequestorMode,
    IN BOOLEAN SynchronousIo,
    IN TRANSFER_TYPE TransferType
    );

VOID
IopTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
IopTrackLink(
    IN PFILE_OBJECT FileObject,
    IN OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_TRACKING_INFORMATION FileInformation,
    IN ULONG Length,
    IN PKEVENT Event,
    IN KPROCESSOR_MODE RequestorMode
    );


VOID
IopUserCompletion(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

NTSTATUS
IopXxxControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl
    );

NTSTATUS
IopReportResourceUsage(
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PCM_RESOURCE_LIST DriverList OPTIONAL,
    IN ULONG DriverListSize OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN PCM_RESOURCE_LIST DeviceList OPTIONAL,
    IN ULONG DeviceListSize OPTIONAL,
    IN BOOLEAN OverrideConflict,
    OUT PBOOLEAN ConflictDetected
    );


VOID
IopDoNameTransmogrify(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    );

extern LOGICAL IoCountOperations;

FORCEINLINE
VOID
IopUpdateOtherOperationCount(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to update the operation count for the current
    process to indicate that an I/O service other than a read or write
    has been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {

#if defined(_WIN64)

        KeGetCurrentThread()->OtherOperationCount += 1;

#else

        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->OtherOperationCount, 1);

#endif

        InterlockedIncrement( &KeGetCurrentPrcb()->IoOtherOperationCount );
    }
}

FORCEINLINE
VOID
IopUpdateReadOperationCount(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to update the read operation count for the
    current process to indicate that the NtReadFile system service has
    been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {

#if defined(_WIN64)

        KeGetCurrentThread()->ReadOperationCount += 1;

#else

        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->ReadOperationCount, 1);

#endif

        InterlockedIncrement( &KeGetCurrentPrcb()->IoReadOperationCount );
    }
}

FORCEINLINE
VOID
IopUpdateWriteOperationCount(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to update the write operation count for the
    current process to indicate that the NtWriteFile service other has
    been invoked.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {

#if defined(_WIN64)

        KeGetCurrentThread()->WriteOperationCount += 1;

#else

        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->WriteOperationCount, 1);

#endif

        InterlockedIncrement( &KeGetCurrentPrcb()->IoWriteOperationCount );
    }
}

FORCEINLINE
VOID
IopUpdateOtherTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the transfer count for the current
    process for an operation other than a read or write system service.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {

#if defined(_WIN64)

        KeGetCurrentThread()->OtherTransferCount += TransferCount;

#else

        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->OtherTransferCount, TransferCount);

#endif

        ExInterlockedAddLargeStatistic( &KeGetCurrentPrcb()->IoOtherTransferCount, TransferCount );
    }
}

FORCEINLINE
VOID
IopUpdateReadTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the read transfer count for the
    current process.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {

#if defined(_WIN64)

        KeGetCurrentThread()->ReadTransferCount += TransferCount;

#else

        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->ReadTransferCount, TransferCount);

#endif

        ExInterlockedAddLargeStatistic( &KeGetCurrentPrcb()->IoReadTransferCount, TransferCount );
    }
}

FORCEINLINE
VOID
IopUpdateWriteTransferCount(
    IN ULONG TransferCount
    )
/*++

Routine Description:

    This routine is invoked to update the write transfer count for the
    current process.

    There is an implicit assumption that this call is always made in the context
    of the issuing thread. Also note that overflow is folded into the thread's
    process.

Arguments:

    TransferCount - The count of the number of bytes transferred.

Return Value:

    None.

--*/
{
    if (IoCountOperations == TRUE) {

#if defined(_WIN64)

        KeGetCurrentThread()->WriteTransferCount += TransferCount;

#else

        ExInterlockedAddLargeStatistic( &THREAD_TO_PROCESS(PsGetCurrentThread())->WriteTransferCount, TransferCount);

#endif

        ExInterlockedAddLargeStatistic( &KeGetCurrentPrcb()->IoWriteTransferCount, TransferCount );
    }
}

NTSTATUS
FORCEINLINE
IopfCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to pass an I/O Request Packet (IRP) to another
    driver at its dispatch routine.

Arguments:

    DeviceObject - Pointer to device object to which the IRP should be passed.

    Irp - Pointer to IRP for request.

Return Value:

    Return status from driver's dispatch routine.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDRIVER_OBJECT driverObject;
    NTSTATUS status;

    //
    // Ensure that this is really an I/O Request Packet.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Update the IRP stack to point to the next location.
    //
    Irp->CurrentLocation--;

    if (Irp->CurrentLocation <= 0) {
        KiBugCheck3( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, 0, 0 );
    }

    irpSp = IoGetNextIrpStackLocation( Irp );
    Irp->Tail.Overlay.CurrentStackLocation = irpSp;

    //
    // Save a pointer to the device object for this request so that it can
    // be used later in completion.
    //

    irpSp->DeviceObject = DeviceObject;


    //
    // Invoke the driver at its dispatch routine entry point.
    //

    driverObject = DeviceObject->DriverObject;

    //
    // Prevent the driver from unloading.
    //


    status = driverObject->MajorFunction[irpSp->MajorFunction]( DeviceObject,
                                                              Irp );

    return status;
}


VOID
FASTCALL
IopfCompleteRequest(
    IN  PIRP    Irp,
    IN  CCHAR   PriorityBost
    );


PIRP
IopAllocateIrpPrivate(
    IN  CCHAR   StackSize,
    IN  BOOLEAN ChargeQuota
    );

VOID
IopFreeIrp(
    IN  PIRP    Irp
    );

PVOID
IopAllocateErrorLogEntry(
    IN PDEVICE_OBJECT deviceObject,
    IN PDRIVER_OBJECT driverObject,
    IN UCHAR EntrySize
    );

VOID
IopNotifyAlreadyRegisteredFileSystems(
    IN PLIST_ENTRY  ListHead,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine,
    IN BOOLEAN                 SkipRaw
    );

NTSTATUS
IopCheckUnloadDriver(
    IN PDRIVER_OBJECT driverObject,
    OUT PBOOLEAN unloadDriver
    );
//
// Interlocked increment/decrement functions using queued spin locks.
//

ULONG
FASTCALL
IopInterlockedDecrementUlong (
   IN KSPIN_LOCK_QUEUE_NUMBER Number,
   IN OUT PLONG Addend
   );

ULONG
FASTCALL
IopInterlockedIncrementUlong (
   IN KSPIN_LOCK_QUEUE_NUMBER Number,
   IN OUT PLONG Addend
   );


VOID
IopShutdownBaseFileSystems(
    IN PLIST_ENTRY  ListHead
    );

VOID
IopPerfLogFileCreate(
    IN PFILE_OBJECT FileObject,
    IN PUNICODE_STRING CompleteName
    );

BOOLEAN
IopInitializeReserveIrp(
    PIOP_RESERVE_IRP_ALLOCATOR  Allocator
    );

PIRP
IopAllocateReserveIrp(
    IN CCHAR StackSize
    );

VOID
IopFreeReserveIrp(
    IN  CCHAR   PriorityBoost
    );

NTSTATUS
IopGetBasicInformationFile(
    IN  PFILE_OBJECT            FileObject,
    IN  PFILE_BASIC_INFORMATION BasicInformationBuffer
    );

NTSTATUS
IopCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN ULONG InternalFlags,
    IN PVOID DeviceObject
    );

BOOLEAN
IopVerifyDeviceObjectOnStack(
    IN  PDEVICE_OBJECT  BaseDeviceObject,
    IN  PDEVICE_OBJECT  TopDeviceObject
    );

BOOLEAN
IopVerifyDiskSignature(
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout,
    IN PARC_DISK_SIGNATURE          LoaderDiskBlock,
    OUT PULONG                      DiskSignature
    );

NTSTATUS
IopGetDriverPathInformation(
    IN  PFILE_OBJECT                        FileObject,
    IN  PFILE_FS_DRIVER_PATH_INFORMATION    FsDpInfo,
    IN  ULONG                               Length
    );

BOOLEAN
IopVerifyDriverObjectOnStack(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IopInitializeIrpStackProfiler(
    VOID
    );

VOID
IopIrpStackProfilerTimer(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IopProcessIrpStackProfiler(
    VOID
    );

PDEVICE_OBJECT
IopAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject OPTIONAL
    );


NTSTATUS
IopCreateSecurityDescriptorPerType(
    IN  PSECURITY_DESCRIPTOR  Descriptor,
    IN  ULONG                 SecurityDescriptorFlavor,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    );

BOOLEAN
IopReferenceVerifyVpb(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PVPB            *Vpb,
    OUT PDEVICE_OBJECT  *FsDeviceObject
    );

VOID
IopDereferenceVpbAndFree(
    IN PVPB Vpb
    );
#endif // _IOMGR_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\iosubs.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    iosubs.c

Abstract:

    This module contains the subroutines for the I/O system.

--*/

#include "iomgr.h"

//
// This is the overall system device configuration record.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg("PAGEDATA")
#endif
static CONFIGURATION_INFORMATION ConfigurationInformation = {
    0,                                 // DiskCount
    0,                                 // FloppyCount
    0,                                 // CdRomCount
    0,                                 // TapeCount
    0,                                 // ScsiPortCount
    0,                                 // SerialCount
    0,                                 // ParallelCount
    FALSE,                             // Primary ATDISK IO address claimed
    FALSE,                             // Secondary ATDISK IO address claimed
    sizeof(CONFIGURATION_INFORMATION), // Version
    0                                  // MediumChangerCount
};
#ifdef ALLOC_DATA_PRAGMA
#pragma  data_seg()
#endif

//
// This value may be overridden by the registry.
//

LOGICAL IoCountOperations = TRUE;
LONG    IoPageReadIrpAllocationFailure;
LONG    IoPageReadNonPagefileIrpAllocationFailure;


#ifdef ALLOC_PRAGMA
NTSTATUS
IopDeleteSessionSymLinks(
    IN PUNICODE_STRING LinkName
    );
#pragma alloc_text(PAGE, IoAttachDevice)
#pragma alloc_text(PAGE, IoCancelThreadIo)
#pragma alloc_text(PAGE, IoCheckDesiredAccess)
#pragma alloc_text(PAGE, IoCheckEaBufferValidity)
#pragma alloc_text(PAGE, IoCheckFunctionAccess)
#pragma alloc_text(PAGE, IoCheckQuotaBufferValidity)
#pragma alloc_text(PAGE, IoCheckShareAccess)
#pragma alloc_text(PAGE, IoConnectInterrupt)
#pragma alloc_text(PAGE, IoCreateController)
#pragma alloc_text(PAGE, IoCreateDevice)
#pragma alloc_text(PAGE, IoCreateDriver)
#pragma alloc_text(PAGE, IoCreateFile)
#pragma alloc_text(PAGE, IopCreateFile)
#pragma alloc_text(PAGE, IoCreateNotificationEvent)
#pragma alloc_text(PAGE, IoCreateStreamFileObject)
#pragma alloc_text(PAGE, IoCreateStreamFileObjectEx)
#pragma alloc_text(PAGE, IoCreateStreamFileObjectLite)
#pragma alloc_text(PAGE, IoCreateSymbolicLink)
#pragma alloc_text(PAGE, IoCreateSynchronizationEvent)
#pragma alloc_text(PAGE, IoCreateUnprotectedSymbolicLink)
#pragma alloc_text(PAGE, IoDeleteController)
#pragma alloc_text(PAGE, IoDeleteDriver)
#pragma alloc_text(PAGE, IoDeleteSymbolicLink)
#pragma alloc_text(PAGE, IopDeleteSessionSymLinks)
#pragma alloc_text(PAGE, IoDisconnectInterrupt)
#pragma alloc_text(PAGE, IoEnqueueIrp)
#pragma alloc_text(PAGE, IoGetFileObjectGenericMapping)
#pragma alloc_text(PAGE, IoGetInitialStack)
#pragma alloc_text(PAGE, IoFastQueryNetworkAttributes)
#pragma alloc_text(PAGE, IoGetConfigurationInformation)
#pragma alloc_text(PAGE, IoGetDeviceObjectPointer)
#pragma alloc_text(PAGE, IoComputeDesiredAccessFileObject)
#pragma alloc_text(PAGE, IoInitializeTimer)
#pragma alloc_text(PAGE, IoIsValidNameGraftingBuffer)
#pragma alloc_text(PAGE, IopDoNameTransmogrify)
#pragma alloc_text(PAGE, IoQueryFileDosDeviceName)
#pragma alloc_text(PAGE, IoQueryFileInformation)
#pragma alloc_text(PAGE, IoQueryVolumeInformation)
#pragma alloc_text(PAGE, IoRegisterBootDriverReinitialization)
#pragma alloc_text(PAGE, IoRegisterDriverReinitialization)
#pragma alloc_text(PAGE, IoRegisterFileSystem)
#pragma alloc_text(PAGE, IoRegisterFsRegistrationChange)
#pragma alloc_text(PAGE, IoRegisterLastChanceShutdownNotification)
#pragma alloc_text(PAGE, IoRegisterShutdownNotification)
#pragma alloc_text(PAGE, IoRemoveShareAccess)
#pragma alloc_text(PAGE, IoSetInformation)
#pragma alloc_text(PAGE, IoSetShareAccess)
#pragma alloc_text(PAGE, IoSetSystemPartition)
#pragma alloc_text(PAGE, IoUnregisterFileSystem)
#pragma alloc_text(PAGE, IoUnregisterFsRegistrationChange)
#pragma alloc_text(PAGE, IoUpdateShareAccess)
#pragma alloc_text(PAGE, IoVerifyVolume)
#pragma alloc_text(PAGE, IoGetBootDiskInformation)
#pragma alloc_text(PAGE, IopCreateDefaultDeviceSecurityDescriptor)
#pragma alloc_text(PAGE, IopCreateVpb)
#pragma alloc_text(PAGE, IoCancelFileOpen)
#pragma alloc_text(PAGE, IopNotifyAlreadyRegisteredFileSystems)
#pragma alloc_text(PAGE, IoCreateFileSpecifyDeviceObjectHint)
#pragma alloc_text(PAGELK, IoShutdownSystem)
#pragma alloc_text(PAGELK, IoUnregisterShutdownNotification)
#pragma alloc_text(PAGE, IoCheckQuerySetFileInformation)
#pragma alloc_text(PAGE, IoCheckQuerySetVolumeInformation)
#pragma alloc_text(PAGE, IoEnumerateRegisteredFiltersList)
#endif

//
// Define macros to allocate and free an open packet so platforms that can
// afford the extra stack space are not penalized by those that cannot.
//

#if defined(_AMD64_)

#define IopAllocateOpenPacket() _alloca(sizeof(OPEN_PACKET))

#define IopFreeOpenPacket(p)

#else

#define IopAllocateOpenPacket()                                              \
    ExAllocatePoolWithTag( NonPagedPool,                                     \
                           sizeof(OPEN_PACKET),                              \
                           'pOoI')

#define IopFreeOpenPacket(p) ExFreePool(p)

#endif


VOID
IoAcquireCancelSpinLock(
    OUT PKIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to acquire the cancel spin lock.  This spin lock
    must be acquired before setting the address of a cancel routine in an
    IRP.

Arguments:

    Irql - Address of a variable to receive the old IRQL.

Return Value:

    None.

--*/

{

    //
    // Simply acquire the cancel spin lock and return.
    //

    *Irql = KeAcquireQueuedSpinLock( LockQueueIoCancelLock );
}

VOID
IoAcquireVpbSpinLock(
    OUT PKIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to acquire the Volume Parameter Block (VPB) spin
    lock.  This spin lock must be acquired before accessing the mount flag,
    reference count, and device object fields of a VPB.

Arguments:

    Irql - Address of a variable to receive the old IRQL.

Return Value:

    None.

--*/

{

    //
    // Simply acquire the IopLoadFileSystemDriverVPB spin lock and return.
    //

    *Irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    return;
}


NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by calling HalAllocateAdapterChannel which does all of
    the work.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
#if !defined(NO_LEGACY_DRIVERS)
    PWAIT_CONTEXT_BLOCK wcb;

    wcb = &DeviceObject->Queue.Wcb;

    wcb->DeviceObject = DeviceObject;
    wcb->CurrentIrp = DeviceObject->CurrentIrp;
    wcb->DeviceContext = Context;

    return( HalAllocateAdapterChannel( AdapterObject,
                                       wcb,
                                       NumberOfMapRegisters,
                                       ExecutionRoutine ) );
#else
    return( (*((PDMA_ADAPTER)AdapterObject)->DmaOperations->
             AllocateAdapterChannel)( (PDMA_ADAPTER)AdapterObject,
                                      DeviceObject,
                                      NumberOfMapRegisters,
                                      ExecutionRoutine,
                                      Context) );

#endif // NO_LEGACY_DRIVERS
}


VOID
IoAllocateController(
    IN PCONTROLLER_OBJECT ControllerObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the controller specified by the controller object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the controller on the controller's queue.  If the queue is
    already "busy", then the controller has already been allocated, so the
    device object is simply placed onto the queue and waits until the controller
    becomes free.

    Once the controller becomes free (or if it already is), then the driver's
    execution routine is invoked.

Arguments:

    ControllerObject - Pointer to the controller object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the controller.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the controller has been allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    None.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    IO_ALLOCATION_ACTION action;

    //
    // Initialize the device object's wait context block in case this device
    // must wait before being able to allocate the controller.
    //

    DeviceObject->Queue.Wcb.DeviceRoutine = ExecutionRoutine;
    DeviceObject->Queue.Wcb.DeviceContext = Context;

    //
    // Allocate the controller object for this particular device.  If the
    // controller cannot be allocated because it has already been allocated
    // to another device, then return to the caller now;  otherwise,
    // continue.
    //

    if (!KeInsertDeviceQueue( &ControllerObject->DeviceWaitQueue,
                              &DeviceObject->Queue.Wcb.WaitQueueEntry )) {

        //
        // The controller was not busy so it has been allocated.  Simply
        // invoke the driver's execution routine now.
        //

        action = ExecutionRoutine( DeviceObject,
                                   DeviceObject->CurrentIrp,
                                   0,
                                   Context );

        //
        // If the driver would like to have the controller deallocated,
        // then deallocate it now.
        //

        if (action == DeallocateObject) {
            IoFreeController( ControllerObject );
        }
    }
}

NTSTATUS
IoAllocateDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress,
    IN ULONG DriverObjectExtensionSize,
    OUT PVOID *DriverObjectExtension
    )

/*++

Routine Description:
    This routine allocates per driver storage for helper or class drivers
    which may support several different mini-drivers.  The storage is tagged
    with a client identification address which is used to retrieve a pointer
    to the storage.  The client id must be unique.

    The allocated storage is freed when the driver object is deleted.

Arguments:

    DriverObject - The driver object to which the extension is to be
        associated.

    ClientIdentificationAddress - Unique identifier used to retrieve the
        extension.

    DriverObjectExtensionSize - Specifies the size in bytes of the extension.

    DriverObjectExtension - Returns a pointer to the allocated extension.

Return Value:

    Returns the status of the operation.  Failure cases are
    STATUS_INSUFFICIENT_RESOURCES and STATUS_OBJECT_NAME_COLLISION.

--*/

{
    KIRQL irql;
    BOOLEAN inserted = FALSE;
    PIO_CLIENT_EXTENSION extension;
    PIO_CLIENT_EXTENSION newExtension;

    *DriverObjectExtension = NULL;

    newExtension = ExAllocatePoolWithTag( NonPagedPool,
                                          DriverObjectExtensionSize +
                                          sizeof( IO_CLIENT_EXTENSION ),
                                          'virD');

    if (newExtension == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory( newExtension,
                    DriverObjectExtensionSize +
                    sizeof( IO_CLIENT_EXTENSION )
                    );

    newExtension->ClientIdentificationAddress = ClientIdentificationAddress;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    extension = DriverObject->DriverExtension->ClientDriverExtension;
    while (extension != NULL) {

        if (extension->ClientIdentificationAddress == ClientIdentificationAddress) {
            break;
        }

        extension = extension->NextExtension;
    }

    if (extension == NULL) {

        //
        // The client id does not exist.  Insert the new extension in the
        // list.
        //

        newExtension->NextExtension =
            DriverObject->DriverExtension->ClientDriverExtension;
        DriverObject->DriverExtension->ClientDriverExtension = newExtension;
        inserted = TRUE;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    if (!inserted) {
        ExFreePool( newExtension );
        return(STATUS_OBJECT_NAME_COLLISION);
    }

    //
    // Return a pointer to the client's data area.
    //

    *DriverObjectExtension = newExtension + 1;
    return(STATUS_SUCCESS);
}

PVOID
IoAllocateErrorLogEntry(
    IN PVOID IoObject,
    IN UCHAR EntrySize
    )

/*++

Routine Description:

    This routine allocates and initializes an error log entry buffer and returns
    a pointer to the data entry portion of the buffer.

Arguments:

    IoObject - Pointer to driver's device object or driver object.

    EntrySize - Size of entry to be allocated, in bytes.  The maximum size is
        specified by ERROR_LOG_MAXIMUM_SIZE.

Return Value:

    Pointer to the body of the allocated error log entry, or NULL, if there are
    no free entries in the system.

Note:

    This routine assumes that the caller wants an error log entry within the
    bounds of the maximum size.

--*/

{
    PDEVICE_OBJECT deviceObject;
    PDRIVER_OBJECT driverObject;

    //
    // Make sure that a I/O object pointer was passed in.
    //

    if (IoObject == NULL) {
        return(NULL);
    }

    //
    // Assume for a moment this is a device object.
    //

    deviceObject = IoObject;

    //
    // Determine if this is a driver object or device object or if we
    // are allocating a generic error log entry.   This is determined
    // from the Type field of the object passed in.
    //

    if (deviceObject->Type == IO_TYPE_DEVICE) {

        driverObject = deviceObject->DriverObject;

    } else if (deviceObject->Type == IO_TYPE_DRIVER) {

        driverObject = (PDRIVER_OBJECT) IoObject;
        deviceObject = NULL;

    } else {

        return(NULL);

    }

    return (IopAllocateErrorLogEntry(
                deviceObject,
                driverObject,
                EntrySize));

}

PVOID
IoAllocateGenericErrorLogEntry(
    IN  UCHAR   EntrySize
    )

/*++

Routine Description:

    This routine allocates and initializes an error log entry buffer and returns
    a pointer to the data entry portion of the buffer. It's expected to be
    called from inside the kernel where there may not be a driver object
    or a device object.

Arguments:


    EntrySize - Size of entry to be allocated, in bytes.  The maximum size is
        specified by ERROR_LOG_MAXIMUM_SIZE.

Return Value:

    Pointer to the body of the allocated error log entry, or NULL, if there are
    no free entries in the system.

Note:

    This routine assumes that the caller wants an error log entry within the
    bounds of the maximum size.

--*/

{
    return(IopAllocateErrorLogEntry(NULL, NULL, EntrySize));
}

PVOID
IopAllocateErrorLogEntry(
    IN PDEVICE_OBJECT deviceObject,
    IN PDRIVER_OBJECT driverObject,
    IN UCHAR EntrySize
    )
{
    PERROR_LOG_ENTRY elEntry;
    PVOID returnValue;
    ULONG size;
    ULONG oldSize;

    //
    // Make sure the packet is large enough but not too large.
    //

    if (EntrySize < sizeof(IO_ERROR_LOG_PACKET) ||
        EntrySize > ERROR_LOG_MAXIMUM_SIZE) {

        return(NULL);
    }

    //
    // Round entry size to a PVOID size boundary.
    //

    EntrySize = (UCHAR) ((EntrySize + sizeof(PVOID) - 1) & ~(sizeof(PVOID) - 1));

    //
    // Calculate the size of the entry needed.
    //

    size = sizeof(ERROR_LOG_ENTRY) + EntrySize;

    //
    // Make sure that there are not too many outstanding packets.
    //


    oldSize = InterlockedExchangeAdd(&IopErrorLogAllocation, size);

    if (oldSize > IOP_MAXIMUM_LOG_ALLOCATION) {

        //
        // Fail the request.
        //

        InterlockedExchangeAdd(&IopErrorLogAllocation, -(LONG)size);

        return(NULL);
    }

    //
    // Allocate the packet.
    //

    elEntry = ExAllocatePoolWithTag( NonPagedPool, size, 'rEoI' );

    if (elEntry == NULL) {

        //
        // Drop the allocation and return.
        //

        InterlockedExchangeAdd(&IopErrorLogAllocation, -(LONG)size);

        return(NULL);
    }

    //
    // Reference the device object and driver object. So they don't
    // go away before the name gets pulled out.
    //

    if (deviceObject != NULL) {

        ObReferenceObject( deviceObject );
    }

    if (driverObject != NULL) {

        ObReferenceObject( driverObject );
    }

    //
    // Initialize the fields.
    //

    RtlZeroMemory(elEntry, size);

    elEntry->Type = IO_TYPE_ERROR_LOG;
    elEntry->Size = (USHORT) size;
    elEntry->DeviceObject = deviceObject;
    elEntry->DriverObject = driverObject;

    returnValue = elEntry+1;


    return returnValue;
}

VOID
IoFreeErrorLogEntry(
    IN PVOID ElEntry
    )
/*++

Routine Description:

    This routine frees an entry allocated using IoAllocateErrorLogEntry. Its used to
    free an entry if its not used to actually write an errorlog entry.

Arguments:

    ElEntry - Pointer to the entry that was allocated by IoAllocateErrorLogEntry.

Return Value:

--*/
{
    PERROR_LOG_ENTRY entry;

    //
    // Get the address of the error log entry header,
    //

    entry = ((PERROR_LOG_ENTRY) ElEntry) - 1;

    //
    // Drop the reference counts.
    //

    if (entry->DeviceObject != NULL) {
        ObDereferenceObject (entry->DeviceObject);
    }

    if (entry->DriverObject != NULL) {
        ObDereferenceObject (entry->DriverObject);
    }

    InterlockedExchangeAdd( &IopErrorLogAllocation,
                           -((LONG) (entry->Size )));

    ExFreePool (entry);

    return;
}

PIRP
IoAllocateIrp(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    )
{
    return (pIoAllocateIrp(StackSize, ChargeQuota));
}


PIRP
IopAllocateIrpPrivate(
    IN CCHAR StackSize,
    IN BOOLEAN ChargeQuota
    )

/*++

Routine Description:

    This routine allocates an I/O Request Packet from the system nonpaged pool.
    The packet will be allocated to contain StackSize stack locations.  The IRP
    will also be initialized.

Arguments:

    StackSize - Specifies the maximum number of stack locations required.

    ChargeQuota - Specifies whether quota should be charged against thread.

Return Value:

    The function value is the address of the allocated/initialized IRP,
    or NULL if one could not be allocated.

--*/

{
    USHORT allocateSize;
    UCHAR fixedSize;
    PIRP irp;
    UCHAR lookasideAllocation;
    PGENERAL_LOOKASIDE lookasideList;
    PP_NPAGED_LOOKASIDE_NUMBER number;
    USHORT packetSize;
    PKPRCB prcb;
    CCHAR   largeIrpStackLocations;

    //
    // If the size of the packet required is less than or equal to those on
    // the lookaside lists, then attempt to allocate the packet from the
    // lookaside lists.
    //

    if (IopIrpProfileStackCountEnabled()) {
        IopProfileIrpStackCount(StackSize);
    }


    irp = NULL;

    fixedSize = 0;
    packetSize = IoSizeOfIrp(StackSize);
    allocateSize = packetSize;
    prcb = KeGetCurrentPrcb();

    //
    // Capture this value once as it can change and use it.
    //

    largeIrpStackLocations = (CCHAR)IopLargeIrpStackLocations;

    if ((StackSize <= (CCHAR)largeIrpStackLocations) &&
        ((ChargeQuota == FALSE) || (prcb->LookasideIrpFloat > 0))) {
        fixedSize = IRP_ALLOCATED_FIXED_SIZE;
        number = LookasideSmallIrpList;
        if (StackSize != 1) {
            allocateSize = IoSizeOfIrp((CCHAR)largeIrpStackLocations);
            number = LookasideLargeIrpList;
        }

        lookasideList = prcb->PPLookasideList[number].P;
        lookasideList->TotalAllocates += 1;
        irp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);

        if (irp == NULL) {
            lookasideList->AllocateMisses += 1;
            lookasideList = prcb->PPLookasideList[number].L;
            lookasideList->TotalAllocates += 1;
            irp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);
            if (irp == NULL) {
                lookasideList->AllocateMisses += 1;
            }
        }

        if (IopIrpAutoSizingEnabled() && irp) {

            //
            // See if this IRP is a stale entry. If so just free it.
            // This can happen if we decided to change the lookaside list size.
            // We need to get the size of the IRP from the information field as the size field
            // is overlayed with single list entry.
            //

            if (irp->IoStatus.Information < packetSize) {
                lookasideList->TotalFrees += 1;
                ExFreePool(irp);
                irp = NULL;

            } else {

                //
                // Update allocateSize to the correct value.
                //
                allocateSize = (USHORT)irp->IoStatus.Information;
            }
        }
    }


    //
    // If an IRP was not allocated from the lookaside list, then allocate
    // the packet from nonpaged pool and charge quota if requested.
    //

    lookasideAllocation = 0;
    if (!irp) {

        //
        // There are no free packets on the lookaside list, or the packet is
        // too large to be allocated from one of the lists, so it must be
        // allocated from nonpaged pool. If quota is to be charged, charge it
        // against the current process. Otherwise, allocate the pool normally.
        //

        if (ChargeQuota) {
            irp = ExAllocatePoolWithQuotaTag(NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE,
                                             allocateSize,' prI');

        } else {

            //
            // Attempt to allocate the pool from non-paged pool.  If this
            // fails, and the caller's previous mode was kernel then allocate
            // the pool as must succeed.
            //

            irp = ExAllocatePoolWithTag(NonPagedPool, allocateSize, ' prI');
        }

        if (!irp) {
            return NULL;
        }

    } else {
        if (ChargeQuota != FALSE) {
            lookasideAllocation = IRP_LOOKASIDE_ALLOCATION;
            InterlockedDecrement( &prcb->LookasideIrpFloat );
        }

        ChargeQuota = FALSE;
    }

    //
    // Initialize the packet.
    // Note that irp->Size may not be equal to IoSizeOfIrp(StackSize)
    //

    IopInitializeIrp(irp, allocateSize, StackSize);
    irp->AllocationFlags = (fixedSize | lookasideAllocation);
    if (ChargeQuota) {
        irp->AllocationFlags |= IRP_QUOTA_CHARGED;
    }

    return irp;
}

PMDL
IoAllocateMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN BOOLEAN SecondaryBuffer,
    IN BOOLEAN ChargeQuota,
    IN OUT PIRP Irp OPTIONAL
    )

/*++

Routine Description:

    This routine allocates a Memory Descriptor List (MDL) large enough to map
    the buffer specified by the VirtualAddress and Length parameters.  If the
    routine is given a pointer to an Irp, then it will chain the MDL to the
    IRP in the appropriate way.

    If this routine is not given a pointer to an Irp it is up to the caller to
    set the MDL address in the IRP that the MDL is being allocated for.

    Note that the header information of the MDL will also be initialized.

Arguments:

    VirtualAddress - Starting virtual address of the buffer to be mapped.

    Length - Length, in bytes, of the buffer to be mapped.

    SecondaryBuffer - Indicates whether this is a chained buffer.

    ChargeQuota - Indicates whether quota should be charged if MDL allocated.

        N.B. This parameter is ignored.

    Irp - Optional pointer to IRP that MDL is being allocated for.

Return Value:

    A pointer to the allocated MDL, or NULL if one could not be allocated.
    Note that if no MDL could be allocated because there was not enough quota,
    then it is up to the caller to catch the raised exception.

--*/

{
    ULONG allocateSize;
    USHORT fixedSize;
    PMDL mdl;
    ULONG size;
    PMDL tmpMdlPtr;

    ASSERT(Length);

    UNREFERENCED_PARAMETER (ChargeQuota);

    //
    // If the requested length is greater than 2Gb, then we're not going
    // to be able to map the memory, so fail the request.
    //

    if (Length & 0x80000000) {
        return NULL;
    }


    //
    // Allocate an MDL from the lookaside list or pool as appropriate.
    //

    mdl = NULL;
    fixedSize = 0;
    size = ADDRESS_AND_SIZE_TO_SPAN_PAGES(VirtualAddress, Length);
    if (size > IOP_FIXED_SIZE_MDL_PFNS) {
        allocateSize = sizeof(MDL) + (sizeof(PFN_NUMBER) * size);
        if (allocateSize > MAXUSHORT) {
            return NULL;
        }

    } else {
        fixedSize = MDL_ALLOCATED_FIXED_SIZE;
        allocateSize =  sizeof(MDL) + (sizeof(PFN_NUMBER) * IOP_FIXED_SIZE_MDL_PFNS);
        mdl = (PMDL)ExAllocateFromPPLookasideList(LookasideMdlList);
    }

    if (!mdl) {
        mdl = ExAllocatePoolWithTag(NonPagedPool, allocateSize, ' ldM');
        if (!mdl) {
            return NULL;
        }
    }

    //
    // Now fill in the header of the MDL.
    //

    MmInitializeMdl(mdl, VirtualAddress, Length);
    mdl->MdlFlags |= (fixedSize);

    //
    // Finally, if an IRP was specified, store the address of the MDL
    // based on whether or not this is a secondary buffer.
    //

    if (Irp) {
        if (!SecondaryBuffer) {
            Irp->MdlAddress = mdl;

        } else {
            tmpMdlPtr = Irp->MdlAddress;
            while (tmpMdlPtr->Next != NULL) {
                tmpMdlPtr = tmpMdlPtr->Next;
            }

            tmpMdlPtr->Next = mdl;
        }
    }

    return mdl;
}

NTSTATUS
IoAsynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PIO_APC_ROUTINE ApcRoutine,
    IN PVOID ApcContext,
    IN IO_PAGING_PRIORITY Priority,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PIRP *Irp OPTIONAL
    )

/*++

Routine Description:

    This routine provides a special, fast interface for the Modified Page Writer
    (MPW) to write pages to the disk quickly and with very little overhead.  All
    of the special handling for this request is recognized by setting the
    IRP_PAGING_IO flag in the IRP flags word.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the write should be performed on.

    MemoryDescriptorList - An MDL which describes the physical pages that the
        pages should be written to the disk.  All of the pages have been locked
        in memory.  The MDL also describes the length of the write operation.

    StartingOffset - Pointer to the offset in the file from which the write
        should take place.

    ApcRoutine - The address of a kernel APC routine which should be executed
        after the write operation has completed.

    ApcContext - A context parameter which should be supplied to the kernel APC
        routine when it executes.

    Priority  - Priority that should be given to this request by the storage stack

    IoStatusBlock - A pointer to the I/O status block in which the final status
        and information should be stored.

    Irp - If specified, allows the caller to squirrel away a pointer to the Irp.

Return Value:

    The function value is the final status of the queue request to the I/O
    system subcomponents.


--*/

{
    PIRP irp;
    KIRQL irql;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;

    //
    // Increment performance counters
    //

    if (CcIsFileCached(FileObject)) {
        CcDataFlushes += 1;
        CcDataPages += (MemoryDescriptorList->ByteCount + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // Begin by getting a pointer to the device object that the file resides
    // on.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate an I/O Request Packet (IRP) for this out-page operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  If specified, let the caller know what Irp is responsible for this
    //  transfer.  While this is mainly for debugging purposes, it is
    //  absolutely essential to debug certain types of problems, and is
    //  very cheap, thus is included in the FREE build as well.
    //

    if (ARGUMENT_PRESENT(Irp)) {
        *Irp = irp;
    }

    //
    // Get a pointer to the first stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP according to this request.
    //

    irp->MdlAddress = MemoryDescriptorList;
    irp->Flags = IRP_PAGING_IO | IRP_NOCACHE;

    if ( Priority == IoPagingPriorityHigh ) {
        irp->Flags |= IRP_HIGH_PRIORITY_PAGING_IO;
    }

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->UserBuffer = (PVOID) ((PCHAR) MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset);
    irp->RequestorMode = KernelMode;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Fill in the normal write parameters.
    //

    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->Parameters.Write.Length = MemoryDescriptorList->ByteCount;
    irpSp->Parameters.Write.ByteOffset = *StartingOffset;
    irpSp->FileObject = FileObject;


    //
    // Queue the packet to the appropriate driver based on whether or not there
    // is a VPB associated with the device.
    //

    status = IoCallDriver( deviceObject, irp );

    if (NT_ERROR( status )) {
        IoStatusBlock->Status = status;
        IoStatusBlock->Information = 0;
        KeRaiseIrql( APC_LEVEL, &irql );
        ApcRoutine( ApcContext, IoStatusBlock, 0 );
        KeLowerIrql( irql );
        status = STATUS_PENDING;
    }

    return status;
}


NTSTATUS
IoAttachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PUNICODE_STRING TargetDevice,
    OUT PDEVICE_OBJECT *AttachedDevice
    )

/*++

Routine Description:

    This routine "attaches" a device to another device.  That is, it associates
    the source device to a target device which enables the I/O system to ensure
    that the target device a) exists, and b) cannot be unloaded until the source
    device has detached.  Also, requests bound for the target device are given
    to the source device first, where applicable.

Arguments:

    SourceDevice - Pointer to device object to be attached to the target.

    TargetDevice - Supplies the name of the target device to which the attach
        is to occur.

    AttachedDevice - Returns a pointer to the device to which the attach
        occurred.  This is the device object that the source driver should
        use to communicate with the target driver.

Return Value:

    The function value is the final status of the operation.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT targetDevice;
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();

    //
    // Attempt to open the target device for attach access.  This ensures that
    // the device itself will be opened, with all of the special considerations
    // thereof.
    //

    InitializeObjectAttributes( &objectAttributes,
                                TargetDevice,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenFile( &fileHandle,
                         FILE_READ_ATTRIBUTES,
                         &objectAttributes,
                         &ioStatus,
                         0,
                         FILE_NON_DIRECTORY_FILE | IO_ATTACH_DEVICE_API );

    if (NT_SUCCESS( status )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );
        if (NT_SUCCESS( status )) {

            //
            // Get a pointer to the device object for this file, and close
            // the handle.
            //

            targetDevice = IoGetRelatedDeviceObject( fileObject );
            (VOID) ZwClose( fileHandle );

        } else {

            return status;
        }

    } else {

        return status;

    }

    //
    // Set the attached device pointer so that the driver being attached to
    // cannot unload until the detach occurs, and so that attempts to open the
    // device object go through the attached driver.  Note that the reference
    // count is not incremented since exclusive drivers can only be opened once
    // and this would count as an open.  At that point, both device objects
    // would become useless.
    //

    status = IoAttachDeviceToDeviceStackSafe( SourceDevice, targetDevice, AttachedDevice );

    //
    // Finally, dereference the file object.  This decrements the reference
    // count for the target device so that when the detach occurs the device
    // can go away if necessary.
    //

    ObDereferenceObject( fileObject );

    //
    // Return the final status of the operation.
    //

    return status;
}

NTSTATUS
IoAttachDeviceByPointer(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine attaches the source device object to the target device
    object.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to take place.

Return Value:

    The function value is the final status of the attach operation.

Note:

    THIS FUNCTION IS OBSOLETE!!! see IoAttachDeviceToDeviceStack

--*/

{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the TargetDevice.
    //

    deviceObject = IoAttachDeviceToDeviceStack( SourceDevice, TargetDevice );
    if( deviceObject == NULL ){
        status = STATUS_NO_SUCH_DEVICE;
    } else {
        status = STATUS_SUCCESS;
    }

    return status;
}

PDEVICE_OBJECT
IoAttachDeviceToDeviceStack(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    )
/*++

Routine Description:

    This routine attaches the source device object to the target device
    object and returns a pointer to the actual device attached to, if
    successful.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to occur.

Return Value:

    If successful, this function returns a pointer to the device object to
    which the attachment actually occurred.

    If unsuccessful, this function returns NULL.  (This could happen if the
    device currently at the top of the attachment chain is being unloaded,
    deleted or initialized.)

--*/
{

    return (IopAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, NULL));

}

NTSTATUS
IoAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    )
/*++

Routine Description:

    This routine attaches the source device object to the target device
    object.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to occur.

    AttachedToDeviceObject - Specifies a pointer  where the attached to device object
        is stored. Its updated while holding the database lock so that when a filter gets an IRP
        its attached to device object field is updated correctly.

Return Value:

    None.

--*/
{

    if (IopAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, AttachedToDeviceObject) == NULL)
        return STATUS_NO_SUCH_DEVICE;
    else
        return STATUS_SUCCESS;
}

PDEVICE_OBJECT
IopAttachDeviceToDeviceStackSafe(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject OPTIONAL
    )

/*++

Routine Description:

    This routine attaches the source device object to the target device
    object and returns a pointer to the actual device attached to, if
    successful.

Arguments:

    SourceDevice - Specifies the device object that is to be attached to
        the target device.

    TargetDevice - Specifies the device object to which the attachment is
        to occur.

    AttachedToDeviceObject - Specifies a pointer  where the attached to device object
        is stored. Its updated while holding the database lock so that when a filter gets an IRP
        its attached to device object field is updated correctly.

Return Value:

    If successful, this function returns a pointer to the device object to
    which the attachment actually occurred.

    If unsuccessful, this function returns NULL.  (This could happen if the
    device currently at the top of the attachment chain is being unloaded,
    deleted or initialized.)

--*/

{
    PDEVICE_OBJECT deviceObject;
    PDEVOBJ_EXTENSION sourceExtension;
    KIRQL irql;

    //
    // Retrieve a pointer to the source device object's extension outside
    // of the IopDatabaseLock, since it isn't protected by that.
    //

    sourceExtension = SourceDevice->DeviceObjectExtension;

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the TargetDevice, and attach to it.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Tell the Special IRP code the stack has changed. Code that will reexamine
    // the stack takes the database lock, so we can place the call here. This
    // also allows us to assert correct behavior *before* the stack is built up.
    //

    IOV_ATTACH_DEVICE_TO_DEVICE_STACK(SourceDevice, TargetDevice);

    deviceObject = IoGetAttachedDevice( TargetDevice );

    //
    // Make sure that the SourceDevice object isn't already attached to
    // something else, this is now illegal.
    //

    ASSERT( sourceExtension->AttachedTo == NULL );

    //
    // Now attach to the device, provided that it is not being unloaded,
    // deleted or initializing.
    //

    if (deviceObject->Flags & DO_DEVICE_INITIALIZING ||
        deviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED)) {

        //
        // The device currently at the top of the attachment chain is being
        // unloaded, deleted or initialized.
        //

        deviceObject = (PDEVICE_OBJECT) NULL;

    } else {

        //
        // Perform the attachment.  First update the device previously at the
        // top of the attachment chain.
        //
        deviceObject->AttachedDevice = SourceDevice;
        deviceObject->Spare1++;

        //
        // Now update the new top-of-attachment-chain.
        //

        SourceDevice->StackSize = (UCHAR) (deviceObject->StackSize + 1);
        SourceDevice->AlignmentRequirement = deviceObject->AlignmentRequirement;
        SourceDevice->SectorSize = deviceObject->SectorSize;

        if (deviceObject->DeviceObjectExtension->ExtensionFlags & DOE_START_PENDING)  {
            SourceDevice->DeviceObjectExtension->ExtensionFlags |= DOE_START_PENDING;
        }

        //
        // Attachment chain is doubly-linked.
        //

        sourceExtension->AttachedTo = deviceObject;
    }

    //
    // Atomically update this field inside the lock.
    // The caller has to ensure that this location is in non-paged pool.
    // This is required so that a filesystem filter can attach to a device and before it
    // gets an IRP it can update its lower device object pointer.
    //

    if (AttachedToDeviceObject) {
        *AttachedToDeviceObject = deviceObject;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return deviceObject;
}

PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN
        IRP_MJ_POWER

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    IoStatusBlock - Pointer to the I/O status block for completion status
        information.  This parameter is optional since most asynchronous FSD
        requests will be synchronized by using completion routines, and so the
        I/O status block will not be written.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {
        return irp;
    }

    //
    // Set current thread for IoSetHardErrorOrVerifyDevice.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code.
    //

    irpSp->MajorFunction = (UCHAR) MajorFunction;

    if (MajorFunction != IRP_MJ_FLUSH_BUFFERS &&
        MajorFunction != IRP_MJ_SHUTDOWN &&
        MajorFunction != IRP_MJ_PNP &&
        MajorFunction != IRP_MJ_POWER) {

        //
        // Now allocate a buffer or lock the pages of the caller's buffer into
        // memory based on whether the target device performs direct or buffered
        // I/O operations.
        //

        if (DeviceObject->Flags & DO_BUFFERED_IO) {

            //
            // The target device supports buffered I/O operations.  Allocate a
            // system buffer and, if this is a write, fill it in.  Otherwise,
            // the copy will be done into the caller's buffer in the completion
            // code.  Also note that the system buffer should be deallocated on
            // completion.  Also, set the parameters based on whether this is a
            // read or a write operation.
            //

            irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     Length,
                                                                     '  oI' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            if (MajorFunction == IRP_MJ_WRITE) {
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, Buffer, Length );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
                irp->UserBuffer = Buffer;
            }

        } else if (DeviceObject->Flags & DO_DIRECT_IO) {

            //
            // The target device supports direct I/O operations.  Allocate
            // an MDL large enough to map the buffer and lock the pages into
            // memory.
            //

            irp->MdlAddress = IoAllocateMdl( Buffer,
                                             Length,
                                             FALSE,
                                             FALSE,
                                             NULL );

            if (irp->MdlAddress == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            try {
                MmProbeAndLockPages( irp->MdlAddress,
                                     KernelMode,
                                     (LOCK_OPERATION) (MajorFunction == IRP_MJ_READ ? IoWriteAccess : IoReadAccess) );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                  if (irp->MdlAddress != NULL) {
                      IoFreeMdl( irp->MdlAddress );
                  }
                  IoFreeIrp( irp );
                  return (PIRP) NULL;
            }

        } else {

            //
            // The operation is neither buffered nor direct.  Simply pass the
            // address of the buffer in the packet to the driver.
            //

            irp->UserBuffer = Buffer;
        }

        //
        // Set the parameters according to whether this is a read or a write
        // operation.  Notice that these parameters must be set even if the
        // driver has not specified buffered or direct I/O.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            irpSp->Parameters.Write.Length = Length;
            irpSp->Parameters.Write.ByteOffset = *StartingOffset;
        } else {
            irpSp->Parameters.Read.Length = Length;
            irpSp->Parameters.Read.ByteOffset = *StartingOffset;
        }
    }

    //
    // Finally, set the address of the I/O status block and return a pointer
    // to the IRP.
    //

    irp->UserIosb = IoStatusBlock;
    return irp;
}

PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) that can be used to
    perform a synchronous internal or normal device I/O control function.

Arguments:

    IoControlCode - Specifies the device I/O control code that is to be
        performed by the target device driver.

    DeviceObject - Specifies the target device on which the I/O control
        function is to be performed.

    InputBuffer - Optional pointer to an input buffer that is to be passed
        to the device driver.

    InputBufferLength - Length of the InputBuffer in bytes.  If the Input-
        Buffer parameter is not passed, this parameter must be zero.

    OutputBuffer - Optional pointer to an output buffer that is to be passed
        to the device driver.

    OutputBufferLength - Length of the OutputBuffer in bytes.  If the
        OutputBuffer parameter is not passed, this parameter must be zero.

    InternalDeviceIoControl - A BOOLEAN parameter that specifies whether
        the packet that gets generated should have a major function code
        of IRP_MJ_INTERNAL_DEVICE_CONTROL (the parameter is TRUE), or
        IRP_MJ_DEVICE_CONTROL (the parameter is FALSE).

    Event - Supplies a pointer to a kernel event that is to be set to the
        Signaled state when the I/O operation is complete.  Note that the
        Event must already be set to the Not-Signaled state.

    IoStatusBlock - Supplies a pointer to an I/O status block that is to
        be filled in with the final status of the operation once it
        completes.

Return Value:

    The function value is a pointer to the generated IRP suitable for calling
    the target device driver.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG method;

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize, FALSE );
    if (!irp) {
        return irp;
    }

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code based on the type of device I/O control
    // function the caller has specified.
    //

    if (InternalDeviceIoControl) {
        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    } else {
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all four methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    //
    // Get the method bits from the I/O control code to determine how the
    // buffers are to be passed to the driver.
    //

    method = IoControlCode & 3;

    //
    // Based on the method that the buffers are being passed, either allocate
    // buffers or build MDLs or do nothing.
    //

    switch ( method ) {

    case METHOD_BUFFERED:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer
        // to the allocated buffer and set the appropriate IRP fields.
        //

        if (InputBufferLength != 0 || OutputBufferLength != 0) {
            irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     InputBufferLength > OutputBufferLength ? InputBufferLength : OutputBufferLength,
                                                                     '  oI' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }
            if (ARGUMENT_PRESENT( InputBuffer )) {
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
            }
            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            irp->UserBuffer = OutputBuffer;
            if (ARGUMENT_PRESENT( OutputBuffer )) {
                irp->Flags |= IRP_INPUT_OPERATION;
            }
        } else {
            irp->Flags = 0;
            irp->UserBuffer = (PVOID) NULL;
        }

        break;

    case METHOD_IN_DIRECT:
    case METHOD_OUT_DIRECT:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that an output buffer must have been specified.
        //

        if (ARGUMENT_PRESENT( InputBuffer )) {
            irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                                     InputBufferLength,
                                                                     '  oI' );
            if (irp->AssociatedIrp.SystemBuffer == NULL) {
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }
            RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                           InputBuffer,
                           InputBufferLength );
            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        } else {
            irp->Flags = 0;
        }

        if (ARGUMENT_PRESENT( OutputBuffer )) {
            irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                             OutputBufferLength,
                                             FALSE,
                                             FALSE,
                                             NULL );
            if (irp->MdlAddress == NULL) {
                if (ARGUMENT_PRESENT( InputBuffer )) {
                    ExFreePool( irp->AssociatedIrp.SystemBuffer );
                }
                IoFreeIrp( irp );
                return (PIRP) NULL;
            }

            try {

                MmProbeAndLockPages( irp->MdlAddress,
                                     KernelMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                  if (irp->MdlAddress != NULL) {
                      IoFreeMdl( irp->MdlAddress );
                  }

                  if (ARGUMENT_PRESENT( InputBuffer )) {
                      ExFreePool( irp->AssociatedIrp.SystemBuffer );
                  }

                  IoFreeIrp( irp );
                  return (PIRP) NULL;
            }
        }

        break;

    case METHOD_NEITHER:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

    //
    // Finally, set the address of the I/O status block and the address of
    // the kernel event object.  Note that I/O completion will not attempt
    // to dereference the event since there is no file object associated
    // with this operation.
    //

    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;

    //
    // Also set the address of the current thread in the packet so the
    // completion code will have a context to execute in.  The IRP also
    // needs to be queued to the thread since the caller is going to set
    // the file object pointer.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    IopQueueThreadIrp( irp );

    //
    // Simply return a pointer to the packet.
    //

    return irp;
}

VOID
IoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine maps a portion of a buffer as described by an MDL.  The
    portion of the buffer to be mapped is specified via a virtual address
    and an optional length.  If the length is not supplied, then the
    remainder of the buffer is mapped.

Arguments:

    SourceMdl - MDL for the current buffer.

    TargetMdl - MDL to map the specified portion of the buffer.

    VirtualAddress - Base of the buffer to begin mapping.

    Length - Length of buffer to be mapped;  if zero, remainder.

Return Value:

    None.

Notes:

    This routine assumes that the target MDL is large enough to map the
    desired portion of the buffer.  If the target is not large enough
    then an exception will be raised.

    It is also assumed that the remaining length of the buffer to be mapped
    is non-zero.

--*/

{
    ULONG_PTR baseVa;
    ULONG offset;
    ULONG newLength;
    ULONG pageOffset;
    PPFN_NUMBER basePointer;
    PPFN_NUMBER copyPointer;

    //
    // Calculate the base address of the buffer that the source Mdl maps.
    // Then, determine the length of the buffer to be mapped, if not
    // specified.
    //

    baseVa = (ULONG_PTR) MmGetMdlBaseVa( SourceMdl );
    offset = (ULONG) ((ULONG_PTR)VirtualAddress - baseVa) - MmGetMdlByteOffset(SourceMdl);

    if (Length == 0) {
        newLength = MmGetMdlByteCount( SourceMdl ) - offset;
    } else {
        newLength = Length;
        //if (newLength > (MmGetMdlByteCount(SourceMdl) - offset)) {
        //    KeBugCheck( TARGET_MDL_TOO_SMALL );
        //}
    }

    //
    // Initialize the target MDL header.  Note that the original size of
    // the MDL structure itself is left unchanged.
    //

    TargetMdl->Process = SourceMdl->Process;

    TargetMdl->StartVa = (PVOID) PAGE_ALIGN( VirtualAddress );
    pageOffset = ((ULONG)((ULONG_PTR) TargetMdl->StartVa - (ULONG_PTR) SourceMdl->StartVa)) >> PAGE_SHIFT;


    TargetMdl->ByteCount = newLength;
    TargetMdl->ByteOffset = BYTE_OFFSET( VirtualAddress );
    newLength = ADDRESS_AND_SIZE_TO_SPAN_PAGES( VirtualAddress, newLength );
    if (((TargetMdl->Size - sizeof( MDL )) / sizeof (PFN_NUMBER)) < newLength ) {
        KeBugCheck( TARGET_MDL_TOO_SMALL );
    }

    //
    // Set the MdlFlags in the target MDL.  Clear all flags but
    // carry across the allocation information, page read and the
    // system mapped info.
    //

    TargetMdl->MdlFlags &= (MDL_ALLOCATED_FIXED_SIZE | MDL_ALLOCATED_MUST_SUCCEED);
    TargetMdl->MdlFlags |= SourceMdl->MdlFlags & (MDL_SOURCE_IS_NONPAGED_POOL |
                                                  MDL_MAPPED_TO_SYSTEM_VA |
                                                  MDL_IO_PAGE_READ |
                                                  MDL_IO_SPACE );
    TargetMdl->MdlFlags |= MDL_PARTIAL;

#if DBG
    if (TargetMdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) {
        TargetMdl->MdlFlags |= MDL_PARENT_MAPPED_SYSTEM_VA;
    }
#endif //DBG

    //
    // Preserved the mapped system address.
    //

    TargetMdl->MappedSystemVa = (PUCHAR)SourceMdl->MappedSystemVa + offset;

    //
    // Determine the base address of the first PFN in the source MDL that
    // needs to be copied to the target.  Then, copy as many PFNs as are
    // needed.
    //

    basePointer = MmGetMdlPfnArray(SourceMdl);
    basePointer += pageOffset;
    copyPointer = MmGetMdlPfnArray(TargetMdl);

    while (newLength > 0) {
        *copyPointer = *basePointer;
        copyPointer++;
        basePointer++;
        newLength--;
    }
}

PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

    The IRP created by this function causes the I/O system to complete the
    request by setting the specified event to the Signaled state.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    Event - Pointer to a kernel event structure for synchronization.  The event
        will be set to the Signaled state when the I/O has completed.

    IoStatusBlock - Pointer to I/O status block for completion status info.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;

    //
    // Do all of the real work in real IRP build routine.
    //

    irp = IoBuildAsynchronousFsdRequest( MajorFunction,
                                         DeviceObject,
                                         Buffer,
                                         Length,
                                         StartingOffset,
                                         IoStatusBlock );
    if (irp == NULL) {
        return irp;
    }

    //
    // Now fill in the event to the completion code will do the right thing.
    // Notice that because there is no FileObject, the I/O completion code
    // will not attempt to dereference the event.
    //

    irp->UserEvent = Event;

    //
    // There will be a file object associated w/this packet, so it must be
    // queued to the thread.
    //

    IopQueueThreadIrp( irp );
    return irp;
}


NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    if (pIofCallDriver != NULL) {

        //
        // This routine will either jump immediately to IovCallDriver or
        // IoPerfCallDriver.
        //
        return pIofCallDriver(DeviceObject, Irp, _ReturnAddress());
    }

    return IopfCallDriver(DeviceObject, Irp);
}

NTSTATUS
FASTCALL
IofCallDriverSpecifyReturn(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN OUT  PIRP            Irp,
    IN      PVOID           ReturnAddress   OPTIONAL
    )
{
    if (pIofCallDriver != NULL) {

        //
        // This routine will either jump immediately to IovCallDriver or
        // IoPerfCallDriver.
        //
        return pIofCallDriver(DeviceObject, Irp, ReturnAddress);
    }

    return IopfCallDriver(DeviceObject, Irp);
}


BOOLEAN
IoCancelIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to cancel an individual I/O Request Packet.
    It acquires the cancel spin lock, sets the cancel flag in the IRP, and
    then invokes the cancel routine specified by the appropriate field in
    the IRP, if a routine was specified.  It is expected that the cancel
    routine will release the cancel spinlock.  If there is no cancel routine,
    then the cancel spin lock is released.

Arguments:

    Irp - Supplies a pointer to the IRP to be cancelled.

Return Value:

    The function value is TRUE if the IRP was in a cancelable state (it
    had a cancel routine), else FALSE is returned.

Notes:

    It is assumed that the caller has taken the necessary action to ensure
    that the packet cannot be fully completed before invoking this routine.

--*/

{
    PDRIVER_CANCEL cancelRoutine;
    KIRQL irql;
    BOOLEAN returnValue;


    ASSERT( Irp->Type == IO_TYPE_IRP );

    if (IopVerifierOn) {
        if (IOV_CANCEL_IRP(Irp, &returnValue)) {
            return returnValue;
        }
    }

    //
    // Acquire the cancel spin lock.
    //

    IoAcquireCancelSpinLock( &irql );

    //
    // Set the cancel flag in the IRP.
    //

    Irp->Cancel = TRUE;

    //
    // Obtain the address of the cancel routine, and if one was specified,
    // invoke it.
    //

    cancelRoutine = (PDRIVER_CANCEL) (ULONG_PTR) InterlockedExchangePointer( (PVOID *) &Irp->CancelRoutine,
                                                                 NULL );

    if (cancelRoutine) {
        if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1)) {
            KeBugCheckEx( CANCEL_STATE_IN_COMPLETED_IRP, (ULONG_PTR) Irp, (ULONG_PTR) cancelRoutine, 0, 0 );
        }
        Irp->CancelIrql = irql;

        cancelRoutine( Irp->Tail.Overlay.CurrentStackLocation->DeviceObject,
                       Irp );
        //
        // The cancel spinlock should have been released by the cancel routine.
        //

        return(TRUE);

    } else {

        //
        // There was no cancel routine, so release the cancel spinlock and
        // return indicating the Irp was not currently cancelable.
        //

        IoReleaseCancelSpinLock( irql );

        return(FALSE);
    }
}



VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine cancels all of the I/O operations for the specified thread.
    This is accomplished by walking the list of IRPs in the thread IRP list
    and canceling each one individually.  No other I/O operations can be
    started for the thread since this routine has control of the thread itself.

Arguments:

    Tcb - Pointer to the Thread Control Block for the thread.

Return Value:

    None.

--*/

{
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    KIRQL irql;
    PETHREAD thread;
    PIRP irp;
    ULONG count;
    LARGE_INTEGER interval;

    PAGED_CODE();

    DBG_UNREFERENCED_PARAMETER( Thread );

    thread = PsGetCurrentThread();

    header = &thread->IrpList;

    if ( IsListEmpty( header )) {
        return;
    }

    //
    // Raise the IRQL so that the IrpList cannot be modified by a completion
    // APC.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    entry = header->Flink;

    //
    // Walk the list of pending IRPs, canceling each of them.
    //

    while (header != entry) {
        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        IoCancelIrp( irp );
        entry = entry->Flink;
    }

    //
    // Wait for the requests to complete.  Note that waiting may eventually
    // timeout, in which case more work must be done.
    //

    count = 0;
    interval.QuadPart = -10 * 1000 * 100;

    while (!IsListEmpty( header )) {

        //
        // Lower the IRQL so that the thread APC can fire which will complete
        // the requests.  Delay execution for a time and let the request
        // finish.  The delay time is 100ms.
        //

        KeLowerIrql( irql );
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        if (count++ > 3000) {

            //
            // This I/O request has timed out, as it has not been completed
            // for a full 5 minutes. Attempt to remove the packet's association
            // with this thread.  Note that by not resetting the count, the
            // next time through the loop the next packet, if there is one,
            // which has also timed out, will be dealt with, although it
            // will be given another 100ms to complete.
            //

            IopDisassociateThreadIrp();
        }

        KeRaiseIrql( APC_LEVEL, &irql );
    }

    KeLowerIrql( irql );
}

NTSTATUS
IoCheckDesiredAccess(
    IN OUT PACCESS_MASK DesiredAccess,
    IN ACCESS_MASK GrantedAccess
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not the granted access
    to a file allows the access specified by a desired access.

Arguments:

    DesiredAccess - Pointer to a variable containing the access desired to
        the file.

    GrantedAccess - Access currently granted to the file.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has the access to the file, then STATUS_SUCCESS is returned;
    otherwise, STATUS_ACCESS_DENIED is returned.

    Also, the DesiredAccess is returned with no generic mapping.

--*/

{
    PAGED_CODE();

    //
    // Convert the desired access to a non-generic access mask.
    //

    RtlMapGenericMask( DesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    //
    // Determine whether the desired access to the file is allowed, given
    // the current granted access.
    //

    if (!SeComputeDeniedAccesses( GrantedAccess, *DesiredAccess )) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_ACCESS_DENIED;
    }
}

NTSTATUS
IoCheckEaBufferValidity(
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    OUT PULONG ErrorOffset
    )

/*++

Routine Description:

    This routine checks the validity of the specified EA buffer to guarantee
    that its format is proper, no fields hang over, that it is not recursive,
    etc.

Arguments:

    EaBuffer - Pointer to the buffer containing the EAs to be checked.

    EaLength - Specifies the length of EaBuffer.

    ErrorOffset - A variable to receive the offset of the offending entry
        in the EA buffer if an error is incurred.  This variable is only
        valid if an error occurs.

Return Value:

    The function value is STATUS_SUCCESS if the EA buffer contains a valid,
    properly formed list, otherwise STATUS_EA_LIST_INCONSISTENT.

--*/

#define ALIGN_LONG( Address ) ( (ULONG) ((Address + 3) & ~3) )

#define GET_OFFSET_LENGTH( CurrentEa, EaBase ) (    \
    (ULONG) ((PCHAR) CurrentEa - (PCHAR) EaBase) )

{
    LONG tempLength;
    ULONG entrySize;
    PFILE_FULL_EA_INFORMATION eas;

    PAGED_CODE();

    //
    // Walk the buffer and ensure that its format is valid.  That is, ensure
    // that it does not walk off the end of the buffer, is not recursive,
    // etc.
    //

    eas = EaBuffer;
    tempLength = EaLength;

    for (;;) {

        //
        // Get the size of the current entry in the buffer.  The minimum
        // size of the entry is the fixed size part of the structure plus
        // the length of the name, a single termination character byte which
        // must be present (a 0), plus the length of the value.  If this
        // is not the last entry, then there will also be pad bytes to get
        // to the next longword boundary.
        //

        //
        // Start by checking that the fixed size lies within the stated length.
        //

        if (tempLength < FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0])) {

            *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
            return STATUS_EA_LIST_INCONSISTENT;
        }

        entrySize = FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                        eas->EaNameLength + 1 + eas->EaValueLength;

        //
        // Confirm that the full length lies within the stated buffer length.
        //

        if ((ULONG) tempLength < entrySize) {

            *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
            return STATUS_EA_LIST_INCONSISTENT;
        }

        //
        // Confirm that there is a NULL terminator after the name.
        //

        if (eas->EaName[eas->EaNameLength] != '\0') {

            *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
            return STATUS_EA_LIST_INCONSISTENT;
        }

        if (eas->NextEntryOffset) {

            //
            // There is another entry in the buffer and it must be longword
            // aligned.  Ensure that the offset indicates that it is.  If it
            // isn't, return invalid parameter.
            //

            if (ALIGN_LONG( entrySize ) != eas->NextEntryOffset ||
                (LONG) eas->NextEntryOffset < 0) {
                *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
                return STATUS_EA_LIST_INCONSISTENT;

            } else {

                //
                // There is another entry in the buffer, so account for the
                // size of the current entry in the length and get a pointer
                // to the next entry.
                //

                tempLength -= eas->NextEntryOffset;
                if (tempLength < 0) {
                    *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
                    return STATUS_EA_LIST_INCONSISTENT;
                }
                eas = (PFILE_FULL_EA_INFORMATION) ((PCHAR) eas + eas->NextEntryOffset);

            }

        } else {

            //
            // There are no other entries in the buffer.  Simply account for
            // the overall buffer length according to the size of the current
            // entry and exit the loop.
            //

            tempLength -= entrySize;
            break;

        }
    }

    //
    // All of the entries in the buffer have been processed.  Check to see
    // whether the overall buffer length went negative.  If so, return an
    // error.
    //

    if (tempLength < 0) {
        *ErrorOffset = GET_OFFSET_LENGTH( eas, EaBuffer );
        return STATUS_EA_LIST_INCONSISTENT;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IoCheckFunctionAccess(
    IN ACCESS_MASK GrantedAccess,
    IN UCHAR MajorFunction,
    IN UCHAR MinorFunction,
    IN ULONG IoControlCode,
    IN PVOID Arg1 OPTIONAL,
    IN PVOID Arg2 OPTIONAL
    )

/*++

Routine Description:

    This routine checks the parameters and access for the function and
    parameters specified by the input parameters against the current access
    to the file as described by the GrantedAccess mask parameter.  If the
    caller has the access to the file, then a successful status code is
    returned.  Otherwise, an error status code is returned as the function
    value.

Arguments:

    GrantedAccess - Access granted to the file for the caller.

    MajorFunction - Major function code for the operation being performed.

    MinorFunction - Minor function code for the operation being performed.

    IoControlCode - I/O function control code for a device or file system I/O
        code.  Used only for those two function types.

    Arg1 - Optional argument that depends on the major function. Its
         FileInformationClass if the major function code indicates a query or set
         file information function is being performed. It points to Security Info
         if major function code is IRP_MJ_*_SECURITY.

    Arg2 - Optional second argument that depends on the major function. Currently its
        FsInformationClass.This parameter MUST be supplied if the major function
        code indicates that a query or set file system information function is
        being performed.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has the access to the file, then STATUS_SUCCESS is returned;
    otherwise, STATUS_ACCESS_DENIED is returned.

Note:

    The GrantedAccess mask may not contain any generic mappings.  That is,
    the IoCheckDesiredAccess function must have been previously invoked to
    return a full mask.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PFILE_INFORMATION_CLASS FileInformationClass;
    PFS_INFORMATION_CLASS FsInformationClass;
    SECURITY_INFORMATION SecurityInformation;
    ACCESS_MASK DesiredAccess;

    UNREFERENCED_PARAMETER( MinorFunction );

    PAGED_CODE();

    //
    // Determine the major function being performed.  If the function code
    // is invalid, then return an error.
    //

    FileInformationClass = (PFILE_INFORMATION_CLASS)Arg1;
    FsInformationClass = (PFS_INFORMATION_CLASS)Arg2;

    switch( MajorFunction ) {

    case IRP_MJ_CREATE:
    case IRP_MJ_CLOSE:

        break;

    case IRP_MJ_READ:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_READ_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_WRITE:

        if (!SeComputeGrantedAccesses( GrantedAccess, FILE_WRITE_DATA | FILE_APPEND_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_QUERY_INFORMATION:

        if (IopQueryOperationAccess[*FileInformationClass] != 0) {
            if (SeComputeDeniedAccesses( GrantedAccess, IopQueryOperationAccess[*FileInformationClass] )) {
                status = STATUS_ACCESS_DENIED;
            }
        }
        break;

    case IRP_MJ_SET_INFORMATION:

        if (IopSetOperationAccess[*FileInformationClass] != 0) {
            if (SeComputeDeniedAccesses( GrantedAccess, IopSetOperationAccess[*FileInformationClass] )) {
                status = STATUS_ACCESS_DENIED;
            }
        }
        break;

    case IRP_MJ_QUERY_EA:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_READ_EA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_SET_EA:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_WRITE_EA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_FLUSH_BUFFERS:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_WRITE_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_QUERY_VOLUME_INFORMATION:

        if (SeComputeDeniedAccesses( GrantedAccess, IopQueryFsOperationAccess[*FsInformationClass] )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_SET_VOLUME_INFORMATION:

        if (SeComputeDeniedAccesses( GrantedAccess, IopSetFsOperationAccess[*FsInformationClass] )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_DIRECTORY_CONTROL:

        if (SeComputeDeniedAccesses( GrantedAccess, FILE_LIST_DIRECTORY )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_FILE_SYSTEM_CONTROL:
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        {
            ULONG accessMode = (IoControlCode >> 14) & 3;

            if (accessMode != FILE_ANY_ACCESS) {

                //
                // This I/O control requires that the caller have read, write,
                // or read/write access to the object.  If this is not the case,
                // then cleanup and return an appropriate error status code.
                //

                if (!(SeComputeGrantedAccesses( GrantedAccess, accessMode ))) {
                    status = STATUS_ACCESS_DENIED;
                }
            }

        }
        break;

    case IRP_MJ_LOCK_CONTROL:

        if (!SeComputeGrantedAccesses( GrantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_SET_SECURITY:

        SecurityInformation = *((PSECURITY_INFORMATION)Arg1);
        SeSetSecurityAccessMask(SecurityInformation, &DesiredAccess);

        if (SeComputeDeniedAccesses( GrantedAccess, DesiredAccess )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;

    case IRP_MJ_QUERY_SECURITY:

        SecurityInformation = *((PSECURITY_INFORMATION)Arg1);
        SeQuerySecurityAccessMask(SecurityInformation, &DesiredAccess);

        if (SeComputeDeniedAccesses( GrantedAccess, DesiredAccess )) {
            status = STATUS_ACCESS_DENIED;
        }
        break;
    default:

        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    return status;
}

NTKERNELAPI
NTSTATUS
IoCheckQuerySetFileInformation(
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    )

/*++

Routine Description:

    This routine checks the validity of the parameters for either a query or a
    set file information operation.  It is used primarily by network servers
    running in kernel mode since no such parameter validity checking is done
    in the normal path.

Arguments:

    FileInformationClass - Specifies the information class to check checked.

    Length - Specifies the length of the buffer supplied.

    SetOperation - Specifies that the operation was a set file information as
        opposed to a query operation.

Return Value:

    The function value is STATUS_SUCCESS if the parameters were valid,
    otherwise an appropriate error is returned.

--*/

{
    PCHAR operationLength;

    //
    // The file information class itself must be w/in the valid range of file
    // information classes, otherwise this is an invalid information class.
    //

    if ((ULONG) FileInformationClass >= FileMaximumInformation) {
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    // Determine whether this is a query or a set operation and act accordingly.
    //

    if (SetOperation) {
        operationLength = (PCHAR) IopSetOperationLength;
    }
    else {
        operationLength = (PCHAR) IopQueryOperationLength;
    }

    if (!operationLength[FileInformationClass]) {
        return STATUS_INVALID_INFO_CLASS;
    }
    if (Length < (ULONG) operationLength[FileInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    return STATUS_SUCCESS;
}
NTKERNELAPI
NTSTATUS
IoCheckQuerySetVolumeInformation(
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    IN BOOLEAN SetOperation
    )

/*++

Routine Description:

    This routine checks the validity of the parameters for either a query or a
    set volume information operation.  It is used primarily by network servers
    running in kernel mode since no such parameter validity checking is done
    in the normal path.

Arguments:

    FsInformationClass - Specifies the information class to check.

    Length - Specifies the length of the buffer supplied.

    SetOperation - Specifies that the operation was a set volume information as
        opposed to a query operation.

Return Value:

    The function value is STATUS_SUCCESS if the parameters were valid,
    otherwise an appropriate error is returned.

--*/

{
    PCHAR operationLength;

    if (SetOperation) {
        operationLength = (PCHAR) IopSetFsOperationLength;
    }
    else {
        operationLength = (PCHAR) IopQueryFsOperationLength;
    }

    //
    // The volume information class itself must be w/in the valid range of file
    // information classes, otherwise this is an invalid information class.
    //
    if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
        operationLength[ FsInformationClass ] == 0 ) {

        return STATUS_INVALID_INFO_CLASS;
    }

    if (Length < (ULONG) operationLength[FsInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IoCheckQuotaBufferValidity(
    IN PFILE_QUOTA_INFORMATION QuotaBuffer,
    IN ULONG QuotaLength,
    OUT PULONG ErrorOffset
    )

/*++

Routine Description:

    This routine checks the validity of the specified quota buffer to guarantee
    that its format is proper, no fields hang over, that it is not recursive,
    etc.

Arguments:

    QuotaBuffer - Pointer to the buffer containing the quota entries to be
        checked.

    QuotaLength - Specifies the length of the QuotaBuffer.

    ErrorOffset - A variable to receive the offset of the offending entry in
        the quota buffer if an error is incurred.  This variable is only valid
        if an error occurs.

Return Value:

    The function value is STATUS_SUCCESS if the quota buffer contains a valid,
    properly formed list, otherwise STATUS_QUOTA_LIST_INCONSISTENT.

--*/

#if defined(_X86_)
#define REQUIRED_QUOTA_ALIGNMENT sizeof( ULONG )
#else
#define REQUIRED_QUOTA_ALIGNMENT sizeof( ULONGLONG )
#endif

#define ALIGN_QUAD( Address ) ( (ULONG) ((Address + 7) & ~7) )

#define GET_OFFSET_LENGTH( CurrentEntry, QuotaBase ) (\
    (ULONG) ((PCHAR) CurrentEntry - (PCHAR) QuotaBase) )

{
    LONG tempLength;
    ULONG entrySize;
    PFILE_QUOTA_INFORMATION quotas;

    PAGED_CODE();

    //
    // Walk the buffer and ensure that its format is valid.  That is, ensure
    // that it does not walk off the end of the buffer, is not recursive,
    // etc.
    //

    quotas = QuotaBuffer;
    tempLength = QuotaLength;

    //
    // Ensure the buffer has the correct alignment.
    //

    if ((ULONG_PTR) quotas & (REQUIRED_QUOTA_ALIGNMENT - 1)) {
        *ErrorOffset = 0;
        return STATUS_DATATYPE_MISALIGNMENT;
    }

    for (;;) {

        ULONG sidLength;

        //
        // Get the size of the current entry in the buffer.  The minimum size
        // of the entry is the fixed size part of the structure plus the actual
        // length of the SID.  If this is not the last entry, then there will
        // also be pad bytes to get to the next longword boundary.  Likewise,
        // ensure that the SID itself is valid.
        //

        if (tempLength < FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) ||
            !RtlValidSid( &quotas->Sid )) {
            goto error_exit;
        }

        sidLength = RtlLengthSid( (&quotas->Sid) );
        entrySize = FIELD_OFFSET( FILE_QUOTA_INFORMATION, Sid ) + sidLength;

        //
        // Confirm that the full length lies within the stated buffer length.
        //

        if ((ULONG) tempLength < entrySize ||
            quotas->SidLength != sidLength) {
            goto error_exit;
        }

        if (quotas->NextEntryOffset) {

            //
            // There is another entry in the buffer and it must be longword
            // aligned.  Ensure that the offset indicates that it is.  If it
            // is not, return error status code.
            //

            if (entrySize > quotas->NextEntryOffset ||
                quotas->NextEntryOffset & (REQUIRED_QUOTA_ALIGNMENT - 1) ||
                (LONG) quotas->NextEntryOffset < 0) {
                goto error_exit;

            } else {

                //
                // There is another entry in the buffer, so account for the size
                // of the current entry in the length and get a pointer to the
                // next entry.
                //

                tempLength -= quotas->NextEntryOffset;
                if (tempLength < 0) {
                    goto error_exit;
                }
                quotas = (PFILE_QUOTA_INFORMATION) ((PCHAR) quotas + quotas->NextEntryOffset);
            }

        } else {

            //
            // There are no more entries in the buffer.  Simply account for the
            // overall buffer length according to the size of the current
            // entry and exit the loop.
            //

            tempLength -= entrySize;
            break;
        }
    }

    //
    // All of the entries in the buffer have been processed.  Check to see
    // whether the overall buffer length went negative.  If so, return an
    // error.
    //

    if (tempLength < 0) {
        goto error_exit;
    }

    return STATUS_SUCCESS;

error_exit:

    *ErrorOffset = GET_OFFSET_LENGTH( quotas, QuotaBuffer );
    return STATUS_QUOTA_LIST_INCONSISTENT;

}

NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not a new accessor to
    a file actually has shared access to it.  The check is made according
    to:

        1)  How the file is currently opened.

        2)  What types of shared accesses are currently specified.

        3)  The desired and shared accesses that the new open is requesting.

    If the open should succeed, then the access information about how the
    file is currently opened is updated, according to the Update parameter.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

    Update - Specifies whether or not the share access information for the
        file is to be updated.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has access to the file, STATUS_SUCCESS is returned.  Otherwise,
    STATUS_SHARING_VIOLATION is returned.

Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    ULONG ocount;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    // Note that reading and writing attributes are not included in the
    // access check.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);


    //
    // There is no more work to do unless the user specified one of the
    // sharing modes above.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // If this is a special filter fileobject ignore share access check if necessary.
        //

        if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
            PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

            if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {
                return STATUS_SUCCESS;
            }
        }

        //
        // Now check to see whether or not the desired accesses are compatible
        // with the way that the file is currently open.
        //

        ocount = ShareAccess->OpenCount;

        if ( (FileObject->ReadAccess && (ShareAccess->SharedRead < ocount))
             ||
             (FileObject->WriteAccess && (ShareAccess->SharedWrite < ocount))
             ||
             (FileObject->DeleteAccess && (ShareAccess->SharedDelete < ocount))
             ||
             ((ShareAccess->Readers != 0) && !FileObject->SharedRead)
             ||
             ((ShareAccess->Writers != 0) && !FileObject->SharedWrite)
             ||
             ((ShareAccess->Deleters != 0) && !FileObject->SharedDelete)
           ) {

            //
            // The check failed.  Simply return to the caller indicating that the
            // current open cannot access the file.
            //

            return STATUS_SHARING_VIOLATION;

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

        } else if (Update) {

            ShareAccess->OpenCount++;

            ShareAccess->Readers += FileObject->ReadAccess;
            ShareAccess->Writers += FileObject->WriteAccess;
            ShareAccess->Deleters += FileObject->DeleteAccess;

            ShareAccess->SharedRead += FileObject->SharedRead;
            ShareAccess->SharedWrite += FileObject->SharedWrite;
            ShareAccess->SharedDelete += FileObject->SharedDelete;
        }
    }
    return STATUS_SUCCESS;
}

VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    //
    // This routine will either jump immediately to IopfCompleteRequest, or
    // rather IovCompleteRequest.
    //
    pIofCompleteRequest(Irp, PriorityBoost);
}

VOID
FASTCALL
IopfCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )

/*++

Routine Description:

    This routine is invoked to complete an I/O request.  It is invoked by the
    driver in its DPC routine to perform the final completion of the IRP.  The
    functions performed by this routine are as follows.

        1.  A check is made to determine whether the packet's stack locations
            have been exhausted.  If not, then the stack location pointer is set
            to the next location and if there is a routine to be invoked, then
            it will be invoked.  This continues until there are either no more
            routines which are interested or the packet runs out of stack.

            If a routine is invoked to complete the packet for a specific driver
            which needs to perform work a lot of work or the work needs to be
            performed in the context of another process, then the routine will
            return an alternate success code of STATUS_MORE_PROCESSING_REQUIRED.
            This indicates that this completion routine should simply return to
            its caller because the operation will be "completed" by this routine
            again sometime in the future.

        2.  A check is made to determine whether this IRP is an associated IRP.
            If it is, then the count on the master IRP is decremented.  If the
            count for the master becomes zero, then the master IRP will be
            completed according to the steps below taken for a normal IRP being
            completed.  If the count is still non-zero, then this IRP (the one
            being completed) will simply be deallocated.

        3.  If this is paging I/O or a close operation, then simply write the
            I/O status block and set the event to the signaled state, and
            dereference the event.  If this is paging I/O, deallocate the IRP
            as well.

        4.  Unlock the pages, if any, specified by the MDL by calling
            MmUnlockPages.

        5.  A check is made to determine whether or not completion of the
            request can be deferred until later.  If it can be, then this
            routine simply exits and leaves it up to the originator of the
            request to fully complete the IRP.  By not initializing and queueing
            the special kernel APC to the calling thread (which is the current
            thread by definition), a lot of interrupt and queueing processing
            can be avoided.


        6.  The final rundown routine is invoked to queue the request packet to
            the target (requesting) thread as a special kernel mode APC.

Arguments:

    Irp - Pointer to the I/O Request Packet to complete.

    PriorityBoost - Supplies the amount of priority boost that is to be given
        to the target thread when the special kernel APC is queued.

Return Value:

    None.

--*/

#define ZeroIrpStackLocation( IrpSp ) {         \
    (IrpSp)->MinorFunction = 0;                 \
    (IrpSp)->Flags = 0;                         \
    (IrpSp)->Control &= SL_ERROR_RETURNED ;     \
    (IrpSp)->Parameters.Others.Argument1 = 0;   \
    (IrpSp)->Parameters.Others.Argument2 = 0;   \
    (IrpSp)->Parameters.Others.Argument3 = 0;   \
    (IrpSp)->FileObject = (PFILE_OBJECT) NULL; }

{
    PIRP masterIrp;
    NTSTATUS status;
    PIO_STACK_LOCATION stackPointer;
    PIO_STACK_LOCATION bottomSp;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;
    PETHREAD thread;
    PFILE_OBJECT fileObject;
    KIRQL irql;
    PVOID saveAuxiliaryPointer = NULL;
    NTSTATUS    errorStatus;

    //
    // Begin by ensuring that this packet has not already been completed
    // by someone.
    //

    if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1) ||
        Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }

    //
    // Ensure that the packet being completed really is still an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Ensure that no one believes that this request is still in a cancelable
    // state.
    //

    ASSERT( !Irp->CancelRoutine );

    //
    // Ensure that the packet is not being completed with a thoroughly
    // confusing status code.  Actually completing a packet with a pending
    // status probably means that someone forgot to set the real status in
    // the packet.
    //

    ASSERT( Irp->IoStatus.Status != STATUS_PENDING );

    //
    // Ensure that the packet is not being completed with a minus one.  This
    // is apparently a common problem in some drivers, and has no meaning
    // as a status code.
    //

    ASSERT( Irp->IoStatus.Status != 0xffffffff );

    //
    // Diagnosability support.
    //

    bottomSp = ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) + sizeof( IRP )));

    if (bottomSp->Control & SL_ERROR_RETURNED) {
        errorStatus = (NTSTATUS)(ULONG_PTR)(bottomSp->Parameters.Others.Argument4);
    } else {
        errorStatus = STATUS_SUCCESS;
    }

    //
    // Now check to see whether this is the last driver that needs to be
    // invoked for this packet.  If not, then bump the stack and check to
    // see whether the driver wishes to see the completion.  As each stack
    // location is examined, invoke any routine which needs to be invoked.
    // If the routine returns STATUS_MORE_PROCESSING_REQUIRED, then stop the
    // processing of this packet.
    //

    for (stackPointer = IoGetCurrentIrpStackLocation( Irp ),
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++;
         Irp->CurrentLocation <= (CCHAR) (Irp->StackCount + 1);
         stackPointer++,
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++) {

        //
        // A stack location was located.  Check to see whether or not it
        // has a completion routine and if so, whether or not it should be
        // invoked.
        //
        // Begin by saving the pending returned flag in the current stack
        // location in the fixed part of the IRP.
        //

        Irp->PendingReturned = stackPointer->Control & SL_PENDING_RETURNED;

        //
        // If a completion routine changed the status then
        // mark the upper level stack pointer as the one
        // that flagged the error.
        //

        if (!NT_SUCCESS(Irp->IoStatus.Status)) {

            if (Irp->IoStatus.Status != errorStatus) {
                errorStatus = Irp->IoStatus.Status;
                stackPointer->Control |= SL_ERROR_RETURNED;
                bottomSp->Parameters.Others.Argument4 = (PVOID)(ULONG_PTR)errorStatus;
                bottomSp->Control |= SL_ERROR_RETURNED; // Mark that there is status in this location
            }
        }

        if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
             (!NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_ERROR) ||
             (Irp->Cancel &&
             stackPointer->Control & SL_INVOKE_ON_CANCEL)
           ) {

            //
            // This driver has specified a completion routine.  Invoke the
            // routine passing it a pointer to its device object and the
            // IRP that is being completed.
            //

            ZeroIrpStackLocation( stackPointer );

            if (Irp->CurrentLocation == (CCHAR) (Irp->StackCount + 1)) {
                deviceObject = NULL;
            }
            else {
                deviceObject = IoGetCurrentIrpStackLocation( Irp )->DeviceObject;
            }

            status = stackPointer->CompletionRoutine( deviceObject,
                                                      Irp,
                                                      stackPointer->Context );

            if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                //
                // Note:  Notice that if the driver has returned the above
                //        status value, it may have already DEALLOCATED the
                //        packet!  Therefore, do NOT touch any part of the
                //        IRP in the following code.
                //

                return;
            }

        } else {
            if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount) {
                IoMarkIrpPending( Irp );
            }
            ZeroIrpStackLocation( stackPointer );
        }
    }

    //
    // Check to see whether this is an associated IRP.  If so, then decrement
    // the count in the master IRP.  If the count is decremented to zero,
    // then complete the master packet as well.
    //

    if (Irp->Flags & IRP_ASSOCIATED_IRP) {
        ULONG count;

        masterIrp = Irp->AssociatedIrp.MasterIrp;

        //
        // After this decrement master IRP cannot be touched except if count == 1.
        //

        count = IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                              &masterIrp->AssociatedIrp.IrpCount );

        //
        // Deallocate this packet and any MDLs that are associated with it
        // by either doing direct deallocations if they were allocated from
        // a zone or by queueing the packet to a thread to perform the
        // deallocation.
        //
        // Also, check the count of the master IRP to determine whether or not
        // the count has gone to zero.  If not, then simply get out of here.
        // Otherwise, complete the master packet.
        //

        IopFreeIrpAndMdls( Irp );
        if (count == 1) {
            IoCompleteRequest( masterIrp, PriorityBoost );
        }
        return;
    }

    //
    // Check to see if we have a name junction. If so set the stage to
    // transmogrify the reparse point data in IopCompleteRequest.
    //

    if ((Irp->IoStatus.Status == STATUS_REPARSE )  &&
        (Irp->IoStatus.Information > IO_REPARSE_TAG_RESERVED_RANGE)) {

        if (Irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {

            //
            // For name junctions, we save the pointer to the auxiliary
            // buffer and use it below.
            //

            ASSERT( Irp->Tail.Overlay.AuxiliaryBuffer != NULL );

            saveAuxiliaryPointer = (PVOID) Irp->Tail.Overlay.AuxiliaryBuffer;

            //
            // We NULL the entry to avoid its de-allocation at this time.
            // This buffer get deallocated in IopDoNameTransmogrify
            //

            Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
        } else {

            //
            // Fail the request. A driver needed to act on this IRP prior
            // to getting to this point.
            //

            Irp->IoStatus.Status = STATUS_IO_REPARSE_TAG_NOT_HANDLED;
        }
    }

    //
    // Check the auxiliary buffer pointer in the packet and if a buffer was
    // allocated, deallocate it now.  Note that this buffer must be freed
    // here since the pointer is overlayed with the APC that will be used
    // to get to the requesting thread's context.
    //

    if (Irp->Tail.Overlay.AuxiliaryBuffer) {
        ExFreePool( Irp->Tail.Overlay.AuxiliaryBuffer );
        Irp->Tail.Overlay.AuxiliaryBuffer = NULL;
    }

    //
    // Check to see if this is paging I/O or a close operation.  If either,
    // then special processing must be performed.  The reasons that special
    // processing must be performed is different based on the type of
    // operation being performed.  The biggest reasons for special processing
    // on paging operations are that using a special kernel APC for an in-
    // page operation cannot work since the special kernel APC can incur
    // another pagefault.  Likewise, all paging I/O uses MDLs that belong
    // to the memory manager, not the I/O system.
    //
    // Close operations are special because the close may have been invoked
    // because of a special kernel APC (some IRP was completed which caused
    // the reference count on the object to become zero while in the I/O
    // system's special kernel APC routine).  Therefore, a special kernel APC
    // cannot be used since it cannot execute until the close APC finishes.
    //
    // The special steps are as follows for a synchronous paging operation
    // and close are:
    //
    //     1.  Copy the I/O status block (it is in SVAS, nonpaged).
    //     2.  Signal the event
    //     3.  If paging I/O, deallocate the IRP
    //
    // The special steps taken for asynchronous paging operations (out-pages)
    // are as follows:
    //
    //     1.  Initialize a special kernel APC just for page writes.
    //     1.  Queue the special kernel APC.
    //
    // It should also be noted that the logic for completing a Mount request
    // operation is exactly the same as a Page Read.  No assumptions should be
    // made here about this being a Page Read operation w/o carefully checking
    // to ensure that they are also true for a Mount.  That is:
    //
    //     IRP_PAGING_IO  and  IRP_MOUNT_COMPLETION
    //
    // are the same flag in the IRP.
    //
    // Also note that the last time the IRP is touched for a close operation
    // must be just before the event is set to the signaled state.  Once this
    // occurs, the IRP can be deallocated by the thread waiting for the event.
    //
    //
    // IRP_CLOSE_OPERATION and IRP_SET_USER_EVENT are the same flags. They both indicate
    // that only the user event field should be set and no APC should be queued. Unfortunately
    // IRP_CLOSE_OPERATION is used by some drivers to do exactly this so it cannot be renamed.
    //
    //

    if (Irp->Flags & (IRP_PAGING_IO | IRP_CLOSE_OPERATION |IRP_SET_USER_EVENT)) {
        if (Irp->Flags & (IRP_SYNCHRONOUS_PAGING_IO | IRP_CLOSE_OPERATION |IRP_SET_USER_EVENT)) {
            ULONG flags;

            flags = Irp->Flags & (IRP_SYNCHRONOUS_PAGING_IO|IRP_PAGING_IO);
            *Irp->UserIosb = Irp->IoStatus;
            (VOID) KeSetEvent( Irp->UserEvent, PriorityBoost, FALSE );
            if (flags) {
                if (IopIsReserveIrp(Irp)) {
                    IopFreeReserveIrp(PriorityBoost);
                } else {
                    IoFreeIrp( Irp );
                }
            }
        } else {
            thread = Irp->Tail.Overlay.Thread;
            KeInitializeApc( &Irp->Tail.Apc,
                             &thread->Tcb,
                             Irp->ApcEnvironment,
                             IopCompletePageWrite,
                             (PKRUNDOWN_ROUTINE) NULL,
                             (PKNORMAL_ROUTINE) NULL,
                             KernelMode,
                             (PVOID) NULL );
            (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                     (PVOID) NULL,
                                     (PVOID) NULL,
                                     PriorityBoost );
        }
        return;
    }

    //
    // Check to see whether any pages need to be unlocked.
    //

    if (Irp->MdlAddress != NULL) {

        //
        // Unlock any pages that may be described by MDLs.
        //

        mdl = Irp->MdlAddress;
        while (mdl != NULL) {
            MmUnlockPages( mdl );
            mdl = mdl->Next;
        }
    }

    //
    // Make a final check here to determine whether or not this is a
    // synchronous I/O operation that is being completed in the context
    // of the original requestor.  If so, then an optimal path through
    // I/O completion can be taken.
    //

    if (Irp->Flags & IRP_DEFER_IO_COMPLETION && !Irp->PendingReturned) {

        if ((Irp->IoStatus.Status == STATUS_REPARSE )  &&
            (Irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {

            //
            // For name junctions we reinstate the address of the appropriate
            // buffer. It is freed in parse.c
            //

            Irp->Tail.Overlay.AuxiliaryBuffer = saveAuxiliaryPointer;
        }

        return;
    }

    //
    // Finally, initialize the IRP as an APC structure and queue the special
    // kernel APC to the target thread.
    //

    thread = Irp->Tail.Overlay.Thread;
    fileObject = Irp->Tail.Overlay.OriginalFileObject;

    if (!Irp->Cancel) {

        KeInitializeApc( &Irp->Tail.Apc,
                         &thread->Tcb,
                         Irp->ApcEnvironment,
                         IopCompleteRequest,
                         IopAbortRequest,
                         (PKNORMAL_ROUTINE) NULL,
                         KernelMode,
                         (PVOID) NULL );

        (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                 fileObject,
                                 (PVOID) saveAuxiliaryPointer,
                                 PriorityBoost );
    } else {

        //
        // This request has been cancelled.  Ensure that access to the thread
        // is synchronized, otherwise it may go away while attempting to get
        // through the remainder of completion for this request.  This happens
        // when the thread times out waiting for the request to be completed
        // once it has been cancelled.
        //
        // Note that it is safe to capture the thread pointer above, w/o having
        // the lock because the cancel flag was not set at that point, and
        // the code that disassociates IRPs must set the flag before looking to
        // see whether or not the packet has been completed, and this packet
        // will appear to be completed because it no longer belongs to a driver.
        //

        irql = KeAcquireQueuedSpinLock( LockQueueIoCompletionLock );

        thread = Irp->Tail.Overlay.Thread;

        if (thread) {

            KeInitializeApc( &Irp->Tail.Apc,
                             &thread->Tcb,
                             Irp->ApcEnvironment,
                             IopCompleteRequest,
                             IopAbortRequest,
                             (PKNORMAL_ROUTINE) NULL,
                             KernelMode,
                             (PVOID) NULL );

            (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                     fileObject,
                                     (PVOID) saveAuxiliaryPointer,
                                     PriorityBoost );

            KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, irql );

        } else {

            //
            // This request has been aborted from completing in the caller's
            // thread.  This can only occur if the packet was cancelled, and
            // the driver did not complete the request, so it was timed out.
            // Attempt to drop things on the floor, since the originating thread
            // has probably exited at this point.
            //

            KeReleaseQueuedSpinLock( LockQueueIoCompletionLock, irql );

            ASSERT( Irp->Cancel );

            //
            // Drop the IRP on the floor.
            //

            IopDropIrp( Irp, fileObject );

        }
    }
}

NTSTATUS
IoConnectInterrupt(
    OUT PKINTERRUPT *InterruptObject,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN KAFFINITY ProcessorEnableMask,
    IN BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This routine allocates, initializes, and connects interrupt objects for
    all of the processors specified in the processor enable mask.

Arguments:

    InterruptObject - Address of a variable to receive a pointer to the first
        interrupt object allocated and initialized.

    ServiceRoutine - Address of the interrupt service routine (ISR) that should
        be executed when the interrupt occurs.

    ServiceContext - Supplies a pointer to the context information required
        by the ISR.

    SpinLock - Supplies a pointer to a spin lock to be used when synchronizing
        with the ISR.

    Vector - Supplies the vector upon which the interrupt occurs.

    Irql - Supplies the IRQL upon which the interrupt occurs.

    SynchronizeIrql - The request priority that the interrupt should be
        synchronized with.

    InterruptMode - Specifies the interrupt mode of the device.

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorEnableMask - Specifies a bit-vector for each processor on which
        the interrupt is to be connected.  A value of one in the bit position
        corresponding to the processor number indicates that the interrupt
        should be allowed on that processor.  At least one bit must be set.

    FloatingSave - A BOOLEAN that specifies whether or not the machine's
        floating point state should be saved before invoking the ISR.

Return Value:

    The function value is the final function status.  The three status values
    that this routine can itself return are:

        STATUS_SUCCESS - Everything worked successfully.
        STATUS_INVALID_PARAMETER - No processors were specified.
        STATUS_INSUFFICIENT_RESOURCES - There was not enough nonpaged pool.

--*/

{
    CCHAR count;
    BOOLEAN builtinUsed;
    PKINTERRUPT interruptObject;
    KAFFINITY processorMask;
    NTSTATUS status;
    PIO_INTERRUPT_STRUCTURE interruptStructure;
    PKSPIN_LOCK spinLock;
#ifdef  INTR_BINDING
    ULONG AssignedProcessor;
#endif  // INTR_BINDING

    PAGED_CODE();

    //
    // Initialize the return pointer and assume success.
    //

    *InterruptObject = (PKINTERRUPT) NULL;
    status = STATUS_SUCCESS;

    //
    // Determine how much memory is to be allocated based on how many
    // processors this system may have and how many bits are set in the
    // processor enable mask.
    //

    processorMask = ProcessorEnableMask & KeActiveProcessors;
    count = 0;

    while (processorMask) {
        if (processorMask & 1) {
            count++;
        }
        processorMask >>= 1;
    }

    //
    // If any interrupt objects are to be allocated and initialized, allocate
    // the memory now.
    //

    if (count) {

        interruptStructure = ExAllocatePoolWithTag( NonPagedPool,
                                                    ((count - 1) * sizeof( KINTERRUPT )) +
                                                    sizeof( IO_INTERRUPT_STRUCTURE ),
                                                    'nioI' );
        if (interruptStructure == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If the caller specified a spin lock to be used for the interrupt object,
    // use it.  Otherwise, provide one by using the one in the structure that
    // was just allocated.
    //

    if (ARGUMENT_PRESENT( SpinLock )) {
        spinLock = SpinLock;
    } else {
        spinLock = &interruptStructure->SpinLock;
    }

    //
    // Initialize and connect the
    // interrupt objects to the appropriate processors.
    //

    //
    // Return the address of the first interrupt object in case an
    // interrupt is pending for the device when it is initially connected
    // and the driver must synchronize its execution with the ISR.
    //

    *InterruptObject = &interruptStructure->InterruptObject;

    //
    // Begin by getting a pointer to the start of the memory to be used
    // for interrupt objects other than the builtin object.
    //

    interruptObject = (PKINTERRUPT) (interruptStructure + 1);
    builtinUsed = FALSE;
    processorMask = ProcessorEnableMask & KeActiveProcessors;

    //
    // Now zero the interrupt structure itself so that if something goes
    // wrong it can be backed out.
    //

    RtlZeroMemory( interruptStructure, sizeof( IO_INTERRUPT_STRUCTURE ) );

    //
    // For each entry in the processor enable mask that is set, connect
    // and initialize an interrupt object.  The first bit that is set
    // uses the builtin interrupt object, and all others use the pointers
    // that follow it.
    //

    for (count = 0; processorMask; count++, processorMask >>= 1) {

        if (processorMask & 1) {
            KeInitializeInterrupt( builtinUsed ?
                                   interruptObject :
                                   &interruptStructure->InterruptObject,
                                   ServiceRoutine,
                                   ServiceContext,
                                   spinLock,
                                   Vector,
                                   Irql,
                                   SynchronizeIrql,
                                   InterruptMode,
                                   ShareVector,
                                   count,
                                   FloatingSave );

            if (!KeConnectInterrupt( builtinUsed ?
                                     interruptObject :
                                     &interruptStructure->InterruptObject )) {

                //
                // An error occurred while attempting to connect the
                // interrupt.  This means that the driver either specified
                // the wrong type of interrupt mode, or attempted to connect
                // to some processor that didn't exist, or whatever.  In
                // any case, the problem turns out to be an invalid
                // parameter was specified.  Simply back everything out
                // and return an error status.
                //
                // Note that if the builtin entry was used, then the entire
                // structure needs to be walked as there are entries that
                // were successfully connected.  Otherwise, the first
                // attempt to connect failed, so simply free everything
                // in-line.
                //

                if (builtinUsed) {
                    IoDisconnectInterrupt( &interruptStructure->InterruptObject );
                } else {
                    ExFreePool( interruptStructure );
                }
                status = STATUS_INVALID_PARAMETER;
                break;
            }


            //
            // If the builtin entry has been used, then the interrupt
            // object just connected was one of the pointers, so fill
            // it in with the address of the memory actually used.
            //

            if (builtinUsed) {
                interruptStructure->InterruptArray[count] = interruptObject++;

            } else {

                //
                // Otherwise, the builtin entry was used, so indicate
                // that it is no longer valid to use and start using
                // the pointers instead.
                //

                builtinUsed = TRUE;
            }
        }
    }

    //
    // Finally, reset the address of the interrupt object if the function
    // failed and return the final status of the operation.
    //

    if (!NT_SUCCESS( status )) {
        *InterruptObject = (PKINTERRUPT) NULL;
    }

    return status;
}

PCONTROLLER_OBJECT
IoCreateController(
    IN ULONG Size
    )

/*++

Routine Description:

    This routine creates a controller object that can be used to synchronize
    access to a physical device controller from two or more devices.

Arguments:

    Size - Size of the adapter extension in bytes.

Return Value:

    A pointer to the controller object that was created or a NULL pointer.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PCONTROLLER_OBJECT controllerObject;
    HANDLE handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the object attributes structure in preparation for creating
    // the controller object.
    //

    InitializeObjectAttributes( &objectAttributes,
                                (PUNICODE_STRING) NULL,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the controller object itself.
    //

    status = ObCreateObject( KernelMode,
                             IoControllerObjectType,
                             &objectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) sizeof( CONTROLLER_OBJECT ) + Size,
                             0,
                             0,
                             (PVOID *) &controllerObject );
    if (NT_SUCCESS( status )) {

        //
        // Insert the controller object into the table.
        //

        status = ObInsertObject( controllerObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 1,
                                 (PVOID *) &controllerObject,
                                 &handle );

        //
        // If the insert operation fails, set return value to NULL.
        //

        if (!NT_SUCCESS( status )) {
            controllerObject = (PCONTROLLER_OBJECT) NULL;
        } else {

            //
            // The insert completed successfully.  Close the handle so that if
            // the driver is unloaded, the controller object can go away.
            //

            (VOID) ObCloseHandle( handle, KernelMode );

            //
            // Zero the memory for the controller object.
            //

            RtlZeroMemory( controllerObject, sizeof( CONTROLLER_OBJECT ) + Size );

            //
            // Set the type and size of this controller object.
            //

            controllerObject->Type = IO_TYPE_CONTROLLER;
            controllerObject->Size = (USHORT) (sizeof( CONTROLLER_OBJECT ) + Size);
            controllerObject->ControllerExtension = (PVOID) (controllerObject + 1);

            //
            // Finally, initialize the controller's device queue.
            //

            KeInitializeDeviceQueue( &controllerObject->DeviceWaitQueue );
        }
    } else {
        controllerObject = (PCONTROLLER_OBJECT) NULL;
    }

    return controllerObject;
}

VOID
IopInsertRemoveDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Insert
    )

{
    KIRQL irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    if (Insert) {
        DeviceObject->NextDevice = DriverObject->DeviceObject;
        DriverObject->DeviceObject = DeviceObject;
        }
    else {
        PDEVICE_OBJECT *prevPoint;

        prevPoint = &DeviceObject->DriverObject->DeviceObject;
        while (*prevPoint != DeviceObject) {
            prevPoint = &(*prevPoint)->NextDevice;
        }
        *prevPoint = DeviceObject->NextDevice;
    }
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
}

NTSTATUS
IopCreateVpb (
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PVPB Vpb;

    Vpb = ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof( VPB ),
                ' bpV'
                );

    if (!Vpb) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory (Vpb, sizeof(VPB));
    Vpb->Type = IO_TYPE_VPB;
    Vpb->Size = sizeof( VPB );
    Vpb->RealDevice = DeviceObject;
    DeviceObject->Vpb = Vpb;

    return STATUS_SUCCESS;
}

NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN PUNICODE_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine creates a device object and links it into the I/O database.

Arguments:

    DriverObject - A pointer to the driver object for this device.

    DeviceExtensionSize - Size, in bytes, of extension to device object;
        i.e., the size of the driver-specific data for this device object.

    DeviceName - Optional name that should be associated with this device.
        If the DeviceCharacteristics has the FILE_AUTOGENERATED_DEVICE_NAME
        flag set, this parameter is ignored.

    DeviceType - The type of device that the device object should represent.

    DeviceCharacteristics - The characteristics for the device.

    Exclusive - Indicates that the device object should be created with using
        the exclusive object attribute.

        NOTE: This flag should not be used for WDM drivers.  Since only the
        PDO is named, it is the only device object in a devnode attachment
        stack that is openable.  However, since this device object is created
        by the underlying bus driver (which has no knowledge about what type
        of device this is), there is no way to know whether this flag should
        be set.  Therefore, this parameter should always be FALSE for WDM
        drivers.  Drivers attached to the PDO (e.g., the function driver) must
        enforce any exclusivity rules.

    DeviceObject - Pointer to the device object pointer we will return.

Return Value:

    The function value is the final status of the operation.


--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PDEVICE_OBJECT deviceObject;
    PDEVOBJ_EXTENSION deviceObjectExt;
    HANDLE handle;
    BOOLEAN deviceHasName = FALSE;
    UCHAR localSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR securityDescriptor = NULL;
    PACL acl;
    ULONG RoundedSize;
    NTSTATUS status;
    USHORT sectorSize = 0;
    LONG nextUniqueDeviceObjectNumber;
    UNICODE_STRING autoGeneratedDeviceName;
    BOOLEAN retryWithNewName = FALSE;
    WCHAR deviceNameBuffer[17];             // "\Device\xxxxxxxx"

    PAGED_CODE();

    acl = NULL;

    //
    // Enclose the creation of the device object in a do/while, in the rare
    // event where we have to retry because some other driver is using our
    // naming scheme for auto-generated device object names.
    //

    do {

        if (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME) {

            //
            // The caller has requested that we automatically generate a device
            // object name.  Retrieve the next available number to use for this
            // purpose, and create a name of the form "\Device\<n>", where <n>
            // is the (8 hexadecimal digit) character representation of the unique
            // number we retrieve.
            //

            nextUniqueDeviceObjectNumber = InterlockedIncrement( &IopUniqueDeviceObjectNumber );
            swprintf( deviceNameBuffer, L"\\Device\\%08lx", nextUniqueDeviceObjectNumber );

            if (retryWithNewName) {

                //
                // We've already done this once (hence, the unicode device name string
                // is all set up, as is all the security information).  Thus, we can
                // skip down to where we re-attempt the creation of the device object
                // using our new name.
                //

                retryWithNewName = FALSE;
                goto attemptDeviceObjectCreation;

            } else {

                //
                // Set the DeviceName parameter to point to our unicode string, just as
                // if the caller had specified it (note, we explicitly ignore anything
                // the caller passes us for device name if the FILE_AUTOGENERATED_DEVICE_NAME
                // characteristic is specified.
                //

                RtlInitUnicodeString( &autoGeneratedDeviceName, deviceNameBuffer );
                DeviceName = &autoGeneratedDeviceName;
            }
        }

        //
        // Remember whether or not this device was created with a name so that
        // it can be deallocated later.
        //

        deviceHasName = (BOOLEAN) (ARGUMENT_PRESENT( DeviceName ) ? TRUE : FALSE);


        //
        // Determine whether or not this device needs to have a security descriptor
        // placed on it that allows read/write access, or whether the system default
        // should be used.  Disks, virtual disks, and file systems simply use the
        // system default descriptor.  All others allow read/write access.
        //
        // NOTE: This routine assumes that it is in the system's security context.
        //       In particular, it assumes that the Default DACL is the system's
        //       Default DACL.  If this assumption changes in future releases,
        //       then use of the Default DACL below should be reviewed for
        //       appropriateness.
        //

        //
        // If the device is a pnp device then wait until it registers a device
        // class before doing the default setup.
        //

        securityDescriptor = IopCreateDefaultDeviceSecurityDescriptor(
                                DeviceType,
                                DeviceCharacteristics,
                                deviceHasName,
                                localSecurityDescriptor,
                                &acl,
                                NULL
                                );

        switch ( DeviceType ) {

        case FILE_DEVICE_DISK_FILE_SYSTEM:

            sectorSize = 512;
            break;

        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:

            sectorSize = 2048;
            break;

        case FILE_DEVICE_DISK:
        case FILE_DEVICE_VIRTUAL_DISK:

            sectorSize = 512;
            break;
        }

attemptDeviceObjectCreation:
        //
        // Initialize the object attributes structure in preparation for creating
        // device object.  Note that the device may be created as an exclusive
        // device so that only one open can be done to it at a time.  This saves
        // single user devices from having drivers that implement special code to
        // make sure that only one connection is ever valid at any given time.
        //

        InitializeObjectAttributes( &objectAttributes,
                                    DeviceName,
                                    OBJ_KERNEL_HANDLE,
                                    (HANDLE) NULL,
                                    securityDescriptor );



        if (Exclusive) {
            objectAttributes.Attributes |= OBJ_EXCLUSIVE;
        } else {
            objectAttributes.Attributes |= 0;
        }

        if (deviceHasName) {
            objectAttributes.Attributes |= OBJ_PERMANENT;
        }

        //
        // Create the device object itself.
        //

        RoundedSize = (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize)
                       % sizeof (LONGLONG);
        if (RoundedSize) {
            RoundedSize = sizeof (LONGLONG) - RoundedSize;
        }

        RoundedSize += DeviceExtensionSize;

        status = ObCreateObject( KernelMode,
                                 IoDeviceObjectType,
                                 &objectAttributes,
                                 KernelMode,
                                 (PVOID) NULL,
                                 (ULONG) sizeof( DEVICE_OBJECT ) + sizeof ( DEVOBJ_EXTENSION ) +
                                         RoundedSize,
                                 0,
                                 0,
                                 (PVOID *) &deviceObject );

        if ((status == STATUS_OBJECT_NAME_COLLISION) &&
            (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME)) {

            //
            // Some other driver is using our naming scheme, and we've picked a
            // device name already in use.  Try again, with a new number.
            //

            retryWithNewName = TRUE;
        }

    } while (retryWithNewName);

    if (!NT_SUCCESS( status )) {

        //
        // Creating the device object was not successful.  Clean everything
        // up and indicate that the object was not created.
        //

        deviceObject = (PDEVICE_OBJECT) NULL;

    } else {

        //
        // The device was successfully created.  Initialize the object so
        // that it can be inserted into the object table.  Begin by zeroing
        // the memory for the device object.
        //

        RtlZeroMemory( deviceObject,
                       sizeof( DEVICE_OBJECT ) + sizeof ( DEVOBJ_EXTENSION ) +
                       RoundedSize );

        //
        // Fill in deviceObject & deviceObjectExtension cross pointers
        //

        deviceObjectExt = (PDEVOBJ_EXTENSION)  (((PCHAR) deviceObject) +
                            sizeof (DEVICE_OBJECT) + RoundedSize);

        deviceObjectExt->DeviceObject = deviceObject;
        deviceObject->DeviceObjectExtension = deviceObjectExt;

        //
        // Initialize deviceObjectExt
        // Note: the size of a Device Object Extension is initialized specifically
        // to ZERO so no driver will depend on it.
        //

        deviceObjectExt->Type = IO_TYPE_DEVICE_OBJECT_EXTENSION;
        deviceObjectExt->Size = 0;

        PoInitializeDeviceObject(deviceObjectExt);

        //
        // Set the type and size of this device object.
        //

        deviceObject->Type = IO_TYPE_DEVICE;
        deviceObject->Size = (USHORT) (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize);

        //
        // Set the device type field in the object so that later code can
        // check the type.  Likewise, set the device characteristics.
        //

        deviceObject->DeviceType = DeviceType;
        deviceObject->Characteristics = DeviceCharacteristics;

        //
        // If this device is either a tape or a disk, allocate a Volume
        // Parameter Block (VPB) which indicates that the volume has
        // never been mounted, and set the device object's VPB pointer to
        // it.
        //

        if ((DeviceType == FILE_DEVICE_DISK) ||
            (DeviceType == FILE_DEVICE_TAPE) ||
            (DeviceType == FILE_DEVICE_CD_ROM) ||
            (DeviceType == FILE_DEVICE_VIRTUAL_DISK)) {

            status = IopCreateVpb (deviceObject);

            if (!NT_SUCCESS(status)) {

                ObDereferenceObject(deviceObject);

                if (acl != NULL) {
                    ExFreePool( acl );
                }

                *DeviceObject = (PDEVICE_OBJECT)NULL;
                return status;
            }

            KeInitializeEvent( &deviceObject->DeviceLock,
                               SynchronizationEvent,
                               TRUE );
        }

        //
        // Initialize the remainder of the device object.
        //
        deviceObject->AlignmentRequirement = HalGetDmaAlignmentRequirement() - 1;
        deviceObject->SectorSize = sectorSize;
        deviceObject->Flags = DO_DEVICE_INITIALIZING;

        if (Exclusive) {
            deviceObject->Flags |= DO_EXCLUSIVE;
        }
        if (deviceHasName) {
            deviceObject->Flags |= DO_DEVICE_HAS_NAME;
        }

        if(DeviceExtensionSize) {
            deviceObject->DeviceExtension = deviceObject + 1;
        } else {
            deviceObject->DeviceExtension = NULL;
        }

        deviceObject->StackSize = 1;
        switch ( DeviceType ) {

        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
        case FILE_DEVICE_DISK_FILE_SYSTEM:
        case FILE_DEVICE_FILE_SYSTEM:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
        case FILE_DEVICE_TAPE_FILE_SYSTEM:

            //
            // This device represents a file system of some sort.  Simply
            // initialize the queue list head in the device object.
            //

            InitializeListHead( &deviceObject->Queue.ListEntry );
            break;

        default:

            //
            // This is a real device of some sort.  Allocate a spin lock
            // and initialize the device queue object in the device object.
            //

            KeInitializeDeviceQueue( &deviceObject->DeviceQueue );
            break;
        }

        //
        // Insert the device object into the table.
        //

        status = ObInsertObject( deviceObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 1,
                                 (PVOID *) &deviceObject,
                                 &handle );

        if (NT_SUCCESS( status )) {

            //
            // Reference the driver object.   When the device object goes
            // away the reference will be removed.  This prevents the
            // driver object and driver image from going away while the
            // device object is in the pending delete state.
            //

            ObReferenceObject( DriverObject );

            ASSERT((DriverObject->Flags & DRVO_UNLOAD_INVOKED) == 0);

            //
            // The insert completed successfully.  Link the device object
            // and driver objects together.  Close the handle so that if
            // the driver is unloaded, the device object can go away.
            //

            deviceObject->DriverObject = DriverObject;

            IopInsertRemoveDevice( DriverObject, deviceObject, TRUE );
            if (deviceObject->Vpb) {
                PoVolumeDevice(deviceObject);
            }

            (VOID) ObCloseHandle( handle, KernelMode );

        } else {

            //
            // The insert operation failed.  Fortunately it dropped the
            // reference count on the device - since that was the last one
            // all the cleanup should be done for us.
            //

            //
            // indicate that no device object was created.
            //

            deviceObject = (PDEVICE_OBJECT) NULL;
        }
    }

    //
    // Free the DACL if we allocated it...
    //

    if (acl != NULL) {
        ExFreePool( acl );
    }

    *DeviceObject = deviceObject;
    return status;
}

NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options
    )
/*++

Routine Description:

    This is the common routine for both NtCreateFile and NtOpenFile to allow
    a user to create or open a file.  This procedure is also used internally
    by kernel mode components, such as the network server, to perform the
    same type of operation, but allows kernel mode code to force checking
    arguments and access to the file, rather than bypassing these checks
    because the code is running in kernel mode.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open
        file.

    DesiredAccess - Supplies the types of access that the caller would like
        to the file.

    ObjectAttributes - Supplies the attributes to be used for the file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.
        This parameter only has an affect if the file is created.  Further,
        if not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    Disposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    EaBuffer - Optionally specifies a set of EAs to be applied to the file
        if it is created.

    EaLength - Supplies the length of the EaBuffer.

    CreateFileType - The type of file to create.

    ExtraCreateParameters - Optionally specifies a pointer to extra create
        parameters.  The format of the parameters depends on the value of
        CreateFileType.

    Options - Specifies the options that are to be used during generation
        of the create IRP.

Return Value:

    The function value is the final status of the create/open operation.

Warning:

    If a pointer to ExtraCreateParameters is passed the data must be
    readable from kernel mode.


--*/
{

#define IOP_CREATE_FILE_TIMEOUT 1000

    NTSTATUS status = STATUS_SUCCESS;  // compiling with W4 incorrectly reports an error at the break
                                       // instruction inside the loop
    LONG CapturedSequence;
    LONG SleepInterval = 0;

    //
    // Simply invoke the common I/O file creation routine to perform the work.
    //

    PAGED_CODE();

    do {

        //
        //  Capture the sequence
        //

        CapturedSequence = ExHotpSyncRenameSequence;

        //
        //  If another thread is in the process of atomic file
        //  rename, we need to retry opening the file in case of failures.
        //  If a high priority thread enters this code while a
        //  another thread is in the middle of doing a double-rename operation,
        //  we need to back off a bit this thread and sleep until others
        //  threads involved in hotpatching finish the operation.
        //
        //  Note: SleepInterval starts from 0, and it will be
        //  incremented after the test. So the thread will not sleep first
        //  time calling IoCreateFile
        //

        if ( (CapturedSequence & 1) && ( SleepInterval++ ) ) {

            LARGE_INTEGER interval;

            //
            //  We are during an atomic rename operation. Check if this
            //  happens in the context of this thread. Do not
            //  attempt to retry if yes. 
            //  This handles cases where AV drivers open files synchronous
            //  as effect of a file rename.
            //
            
            if ( ExSyncRenameOwner == KeGetCurrentThread() ) {

                //
                //  Note that this code path is not taken for the first pass
                //  through this do / while loop, so the correct status will be initialized
                //  if this condition is true
                //

                break;
            }

            interval.QuadPart = - (LONGLONG)SleepInterval * 10 * 1000;

            if (SleepInterval > IOP_CREATE_FILE_TIMEOUT) {

                //
                //  We still do not make any progress. Limit
                //  the timeout next sleep to something reasonable
                //  and assert a possible deadlock in checked builds.
                //

                SleepInterval = IOP_CREATE_FILE_TIMEOUT;
                ASSERT( FALSE );
            }

            KeDelayExecutionThread( KernelMode, FALSE, &interval );
            CapturedSequence = ExHotpSyncRenameSequence;
        }

        status =  IopCreateFile( FileHandle,
                                 DesiredAccess,
                                 ObjectAttributes,
                                 IoStatusBlock,
                                 AllocationSize,
                                 FileAttributes,
                                 ShareAccess,
                                 Disposition,
                                 CreateOptions,
                                 EaBuffer,
                                 EaLength,
                                 CreateFileType,
                                 ExtraCreateParameters,
                                 Options,
                                 0,
                                 NULL
                                 );

    } while ( (!NT_SUCCESS(status))
                 &&
              ((CapturedSequence & 1) || (CapturedSequence != ExHotpSyncRenameSequence)));

    return status;
}

NTSTATUS
IoCreateFileSpecifyDeviceObjectHint(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN PVOID DeviceObject
    )
{

    ULONG   internalFlags = IOP_CREATE_DEVICE_OBJECT_EXTENSION;

    if (DeviceObject != NULL) {
        internalFlags |= IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT;
    }

    if (Options & IO_IGNORE_SHARE_ACCESS_CHECK) {
        internalFlags |= IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK;
    }

    return IopCreateFile(
            FileHandle,
            DesiredAccess,
            ObjectAttributes,
            IoStatusBlock,
            AllocationSize,
            FileAttributes,
            ShareAccess,
            Disposition,
            CreateOptions,
            EaBuffer,
            EaLength,
            CreateFileType,
            ExtraCreateParameters,
            Options|IO_NO_PARAMETER_CHECKING,
            internalFlags,
            DeviceObject
            );
}

NTSTATUS
IopCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength,
    IN CREATE_FILE_TYPE CreateFileType,
    IN PVOID ExtraCreateParameters OPTIONAL,
    IN ULONG Options,
    IN ULONG InternalFlags,
    IN PVOID DeviceObject
    )

/*++

Routine Description:

    This is the common routine for both NtCreateFile and NtOpenFile to allow
    a user to create or open a file.  This procedure is also used internally
    by kernel mode components, such as the network server, to perform the
    same type of operation, but allows kernel mode code to force checking
    arguments and access to the file, rather than bypassing these checks
    because the code is running in kernel mode.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open
        file.

    DesiredAccess - Supplies the types of access that the caller would like
        to the file.

    ObjectAttributes - Supplies the attributes to be used for the file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.
        This parameter only has an affect if the file is created.  Further,
        if not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    Disposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    EaBuffer - Optionally specifies a set of EAs to be applied to the file
        if it is created.

    EaLength - Supplies the length of the EaBuffer.

    CreateFileType - The type of file to create.

    ExtraCreateParameters - Optionally specifies a pointer to extra create
        parameters.  The format of the parameters depends on the value of
        CreateFileType.

    Options - Specifies the options that are to be used during generation
        of the create IRP.

    DeviceObject - Specifies which device object to use when issuing the create IRP.

Return Value:

    The function value is the final status of the create/open operation.

Warning:

    If a pointer to ExtraCreateParameters is passed the data must be
    readable from kernel mode.


--*/

{
    KPROCESSOR_MODE requestorMode;
    NTSTATUS status;
    HANDLE handle;
    POPEN_PACKET openPacket;
    BOOLEAN SuccessfulIoParse;
    LARGE_INTEGER initialAllocationSize;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    requestorMode = KeGetPreviousMode();

    if (Options & IO_NO_PARAMETER_CHECKING) {
        requestorMode = KernelMode;
    }

    openPacket = IopAllocateOpenPacket();
    if (openPacket == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (requestorMode != KernelMode || Options & IO_CHECK_CREATE_PARAMETERS) {

        //
        // Check for any invalid parameters.
        //

        if (

            //
            // Check that no invalid file attributes flags were specified.
            //

//          (FileAttributes & ~FILE_ATTRIBUTE_VALID_SET_FLAGS)
            (FileAttributes & ~FILE_ATTRIBUTE_VALID_FLAGS)

            ||

            //
            // Check that no invalid share access flags were specified.
            //

            (ShareAccess & ~FILE_SHARE_VALID_FLAGS)

            ||

            //
            // Ensure that the disposition value is in range.
            //

            (Disposition > FILE_MAXIMUM_DISPOSITION)

            ||

            //
            // Check that no invalid create options were specified.
            //

            (CreateOptions & ~FILE_VALID_OPTION_FLAGS)

            ||

            //
            // If the caller specified synchronous I/O, then ensure that
            // (s)he also asked for synchronize desired access to the
            // file.
            //

            (CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT) &&
            (!(DesiredAccess & SYNCHRONIZE)))

            ||

            //
            // Also, if the caller specified that the file is to be deleted
            // on close, then ensure that delete is specified as one of the
            // desired accesses requested.
            //

            (CreateOptions & FILE_DELETE_ON_CLOSE &&
            (!(DesiredAccess & DELETE)))

            ||

            //
            // Likewise, ensure that if one of the synchronous I/O modes
            // is specified that the other one is not specified as well.
            //

            ((CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ==
                              (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT))

            ||

            //
            // If this create or open is for a directory operation, check
            // that all of the other flags, dispositions, and desired
            // access parameters were also specified correctly.
            //
            // These are as follows:
            //
            //     o  No other flags other than the synchronous I/O flags,
            //        write-through, or open by file ID are set.
            //
            //     o  The disposition value is one of create, open, or
            //        open-if.
            //
            //     o  No non-directory accesses have been specified.
            //

            ((CreateOptions & FILE_DIRECTORY_FILE)
             && !(CreateOptions & FILE_NON_DIRECTORY_FILE)
             && ((CreateOptions & ~(FILE_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_ALERT |
                                    FILE_SYNCHRONOUS_IO_NONALERT |
                                    FILE_WRITE_THROUGH |
                                    FILE_COMPLETE_IF_OPLOCKED |
                                    FILE_OPEN_FOR_BACKUP_INTENT |
                                    FILE_DELETE_ON_CLOSE |
                                    FILE_OPEN_FOR_FREE_SPACE_QUERY |
                                    FILE_OPEN_BY_FILE_ID |
                                    FILE_NO_COMPRESSION|
                                    FILE_OPEN_REPARSE_POINT))
                 || ((Disposition != FILE_CREATE)
                     && (Disposition != FILE_OPEN)
                     && (Disposition != FILE_OPEN_IF))
                )
            )

            ||

            //
            //  FILE_COMPLETE_IF_OPLOCK and FILE_RESERVE_OPFILTER are
            //  incompatible options.
            //

            ((CreateOptions & FILE_COMPLETE_IF_OPLOCKED) &&
             (CreateOptions & FILE_RESERVE_OPFILTER))

            ||

            //
            // Fail the create if desired access is zero.
            //
            (IopFailZeroAccessCreate && !DesiredAccess)

            ||

            //
            // Finally, if the no intermediate buffering option was
            // specified, ensure that the caller did not also request
            // append access to the file.
            //

            (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING &&
            (DesiredAccess & FILE_APPEND_DATA)) ) {

            IopFreeOpenPacket(openPacket);
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Check the file type specific creation parameters.
        //

        if (CreateFileType == CreateFileTypeNone) {

            NOTHING;

        } else if (CreateFileType == CreateFileTypeNamedPipe) {

            if (!ARGUMENT_PRESENT( ExtraCreateParameters ) ) {

                IopFreeOpenPacket(openPacket);
                return STATUS_INVALID_PARAMETER;

            } else {

                PNAMED_PIPE_CREATE_PARAMETERS NamedPipeCreateParameters;

                NamedPipeCreateParameters = ExtraCreateParameters;

                //
                // Check the parameters for creating a named pipe to
                // ensure that no invalid parameters were passed.
                //

                if (

                    //
                    // Check the NamedPipeType field to ensure that it
                    // is within range.
                    //

                    (NamedPipeCreateParameters->NamedPipeType >
                        FILE_PIPE_MESSAGE_TYPE)

                    ||

                    //
                    // Check the ReadMode field to ensure that it is
                    // within range.
                    //

                    (NamedPipeCreateParameters->ReadMode >
                        FILE_PIPE_MESSAGE_MODE)

                    ||

                    //
                    // Check the CompletionMode field to ensure that
                    // it is within range.
                    //

                    (NamedPipeCreateParameters->CompletionMode >
                        FILE_PIPE_COMPLETE_OPERATION)

                    ||

                    //
                    // Check the ShareAccess parameter to ensure that
                    // it does not specify shared delete access.  The
                    // Named Pipe File System itself will need to ensure
                    // that at least one of SHARE_READ or SHARE_WRITE
                    // is specified if the first instance of the pipe
                    // is being created.
                    //

                    (ShareAccess & FILE_SHARE_DELETE)

                    ||

                    //
                    // Check the Disposition parameter to ensure that
                    // is does not specify anything other than create,
                    // open, or open if.
                    //

                    (Disposition < FILE_OPEN || Disposition > FILE_OPEN_IF)

                    ||

                    //
                    // Finally, check the CreateOptions parameter to
                    // ensure that it does not contain any invalid
                    // options for named pipes.
                    //

                    (CreateOptions & ~FILE_VALID_PIPE_OPTION_FLAGS)) {
                    IopFreeOpenPacket(openPacket);
                    return STATUS_INVALID_PARAMETER;
                }

            }

        } else if (CreateFileType == CreateFileTypeMailslot) {

            if (!ARGUMENT_PRESENT( ExtraCreateParameters ) ) {

                IopFreeOpenPacket(openPacket);
                return STATUS_INVALID_PARAMETER;

            } else {

                PMAILSLOT_CREATE_PARAMETERS mailslotCreateParameters;

                mailslotCreateParameters = ExtraCreateParameters;

                //
                // Check the parameters for creating a mailslot to ensure
                // that no invalid parameters were passed.
                //

                if (

                    //
                    // Check the ShareAccess parameter to ensure that
                    // it does not specify shared delete access.
                    //

                    (ShareAccess & FILE_SHARE_DELETE)

                    ||

                    //
                    // Check the ShareAccess parameter to ensure that
                    // shared write access is specified.
                    //

                    !(ShareAccess & ~FILE_SHARE_WRITE)

                    ||

                    //
                    // Check the Disposition parameter to ensure that
                    // it specifies that the file is to be created.
                    //

                    (Disposition != FILE_CREATE)

                    ||

                    //
                    // Check the CreateOptions parameter to ensure that
                    // it does not contain any options that are invalid
                    // for mailslots.
                    //

                    (CreateOptions & ~FILE_VALID_MAILSLOT_OPTION_FLAGS)) {
                    IopFreeOpenPacket(openPacket);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
    }

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the
        // arguments and capture them as necessary.  If any failures occur,
        // the condition handler will be invoked to handle them.  It will
        // simply cleanup and return an access violation status code back
        // to the system service dispatcher.
        //

        openPacket->EaBuffer = (PFILE_FULL_EA_INFORMATION) NULL;

        try {

            //
            // The FileHandle parameter must be writeable by the caller.
            // Probe it for a write operation.
            //

            ProbeAndWriteHandle( FileHandle, 0L );

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The AllocationSize parameter must be readable by the caller
            // if it is present.  If so, probe and capture it.
            //

            if (ARGUMENT_PRESENT( AllocationSize )) {
                ProbeForReadSmallStructure( AllocationSize,
                              sizeof( LARGE_INTEGER ),
                              sizeof( ULONG ) );
                initialAllocationSize = *AllocationSize;
            } else {
                initialAllocationSize.QuadPart = 0;
            }

            if (initialAllocationSize.QuadPart < 0) {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to access the
            // caller's parameters.  Simply return the reason for the
            // exception as the service status.
            //

            IopFreeOpenPacket(openPacket);
            return GetExceptionCode();
        }

        //
        // Finally, if an EaBuffer was specified, ensure that it is readable
        // from the caller's mode and capture it.
        //

        if (ARGUMENT_PRESENT( EaBuffer ) && EaLength) {

            ULONG errorOffset;

            try {

                ProbeForRead( EaBuffer, EaLength, sizeof( ULONG ) );
                openPacket->EaBuffer = ExAllocatePoolWithQuotaTag( NonPagedPool,
                                                                  EaLength,
                                                                  'aEoI' );
                openPacket->EaLength = EaLength;
                RtlCopyMemory( openPacket->EaBuffer, EaBuffer, EaLength );

                //
                // Walk the buffer and ensure that its format is valid.  Note
                // that has been probed.
                //

                status = IoCheckEaBufferValidity( openPacket->EaBuffer,
                                                  EaLength,
                                                  &errorOffset );

                if (!NT_SUCCESS( status )) {
                    IoStatusBlock->Status = status;
                    IoStatusBlock->Information = errorOffset;
                    ExRaiseStatus( status );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while attempting to access the
                // caller's parameters.  Check to see whether or not an EA
                // buffer was allocated and deallocate if so.
                //

                if (openPacket->EaBuffer != NULL) {
                    ExFreePool( openPacket->EaBuffer );
                }

                IopFreeOpenPacket(openPacket);
                return GetExceptionCode();

            }

        } else {

            //
            // No EAs were specified.
            //

            openPacket->EaBuffer = (PVOID) NULL;
            openPacket->EaLength = 0L;
        }

    } else {

        //
        // The caller's mode is kernel.  Copy the input parameters to their
        // expected locations for later use.  Also, put move attach device
        // flag where it belongs.
        //

        if (CreateOptions & IO_ATTACH_DEVICE_API) {
            Options |= IO_ATTACH_DEVICE;
            CreateOptions &= ~IO_ATTACH_DEVICE_API;

        }

        if (ARGUMENT_PRESENT( AllocationSize )) {
            initialAllocationSize = *AllocationSize;
        } else {
            initialAllocationSize.QuadPart = 0;
        }

        if (ARGUMENT_PRESENT( EaBuffer ) && EaLength) {

            ULONG errorOffset;

            openPacket->EaBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                                         EaLength,
                                                         'aEoI' );
            if (!openPacket->EaBuffer) {
                IopFreeOpenPacket(openPacket);
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            openPacket->EaLength = EaLength;
            RtlCopyMemory( openPacket->EaBuffer, EaBuffer, EaLength );

            //
            // Walk the buffer and ensure that its format is valid.  Note
            // that has been probed.
            //

            status = IoCheckEaBufferValidity( openPacket->EaBuffer,
                                              EaLength,
                                              &errorOffset );

            if (!NT_SUCCESS( status )) {
                ExFreePool(openPacket->EaBuffer);
                IoStatusBlock->Status = status;
                IoStatusBlock->Information = errorOffset;
                IopFreeOpenPacket(openPacket);
                return status;
            }

        } else {
            openPacket->EaBuffer = (PVOID) NULL;
            openPacket->EaLength = 0L;
        }
    }

    //
    // Now fill in an Open Packet (OP) to be used in calling the device object
    // parse routine.  This packet will allow information to be passed between
    // this routine and the parse routine so that a common context may be kept.
    // For most services this would be done with an I/O Request Packet (IRP),
    // but this cannot be done here because the number of stack entries which
    // need to be allocated in the IRP is not yet known.
    //

    openPacket->Type = IO_TYPE_OPEN_PACKET;
    openPacket->Size = sizeof( OPEN_PACKET );
    openPacket->ParseCheck = 0L;
    openPacket->AllocationSize = initialAllocationSize;
    openPacket->CreateOptions = CreateOptions;
    openPacket->FileAttributes = (USHORT) FileAttributes;
    openPacket->ShareAccess = (USHORT) ShareAccess;
    openPacket->Disposition = Disposition;
    openPacket->Override = FALSE;
    openPacket->QueryOnly = FALSE;
    openPacket->DeleteOnly = FALSE;
    openPacket->Options = Options;
    openPacket->RelatedFileObject = (PFILE_OBJECT) NULL;
    openPacket->CreateFileType = CreateFileType;
    openPacket->ExtraCreateParameters = ExtraCreateParameters;
    openPacket->TraversedMountPoint = FALSE;
    openPacket->InternalFlags = InternalFlags;
    openPacket->TopDeviceObjectHint = DeviceObject;

    //
    // Assume that the operation is going to be successful.
    //

    openPacket->FinalStatus = STATUS_SUCCESS;

    //
    // Zero the file object field in the OP so the parse routine knows that
    // this is the first time through.  For reparse operations it will continue
    // to use the same file object that it allocated the first time.
    //

    openPacket->FileObject = (PFILE_OBJECT) NULL;

    //
    // Update the open count for this process.
    //

    IopUpdateOtherOperationCount();

    //
    // Attempt to open the file object by name.  This will yield the handle
    // that the user is to use as his handle to the file in all subsequent
    // calls, if it works.
    //
    // This call performs a whole lot of the work for actually getting every-
    // thing set up for the I/O system.  The object manager will take the name
    // of the file and will translate it until it reaches a device object (or
    // it fails).  If the former, then it will invoke the parse routine set up
    // by the I/O system for device objects.  This routine will actually end
    // up creating the file object, allocating an IRP, filling it in, and then
    // invoking the driver's dispatch routine with the packet.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 requestorMode,
                                 NULL,
                                 DesiredAccess,
                                 openPacket,
                                 &handle );

    //
    // If an EA buffer was allocated, deallocate it now before attempting to
    // determine whether or not the operation was successful so that it can be
    // done in one place rather than in two places.
    //

    if (openPacket->EaBuffer) {
        ExFreePool( openPacket->EaBuffer );
    }

    //
    // Check the status of the open.  If it was not successful, cleanup and
    // get out.  Notice that it is also possible, because this code does not
    // explicitly request that a particular type of object (because the Object
    // Manager does not check when a parse routine is present and because the
    // name first refers to a device object and then a file object), a check
    // must be made here to ensure that what was returned was really a file
    // object.  The check is to see whether the device object parse routine
    // believes that it successfully returned a pointer to a file object.  If
    // it does, then OK;  otherwise, something went wrong somewhere.
    //

    SuccessfulIoParse = (BOOLEAN) (openPacket->ParseCheck == OPEN_PACKET_PATTERN);

    if (!NT_SUCCESS( status ) || !SuccessfulIoParse) {

        if (NT_SUCCESS( status )) {

            //
            // The operation was successful as far as the object system is
            // concerned, but the I/O system device parse routine was never
            // successfully completed so this operation has actually completed
            // with an error because of an object mismatch.  Therefore, this is
            // the wrong type of object so dereference whatever was actually
            // referenced by closing the handle that was created for it.
            // We have to do a ZwClose as this handle can be a kernel handle if
            // IoCreateFile was called by a driver.
            //

            ZwClose( handle );
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        //
        // If the final status according to the device parse routine
        // indicates that the operation was not successful, then use that
        // routine's final status because it is more descriptive than the
        // status which was returned by the object manager.
        //

        if (!NT_SUCCESS( openPacket->FinalStatus )) {
            status = openPacket->FinalStatus;

            if (NT_WARNING( status )) {

                try {

                    IoStatusBlock->Status = openPacket->FinalStatus;
                    IoStatusBlock->Information = openPacket->Information;

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    status = GetExceptionCode();

                }

            }

        } else if (openPacket->FileObject != NULL && !SuccessfulIoParse) {

            //
            // Otherwise, one of two things occurred:
            //
            //     1)  The parse routine was invoked at least once and a
            //         reparse was performed but the parse routine did not
            //         actually complete.
            //
            //     2)  The parse routine was successful so everything worked
            //         but the object manager incurred an error after the
            //         parse routine completed.
            //
            // For case #1, there is an outstanding file object that still
            // exists.  This must be cleaned up.
            //
            // For case #2, nothing must be done as the object manager has
            // already dereferenced the file object.  Note that this code is
            // not invoked if the parse routine completed with a successful
            // status return (SuccessfulIoParse is TRUE).
            //

            if (openPacket->FileObject->FileName.Length != 0) {
                ExFreePool( openPacket->FileObject->FileName.Buffer );
            }
            openPacket->FileObject->DeviceObject = (PDEVICE_OBJECT) NULL;
            ObDereferenceObject( openPacket->FileObject );
        }

        //
        // When an NTFS file junction or an NTFS directory junction is traversed
        // OBJ_MAX_REPARSE_ATTEMPTS namy times, the object manager gives up and
        // returns the code STATUS_OBJECT_NAME_NOT_FOUND.
        //
        // This can happen in the following cases:
        //
        //      1) One encounters a legal chain of directory junctions that happen
        //         to be longer than the value of the above constant.
        //
        //      2) One encounters a self-referential file or directory junction that
        //         is, in effect, a tight name cycle.
        //
        //      3) One encounters a name cycle composed of several NTFS junctions.
        //
        // To improve on this return code see if  openPacket->Information  is
        // the trace of an NTFS name junction.
        //

        if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
            (openPacket->Information == IO_REPARSE_TAG_MOUNT_POINT)) {

            status = STATUS_REPARSE_POINT_NOT_RESOLVED;
        }

    } else {

        //
        // At this point, the open/create operation has been successfully
        // completed.  There is a handle to the file object, which has been
        // created, and the file object has been signaled.
        //
        // The remaining work to be done is to complete the operation.  This is
        // performed as follows:
        //
        //    1.  The file object has been signaled, so no work needs to be done
        //        for it.
        //
        //    2.  The file handle is returned to the user.
        //
        //    3.  The I/O status block is written with the final status.
        //

        openPacket->FileObject->Flags |= FO_HANDLE_CREATED;

        ASSERT( openPacket->FileObject->Type == IO_TYPE_FILE );

        try {

            //
            // Return the file handle.
            //

            *FileHandle = handle;

            //
            // Write the I/O status into the caller's buffer.
            //

            IoStatusBlock->Information = openPacket->Information;
            IoStatusBlock->Status = openPacket->FinalStatus;
            status = openPacket->FinalStatus;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            status = GetExceptionCode();

        }

    }

    //
    // If the parse routine successfully created a file object then
    // dereference it here.
    //

    if (SuccessfulIoParse && openPacket->FileObject != NULL) {

        ObDereferenceObject( openPacket->FileObject );
    }

    IopFreeOpenPacket(openPacket);
    return status;
}

PKEVENT
IoCreateNotificationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    This routine creates a named notification event for use in notifying
    different system components or drivers that an event occurred.

Arguments:

    EventName - Supplies the full name of the event.

    EventHandle - Supplies a location to return a handle to the event.

Return Value:

    The function value is a pointer to the created/opened event, or NULL if
    the event could not be created/opened.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE eventHandle;
    PKEVENT eventObject;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes.
    //

    InitializeObjectAttributes( &objectAttributes,
                                EventName,
                                OBJ_OPENIF|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Now create or open the event.
    //

    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            &objectAttributes,
                            NotificationEvent,
                            TRUE );
    if (!NT_SUCCESS( status )) {
        return (PKEVENT) NULL;
    }

    //
    // Reference the object by its handle to get a pointer that can be returned
    // to the caller.
    //

    (VOID) ObReferenceObjectByHandle( eventHandle,
                                      0,
                                      ExEventObjectType,
                                      KernelMode,
                                      (PVOID *) &eventObject,
                                      NULL );
    ObDereferenceObject( eventObject );

    //
    // Return the handle and the pointer to the event.
    //

    *EventHandle = eventHandle;

    return eventObject;
}

PFILE_OBJECT
IoCreateStreamFileObject(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    )
{
    return (IoCreateStreamFileObjectEx(FileObject, DeviceObject, NULL));
}


PFILE_OBJECT
IoCreateStreamFileObjectEx(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    OUT PHANDLE FileHandle OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a new file object that represents an
    alternate data stream for an existing file object.  The input file object
    represents the file object that already exists for a file, and the newly
    created stream file object is used to access other parts of the file
    other than the data.  Some uses of stream file objects are the EAs or
    the SECURITY_DESCRIPTORs on the file.  The stream file object allows
    the file system to cache these parts of the file just as if they were
    an entire to themselves.

    It is also possible to use stream file objects to represent virtual
    volume files.  This allows various parts of the on-disk structure to
    be viewed as a virtual file and therefore be cached using the same logic
    in the file system.  For this case, the device object pointer is used
    to create the file object.

Arguments:

    FileObject - Pointer to the file object to which the new stream file
        is related.  This pointer is optional.

    DeviceObject - Pointer to the device object on which the stream file
        is to be opened.  This pointer is not optional if the FileObject
        pointer is not specified.

    FileHandle - Out parameter for handle if necessary.

Return Value:

    The function value is a pointer to the newly created stream file object.

--*/

{
    PFILE_OBJECT newFileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by getting the device object from either the file object or
    // the device object parameter.
    //

    if (ARGUMENT_PRESENT( FileObject )) {
        DeviceObject = FileObject->DeviceObject;
    }

    //
    // Increment the reference count for the target device object.  Note
    // that no check is made to determine whether or not the device driver
    // is attempting to unload since this is an implicit open of a pseudo-
    // file that is being made, not a real file open request.  In essence,
    // no new file is really being opened.
    //

    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );

    //
    // Initialize the object attributes that will be used to create the file
    // object.
    //

    InitializeObjectAttributes( &objectAttributes,
                                (PUNICODE_STRING) NULL,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the new file object.
    //

    status = ObCreateObject( KernelMode,
                             IoFileObjectType,
                             &objectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) sizeof( FILE_OBJECT ),
                             (ULONG) sizeof( FILE_OBJECT ),
                             0,
                             (PVOID *) &newFileObject );

    if (!NT_SUCCESS( status )) {
        IopDecrementDeviceObjectRef( DeviceObject, FALSE, FALSE );
        ExRaiseStatus( status );
    }

    //
    // Initialize the common fields of the file object.
    //

    RtlZeroMemory( newFileObject, sizeof( FILE_OBJECT ) );
    newFileObject->Type = IO_TYPE_FILE;
    newFileObject->Size = sizeof( FILE_OBJECT );
    newFileObject->DeviceObject = DeviceObject;
    newFileObject->Flags = FO_STREAM_FILE;
    KeInitializeEvent( &newFileObject->Event, SynchronizationEvent, FALSE );

    //
    // Insert the device object into the table.  Note that this is done w/a
    // pointer bias so that the object cannot go away if some random user
    // application closes the handle before this code is finished w/it.
    //

    status = ObInsertObject( newFileObject,
                             NULL,
                             FILE_READ_DATA,
                             1,
                             (PVOID *) &newFileObject,
                             &handle );

    if (!NT_SUCCESS( status )) {
        ExRaiseStatus( status );
    }

    //
    // The insert completed successfully.  Update the bookkeeping so that the
    // fact that there is a handle is reflected.
    //

    newFileObject->Flags |= FO_HANDLE_CREATED;
    ASSERT( newFileObject->Type == IO_TYPE_FILE );

    //
    // Synchronize here with the file system to make sure that
    // volumes don't go away while en route to the FS.
    //

    if (DeviceObject->Vpb) {
        IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                      (PLONG) &DeviceObject->Vpb->ReferenceCount );
    }

    //
    // Finally, close the handle to the file. and clear the forward cluster
    //

    if (FileHandle == NULL) {
        ObCloseHandle( handle , KernelMode);
    } else {
        *FileHandle = handle;

        //
        // Get rid of the reference in ObInsertObject.
        //

        ObDereferenceObject(newFileObject);
    }

    ASSERT( NT_SUCCESS( status ) );

    return newFileObject;
}



PFILE_OBJECT
IoCreateStreamFileObjectLite(
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a new file object that represents an
    alternate data stream for an existing file object.  The input file object
    represents the file object that already exists for a file, and the newly
    created stream file object is used to access other parts of the file
    other than the data.  Some uses of stream file objects are the EAs or
    the SECURITY_DESCRIPTORs on the file.  The stream file object allows
    the file system to cache these parts of the file just as if they were
    an entire to themselves.

    It is also possible to use stream file objects to represent virtual
    volume files.  This allows various parts of the on-disk structure to
    be viewed as a virtual file and therefore be cached using the same logic
    in the file system.  For this case, the device object pointer is used
    to create the file object.

    This call differs from IoCreateStreamFileObject in that it performs no
    handle management and does not result in a call to the file system
    cleanup entry.

Arguments:

    FileObject - Pointer to the file object to which the new stream file
        is related.  This pointer is optional.

    DeviceObject - Pointer to the device object on which the stream file
        is to be opened.  This pointer is not optional if the FileObject
        pointer is not specified.

Return Value:

    The function value is a pointer to the newly created stream file object.

--*/

{
    PFILE_OBJECT newFileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by getting the device object from either the file object or
    // the device object parameter.
    //

    if (ARGUMENT_PRESENT( FileObject )) {
        DeviceObject = FileObject->DeviceObject;
    }

    //
    // if the driver has been marked for an unload or deleted operation, and
    // the reference count goes to zero, then the driver may need to be
    // unloaded or deleted at this point.
    // file that is being made, not a real file open request.  In essence,
    // no new file is really being opened.
    //

    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );

    //
    // Initialize the object attributes that will be used to create the file
    // object.
    //

    InitializeObjectAttributes( &objectAttributes,
                                (PUNICODE_STRING) NULL,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the new file object.
    //

    status = ObCreateObject( KernelMode,
                             IoFileObjectType,
                             &objectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             (ULONG) sizeof( FILE_OBJECT ),
                             (ULONG) sizeof( FILE_OBJECT ),
                             0,
                             (PVOID *) &newFileObject );

    if (!NT_SUCCESS( status )) {
        IopDecrementDeviceObjectRef( DeviceObject, FALSE, FALSE );
        ExRaiseStatus( status );
    }

    //
    // Initialize the common fields of the file object.
    //

    RtlZeroMemory( newFileObject, sizeof( FILE_OBJECT ) );
    newFileObject->Type = IO_TYPE_FILE;
    newFileObject->Size = sizeof( FILE_OBJECT );
    newFileObject->DeviceObject = DeviceObject;
    newFileObject->Flags = FO_STREAM_FILE;
    KeInitializeEvent( &newFileObject->Event, SynchronizationEvent, FALSE );

    //
    //  Clean up from the creation.
    //

    ObFreeObjectCreateInfoBuffer(OBJECT_TO_OBJECT_HEADER(newFileObject)->ObjectCreateInfo);
    OBJECT_TO_OBJECT_HEADER(newFileObject)->ObjectCreateInfo = NULL;

    newFileObject->Flags |= FO_HANDLE_CREATED;
    ASSERT( newFileObject->Type == IO_TYPE_FILE );

    //
    // Synchronize here with the file system to make sure that
    // volumes don't go away while en route to the FS.
    //

    if (DeviceObject->Vpb) {
        IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                      (PLONG) &DeviceObject->Vpb->ReferenceCount );
    }

    return newFileObject;
}


NTSTATUS
IoCreateSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine is invoked to assign a symbolic link name to a device.

Arguments:

    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.

    DeviceName - Supplies the name to which the symbolic link name refers.

Return Value:

    The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                SePublicDefaultUnrestrictedSd );

    //
    // Note that the following assignment can fail (because it is not system
    // initialization time and therefore the \ARCname directory does not
    // exist - if this is really a call to IoAssignArcName), but that is fine.
    //

    status = ZwCreateSymbolicLinkObject( &linkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &objectAttributes,
                                         DeviceName );
    if (NT_SUCCESS( status )) {
        ZwClose( linkHandle );
    }

    return status;
}

PKEVENT
IoCreateSynchronizationEvent(
    IN PUNICODE_STRING EventName,
    OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    This routine creates a named synchronization event for use in serialization
    of access to hardware between two otherwise non-related drivers.  The event
    is created if it does not already exist, otherwise it is simply opened.

Arguments:

    EventName - Supplies the full name of the event.

    EventHandle - Supplies a location to return a handle to the event.

Return Value:

    The function value is a pointer to the created/opened event, or NULL if
    the event could not be created/opened.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE eventHandle;
    PKEVENT eventObject;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes.
    //

    InitializeObjectAttributes( &objectAttributes,
                                EventName,
                                OBJ_OPENIF|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Now create or open the event.
    //

    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            &objectAttributes,
                            SynchronizationEvent,
                            TRUE );
    if (!NT_SUCCESS( status )) {
        return (PKEVENT) NULL;
    }

    //
    // Reference the object by its handle to get a pointer that can be returned
    // to the caller.
    //

    (VOID) ObReferenceObjectByHandle( eventHandle,
                                      0,
                                      ExEventObjectType,
                                      KernelMode,
                                      (PVOID *) &eventObject,
                                      NULL );
    ObDereferenceObject( eventObject );

    //
    // Return the handle and the pointer to the event.
    //

    *EventHandle = eventHandle;

    return eventObject;
}

NTSTATUS
IoCreateUnprotectedSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName,
    IN PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine is invoked to assign an unprotected symbolic link name to
    a device.  That is, a symbolic link that can be dynamically reassigned
    without any special authorization. The security descriptor is inherited
    from the container (like DosDevices) which has the right symbolic link.


Arguments:

    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.

    DeviceName - Supplies the name to which the symbolic link name refers.

Return Value:

    The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();


    //
    // Initialize the object attributes for the symbolic link.
    // We pass a NULL so that the security descriptor is inherited
    // from the parent.
    // Prior to .NET server this routine set a NULL DACL that could be overridden
    // by inheritable ACLs. This was essentially the same as passing a NULL to
    // ObjectAttributes.
    //

    InitializeObjectAttributes( &objectAttributes,
                            SymbolicLinkName,
                            OBJ_PERMANENT | OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                            (HANDLE) NULL,
                            NULL );

    //
    // Note that the following assignment can fail (because it is not system
    // initialization time and therefore the \ARCname directory does not
    // exist - if this is really a call to IoAssignArcName), but that is fine.
    //

    status = ZwCreateSymbolicLinkObject( &linkHandle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &objectAttributes,
                                         DeviceName );
    if (NT_SUCCESS( status )) {
        ZwClose( linkHandle );
    }

    return status;
}

VOID
IoDeleteController(
    IN PCONTROLLER_OBJECT ControllerObject
    )

/*++

Routine Description:

    This routine deletes the specified controller object from the system
    so that it may no longer be referenced from a driver.  It is invoked
    when either the driver is being unloaded from the system, or the driver's
    initialization routine failed to properly initialize the device or a
    fatal driver initialization error was encountered.

Arguments:

    ControllerObject - Pointer to the controller object that is to be
        deleted.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // The controller was created as a temporary object, and all of the
    // handles for the object have already been closed.  At this point,
    // simply dereferencing the object will cause it to be deleted.
    //

    ObDereferenceObject( ControllerObject );
}

VOID
IopRemoveTimerFromTimerList(
    IN PIO_TIMER timer
    )
{
    KIRQL irql;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (irql);
#endif

    ExAcquireFastLock( &IopTimerLock, &irql );
    RemoveEntryList( &timer->TimerList );
    if (timer->TimerFlag) {
        IopTimerCount--;
    }
    ExReleaseFastLock( &IopTimerLock, irql );
}

VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine deletes the specified device object from the system so that
    it may no longer be referenced.  It is invoked when either the device
    driver is being unloaded from the system, or the driver's initialization
    routine failed to properly initialize the device or a fatal driver
    initialization error was encountered, or when the device is being removed
    from the system.

Arguments:

    DeviceObject - Pointer to the device object that is to be deleted.

Return Value:

    None.

--*/

{
    KIRQL irql;

    IOV_DELETE_DEVICE(DeviceObject);

    //
    // Check to see whether or not the device has registered a shutdown
    // handler if necessary, and if so, unregister it.
    //

    if (DeviceObject->Flags & DO_SHUTDOWN_REGISTERED) {
        IoUnregisterShutdownNotification( DeviceObject );
    }

    //
    // Release the pool that was allocated to contain the timer dispatch
    // routine and its associated context if there was one.
    //

    if (DeviceObject->Timer) {
        PIO_TIMER timer;

        timer = DeviceObject->Timer;
        IopRemoveTimerFromTimerList(timer);
        ExFreePool( timer );
    }

    //
    // If this device has a name, then mark the
    // object as temporary so that when it is dereferenced it will be
    // deleted.
    //

    if (DeviceObject->Flags & DO_DEVICE_HAS_NAME) {
        ObMakeTemporaryObject( DeviceObject );
    }

    //
    // PoRunDownDeviceObject will clean up any power management
    // structures attached to the device object.
    //

    PoRunDownDeviceObject(DeviceObject);

    //
    // Mark the device object as deleted.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    DeviceObject->DeviceObjectExtension->ExtensionFlags |= DOE_DELETE_PENDING;

    if (!DeviceObject->ReferenceCount) {
        IopCompleteUnloadOrDelete( DeviceObject, FALSE, irql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    }
}


NTSTATUS
IopDeleteSessionSymLinks(
    IN PUNICODE_STRING LinkName
    )
/*++

Routine Description:

    This routine is called from IoDeleteSymbolic Link. It enumerates all the
    Terminal Server session specific object directories and deletes the specified
    symbolic link from the DosDevices object directory of each sesssion. This
    routine is only called when Terminal Services is enabled.

Arguments:

    SymbolicLinkName - Provides the Unicode name string to be deassigned.

Return Values:

    None.

--*/

#define PREFIX_STRING_LENGTH (sizeof(L"\\DosDevices\\")/sizeof(WCHAR))
{

    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING SymbolicLinkName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    HANDLE linkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN RestartScan;
    ULONG Context = 0;
    ULONG ReturnedLength;
    PWCHAR NameBuf;
    PUCHAR DirInfoBuffer;
    ULONG Size;
    WCHAR Prefix[PREFIX_STRING_LENGTH]; // sizeof L"\\DosDevices\\"



    //
    // Only delete links that start with \DosDevices\
    //

    if (LinkName->Length < (sizeof(L"\\DosDevices\\"))){
        return STATUS_SUCCESS;
    }
    RtlInitUnicodeString( &UnicodeString, L"\\DosDevices\\" );

    wcsncpy(Prefix,LinkName->Buffer, PREFIX_STRING_LENGTH - 1);
    Prefix[PREFIX_STRING_LENGTH - 1] = '\0';
    RtlInitUnicodeString( &SymbolicLinkName, Prefix);

    if (RtlCompareUnicodeString(&UnicodeString, &SymbolicLinkName,TRUE)) {

        return STATUS_SUCCESS;

    }


    //
    // Open the root Sessions Directory.
    //
    RtlInitUnicodeString( &UnicodeString, L"\\Sessions" );

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL
                              );

    Status = ZwOpenDirectoryObject( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (NT_SUCCESS( Status )) {


        //
        // Since SessionId is a ULONG , the prefix (\\Sessions\\<SessionId>\\DosDevices)
        // cannot be more that 128 characters in length
        //
        Size = (LinkName->Length + 128) * sizeof(WCHAR);
        NameBuf = (PWCHAR)ExAllocatePoolWithTag(PagedPool, Size, ' oI');

        if (NameBuf == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        SymbolicLinkName.Buffer = (PWSTR)NameBuf;
        SymbolicLinkName.Length = (USHORT)Size;
        SymbolicLinkName.MaximumLength = (USHORT)Size;


        //
        // 4k should be more than enough to query a directory object entry
        //
        Size = 4096;
        DirInfoBuffer = (PUCHAR)ExAllocatePoolWithTag(PagedPool, Size, ' oI');

        if (DirInfoBuffer == NULL) {
            ExFreePool(NameBuf);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RestartScan = TRUE;
        DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;


        while (TRUE) {

            Status = ZwQueryDirectoryObject( DirectoryHandle,
                                             (PVOID)DirInfo,
                                             Size,
                                             TRUE,
                                             RestartScan,
                                             &Context,
                                             &ReturnedLength
                                           );

            RestartScan = FALSE;

            //
            //  Check the status of the operation.
            //

            if (!NT_SUCCESS( Status )) {
                if (Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                    }

                break;
                }


            //
            // This generates session specific symbolic link path
            // \Sessions\<id>\DosDevices\<LinkName>
            //
            RtlInitUnicodeString( &UnicodeString, L"\\Sessions\\" );
            RtlCopyUnicodeString( &SymbolicLinkName, &UnicodeString );
            RtlAppendUnicodeStringToString( &SymbolicLinkName, &(DirInfo->Name) );
            RtlAppendUnicodeStringToString( &SymbolicLinkName, LinkName );
            //
            // Begin by initializing the object attributes for the symbolic link.
            //

            InitializeObjectAttributes( &Attributes,
                                        &SymbolicLinkName,
                                        OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                        NULL,
                                        NULL );

            //
            // Open the symbolic link itself so that it can be marked temporary and
            // closed.
            //

            Status = ZwOpenSymbolicLinkObject( &linkHandle,
                                               DELETE,
                                               &Attributes );
            if (NT_SUCCESS( Status )) {

                //
                // The symbolic link was successfully opened.  Attempt to make it a
                // temporary object, and then close the handle.  This will cause the
                // object to go away.
                //

                Status = ZwMakeTemporaryObject( linkHandle );
                if (NT_SUCCESS( Status )) {
                    ZwClose( linkHandle );
                }
            }



         }

         ZwClose(DirectoryHandle);
         ExFreePool(NameBuf);
         ExFreePool(DirInfoBuffer);
    }

     return Status;
}


NTSTATUS
IoDeleteSymbolicLink(
    IN PUNICODE_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is invoked to remove a symbolic link from the system.  This
    generally occurs whenever a driver that has assigned a symbolic link needs
    to exit.  It can also be used when a driver no longer needs to redirect
    a name.

Arguments:

    SymbolicLinkName - Provides the Unicode name string to be deassigned.

Return Values:

    None.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Open the symbolic link itself so that it can be marked temporary and
    // closed.
    //

    status = ZwOpenSymbolicLinkObject( &linkHandle,
                                       DELETE,
                                       &objectAttributes );
    if (NT_SUCCESS( status )) {

        //
        // The symbolic link was successfully opened.  Attempt to make it a
        // temporary object, and then close the handle.  This will cause the
        // object to go away.
        //

        status = ZwMakeTemporaryObject( linkHandle );
        if (NT_SUCCESS( status )) {
            ZwClose( linkHandle );
        }

        //
        // When LUID DosDevices are disabled and Terminal Services are
        // enabled, then remove the possible multiple copies of the symbolic
        // link from the DosDevices in the TS sessions
        // When LUID DosDevices are enabled or TS is not enabled, then
        // the symbolic link is not copied and no cleanup is needed.
        //

        if ((ObIsLUIDDeviceMapsEnabled() == 0) &&
            (ExVerifySuite(TerminalServer) == TRUE)) {

            IopDeleteSessionSymLinks( SymbolicLinkName );
        }
    }


    return status;
}

VOID
IoDetachDevice(
    IN OUT PDEVICE_OBJECT TargetDevice
    )

/*++

Routine Description:

    This routine detaches the device object which is currently attached to the
    target device.

Arguments:

    TargetDevice - Pointer to device object to be detached from.

Return Value:

    None.


--*/

{
    KIRQL irql;
    PDEVICE_OBJECT detachingDevice;
    PDEVOBJ_EXTENSION detachingExtension;

    //
    // Detach the device object attached to the target device.  This also
    // includes decrementing the reference count for the device.  Note that
    // if the driver has been marked for an unload operation, and the
    // reference count goes to zero, then the driver may need to be unloaded
    // at this point.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Tell the Special IRP code the stack has changed. Code that will reexamine
    // the stack takes the database lock, so we can place the call here. This
    // also allows us to assert correct behavior *before* the stack is torn
    // down.
    //
    IOV_DETACH_DEVICE(TargetDevice);

    detachingDevice = TargetDevice->AttachedDevice;
    detachingExtension = detachingDevice->DeviceObjectExtension;
    ASSERT( detachingExtension->AttachedTo == TargetDevice );

    //
    // Unlink the device from the doubly-linked attachment chain.
    //

    detachingExtension->AttachedTo = NULL;
    TargetDevice->AttachedDevice = NULL;

    if (TargetDevice->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING) &&
        !TargetDevice->ReferenceCount) {
        IopCompleteUnloadOrDelete( TargetDevice, FALSE, irql );
    } else {
        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    }
}

VOID
IoDisconnectInterrupt(
    IN PKINTERRUPT InterruptObject
    )

/*++

Routine Description:

    This routine disconnects all of the interrupt objects that were
    initialized and connected by the IoConnectInterrupt routine.  Note
    that no interrupt objects directly connected using the kernel
    services may be input to this routine.

Arguments:

    InterruptObject - Supplies a pointer to the interrupt object allocated
        by the IoConnectInterrupt routine.

Return Value:

    None.

--*/

{
    PIO_INTERRUPT_STRUCTURE interruptStructure;
    ULONG i;

    PAGED_CODE();

    //
    // Obtain a pointer to the builtin interrupt object in the I/O interrupt
    // structure.
    //

    interruptStructure = CONTAINING_RECORD( InterruptObject,
                                            IO_INTERRUPT_STRUCTURE,
                                            InterruptObject );

    //
    // The builtin interrupt object is always used, so simply disconnect
    // it.
    //

    KeDisconnectInterrupt( &interruptStructure->InterruptObject );

    //
    // Now loop through each of the interrupt objects pointed to by the
    // structure and disconnect each.
    //

    for (i = 0; i < MAXIMUM_PROCESSORS; i++) {
        if (interruptStructure->InterruptArray[i] != NULL) {
            KeDisconnectInterrupt( interruptStructure->InterruptArray[i] );
        }
    }

    //
    // Finally, deallocate the memory associated with the entire structure.
    //

    ExFreePool( interruptStructure );
}

VOID
IoEnqueueIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enqueues the specified I/O Request Packet (IRP) to the thread's
    IRP pending queue.  The thread that the IRP is queued to is specified by
    the IRP's Thread field.

Arguments:

    Irp - Supplies a pointer to the IRP to be enqueued.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Simply enqueue the IRP to the thread's IRP queue.
    //

    IopQueueThreadIrp( Irp );
    return;
}

BOOLEAN
IoFastQueryNetworkAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine attempts to perform a fast I/O call to obtain the network
    attributes for a file.  This involves a specialized interface between
    this function and the I/O system's device parse method.  This allows the
    parse method to have the file system pseudo-open the file, obtain the
    appropriate attributes for the file, and return them to the caller w/as
    little overhead as possible from either the Object Manager or the I/O
    system itself.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for opening the
        file (e.g., the file's name, etc).

    DesiredAccess - Supplies the type(s) of access that the caller would like
        to the file.

    OpenOptions - Supplies standard NtOpenFile open options.

    IoStatus - Supplies a pointer to a variable to receive the final status
        of the operation.

    Buffer - Supplies an output buffer to receive the network attributes for
        the specified file.

Return Value:

    The final function value indicates whether or not the fast path could
    be taken successfully.

--*/

{
    HANDLE handle;
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;

    //
    // Build a parse open packet that tells the parse method to open the
    // file and query its network attributes using the fast path, if it
    // exists for this file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.CreateOptions = OpenOptions | FILE_OPEN_REPARSE_POINT;
    openPacket.Options = IO_FORCE_ACCESS_CHECK;
    openPacket.NetworkInformation = Buffer;
    openPacket.QueryOnly = TRUE;
    openPacket.FullAttributes = TRUE;
    openPacket.LocalFileObject = &localFileObject;

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file using the fast
    // path open and perform the query, effectively closing it as well.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 KernelMode,
                                 NULL,
                                 DesiredAccess,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.  The QueryOnly field is
    // set to whether or not the fast path was invoked.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {

        //
        // The parse routine was not invoked properly so the operation did
        // not work at all.
        //

        if (NT_SUCCESS(status)) {
            ZwClose(handle);
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        IoStatus->Status = status;
    } else {

        //
        // The fast path routine was successfully invoked so return the
        // final status of the operation.
        //

        IoStatus->Status = openPacket.FinalStatus;
        IoStatus->Information = openPacket.Information;
    }
    return TRUE;
}

VOID
IoFreeController(
    IN PCONTROLLER_OBJECT ControllerObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified controller object.
    No checks are made to ensure that the controller is really allocated
    to a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the controller
    object it will be pulled from the queue and its execution routine will
    be invoked.

Arguments:

    ControllerObject - Pointer to the controller object to be deallocated.

Return Value:

    None.

--*/

{
    PKDEVICE_QUEUE_ENTRY packet;
    PDEVICE_OBJECT deviceObject;
    IO_ALLOCATION_ACTION action;

    //
    // Simply remove the next entry from the controller's device wait queue.
    // If one was successfully removed, invoke its execution routine.
    //

    packet = KeRemoveDeviceQueue( &ControllerObject->DeviceWaitQueue );
    if (packet != NULL) {
        deviceObject = CONTAINING_RECORD( packet,
                                          DEVICE_OBJECT,
                                          Queue.Wcb.WaitQueueEntry );
        action = deviceObject->Queue.Wcb.DeviceRoutine( deviceObject,
                                                        deviceObject->CurrentIrp,
                                                        0,
                                                        deviceObject->Queue.Wcb.DeviceContext );

        //
        // If the execution routine wants the controller to be deallocate
        // now, deallocate it.
        //

        if (action == DeallocateObject) {
            IoFreeController( ControllerObject );
        }
    }
}

VOID
IoFreeIrp(
    IN PIRP Irp
    )
{
    pIoFreeIrp(Irp);
}


VOID
IopFreeIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deallocates the specified I/O Request Packet.

Arguments:

    Irp - I/O Request Packet to deallocate.

Return Value:

    None.

--*/

{
    PGENERAL_LOOKASIDE lookasideList;
    PP_NPAGED_LOOKASIDE_NUMBER number;
    PKPRCB prcb;

    //
    // Ensure that the data structure being freed is really an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    if (Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }


    ASSERT(IsListEmpty(&(Irp)->ThreadListEntry));
    Irp->Type = 0;

    //
    // Ensure that all of the owners of the IRP have at least been notified
    // that the request is going away.
    //

    ASSERT( Irp->CurrentLocation >= Irp->StackCount );

    //
    // Deallocate the IRP.
    //

    prcb = KeGetCurrentPrcb();
    if (Irp->AllocationFlags & IRP_LOOKASIDE_ALLOCATION) {
        Irp->AllocationFlags ^= IRP_LOOKASIDE_ALLOCATION;
        InterlockedIncrement( &prcb->LookasideIrpFloat );
    }

    if (!(Irp->AllocationFlags & IRP_ALLOCATED_FIXED_SIZE) ||
        (Irp->AllocationFlags & IRP_ALLOCATED_MUST_SUCCEED)) {
        ExFreePool( Irp );

    } else {

        if (IopIrpAutoSizingEnabled() &&
            (Irp->Size != IoSizeOfIrp(IopLargeIrpStackLocations)) &&
            (Irp->Size != IoSizeOfIrp(1))) {

            ExFreePool( Irp );
            return;
        }

        //
        // Store the size in a different field as this will get overwritten by single list entry.
        //

        Irp->IoStatus.Information = Irp->Size;

        number = LookasideSmallIrpList;
        if (Irp->StackCount != 1) {
            number = LookasideLargeIrpList;
        }

        lookasideList = prcb->PPLookasideList[number].P;
        lookasideList->TotalFrees += 1;
        if (ExQueryDepthSList( &lookasideList->ListHead ) >= lookasideList->Depth) {
            lookasideList->FreeMisses += 1;
            lookasideList = prcb->PPLookasideList[number].L;
            lookasideList->TotalFrees += 1;
            if (ExQueryDepthSList( &lookasideList->ListHead ) >= lookasideList->Depth) {
                lookasideList->FreeMisses += 1;
                ExFreePool( Irp );

            } else {
                if (Irp->AllocationFlags & IRP_QUOTA_CHARGED) {
                    Irp->AllocationFlags ^= IRP_QUOTA_CHARGED;
                    ExReturnPoolQuota( Irp );
                }

                InterlockedPushEntrySList( &lookasideList->ListHead,
                                           (PSLIST_ENTRY) Irp );
            }

        } else {
            if (Irp->AllocationFlags & IRP_QUOTA_CHARGED) {
                Irp->AllocationFlags ^= IRP_QUOTA_CHARGED;
                ExReturnPoolQuota( Irp );
            }

            InterlockedPushEntrySList( &lookasideList->ListHead,
                                       (PSLIST_ENTRY) Irp );
        }
    }

    return;
}

VOID
IoFreeMdl(
    IN PMDL Mdl
    )

/*++

Routine Description:

    This routine frees a Memory Descriptor List (MDL).  It only frees the
    specified MDL; any chained MDLs must be freed explicitly through another
    call to this routine.

Arguments:

    Mdl - Pointer to the Memory Descriptor List to be freed.

Return Value:

    None.

--*/

{

    //
    // Tell memory management that this MDL will be re-used.  This will
    // cause MM to unmap any pages that have been mapped for this MDL if
    // it is a partial MDL.
    //

    MmPrepareMdlForReuse(Mdl);
    if (((Mdl->MdlFlags & MDL_ALLOCATED_FIXED_SIZE) == 0) ||
        ((Mdl->MdlFlags & MDL_ALLOCATED_MUST_SUCCEED) != 0)) {
        ExFreePool(Mdl);

    } else {
        ExFreeToPPLookasideList(LookasideMdlList, Mdl);
    }
}

PDEVICE_OBJECT
IoGetAttachedDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine returns the highest level device object associated with
    the specified device.

    N.B. Caller must own the IopDatabaseLock. External callers of this
    function must ensure nobody is attaching or detaching from the stack.
    If they cannot, they *must* use IoGetAttachedDeviceReference.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the attached
        device is to be returned.

Return Value:

    The function value is the highest level device attached to the specified
    device.  If no devices are attached, then the pointer to the device
    object itself is returned.

--*/

{
    //
    // Loop through all of the device object's attached to the specified
    // device.  When the last device object is found that is not attached
    // to, return it.
    //

    while (DeviceObject->AttachedDevice) {
        DeviceObject = DeviceObject->AttachedDevice;
    }

    return DeviceObject;
}

PDEVICE_OBJECT
IoGetAttachedDeviceReference(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine synchronizes with the Io database and returns a reference
    to the highest level device object associated with the specified device.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the attached
        device is to be returned.

Return Value:

    The function value is a reference to the highest level device attached
    to the specified device.  If no devices are attached, then the pointer
    to the device object itself is returned.

--*/
{
    KIRQL               irql;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    DeviceObject = IoGetAttachedDevice (DeviceObject);
    ObReferenceObject (DeviceObject);
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
    return DeviceObject;
}

PDEVICE_OBJECT
IoGetBaseFileSystemDeviceObject(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns the base (lowest-level) file system volume device
    object associated with a file.  I.e., it locates the file system w/o
    walking the attached device object list.

Arguments:

    FileObject - Supplies a pointer to the file object for which the base
        file system device object is to be returned.

Return Value:

    The function value is the lowest level volume device object associated
    w/the file.

--*/

{
    PDEVICE_OBJECT deviceObject;

    //
    // If the file object has a mounted Vpb, use its DeviceObject.
    //

    if (FileObject->Vpb != NULL && FileObject->Vpb->DeviceObject != NULL) {
        deviceObject = FileObject->Vpb->DeviceObject;

    //
    // Otherwise, if the real device has a VPB that indicates that it is
    // mounted, then use the file system device object associated with the
    // VPB.
    //

    } else if (!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN) &&
               FileObject->DeviceObject->Vpb != NULL &&
               FileObject->DeviceObject->Vpb->DeviceObject != NULL) {

            deviceObject = FileObject->DeviceObject->Vpb->DeviceObject;

    //
    // Otherwise, just return the real device object.
    //

    } else {

        deviceObject = FileObject->DeviceObject;
    }

    ASSERT( deviceObject != NULL );

    //
    // Simply return the resultant file object.
    //

    return deviceObject;
}

PCONFIGURATION_INFORMATION
IoGetConfigurationInformation( VOID )

/*++

Routine Description:

    This routine returns a pointer to the system's device configuration
    information structure so that drivers and the system can determine how
    many different types of devices exist in the system.

Arguments:

    None.

Return Value:

    The function value is a pointer to the configuration information
    structure.

--*/

{
    PAGED_CODE();

    //
    // Simply return a pointer to the built-in configuration information
    // structure.
    //

    return (&ConfigurationInformation);
}

PEPROCESS
IoGetCurrentProcess( VOID )

/*++

Routine Description:

    This routine returns a pointer to the current process.  It is actually
    a jacket routine for the PS version of the same function since device
    drivers using the ntddk header file cannot see into a thread object.

Arguments:

    None.

Return Value:

    The function value is a pointer to the current process.

Note:

    Note that this function cannot be paged because it is invoked at raised
    IRQL in debug builds, which is the only time that the PAGED_CODE macro
    actually does anything.  Therefore, it is impossible to find code that
    invokes this function at raised IRQL in a normal system w/o simply running
    into the "proper conditions".  This is too risky to actually page this
    routine, so it is left nonpaged.

--*/

{
    //
    // Simply return a pointer to the current process.
    //

    return PsGetCurrentProcess();
}

NTSTATUS
IoGetDeviceObjectPointer(
    IN PUNICODE_STRING ObjectName,
    IN ACCESS_MASK DesiredAccess,
    OUT PFILE_OBJECT *FileObject,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine returns a pointer to the device object specified by the
    object name.  It also returns a pointer to the referenced file object
    that has been opened to the device that ensures that the device cannot
    go away.

    To close access to the device, the caller should dereference the file
    object pointer.

Arguments:

    ObjectName - Name of the device object for which a pointer is to be
        returned.

    DesiredAccess - Access desired to the target device object.

    FileObject - Supplies the address of a variable to receive a pointer
        to the file object for the device.

    DeviceObject - Supplies the address of a variable to receive a pointer
        to the device object for the specified device.

Return Value:

    The function value is a referenced pointer to the specified device
    object, if the device exists.  Otherwise, NULL is returned.

--*/

{
    PFILE_OBJECT fileObject;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fileHandle;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Initialize the object attributes to open the device.
    //

    InitializeObjectAttributes( &objectAttributes,
                                ObjectName,
                                OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwOpenFile( &fileHandle,
                         DesiredAccess,
                         &objectAttributes,
                         &ioStatus,
                         0,
                         FILE_NON_DIRECTORY_FILE );

    if (NT_SUCCESS( status )) {

        //
        // The open operation was successful.  Dereference the file handle
        // and obtain a pointer to the device object for the handle.
        //

        status = ObReferenceObjectByHandle( fileHandle,
                                            0,
                                            IoFileObjectType,
                                            KernelMode,
                                            (PVOID *) &fileObject,
                                            NULL );
        if (NT_SUCCESS( status )) {

            *FileObject = fileObject;

            //
            // Get a pointer to the device object for this file.
            //
            *DeviceObject = IoGetRelatedDeviceObject( fileObject );
        }

        (VOID) ZwClose( fileHandle );
    }

    return status;
}

PDEVICE_OBJECT
IoGetDeviceToVerify(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns a pointer to the device object that is to be verified.
    The pointer is set in the thread object by a device driver when the disk
    or CD-ROM media appears to have changed since the last access to the device.

Arguments:

    Thread - Pointer to the thread whose field is to be queried.

Return Value:

    The function value is a pointer to the device to be verified, or NULL.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.


--*/

{
    //
    // Simply return the device to be verified.
    //

    return Thread->DeviceToVerify;
}

NTKERNELAPI
PVOID
IoGetDriverObjectExtension(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID ClientIdentificationAddress
    )
/*++

Routine Description:

    This routine returns a pointer to the client driver object extension.
    This extension was allocated using IoAllocateDriverObjectExtension. If
    an extension with the create Id does not exist for the specified driver
    object then NULL is returned.

Arguments:

    DriverObject - Pointer to driver object owning the extension.

    ClientIdentificationAddress - Supplies the unique identifier which was
        used to create the extension.

Return Value:

    The function value is a pointer to the client driver object extension,
    or NULL.

--*/

{
    KIRQL irql;
    PIO_CLIENT_EXTENSION extension;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    extension = DriverObject->DriverExtension->ClientDriverExtension;
    while (extension != NULL) {

        if (extension->ClientIdentificationAddress == ClientIdentificationAddress) {
            break;
        }

        extension = extension->NextExtension;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    if (extension == NULL) {
        return NULL;
    }

    return extension + 1;
}

PGENERIC_MAPPING
IoGetFileObjectGenericMapping(
    VOID
    )

/*++

Routine Description:

    This routine returns a pointer to the generic mapping for a file object.

Arguments:

    None.

Return Value:

    A pointer to the generic mapping for a file object.

--*/

{
    PAGED_CODE()

    //
    // Simply return a pointer to the generic mapping for a file object.
    //

    return (PGENERIC_MAPPING)&IopFileMapping;
}

PVOID
IoGetInitialStack(
    VOID
    )

/*++

Routine Description:

    This routine returns the base initial address of the current thread's
    stack.

Arguments:

    None.

Return Value:

    The base initial address of the current thread's stack.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply return the initial stack for this thread.
    //

    return PsGetCurrentThread()->Tcb.InitialStack;
}

VOID
IoGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    )
/*++

Routine Description:

    This routine returns the low/high limits of the stack currently used.
    This can be a thread stack or a DPC stack depending on the execution
    context.

Arguments:

    LowLimit - address to write low address of the stack region currently used.

    HighLimit - address to write high address of the stack region currently used.

Return Value:

    None. For any kind of error both LowLimit and HighLimit will be zeroed.
    For example this will happen if the driver illegally switched to a
    different stack.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/
{
    volatile ULONG_PTR StackAddress;

    //
    // The local variable is marked volatile so that the compiler
    // will not get any ideas to optimize its use. We really need this
    // to be stack based so that its address is within current stack
    // limits.
    //

    StackAddress = (ULONG_PTR)(&StackAddress);

    //
    // Get the stack associated with current thread. This call is not
    // aware of DPCs. It will just read stack limits from current thread
    // control block.
    //

    RtlpGetStackLimits (LowLimit, HighLimit);

    //
    // Check if address of a local variable is within stack limits.
    // If not then this could be a DPC stack.
    //

    if ((StackAddress < *LowLimit) || (StackAddress > *HighLimit)) {

        //
        // It would be nice to null the limits to be returned.
        // This would signal error for stacks switched without kernel's
        // knowledge. However there are drivers switching stacks like this
        // and they get confused by the zeroed limits. Therefore we do not
        // do it.
        //

        if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

            PKPRCB Prcb = KeGetCurrentPrcb();
            ULONG_PTR DpcStack = (ULONG_PTR)(Prcb->DpcStack);

            if ((Prcb->DpcRoutineActive) &&
                (StackAddress <= DpcStack) &&
                (StackAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                *HighLimit = DpcStack;
                *LowLimit = DpcStack - KERNEL_STACK_SIZE;
            }
        }
    }
}


NTSTATUS
IoComputeDesiredAccessFileObject(
    IN PFILE_OBJECT FileObject,
    OUT PNTSTATUS DesiredAccess
    )

/*++

Routine Description

    This routine is called by ObReferenceFileObjectForWrite (from NtWriteFile)
    to determine which access is desired for the passed file object.  The desired
    access differs if the FileObject is a file or a pipe.

Arguments

    FileObject - the file object to access

    DesiredAccess - the computed access for the object

Return Value

    STATUS_OBJECT_TYPE_MISMATCH if the object is not of type IoFileObjectType
    STATUS_SUCCESS if successful

--*/

{
    POBJECT_HEADER ObjectHeader = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    *DesiredAccess = 0;
    ObjectHeader = OBJECT_TO_OBJECT_HEADER(FileObject);

    if (ObjectHeader->Type == IoFileObjectType) {

        *DesiredAccess = (!(FileObject->Flags & FO_NAMED_PIPE) ? FILE_APPEND_DATA : 0) | FILE_WRITE_DATA;
        Status = STATUS_SUCCESS;

    } else {

        Status = STATUS_OBJECT_TYPE_MISMATCH;
    }

    return Status;
}


PDEVICE_OBJECT
IoGetRelatedDeviceObject(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns a pointer to the actual device object than an I/O
    Request Packet (IRP) should be given to based on the specified file
    object.

    N.B. - Callers of this function must ensure no device object is
    attaching or detaching from this stack for the duration of this call.
    This is because the database lock is *not* held!

Arguments:

    FileObject - Pointer to the file object representing the open file.

Return Value:

    The return value is a pointer to the device object for the driver to
    whom the request is to be given.

--*/

{
    PDEVICE_OBJECT deviceObject;

    //
    // If the file object was taken out against the mounted file system, it
    // will have a Vpb. Traverse it to get to the DeviceObject. Note that in
    // this case we should never follow FileObject->DeviceObject, as that
    // mapping may be invalid after a forced dismount.
    //

    if (FileObject->Vpb != NULL && FileObject->Vpb->DeviceObject != NULL) {

        ASSERT(!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN));
        deviceObject = FileObject->Vpb->DeviceObject;


        //
        // If a driver opened a disk device using direct device open and
        // later on it uses IoGetRelatedTargetDeviceObject to find the
        // device object it wants to send an IRP then it should not get the
        // filesystem device object. This is so that if the device object is in the
        // process of being mounted then vpb is not stable.
        //

    } else if (!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN) &&
               FileObject->DeviceObject->Vpb != NULL &&
               FileObject->DeviceObject->Vpb->DeviceObject != NULL) {

            deviceObject = FileObject->DeviceObject->Vpb->DeviceObject;

    //
    // This is a direct open against the device stack (and there is no mounted
    // file system to strain the IRPs through).
    //

    } else {

        deviceObject = FileObject->DeviceObject;
    }

    ASSERT( deviceObject != NULL );

    //
    // Check to see whether or not the device has any associated devices.
    // If so, return the highest level device; otherwise, return a pointer
    // to the device object itself.
    //

    if (deviceObject->AttachedDevice != NULL) {
        if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {

            PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =
                (PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

            ASSERT(!(FileObject->Flags & FO_DIRECT_DEVICE_OPEN));

            if (fileObjectExtension->TopDeviceObjectHint != NULL &&
                IopVerifyDeviceObjectOnStack(deviceObject, fileObjectExtension->TopDeviceObjectHint)) {
                return fileObjectExtension->TopDeviceObjectHint;
            }
        }
        deviceObject = IoGetAttachedDevice( deviceObject );
    }

    return deviceObject;
}

ULONG
IoGetRequestorProcessId(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns a 32-bit value that is unique to the process that
    originally requested the specified I/O operation.

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    The function value is the 32-bit process ID.


--*/

{
    PEPROCESS process;

    process = IoGetRequestorProcess( Irp );
    if (process != NULL) {

        //
        // UniqueProcessId is a kernel-mode handle, safe to truncate to ULONG.
        //

        return HandleToUlong( process->UniqueProcessId );
    } else {

        //
        // Return a PID of zero if there is no process associated with the IRP.
        //

        return 0;
    }
}

PEPROCESS
IoGetRequestorProcess(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns a pointer to the process that originally
    requested the specified I/O operation.

Arguments:

    Irp - Pointer to the I/O Request Packet.

Return Value:

    The function value is a pointer to the original requesting process.


--*/

{
    //
    // Return the address of the process that requested the I/O operation.
    //

    PETHREAD thread = Irp->Tail.Overlay.Thread;
    if (thread) {

        //
        // The thread was not attached when the IRP was issued. So get
        // the original process. Note that this API could be called from
        // another process or thread.
        //

        if (Irp->ApcEnvironment == OriginalApcEnvironment) {
            return (THREAD_TO_PROCESS(thread));

        //
        // The thread was attached when the IRP was issued. In this case
        // give the process to which the thread is currently attached. Note that
        // this only works if the thread that issued the IO request while it was
        // attached does not attach again. This is not allowed.
        //

        } else if (Irp->ApcEnvironment == AttachedApcEnvironment) {
            return (CONTAINING_RECORD(((thread)->Tcb.ApcState.Process),EPROCESS,Pcb));

        } else {
            return NULL;
        }
    } else {
        return NULL;
    }
}

PIRP
IoGetTopLevelIrp(
    VOID
    )

/*++

Routine Description:

    This routine returns the contents of the TopLevelIrp field of the current
    thread.

Arguments:

    None.

Return Value:

    The final function value is the contents of the TopLevelIrp field.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply return the TopLevelIrp field of the thread.
    //

    return (PIRP) (PsGetCurrentThread()->TopLevelIrp);
}

VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    Initializes an IRP.

Arguments:

    Irp - a pointer to the IRP to initialize.

    PacketSize - length, in bytes, of the IRP.

    StackSize - Number of stack locations in the IRP.

Return Value:

    None.

--*/

{
    IOV_INITIALIZE_IRP(Irp, PacketSize, StackSize);

    //
    // Begin by zeroing the entire packet.
    //

    RtlZeroMemory( Irp, PacketSize );

    //
    // Initialize the remainder of the packet by setting the appropriate fields
    // and setting up the I/O stack locations in the packet.
    //

    Irp->Type = (CSHORT) IO_TYPE_IRP;
    Irp->Size = (USHORT) PacketSize;
    Irp->StackCount = (CCHAR) StackSize;
    Irp->CurrentLocation = (CCHAR) (StackSize + 1);
    Irp->ApcEnvironment = KeGetCurrentApcEnvironment();
    InitializeListHead (&(Irp)->ThreadListEntry);
    Irp->Tail.Overlay.CurrentStackLocation =
        ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) +
            sizeof( IRP ) +
            ( (StackSize) * sizeof( IO_STACK_LOCATION ))));
}

VOID
IoReuseIrp(
    PIRP Irp,
    NTSTATUS Status)
/*++

Routine Description:

    This routine is used by drivers to initialize an already allocated IRP for reuse.
    It does what IoInitializeIrp does but it saves the allocation flags so that we know
    how to free the Irp and take care of quote requirements. Drivers should call IoReuseIrp
    instead of calling IoInitializeIrp to reinitialize an IRP.

Arguments:

    Irp - Pointer to Irp to be reused

    Status - Status to preinitialize the Iostatus field.

--*/
{

    USHORT  PacketSize;
    CCHAR   StackSize;
    UCHAR   AllocationFlags;

    // Did anyone forget to pull their cancel routine?
    ASSERT(Irp->CancelRoutine == NULL) ;

    // We probably don't want thread enqueue'd IRPs to be used
    // ping-pong style as they cannot be dequeue unless they
    // complete entirely. Not really an issue for worker threads,
    // but definitely for operations on application threads.
    ASSERT(IsListEmpty(&Irp->ThreadListEntry)) ;

    AllocationFlags = Irp->AllocationFlags;
    StackSize = Irp->StackCount;
    PacketSize =  IoSizeOfIrp(StackSize);
    IopInitializeIrp(Irp, PacketSize, StackSize);
    Irp->AllocationFlags = AllocationFlags;
    Irp->IoStatus.Status = Status;

}



NTSTATUS
IoInitializeTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_TIMER_ROUTINE TimerRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is used by drivers to initialize a timer entry for a device
    object.

Arguments:

    DeviceObject - Pointer to device object to be used.

    TimerRoutine - Driver routine to be executed when timer expires.

    Context - Context parameter that is passed to the driver routine.

Return Value:

    The function value indicates whether or not the timer was initialized.

--*/

{
    PIO_TIMER timer;

    PAGED_CODE();

    //
    // Begin by getting the address of the timer to be used.  If no timer has
    // been allocated, allocate one and initialize it.
    //

    timer = DeviceObject->Timer;
    if (!timer) {
        timer = ExAllocatePoolWithTag( NonPagedPool, sizeof( IO_TIMER ), 'iToI' );
        if (!timer) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Initialize the timer entry so that it is suitable for being placed
        // into the I/O system's timer queue.
        //

        RtlZeroMemory( timer, sizeof( IO_TIMER ) );
        timer->Type = IO_TYPE_TIMER;
        timer->DeviceObject = DeviceObject;
        DeviceObject->Timer = timer;
    }

    //
    // Set the address of the driver's timer routine and the context parameter
    // passed to it and insert it onto the timer queue.  Note that the timer
    // enable flag is not set, so this routine will not actually be invoked
    // yet.
    //

    timer->TimerRoutine = TimerRoutine;
    timer->Context = Context;

    ExInterlockedInsertTailList( &IopTimerQueueHead,
                                 &timer->TimerList,
                                 &IopTimerLock );
    return STATUS_SUCCESS;
}

BOOLEAN
IoIsOperationSynchronous(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines whether an I/O operation is to be considered
    synchronous or an asynchronous, from the implementors point-of-view.
    Synchronous I/O is defined by how the file was opened, or the API being
    used to perform the operation, or by the type of paging I/O being
    performed, if the operation is paging I/O.

    It is possible for asynchronous paging I/O to occur to a file that was
    opened for synchronous I/O.  This occurs when the Modified Page Writer
    is doing I/O to a file that is mapped, when too many modified pages exist
    in the system.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) representing the operation
        to be performed.

Return Value:

    A value of TRUE is returned if the operation is synchronous, otherwise
    FALSE is returned.

--*/

{
    //
    // Determine whether this is a synchronous I/O operation.  Synchronous I/O
    // is defined as an operation that is:
    //
    //     A file opened for synchronous I/O
    //         OR
    //     A synchronous API operation
    //         OR
    //     A synchronous paging I/O operation
    //
    //  AND this is NOT an asynchronous paging I/O operation occurring to some
    //  file that was opened for either synchronous or asynchronous I/O.
    //

    if ((IoGetCurrentIrpStackLocation( Irp )->FileObject->Flags & FO_SYNCHRONOUS_IO ||
        Irp->Flags & IRP_SYNCHRONOUS_API ||
        Irp->Flags & IRP_SYNCHRONOUS_PAGING_IO) &&
        !(Irp->Flags & IRP_PAGING_IO &&
        !(Irp->Flags & IRP_SYNCHRONOUS_PAGING_IO))) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOLEAN
IoIsSystemThread(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns a BOOLEAN indicating whether or not the specified
    thread is a system thread.

Arguments:

    Thread - Pointer to the thread to be checked.

Return Value:

    A value of TRUE is returned if the indicated thread is a system thread,
    else FALSE.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    return (BOOLEAN) IS_SYSTEM_THREAD(Thread);
}

BOOLEAN
IoIsValidNameGraftingBuffer(
    IN PIRP Irp,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    )

/*++

Routine Description:

    This routine returns a BOOLEAN indicating whether or not the specified
    buffer is a valid name grafting buffer. All internal validity checks are
    encapsulated in this routine.

    Among the checks performed is whether the name lengths stored within the
    buffer in the private data section are compatible with the total size of
    the buffer that has been passed in.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) representing the operation
        to be performed.

    Buffer - Pointer to a reparse data buffer that is supposed to contain
        a self-consistent set of names to perform name grafting.

Return Value:

    A value of TRUE is returned if the buffer is correct for name grafting,
    else FALSE.

Note:

    This function needs to be kept synchronized with the definition of
    REPARSE_DATA_BUFFER.

--*/

{
    PIO_STACK_LOCATION thisStackPointer = NULL;
    UNICODE_STRING     drivePath;

    PAGED_CODE();

    ASSERT( FIELD_OFFSET( REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0] ) ==
            FIELD_OFFSET( REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0] ) );
    ASSERT( ReparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );

    //
    // Determine whether we have the correct kind of reparse tag in the buffer.
    //

    if (ReparseBuffer->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT) {

        //
        // The reparse tag is not an NT name grafting tag.
        //

        return FALSE;
    }

    //
    // Determine whether we have enough data for all the length fields.
    //

    if (ReparseBuffer->ReparseDataLength <
        (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) {

        //
        // The buffer is shorter than the minimum needed to express a pair of valid
        // names.
        //

        return FALSE;
    }

    //
    // Get the address of the current stack location.
    //

    thisStackPointer = IoGetCurrentIrpStackLocation( Irp );

    //
    // Determine whether the data lengths returned are consistent with the buffer in
    // which they are retrieved.
    //
    // This check is meaningful only when the buffer has been allocated. When this routine
    // is used when a name grafting is being set there is no allocated output buffer.
    //

    if ((thisStackPointer->Parameters.FileSystemControl.OutputBufferLength > 0) &&
        (thisStackPointer->Parameters.FileSystemControl.OutputBufferLength <
        (ULONG)(FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) +
                ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
                ReparseBuffer->MountPointReparseBuffer.PrintNameLength +
                2 * sizeof( UNICODE_NULL )))) {

        //
        // The length of the appropriate buffer header, plus the lengths of the substitute
        // and print names are longer than the length of the buffer passed in.
        // Thus, this data is not self-consistent.
        //
        // Note that it is only the I/O subsystem that needs to check for this internal
        // consistency in the buffer as it will do a blind data copy using these lengths
        // when transmogrifying the names. The file system returning the buffer only needs
        // to ascertain that the total size of the data retrieved does not exceed the size
        // of the output buffer.
        //

        return FALSE;
    }

    //
    // Now we determine whether the names were placed according to the reparse point
    // specification.
    //

    //
    // Determine whether the SubstituteNameOffset is zero.
    //

    if (ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset != 0) {

        //
        // Incorrect offset for the substitute name.
        //

        return FALSE;
    }

    //
    // Determine whether PrintNameOffset is correct.
    //

    if (ReparseBuffer->MountPointReparseBuffer.PrintNameOffset !=
        (ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength + sizeof( UNICODE_NULL )) ) {

        //
        // Incorrect offset for the print name.
        //

        return FALSE;
    }

    //
    // Determine whether ReparseDataLength is correct for name grafting operations.
    // We require a buffer of type REPARSE_DATA_BUFFER.
    //

    if (ReparseBuffer->ReparseDataLength !=
        (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE) +
        ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
        ReparseBuffer->MountPointReparseBuffer.PrintNameLength +
        2 * sizeof( UNICODE_NULL )) {

        //
        // Incorrect length of the reparse data.
        //

        return FALSE;
    }

    //
    // Determine that the substitute name is not a UNC name.
    // This assumes that ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset is zero (0).
    //

    {
        //
        // This conditional is a transcription of part of the code of RtlDetermineDosPathNameType_U
        // present in ntos\dll\curdir.c
        //
        // The only two legal names that can begin with \\ are:  \\.  and  \\?
        // All other names that begin with  \\  are disallowed.
        //

        if ((ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength > 6) &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'\\') &&
            !((ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'.') ||
              (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?'))) {

            //
            // The name is not one we want to deal with.
            //

            return FALSE;
        }

        //
        // When  RtlDosPathNameToNtPathName_U  is used, the UNC names are returned with a prefix
        // of the form  \??\UNC\
        //

        if ((ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength > 16) &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[3] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[4] == L'U') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[5] == L'N') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[6] == L'C') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[7] == L'\\')) {

            //
            // The name is not one we want to deal with.
            //

            return FALSE;
        }

        //
        // See whether there is a drive letter that is mapped at the beginning of the name.
        // If the drive letter is C, then the prefix has the form  \??\C:
        // Note that we skip the offset 4 on purpose.
        //

        if ((ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength > 12) &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[3] == L'\\') &&
            (ReparseBuffer->MountPointReparseBuffer.PathBuffer[5] == L':')) {

            NTSTATUS           status;
            UNICODE_STRING     linkValue;
            OBJECT_ATTRIBUTES  objectAttributes;
            HANDLE             linkHandle;
            PWCHAR             linkValueBuffer = NULL;   //  MAX_PATH is 260
            WCHAR              pathNameValue[sizeof(L"\\??\\C:\0")];

            RtlCopyMemory( &pathNameValue[0], L"\\??\\C:\0", sizeof(L"\\??\\C:\0") );

            RtlInitUnicodeString( &drivePath, pathNameValue );

            //
            // Place the appropriate drive letter in the buffer overwriting offset 4.
            //

            drivePath.Buffer[4] = ReparseBuffer->MountPointReparseBuffer.PathBuffer[4];

            InitializeObjectAttributes( &objectAttributes,
                                        &drivePath,
                                        OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
                                        (HANDLE) NULL,
                                        (PSECURITY_DESCRIPTOR) NULL );

            status = ZwOpenSymbolicLinkObject( &linkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &objectAttributes );


            if ( NT_SUCCESS( status ) ) {

                //
                // Now query the link and see if there is a redirection
                //

                linkValueBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                                         2 * 260,
                                                         '  oI' );
                if ( !linkValueBuffer ) {

                    //
                    // Insufficient resources. Return FALSE.
                    //

                    ZwClose( linkHandle );
                    return FALSE;
                }

                linkValue.Buffer = linkValueBuffer;
                linkValue.Length = 0;
                linkValue.MaximumLength = (USHORT)(2 * 260);

                status = ZwQuerySymbolicLinkObject( linkHandle,
                                                    &linkValue,
                                                    NULL );
                ZwClose( linkHandle );


                if ( NT_SUCCESS( status ) ) {

                    //
                    // The link is a re-directed drive when it has the prefix
                    // \Device\LanmanRedirector\
                    //

                    if ((linkValue.Buffer[ 0] == L'\\') &&
                        (linkValue.Buffer[ 1] == L'D') &&
                        (linkValue.Buffer[ 2] == L'e') &&
                        (linkValue.Buffer[ 3] == L'v') &&
                        (linkValue.Buffer[ 4] == L'i') &&
                        (linkValue.Buffer[ 5] == L'c') &&
                        (linkValue.Buffer[ 6] == L'e') &&
                        (linkValue.Buffer[ 7] == L'\\') &&
                        (linkValue.Buffer[ 8] == L'L') &&
                        (linkValue.Buffer[ 9] == L'a') &&
                        (linkValue.Buffer[10] == L'n') &&
                        (linkValue.Buffer[14] == L'R') &&
                        (linkValue.Buffer[15] == L'e') &&
                        (linkValue.Buffer[16] == L'd') &&
                        (linkValue.Buffer[17] == L'i') &&
                        (linkValue.Buffer[18] == L'r') &&
                        (linkValue.Buffer[23] == L'r') &
                        (linkValue.Buffer[24] == L'\\')) {

                        //
                        // Free the buffer.
                        //

                        ExFreePool( linkValueBuffer );

                        return FALSE;
                    }

                }

                //
                // Free the buffer.
                //

                ExFreePool( linkValueBuffer );
            }
        }
    }

    //
    // Determine that we either have an NT file name or a volume mount point target name.
    //
    // This closes the door of having an arbitrary device name that, with the help of the
    // server, can be used to bypass access checks to the underlying device.
    //

    {
        UNICODE_STRING volumeName;

        if (
            //
            // The shortest valid name is one of the kind \??\C: whose length is 12 when
            // in Unicode. All names used by volume mount points are longer.
            //

            ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength < 12 ) {

            return FALSE;
        }

        //
        // The name has at least 6 Unicode characters.
        //
        // We have verified above that MountPointReparseBuffer.SubstituteNameOffset
        // is zero.
        //

        volumeName.Length =
        volumeName.MaximumLength = ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength;
        volumeName.Buffer = (PWSTR) ReparseBuffer->MountPointReparseBuffer.PathBuffer;

        //
        // When we do not have a name that begins with a drive letter and it is not
        // a valid volume mount point name then we return false.
        //

        if ( !((ReparseBuffer->MountPointReparseBuffer.PathBuffer[0] == L'\\') &&
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[1] == L'?') &&
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[2] == L'?') &&
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[3] == L'\\') &&
               //
               // Notice that we skip index 4, where the drive letter is to be.
               //
               (ReparseBuffer->MountPointReparseBuffer.PathBuffer[5] == L':'))

             &&

             !MOUNTMGR_IS_VOLUME_NAME( &volumeName ) ) {

            return FALSE;
        }
    }

    //
    // Otherwise return TRUE.
    //

    return TRUE;
}

VOID
IopDoNameTransmogrify(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN PREPARSE_DATA_BUFFER ReparseBuffer
    )

/*++

Routine Description:

    This routine is called to do the name grafting needed for junctions.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) representing the operation
        to be performed.

    FileObject - Pointer to the file object whose name is being affected.

    ReparseBuffer - Pointer to a reparse data buffer that is supposed to contain
        a self-consistent set of names to perform name grafting.

Return Value:

    No explicit return value. The appropriate fields off the IRP are set.

Note:

    This function needs to be kept synchronized with the definition of
    REPARSE_DATA_BUFFER.

--*/

{
    USHORT pathLength = 0;
    USHORT neededBufferLength = 0;
    PVOID outBuffer = NULL;
    PWSTR pathBuffer = NULL;

    PAGED_CODE();

    //
    // We do the appropriate paste of the new name in the FileName buffer
    // and deallocate the buffer that brought the data from the file system.
    //

    ASSERT( Irp->IoStatus.Status == STATUS_REPARSE );
    ASSERT( Irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT );

    ASSERT( Irp->Tail.Overlay.AuxiliaryBuffer != NULL );

    ASSERT( ReparseBuffer != NULL );
    ASSERT( ReparseBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
    ASSERT( ReparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
    ASSERT( ReparseBuffer->Reserved < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );


    //
    // Determine whether we have enough data for all the length fields.
    //
    // Determine whether the lengths returned are consistent with the maximum
    // buffer. This is the best self-defense check we can do at this time as
    // the stack pointer is already invalid.
    //

    if (ReparseBuffer->ReparseDataLength >=
        (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) - REPARSE_DATA_BUFFER_HEADER_SIZE)) {

        if (MAXIMUM_REPARSE_DATA_BUFFER_SIZE <
            (FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]) +
                ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength +
                ReparseBuffer->MountPointReparseBuffer.PrintNameLength)) {

            Irp->IoStatus.Status = STATUS_IO_REPARSE_DATA_INVALID;
        }
    } else {
        Irp->IoStatus.Status = STATUS_IO_REPARSE_DATA_INVALID;
    }

    //
    // The value in  ReparseBuffer->Reserved  is the length of the file
    // name that has still to be parsed.
    //

    //
    // Copy the buffer when it has the appropriate length, else return a null UNICODE name:
    //   (1) Do defensive sanity checks on the name lengths returned.
    //
    // We only care to do this if we have no error conditions.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        pathBuffer = (PWSTR)((PCHAR)ReparseBuffer->MountPointReparseBuffer.PathBuffer +
                             ReparseBuffer->MountPointReparseBuffer.SubstituteNameOffset);
        pathLength = ReparseBuffer->MountPointReparseBuffer.SubstituteNameLength;
    }

    //
    // Notice that if the data returned in AuxiliaryBuffer is not long enough then
    // pathLength has value 0 and pathBuffer has value NULL.
    //
    // The value in  ReparseBuffer->Reserved  is the length of the file name that
    // has still to be parsed.
    //
    // We only care to do this if we have no error conditions.
    //

    if (ReparseBuffer->Reserved < 0) {

        //
        // This is an invalid offset.
        //

        Irp->IoStatus.Status = STATUS_IO_REPARSE_DATA_INVALID;
    }

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        // Check for overflow. (pathLength <= MAXIMUM_REPARSE_DATA_BUFFER_SIZE)
        // so pathLength + sizeof(UNICODE_NULL) cannot overflow.
        //

        if (((USHORT)MAXUSHORT - ReparseBuffer->Reserved ) > (pathLength +(USHORT)sizeof(UNICODE_NULL))) {
            neededBufferLength = pathLength + ReparseBuffer->Reserved + sizeof( UNICODE_NULL );
            //
            // If the out name buffer isn't large enough, allocate a new one.
            //

            if (FileObject->FileName.MaximumLength < neededBufferLength) {
                outBuffer = ExAllocatePoolWithTag( PagedPool,
                                                   neededBufferLength,
                                                   'cFoI' );
                if (!outBuffer) {
                    Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                outBuffer = FileObject->FileName.Buffer;
            }
        } else {
            Irp->IoStatus.Status = STATUS_NAME_TOO_LONG;
        }
    }

    //
    // Place in the out name buffer the remaining part of the name.
    //
    // We only care to do this if we have no error conditions.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        if (ReparseBuffer->Reserved) {

            RtlMoveMemory ( (PCHAR)outBuffer + pathLength,
                            (PCHAR)FileObject->FileName.Buffer +
                                  (FileObject->FileName.Length - ReparseBuffer->Reserved),
                            ReparseBuffer->Reserved );
        }

        //
        // Copy into the front of the out name buffer the value of the
        // reparse point.
        //

        if (pathLength) {

            RtlCopyMemory( (PCHAR)outBuffer,
                           (PCHAR)pathBuffer,
                           pathLength );
        }

        FileObject->FileName.Length = neededBufferLength - sizeof( UNICODE_NULL );

        //
        // Free the old name buffer when needed and update the appropriate values.
        //

        if (outBuffer != FileObject->FileName.Buffer) {

            if (FileObject->FileName.Buffer != NULL) {
                ExFreePool( FileObject->FileName.Buffer );
            }
            FileObject->FileName.Buffer = outBuffer;
            FileObject->FileName.MaximumLength = neededBufferLength;
            ((PWSTR)outBuffer)[ (neededBufferLength / sizeof( WCHAR ))-1 ] = UNICODE_NULL;
        }
    }

    //
    // Free the buffer that came from the file system.
    // NULL the pointer.
    //

    ExFreePool( ReparseBuffer );
    ReparseBuffer = NULL;
}

PIRP
IoMakeAssociatedIrp(
    IN PIRP Irp,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    This routine allocates an I/O Request Packet from the system nonpaged pool
    and makes it an associated IRP to the specified IRP.  The packet will be
    allocated to contain StackSize stack locations.  The IRP will also be
    initialized.

    Note that it is up to the caller to have set the number of associated IRPs
    in the master packet before calling this routine for the first time.  The
    count should be set in the master packet in:  AssociatedIrp.IrpCount.

Arguments:

    Irp - Pointer to master IRP to be associated with.

    StackSize - Specifies the maximum number of stack locations required.

Return Value:

    The function value is the address of the associated IRP or NULL, if the
    IRP could be allocated.

--*/

{
    USHORT allocateSize;
    UCHAR fixedSize;
    PIRP associatedIrp;
    PGENERAL_LOOKASIDE lookasideList;
    PP_NPAGED_LOOKASIDE_NUMBER number;
    USHORT packetSize;
    PKPRCB prcb;
    CCHAR   largeIrpStackLocations;

    //
    // If the size of the packet required is less than or equal to those on
    // the lookaside lists, then attempt to allocate the packet from the
    // lookaside lists.
    //


    associatedIrp = NULL;
    fixedSize = 0;
    packetSize = IoSizeOfIrp(StackSize);
    allocateSize = packetSize;
    largeIrpStackLocations = (CCHAR)IopLargeIrpStackLocations;

    if (StackSize <= largeIrpStackLocations) {
        fixedSize = IRP_ALLOCATED_FIXED_SIZE;
        number = LookasideSmallIrpList;
        if (StackSize != 1) {
            allocateSize = IoSizeOfIrp(largeIrpStackLocations);
            number = LookasideLargeIrpList;
        }

        prcb = KeGetCurrentPrcb();
        lookasideList = prcb->PPLookasideList[number].P;
        lookasideList->TotalAllocates += 1;
        associatedIrp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);

        if (associatedIrp == NULL) {
            lookasideList->AllocateMisses += 1;
            lookasideList = prcb->PPLookasideList[number].L;
            lookasideList->TotalAllocates += 1;
            associatedIrp = (PIRP)InterlockedPopEntrySList(&lookasideList->ListHead);
            if (!associatedIrp) {
                lookasideList->AllocateMisses += 1;
            }
        }

        if (IopIrpAutoSizingEnabled() && associatedIrp) {

            //
            // See if this IRP is a stale entry. If so just free it.
            // This can happen if we decided to change the lookaside list size.
            // We need to get the size of the IRP from the information field as the
            // size field is overlaid with the single list entry.
            //

            if (associatedIrp->IoStatus.Information < packetSize) {
                lookasideList->TotalFrees += 1;
                ExFreePool(associatedIrp);
                associatedIrp = NULL;
            } else {

                //
                // Update allocateSize to the correct value.
                //
                allocateSize = (USHORT)associatedIrp->IoStatus.Information;
            }
        }
    }

    //
    // If an IRP was not allocated from the lookaside list, then allocate
    // the packet from nonpaged pool.
    //

    if (!associatedIrp) {

        //
        // There are no free packets on the lookaside list, or the packet is
        // too large to be allocated from one of the lists, so it must be
        // allocated from general non-paged pool.
        //

        associatedIrp = ExAllocatePoolWithTag(NonPagedPool, allocateSize, ' prI');
        if (!associatedIrp) {
            return NULL;
        }

    }

    //
    // Initialize the packet.
    //

    IopInitializeIrp(associatedIrp, allocateSize, StackSize);
    associatedIrp->Flags |= IRP_ASSOCIATED_IRP;
    associatedIrp->Flags |= (Irp->Flags & IRP_HIGH_PRIORITY_PAGING_IO);
    associatedIrp->AllocationFlags |= (fixedSize);

    //
    // Set the thread ID to be that of the master.
    //

    associatedIrp->Tail.Overlay.Thread = Irp->Tail.Overlay.Thread;

    //
    // Now make the association between this packet and the master.
    //

    associatedIrp->AssociatedIrp.MasterIrp = Irp;
    return associatedIrp;
}



NTSTATUS
IoPageRead(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine provides a special, fast interface for the Pager to read pages
    in from the disk quickly and with very little overhead.  All of the special
    handling for this request is recognized by setting the IRP_PAGING_IO flag
    in the IRP flags word.  In-page operations are detected by using the IRP
    flag IRP_INPUT_OPERATION.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the read should be performed from.

    MemoryDescriptorList - An MDL which describes the physical pages that the
        pages should be read into from the disk.  All of the pages have been
        locked in memory.  The MDL also describes the length of the read
        operation.

        If the low bit of the MDL is set, then the I/O is issued asynchronously,
        otherwise it is done synchronously.

    StartingOffset - Pointer to the offset in the file from which the read
        should take place.

    Event - A pointer to a kernel event structure to be used for synchronization
        purposes.  The event will be set to the Signaled state once the in-page
        operation completes.

    IoStatusBlock - A pointer to the I/O status block in which the final status
        and information should be stored.

Return Value:

    The function value is the final status of the queue request to the I/O
    system subcomponents.

Notes:

    This routine is invoked at APC_LEVEL; this level is honored throughout the
    execution of the entire I/O request, including completion.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    //
    // Begin by getting a pointer to the device object that the file resides
    // on.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate an I/O Request Packet (IRP) for this in-page operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {
        if (MmIsFileObjectAPagingFile(FileObject)) {
            InterlockedIncrement(&IoPageReadIrpAllocationFailure);
            irp = IopAllocateReserveIrp(deviceObject->StackSize);
        } else {
            InterlockedIncrement(&IoPageReadNonPagefileIrpAllocationFailure);
        }

        if (!irp) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Get a pointer to the first stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP according to this request.
    //

    //
    // The low bit of the MDL is biased to indicate async behavior is desired.
    //

    if ((ULONG_PTR)MemoryDescriptorList & 0x1) {
        irp->Flags = IRP_PAGING_IO | IRP_NOCACHE | IRP_SET_USER_EVENT;
        MemoryDescriptorList = (PMDL) ((ULONG_PTR)MemoryDescriptorList & ~0x1);
    } else {
        irp->Flags = IRP_PAGING_IO | IRP_NOCACHE | IRP_SYNCHRONOUS_PAGING_IO | IRP_INPUT_OPERATION;
    }

    irp->MdlAddress = MemoryDescriptorList;

    irp->RequestorMode = KernelMode;
    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;
    irp->UserBuffer = (PVOID) ((PCHAR) MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset);
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the normal read parameters.
    //

    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = FileObject;
    irpSp->Parameters.Read.Length = MemoryDescriptorList->ByteCount;
    irpSp->Parameters.Read.ByteOffset = *StartingOffset;

    //
    // For debugging purposes.
    //

    IoStatusBlock->Information = (ULONG_PTR)irp;

    //
    // Increment performance counter.  The Cache Manager I/Os always are
    // "recursive".
    //

    if (MmIsRecursiveIoFault()) {
        *CcMissCounter += (MemoryDescriptorList->ByteCount + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // Queue the packet to the appropriate driver based on whether or not there
    // is a VPB associated with the device.
    //

    return IoCallDriver( deviceObject, irp );
}


NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FileInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FileInformationClass,
                                   Length,
                                   KernelMode,
                                   FileInformation,
                                   ReturnedLength,
                                   TRUE );
}

NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified volume.
    The information returned is determined by the FsInformationClass that
    is specified, and it is placed into the caller's FsInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

    Length - Supplies the length of the FsInformation buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FsInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FsInformationClass,
                                   Length,
                                   KernelMode,
                                   FsInformation,
                                   ReturnedLength,
                                   FALSE );
}

VOID
IoQueueThreadIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine queues the specified I/O Request Packet (IRP) to the current
    thread's IRP pending queue.  This queue locates all of the outstanding
    I/O requests for the thread.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) to be queued.

Return Value:

    None.

--*/

{
    //
    // Simply queue the packet using the internal queueing routine.
    //

    IopQueueThreadIrp( Irp );
}

VOID
IoRaiseHardError(
    IN PIRP Irp,
    IN PVPB Vpb OPTIONAL,
    IN PDEVICE_OBJECT RealDeviceObject
    )

/*++

Routine Description:

    This routine pops up a hard error in the context of the thread that
    originally requested the I/O operation specified by the input IRP.  This
    is done by queueing a kernel APC to the original thread, passing it a
    pointer to the device objects and the IRP.  Once the pop up is performed,
    the routine either completes the I/O request then, or it calls the driver
    back with the same IRP.

    If the original request was an IoPageRead, then it was at APC level and
    we have to create a thread to "hold" this pop-up.  Note that we have to
    queue to an ExWorker thread to create the thread since this can only be
    done from the system process.

Arguments:

    Irp - A pointer to the I/O Request Packet (IRP) for the request that
        failed.

    Vpb - This is the volume parameter block of the offending media.  If the
        media not yet mounted, this parameter should be absent.

    RealDeviceObject - A pointer to the device object that represents the
        device that the file system believes it has mounted.  This is
        generally the "real" device object in the VPB, but may, in fact,
        be a device object attached to the physical device.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    ULONG              irpFlags;
    PETHREAD           Thread;

    //
    // If pop-ups are disabled for the requesting thread, just complete the
    // request.
    //

    Thread = Irp->Tail.Overlay.Thread;

    if ((Thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0) {

        //
        // An error was incurred, so zero out the information field before
        // completing the request if this was an input operation.  Otherwise,
        // IopCompleteRequest will try to copy to the user's buffer.
        //

        if (Irp->Flags & IRP_INPUT_OPERATION) {
            Irp->IoStatus.Information = 0;
        }

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return;
    }

    //
    //  If this Irp resulted from a call to IoPageRead(), the caller must
    //  have been at APC level, so don't try enqueing an APC.
    //
    //  Also if this is a cleanup Irp, force this pop-up to go to the new
    //  thread so that it cannot be disabled.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    irpFlags = Irp->Flags & (~IRP_VERIFIER_MASK);
    if ((irpFlags == (IRP_PAGING_IO |
                        IRP_NOCACHE |
                        IRP_SYNCHRONOUS_PAGING_IO |
                        IRP_INPUT_OPERATION)) ||
        ((IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
         (IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME)) ||
        (IrpSp->MajorFunction == IRP_MJ_CLEANUP)) {

        PIOP_APC_HARD_ERROR_PACKET packet;

        //
        // Need to check here whether hard errors are disabled for the thread
        // as we will be in system context later and it will be too late
        //
        if ((IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
            !IS_SYSTEM_THREAD(Thread)) {

            NTSTATUS status;
            ULONG hardErrorMode;
            SIZE_T bytesCopied;
            BOOLEAN fail = TRUE;
            PEPROCESS process;

            process = THREAD_TO_PROCESS(Thread);

            if (process == PsGetCurrentProcess()) {
                PTEB Teb = Thread->Tcb.Teb;

                try {
                    if (!(Teb->HardErrorMode & RTL_ERRORMODE_FAILCRITICALERRORS)) {
                       fail = FALSE;
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    ;
                }
            } else {

                //
                // The issuing thread is in another process so we need to read the TEB from
                // that processes memory
                //
                status = MmCopyVirtualMemory(process,
                                         ((PUCHAR)Thread->Tcb.Teb) + FIELD_OFFSET(TEB, HardErrorMode),
                                         PsGetCurrentProcess(),
                                         &hardErrorMode,
                                         sizeof(hardErrorMode),
                                         KernelMode,
                                         &bytesCopied);

                if (NT_SUCCESS(status) && !(hardErrorMode & RTL_ERRORMODE_FAILCRITICALERRORS)) {
                    fail = FALSE;
                }
            }

            if (fail) {

                Irp->IoStatus.Information = 0;

                IoCompleteRequest( Irp, IO_DISK_INCREMENT );

                return;
            }
        }

        packet = ExAllocatePoolWithTag( NonPagedPool,
                                        sizeof( IOP_APC_HARD_ERROR_PACKET ),
                                        'rEoI' );

        if ( packet == NULL ) {

            IoCompleteRequest( Irp, IO_DISK_INCREMENT );
            return;
        }

        ExInitializeWorkItem( &packet->Item, IopStartApcHardError, packet );
        packet->Irp = Irp;
        packet->Vpb = Vpb;
        packet->RealDeviceObject = RealDeviceObject;

        ExQueueWorkItem( &packet->Item, CriticalWorkQueue );

    } else {

        PKAPC apc;

        //
        // Begin by allocating and initializing an APC that can be sent to the
        // target thread.
        //

        apc = ExAllocatePoolWithTag( NonPagedPool, sizeof( KAPC ), 'CPAK' );

        //
        // If we could not get the pool, we have no choice but to just complete
        // the Irp, thereby passing the error onto the caller.
        //

        if ( apc == NULL ) {

            IoCompleteRequest( Irp, IO_DISK_INCREMENT );
            return;
        }

        KeInitializeApc( apc,
                         &Thread->Tcb,
                         Irp->ApcEnvironment,
                         IopDeallocateApc,
                         IopAbortRequest,
                         IopRaiseHardError,
                         KernelMode,
                         Irp );

        (VOID) KeInsertQueueApc( apc,
                                 Vpb,
                                 RealDeviceObject,
                                 0 );
    }
}

BOOLEAN
IoRaiseInformationalHardError(
    IN NTSTATUS ErrorStatus,
    IN PUNICODE_STRING String OPTIONAL,
    IN PKTHREAD Thread OPTIONAL
    )
/*++

Routine Description:

    This routine pops up a hard error in the hard error popup thread.  The
    routine returns immediately, enqueuing the actual pop-up to a worker
    thread.  The hard error that is raised is informational in the sense that
    only the OK button is displayed.

Arguments:

    ErrorStatus - The error condition.

    String - Depending on the error, a string may have to be enqueued.

    Thread - If present, enqueue an APC to this thread rather than using
        the hard error thread.

Return Value:

    BOOLEAN - TRUE if we decided to dispatch a pop-up.  FALSE if we decided
        not to because:

        - pop-ups are disabled in the requested thread, or

        - a pool allocation failed, or

        - an equivalent pop-up is currently pending a user response (i.e.
          waiting for the user to press <OK>) or in the queue, or

        - too many pop-ups have already been queued.

--*/

//
//  This macro compares two pop-ups to see if they are content equivalent.
//

#define ArePacketsEquivalent(P1,P2) (                              \
    (P1->ErrorStatus == P2->ErrorStatus) &&                        \
    ((!P1->String.Buffer && !P2->String.Buffer) ||                 \
     ((P1->String.Length == P2->String.Length) &&                  \
      (RtlEqualMemory(P1->String.Buffer,                           \
                        P2->String.Buffer,                         \
                        P1->String.Length))))                      \
)

{
    KIRQL oldIrql;
    PVOID stringBuffer;
    PLIST_ENTRY links;

    PIOP_HARD_ERROR_PACKET hardErrorPacket;

    //
    // If pop-ups are disabled for the requesting thread, just return.
    //

    if (ARGUMENT_PRESENT(Thread) ?
        ((CONTAINING_RECORD(Thread, ETHREAD, Tcb)->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0) :
        ((PsGetCurrentThread()->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) != 0)) {

        return FALSE;
    }

    //
    // If this is one of those special error popup codes that CSRSS expects
    // to be called with a correct set of arguments, disallow from a driver
    //
    if ( ErrorStatus == STATUS_VDM_HARD_ERROR ||
         ErrorStatus == STATUS_UNHANDLED_EXCEPTION ||
         ErrorStatus == STATUS_SERVICE_NOTIFICATION ) {
        return FALSE;
    }

    //
    //  If this request is going to be sent to the hard error thread, and
    //  there are more than 25 entries already in the queue, don't
    //  add any more.  We'll do another safe check later on.
    //

    if ( !ARGUMENT_PRESENT( Thread ) &&
         (KeReadStateSemaphore( &IopHardError.WorkQueueSemaphore ) >=
          IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS) ) {

        return FALSE;
    } else {
        if (IopHardError.NumPendingApcPopups > IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS) {
            return FALSE;
        }
    }

    //
    //  Allocate the packet, and a buffer for the string if present.
    //

    hardErrorPacket = ExAllocatePoolWithTag( NonPagedPool,
                                             sizeof(IOP_HARD_ERROR_PACKET),
                                             'rEoI');

    if (!hardErrorPacket) { return FALSE; }

    //
    //  Zero out the packet and fill the NT_STATUS we will pop up.
    //

    RtlZeroMemory( hardErrorPacket, sizeof(IOP_HARD_ERROR_PACKET) );

    hardErrorPacket->ErrorStatus = ErrorStatus;

    //
    //  If there is a string, copy it.
    //

    if ( ARGUMENT_PRESENT( String ) && String->Length ) {

        stringBuffer = ExAllocatePoolWithTag( NonPagedPool,
                                              String->Length,
                                              'rEoI' );

        if (!stringBuffer) {
            ExFreePool( hardErrorPacket );
            return FALSE;
        }

        hardErrorPacket->String.Length = String->Length;
        hardErrorPacket->String.MaximumLength = String->Length;

        hardErrorPacket->String.Buffer = stringBuffer;

        RtlCopyMemory( stringBuffer, String->Buffer, String->Length );
    }

    //
    //  If there is an Thread, enqueue an APC for ourself, otherwise send
    //  it off to the to the hard error thread.
    //

    if ( ARGUMENT_PRESENT( Thread ) ) {

        PKAPC apc;

        //
        // Begin by allocating and initializing an APC that can be sent to the
        // target thread.
        //

        apc = ExAllocatePoolWithTag( NonPagedPool, sizeof( KAPC ), 'CPAK' );

        //
        // If we could not get the pool, we have no choice but to just
        // free the packet and return.
        //

        if ( apc == NULL ) {

            if ( hardErrorPacket->String.Buffer ) {
                ExFreePool( hardErrorPacket->String.Buffer );
            }

            ExFreePool( hardErrorPacket );

            return FALSE;
        }

        InterlockedIncrement(&IopHardError.NumPendingApcPopups);
        KeInitializeApc( apc,
                         Thread,
                         OriginalApcEnvironment,
                         IopDeallocateApc,
                         NULL,
                         IopRaiseInformationalHardError,
                         KernelMode,
                         hardErrorPacket );

        (VOID) KeInsertQueueApc( apc, NULL, NULL, 0 );

    } else {

        //
        //  Get exclusive access to the work queue.
        //

        ExAcquireSpinLock( &IopHardError.WorkQueueSpinLock, &oldIrql );

        //
        //  Check the Signal state again, if OK, go ahead and enqueue.
        //

        if ( KeReadStateSemaphore( &IopHardError.WorkQueueSemaphore ) >=
             IOP_MAXIMUM_OUTSTANDING_HARD_ERRORS ) {

            ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );

            if ( hardErrorPacket->String.Buffer ) {
                ExFreePool( hardErrorPacket->String.Buffer );
            }
            ExFreePool( hardErrorPacket );
            return FALSE;
        }

        //
        //  If there is a pop-up currently up, check for a match
        //

        if (IopCurrentHardError &&
            ArePacketsEquivalent( hardErrorPacket, IopCurrentHardError )) {

            ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );

            if ( hardErrorPacket->String.Buffer ) {
                ExFreePool( hardErrorPacket->String.Buffer );
            }
            ExFreePool( hardErrorPacket );
            return FALSE;
        }

        //
        //  Run down the list of queued pop-ups looking for a match.
        //

        links = IopHardError.WorkQueue.Flink;

        while (links != &IopHardError.WorkQueue) {

            PIOP_HARD_ERROR_PACKET queueHardErrorPacket;

            queueHardErrorPacket = CONTAINING_RECORD( links,
                                                      IOP_HARD_ERROR_PACKET,
                                                      WorkQueueLinks );

            if (ArePacketsEquivalent( hardErrorPacket,
                                      queueHardErrorPacket )) {

                ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );

                if ( hardErrorPacket->String.Buffer ) {
                    ExFreePool( hardErrorPacket->String.Buffer );
                }
                ExFreePool( hardErrorPacket );
                return FALSE;
            }

            links = links->Flink;
        }

        //
        //  Enqueue this packet.
        //

        InsertTailList( &IopHardError.WorkQueue,
                        &hardErrorPacket->WorkQueueLinks );

        //
        //  Bump the count on the semaphore so that the hard error thread
        //  will know that an entry has been placed in the queue.
        //

        (VOID) KeReleaseSemaphore( &IopHardError.WorkQueueSemaphore,
                                   0,
                                   1L,
                                   FALSE );

        //
        //  If we are not currently running in an ExWorkerThread, queue
        //  a work item.
        //

        if ( !IopHardError.ThreadStarted ) {
            IopHardError.ThreadStarted = TRUE;
            ExQueueWorkItem( &IopHardError.ExWorkItem, DelayedWorkQueue );
        }

        //
        //  Finally, release the spinlockevent, allowing access to the work queue again.
        //  The combination of releasing both the event and the semaphore will
        //  enable the thread to wake up and obtain the entry.
        //

        ExReleaseSpinLock( &IopHardError.WorkQueueSpinLock, oldIrql );
    }

    return TRUE;
}

VOID
IoRegisterBootDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked by boot drivers during their initialization or
    during their reinitialization to register with the I/O system to be
    called again once all devices have been enumerated and started.
    Note that it  is possible for this to occur during a normally running
    system, if the  driver is loaded dynamically, so all references to the
    reinitialization queue must be synchronized.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverReinitializationRoutine - The address of the reinitialization
        routine that is to be invoked.

    Context - Pointer to the context that is passed to the driver's
        reinitialization routine.

Return Value:

    None.

--*/

{
    PREINIT_PACKET reinitEntry;

    PAGED_CODE();

    //
    // Allocate a reinitialization entry to be inserted onto the list.  Note
    // that if the entry cannot be allocated, then the request is simply
    // dropped on the floor.
    //

    reinitEntry = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof( REINIT_PACKET ),
                                         'iRoI' );
    if (!reinitEntry) {
        return;
    }

    DriverObject->Flags |= DRVO_BOOTREINIT_REGISTERED;
    reinitEntry->DriverObject = DriverObject;
    reinitEntry->DriverReinitializationRoutine = DriverReinitializationRoutine;
    reinitEntry->Context = Context;

    IopInterlockedInsertTailList( &IopBootDriverReinitializeQueueHead,
                                  &reinitEntry->ListEntry );
}

VOID
IoRegisterDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_REINITIALIZE DriverReinitializationRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked by drivers during their initialization or during
    their reinitialization to register with the I/O system to be called again
    before I/O system initialization is complete.  Note that it is possible
    for this to occur during a normally running system, if the driver is
    loaded dynamically, so all references to the reinitialization queue must
    be synchronized.

Arguments:

    DriverObject - Pointer to the driver's driver object.

    DriverReinitializationRoutine - The address of the reinitialization
        routine that is to be invoked.

    Context - Pointer to the context that is passed to the driver's
        reinitialization routine.

Return Value:

    None.

--*/

{
    PREINIT_PACKET reinitEntry;

    PAGED_CODE();

    //
    // Allocate a reinitialization entry to be inserted onto the list.  Note
    // that if the entry cannot be allocated, then the request is simply
    // dropped on the floor.
    //

    reinitEntry = ExAllocatePoolWithTag( NonPagedPool,
                                         sizeof( REINIT_PACKET ),
                                         'iRoI' );
    if (!reinitEntry) {
        return;
    }

    DriverObject->Flags |= DRVO_REINIT_REGISTERED;
    reinitEntry->DriverObject = DriverObject;
    reinitEntry->DriverReinitializationRoutine = DriverReinitializationRoutine;
    reinitEntry->Context = Context;

    IopInterlockedInsertTailList( &IopDriverReinitializeQueueHead,
                                  &reinitEntry->ListEntry );
}

VOID
IoRegisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine inserts the device object for the file system which the device
    object represents into the list of file systems in the system.

Arguments:

    DeviceObject - Pointer to device object for the file system.

Return Value:

    None.


--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY listHead = NULL;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Allocate the I/O database resource for a write operation.
    //

    (VOID) ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Insert the device object into the appropriate file system queue based on
    // the driver type in the device object.  Notice that if the device type is
    // unrecognized, the file system is simply not registered.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) {
        listHead = &IopNetworkFileSystemQueueHead;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_CD_ROM_FILE_SYSTEM) {
        listHead = &IopCdRomFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
        listHead = &IopDiskFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    } else if (DeviceObject->DeviceType == FILE_DEVICE_TAPE_FILE_SYSTEM) {
        listHead = &IopTapeFileSystemQueueHead;
        DeviceObject->DriverObject->Flags |= DRVO_BASE_FILESYSTEM_DRIVER;
    }

    //
    //  Low priority filesystems are inserted one-from-back on the queue (ahead of
    //  raw, behind everything else), as opposed to on the front.
    //

    if (listHead != NULL) {
        if (DeviceObject->Flags & DO_LOW_PRIORITY_FILESYSTEM ) {
            InsertTailList( listHead->Blink,
                            &DeviceObject->Queue.ListEntry );
        } else {
            InsertHeadList( listHead,
                            &DeviceObject->Queue.ListEntry );
        }
    }

    IopFsRegistrationOps++;

    //
    // Ensure that this file system's device is operable.
    //

    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Notify all of the registered drivers that this file system has been
    // registered as an active file system of some type.
    //

    entry = IopFsNotifyChangeQueueHead.Flink;
    while (entry != &IopFsNotifyChangeQueueHead) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        entry = entry->Flink;
        nPacket->NotificationRoutine( DeviceObject, TRUE );
    }

    //
    // Release the I/O database resource.
    //

    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Increment the number of reasons that this driver cannot be unloaded.
    //

    IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );
}

VOID
IopNotifyAlreadyRegisteredFileSystems(
    IN PLIST_ENTRY  ListHead,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine,
    IN BOOLEAN SkipRaw
    )
/*++

Routine Description:

    This routine calls the driver notification routine for filesystems
    that have already been registered at the time of the call.

Arguments:

    ListHead - Pointer to the filesystem registration list head.
    DriverNotificationRoutine - Pointer to the routine that has to be called.

Return Value:

    None.

--*/
{
    PLIST_ENTRY entry;
    PDEVICE_OBJECT fsDeviceObject;

    entry = ListHead->Flink;
    while (entry != ListHead) {

        //
        // Skip raw filesystem notification
        //
        if ((entry->Flink == ListHead) && (SkipRaw)) {
            break;
        }

        fsDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );
        entry = entry->Flink;
        DriverNotificationRoutine( fsDeviceObject, TRUE );
    }
}


NTSTATUS
IoRegisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    )

/*++

Routine Description:

    This routine registers the specified driver's notification routine to be
    invoked whenever a file system registers or unregisters itself as an active
    file system in the system.

Arguments:

    DriverObject - Pointer to the driver object for the driver.

    DriverNotificationRoutine - Address of routine to invoke when a file system
        registers or unregisters itself.

Return Value:

    STATUS_DEVICE_ALREADY_ATTACHED -
                Indicates that the caller has already registered
                last with the same driver object & driver notification

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_SUCCESS

--*/

{
    PNOTIFICATION_PACKET nPacket;

    PAGED_CODE();

    ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    if (!IsListEmpty( &IopFsNotifyChangeQueueHead )) {

        //
        // Retrieve entry at tail of list
        //

        nPacket = CONTAINING_RECORD( IopFsNotifyChangeQueueHead.Blink, NOTIFICATION_PACKET, ListEntry );

        if ((nPacket->DriverObject == DriverObject) &&
            (nPacket->NotificationRoutine == DriverNotificationRoutine)) {

            ExReleaseResourceLite( &IopDatabaseResource);
            return STATUS_DEVICE_ALREADY_ATTACHED;
        }
    }

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    nPacket = ExAllocatePoolWithTag( PagedPool|POOL_COLD_ALLOCATION,
                                     sizeof( NOTIFICATION_PACKET ),
                                     'sFoI' );
    if (!nPacket) {

        ExReleaseResourceLite( &IopDatabaseResource );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the notification packet and insert it onto the tail of the
    // list.
    //

    nPacket->DriverObject = DriverObject;
    nPacket->NotificationRoutine = DriverNotificationRoutine;

    InsertTailList( &IopFsNotifyChangeQueueHead, &nPacket->ListEntry );

    IopNotifyAlreadyRegisteredFileSystems(&IopNetworkFileSystemQueueHead, DriverNotificationRoutine, FALSE);
    IopNotifyAlreadyRegisteredFileSystems(&IopCdRomFileSystemQueueHead, DriverNotificationRoutine, TRUE);
    IopNotifyAlreadyRegisteredFileSystems(&IopDiskFileSystemQueueHead, DriverNotificationRoutine, TRUE);
    IopNotifyAlreadyRegisteredFileSystems(&IopTapeFileSystemQueueHead, DriverNotificationRoutine, TRUE);

    //
    // Notify this driver about all already notified filesystems
    // registered as an active file system of some type.
    //


    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Increment the number of reasons that this driver cannot be unloaded.
    //

    ObReferenceObject( DriverObject );

    return STATUS_SUCCESS;
}


NTSTATUS
IoRegisterLastChanceShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows a driver to register that it would like to have its
    shutdown routine invoked at very late in system shutdown.  This gives
    the driver an opportunity to get control just before the system is fully
    shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PSHUTDOWN_PACKET shutdown;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    shutdown = ExAllocatePoolWithTag( NonPagedPool,
                                      sizeof( SHUTDOWN_PACKET ),
                                      'hSoI' );
    if (!shutdown) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the shutdown packet and insert it onto the head of the list.
    // Note that this is done because some drivers have dependencies on LIFO
    // notification ordering.
    //

    ObReferenceObject(DeviceObject);    // Ensure that the driver remains
    shutdown->DeviceObject = DeviceObject;

    IopInterlockedInsertHeadList( &IopNotifyLastChanceShutdownQueueHead,
                                  &shutdown->ListEntry );

    //
    // Do the bookkeeping to indicate that this driver has successfully
    // registered a shutdown notification routine.
    //

    DeviceObject->Flags |= DO_SHUTDOWN_REGISTERED;

    return STATUS_SUCCESS;
}

NTSTATUS
IoRegisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine allows a driver to register that it would like to have its
    shutdown routine invoked when the system is being shutdown.  This gives
    the driver an opportunity to get control just before the system is fully
    shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PSHUTDOWN_PACKET shutdown;

    PAGED_CODE();

    //
    // Begin by attempting to allocate storage for the shutdown packet.  If
    // one cannot be allocated, simply return an appropriate error.
    //

    shutdown = ExAllocatePoolWithTag( NonPagedPool,
                                      sizeof( SHUTDOWN_PACKET ),
                                      'hSoI' );
    if (!shutdown) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the shutdown packet and insert it onto the head of the list.
    // Note that this is done because some drivers have dependencies on LIFO
    // notification ordering.
    //

    shutdown->DeviceObject = DeviceObject;
    ObReferenceObject(DeviceObject);    // Ensure that the driver remains

    IopInterlockedInsertHeadList( &IopNotifyShutdownQueueHead,
                                  &shutdown->ListEntry );

    //
    // Do the bookkeeping to indicate that this driver has successfully
    // registered a shutdown notification routine.
    //

    DeviceObject->Flags |= DO_SHUTDOWN_REGISTERED;

    return STATUS_SUCCESS;
}

VOID
IoReleaseCancelSpinLock(
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to release the cancel spin lock.  This spin lock
    must be acquired before setting the address of a cancel routine in an
    IRP and released after the cancel routine has been set.

Arguments:

    Irql - Supplies the IRQL value returned from acquiring the spin lock.

Return Value:

    None.

--*/

{
    //
    // Simply release the cancel spin lock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoCancelLock, Irql );
}

VOID
IoReleaseVpbSpinLock(
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked to release the Volume Parameter Block (VPB) spin
    lock.  This spin lock must be acquired before accessing the mount flag,
    reference count, and device object fields of a VPB.

Arguments:

    Irql - Supplies the IRQL value returned from acquiring the spin lock.

Return Value:

    None.

--*/

{
    //
    // Simply release the VPB spin lock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, Irql );
}

VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to remove the access and share access information
    in a file system Share Access structure for a given open instance.

Arguments:

    FileObject - Pointer to the file object of the current access being closed.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // If this accessor wanted some type of access other than READ_ or
    // WRITE_ATTRIBUTES, then account for the fact that he has closed the
    // file.  Otherwise, he hasn't been accounted for in the first place
    // so don't do anything.
    //

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {
            return;
        }
    }

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount--;

        //
        // For each access type, decrement the appropriate count in the Share
        // Access structure.
        //

        if (FileObject->ReadAccess) {
            ShareAccess->Readers--;
        }

        if (FileObject->WriteAccess) {
            ShareAccess->Writers--;
        }

        if (FileObject->DeleteAccess) {
            ShareAccess->Deleters--;
        }

        //
        // For each shared access type, decrement the appropriate count in the
        // Share Access structure.
        //

        if (FileObject->SharedRead) {
            ShareAccess->SharedRead--;
        }

        if (FileObject->SharedWrite) {
            ShareAccess->SharedWrite--;
        }

        if (FileObject->SharedDelete) {
            ShareAccess->SharedDelete--;
        }
    }
}

VOID
IoSetDeviceToVerify(
    IN PETHREAD Thread,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine sets the device to verify field in the thread object.  This
    function is invoked by file systems to NULL this field, or to set it to
    predefined values.

Arguments:

    Thread - Pointer to the thread whose field is to be set.

    DeviceObject - Pointer to the device to be verified, or NULL, or ...

Return Value:

    None.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply set the device to be verified in the specified thread.
    //

    Thread->DeviceToVerify = DeviceObject;
}

VOID
IoSetHardErrorOrVerifyDevice(
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked when a driver realizes that the media
    has possibly changed on a device, and it must be verified before
    continuing, or a hard error has occured.  The device is stored
    in the thread local storage of the Irp's originating thread.

Arguments:

    Irp - Pointer to an I/O Request Packet to get the thread.

    DeviceObject - This is the device that needs to be verified.

Return Value:

    None.

--*/

{

    //
    // If this IRP is not associated with a thread do nothing.
    // Its a defensive check to catch drivers that pass
    // all kinds of IRPs to this routine.
    //

    if (!Irp->Tail.Overlay.Thread) {
        return;
    }


    //
    // Store the address of the device object that needs verification in
    // the appropriate field of the thread pointed to by the specified I/O
    // Request Packet.
    //



    Irp->Tail.Overlay.Thread->DeviceToVerify = DeviceObject;
}

NTSTATUS
IoSetInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    IN PVOID FileInformation
    )

/*++

Routine Description:

    This routine sets the requested information for the specified file.
    The information that is set is determined by the FileInformationClass
    parameter, and the information itself is passed in the FileInformation
    buffer.

Arguments:

    FileObject - Supplies a pointer to the file object for the file that
        is to be changed.

    FileInformationClass - Specifies the type of information that should
        be set on the file.

    Length - Supplies the length of the FileInformation buffer in bytes.

    FileInformation - A buffer containing the file information to set.  This
        buffer must not be pageable and must reside in system space.

Return Value:

    The status returned is the final completion status of the operation.


--*/

{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    HANDLE targetHandle = NULL;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //

    ObReferenceObject( FileObject );

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then initialize the local event.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( FileObject )) {
            status = IopAcquireFileObjectLock( FileObject,
                                               KernelMode,
                                               (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( FileObject );
                return status;
            }
        }
        KeClearEvent( &FileObject->Event );
        synchronousIo = TRUE;
    } else {
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case there is
    // not enough memory to satisfy the request.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( FileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
    } else {
        irp->UserEvent = &event;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->UserIosb = &localIoStatus;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    // Set the system buffer address to the address of the caller's buffer and
    // set the flags so that the buffer is not deallocated.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;
    irp->Flags |= IRP_BUFFERED_IO;

    //
    // Copy the caller's parameters to the service-specific portion of the IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants to
    // set is device independent (I/O system dependent).  If this is the case,
    // then the request can be satisfied here without having to have all of
    // the drivers implement the same code.  Note that having the IRP is still
    // necessary since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = FileInformation;

        //
        // Set or clear the appropriate flags in the file object.
        //

        if (!(FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)) {
            if (modeBuffer->Mode & FILE_WRITE_THROUGH) {
                FileObject->Flags |= FO_WRITE_THROUGH;
            } else {
                FileObject->Flags &= ~FO_WRITE_THROUGH;
            }
        }

        if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
            FileObject->Flags |= FO_SEQUENTIAL_ONLY;
        } else {
            FileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
        }

        if (modeBuffer->Mode & FO_SYNCHRONOUS_IO) {
            if (modeBuffer->Mode & FILE_SYNCHRONOUS_IO_ALERT) {
                FileObject->Flags |= FO_ALERTABLE_IO;
            } else {
                FileObject->Flags &= ~FO_ALERTABLE_IO;
            }
        }

        status = STATUS_SUCCESS;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

        IoSetNextIrpStackLocation( irp );
        IoCompleteRequest( irp, 0 );

    } else if (FileInformationClass == FileRenameInformation ||
               FileInformationClass == FileLinkInformation ||
               FileInformationClass == FileMoveClusterInformation) {

        //
        // Note that the following code assumes that a rename information
        // and a set link information structure look exactly the same.
        //

        PFILE_RENAME_INFORMATION renameBuffer = FileInformation;

        //
        // Copy the value of the replace BOOLEAN (or the ClusterCount field)
        // from the caller's buffer to the I/O stack location parameter
        // field where it is expected by file systems.
        //

        if (FileInformationClass == FileMoveClusterInformation) {
            irpSp->Parameters.SetFile.ClusterCount =
                ((FILE_MOVE_CLUSTER_INFORMATION *) renameBuffer)->ClusterCount;
        } else {
            irpSp->Parameters.SetFile.ReplaceIfExists = renameBuffer->ReplaceIfExists;
        }

        //
        // Check to see whether or not a fully qualified pathname was supplied.
        // If so, then more processing is required.
        //

        if (renameBuffer->FileName[0] == (UCHAR) OBJ_NAME_PATH_SEPARATOR ||
            renameBuffer->RootDirectory != NULL) {

            //
            // A fully qualified file name was specified as the target of the
            // rename operation.  Attempt to open the target file and ensure
            // that the replacement policy for the file is consistent with the
            // caller's request, and ensure that the file is on the same volume.
            //

            status = IopOpenLinkOrRenameTarget( &targetHandle,
                                                irp,
                                                renameBuffer,
                                                FileObject );
            if (!NT_SUCCESS( status )) {
                IoSetNextIrpStackLocation( irp );
                IoCompleteRequest( irp, 2 );

            } else {

                //
                // The fully qualified file name specifies a file on the same
                // volume and if it exists, then the caller specified that it
                // should be replaced.
                //

                status = IoCallDriver( deviceObject, irp );

            }

        } else {

            //
            // This is a simple rename operation, so call the driver and let
            // it perform the rename operation within the same directory as
            // the source file.
            //

            status = IoCallDriver( deviceObject, irp );

        }

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (synchronousIo) {
        if (status == STATUS_PENDING) {
            status = KeWaitForSingleObject( &FileObject->Event,
                                            Executive,
                                            KernelMode,
                                            (BOOLEAN) ((FileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );
            if (status == STATUS_ALERTED) {
                IopCancelAlertedRequest( &FileObject->Event, irp );
            }
            status = localIoStatus.Status;
        }
        IopReleaseFileObjectLock( FileObject );

    } else {

        //
        // This is a normal synchronous I/O operation, as opposed to a
        // serialized synchronous I/O operation.  For this case, wait for
        // the local event and copy the final status information back to
        // the caller.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = localIoStatus.Status;
        }
    }

    //
    // If a target handle was created because of a rename operation, close
    // the handle now.
    //

    if (targetHandle != (HANDLE) NULL) {
        ObCloseHandle( targetHandle , KernelMode);
    }

    return status;
}

VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to set the access and share access information
    in a file system Share Access structure for the first open.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    BOOLEAN update = TRUE;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {

            //
            //  This fileobject is marked to ignore share access checks
            //  so we also don't want to affect the file/directory's
            //  ShareAccess structure counts.
            //

            update = FALSE;
        }
    }

    //
    // Check to see whether the current file opener would like to read,
    // write, or delete the file.  If so, account for it in the share access
    // structure; otherwise, skip it.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Only update the share modes if the user wants to read, write or
        // delete the file.
        //

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        if (update) {

            //
            // Set the Share Access structure open count.
            //

            ShareAccess->OpenCount = 1;

            //
            // Set the number of readers, writers, and deleters in the Share Access
            // structure.
            //

            ShareAccess->Readers = FileObject->ReadAccess;
            ShareAccess->Writers = FileObject->WriteAccess;
            ShareAccess->Deleters = FileObject->DeleteAccess;

            //
            // Set the number of shared readers, writers, and deleters in the Share
            // Access structure.
            //

            ShareAccess->SharedRead = FileObject->SharedRead;
            ShareAccess->SharedWrite = FileObject->SharedWrite;
            ShareAccess->SharedDelete = FileObject->SharedDelete;
        }

    } else {

        //
        // No read, write, or delete access has been requested.  Simply zero
        // the appropriate fields in the structure so that the next accessor
        // sees a consistent state.
        //

        if (update) {

            ShareAccess->OpenCount = 0;
            ShareAccess->Readers = 0;
            ShareAccess->Writers = 0;
            ShareAccess->Deleters = 0;
            ShareAccess->SharedRead = 0;
            ShareAccess->SharedWrite = 0;
            ShareAccess->SharedDelete = 0;
        }
    }
}

BOOLEAN
IoSetThreadHardErrorMode(
    IN BOOLEAN EnableHardErrors
    )

/*++

Routine Description:

    This routine either enables or disables hard errors for the current
    thread and returns the old state of the flag.

Arguments:

    EnableHardErrors - Supplies a BOOLEAN value indicating whether or not
        hard errors are to be enabled for the current thread.

Return Value:

    The final function value is the previous state of whether or not hard
    errors were enabled.

--*/

{
    PETHREAD thread;
    BOOLEAN oldFlag;

    //
    // Get a pointer to the current thread, capture the current state of
    // hard errors, and set the new state.
    //

    thread = PsGetCurrentThread();

    if ((thread->CrossThreadFlags&PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED) == 0) {
        oldFlag = TRUE;
    }
    else {
        oldFlag = FALSE;
    }

    if (EnableHardErrors) {
        PS_CLEAR_BITS (&thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    } else {
        PS_SET_BITS (&thread->CrossThreadFlags, PS_CROSS_THREAD_FLAGS_HARD_ERRORS_DISABLED);
    }

    return oldFlag;
}

VOID
IoSetTopLevelIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sets the top level IRP field in the current thread's thread
    object.  This function is invoked by file systems to either set this field
    to the address of an I/O Request Packet (IRP) or to null it.

Arguments:

    Irp - Pointer to the IRP to be stored in the top level IRP field.

Return Value:

    None.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.

--*/

{
    //
    // Simply set the top level IRP field in the current thread's thread
    // object.
    //

    PsGetCurrentThread()->TopLevelIrp = (ULONG_PTR) Irp;
    return;
}

VOID
IoShutdownSystem (
    IN ULONG Phase
    )

/*++

Routine Description:

    This routine shuts down the I/O portion of the system in preparation
    for a power-off or reboot.

Arguments:

    RebootPending - Indicates whether a reboot is imminently pending.

    Phase - Indicates which phase of shutdown is being performed.

Return Value:

    None

--*/

{
    PSHUTDOWN_PACKET shutdown;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;
    PLIST_ENTRY entry;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    PAGED_CODE();

    //
    // Initialize the event used to synchronize the complete of all of the
    // shutdown routines.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    if (Phase == 0) {

        ZwClose(IopLinkTrackingServiceEventHandle);

        IoShutdownPnpDevices();

        //
        // Walk the list of the drivers in the system that have registered
        // themselves as wanting to know when the system is about to be
        // shutdown and invoke each.
        //

        while ((entry = IopInterlockedRemoveHeadList( &IopNotifyShutdownQueueHead )) != NULL) {
            shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );

            //
            // Another driver has been found that has indicated that it requires
            // shutdown notification.  Invoke the driver's shutdown entry point.
            //

            deviceObject = IoGetAttachedDeviceReference( shutdown->DeviceObject );

            irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                deviceObject,
                                                (PVOID) NULL,
                                                0,
                                                (PLARGE_INTEGER) NULL,
                                                &event,
                                                &ioStatus );

            //
            // If we get an IRP issue the shutdown. Otherwise just skip the driver. Its unfortunate but even
            // drivers if they fail in memory allocations on shutdown have to skip it.
            //

            if (irp) {
                if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
#if DBG
                    PUNICODE_STRING DeviceName = ObGetObjectName( shutdown->DeviceObject );

                    DbgPrint( "IO: Waiting for shutdown of device object (%x) - %wZ\n",
                              shutdown->DeviceObject,
                              DeviceName
                            );
#endif // DBG
                    (VOID) KeWaitForSingleObject( &event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  (PLARGE_INTEGER) NULL );
                }
            }

            ObDereferenceObject(deviceObject);
            ObDereferenceObject(shutdown->DeviceObject);
            ExFreePool( shutdown );
            KeClearEvent( &event );
        }

        IOV_UNLOAD_DRIVERS();

    } else if (Phase == 1) {

#if defined(REMOTE_BOOT)
        //
        // If this is a remote boot client then allow the cache to close the database and
        // mark it clean.
        //

        IopShutdownCsc();
#endif // defined(REMOTE_BOOT)

        // Gain access to the file system header queues by acquiring the
        // database resource for shared access.
        //

        ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

        IopShutdownBaseFileSystems(&IopDiskFileSystemQueueHead);

        IopShutdownBaseFileSystems(&IopCdRomFileSystemQueueHead);

        IopShutdownBaseFileSystems(&IopTapeFileSystemQueueHead);


        //
        // Walk the list of the drivers in the system that have registered
        // themselves as wanting to know at the last chance when the system
        // is about to be shutdown and invoke each.
        //

        while ((entry = IopInterlockedRemoveHeadList( &IopNotifyLastChanceShutdownQueueHead )) != NULL) {
            shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );

            //
            // Another driver has been found that has indicated that it requires
            // shutdown notification.  Invoke the driver's shutdown entry point.
            //

            deviceObject = IoGetAttachedDeviceReference( shutdown->DeviceObject );

            irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                deviceObject,
                                                (PVOID) NULL,
                                                0,
                                                (PLARGE_INTEGER) NULL,
                                                &event,
                                                &ioStatus );

            if (irp) {
                if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
#if DBG
                    PUNICODE_STRING DeviceName = ObGetObjectName( shutdown->DeviceObject );

                    DbgPrint( "IO: Waiting for last chance shutdown of device object (%x) - %wZ\n",
                              shutdown->DeviceObject,
                              DeviceName
                            );
#endif // DBG
                    (VOID) KeWaitForSingleObject( &event,
                                                  Executive,
                                                  KernelMode,
                                                  FALSE,
                                                  (PLARGE_INTEGER) NULL );
                }
            }

            ObDereferenceObject(deviceObject);
            ObDereferenceObject(shutdown->DeviceObject);

            ExFreePool( shutdown );
            KeClearEvent( &event );
        }

        //
        // N.B. The system has stopped.  The IopDatabaseResource lock is
        // not released so that no other mount operations can take place.
        //
        // ExReleaseResourceLite( &IopDatabaseResource );
        //
    }

    return ;
}

VOID
IopShutdownBaseFileSystems(
    IN PLIST_ENTRY  ListHead
    )
{
    PLIST_ENTRY entry;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PDEVICE_OBJECT baseDeviceObject;
    PDEVICE_OBJECT deviceObject;
    PIRP    irp;

    //
    // Loop through each of the disk file systems, invoking each to shutdown
    // each of their mounted volumes.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    entry = RemoveHeadList(ListHead);

    while (entry != ListHead) {

        baseDeviceObject = CONTAINING_RECORD( entry, DEVICE_OBJECT, Queue.ListEntry );

        //
        // We have removed the entry. If the filesystem in this thread calls IoUnregisterFileSystem
        // then we won't remove the entry from the list as the Flink == NULL.
        //


        baseDeviceObject->Queue.ListEntry.Flink = NULL;
        baseDeviceObject->Queue.ListEntry.Blink = NULL;

        //
        // Prevent the driver from getting unloaded while shutdown handler is in progress.
        // Also prevent the base device object from going away as we need to decrement the
        // reasons for unload count later.
        //

        ObReferenceObject(baseDeviceObject);
        IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                      &baseDeviceObject->ReferenceCount );

        deviceObject = baseDeviceObject;
        if (baseDeviceObject->AttachedDevice) {
            deviceObject = IoGetAttachedDevice( baseDeviceObject );
        }

        //
        // Another file system has been found.  Invoke this file system at
        // its shutdown entry point.
        //

        irp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                            deviceObject,
                                            (PVOID) NULL,
                                            0,
                                            (PLARGE_INTEGER) NULL,
                                            &event,
                                            &ioStatus );
        //
        // Its possible that the drivers are unloaded before this call returns but IoCallDriver
        // takes a reference to the device object before calling the driver. So the image will not
        // get unloaded.
        //

        if (irp) {
            if (IoCallDriver( deviceObject, irp ) == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            }
        }
        entry = RemoveHeadList(ListHead);

        KeClearEvent( &event );

        IopDecrementDeviceObjectRef(baseDeviceObject, FALSE, TRUE);
        ObDereferenceObject(baseDeviceObject);
    }
}


VOID
IopStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN LOGICAL Cancelable
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.  If the Cancelable parameter is TRUE, then the update of
    current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/

{
    KIRQL cancelIrql = PASSIVE_LEVEL;
    PIRP irp;
    PKDEVICE_QUEUE_ENTRY packet;

    //
    // Begin by checking to see whether or not this driver's requests are
    // to be considered cancelable.  If so, then acquire the cancel spinlock.
    //

    if (Cancelable) {
        IoAcquireCancelSpinLock( &cancelIrql );
    }

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Remove the next packet from the head of the queue.  If a packet was
    // found, then process it.
    //

    packet = KeRemoveDeviceQueue( &DeviceObject->DeviceQueue );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was located so make it the current packet for this
        // device.
        //

        DeviceObject->CurrentIrp = irp;
        if (Cancelable) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                irp->CancelRoutine = NULL;
            }

           IoReleaseCancelSpinLock( cancelIrql );
        }

        //
        // Invoke the driver's start I/O routine for this packet.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );
    } else {

        //
        // No packet was found, so simply release the cancel spinlock if
        // it was acquired.
        //

        if (Cancelable) {
           IoReleaseCancelSpinLock( cancelIrql );
        }
    }
}

VOID
IopStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN LOGICAL Cancelable,
    IN ULONG Key
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue by key and invoke the device driver's start
    I/O routine for it.  If the Cancelable parameter is TRUE, then the
    update of current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/

{
    KIRQL                cancelIrql = PASSIVE_LEVEL;
    PIRP                 irp;
    PKDEVICE_QUEUE_ENTRY packet;

    //
    // Begin by determining whether or not requests for this device are to
    // be considered cancelable.  If so, then acquire the cancel spinlock.
    //

    if (Cancelable) {
        IoAcquireCancelSpinLock( &cancelIrql );
    }

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Attempt to remove the indicated packet according to the key from the
    // device queue.  If one is found, then process it.
    //

    packet = KeRemoveByKeyDeviceQueue( &DeviceObject->DeviceQueue, Key );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was successfully located.  Make it the current packet
        // and invoke the driver's start I/O routine for it.
        //

        DeviceObject->CurrentIrp = irp;

        if (Cancelable) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                irp->CancelRoutine = NULL;
            }

           IoReleaseCancelSpinLock( cancelIrql );
        }

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );

    } else {

        //
        // No packet was found, so release the cancel spinlock if it was
        // acquired.
        //

        if (Cancelable) {
           IoReleaseCancelSpinLock( cancelIrql );
        }
    }
}

VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL,
    IN PDRIVER_CANCEL CancelFunction OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to start the specified packet request (IRP) on the
    specified device.  If the device is already busy, then the packet is
    simply queued to the device queue. If a non-NULL CancelFunction is
    supplied, it will be put in the IRP.  If the IRP has been canceled, the
    CancelFunction will be called after the IRP has been inserted into the
    queue or made the current packet.

Arguments:

    DeviceObject - Pointer to device object itself.

    Irp - I/O Request Packet which should be started on the device.

    Key - Key to be used in inserting packet into device queue;  optional
        (if not specified, then packet is inserted at the tail).

    CancelFunction - Pointer to an optional cancel routine.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    KIRQL cancelIrql = PASSIVE_LEVEL;
    BOOLEAN i;

    //
    // Raise the IRQL of the processor to dispatch level for synchronization.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    //
    // If the driver has indicated that packets are cancelable, then acquire
    // the cancel spinlock and set the address of the cancel function to
    // indicate that the packet is not only cancelable, but indicates what
    // routine to invoke should it be cancelled.
    //

    if (CancelFunction) {
        IoAcquireCancelSpinLock( &cancelIrql );
        Irp->CancelRoutine = CancelFunction;
    }

    //
    // If a key parameter was specified, then insert the request into the
    // work queue according to the key;  otherwise, simply insert it at the
    // tail.
    //

    if (Key) {
        i = KeInsertByKeyDeviceQueue( &DeviceObject->DeviceQueue,
                                      &Irp->Tail.Overlay.DeviceQueueEntry,
                                      *Key );
    } else {
        i = KeInsertDeviceQueue( &DeviceObject->DeviceQueue,
                                 &Irp->Tail.Overlay.DeviceQueueEntry );
    }

    //
    // If the packet was not inserted into the queue, then this request is
    // now the current packet for this device.  Indicate so by storing its
    // address in the current IRP field, and begin processing the request.
    //

    if (!i) {

        DeviceObject->CurrentIrp = Irp;

        if (CancelFunction) {

            //
            // If the driver does not want the IRP in the cancelable state
            // then set the routine to NULL
            //

            if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_NO_CANCEL) {
                Irp->CancelRoutine = NULL;
            }

            IoReleaseCancelSpinLock( cancelIrql );
        }

        //
        // Invoke the driver's start I/O routine to get the request going on the device.
        // The StartIo routine should handle the cancellation.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, Irp );

    } else {

        //
        // The packet was successfully inserted into the device's work queue.
        // Make one last check to determine whether or not the packet has
        // already been marked cancelled.  If it has, then invoke the
        // driver's cancel routine now.  Note that because the cancel
        // spinlock is currently being held, an attempt to cancel the request
        // from another processor at this point will simply wait until this
        // routine is finished, and then get it cancelled.
        //

        if (CancelFunction) {
            if (Irp->Cancel) {
                Irp->CancelIrql = cancelIrql;
                Irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
                CancelFunction( DeviceObject, Irp );
            } else {
                IoReleaseCancelSpinLock( cancelIrql );
            }
        }
    }

    //
    // Restore the IRQL back to its value upon entry to this function before
    // returning to the caller.
    //

    KeLowerIrql( oldIrql );
}

VOID
IopStartNextPacketByKeyEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG   Key,
    IN int     Flags)
/*++

Routine Description:

    This routine ensures that if the IoStartPacket* routines are called from inside StartIo then
    it defers calling the startio until after the StartIo call returns. It does this by keeping a count.
    It also keeps track of whether its cancelable or has a key by storing the value in the
    device object extension. They are updated without a lock because its incorrect to have two parallel
    calls to IoStartNextPacket or IoStartNextPacketByKey.

Arguments:

    DeviceObject - Pointer to device object itself.

    Key - Specifics the Key used to remove the entry from the queue.

    Flags - Specifies if the deferred call has a key or is cancelable.

Return Value:

    None.

--*/
{
    LOGICAL Cancelable;
    int doAnotherIteration;

    do {
            doAnotherIteration = 0;
            if (InterlockedIncrement(&(DeviceObject->DeviceObjectExtension->StartIoCount)) > 1) {
                DeviceObject->DeviceObjectExtension->StartIoFlags |= Flags;
                DeviceObject->DeviceObjectExtension->StartIoKey = Key;
            } else {
                Cancelable = Flags & DOE_STARTIO_CANCELABLE;
                DeviceObject->DeviceObjectExtension->StartIoFlags &=
                    ~(DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY|DOE_STARTIO_CANCELABLE);
                DeviceObject->DeviceObjectExtension->StartIoKey = 0;
                if (Flags & DOE_STARTIO_REQUESTED_BYKEY) {
                    IopStartNextPacketByKey(DeviceObject, Cancelable, Key);
                }else if (Flags &DOE_STARTIO_REQUESTED){
                    IopStartNextPacket(DeviceObject, Cancelable);
                }
            }
            if (InterlockedDecrement(&(DeviceObject->DeviceObjectExtension->StartIoCount)) == 0) {
                Flags = DeviceObject->DeviceObjectExtension->StartIoFlags &
                    (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY|DOE_STARTIO_CANCELABLE);
                Key = DeviceObject->DeviceObjectExtension->StartIoKey;
                if (Flags & (DOE_STARTIO_REQUESTED|DOE_STARTIO_REQUESTED_BYKEY)) {
                    doAnotherIteration++;
                }
            }
    } while (doAnotherIteration);
}


VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable)
/*++

Routine Description:

    This routine checks the DOE flags to see if StartIO has to be deferred.
    If so it calls the appropriate function.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/
{
    if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_DEFERRED) {
        IopStartNextPacketByKeyEx(DeviceObject, 0, DOE_STARTIO_REQUESTED|(Cancelable ? DOE_STARTIO_CANCELABLE : 0));
    } else {
        IopStartNextPacket(DeviceObject, Cancelable);
    }
}

VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN Cancelable,
    IN ULONG   Key)
/*++

Routine Description:

    This routine checks the DOE flags to see if StartIO has to be deferred.
    If so it calls the appropriate function.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/
{
    if (DeviceObject->DeviceObjectExtension->StartIoFlags & DOE_STARTIO_DEFERRED) {
        IopStartNextPacketByKeyEx(DeviceObject, Key, DOE_STARTIO_REQUESTED_BYKEY|(Cancelable ? DOE_STARTIO_CANCELABLE : 0));
    } else {
        IopStartNextPacketByKey(DeviceObject, Cancelable, Key);
    }
}


VOID
IoSetStartIoAttributes(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeferredStartIo,
    IN BOOLEAN NonCancelable
    )
/*++

Routine Description:

    This routine sets the StartIo attributes so that drivers can change the
    behavior of when StartIo can be called.

Arguments:

    DeviceObject - Pointer to device object itself.

    NonCancelable - If TRUE that IRP passed to StartIo is not in the cancelable state.

    DeferredStartIo - If TRUE startIo is not called recursively and is deferred until the previous
                      StartIo call returns to the IO manager.

Return Value:

    None.

--*/
{
    if (DeferredStartIo) {
          DeviceObject->DeviceObjectExtension->StartIoFlags |= DOE_STARTIO_DEFERRED;
    }

    if (NonCancelable) {
        DeviceObject->DeviceObjectExtension->StartIoFlags |= DOE_STARTIO_NO_CANCEL;
    }
}


VOID
IoStartTimer(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine starts the timer associated with the specified device object.

Arguments:

    DeviceObject - Device object associated with the timer to be started.

Return Value:

    None.

--*/

{
    PIO_TIMER timer;
    KIRQL irql;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (irql);
#endif

    //
    // Get the address of the timer.
    //

    timer = DeviceObject->Timer;

    //
    // If the driver is not being unloaded, then it is okay to start timers.
    //

    if (!(DeviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED))) {

        //
        // Likewise, check to see whether or not the timer is already
        // enabled.  If so, then simply exit.  Otherwise, enable the timer
        // by placing it into the I/O system timer queue.
        //

        ExAcquireFastLock( &IopTimerLock, &irql );
        if (!timer->TimerFlag) {
            timer->TimerFlag = TRUE;
            IopTimerCount++;
        }
        ExReleaseFastLock( &IopTimerLock, irql );
    }
}

VOID
IoStopTimer(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routines stops the timer associated with the specified device object
    from invoking being invoked.

Arguments:

    DeviceObject - Device object associated with the timer to be stopped.

Return Value:

    None.

--*/

{
    KIRQL irql;
    PIO_TIMER timer;

#if !DBG && defined(NT_UP)
    UNREFERENCED_PARAMETER (irql);
#endif

    //
    // Obtain the I/O system timer queue lock, and disable the specified
    // timer.
    //

    timer = DeviceObject->Timer;

    ExAcquireFastLock( &IopTimerLock, &irql );
    if (timer->TimerFlag) {
        timer->TimerFlag = FALSE;
        IopTimerCount--;
    }
    ExReleaseFastLock( &IopTimerLock, irql );
}

NTSTATUS
IoSynchronousPageWrite(
    IN PFILE_OBJECT FileObject,
    IN PMDL MemoryDescriptorList,
    IN PLARGE_INTEGER StartingOffset,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine provides a special, fast interface for the Modified Page Writer
    (MPW) to write pages to the disk quickly and with very little overhead.  All
    of the special handling for this request is recognized by setting the
    IRP_PAGING_IO flag in the IRP flags word.

Arguments:

    FileObject - A pointer to a referenced file object describing which file
        the write should be performed on.

    MemoryDescriptorList - An MDL which describes the physical pages that the
        pages should be written to the disk.  All of the pages have been locked
        in memory.  The MDL also describes the length of the write operation.

    StartingOffset - Pointer to the offset in the file from which the write
        should take place.

    Event - A pointer to a kernel event structure to be used for synchronization
        purposes.  The event will be set to the Signaled state once the pages
        have been written.

    IoStatusBlock - A pointer to the I/O status block in which the final status
        and information should be stored.

Return Value:

    The function value is the final status of the queue request to the I/O
    system subcomponents.


--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    //
    // Increment performance counters
    //

    if (CcIsFileCached(FileObject)) {
        CcDataFlushes += 1;
        CcDataPages += (MemoryDescriptorList->ByteCount + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }

    //
    // Begin by getting a pointer to the device object that the file resides
    // on.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Allocate an I/O Request Packet (IRP) for this out-page operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get a pointer to the first stack location in the packet.  This location
    // will be used to pass the function codes and parameters to the first
    // driver.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Fill in the IRP according to this request.
    //

    irp->MdlAddress = MemoryDescriptorList;
    irp->Flags = IRP_PAGING_IO | IRP_NOCACHE | IRP_SYNCHRONOUS_PAGING_IO;

    irp->RequestorMode = KernelMode;
    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;
    irp->UserBuffer = (PVOID) ((PCHAR) MemoryDescriptorList->StartVa + MemoryDescriptorList->ByteOffset);
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the normal write parameters.
    //

    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->Parameters.Write.Length = MemoryDescriptorList->ByteCount;
    irpSp->Parameters.Write.ByteOffset = *StartingOffset;
    irpSp->FileObject = FileObject;

    //
    // Queue the packet to the appropriate driver based on whether or not there
    // is a VPB associated with the device.
    //

    return IoCallDriver( deviceObject, irp );
}

PEPROCESS
IoThreadToProcess(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine returns a pointer to the process for the specified thread.

Arguments:

    Thread - Thread whose process is to be returned.

Return Value:

    A pointer to the thread's process.

Note:

    This function cannot be made a macro, since fields in the thread object
    move from release to release, so this must remain a full function.


--*/

{
    //
    // Simply return the thread's process.
    //

    return THREAD_TO_PROCESS( Thread );
}

VOID
IoUnregisterFileSystem(
    IN OUT PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine removes the device object for the file system from the active
    list of file systems in the system.

Arguments:

    DeviceObject - Pointer to device object for the file system.

Return Value:

    None.


--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Acquire the I/O database resource for a write operation.
    //

    (VOID)ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Remove the device object from whatever queue it happens to be in at the
    // moment.  There is no need to check here to determine if the device queue
    // is in a queue since it is assumed that the caller registered it as a
    // valid file system.
    //

    if (DeviceObject->Queue.ListEntry.Flink != NULL) {
        RemoveEntryList( &DeviceObject->Queue.ListEntry );
    }

    //
    // Notify all of the registered drivers that this file system has been
    // unregistered as an active file system of some type.
    //

    entry = IopFsNotifyChangeQueueHead.Flink;
    while (entry != &IopFsNotifyChangeQueueHead) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        entry = entry->Flink;
        nPacket->NotificationRoutine( DeviceObject, FALSE );
    }

    IopFsRegistrationOps++;

    //
    // Release the I/O database resource.
    //

    ExReleaseResourceLite( &IopDatabaseResource );

    //
    // Decrement the number of reasons that this driver cannot be unloaded.
    //

    IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                  &DeviceObject->ReferenceCount );
}

VOID
IoUnregisterFsRegistrationChange(
    IN PDRIVER_OBJECT DriverObject,
    IN PDRIVER_FS_NOTIFICATION DriverNotificationRoutine
    )

/*++

Routine Description:

    This routine unregisters the specified driver's notification routine from
    begin invoked whenever a file system registers or unregisters itself as an
    active file system in the system.

Arguments:

    DriverObject - Pointer to the driver object for the driver.

    DriverNotificationRoutine - Address of routine to unregister.

Return Value:

    None.

--*/

{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY entry;

    PAGED_CODE();

    //
    // Begin by acquiring the database resource exclusively.
    //

    ExAcquireResourceExclusiveLite( &IopDatabaseResource, TRUE );

    //
    // Walk the list of registered notification routines and unregister the
    // specified routine.
    //

    for (entry = IopFsNotifyChangeQueueHead.Flink;
        entry != &IopFsNotifyChangeQueueHead;
        entry = entry->Flink) {
        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );
        if (nPacket->DriverObject == DriverObject &&
            nPacket->NotificationRoutine == DriverNotificationRoutine) {
            RemoveEntryList( entry );
            ExFreePool( nPacket );
            break;
        }
    }

    ExReleaseResourceLite( &IopDatabaseResource );

    ObDereferenceObject( DriverObject );

}

VOID
IoUnregisterShutdownNotification(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine removes a registered driver from the shutdown notification
    queue.  Henceforth, the driver will not be notified when the system is
    being shutdown.

Arguments:

    DeviceObject - Pointer to the driver's device object.

Return Value:

    None.

--*/

{
    PLIST_ENTRY entry;
    PSHUTDOWN_PACKET shutdown;
    KIRQL irql;

    PAGED_CODE();

    //
    // Lock this code into memory for the duration of this function's execution.
    //

    ASSERT(ExPageLockHandle);
    MmLockPageableSectionByHandle( ExPageLockHandle );

    //
    // Acquire the spinlock that protects the shutdown notification queue, and
    // walk the queue looking for the caller's entry.  Once found, remove it
    // from the queue.  It is an error to not find it, but it is ignored here.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    for (entry = IopNotifyShutdownQueueHead.Flink;
         entry != &IopNotifyShutdownQueueHead;
         entry = entry->Flink) {

        //
        // An entry has been located.  If it is the one that is being searched
        // for, simply remove it from the list and deallocate it.
        //

        shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );
        if (shutdown->DeviceObject == DeviceObject) {
            RemoveEntryList( entry );
            entry = entry->Blink;
            ObDereferenceObject(DeviceObject);
            ExFreePool( shutdown );
        }
    }

    for (entry = IopNotifyLastChanceShutdownQueueHead.Flink;
         entry != &IopNotifyLastChanceShutdownQueueHead;
         entry = entry->Flink) {

        //
        // An entry has been located.  If it is the one that is being searched
        // for, simply remove it from the list and deallocate it.
        //

        shutdown = CONTAINING_RECORD( entry, SHUTDOWN_PACKET, ListEntry );
        if (shutdown->DeviceObject == DeviceObject) {
            RemoveEntryList( entry );
            entry = entry->Blink;
            ObDereferenceObject(DeviceObject);
            ExFreePool( shutdown );
        }
    }

    //
    // Release the spinlock.
    //

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    MmUnlockPageableImageSection( ExPageLockHandle );

    DeviceObject->Flags &= ~DO_SHUTDOWN_REGISTERED;

}

VOID
IoUpdateShareAccess(
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine updates the share access context for a file according to
    the desired access and share access by the current open requestor.  The
    IoCheckShareAccess routine must already have been invoked and succeeded
    in order to invoke this routine.  Note that when the former routine was
    invoked the Update parameter must have been FALSE.

Arguments:

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

Return Value:

    None.

--*/

{
    BOOLEAN update = TRUE;

    PAGED_CODE();

    //
    // If this is a special filter fileobject ignore share access check if necessary.
    //

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);

        if (fileObjectExtension->FileObjectExtensionFlags & FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK) {

            //
            //  This fileobject is marked to ignore share access checks
            //  so we also don't want to affect the file/directory's
            //  ShareAccess structure counts.
            //

            update = FALSE;
        }
    }

    //
    // Check to see whether or not the desired accesses need read, write,
    // or delete access to the file.
    //

    if ((FileObject->ReadAccess ||
         FileObject->WriteAccess ||
         FileObject->DeleteAccess) &&
        update) {

        //
        // The open request requires read, write, or delete access so update
        // the share access context for the file.
        //

        ShareAccess->OpenCount++;

        ShareAccess->Readers += FileObject->ReadAccess;
        ShareAccess->Writers += FileObject->WriteAccess;
        ShareAccess->Deleters += FileObject->DeleteAccess;

        ShareAccess->SharedRead += FileObject->SharedRead;
        ShareAccess->SharedWrite += FileObject->SharedWrite;
        ShareAccess->SharedDelete += FileObject->SharedDelete;
    }
}


NTSTATUS
IoVerifyVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    )

/*++

Routine Description:

    This routine is invoked to check a mounted volume on the specified device
    when it appears as if the media may have changed since it was last
    accessed.  If the volume is not the same volume, and a new mount is not
    to be attempted, return the error.

    If the verify fails, this routine is used to perform a new mount operation
    on the device.  In this case, a "clean" VPB is allocated and a new mount
    operation is attempted.  If no mount operation succeeds, then again the
    error handling described above occurs.

Arguments:

    DeviceObject - Pointer to device object on which the volume is to be
        mounted.

    AllowRawMount - Indicates that this verify is on behalf of a DASD open
        request, thus we want to allow a raw mount if the verify fails.

Return Value:

    The function value is a successful status code if a volume was successfully
    mounted on the device.  Otherwise, an error code is returned.


--*/

{
    NTSTATUS status;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN verifySkipped = FALSE;
    PDEVICE_OBJECT fsDeviceObject;
    PDEVICE_OBJECT fsBaseDeviceObject;
    PVPB    mountVpb;
    PVPB    vpb;

    PAGED_CODE();

    //
    //  Acquire the DeviceObject lock.  Nothing in this routine can raise
    //  so no try {} finally {} is required.
    //

    status = KeWaitForSingleObject( &DeviceObject->DeviceLock,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL );

    ASSERT( status == STATUS_SUCCESS );

    //
    // If this volume is not mounted by anyone, skip the verify operation,
    // but do the mount.
    //

    if (!IopReferenceVerifyVpb(DeviceObject, &vpb, &fsBaseDeviceObject)) {


        verifySkipped = TRUE;

        status = STATUS_SUCCESS;

    } else {

        //
        // This volume needs to be verified.  Initialize the event to be
        // used while waiting for the operation to complete.
        //

        KeInitializeEvent( &event, NotificationEvent, FALSE );
        status = STATUS_UNSUCCESSFUL;

        //
        // Allocate and initialize an IRP for this verify operation.  Notice
        // that the flags for this operation appear the same as a page read
        // operation.  This is because the completion code for both of the
        // operations is exactly the same logic.
        //

        fsDeviceObject = fsBaseDeviceObject;

        while (fsDeviceObject->AttachedDevice) {
            fsDeviceObject = fsDeviceObject->AttachedDevice;
        }
        irp = IoAllocateIrp( fsDeviceObject->StackSize, FALSE );
        if (!irp) {

            KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irp->Flags = IRP_MOUNT_COMPLETION | IRP_SYNCHRONOUS_PAGING_IO;
        irp->RequestorMode = KernelMode;
        irp->UserEvent = &event;
        irp->UserIosb = &ioStatus;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
        irpSp->MinorFunction = IRP_MN_VERIFY_VOLUME;
        irpSp->Flags = AllowRawMount ? SL_ALLOW_RAW_MOUNT : 0;
        irpSp->Parameters.VerifyVolume.Vpb = vpb;
        irpSp->Parameters.VerifyVolume.DeviceObject = fsBaseDeviceObject;

        status = IoCallDriver( fsDeviceObject, irp );

        //          IopLoadFileSystemDriver
        // Wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = ioStatus.Status;
        }

        //
        // Deref the VPB obtained above.
        //

        IopDereferenceVpbAndFree(vpb);
    }

    //
    // If the verify operation was skipped or unsuccessful perform a mount
    // operation.
    //

    if ((status == STATUS_WRONG_VOLUME) || verifySkipped) {

        //
        // A mount operation is to be attempted.  Allocate a new VPB
        // for this device and attempt to mount it.
        //

        if (NT_SUCCESS(IopCreateVpb (DeviceObject))) {

            PoVolumeDevice (DeviceObject);

            //
            // Now mount the volume.
            //

            mountVpb = NULL;
            if (!NT_SUCCESS( IopMountVolume( DeviceObject, AllowRawMount, TRUE, FALSE, &mountVpb ) )) {
                DeviceObject->Flags &= ~DO_VERIFY_VOLUME;
            } else {
                if (mountVpb) {

                    //
                    // Decrement  the reference allocated in IopMountVolume.
                    //

                    IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                                  (PLONG) &mountVpb->ReferenceCount );
                }
            }
        } else {
            DeviceObject->Flags &= ~DO_VERIFY_VOLUME;
        }
    }

    //
    //  Release the device lock.
    //

    KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );

    //
    // Return the status from the verify operation as the final status of
    // this function.
    //

    return status;
}

VOID
IoWriteErrorLogEntry(
    IN OUT PVOID ElEntry
    )

/*++

Routine Description:

    This routine places the error log entry specified by the input argument
    onto the queue of buffers to be written to the error log process's port.
    The error log thread will then actually send it.

Arguments:

    ElEntry Pointer to the error log entry.

Return Value:

    None.

--*/

{
    PERROR_LOG_ENTRY entry;
    KIRQL oldIrql;

    //
    // Get the address of the error log entry header, acquire the spin lock,
    // insert the entry onto the queue, if there are no pending requests
    // then queue a worker thread request and release the spin lock.
    //

    entry = ((PERROR_LOG_ENTRY) ElEntry) - 1;

    if (IopErrorLogDisabledThisBoot) {
        //
        // Do nothing, drop the reference.
        //

        if (entry->DeviceObject != NULL) {
            //
            // IopErrorLogThread tests for NULL before derefing.
            // So do the same here.
            //
            ObDereferenceObject (entry->DeviceObject);
        }
        if (entry->DriverObject != NULL) {
            ObDereferenceObject (entry->DriverObject);
        }

        InterlockedExchangeAdd( &IopErrorLogAllocation,
                               -((LONG) (entry->Size )));
        ExFreePool (entry);
        return;

    }

    //
    // Set the time that the entry was logged.
    //

    KeQuerySystemTime( (PVOID) &entry->TimeStamp );

    ExAcquireSpinLock( &IopErrorLogLock, &oldIrql );

    //
    // Queue the request to the error log queue.
    //

    InsertTailList( &IopErrorLogListHead, &entry->ListEntry );

    //
    // If there is no pending work, then queue a request to a worker thread.
    //

    if (!IopErrorLogPortPending) {

        IopErrorLogPortPending = TRUE;

        ExInitializeWorkItem( &IopErrorLogWorkItem, IopErrorLogThread, NULL );
        ExQueueWorkItem( &IopErrorLogWorkItem, DelayedWorkQueue );

    }

    ExReleaseSpinLock(&IopErrorLogLock, oldIrql);
}

NTSTATUS
IoGetBootDiskInformation(
    IN OUT PBOOTDISK_INFORMATION BootDiskInformation,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine provides the caller with the signature and offset of
    the boot disk and system disk. This information is obtained from the
    loader block. The callers have to be boot drivers which have registered
    for a callback once all disk devices have been started
Arguments:

    BootDiskInformation - Supplies a pointer to the structure allocated by the
    caller for requested information.
    Size - Size of the BootDiskInformation structure.

Return Value:

    STATUS_SUCCESS - successful.
    STATUS_TOO_LATE - indicates that the Loader Block has already been freed
    STATUS_INVALID_PARAMETER - size allocated for boot disk information
    is insufficient.

--*/

{
    PLOADER_PARAMETER_BLOCK LoaderBlock = NULL;
    STRING arcBootDeviceString;
    CHAR deviceNameBuffer[128];
    STRING deviceNameString;
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    CHAR arcNameBuffer[128];
    STRING arcNameString;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    DISK_GEOMETRY diskGeometry;
    PDRIVE_LAYOUT_INFORMATION_EX driveLayout;
    PLIST_ENTRY listEntry;
    PARC_DISK_SIGNATURE diskBlock;
    ULONG diskNumber;
    ULONG partitionNumber;
    PCHAR arcName;
    PIRP irp;
    KEVENT event;
    BOOLEAN singleBiosDiskFound;
    PARC_DISK_INFORMATION arcInformation;
    ULONG totalDriverDisksFound = IoGetConfigurationInformation()->DiskCount;
    STRING arcSystemDeviceString;
    PARTITION_INFORMATION_EX PartitionInfo;
    PBOOTDISK_INFORMATION_EX    bootDiskInformationEx;
    ULONG diskSignature = 0;

    PAGED_CODE();

    if (IopLoaderBlock == NULL) {
        return STATUS_TOO_LATE;
    }

    if (Size < sizeof(BOOTDISK_INFORMATION)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (Size < sizeof(BOOTDISK_INFORMATION_EX)) {
        bootDiskInformationEx = NULL;
    } else {
        bootDiskInformationEx = (PBOOTDISK_INFORMATION_EX)BootDiskInformation;
    }

    LoaderBlock = (PLOADER_PARAMETER_BLOCK)IopLoaderBlock;
    arcInformation = LoaderBlock->ArcDiskInformation;

    //
    // If a single bios disk was found if there is only a
    // single entry on the disk signature list.
    //
    singleBiosDiskFound = (arcInformation->DiskSignatures.Flink->Flink ==
                           &arcInformation->DiskSignatures) ? (TRUE) : (FALSE);

    //
    // Get ARC boot device name from loader block.
    //

    RtlInitAnsiString( &arcBootDeviceString,
                       LoaderBlock->ArcBootDeviceName );
    //
    // Get ARC system device name from loader block.
    //

    RtlInitAnsiString( &arcSystemDeviceString,
                       LoaderBlock->ArcHalDeviceName );
    //
    // For each disk, get its drive layout and check to see if the
    // signature is among the list of signatures in the loader block.
    // If yes, check to see if the disk contains the boot or system
    // partitions. If yes, fill up the requested structure.
    //

    for (diskNumber = 0;
         diskNumber < totalDriverDisksFound;
         diskNumber++) {

        //
        // Construct the NT name for a disk and obtain a reference.
        //

        sprintf( deviceNameBuffer,
                 "\\Device\\Harddisk%d\\Partition0",
                 diskNumber );
        RtlInitAnsiString( &deviceNameString, deviceNameBuffer );
        status = RtlAnsiStringToUnicodeString( &deviceNameUnicodeString,
                                               &deviceNameString,
                                               TRUE );
        if (!NT_SUCCESS( status )) {
            continue;
        }

        status = IoGetDeviceObjectPointer( &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );
        RtlFreeUnicodeString( &deviceNameUnicodeString );

        if (!NT_SUCCESS( status )) {
            continue;
        }

        //
        // Create IRP for get drive geometry device control.
        //

        irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &diskGeometry,
                                             sizeof(DISK_GEOMETRY),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
        if (!irp) {
            ObDereferenceObject( fileObject );
            continue;
        }

        KeInitializeEvent( &event,
                           NotificationEvent,
                           FALSE );
        status = IoCallDriver( deviceObject,
                               irp );

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &event,
                                   Suspended,
                                   KernelMode,
                                   FALSE,
                                   NULL );
            status = ioStatusBlock.Status;
        }

        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }

        //
        // Get partition information for this disk.
        //

        status = IoReadPartitionTableEx( deviceObject,
                                       &driveLayout );


        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            continue;
        }

        //
        // Make sure sector size is at least 512 bytes.
        //

        if (diskGeometry.BytesPerSector < 512) {
            diskGeometry.BytesPerSector = 512;
        }



        ObDereferenceObject( fileObject );

        //
        // For each ARC disk information record in the loader block
        // match the disk signature and checksum to determine its ARC
        // name and construct the NT ARC names symbolic links.
        //

        for (listEntry = arcInformation->DiskSignatures.Flink;
             listEntry != &arcInformation->DiskSignatures;
             listEntry = listEntry->Flink) {

            //
            // Get next record and compare disk signatures.
            //

            diskBlock = CONTAINING_RECORD( listEntry,
                                           ARC_DISK_SIGNATURE,
                                           ListEntry );

            //
            // Compare disk signatures.
            //
            // Or if there is only a single disk drive from
            // both the bios and driver viewpoints then
            // assign an arc name to that drive.
            //

            if ((singleBiosDiskFound &&
                 (totalDriverDisksFound == 1) &&
                 (driveLayout->PartitionStyle == PARTITION_STYLE_MBR)) ||
                IopVerifyDiskSignature(driveLayout, diskBlock, &diskSignature)) {

                //
                // Create unicode ARC name for this partition.
                //

                arcName = diskBlock->ArcName;
                sprintf( arcNameBuffer,
                         "\\ArcName\\%s",
                         arcName );
                RtlInitAnsiString( &arcNameString, arcNameBuffer );

                //
                // Create an ARC name for every partition on this disk.
                //

                for (partitionNumber = 0;
                     partitionNumber < driveLayout->PartitionCount;
                     partitionNumber++) {

                    //
                    // Create unicode NT device name.
                    //

                    sprintf( deviceNameBuffer,
                             "\\Device\\Harddisk%d\\Partition%d",
                             diskNumber,
                             partitionNumber+1 );
                    RtlInitAnsiString( &deviceNameString, deviceNameBuffer );

                    status = RtlAnsiStringToUnicodeString(
                                                       &deviceNameUnicodeString,
                                                       &deviceNameString,
                                                       TRUE );

                    if (!NT_SUCCESS( status )) {
                        continue;
                    }


                    //
                    // If we came through the single disk case.
                    //

                    if (diskSignature == 0) {
                        diskSignature = driveLayout->Mbr.Signature;
                    }

                    //
                    // Create unicode ARC name for this partition and
                    // check to see if this is the boot disk.
                    //

                    sprintf( arcNameBuffer,
                             "%spartition(%d)",
                             arcName,
                             partitionNumber+1 );
                    RtlInitAnsiString( &arcNameString, arcNameBuffer );
                    if (RtlEqualString( &arcNameString,
                                        &arcBootDeviceString,
                                        TRUE )) {


                        BootDiskInformation->BootDeviceSignature = diskSignature;

                        //
                        // Get Partition Information for the offset of the
                        // partition within the disk
                        //
                        status = IoGetDeviceObjectPointer(
                                           &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );

                        if (!NT_SUCCESS( status )) {
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        //
                        // Create IRP for get drive geometry device control.
                        //

                        irp = IoBuildDeviceIoControlRequest(
                                             IOCTL_DISK_GET_PARTITION_INFO_EX,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &PartitionInfo,
                                             sizeof(PARTITION_INFORMATION_EX),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
                        if (!irp) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        KeInitializeEvent( &event,
                                           NotificationEvent,
                                           FALSE );
                        status = IoCallDriver( deviceObject,
                                               irp );

                        if (status == STATUS_PENDING) {
                            KeWaitForSingleObject( &event,
                                                   Suspended,
                                                   KernelMode,
                                                   FALSE,
                                                   NULL );
                            status = ioStatusBlock.Status;
                        }

                        if (!NT_SUCCESS( status )) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }
                        BootDiskInformation->BootPartitionOffset =
                                        PartitionInfo.StartingOffset.QuadPart;

                        if (driveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->BootDeviceIsGpt = TRUE;

                                //
                                // Structure copy.
                                //

                                bootDiskInformationEx->BootDeviceGuid = driveLayout->Gpt.DiskId;
                            }
                        } else {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->BootDeviceIsGpt = FALSE;
                            }
                        }

                        ObDereferenceObject( fileObject );
                    }

                    //
                    // See if this is the system partition.
                    //
                    if (RtlEqualString( &arcNameString,
                                        &arcSystemDeviceString,
                                        TRUE )) {
                        BootDiskInformation->SystemDeviceSignature = diskSignature;
                        //
                        // Get Partition Information for the offset of the
                        // partition within the disk
                        //

                        status = IoGetDeviceObjectPointer(
                                           &deviceNameUnicodeString,
                                           FILE_READ_ATTRIBUTES,
                                           &fileObject,
                                           &deviceObject );

                        if (!NT_SUCCESS( status )) {
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        //
                        // Create IRP for get drive geometry device control.
                        //

                        irp = IoBuildDeviceIoControlRequest(
                                             IOCTL_DISK_GET_PARTITION_INFO_EX,
                                             deviceObject,
                                             NULL,
                                             0,
                                             &PartitionInfo,
                                             sizeof(PARTITION_INFORMATION_EX),
                                             FALSE,
                                             &event,
                                             &ioStatusBlock );
                        if (!irp) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }

                        KeInitializeEvent( &event,
                                           NotificationEvent,
                                           FALSE );
                        status = IoCallDriver( deviceObject,
                                               irp );

                        if (status == STATUS_PENDING) {
                            KeWaitForSingleObject( &event,
                                                   Suspended,
                                                   KernelMode,
                                                   FALSE,
                                                   NULL );
                            status = ioStatusBlock.Status;
                        }

                        if (!NT_SUCCESS( status )) {
                            ObDereferenceObject( fileObject );
                            RtlFreeUnicodeString( &deviceNameUnicodeString );
                            continue;
                        }
                        BootDiskInformation->SystemPartitionOffset =
                                        PartitionInfo.StartingOffset.QuadPart;

                        if (driveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->SystemDeviceIsGpt = TRUE;

                                //
                                // Structure copy.
                                //

                                bootDiskInformationEx->SystemDeviceGuid = driveLayout->Gpt.DiskId;
                            }
                        } else {
                            if (bootDiskInformationEx) {
                                bootDiskInformationEx->SystemDeviceIsGpt = FALSE;
                            }
                        }

                        ObDereferenceObject( fileObject );
                    }

                    RtlFreeUnicodeString( &deviceNameUnicodeString );
                }
            }
        }
        ExFreePool( driveLayout );
    }
    return STATUS_SUCCESS;
}

PSECURITY_DESCRIPTOR
IopCreateDefaultDeviceSecurityDescriptor(
    IN DEVICE_TYPE DeviceType,
    IN ULONG DeviceCharacteristics,
    IN BOOLEAN DeviceHasName,
    IN PUCHAR Buffer,
    OUT PACL *AllocatedAcl,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    )
/*++

Routine Description:

    This routine creates a security descriptor for a device object. The security descriptor is
    set based on the device type.
    This can be called from PnP MGR or IoCreateDevice.

Arguments:

    DeviceType  - Type of Device
    DeviceCharacteristics - Characteristics of the device.
    DeviceHasName - TRUE if device object has a name
    Buffer - Storage for security descriptor
    AllocatedAcl - Is non-null if this routine allocated an ACL.
    SecurityInformation - OUT parameter where SecurityInformation is passed.

Return Value:

    PSECURITY_DESCRIPTOR. NULL on error.
--*/
{
    PSECURITY_DESCRIPTOR descriptor = (PSECURITY_DESCRIPTOR) Buffer;

    NTSTATUS status;

    PAGED_CODE();

    if(ARGUMENT_PRESENT(SecurityInformation)) {
        (*SecurityInformation) = 0;
    }

    *AllocatedAcl = NULL;


    switch ( DeviceType ) {

        case FILE_DEVICE_DISK_FILE_SYSTEM:
        case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
        case FILE_DEVICE_FILE_SYSTEM:
        case FILE_DEVICE_TAPE_FILE_SYSTEM: {

            //
            // Use the standard public default protection for these types of devices.
            //
            status = IopCreateSecurityDescriptorPerType(
                                descriptor,
                                IO_SD_SYS_ALL_ADM_ALL_WORLD_E_RES_E,
                                SecurityInformation
                                );

            break;
        }

        case FILE_DEVICE_CD_ROM:
        case FILE_DEVICE_MASS_STORAGE:
        case FILE_DEVICE_DISK:
        case FILE_DEVICE_VIRTUAL_DISK:
        case FILE_DEVICE_NETWORK_FILE_SYSTEM:
        case FILE_DEVICE_DFS_FILE_SYSTEM:
        case FILE_DEVICE_NETWORK: {

            if ((DeviceHasName) &&
                ((DeviceCharacteristics & FILE_FLOPPY_DISKETTE) != 0)) {

                status = IopCreateSecurityDescriptorPerType(
                                    descriptor,
                                    IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE,
                                    SecurityInformation
                                    );

            } else {

                UCHAR i;
                PACL acl;
                BOOLEAN aceFound;
                BOOLEAN aceFoundForCDROM;
                PACCESS_ALLOWED_ACE ace;

                //
                // Protect the device so that an administrator can run chkdsk
                // on it. This is done by making a copy of the default public
                // ACL and changing the accesses granted to the administrators
                // alias.
                //
                // The logic here is:
                //
                //      - Copy the public default dacl into another buffer
                //
                //      - Find the ACE granting ADMINISTRATORS access
                //
                //      - Change the granted access mask of that ACE to give
                //        administrators write access.
                //
                //

                acl = ExAllocatePoolWithTag(
                        PagedPool,
                        SePublicDefaultUnrestrictedDacl->AclSize,
                        'eSoI' );

                if (!acl) {
                    return NULL;
                }

                RtlCopyMemory( acl,
                               SePublicDefaultUnrestrictedDacl,
                               SePublicDefaultUnrestrictedDacl->AclSize );

                //
                // Find the Administrators ACE
                //

                aceFound = FALSE;
                aceFoundForCDROM = FALSE;

                for ( i = 0, status = RtlGetAce(acl, 0, &ace);
                      NT_SUCCESS(status);
                      i++, status = RtlGetAce(acl, i, &ace)) {

                    PSID sid;

                    sid = &(ace->SidStart);
                    if (RtlEqualSid( SeAliasAdminsSid, sid )) {

                        ace->Mask |= ( GENERIC_READ |
                                       GENERIC_WRITE |
                                       GENERIC_EXECUTE );

                        aceFound = TRUE;
                    }

                    if (DeviceType == FILE_DEVICE_CD_ROM) {

                         if (RtlEqualSid( SeWorldSid, sid )) {
                             ace->Mask |= GENERIC_READ;
                             aceFoundForCDROM = TRUE;
                         }
                     }
                }

                //
                // If the ACE wasn't found, then the public default ACL has been
                // changed.  For this case, this code needs to be updated to match
                // the new public default DACL.
                //

                ASSERT(aceFound == TRUE);

                if (DeviceType == FILE_DEVICE_CD_ROM) {
                    ASSERT(aceFoundForCDROM == TRUE);
                }

                //
                // Finally, build a full security descriptor from the above DACL.
                //

                RtlCreateSecurityDescriptor( descriptor,
                                             SECURITY_DESCRIPTOR_REVISION );

                RtlSetDaclSecurityDescriptor( descriptor,
                                              TRUE,
                                              acl,
                                              FALSE );

                if(ARGUMENT_PRESENT(SecurityInformation)) {
                    (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
                }

                *AllocatedAcl = acl;
                status = STATUS_SUCCESS;
            }

            break;
        }

        default: {

            status = IopCreateSecurityDescriptorPerType(
                                descriptor,
                                IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE,
                                SecurityInformation
                                );

            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        return NULL;
    }
    return descriptor;
}

NTSTATUS
IopCreateSecurityDescriptorPerType(
    IN  PSECURITY_DESCRIPTOR  Descriptor,
    IN  ULONG                 SecurityDescriptorFlavor,
    OUT PSECURITY_INFORMATION SecurityInformation OPTIONAL
    )
/*++

Routine Description:

    This routine creates a security descriptor based on the flavor.

Arguments:

    Descriptor - Storage for security descriptor
    SecurityInformation - OUT parameter where SecurityInformation is passed.
    SecurityDescriptorFlavor - Type used to determine the security descriptor flavor.

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS    status;
    PACL        acl;

    switch (SecurityDescriptorFlavor) {
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_E           :
            acl = SePublicDefaultDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_E_RES_E     :
            acl = SePublicDefaultUnrestrictedDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE         :
            acl = SePublicOpenDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_ALL_WORLD_RWE_RES_RE  :
            acl = SePublicOpenUnrestrictedDacl;
            break;
        case  IO_SD_SYS_ALL_ADM_RE                    :
            acl = SeSystemDefaultDacl;
            break;
        default:
            ASSERT(0);
            return STATUS_INVALID_PARAMETER;
    }

    status = RtlCreateSecurityDescriptor(
                Descriptor,
                SECURITY_DESCRIPTOR_REVISION );

    ASSERT( NT_SUCCESS( status ) );

    status = RtlSetDaclSecurityDescriptor(
                Descriptor,
                TRUE,
                acl,
                FALSE );


    if(ARGUMENT_PRESENT(SecurityInformation)) {
        (*SecurityInformation) |= DACL_SECURITY_INFORMATION;
    }
    return status;
}

NTSTATUS
IoGetRequestorSessionId(
    IN PIRP Irp,
    OUT PULONG pSessionId
    )

/*++

Routine Description:

    This routine returns the session ID for process that originally
    requested the specified I/O operation.

Arguments:

    Irp - Pointer to the I/O Request Packet.

    pSessionId - Pointer to the session Id which is set upon successful return.

Return Value:

    Returns STATUS_SUCCESS if the session ID was available, otherwise
    STATUS_UNSUCCESSFUL.

--*/

{
    PEPROCESS Process;

    //
    // Get the address of the process that requested the I/O operation.
    //

    if (Irp->Tail.Overlay.Thread) {
        Process = THREAD_TO_PROCESS( Irp->Tail.Overlay.Thread );
        *pSessionId = MmGetSessionId(Process);
        return(STATUS_SUCCESS);
    }

    *pSessionId = (ULONG) -1;
    return(STATUS_UNSUCCESSFUL);
}

VOID
IoCancelFileOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine is invoked by a filter driver to send a close to the
    next filesystem driver below. It's needed as part of the file open
    process. The filter driver forwards the open to the FSD and the FSD
    returns success. The filter driver then examines some stuff and
    decides that the open has to be failed. In this case it has to send
    a close to the FSD.

    We can safely assume a thread context because it has to be called only
    in the context of file open. If the file object already has a handle
    then the owner of the handle can then simply close the handle to the
    file object and we will close the file.

    This code is extracted from IopCloseFile and IopDeleteFile. So it is
    duplication of code but it prevents duplication elsewhere in other FSDs.

Arguments:

    FileObject - Points to the file that needs to be closed.

    DeviceObject - Points to the device object of the filesystem driver below
        the filter driver.

Return Value:

    None

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    KEVENT event;
    KIRQL irql;

    //
    // Cannot call this function if a handle has already been created
    // for this file.
    //
    ASSERT(!(FileObject->Flags & FO_HANDLE_CREATED));

    if (FileObject->Flags & FO_HANDLE_CREATED) {
        KeBugCheckEx( INVALID_CANCEL_OF_FILE_OPEN, (ULONG_PTR) FileObject, (ULONG_PTR)DeviceObject, 0, 0 );
        return;
    }

    //
    // Initialize the local event that will be used to synchronize access
    // to the driver completing this I/O operation.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Reset the event in the file object.
    //

    KeClearEvent( &FileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.
    //

    irp = IopAllocateIrpMustSucceed( DeviceObject->StackSize );
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->RequestorMode = KernelMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = &event;
    irp->UserIosb = &irp->IoStatus;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
    irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.  No
    // function-specific parameters are required for this operation.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_CLEANUP;
    irpSp->FileObject = FileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Invoke the driver at its appropriate dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, irp );

    //
    // If no error was incurred, wait for the I/O operation to complete.
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      UserRequest,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
    }

    //
    // The following code tears down the IRP by hand since it may not
    // be possible for it to be completed (either because this code was
    // invoked as APC_LEVEL in the first place - or because the reference
    // count on the object cannot be incremented due to this routine
    // being invoked by the delete file procedure below).  Cleanup IRPs
    // therefore use close semantics (the close operation flag is set
    // in the IRP) so that the I/O complete request routine itself sets
    // the event to the Signaled state.
    //

    KeRaiseIrql( APC_LEVEL, &irql );
    IopDequeueThreadIrp( irp );
    KeLowerIrql( irql );

    //
    // Reuse the IRP for the next operation.
    //

    IoFreeIrp( irp );

    //
    // Reset the event in the file object.
    //

    KeClearEvent( &FileObject->Event );

    FileObject->Flags |= FO_FILE_OPEN_CANCELLED;

}

VOID
IoRetryIrpCompletions(
    VOID
    )
/*++

Routine Description:

    This routine is called from Mm when a page fault has completed. It's
    called on the special occasion when a thread faults a page and then when
    it's waiting for the inpage to complete, an IopCompleteRequest APC fires
    and we fault the same page again (say if the user buffer falls on the
    same page).  Note the fault during the APC may be referencing the same or
    a different user virtual address but this is irrelevant - the problem lies
    in the fact that both virtual address references are to the same physical
    page and thus result in a collided fault in the Mm.

    Mm detects this case (to avoid deadlock) and returns STATUS_FAULT_COLLISION
    and the I/O manager bails out the APC after marking the Irp with the flag
    IRP_RETRY_IO_COMPLETION. Later on when Mm has decided the fault has
    progressed far enough to avoid deadlock, it calls back into this routine
    which calls IopCompleteRequest again.  The code in IopCompleteRequest is
    written in a reentrant way so that the retry knows the completion is only
    partially processed so far. We can fault in two places in IopCompleteRequest
    and in both cases if we call IopCompleteRequest again they will now work.

    This call must be called in the context of the thread that is faulting.
    This function is called at APC_LEVEL or below.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL irql;
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    PETHREAD thread;
    PIRP irp;
    PVOID saveAuxiliaryPointer = NULL;
    PFILE_OBJECT fileObject;

    thread = PsGetCurrentThread();

    //
    // Raise the IRQL so that the IrpList cannot be modified by a completion
    // APC.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    header = &thread->IrpList;
    entry = thread->IrpList.Flink;

    //
    // Walk the list of pending IRPs, completing each of them.
    //

    while (header != entry) {

        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        entry = entry->Flink;

        if (irp->Flags & IRP_RETRY_IO_COMPLETION) {

            ASSERT(!(irp->Flags & IRP_CREATE_OPERATION));

            irp->Flags &= ~IRP_RETRY_IO_COMPLETION;
            fileObject = irp->Tail.Overlay.OriginalFileObject;
            IopCompleteRequest(
                    &irp->Tail.Apc,
                    NULL,
                    NULL,
                    &fileObject,
                    &saveAuxiliaryPointer);
        }
    }

    KeLowerIrql( irql );
}

#if defined(_WIN64)
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp OPTIONAL
    )
/*+++

Routine Description:

   This API returns TRUE if the process that originated the IRP is running a 32 bit x86
   application. If there is no IRP then a NULL can be passed to the API and that implies
   that the current process context is used to test if its running a 32 bit x86 application.
   Its assumed a NULL will be passed by drivers executing in the fast io path.

Arguments:

    IRP  OPTIONAL.

Return Value:

    None.

--*/
{
    if (Irp) {
        if (Irp->RequestorMode == UserMode) {
            PEPROCESS Process;
            Process = IoGetRequestorProcess(Irp);
            if (Process && PsGetProcessWow64Process(Process)) {
                return TRUE;
            }
        }
    } else {
        if ((ExGetPreviousMode() == UserMode) &&
                (PsGetProcessWow64Process(PsGetCurrentProcess()))) {
            return TRUE;
        }
    }
    return FALSE;
}
#endif

NTSTATUS
IoQueryFileDosDeviceName(
    IN PFILE_OBJECT FileObject,
    OUT POBJECT_NAME_INFORMATION *ObjectNameInformation
    )

/*++

Routine Description:

    Thin shell around IopQueryNameInternal that returns a dos device name
    for a file e.g c:\foo

Arguments:

    FileObject - Points to the file that needs to be closed.

    ObjectNameInformation - structure to return name in note this will be a flat
      unicode string where the buffer is adjacent to the string

    RetLength - returned length of structure

Return Value:

    None

--*/

{
    ULONG ObjectNameInfoLength;
    POBJECT_NAME_INFORMATION ObjectNameInfo;
    NTSTATUS Status;

    //
    //  Allocate an initial buffer to query the filename, query, then
    //  retry if needed with the correct length.
    //

    ObjectNameInfoLength = 96*sizeof(WCHAR) + sizeof(UNICODE_STRING);

    while (TRUE) {

        ObjectNameInfo = ExAllocatePoolWithTag( PagedPool, ObjectNameInfoLength, 'nDoI');

        if (ObjectNameInfo == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Status = IopQueryNameInternal( FileObject,
                                       TRUE,
                                       TRUE,
                                       ObjectNameInfo,
                                       ObjectNameInfoLength,
                                       &ObjectNameInfoLength,
                                       KernelMode );

        if (Status == STATUS_SUCCESS) {
            *ObjectNameInformation = ObjectNameInfo;
            break;
        }

        ExFreePool( ObjectNameInfo );

        if (Status != STATUS_BUFFER_OVERFLOW) {
            break;
        }
    }

    return Status;
}


NTSTATUS
IopUnloadSafeCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_UNLOAD_SAFE_COMPLETION_CONTEXT Usc = Context;
    NTSTATUS Status;

    ObReferenceObject (Usc->DeviceObject);

    Status = Usc->CompletionRoutine (DeviceObject, Irp, Usc->Context);

    ObDereferenceObject (Usc->DeviceObject);
    ExFreePool (Usc);
    return Status;
}


NTSTATUS
IoSetCompletionRoutineEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN InvokeOnSuccess,
    IN BOOLEAN InvokeOnError,
    IN BOOLEAN InvokeOnCancel
    )
//++
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver. This routine obtains a reference count to the specified device object
//     to protect the completion routine from unload problems.
//
// Arguments:
//
//     DeviceObject - Device object to take references on.
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--
{
    PIO_UNLOAD_SAFE_COMPLETION_CONTEXT Usc;

    Usc = ExAllocatePoolWithTag (NonPagedPool, sizeof (*Usc), 'sUoI');
    if (Usc == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Usc->DeviceObject      = DeviceObject;
    Usc->CompletionRoutine = CompletionRoutine;
    Usc->Context           = Context;
    IoSetCompletionRoutine (Irp, IopUnloadSafeCompletion, Usc, InvokeOnSuccess, InvokeOnError, InvokeOnCancel);
    return STATUS_SUCCESS;
}

NTSTATUS
IoCreateDriver(
    IN PUNICODE_STRING DriverName    OPTIONAL,
    IN PDRIVER_INITIALIZE InitializationFunction
    )
/*++

Routine Description:

    This routine creates a driver object for a kernel component that
    was not loaded as a driver.  If the creation of the driver object
    succeeds, Initialization function is invoked with the same parameters
    as passed to DriverEntry.

Parameters:

    DriverName - Supplies the name of the driver for which a driver object
                 is to be created.

    InitializationFunction - Equivalent to DriverEntry().

ReturnValue:

    Status code that indicates whether or not the function was successful.

Notes:

--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    PDRIVER_OBJECT driverObject;
    HANDLE driverHandle;
    ULONG objectSize;
    USHORT length;
    UNICODE_STRING driverName, serviceName;
    WCHAR buffer[60];
    ULONG i;

    PAGED_CODE();

    if (DriverName == NULL) {

        //
        // Made-up a name for the driver object.
        //

        length = (USHORT) _snwprintf(buffer, (sizeof(buffer) / sizeof(WCHAR)) - 1, L"\\Driver\\%08u", KiQueryLowTickCount());
        driverName.Length = length * sizeof(WCHAR);
        driverName.MaximumLength = driverName.Length + sizeof(UNICODE_NULL);
        driverName.Buffer = buffer;                                                           \
    } else {
        driverName = *DriverName;
    }

    //
    // Attempt to create the driver object
    //

    InitializeObjectAttributes( &objectAttributes,
                                &driverName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    objectSize = sizeof( DRIVER_OBJECT ) + sizeof( DRIVER_EXTENSION );
    status = ObCreateObject( KernelMode,
                             IoDriverObjectType,
                             &objectAttributes,
                             KernelMode,
                             NULL,
                             objectSize,
                             0,
                             0,
                             &driverObject );

    if( !NT_SUCCESS( status )){

        //
        // Driver object creation failed
        //

        return status;
    }

    //
    // We've created a driver object, initialize it.
    //

    RtlZeroMemory( driverObject, objectSize );
    driverObject->DriverExtension = (PDRIVER_EXTENSION)(driverObject + 1);
    driverObject->DriverExtension->DriverObject = driverObject;
    driverObject->Type = IO_TYPE_DRIVER;
    driverObject->Size = sizeof( DRIVER_OBJECT );
    driverObject->Flags = DRVO_BUILTIN_DRIVER;
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
        driverObject->MajorFunction[i] = IopInvalidDeviceRequest;
    driverObject->DriverInit = InitializationFunction;

    serviceName.Buffer = (PWSTR)ExAllocatePool(PagedPool, driverName.Length + sizeof(WCHAR));
    if (serviceName.Buffer) {
        serviceName.MaximumLength = driverName.Length + sizeof(WCHAR);
        serviceName.Length = driverName.Length;
        RtlCopyMemory(serviceName.Buffer, driverName.Buffer, driverName.Length);
        serviceName.Buffer[serviceName.Length / sizeof(WCHAR)] = UNICODE_NULL;
        driverObject->DriverExtension->ServiceKeyName = serviceName;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto errorFreeDriverObject;
    }

    //
    // Insert it into the object table.
    //

    status = ObInsertObject( driverObject,
                             NULL,
                             FILE_READ_DATA,
                             OBJ_KERNEL_HANDLE,
                             NULL,
                             &driverHandle );

    if( !NT_SUCCESS( status )){

        //
        // Couldn't insert the driver object into the table.
        // The object got dereferenced by the object manager. Just exit
        //

        goto errorReturn;
    }

    //
    // Reference the handle and obtain a pointer to the driver object so that
    // the handle can be deleted without the object going away.
    //

    status = ObReferenceObjectByHandle( driverHandle,
                                        0,
                                        IoDriverObjectType,
                                        KernelMode,
                                        (PVOID *) &driverObject,
                                        (POBJECT_HANDLE_INFORMATION) NULL );
    if( !NT_SUCCESS( status )) {
       //
       // Backout here is probably bogus. If the ref didn't work then the handle is probably bad
       // Do this right though just in case there are other common error returns for ObRef...
       //
       ZwMakeTemporaryObject( driverHandle ); // Cause handle close to free the object
       ZwClose( driverHandle ); // Close the handle.
       goto errorReturn;
    }

    ZwClose( driverHandle );

    //
    // Store the name of the device driver in the driver object so that it
    // can be easily found by the error log thread.
    //

    driverObject->DriverName.Buffer = ExAllocatePool( PagedPool,
                                                      driverName.MaximumLength );
    if (driverObject->DriverName.Buffer) {
        driverObject->DriverName.MaximumLength = driverName.MaximumLength;
        driverObject->DriverName.Length = driverName.Length;

        RtlCopyMemory( driverObject->DriverName.Buffer,
                       driverName.Buffer,
                       driverName.MaximumLength );
    }

    //
    // Call the driver initialization routine
    //

    status = (*InitializationFunction)(driverObject, NULL);

    if( !NT_SUCCESS( status )){

errorFreeDriverObject:

        //
        // If we were unsuccessful, we need to get rid of the driverObject
        // that we created.
        //

        ObMakeTemporaryObject( driverObject );
        ObDereferenceObject( driverObject );
    }
errorReturn:
    return status;
}

VOID
IoDeleteDriver(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine deletes a driver object created explicitly through
    IoCreateDriver.

Parameters:

    DriverObject - Supplies a pointer to the driver object to be deleted.

ReturnValue:

    Status code that indicates whether or not the function was successful.

Notes:

--*/
{

    ObDereferenceObject(DriverObject);
}

PDEVICE_OBJECT
IoGetLowerDeviceObject(
    IN  PDEVICE_OBJECT  DeviceObject
    )
/*++

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DeviceObject - Supplies a pointer to the deviceObject whose next device object needs
                    to be obtained.

ReturnValue:

    NULL if driver is unloaded or marked for unload or if there is no attached deviceobject.
    Otherwise a referenced pointer to the deviceobject is returned.

Notes:

--*/
{
    KIRQL   irql;
    PDEVICE_OBJECT  targetDeviceObject;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if ((DeviceObject->DeviceObjectExtension->ExtensionFlags &
        (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED))) {

        KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );
        return NULL;
    }

    targetDeviceObject = NULL;
    if (DeviceObject->DeviceObjectExtension->AttachedTo) {
        targetDeviceObject = DeviceObject->DeviceObjectExtension->AttachedTo;
        ObReferenceObject(targetDeviceObject);
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return targetDeviceObject;
}

NTSTATUS
IoEnumerateDeviceObjectList(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PDEVICE_OBJECT  *DeviceObjectList,
    IN  ULONG           DeviceObjectListSize,
    OUT PULONG          ActualNumberDeviceObjects
    )
/*++

Routine Description:

    This routine gets the next lower device object on the device stack.

Parameters:

    DriverObject - Driver Object whose device objects have to be enumerated.

    DeviceObjectList - Pointer to an array where device object lists will be stored.

    DeviceObjectListSize - Size in bytes of the DeviceObjectList array

    ActualNumberDeviceObjects - The actual number of device objects in a driver object.

ReturnValue:

    If size is not sufficient it will return STATUS_BUFFER_TOO_SMALL.

Notes:

--*/
{
    KIRQL   irql;
    PDEVICE_OBJECT  deviceObject;
    ULONG   numListEntries;
    ULONG   numDeviceObjects = 0;
    NTSTATUS status = STATUS_SUCCESS;

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    deviceObject = DriverObject->DeviceObject;

    numListEntries = DeviceObjectListSize / sizeof(PDEVICE_OBJECT);

    while (deviceObject) {
        numDeviceObjects++;
        deviceObject = deviceObject->NextDevice;
    }

    *ActualNumberDeviceObjects = numDeviceObjects;

    if (numDeviceObjects > numListEntries) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    deviceObject = DriverObject->DeviceObject;

    while ((numListEntries > 0) && deviceObject) {
        ObReferenceObject(deviceObject);
        *DeviceObjectList = deviceObject;
        DeviceObjectList++;
        deviceObject = deviceObject->NextDevice;
        numListEntries--;
    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return status;
}

PDEVICE_OBJECT
IoGetDeviceAttachmentBaseRef(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine returns the lowest level device object associated with
    the specified device.

Arguments:

    DeviceObject - Supplies a pointer to the device for which the bottom of
        attachment chain is to be found.

Return Value:

    The function value is a reference to the lowest level device attached
    to the specified device.  If the supplied device object is that device
    object, then a pointer to it is returned.

    A reference is taken on the returned device object.  It is the
    responsibility of the caller to release it.

--*/

{
    PDEVICE_OBJECT baseDeviceObject;
    KIRQL irql;

    //
    // Any examination of attachment chain linkage must be done with
    // IopDatabaseLock taken.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    //
    // Find the base of the attachment chain.
    //

    baseDeviceObject = IopGetDeviceAttachmentBase( DeviceObject );

    //
    // Reference the device object before releasing the database lock.
    //

    ObReferenceObject( baseDeviceObject );
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return baseDeviceObject;
}

NTSTATUS
IoGetDiskDeviceObject(
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    )
/*++

Routine Description:

    This routine returns the disk device object associated with a filesystem
    volume device object. The disk device object need not be an actual disk but
    in general associated with storage.

Arguments:

    FileSystemDeviceObject - Supplies a pointer to the device for which the bottom of
        attachment chain is to be found.
    DiskDeviceObject     - Supplies storage for the return value.

Return Value:

    The function returns the disk device object associated with a filesystem
    device object. Returns a referenced device object. If the VPB reference count
    is zero we cannot rely on the device object pointer.

--*/
{
    KIRQL   irql;
    PVPB    vpb;

    //
    // Filesystem deviceobject's VPB field should be NULL
    //

    if (FileSystemDeviceObject->Vpb) {
        return STATUS_INVALID_PARAMETER;
    }

    IoAcquireVpbSpinLock(&irql);

    vpb = FileSystemDeviceObject->DeviceObjectExtension->Vpb;

    if (!vpb) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_INVALID_PARAMETER;
    }

    if (vpb->ReferenceCount == 0) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_VOLUME_DISMOUNTED;
    }

    if (!(vpb->Flags & VPB_MOUNTED)) {
        IoReleaseVpbSpinLock(irql);
        return STATUS_VOLUME_DISMOUNTED;
    }

    *DiskDeviceObject = vpb->RealDevice;
    ObReferenceObject( *DiskDeviceObject);
    IoReleaseVpbSpinLock(irql);

    return STATUS_SUCCESS;
}

NTSTATUS
IoSetSystemPartition(
    PUNICODE_STRING VolumeNameString
    )
/*++

Routine Description:

    This routine sets system partition registry key to the volume name string. Used
    by the mount manager in case volume name changes.

Arguments:

    VolumeNameString - Name of the volume that is the system partition.

Return Value:

    NTSTATUS

--*/
{
    HANDLE systemHandle, setupHandle;
    UNICODE_STRING nameString, machineSystemName;
    NTSTATUS    status;

    //
    // Declare a unicode buffer big enough to contain the longest string we'll be using.
    // (ANSI string in 'sizeof()' below on purpose--we want the number of chars here.)
    //
    WCHAR nameBuffer[sizeof("SystemPartition")];

    //
    // Open HKLM\SYSTEM key.
    //

    RtlInitUnicodeString(&machineSystemName, L"\\REGISTRY\\MACHINE\\SYSTEM");
    status = IopOpenRegistryKeyEx( &systemHandle,
                                   NULL,
                                   &machineSystemName,
                                   KEY_ALL_ACCESS
                                   );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Now open/create the setup subkey.
    //

    ASSERT( sizeof(L"Setup") <= sizeof(nameBuffer) );

    nameBuffer[0] = L'S';
    nameBuffer[1] = L'e';
    nameBuffer[2] = L't';
    nameBuffer[3] = L'u';
    nameBuffer[4] = L'p';
    nameBuffer[5] = L'\0';

    nameString.MaximumLength = sizeof(L"Setup");
    nameString.Length        = sizeof(L"Setup") - sizeof(WCHAR);
    nameString.Buffer        = nameBuffer;

    status = IopCreateRegistryKeyEx( &setupHandle,
                                     systemHandle,
                                     &nameString,
                                     KEY_ALL_ACCESS,
                                     REG_OPTION_NON_VOLATILE,
                                     NULL
                                     );

    NtClose(systemHandle);  // Don't need the handle to the HKLM\System key anymore.

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT( sizeof(L"SystemPartition") <= sizeof(nameBuffer) );

    nameBuffer[0]  = L'S';
    nameBuffer[1]  = L'y';
    nameBuffer[2]  = L's';
    nameBuffer[3]  = L't';
    nameBuffer[4]  = L'e';
    nameBuffer[5]  = L'm';
    nameBuffer[6]  = L'P';
    nameBuffer[7]  = L'a';
    nameBuffer[8]  = L'r';
    nameBuffer[9]  = L't';
    nameBuffer[10] = L'i';
    nameBuffer[11] = L't';
    nameBuffer[12] = L'i';
    nameBuffer[13] = L'o';
    nameBuffer[14] = L'n';
    nameBuffer[15] = L'\0';

    nameString.MaximumLength = sizeof(L"SystemPartition");
    nameString.Length        = sizeof(L"SystemPartition") - sizeof(WCHAR);



    status = ZwSetValueKey(setupHandle,
                            &nameString,
                            TITLE_INDEX_VALUE,
                            REG_SZ,
                            VolumeNameString->Buffer,
                            VolumeNameString->Length + sizeof(WCHAR)
                           );


    return status;
}


BOOLEAN
IoIsFileOriginRemote(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns the origin of the original create request for the
    specified file.  That is, was it created locally on this machine or remotely
    on another machine via a network provider.

Arguments:

    FileObject - Supplies the file object that is to be checked.

Return Value:

    TRUE - Means the create request originated on a remote machine.

    FALSE - Means the create request originated on the local machine.

--*/

{
    BOOLEAN Remote;


    //
    //  Check the origin flag and return the appropriate result.
    //

    if (FileObject->Flags & FO_REMOTE_ORIGIN) {

        Remote = TRUE;

    } else {

        Remote = FALSE;
    }

    return Remote;
}

NTSTATUS
IoSetFileOrigin(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Remote
    )

/*++

Routine Description:

    This routine sets the origin of the original create request for the
    specified file.  That is, was it created locally on this machine or remotely
    on another machine via a network provider.  By default file objects are
    considered to have a local origin.  Network providers should call this
    function in their server for any file objects that were created to satisfy
    a create request from their client.

Arguments:

    FileObject - Supplies the file object that is to be set.

    Remote - Supplies whether the file object is for a remote create request or not.

Return Value:

    Returns STATUS_SUCCESS unless the origin is already set to what the caller is requesting.

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER_MIX;


    //
    //  Set or clear the origin flag per the callers request.
    //

    if (Remote) {

        if ((FileObject->Flags & FO_REMOTE_ORIGIN) == 0) {

            FileObject->Flags |= FO_REMOTE_ORIGIN;
            Status = STATUS_SUCCESS;
        }

    } else {

        if (FileObject->Flags & FO_REMOTE_ORIGIN) {

            FileObject->Flags &= ~FO_REMOTE_ORIGIN;
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}


PVOID
IoGetFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    This routine returns the filter context associated with a fileobject that has an extension.

Arguments:

    FileObject  - FileObject for which the filter context is retrieved

Return Value:

    NTSTATUS

--*/
{
    PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);
        return (fileObjectExtension->FilterContext);
    }
    return NULL;
}


NTSTATUS
IoChangeFileObjectFilterContext(
    IN  PFILE_OBJECT    FileObject,
    IN  PVOID           FilterContext,
    IN  BOOLEAN         Set
    )
/*++

Routine Description:

    This routine set or clear fileobject filter context. It can be set only once.

Arguments:

    FileObject  - FileObject for which the filter context is retrieved
    FilterContext - New Filter context to be set in the fileobject extension
    Set - If TRUE allows FilterContext to be set in the fileobject only if the old value is NULL
          If FALSE allows fileObject field to be cleared only if FileContext is the old value in the fileobject.

Return Value:

    Returns NTSTATUS

--*/
{
    PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

    if (FileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
        fileObjectExtension =(PIOP_FILE_OBJECT_EXTENSION)(FileObject + 1);
        if (Set) {
            if (InterlockedCompareExchangePointer(&fileObjectExtension->FilterContext, FilterContext, NULL) != NULL)
                return STATUS_ALREADY_COMMITTED;
            return STATUS_SUCCESS;
        } else {
            if (InterlockedCompareExchangePointer(&fileObjectExtension->FilterContext, NULL, FilterContext) != FilterContext)
                return STATUS_ALREADY_COMMITTED;
            return STATUS_SUCCESS;
        }
    }
    return STATUS_INVALID_PARAMETER;
}


BOOLEAN
IoIsDeviceEjectable(
    IN  PDEVICE_OBJECT DeviceObject
    )
{
    if ((FILE_FLOPPY_DISKETTE & DeviceObject->Characteristics)
            || (InitWinPEModeType & INIT_WINPEMODE_INRAM)) {

        return TRUE;
    }

    return FALSE;
}


NTSTATUS
IoValidateDeviceIoControlAccess(
    IN  PIRP    Irp,
    IN  ULONG   RequiredAccess
    )
/*++

Routine Description:

    This routine validates ioctl access bits based on granted access information passed in the IRP.
    This routine is called by a driver to validate IOCTL access bits for IOCTLs that were originally
    defined as FILE_ANY_ACCESS and cannot be changed for compatibility reasons but really has to be
    validated for read/write access.


Arguments:

    IRP  - IRP for the device control
    RequiredAccess - Is the expected access required by the driver. Should be FILE_READ_ACCESS, FILE_WRITE_ACCESS
    or both.

Return Value:

    Returns NTSTATUS

--*/
{
    ACCESS_MASK         grantedAccess;
    PIO_STACK_LOCATION  irpSp;

    //
    // Validate RequiredAccess.
    //

    if (RequiredAccess & (FILE_READ_ACCESS|FILE_WRITE_ACCESS)){

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        //
        // If the driver passes the wrong IRP fail the API.
        //

        if ((irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) &&
            (irpSp->MajorFunction != IRP_MJ_FILE_SYSTEM_CONTROL)) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Kernel mode IRPs always succeed.
        //

        if (Irp->RequestorMode == KernelMode) {
            return STATUS_SUCCESS;
        }

        //
        // Get the granted access bits from the IRP.
        //

        grantedAccess = (irpSp->Flags & SL_READ_ACCESS_GRANTED) ? FILE_READ_DATA : 0;
        grantedAccess |= (irpSp->Flags & SL_WRITE_ACCESS_GRANTED) ? FILE_WRITE_DATA : 0;

        if (SeComputeGrantedAccesses ( grantedAccess, RequiredAccess ) != RequiredAccess ) {
            return STATUS_ACCESS_DENIED;
        } else {
            return STATUS_SUCCESS;
        }

    } else {
        return STATUS_INVALID_PARAMETER;
    }
}


IO_PAGING_PRIORITY
FASTCALL
IoGetPagingIoPriority(
    IN    PIRP    Irp
    )
/*++

Routine Description:

    This routine returns the paging priority for an IRP. Its
    called by the storage stack to determine how to queue the IRP to the
    disk.

Arguments:

    IRP  - IRP for paging IO.

Return Value:

    Returns IO_PAGING_PRIORITY

--*/
{
    if (Irp->Flags & IRP_HIGH_PRIORITY_PAGING_IO) {
        return IoPagingPriorityHigh;
    }
    if (!(Irp->Flags & IRP_PAGING_IO)) {
        return IoPagingPriorityInvalid;
    }
    return IoPagingPriorityNormal;
}

PDEVICE_OBJECT
IoFindDeviceThatFailedIrp(
    IN  PIRP    Irp
    )
/*++

Routine Description:

    This routine returns the top most device object in the stack
    that failed the IRP. It returns NULL if the IRP's status
    is successful. Note that its the responsibility of the caller
    to ensure that the device object is valid.

Arguments:

    IRP  - Pointer to IRP.

Return Value:

    Returns DEVICE_OBJECT pointer

--*/
{
    PIO_STACK_LOCATION  irpSp;
    ULONG               i;
    ULONG               stackSize = Irp->StackCount;

    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        return NULL;
    }

    irpSp = ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) +
            sizeof( IRP ) +
            ( (stackSize - 1) * sizeof( IO_STACK_LOCATION ))));


    for (i = 0; i < stackSize; i++, irpSp--) {
        if (irpSp->Control & SL_ERROR_RETURNED) {
            return irpSp->DeviceObject;
        }
    }

    return NULL;
}


NTSTATUS
IoEnumerateRegisteredFiltersList(
    IN  PDRIVER_OBJECT  *DriverObjectList,
    IN  ULONG           DriverObjectListSize,
    OUT PULONG          ActualNumberDriverObjects
    )
/*++

Routine Description:

    This routine retrieves a list of driver objects associated with all of the
    filters which have registered with the system.

Parameters:

    DriverObjectList - Pointer to an array where driver  object lists will be stored.

    DriverObjectListSize - Size in bytes of the DriverObjectList array

    ActualNumberDriverObjects - The actual number of driver objects returned.

ReturnValue:

    If size is not sufficient it will return STATUS_BUFFER_TOO_SMALL.

Notes:

--*/
{
    PNOTIFICATION_PACKET nPacket;
    PLIST_ENTRY entry;
    ULONG   numListEntries;
    ULONG   numDriverObjects = 0;
    NTSTATUS status = STATUS_SUCCESS;

    //
    //  Lock the list shared
    //

    ExAcquireResourceSharedLite( &IopDatabaseResource, TRUE );

    //
    //  Calculate how many entries can be returned
    //

    numListEntries = DriverObjectListSize / sizeof(PDRIVER_OBJECT);

    //
    //  Calculate how many entries are on the list
    //

    entry = IopFsNotifyChangeQueueHead.Flink;
    while (entry != &IopFsNotifyChangeQueueHead) {

        numDriverObjects++;
        entry = entry->Flink;
    }

    //
    //  Return total number of entries on the list
    //

    *ActualNumberDriverObjects = numDriverObjects;

    //
    //  If we don't have room for all of the entries, tell them about this
    //

    if (numDriverObjects > numListEntries) {
        status = STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Return what entries we can
    //

    entry = IopFsNotifyChangeQueueHead.Flink;

    while ((numListEntries > 0) && (entry != &IopFsNotifyChangeQueueHead)) {

        nPacket = CONTAINING_RECORD( entry, NOTIFICATION_PACKET, ListEntry );

        ObReferenceObject(nPacket->DriverObject);

        *DriverObjectList = nPacket->DriverObject;
        DriverObjectList++;

        entry = entry->Flink;
        numListEntries--;
    }

    ExReleaseResourceLite( &IopDatabaseResource );

    return status;
}

//
// Thunks to support standard call callers
//

#ifdef IoCallDriver
#undef IoCallDriver
#endif

NTSTATUS
IoCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    return IofCallDriver (DeviceObject, Irp);
}

#ifdef IoCompleteRequest
#undef IoCompleteRequest
#endif

VOID
IoCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    IofCompleteRequest (Irp, PriorityBoost);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\lock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lock.c

Abstract:

    This module contains the code to implement the NtLockFile and the
    NtUnlockFile system services for the NT I/O system.

--*/

#include "iomgr.h"

#pragma alloc_text(PAGE, NtLockFile)
#pragma alloc_text(PAGE, NtUnlockFile)

NTSTATUS
NtLockFile(
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PLARGE_INTEGER ByteOffset,
    __in PLARGE_INTEGER Length,
    __in ULONG Key,
    __in BOOLEAN FailImmediately,
    __in BOOLEAN ExclusiveLock
    )

/*++

Routine Description:

    This service locks a specified range of bytes on the file specified by
    the FileHandle parameter.  The lock may either be an exclusive lock or
    a shared lock.  Furthermore, the caller has the option of specifying
    whether or not the service should return immediately if the lock cannot
    be acquired without waiting.

Arguments:

    FileHandle - Supplies a handle to an open file.

    Event - Supplies an optional event to be set to the Signaled state when
        the operation is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    ByteOffset - Specifies the starting byte offset of the range to lock.

    Length - Specifies the length of the byte range to be locked.

    Key - Specifies the key to be associated with the lock.

    FailImmediately - Specifies that if the lock cannot immediately be
        acquired that the service should return to the caller.

    ExclusiveLock - Specifies, if TRUE, that the lock should be an exclusive
        lock;  otherwise the lock is a shared lock.

Return Value:

    The status returned is success if the operation was properly queued to
    the I/O system.  Once the operation completes, the status can be
    determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT eventObject = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER fileOffset;
    LARGE_INTEGER length;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers
    // in user mode.  Note that if the handle does not refer to a file
    // object, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either READ or WRITE access to
        // the file.  If not, cleanup and return an error.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus(IoStatusBlock);

            //
            // If this is a 32-bit asynchronous IO, then mark the Iosb being sent as so.
            // Note: IopMarkApcRoutineIfAsyncronousIo32 must be called after probing
            //       the IoStatusBlock structure for write.
            //

            IopMarkApcRoutineIfAsyncronousIo32(IoStatusBlock,ApcRoutine,(fileObject->Flags & FO_SYNCHRONOUS_IO));

            //
            // The ByteOffset parameter must be readable by the caller.  Probe
            // and capture it.
            //

            ProbeForReadSmallStructure( ByteOffset,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            fileOffset = *ByteOffset;

            //
            // Likewise, the Length parameter must also be readable by the
            // caller.  Probe and capture it as well.
            //

            ProbeForReadSmallStructure( Length,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            length = *Length;

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred attempting to probe the caller's
            // parameters.  Dereference the file object and return an
            // appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return GetExceptionCode();
        }

    } else {

        //
        // The caller's mode was kernel.  Get the ByteOffset and Length
        // parameter 's to the expected locations.
        //

        fileOffset = *ByteOffset;
        length = *Length;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.  Since certain legacy
    // applications rely on an old bug in Win32's LockFileEx, we must
    // tolerate bad event handles.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ASSERT( !eventObject );
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the target device object and the fast Io dispatch
    // structure.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Turbo lock support.  If the fast Io Dispatch specifies a fast lock
    // routine then we'll first try and calling it with the specified lock
    // parameters.
    //

    if (fastIoDispatch && fastIoDispatch->FastIoLock) {

        IO_STATUS_BLOCK localIoStatus;

        if (fastIoDispatch->FastIoLock( fileObject,
                                        &fileOffset,
                                        &length,
                                        PsGetCurrentProcessByThread(CurrentThread),
                                        Key,
                                        FailImmediately,
                                        ExclusiveLock,
                                        &localIoStatus,
                                        deviceObject )) {

            //
            // Carefully return the I/O status.
            //

            try {
#if defined(_WIN64)
                //
                // If this is a32-bit thread, and the IO request is 
                // asynchronous, then the IOSB is 32-bit. Wow64 always sends
                // the 32-bit IOSB when the I/O is asynchronous.
                //
                if (IopIsIosb32(ApcRoutine)) {
                    PIO_STATUS_BLOCK32 UserIosb32 = (PIO_STATUS_BLOCK32)IoStatusBlock;
                    
                    UserIosb32->Information = (ULONG)localIoStatus.Information;
                    UserIosb32->Status = (NTSTATUS)localIoStatus.Status;
                } else {
                    *IoStatusBlock = localIoStatus;
                }
#else
                *IoStatusBlock = localIoStatus;
#endif
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                localIoStatus.Status = GetExceptionCode();
                localIoStatus.Information = 0;
            }

            //
            // If a valid event was specified, set it.
            //

            if (eventObject) {
                KeSetEvent( eventObject, 0, FALSE );
                ObDereferenceObject( eventObject );
            }

            //
            // Note that the file object event need not be set to the
            // Signaled state, as it is already set.
            //

            //
            // If this file object has a completion port associated with it
            // and this request has a non-NULL APC context then a completion
            // message needs to be queued.
            //

            if (fileObject->CompletionContext && ARGUMENT_PRESENT( ApcContext )) {
                if (!NT_SUCCESS(IoSetIoCompletion( fileObject->CompletionContext->Port,
                                                   fileObject->CompletionContext->Key,
                                                   ApcContext,
                                                   localIoStatus.Status,
                                                   localIoStatus.Information,
                                                   TRUE ))) {
                    localIoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            //
            // Cleanup and return.
            //

            fileObject->LockOperation = TRUE;
            ObDereferenceObject( fileObject );
            return localIoStatus.Status;
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state and mark it as having had
    // a lock operation performed on it.
    //

    KeClearEvent( &fileObject->Event );
    fileObject->LockOperation = TRUE;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_LOCK;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Flags = 0;
    if (FailImmediately) {
        irpSp->Flags = SL_FAIL_IMMEDIATELY;
    }
    if (ExclusiveLock) {
        irpSp->Flags |= SL_EXCLUSIVE_LOCK;
    }
    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = fileOffset;

    try {
        PLARGE_INTEGER lengthBuffer;

        //
        // Attempt to allocate an intermediary buffer to hold the length of
        // this lock operation.  If it fails, either because there is no
        // more quota, or because there are no more resources, then the
        // exception handler will be invoked to cleanup and exit.
        //

        lengthBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                sizeof( LARGE_INTEGER ) );

        *lengthBuffer = length;
        irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
        irpSp->Parameters.LockControl.Length = lengthBuffer;
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred.  Simply clean everything up and
        // return an appropriate error status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             eventObject,
                             (PKEVENT) NULL );

        return GetExceptionCode();
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    return IopSynchronousServiceTail( deviceObject,
                                      irp,
                                      fileObject,
                                      FALSE,
                                      requestorMode,
                                      synchronousIo,
                                      OtherTransfer );
}

NTSTATUS
NtUnlockFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PLARGE_INTEGER ByteOffset,
    __in PLARGE_INTEGER Length,
    __in ULONG Key
    )

/*++

Routine Description:

    This service releases the lock associated with the specified byte range
    for the file specified by the FileHandle parameter.

Arguments:

    FileHandle - Supplies a handle to an open file.

    IoStatusBlock - Address of the caller's I/O status block.

    ByteOffset - Specifies the byte offset of the range to unlock.

    Length - Specifies the length of the byte range to unlock.

    Key - Specifies the key associated with the locked range.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT event;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    LARGE_INTEGER fileOffset;
    LARGE_INTEGER length;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers
    // in user mode.  Note that if the handle does not refer to a file
    // object, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either READ or WRITE access
        // to the file.  If not, cleanup and return an error.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, FILE_READ_DATA | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The ByteOffset parameter must be readable by the caller.  Probe
            // and capture it.
            //

            ProbeForReadSmallStructure( ByteOffset,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            fileOffset = *ByteOffset;

            //
            // Likewise, the Length parameter must also be readable by the
            // caller.  Probe and capture it as well.
            //

            ProbeForReadSmallStructure( Length,
                                        sizeof( LARGE_INTEGER ),
                                        sizeof( ULONG ) );
            length = *Length;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was kernel.  Get the ByteOffset and Length
        // parameter 's to the expected locations.
        //

        fileOffset = *ByteOffset;
        length = *Length;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.  Also get the fast I/O dispatch address.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Turbo lock support.  If the fast Io Dispatch specifies a fast lock
    // routine then we'll first try and calling it with the specified lock
    // parameters.
    //

    if (fastIoDispatch && fastIoDispatch->FastIoUnlockSingle) {

        IO_STATUS_BLOCK localIoStatus;

        if (fastIoDispatch->FastIoUnlockSingle( fileObject,
                                                &fileOffset,
                                                &length,
                                                PsGetCurrentProcessByThread(CurrentThread),
                                                Key,
                                                &localIoStatus,
                                                deviceObject )) {

            //
            // Carefully return the I/O status.
            //

            try {
                *IoStatusBlock = localIoStatus;
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                localIoStatus.Status = GetExceptionCode();
                localIoStatus.Information = 0;
            }

            //
            // Cleanup and return.
            //

            ObDereferenceObject( fileObject );
            return localIoStatus.Status;
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
        event = NULL;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (event) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
    irpSp->MinorFunction = IRP_MN_UNLOCK_SINGLE;
    irpSp->FileObject = fileObject;

    try {
        PLARGE_INTEGER lengthBuffer;

        //
        // Attempt to allocate an intermediary buffer to hold the length of
        // this lock operation.  If it fails, either because there is no
        // more quota, or because there are no more resources, then the
        // exception handler will be invoked to cleanup and exit.
        //

        lengthBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                sizeof( LARGE_INTEGER ) );

        *lengthBuffer = length;
        irp->Tail.Overlay.AuxiliaryBuffer = (PCHAR) lengthBuffer;
        irpSp->Parameters.LockControl.Length = lengthBuffer;
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred.  Simply clean everything up and
        // return an appropriate error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }
  
        IopExceptionCleanup( fileObject,
                             irp,
                             NULL,
                             (PKEVENT) NULL );

        return GetExceptionCode();
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.LockControl.Key = Key;
    irpSp->Parameters.LockControl.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\objsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    objsup.c

Abstract:

    This module contains the object support routine for the NT I/O system.

--*/

#include "iomgr.h"

NTSTATUS
IopSetDeviceSecurityDescriptors(
    IN PDEVICE_OBJECT           OriginalDeviceObject,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    );

NTSTATUS
IopSetDeviceSecurityDescriptor(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopCloseFile)
#pragma alloc_text(PAGE, IopDeleteFile)
#pragma alloc_text(PAGE, IopDeleteDevice)
#pragma alloc_text(PAGE, IopDeleteDriver)
#pragma alloc_text(PAGE, IopGetSetSecurityObject)
#pragma alloc_text(PAGE, IopSetDeviceSecurityDescriptors)
#pragma alloc_text(PAGE, IopSetDeviceSecurityDescriptor)
#endif

VOID
IopCloseFile(
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ULONG GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )

/*++

Routine Description:

    This routine is invoked whenever a handle to a file is deleted.  If the
    handle being deleted is the last handle to the file (the ProcessHandleCount
    parameter is one), then all locks for the file owned by the specified
    process must be released.

    Likewise, if the SystemHandleCount is one then this is the last handle
    for this for file object across all processes.  For this case, the file
    system is notified so that it can perform any necessary cleanup on the
    file.

Arguments:

    Process - A pointer to the process that closed the handle.

    Object - A pointer to the file object that the handle referenced.

    GrantedAccess - Access that was granted to the object through the handle.

    ProcessHandleCount - Count of handles outstanding to the object for the
        process specified by the Process argument.  If the count is one
        then this is the last handle to this file by that process.

    SystemHandleCount - Count of handles outstanding to the object for the
        entire system.  If the count is one then this is the last handle
        to this file in the system.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    KEVENT event;
    PFILE_OBJECT fileObject;
    KIRQL irql;

    UNREFERENCED_PARAMETER( GrantedAccess );

    PAGED_CODE();

    //
    // If the handle count is not one then this is not the last close of
    // this file for the specified process so there is nothing to do.
    //

    if (ProcessHandleCount != 1) {
        return;
    }

    fileObject = (PFILE_OBJECT) Object;

    if (fileObject->LockOperation && SystemHandleCount != 1) {

        IO_STATUS_BLOCK localIoStatus;

        //
        // This is the last handle for the specified process and the process
        // called the NtLockFile or NtUnlockFile system services at least once.
        // Also, this is not the last handle for this file object system-wide
        // so unlock all of the pending locks for this process.  Note that
        // this check causes an optimization so that if this is the last
        // system-wide handle to this file object the cleanup code will take
        // care of releasing any locks on the file rather than having to
        // send the file system two different packets to get them shut down.

        //
        // Get the address of the target device object and the Fast I/O dispatch
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                (VOID) IopAcquireFileObjectLock( fileObject,
                                                 KernelMode,
                                                 FALSE,
                                                 &interrupted );
            }
        }

        //
        // Turbo unlock support.  If the fast Io Dispatch specifies a fast lock
        // routine then we'll first try and calling it with the specified lock
        // parameters.  If this is all successful then we do not need to do
        // the Irp based unlock all call.
        //

        if (fastIoDispatch &&
            fastIoDispatch->FastIoUnlockAll &&
            fastIoDispatch->FastIoUnlockAll( fileObject,
                                             PsGetCurrentProcess(),
                                             &localIoStatus,
                                             deviceObject )) {

            NOTHING;

        } else {

            //
            // Initialize the local event that will be used to synchronize access
            // to the driver completing this I/O operation.
            //

            KeInitializeEvent( &event, SynchronizationEvent, FALSE );

            //
            // Reset the event in the file object.
            //

            KeClearEvent( &fileObject->Event );

            //
            // Allocate and initialize the I/O Request Packet (IRP) for this
            // operation.
            //

            irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
            irp->Tail.Overlay.OriginalFileObject = fileObject;
            irp->Tail.Overlay.Thread = PsGetCurrentThread();
            irp->RequestorMode = KernelMode;

            //
            // Fill in the service independent parameters in the IRP.
            //

            irp->UserEvent = &event;
            irp->UserIosb = &irp->IoStatus;
            irp->Flags = IRP_SYNCHRONOUS_API;
            irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

            //
            // Get a pointer to the stack location for the first driver.  This will
            // be used to pass the original function codes and parameters.  No
            // function-specific parameters are required for this operation.
            //

            irpSp = IoGetNextIrpStackLocation( irp );
            irpSp->MajorFunction = IRP_MJ_LOCK_CONTROL;
            irpSp->MinorFunction = IRP_MN_UNLOCK_ALL;
            irpSp->FileObject = fileObject;

            //
            //  Reference the fileobject again for the IRP (cleared on completion)
            //

            ObReferenceObject( fileObject );

            //
            // Insert the packet at the head of the IRP list for the thread.
            //

            IopQueueThreadIrp( irp );

            //
            // Invoke the driver at its appropriate dispatch entry with the IRP.
            //

            status = IoCallDriver( deviceObject, irp );

            //
            // If no error was incurred, wait for the I/O operation to complete.
            //

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              UserRequest,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
            }
        }

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    if (SystemHandleCount == 1) {

        //
        // The last handle to this file object for all of the processes in the
        // system has just been closed, so invoke the driver's "cleanup" handler
        // for this file.  This is the file system's opportunity to remove any
        // share access information for the file, to indicate that if the file
        // is opened for a caching operation and this is the last file object
        // to the file, then it can do whatever it needs with memory management
        // to cleanup any information.
        //
        // Begin by getting the address of the target device object.
        //

        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        //
        // Ensure that the I/O system believes that this file has a handle
        // associated with it in case it doesn't actually get one from the
        // Object Manager.  This is done because sometimes the Object Manager
        // actually creates a handle, but the I/O system never finds out
        // about it so it attempts to send two cleanups for the same file.
        //

        fileObject->Flags |= FO_HANDLE_CREATED;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        // Note : We need to do this only if IopCloseFile is not called from
        // IopDeleteFile
        //

        if (Process && fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                (VOID) IopAcquireFileObjectLock( fileObject,
                                                 KernelMode,
                                                 FALSE,
                                                 &interrupted );
            }
        }

        //
        // Initialize the local event that will be used to synchronize access
        // to the driver completing this I/O operation.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.
        //

        irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->RequestorMode = KernelMode;

        //
        // Fill in the service independent parameters in the IRP.
        //

        irp->UserEvent = &event;
        irp->UserIosb = &irp->IoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
        irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.  No
        // function-specific parameters are required for this operation.
        //

        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_CLEANUP;
        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Update the operation count statistic for the current process for
        // operations other than read and write.
        //

        IopUpdateOtherOperationCount();

        //
        // Invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If no error was incurred, wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // The following code tears down the IRP by hand since it may not
        // either be possible to it to be completed (because this code was
        // invoked as APC_LEVEL in the first place - or because the reference
        // count on the object cannot be incremented due to this routine
        // being invoked by the delete file procedure below).  Cleanup IRPs
        // therefore use close semantics (the close operation flag is set
        // in the IRP) so that the I/O complete request routine itself sets
        // the event to the Signaled state.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        //
        // Also, free the IRP.
        //

        IoFreeIrp( irp );

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        // Note : We need to do this only if IopCloseFile is not called from
        // IopDeleteFile
        //

        if (Process && fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return;
}

VOID
IopDeleteFile(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the last handle to a specific file handle is
    being closed and the file object is going away.  It is the responsibility
    of this routine to perform the following functions:

        o  Notify the device driver that the file object is open on that the
           file is being closed.

        o  Dereference the user's error port for the file object, if there
           is one associated with the file object.

        o  Decrement the device object reference count.

Arguments:

    Object - Pointer to the file object being deleted.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT fsDevice = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL irql;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    KEVENT event;
    PVPB vpb;
    BOOLEAN referenceCountDecremented;

    //
    // Obtain a pointer to the file object.
    //

    fileObject = (PFILE_OBJECT) Object;

    //
    // Get a pointer to the first device driver which should be notified that
    // this file is going away.  If the device driver field is NULL, then this
    // file is being shut down due to an error attempting to get it open in the
    // first place, so do not do any further processing.
    //

    if (fileObject->DeviceObject) {
        if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            deviceObject = IoGetRelatedDeviceObject( fileObject );
        } else {
            deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
        }

        // 
        // On IopDeleteFile path the lock should always be ours as there should be
        // no one else using this object.
        //

        ASSERT (!(fileObject->Flags & FO_SYNCHRONOUS_IO) ||
                 (InterlockedExchange( (PLONG) &fileObject->Busy, (ULONG) TRUE ) == FALSE ));

        //
        // If this file has never had a file handle created for it, and yet
        // it exists, invoke the close file procedure so that the file system
        // gets the cleanup IRP it is expecting before sending the close IRP.
        //

        if (!(fileObject->Flags & (FO_HANDLE_CREATED | FO_FILE_OPEN_CANCELLED))) {
            IopCloseFile( (PEPROCESS) NULL,
                          Object,
                          0,
                          1,
                          1 );
        }

        //
        // Reset a local event that can be used to wait for the device driver
        // to close the file.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate an I/O Request Packet (IRP) to be used in communicating with
        // the appropriate device driver that the file is being closed.  Notice
        // that the allocation of this packet is done without charging quota so
        // that the operation will not fail.  This is done because there is no
        // way to return an error to the caller at this point.
        //

        irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
        if (!irp) {
            irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        }

        //
        // Get a pointer to the stack location for the first driver.  This is
        // where the function codes and parameters are placed.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Fill in the IRP, indicating that this file object is being deleted.
        //

        irpSp->MajorFunction = IRP_MJ_CLOSE;
        irpSp->FileObject = fileObject;
        irp->UserIosb = &ioStatusBlock;
        irp->UserEvent = &event;
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
        irp->Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API;

        //
        // Place this packet in the thread's I/O pending queue.
        //

        IopQueueThreadIrp( irp );

        //
        // Decrement the reference count on the VPB, if necessary.  We
        // have to do this BEFORE handing the Irp to the file system
        // because of a trick the file systems play with close, and
        // believe me, you really don't want to know what it is.
        //
        // Since there is not a error path here (close cannot fail),
        // and the file system is the only ome who can actually synchronize
        // with the actual completion of close processing, the file system
        // is the one responsible for Vpb deletion.
        //

        vpb = fileObject->Vpb;


        if (vpb && !(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
            IopInterlockedDecrementUlong( LockQueueIoVpbLock,
                                          (PLONG) &vpb->ReferenceCount );

            //
            // Bump the handle count of the filesystem volume device object.
            // This will prevent the filesystem filter stack from being torn down
            // until after the close IRP completes.
            //

            fsDevice = vpb->DeviceObject;
            if (fsDevice) {
                IopInterlockedIncrementUlong( LockQueueIoDatabaseLock,
                                              &fsDevice->ReferenceCount );
            }
        }

        //
        // If this device object has stated for a fact that it knows it will
        // never have the final non-zero reference count among the other
        // device objects associated with our driver object, then decrement
        // our reference count here BEFORE calling the file system.  This
        // is required because for a special class of device objects, the
        // file system may delete them.
        //

        if (fileObject->DeviceObject->Flags & DO_NEVER_LAST_DEVICE) {
            IopInterlockedDecrementUlong( LockQueueIoDatabaseLock,
                                          &fileObject->DeviceObject->ReferenceCount );

            referenceCountDecremented = TRUE;
        } else {
            referenceCountDecremented = FALSE;
        }

        //
        // Give the device driver the packet.  If this request does not work,
        // there is nothing that can be done about it.  This is unfortunate
        // because the driver may have had problems that it was about to
        // report about other operations (e.g., write behind failures, etc.)
        // that it can no longer report.  The reason is that this routine
        // is really initially invoked by NtClose, which has already closed
        // the caller's handle, and that's what the return status from close
        // indicates:  the handle has successfully been closed.
        //

        status = IoCallDriver( deviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // Perform any completion operations that need to be performed on
        // the IRP that was used for this request.  This is done here as
        // as opposed to in normal completion code because there is a race
        // condition between when this routine executes if it was invoked
        // from a special kernel APC (e.g., some IRP was just completed and
        // dereferenced this file object for the last time), and when the
        // special kernel APC because of this packet's completion executing.
        //
        // This problem is solved by not having to queue a special kernel
        // APC routine for completion of this packet.  Rather, it is treated
        // much like a synchronous paging I/O operation, except that the
        // packet is not even freed during I/O completion.  This is because
        // the packet is still in this thread's queue, and there is no way
        // to get it out except at APC_LEVEL.  Unfortunately, the part of
        // I/O completion that needs to dequeue the packet is running at
        // DISPATCH_LEVEL.
        //
        // Hence, the packet must be removed from the queue (synchronized,
        // of course), and then it must be freed.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        IoFreeIrp( irp );

        //
        // Free the file name string buffer if there was one.
        //

        if (fileObject->FileName.Length != 0) {
            ExFreePool( fileObject->FileName.Buffer );
        }

        //
        // If there was an completion port associated w/this file object, dereference
        // it now, and deallocate the completion context pool.
        //

        if (fileObject->CompletionContext) {
            ObDereferenceObject( fileObject->CompletionContext->Port );
            ExFreePool( fileObject->CompletionContext );
        }

        //
        // Free the file context control structure if it exists.
        //

        if (fileObject->Flags & FO_FILE_OBJECT_HAS_EXTENSION) {
            FsRtlPTeardownPerFileObjectContexts(fileObject);
        }

        //
        // Get a pointer to the real device object so its reference count
        // can be decremented.
        //

        deviceObject = fileObject->DeviceObject;

        //
        // Decrement the reference count on the device object.  Note that
        // if the driver has been marked for an unload operation, and the
        // reference count goes to zero, then the driver may need to be
        // unloaded at this point.
        //
        // Note: only do this if the reference count was not already done
        // above.  The device object may be gone in this case.
        //

        if (!referenceCountDecremented) {

            IopDecrementDeviceObjectRef(
                deviceObject,
                FALSE,
                !ObIsObjectDeletionInline(Object)
                );
        }

        //
        // Decrement the filesystem's volume device object handle count
        // so that deletes can proceed.
        //

        if (fsDevice && vpb) {
            IopDecrementDeviceObjectRef(fsDevice,
                                         FALSE,
                                         !ObIsObjectDeletionInline(Object)
                                         );
        }
    }
}

VOID
IopDeleteDriver(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the reference count for a driver object
    becomes zero.  That is, the last reference for the driver has gone away.
    This routine ensures that the object is cleaned up and the driver
    unloaded.

Arguments:

    Object - Pointer to the driver object whose reference count has gone
        to zero.

Return value:

    None.

--*/

{
    PDRIVER_OBJECT driverObject = (PDRIVER_OBJECT) Object;
    PIO_CLIENT_EXTENSION extension;
    PIO_CLIENT_EXTENSION nextExtension;

    PAGED_CODE();

    ASSERT( !driverObject->DeviceObject );

    //
    // Free any client driver object extensions.
    //

    extension = driverObject->DriverExtension->ClientDriverExtension;
    while (extension != NULL) {

        nextExtension = extension->NextExtension;
        ExFreePool( extension );
        extension = nextExtension;
    }

    //
    // If there is a driver section then unload the driver.
    //

    if (driverObject->DriverSection != NULL) {
        //
        // Make sure any DPC's that may be running inside the driver have completed
        //
        KeFlushQueuedDpcs ();

        MmUnloadSystemImage( driverObject->DriverSection );

        PpDriverObjectDereferenceComplete(driverObject);
    }

    //
    // Free the pool associated with the name of the driver.
    //

    if (driverObject->DriverName.Buffer) {
        ExFreePool( driverObject->DriverName.Buffer );
    }

    //
    // Free the pool associated with the service key name of the driver.
    //

    if (driverObject->DriverExtension->ServiceKeyName.Buffer) {
        ExFreePool( driverObject->DriverExtension->ServiceKeyName.Buffer );
    }

    //
    // Free the pool associated with the FsFilterCallbacks structure.
    //

    if (driverObject->DriverExtension->FsFilterCallbacks) {
        ExFreePool( driverObject->DriverExtension->FsFilterCallbacks );
    }
}

VOID
IopDeleteDevice(
    IN PVOID    Object
    )

/*++

Routine Description:

    This routine is invoked when the reference count for a device object
    becomes zero.  That is, the last reference for the device has gone away.
    This routine ensures that the object is cleaned up and the driver object
    is dereferenced.

Arguments:

    Object - Pointer to the driver object whose reference count has gone
        to zero.

Return value:

    None.

--*/

{
    PDEVICE_OBJECT deviceObject = (PDEVICE_OBJECT) Object;
    PVPB vpb = NULL;

    PAGED_CODE();

    IopDestroyDeviceNode(deviceObject->DeviceObjectExtension->DeviceNode);

    //
    // If there's still a VPB attached then free it.
    //

    vpb = InterlockedExchangePointer(&(deviceObject->Vpb), vpb);

    if(vpb != NULL) {

        ASSERTMSG("Unreferenced device object to be deleted is still in use",
                  ((vpb->Flags & (VPB_MOUNTED | VPB_LOCKED)) == 0));

        ASSERT(vpb->ReferenceCount == 0);
        ExFreePool(vpb);
    }
    if (deviceObject->DriverObject != NULL) {
        ObDereferenceObject( deviceObject->DriverObject );
    }
}


PDEVICE_OBJECT
IopGetDevicePDO(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Call this routine to obtain the Base PDO for a device object

Arguments:

    DeviceObject - pointer to device object to get PDO for

ReturnValue:

    PDO if DeviceObject is attached to a PDO, otherwise NULL
    The returned PDO is reference-counted

--*/
{
    PDEVICE_OBJECT deviceBaseObject;
    KIRQL irql;

    ASSERT(DeviceObject);

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );
    deviceBaseObject = IopGetDeviceAttachmentBase(DeviceObject);
    if ((deviceBaseObject->Flags & DO_BUS_ENUMERATED_DEVICE) != 0) {
        //
        // we have determined that this is attached to a PDO
        //
        ObReferenceObject( deviceBaseObject );

    } else {
        //
        // not a PDO
        //
        deviceBaseObject = NULL;
    }
    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return deviceBaseObject;
}


NTSTATUS
IopSetDeviceSecurityDescriptor(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    )
/*++

Routine Description:

    This routine sets the security descriptor on a single device object

Arguments:

    DeviceObject - pointer to base device object

    SecurityInformation - Fields of SD to change
    SecurityDescriptor  - New security descriptor
    PoolType            - Pool type for allocations
    GenericMapping      - Generic mapping for this object

ReturnValue:

    success, or error while setting the descriptor for the device object.

--*/
{

    PSECURITY_DESCRIPTOR OldDescriptor;
    PSECURITY_DESCRIPTOR NewDescriptor;
    PSECURITY_DESCRIPTOR CachedDescriptor;
    NTSTATUS Status;
    PKTHREAD CurrentThread;

    PAGED_CODE();

    //
    // In order to preserve some protected fields in the SD (like the SACL) we need to make sure that only one
    // thread updates it at any one time. If we didn't do this another modification could wipe out a SACL
    // an administrator was adding.
    //
    CurrentThread = KeGetCurrentThread ();
    while (1) {

        //
        // Reference the security descriptor
        //

        KeEnterCriticalRegionThread(CurrentThread);
        ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

        OldDescriptor = DeviceObject->SecurityDescriptor;
        if (OldDescriptor != NULL) {
            ObReferenceSecurityDescriptor( OldDescriptor, 1 );
        }

        ExReleaseResourceLite( &IopSecurityResource );
        KeLeaveCriticalRegionThread(CurrentThread);

        NewDescriptor = OldDescriptor;

        Status = SeSetSecurityDescriptorInfo( NULL,
                                              SecurityInformation,
                                              SecurityDescriptor,
                                              &NewDescriptor,
                                              PoolType,
                                              GenericMapping );
        //
        //  If we successfully set the new security descriptor then we
        //  need to log it in our database and get yet another pointer
        //  to the finally security descriptor
        //
        if ( NT_SUCCESS( Status )) {
            Status = ObLogSecurityDescriptor( NewDescriptor,
                                              &CachedDescriptor,
                                              1 );
            ExFreePool( NewDescriptor );
            if ( NT_SUCCESS( Status )) {
                //
                // Now we need to see if anyone else update this security descriptor inside the
                // gap where we didn't hold the lock. If they did then we just try it all again.
                //
                KeEnterCriticalRegionThread(CurrentThread);
                ExAcquireResourceExclusiveLite( &IopSecurityResource, TRUE );

                if (DeviceObject->SecurityDescriptor == OldDescriptor) {
                    //
                    // Do the swap
                    //
                    DeviceObject->SecurityDescriptor = CachedDescriptor;

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(CurrentThread);

                    //
                    // If there was an original object then we need to work out how many
                    // cached references there were (if any) and return them.
                    //
                    ObDereferenceSecurityDescriptor( OldDescriptor, 2 );
                    break;
                } else {

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(CurrentThread);

                    ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                    ObDereferenceSecurityDescriptor( CachedDescriptor, 1);
                }

            } else {

                //
                //  Dereference old SecurityDescriptor
                //

                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
                break;
            }
        } else {

            //
            //  Dereference old SecurityDescriptor
            //
            if (OldDescriptor != NULL) {
                ObDereferenceSecurityDescriptor( OldDescriptor, 1 );
            }
            break;
        }
    }

    //
    //  And return to our caller
    //

    return( Status );
}


NTSTATUS
IopSetDeviceSecurityDescriptors(
    IN PDEVICE_OBJECT           OriginalDeviceObject,
    IN PDEVICE_OBJECT           DeviceObject,
    IN PSECURITY_INFORMATION    SecurityInformation,
    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,
    IN POOL_TYPE                PoolType,
    IN PGENERIC_MAPPING         GenericMapping
    )
/*++

Routine Description:

    This routine sets the security descriptor on all the devices on the
    device stack for a PNP device. Ideally when the object manager asks the
    IO manager to set the security descriptor of a device object the IO manager
    should set the descriptor only on that device object. This is the classical
    behavior.
    Unfortunately for PNP devices there may be multiple devices on a device
    stack with names.
    If the descriptor is applied to only one of the devices on the stack its
    opens up a security hole as there may be other devices with name on the
    stack which can be opened by a random program.
    To protect against this the descriptor is applied to all device objects on
    the stack.
    Its important that to protect compatibility we need to return the same
    status as what would have been returned if only the requested device
    object's descriptor was set.

Arguments:

    OriginalDeviceObject - Pointer to the device object passed by the object manager
    DeviceObject - pointer to base device object (first one to set)
    SecurityInformation )_ passed directly from IopGetSetSecurityObject
    SecurityDescriptor  )
    PoolType            )
    GenericMapping      )

ReturnValue:

    success, or error while setting the descriptor for the original device object.

--*/
{
    PDEVICE_OBJECT NewDeviceObject = NULL;
    NTSTATUS status;
    NTSTATUS returnStatus = STATUS_SUCCESS;

    ASSERT(DeviceObject);

    PAGED_CODE();

    //
    // pre-reference this object to match the dereference later
    //

    ObReferenceObject( DeviceObject );

    do {

        //
        // Reference the existing security descriptor so it can't be reused.
        // We will only do the final security change if nobody else changes
        // the security while we don't hold the lock. Doing this prevents
        // privileged information being lost like the SACL.
        //

        //
        // Save away and return the device status only for the main device object
        // For example if OldSecurityDescriptor is NULL the IO manager should
        // return STATUS_NO_SECURITY_ON_OBJECT.
        //

        status = IopSetDeviceSecurityDescriptor( DeviceObject,
                                                 SecurityInformation,
                                                 SecurityDescriptor,
                                                 PoolType,
                                                 GenericMapping );


        if (DeviceObject == OriginalDeviceObject) {
            returnStatus = status;
        }


        //
        // We don't need to acquire the database lock because
        // we have a handle to this device stack.
        //

        NewDeviceObject = DeviceObject->AttachedDevice;
        if ( NewDeviceObject != NULL ) {
            ObReferenceObject( NewDeviceObject );
        }

        ObDereferenceObject( DeviceObject );
        DeviceObject = NewDeviceObject;

    } while (NewDeviceObject);

    return returnStatus;
}


NTSTATUS
IopGetSetSecurityObject(
    IN PVOID Object,
    IN SECURITY_OPERATION_CODE OperationCode,
    IN PSECURITY_INFORMATION SecurityInformation,
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN OUT PULONG CapturedLength,
    IN OUT PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    IN POOL_TYPE PoolType,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine is invoked to either query or set the security descriptor
    for a file, directory, volume, or device.  It implements these functions
    by either performing an in-line check if the file is a device or a
    volume, or an I/O Request Packet (IRP) is generated and given to the
    driver to perform the operation.

Arguments:

    Object - Pointer to the file or device object representing the open object.

    SecurityInformation - Information about what is being done to or obtained
        from the object's security descriptor.

    SecurityDescriptor - Supplies the base security descriptor and returns
        the final security descriptor.  Note that if this buffer is coming
        from user space, it has already been probed by the object manager
        to length "CapturedLength", otherwise it points to kernel space and
        should not be probed.  It must, however, be referenced in a try
        clause.

    CapturedLength - For a query operation this specifies the size, in
        bytes, of the output security descriptor buffer and on return
        contains the number of bytes needed to store the complete security
        descriptor.  If the length needed is greater than the length
        supplied the operation will fail.  This parameter is ignored for
        the set and delete operations.  It is expected to point into
        system space, ie, it need not be probed and it will not change.

    ObjectsSecurityDescriptor - Supplies and returns the object's security
        descriptor.

    PoolType - Specifies from which type of pool memory is to be allocated.

    GenericMapping - Supplies the generic mapping for the object type.

Return Value:

    The final status of the operation is returned as the function value.

--*/

{
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT devicePDO = NULL;
    BOOLEAN synchronousIo;
    PSECURITY_DESCRIPTOR oldSecurityDescriptor, CachedSecurityDescriptor;
    PETHREAD CurrentThread;

    UNREFERENCED_PARAMETER( ObjectsSecurityDescriptor );
    UNREFERENCED_PARAMETER( PoolType );

    PAGED_CODE();


    //
    // Begin by determining whether the security operation is to be performed
    // in this routine or by the driver.  This is based upon whether the
    // object represents a device object, or it represents a file object
    // to a device, or a file on the device. If the open is a direct device
    // open then use the device object.
    //

    if (((PDEVICE_OBJECT) (Object))->Type == IO_TYPE_DEVICE) {
        deviceObject = (PDEVICE_OBJECT) Object;
        fileObject = (PFILE_OBJECT) NULL;
    } else {
        fileObject = (PFILE_OBJECT) Object;
        deviceObject = fileObject->DeviceObject;
    }

    if (!fileObject ||
        (!fileObject->FileName.Length && !fileObject->RelatedFileObject) ||
        (fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {

        //
        // This security operation is for the device itself, either through
        // a file object, or directly to the device object.  For the latter
        // case, assignment operations are also possible.  Also note that
        // this may be a stream file object, which do not have security.
        // The security for a stream file is actually represented by the
        // security descriptor on the file itself, or the volume, or the
        // device.
        //

        if (OperationCode == AssignSecurityDescriptor) {

            //
            // Simply assign the security descriptor to the device object,
            // if this is a device object.
            //

            status = STATUS_SUCCESS;

            if (fileObject == NULL || !(fileObject->Flags & FO_STREAM_FILE)) {

                status = ObLogSecurityDescriptor( SecurityDescriptor,
                                                  &CachedSecurityDescriptor,
                                                  1 );
                ExFreePool (SecurityDescriptor);
                if (NT_SUCCESS( status )) {

                    CurrentThread = PsGetCurrentThread ();
                    KeEnterCriticalRegionThread(&CurrentThread->Tcb);
                    ExAcquireResourceExclusiveLite( &IopSecurityResource, TRUE );

                    deviceObject->SecurityDescriptor = CachedSecurityDescriptor;

                    ExReleaseResourceLite( &IopSecurityResource );
                    KeLeaveCriticalRegionThread(&CurrentThread->Tcb);
                }
            }

        } else if (OperationCode == SetSecurityDescriptor) {

            //
            // This is a set operation.  The SecurityInformation parameter
            // determines what part of the SecurityDescriptor is going to
            // be applied to the ObjectsSecurityDescriptor.
            //

            //
            // if this deviceObject is attached to a PDO then we want
            // to modify the security on the PDO and apply it up the
            // device chain. This applies to PNP device objects only. See
            // comment in IopSetDeviceSecurityDescriptors
            //
            devicePDO = IopGetDevicePDO(deviceObject);

            if (devicePDO) {

                //
                // set PDO and all attached device objects
                //

                status = IopSetDeviceSecurityDescriptors(
                                deviceObject,
                                devicePDO,
                                SecurityInformation,
                                SecurityDescriptor,
                                PoolType,
                                GenericMapping );

                ObDereferenceObject( devicePDO );

            } else {

                //
                // set this device object only
                //

                status = IopSetDeviceSecurityDescriptor( deviceObject,
                                                         SecurityInformation,
                                                         SecurityDescriptor,
                                                         PoolType,
                                                         GenericMapping );

            }

        } else if (OperationCode == QuerySecurityDescriptor) {

            //
            // This is a get operation.  The SecurityInformation parameter
            // determines what part of the SecurityDescriptor is going to
            // be returned from the ObjectsSecurityDescriptor.
            //

            CurrentThread = PsGetCurrentThread ();
            KeEnterCriticalRegionThread(&CurrentThread->Tcb);
            ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

            oldSecurityDescriptor = deviceObject->SecurityDescriptor;
            if (oldSecurityDescriptor != NULL) {
                ObReferenceSecurityDescriptor( oldSecurityDescriptor, 1 );
            }

            ExReleaseResourceLite( &IopSecurityResource );
            KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

            status = SeQuerySecurityDescriptorInfo( SecurityInformation,
                                                    SecurityDescriptor,
                                                    CapturedLength,
                                                    &oldSecurityDescriptor );

            if (oldSecurityDescriptor != NULL) {
                ObDereferenceSecurityDescriptor( oldSecurityDescriptor, 1 );
            }

        } else {

            //
            // This is a delete operation.  Simply indicate that everything
            // worked just fine.
            //

            status = STATUS_SUCCESS;

        }

    } else if (OperationCode == DeleteSecurityDescriptor) {

        //
        // This is a delete operation for the security descriptor on a file
        // object.  This function will be performed by the file system once
        // the FCB itself is deleted.  Simply indicate that the operation
        // was successful.
        //

        status = STATUS_SUCCESS;

    } else {

        PIRP irp;
        IO_STATUS_BLOCK localIoStatus;
        KEVENT event;
        PIO_STACK_LOCATION irpSp;
        KPROCESSOR_MODE requestorMode;

        //
        // This file object does not refer to the device itself.  Rather, it
        // refers to either a file or a directory on the device.  This means
        // that the request must be passed to the file system for processing.
        // Note that the only requests that are passed through in this manner
        // are SET or QUERY security operations.  DELETE operations have
        // already been taken care of above since the file system which just
        // drop the storage on the floor when it really needs to, and ASSIGN
        // operations are irrelevant to file systems since they never
        // generate one because they never assign the security descriptor
        // to the object in the first place, they just assign it to the FCB.
        //

        CurrentThread = PsGetCurrentThread ();
        requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

        //
        // Begin by referencing the object by pointer.   Note that the object
        // handle has already been checked for the appropriate access by the
        // object system caller.  This reference must be performed because
        // standard I/O completion will dereference the object.
        //

        ObReferenceObject( fileObject );

        //
        // Make a special check here to determine whether this is a synchronous
        // I/O operation.  If it is, then wait here until the file is owned by
        // the current thread.  If this is not a (serialized) synchronous I/O
        // operation, then initialize the local event.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

            BOOLEAN interrupted;

            if (!IopAcquireFastLock( fileObject )) {
                status = IopAcquireFileObjectLock( fileObject,
                                                   requestorMode,
                                                   (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                                   &interrupted );
                if (interrupted) {
                    ObDereferenceObject( fileObject );
                    return status;
                }
            }
            synchronousIo = TRUE;
        } else {
            KeInitializeEvent( &event, SynchronizationEvent, FALSE );
            synchronousIo = FALSE;
        }

        //
        // Set the file object to the Not-Signaled state.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Get the address of the target device object.
        //

        deviceObject = IoGetRelatedDeviceObject( fileObject );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.  The allocation is performed with an exception handler
        // in case the caller does not have enough quota to allocate the packet.

        irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
        if (!irp) {

            //
            // An IRP could not be allocated.  Cleanup and return an
            // appropriate error status code.
            //

            IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

            return STATUS_INSUFFICIENT_RESOURCES;
        }
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = CurrentThread;
        irp->RequestorMode = requestorMode;

        //
        // Fill in the service independent parameters in the IRP.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            irp->UserEvent = (PKEVENT) NULL;
        } else {
            irp->UserEvent = &event;
            irp->Flags = IRP_SYNCHRONOUS_API;
        }
        irp->UserIosb = &localIoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Now determine whether this is a set or a query operation.
        //

        if (OperationCode == QuerySecurityDescriptor) {

            //
            // This is a query operation.  Fill in the appropriate fields in
            // the stack location for the packet, as well as the fixed part
            // of the packet.  Note that each of these parameters has been
            // captured as well, so there is no need to perform any probing.
            // The only exception is the UserBuffer memory may change, but
            // that is the file system's responsibility to check.  Note that
            // it has already been probed, so the pointer is at least not
            // in an address space that the caller should not be accessing
            // because of mode.
            //

            irpSp->MajorFunction = IRP_MJ_QUERY_SECURITY;
            irpSp->Parameters.QuerySecurity.SecurityInformation = *SecurityInformation;
            irpSp->Parameters.QuerySecurity.Length = *CapturedLength;
            irp->UserBuffer = SecurityDescriptor;

        } else {

            //
            // This is a set operation.  Fill in the appropriate fields in
            // the stack location for the packet.  Note that access to the
            // SecurityInformation parameter is safe, as the parameter was
            // captured by the caller.  Likewise, the SecurityDescriptor
            // refers to a captured copy of the descriptor.
            //

            irpSp->MajorFunction = IRP_MJ_SET_SECURITY;
            irpSp->Parameters.SetSecurity.SecurityInformation = *SecurityInformation;
            irpSp->Parameters.SetSecurity.SecurityDescriptor = SecurityDescriptor;

        }

        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Update the operation count statistic for the current process for
        // operations other than read and write.
        //

        IopUpdateOtherOperationCount();

        //
        // Everything has been properly set up, so simply invoke the driver.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If this operation was a synchronous I/O operation, check the return
        // status to determine whether or not to wait on the file object.  If
        // the file object is to be waited on, wait for the operation to be
        // completed and obtain the final status from the file object itself.
        //

        if (synchronousIo) {
            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &fileObject->Event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
                status = fileObject->FinalStatus;
            }
            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait
            // for the local event and return the final status information
            // back to the caller.
            //

            if (status == STATUS_PENDING) {
                (VOID) KeWaitForSingleObject( &event,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              (PLARGE_INTEGER) NULL );
                status = localIoStatus.Status;
            }
        }

        //
        // If this operation was just attempted on a file system or a device
        // driver of some kind that does not implement security, then return
        // a normal null security descriptor.
        //

        if (status == STATUS_INVALID_DEVICE_REQUEST) {

            //
            // The file system does not implement a security policy.  Determine
            // what type of operation this was and implement the correct
            // semantics for the file system.
            //

            if (OperationCode == QuerySecurityDescriptor) {

                //
                // The operation is a query.  If the caller's buffer is too
                // small, then indicate that this is the case and let him know
                // what size buffer is required.  Otherwise, attempt to return
                // a null security descriptor.
                //

               try {
                    status = SeAssignWorldSecurityDescriptor(
                                 SecurityDescriptor,
                                 CapturedLength,
                                 SecurityInformation
                                 );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    // An exception was incurred while attempting to
                    // access the caller's buffer.  Clean everything
                    // up and return an appropriate status code.
                    //

                    status = GetExceptionCode();
                }

            } else {

                //
                // This was an operation other than a query.  Simply indicate
                // that the operation was successful.
                //

                status = STATUS_SUCCESS;
            }

        } else if (OperationCode == QuerySecurityDescriptor) {

            //
            // The final return status from the file system was something
            // other than invalid device request.  This means that the file
            // system actually implemented the query.  Copy the size of the
            // returned data, or the size of the buffer required in order
            // to query the security descriptor.  Note that once again the
            // assignment is performed inside of an exception handler in case
            // the caller's buffer is inaccessible.  Also note that in order
            // for the Information field of the I/O status block to be set,
            // the file system must return a warning status.  Return the
            // status that the caller expects if the buffer really is too
            // small.
            //

            if (status == STATUS_BUFFER_OVERFLOW) {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            try {

                *CapturedLength = (ULONG) localIoStatus.Information;

            } except( EXCEPTION_EXECUTE_HANDLER ) {
                status = GetExceptionCode();
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\open.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    open.c

Abstract:

    This module contains the code to implement the NtOpenFile system
    service.

--*/

#include "iomgr.h"

#pragma alloc_text(PAGE, NtOpenFile)

NTSTATUS
NtOpenFile(
    __out PHANDLE FileHandle,
    __in ACCESS_MASK DesiredAccess,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in ULONG ShareAccess,
    __in ULONG OpenOptions
    )

/*++

Routine Description:

    This service opens a file or a device.  It is used to establish a file
    handle to the open device/file that can then be used in subsequent
    operations to perform I/O operations on.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    OpenOptions - Caller options for how to perform the open.

Return Value:

    The function value is the final completion status of the open/create
    operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to perform the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         FILE_OPEN,
                         OpenOptions,
                         (PVOID) NULL,
                         0L,
                         CreateFileTypeNone,
                         (PVOID) NULL,
                         0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\qsfs.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    qsfs.c

Abstract:

    This module contains the code to implement the NtQueryVolumeInformationFile
    and NtSetVolumeInformationFile system services for the NT I/O system.

--*/

#include "iomgr.h"
#pragma hdrstop
#include <ioevent.h>

#pragma alloc_text(PAGE, NtQueryVolumeInformationFile)
#pragma alloc_text(PAGE, NtSetVolumeInformationFile)

NTSTATUS
NtQueryVolumeInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service returns information about the volume associated with the
    FileHandle parameter.  The information returned in the buffer is defined
    by the FsInformationClass parameter.  The legal values for this parameter
    are as follows:

        o  FileFsVolumeInformation

        o  FileFsSizeInformation

        o  FileFsDeviceInformation

        o  FileFsAttributeInformation

Arguments:

    FileHandle - Supplies a handle to an open volume, directory, or file
        for which information about the volume is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();


    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FsInformationClass parameter is legal for querying
        // information about the volume.
        //

        if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
            IopQueryFsOperationLength[FsInformationClass] == 0) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Finally, ensure that the supplied buffer is large enough to contain
        // the information associated with the specified query operation that
        // is to be performed.
        //

        if (Length < (ULONG) IopQueryFsOperationLength[FsInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FsInformation buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( FsInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( FsInformation, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( FsInformation,
                               Length,
                               IopQuerySetFsAlignmentRequirement[FsInformationClass] );

            }
#else
            ProbeForWrite( FsInformation,
                           Length,
                           IopQuerySetFsAlignmentRequirement[FsInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred probing the caller's parameters.
            // Simply return an appropriate error status code.
            //


            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopQueryFsOperationAccess[FsInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this open file object represents an open device that was explicitly
    // opened for querying the device's attributes, then ensure that the type
    // of information class was device information.
    //

    if ((fileObject->Flags & FO_DIRECT_DEVICE_OPEN) &&
        FsInformationClass != FileFsDeviceInformation) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.  A special check is made
    // here to determine whether this query is for device information.  If
    // it is, and either:
    //
    //     a)  The open was for the device itself, or
    //
    //     b)  The open was for a file but this is not a redirected device,
    //
    // then perform the query operation in-line.  That is, do not allocate
    // an IRP and call the driver, rather, simply copy the device type and
    // characteristics information from the target device object pointed
    // to by the device object in the file object (the "real" device object
    // in a mass storage device stack).
    //

    if (FsInformationClass == FileFsDeviceInformation &&
        (fileObject->Flags & FO_DIRECT_DEVICE_OPEN ||
        fileObject->DeviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM)) {

        PFILE_FS_DEVICE_INFORMATION deviceAttributes;
        BOOLEAN deviceMounted = FALSE;

        //
        // This query operation can be performed in-line.  Simply copy the
        // information directly from the target device object and indicate
        // that the operation was successful.  Begin, however, by determining
        // whether or not the device is mounted.  This cannot be done at the
        // same time as attempting to touch the user's buffer, as looking at
        // the mounted bit occurs at raised IRQL.
        //

        deviceObject = fileObject->DeviceObject;
        if (deviceObject->Vpb) {
            deviceMounted = IopGetMountFlag( deviceObject );
        }

        //
        // Copy the characteristics information from the device's object
        // into the caller's buffer.
        //

        deviceAttributes = (PFILE_FS_DEVICE_INFORMATION) FsInformation;

        try {

            deviceAttributes->DeviceType = deviceObject->DeviceType;
            deviceAttributes->Characteristics = deviceObject->Characteristics;
            if (deviceMounted) {
                deviceAttributes->Characteristics |= FILE_DEVICE_IS_MOUNTED;
            }

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_FS_DEVICE_INFORMATION );
            status = STATUS_SUCCESS;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            // An error occurred attempting to write into one of the caller's
            // buffers.  Simply indicate that the error occurred, and fall
            // through.
            //

            status = GetExceptionCode();
        }

        //
        // If this operation was performed as synchronous I/O, then release
        // the file object lock.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }

        //
        // Now simply cleanup and return the final status of the operation.
        //

        ObDereferenceObject( fileObject );
        return status;

    }

    if (FsInformationClass == FileFsDriverPathInformation) {

        PFILE_FS_DRIVER_PATH_INFORMATION systemBuffer = NULL;
        PFILE_FS_DRIVER_PATH_INFORMATION userBuffer = FsInformation;

        try {


            systemBuffer = ExAllocatePoolWithQuota( NonPagedPool, Length );

            RtlCopyMemory( systemBuffer,
                           userBuffer,
                           Length );

            status = IopGetDriverPathInformation(fileObject, systemBuffer, Length);

            if (!NT_SUCCESS(status)) {
                ExRaiseStatus(status);
            }

            userBuffer->DriverInPath = systemBuffer->DriverInPath; 

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_FS_DRIVER_PATH_INFORMATION );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while allocating the intermediary
            // system buffer or while copying the caller's data into the
            // buffer. Cleanup and return an appropriate error status code.
            //

            status = GetExceptionCode();

        }

        if (systemBuffer) {
            ExFreePool(systemBuffer);
        }

        //
        // If this operation was performed as synchronous I/O, then release
        // the file object lock.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }

        ObDereferenceObject( fileObject);
        return status;
    }

    //
    // This is either a query that is not for device characteristics
    // information, or it is a query for device information, but it is
    // a query for a redirected device.  Take the long route and actually
    // invoke the driver for the target device to get the information.
    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get a pointer to the device object for the target device.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // If this I/O operation is not being performed as synchronous I/O,
    // then allocate an event that will be used to synchronize the
    // completion of this operation.  That is, this system service is
    // a synchronous API being invoked for a file that is opened for
    // asynchronous I/O.
    //

    if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an
        // appropriate error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer which should be used to put the information into
    // by the driver.  This will be copied back to the caller's buffer when
    // the service completes.  This is done by setting the flag which says
    // that this is an input operation.
    //

    irp->UserBuffer = FsInformation;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    //
    // Allocate the system buffer using an exception handler in case the
    // caller doesn't have enough quota remaining.
    //

    try {

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to allocate the inter-
        // mediary buffer.  Cleanup and return with an appropriate error
        // status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();

    }

    irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                           IRP_DEALLOCATE_BUFFER |
                           IRP_INPUT_OPERATION |
                           IRP_DEFER_IO_COMPLETION);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryVolume.Length = Length;
    irpSp->Parameters.QueryVolume.FsInformationClass = FsInformationClass;

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetVolumeInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID FsInformation,
    __in ULONG Length,
    __in FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service changes information about the volume "mounted" on the device
    specified by the FileHandle parameter.  The information to be changed is
    in the FsInformation buffer.  Its contents are defined by the FsInformation-
    Class parameter, whose values may be as follows:

        o  FileFsLabelInformation

Arguments:

    FileHandle - Supplies a handle to the volume whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer containing the information which should
        be changed on the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        changed about the volume.

Return Value:

    The status returned is the final completion status of the operation.
    block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    PFILE_FS_LABEL_INFORMATION labelInformation;
    BOOLEAN synchronousIo;
    PDEVICE_OBJECT targetDeviceObject;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FsInformationClass parameter is legal for setting
        // information about the volume.
        //

        if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
            IopSetFsOperationLength[FsInformationClass] == 0) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Finally, ensure that the supplied buffer is large enough to contain
        // the information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopSetFsOperationLength[FsInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FsInformation buffer must be readable by the caller.
            //

#if defined(_X86_)
            ProbeForRead( FsInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)
            // If we are a wow64 process, follow the X86 rules
            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForRead( FsInformation, Length, sizeof( ULONG ) );
            }
            else {
                ProbeForRead( FsInformation,
                              Length,
                              IopQuerySetFsAlignmentRequirement[FsInformationClass] );

            }
#else
            ProbeForRead( FsInformation,
                          Length,
                          IopQuerySetFsAlignmentRequirement[FsInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();

        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopSetFsOperationAccess[FsInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Retrieve the device object associated with this file handle.
    //
    
    status = IoGetRelatedTargetDevice( fileObject, &targetDeviceObject );

    if (NT_SUCCESS( status )) {
        //
        // The PDO associated with the devnode we got back from
        // IoGetRelatedTargetDevice has already been referenced by that
        // routine.  Store this reference away in the notification entry,
        // so we can deref it later when the notification entry is unregistered.
        //
    
        ASSERT(targetDeviceObject);
    
    } else {
        targetDeviceObject = NULL;
    }


    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  if this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                if (targetDeviceObject != NULL) {
                    ObDereferenceObject( targetDeviceObject );
                }
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            if (targetDeviceObject != NULL) {
                ObDereferenceObject( targetDeviceObject );
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (targetDeviceObject != NULL) {
            ObDereferenceObject( targetDeviceObject );
        }
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer and copy the information that is to be set on the
    // file into it.  Also, set the flags so that the completion code will
    // properly handle getting rid of the buffer and will not attempt to
    // copy data.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
        RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, FsInformation, Length );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred attempting to allocate the intermediary
        // buffer or while copying the caller's data to the buffer. Determine
        // what happened, cleanup, and return an appropriate error status
        // code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        if (targetDeviceObject != NULL) {
            ObDereferenceObject( targetDeviceObject );
        }
        
        return GetExceptionCode();

    }

    //
    // If the previous mode was not kernel, check the captured label buffer
    // for consistency.
    //

    if (requestorMode != KernelMode &&
        FsInformationClass == FileFsLabelInformation) {

        //
        // The previous mode was something other than kernel.  Check to see
        // whether or not the length of the label specified within the label
        // structure is consistent with the overall length of the structure
        // itself.  If not, then cleanup and get out.
        //

        labelInformation = (PFILE_FS_LABEL_INFORMATION) irp->AssociatedIrp.SystemBuffer;

        if ((LONG) labelInformation->VolumeLabelLength < 0 ||
            labelInformation->VolumeLabelLength +
            FIELD_OFFSET( FILE_FS_LABEL_INFORMATION, VolumeLabel ) > Length) {

            IopExceptionCleanup( fileObject,
                                 irp,
                                 (PKEVENT) NULL,
                                 event );

            if (targetDeviceObject != NULL) {
                ObDereferenceObject( targetDeviceObject );
            }
            
            return STATUS_INVALID_PARAMETER;
        }
    }

    irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetVolume.Length = Length;
    irpSp->Parameters.SetVolume.FsInformationClass = FsInformationClass;


    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    //
    //  Notify anyone who cares about the label change
    //

    if (targetDeviceObject != NULL) {
        if (NT_SUCCESS( status )) {
            TARGET_DEVICE_CUSTOM_NOTIFICATION ChangeEvent;
    
            ChangeEvent.Version = 1;
            ChangeEvent.FileObject = NULL;
            ChangeEvent.NameBufferOffset = -1;
            ChangeEvent.Size = (USHORT)FIELD_OFFSET( TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer );
            
            RtlCopyMemory( &ChangeEvent.Event, &GUID_IO_VOLUME_CHANGE, sizeof( GUID_IO_VOLUME_CHANGE ));
            
            IoReportTargetDeviceChange( targetDeviceObject, &ChangeEvent );
        }

        ObDereferenceObject( targetDeviceObject );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\qsea.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    qsea.c

Abstract:

    This module contains the code to implement the NtQueryEaFile and the
    NtSetEaFile system services for the NT I/O system.

--*/

#include "iomgr.h"

#pragma alloc_text(PAGE, NtQueryEaFile)
#pragma alloc_text(PAGE, NtSetEaFile)

NTSTATUS
NtQueryEaFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in BOOLEAN ReturnSingleEntry,
    __in_bcount_opt(EaListLength) PVOID EaList,
    __in ULONG EaListLength,
    __in_opt PULONG EaIndex,
    __in BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service returns the Extended Attributes (EAs) associated with the
    file specified by the FileHandle parameter.  The amount of information
    returned is based on the size of the EAs, and the size of the buffer.
    That is, either all of the EAs are written to the buffer, or the buffer
    is filled with complete EAs if the buffer is not large enough to contain
    all of the EAs.  Only complete EAs are ever written to the buffer; no
    partial EAs will ever be returned.

Arguments:

    FileHandle - Supplies a handle to the file for which the EAs are returned.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer to receive the EAs for the file.

    Length - Supplies the length, in bytes, of the buffer.

    ReturnSingleEntry - Indicates that only a single entry should be returned
        rather than filling the buffer with as many EAs as possible.

    EaList - Optionally supplies a list of EA names whose values are returned.

    EaListLength - Supplies the length of the EA list, if an EA list was
        specified.

    EaIndex - Supplies the optional index of an EA whose value is to be
        returned.  If specified, then only that EA is returned.

    RestartScan - Indicates whether the scan of the EAs should be restarted
        from the beginning.

Return Value:

    The status returned is the final completion status of the operation.

--*/

#define GET_OFFSET_LENGTH( CurrentEa, EaBase ) (    \
    (ULONG) ((PCHAR) CurrentEa - (PCHAR) EaBase) )


{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    PCHAR auxiliaryBuffer = (PCHAR) NULL;
    BOOLEAN eaListPresent = FALSE;
    ULONG eaIndexValue = 0L;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The buffer must be writeable by the caller.
            //

            ProbeForWrite( Buffer, Length, sizeof( ULONG ) );

            //
            // If the optional EaIndex parameter was specified, then it must be
            // readable by the caller.  Capture its value.
            //

            if (ARGUMENT_PRESENT( EaIndex )) {
                eaIndexValue = ProbeAndReadUlong( EaIndex );
            }

            //
            // If the optional EaList parameter was specified, then it must be
            // readable by the caller.  Validate that the buffer contains a
            // legal get information structure.
            //

            if (ARGUMENT_PRESENT( EaList ) && EaListLength != 0) {

                PFILE_GET_EA_INFORMATION eas;
                LONG tempLength;
                ULONG entrySize;

                eaListPresent = TRUE;

                ProbeForRead( EaList, EaListLength, sizeof( ULONG ) );
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           EaListLength );
                RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );

                eas = (PFILE_GET_EA_INFORMATION) auxiliaryBuffer;
                tempLength = EaListLength;

                //
                // Walk the request buffer and ensure that its format is
                // valid.  That is, ensure that it does not walk off the
                // end of the buffer that has been captured.
                //

                for (;;) {

                    //
                    // Get the size of the current entry in the buffer.
                    //

                    if (tempLength < FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0])) {
                        tempLength = 0;
                        ExFreePool( auxiliaryBuffer );
                        auxiliaryBuffer = (PVOID) NULL;
                        IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                        IoStatusBlock->Information = tempLength;
                        return STATUS_EA_LIST_INCONSISTENT;
                        }

                    entrySize = FIELD_OFFSET( FILE_GET_EA_INFORMATION, EaName[0] ) + eas->EaNameLength + 1;

                    if ((ULONG) tempLength < entrySize) {
                        tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                        ExFreePool( auxiliaryBuffer );
                        auxiliaryBuffer = (PVOID) NULL;
                        IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                        IoStatusBlock->Information = tempLength;
                        return STATUS_EA_LIST_INCONSISTENT;
                        }

                    if (eas->NextEntryOffset != 0) {

                        //
                        // There is another entry in the buffer and it must
                        // be longword aligned.  Ensure that the offset
                        // indicates that it is.  If it isn't, return an
                        // invalid parameter status.
                        //

                        if ((((entrySize + 3) & ~3) != eas->NextEntryOffset) ||
                            ((LONG) eas->NextEntryOffset < 0)) {
                            tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                            ExFreePool( auxiliaryBuffer );
                            auxiliaryBuffer = (PVOID) NULL;
                            IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                            IoStatusBlock->Information = tempLength;
                            return STATUS_EA_LIST_INCONSISTENT;

                        } else {

                            //
                            // There is another entry in the buffer, so
                            // account for the size of the current entry
                            // in the length and get a pointer to the next
                            // entry.
                            //

                            tempLength -= eas->NextEntryOffset;
                            if (tempLength < 0) {
                                tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                                ExFreePool( auxiliaryBuffer );
                                auxiliaryBuffer = (PVOID) NULL;
                                IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                                IoStatusBlock->Information = tempLength;
                                return STATUS_EA_LIST_INCONSISTENT;
                            }
                            eas = (PFILE_GET_EA_INFORMATION) ((PCHAR) eas + eas->NextEntryOffset);
                        }

                    } else {

                        //
                        // There are no other entries in the buffer.  Simply
                        // account for the overall buffer length according
                        // to the size of the current entry and exit the
                        // loop.
                        //

                        tempLength -= entrySize;
                        break;
                    }
                }

                //
                // All of the entries in the buffer have been processed.
                // Check to see whether the overall buffer length went
                // negative.  If so, return an error.
                //

                if (tempLength < 0) {
                    tempLength = GET_OFFSET_LENGTH( eas, auxiliaryBuffer );
                    ExFreePool( auxiliaryBuffer );
                    auxiliaryBuffer = (PVOID) NULL;
                    IoStatusBlock->Status = STATUS_EA_LIST_INCONSISTENT;
                    IoStatusBlock->Information = tempLength;
                    return STATUS_EA_LIST_INCONSISTENT;
                }

            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters, allocating the pool buffer, or copying the
            // caller's EA list to the buffer.  Cleanup and return an
            // appropriate error status code.
            //

            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was KernelMode.  Simply allocate pool for the
        // EaList, if one was specified, and copy the string to it.  Also,
        // if an EaIndex was specified copy it as well.
        //

        if (ARGUMENT_PRESENT( EaList ) && (EaListLength != 0)) {
            eaListPresent = TRUE;
            try {
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           EaListLength );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                return GetExceptionCode();
            }
            RtlCopyMemory( auxiliaryBuffer, EaList, EaListLength );
        }

        if (ARGUMENT_PRESENT( EaIndex )) {
            eaIndexValue = *EaIndex;
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_EA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        if (eaListPresent) {
            ExFreePool( auxiliaryBuffer );
        }
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eaListPresent) {
                    ExFreePool( auxiliaryBuffer );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            if (eaListPresent) {
                ExFreePool( auxiliaryBuffer );
            }
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (eaListPresent) {
            ExFreePool( auxiliaryBuffer );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_EA;
    irpSp->FileObject = fileObject;

    //
    // If the caller specified an EA list of names to be queried, then pass
    // the address of the intermediary buffer containing the list to the
    // driver.
    //

    if (eaListPresent) {
        irp->Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
        irpSp->Parameters.QueryEa.EaList = auxiliaryBuffer;
        irpSp->Parameters.QueryEa.EaListLength = EaListLength;
    }

    //
    // Now determine whether this driver expects to have data buffered
    // to it or whether it performs direct I/O.  This is based on the
    // DO_BUFFERED_IO flag in the device object.  If the flag is set,
    // then a system buffer is allocated and the driver's data will be
    // copied to it.  If the DO_DIRECT_IO flag is set in the device
    // object, then a Memory Descriptor List (MDL) is allocated and
    // the caller's buffer is locked down using it.  Finally, if the
    // driver specifies neither of the flags, then simply pass the
    // address and length of the buffer and allow the driver to perform
    // all of the checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The driver wishes the caller's buffered be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also indicate
        // that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception
        // handler that will perform cleanup if the operation fails.
        //

        if (Length) {
            try {

                //
                // Allocate the intermediary system buffer from nonpaged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                   ExAllocatePoolWithQuota( NonPagedPool, Length );
 
            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the system buffer.
                // Determine what actually happened, clean everything
                // up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer != NULL) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }

            //
            // Remember the address of the caller's buffer so the copy can
            // take place during I/O completion.  Also, set the flags so
            // that the completion code knows to do the copy and to deallocate
            // the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                                   IRP_DEALLOCATE_BUFFER |
                                   IRP_INPUT_OPERATION);
        } else {
            //
            // This is a zero-length request.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO | IRP_INPUT_OPERATION);

        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke
        // the memory management routine to lock the buffer into memory.
        // This is done using an exception handler that will perform
        // cleanup if the operation fails.
        //

        if (Length) {
            mdl = (PMDL) NULL;

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off
                // of the IRP.  Probe and lock the pages associated with
                // the caller's buffer for write access and fill in the MDL
                // with the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the MDL.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer != NULL) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access
        // to it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryEa.Length = Length;
    irpSp->Parameters.QueryEa.EaIndex = eaIndexValue;
    irpSp->Flags = 0;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }
    if (ReturnSingleEntry) {
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }
    if (ARGUMENT_PRESENT( EaIndex )) {
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetEaFile ( 
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length
    )

/*++

Routine Description:

    This service replaces the Extended Attributes (EAs) associated with the file
    specified by the FileHandle parameter.  All of the EAs associated with the
    file are replaced by the EAs in the specified buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose EAs should be changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the new EAs which should be
        used to replace the EAs currently associated with the file.

    Length - Supplies the length, in bytes, of the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The Buffer parameter must be readable by the caller.
            //

            ProbeForRead( Buffer, Length, sizeof( ULONG ) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Cleanup and return an appropriate error status code.
            //

            return GetExceptionCode();
        }
    }


    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_WRITE_EA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_EA;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this driver expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  if the flag is set, then a system buffer is
    // allocated and driver's data is copied to it.  If the DO_DIRECT_IO flag
    // is set in the device object, then a Memory Descriptor List (MDL) is
    // allocated and the caller's buffer is locked down using it.  Finally, if
    // the driver specifies neither of the flags, then simply pass the address
    // and length of the buffer and allow the driver to perform all of the
    // checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        PFILE_FULL_EA_INFORMATION systemBuffer;
        ULONG errorOffset;

        //
        // The driver wishes the caller's buffer to be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also check to
        // ensure that the caller's EA list is valid.  All of this is
        // performed within an exception handler that will perform
        // cleanup if the operation fails.
        //

        if (Length) {
            try {

            //
            // Allocate the intermediary system buffer and charge the caller
            // quota for its allocation.  Copy the caller's EA buffer into the
            // buffer and check to ensure that it is valid.
            //

                systemBuffer = ExAllocatePoolWithQuota( NonPagedPool, Length );

                irp->AssociatedIrp.SystemBuffer = systemBuffer;

                RtlCopyMemory( systemBuffer, Buffer, Length );

                status = IoCheckEaBufferValidity( systemBuffer,
                                                  Length,
                                                  &errorOffset );

                if (!NT_SUCCESS( status )) {
                    IoStatusBlock->Status = status;
                    IoStatusBlock->Information = errorOffset;
                    ExRaiseStatus( status );
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while allocating the buffer, copying
                // the caller's data into it, or walking the EA buffer.  Determine
                // what happened, cleanup, and return an appropriate error status
                // code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }

            //
            // Set the flags so that the completion code knows to deallocate the
            // buffer.
            //
    
            irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        } else {
            irp->AssociatedIrp.SystemBuffer = NULL;
        }


    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This is
        // done using an exception handler that will perform cleanup if the
        // operation fails.
        //

        mdl = (PMDL) NULL;

        if (Length) {
            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of the
                // IRP.  Probe and lock the pages associated with the caller's
                // buffer for read access and fill in the MDL with the PFNs of those
                // pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the MDL.  Determine what actually happened,
                // clean everything up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetEa.Length = Length;


    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\parse.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    parse.c

Abstract:

    This module contains the code to implement the device object parse routine.

--*/

#include "iomgr.h"

//
// Define macro to round up the size of a name for buffer optimization.
//

#define RoundNameSize( Length ) ( \
    (Length < 64 - 8) ? 64 - 8 :  \
    (Length < 128 - 8) ? 128 - 8 :\
    (Length < 256 - 8) ? 256 - 8 : Length )

#define IO_MAX_REMOUNT_REPARSE_ATTEMPTS 32

NTSTATUS
IopGetNetworkOpenInformation(
    IN  PFILE_OBJECT    FileObject,
    IN  POPEN_PACKET    Op
    );

NTSTATUS
IopCheckTopDeviceHint(
    IN OUT PDEVICE_OBJECT *TargetDeviceObject,
    IN POPEN_PACKET Op,
    IN BOOLEAN DirectDeviceOpen
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IopParseFile)
#pragma alloc_text(PAGE, IopParseDevice)
#pragma alloc_text(PAGE, IopQueryName)
#pragma alloc_text(PAGE, IopQueryNameInternal)
#pragma alloc_text(PAGE, IopCheckBackupRestorePrivilege)
#pragma alloc_text(PAGE, IopGetNetworkOpenInformation)
#pragma alloc_text(PAGE, IopCheckTopDeviceHint)
#endif

NTSTATUS
IopCheckDeviceAndDriver(
    IN POPEN_PACKET op,
    IN PDEVICE_OBJECT parseDeviceObject
    )
{
    NTSTATUS status;
    KIRQL irql;

    //
    // Make sure that the device and its driver are really there and they are
    // going to stay there.  The object itself cannot go away just yet because
    // the object management system has performed a reference which bumps the
    // count of the number of reasons why the object must stick around.
    // However, the driver could be attempting to unload itself, so perform
    // this check.  If the driver is being unloaded, then set the final status
    // of the operation to "No such device" and return with a NULL file object
    // pointer.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoDatabaseLock );

    if (parseDeviceObject->DeviceObjectExtension->ExtensionFlags &
            (DOE_UNLOAD_PENDING | DOE_DELETE_PENDING | DOE_REMOVE_PENDING | DOE_REMOVE_PROCESSED | DOE_START_PENDING) ||
        parseDeviceObject->Flags & DO_DEVICE_INITIALIZING) {

        status = STATUS_NO_SUCH_DEVICE;

    } else if (parseDeviceObject->Flags & DO_EXCLUSIVE &&
               parseDeviceObject->ReferenceCount != 0 &&
               op->RelatedFileObject == NULL &&
               !(op->Options & IO_ATTACH_DEVICE)) {

        status = STATUS_ACCESS_DENIED;

    } else {

        parseDeviceObject->ReferenceCount++;
        status = STATUS_SUCCESS;

    }

    KeReleaseQueuedSpinLock( LockQueueIoDatabaseLock, irql );

    return status;
}

PVPB
IopCheckVpbMounted(
    IN POPEN_PACKET op,
    IN PDEVICE_OBJECT parseDeviceObject,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PNTSTATUS status
    )
{
    PVPB vpb;
    PVPB mountVpb;
    KIRQL irql;
    BOOLEAN alertable;

    //
    // Loop here until the VPB_MOUNTED test can be passed while holding the
    // VPB spinlock.  After the mount succeeds, it is still necessary to acquire
    // the spinlock to check that the VPB (which may be different from the one
    // before the mount) is still mounted.  If it is, then its reference count
    // is incremented before releasing the spinlock.
    //

    irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );

    while (!(parseDeviceObject->Vpb->Flags & VPB_MOUNTED)) {

        KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );

        alertable = (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) ? TRUE : FALSE;

        //
        // Try to mount the volume, allowing only RAW to perform the mount if
        // this is a DASD open.
        //

        mountVpb = NULL;
        *status = IopMountVolume( parseDeviceObject,
                                 (BOOLEAN) (!RemainingName->Length && !op->RelatedFileObject),
                                 FALSE,
                                 alertable,
                                 &mountVpb );
        //
        // If the mount operation was unsuccessful, adjust the reference
        // count for the device and return now.
        //

        if (!NT_SUCCESS( *status ) || *status == STATUS_USER_APC || *status == STATUS_ALERTED) {

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (!NT_SUCCESS( *status )) {
                return NULL;
            } else {
                *status = STATUS_WRONG_VOLUME;
                return NULL;
            }
        } else {

            //
            // In this case IopMountVolume did the synchronization already.
            //

            if (mountVpb) {
                return mountVpb;
            }
        }

        irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    }

    //
    // Synchronize here with the file system to make sure that volumes do not
    // go away while en route to the FS.
    //

    vpb = parseDeviceObject->Vpb;

    //
    //  Check here that the VPB is not locked.
    //

    if (vpb->Flags & VPB_LOCKED) {

        *status = STATUS_ACCESS_DENIED;
        vpb = NULL;

    } else {

        vpb->ReferenceCount += 1;
    }

    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );

    //
    // This is because VPB is locked.
    // Do the decrement outside the VPB lock because of possible deadlocks.
    //

    if (!vpb) {
        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );
    }

    return vpb;
}

VOID
IopDereferenceVpbAndFree(
    IN PVPB Vpb
    )
{
    KIRQL irql;
    PVPB vpb = (PVPB) NULL;

    irql = KeAcquireQueuedSpinLock( LockQueueIoVpbLock );
    Vpb->ReferenceCount--;
    if ((Vpb->ReferenceCount == 0) &&
        (Vpb->RealDevice->Vpb != Vpb) &&
        !(Vpb->Flags & VPB_PERSISTENT)) {
        vpb = Vpb;
    }
    KeReleaseQueuedSpinLock( LockQueueIoVpbLock, irql );
    if (vpb) {
        ExFreePool( vpb );
    }
}



NTSTATUS
IopCheckTopDeviceHint(
    IN OUT PDEVICE_OBJECT *TargetDeviceObject,
    IN POPEN_PACKET Op,
    IN BOOLEAN DirectDeviceOpen
)
/*++
 
Routine Description:

    Check a device object hint specified in an open packet for validity.
    
Arguments:

    TargetDeviceObject - Device object whose stack the hint must be on
    for it to be valid; holds the hint on return if it is valid.

    Op - Open packet that contains the device object hint.

    DirectDeviceOpen - Specifies whether the open is a direct device open.

Return Value:

    STATUS_INVALID_PARAMETER - The hint is invalid for this open.

    STATUS_MOUNT_POINT_NOT_RESOLVED - The target device object and the hint
    are on different stacks and a mount point was previously traversed.

    STATUS_INVALID_DEVICE_OBJECT_PARAMETER - The target device object and the
    hint are on different stacks.

    STATUS_SUCCESS otherwise.

--*/
{
    PDEVICE_OBJECT deviceObject = *TargetDeviceObject;

    //
    // You cannot use the device object hint if you are trying to
    // open the device directly or if you are dealing with a device
    // that is not a file system.  In these cases, return an error.
    //

    if (DirectDeviceOpen ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS_FILE_SYSTEM)) {

        return STATUS_INVALID_PARAMETER;
    }

    if  (IopVerifyDeviceObjectOnStack(deviceObject, Op->TopDeviceObjectHint)) {

        *TargetDeviceObject = Op->TopDeviceObjectHint;

    } else {
        
        if (Op->TraversedMountPoint) {
            Op->TraversedMountPoint = FALSE;
            return STATUS_MOUNT_POINT_NOT_RESOLVED;
        } else {
            return STATUS_INVALID_DEVICE_OBJECT_PARAMETER;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IopParseDevice(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and the
    name translates to a device object.  This routine is specified as the parse
    routine for all device objects.

    In the normal case of an NtCreateFile, the user specifies either the name
    of a device or of a file.  In the former situation, this routine is invoked
    with a pointer to the device and a null ("") string.  For this case, the
    routine simply allocates an IRP, fills it in, and passes it to the driver
    for the device.  The driver will then perform whatever rudimentary functions
    are necessary and will return a status code indicating whether an error was
    incurred.  This status code is remembered in the Open Packet (OP).

    In the latter situation, the name string to be opened/created is non-null.
    That is, it contains the remainder of the pathname to the file that is to
    be opened or created.  For this case, the routine allocates an IRP, fills
    it in, and passes it to the driver for the device.  The driver may then
    need to take further action or it may complete the request immediately.  If
    it needs to perform some work asynchronously, then it can queue the request
    and return a status of STATUS_PENDING.  This allows this routine and its
    caller to return to the user so that he can continue.  Otherwise, the open/
    create is basically finished.

    If the driver supports symbolic links, then it is also possible for the
    driver to return a new name.  This name will be returned to the Object
    Manager as a new name to look up.  The parsing will then begin again from
    the start.

    It is also the responsibility of this routine to create a file object for
    the file, if the name specifies a file.  The file object's address is
    returned to the NtCreateFile service through the OP.

Arguments:

    ParseObject - Pointer to the device object the name translated into.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    SecurityQos - Optional security quality of service indicator.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{


    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    POPEN_PACKET op;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    IO_SECURITY_CONTEXT securityContext;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT parseDeviceObject;
    BOOLEAN checkDeviceHint = FALSE;
    BOOLEAN directDeviceOpen;
    PVPB vpb;
    ACCESS_MASK desiredAccess;
    PDUMMY_FILE_OBJECT localFileObject;
    LOGICAL realFileObjectRequired;
    KPROCESSOR_MODE modeForPrivilegeCheck;
    ULONG retryCount = 0;
    BOOLEAN  relativeVolumeOpen = FALSE;     // True if opening a filesystem volume
    PETHREAD CurrentThread;
    ULONG returnedLength;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (ObjectType);

    CurrentThread = PsGetCurrentThread ();

reparse_loop:

    //
    // Assume failure by setting the returned object pointer to NULL.
    //

    *Object = (PVOID) NULL;

    //
    // Get the address of the Open Packet (OP).
    //

    op = Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Obtain a pointer to the parse object as a device object, which is the
    // actual type of the object anyway.
    //

    parseDeviceObject = (PDEVICE_OBJECT) ParseObject;

    //
    // If we passed through a mountpoint do an extra set of validation checks
    // that we don't go to a remote device. We really have to let the object manager
    // open the new path. If we fail it in the path that obtains the reparse point and
    // validates the name (using IoIsValidNameGraftingBuffer) its not sufficient. This is because
    // the path may be valid at that time and change before OB does the reparse.
    //

    if (op->TraversedMountPoint) {

        ASSERT (op->Information == IO_REPARSE_TAG_MOUNT_POINT);

        if ((parseDeviceObject->DeviceType != FILE_DEVICE_DISK) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_CD_ROM) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_VIRTUAL_DISK) &&
            (parseDeviceObject->DeviceType != FILE_DEVICE_TAPE)) {

            status = STATUS_IO_REPARSE_DATA_INVALID;
            return op->FinalStatus = status;
        }
    }

    //
    // If this is a relative open, then get the device on which the file
    // is really being opened from the related file object and use that for
    // the remainder of this function and for all operations performed on
    // the file object that is about to be created.
    //

    if (op->RelatedFileObject) {
        parseDeviceObject = op->RelatedFileObject->DeviceObject;
    }

    //
    // Make sure that the device and its driver are really there and they are
    // going to stay there.  The object itself cannot go away just yet because
    // the object management system has performed a reference which bumps the
    // count of the number of reasons why the object must stick around.
    // However, the driver could be attempting to unload itself, so perform
    // this check.  If the driver is being unloaded, then set the final status
    // of the operation to "No such device" and return with a NULL file object
    // pointer.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    status = IopCheckDeviceAndDriver( op, parseDeviceObject );

    if (!NT_SUCCESS(status)) {
        return op->FinalStatus = status;
    }

    //
    // Since ObOpenObjectByName is called without being passed
    // any object type information, we need to map the generic
    // bits in the DesiredAccess mask here.  We also need to save
    // the object's generic mapping in the access state structure
    // here, because this is the earliest opportunity we have
    // to do so.
    //

    RtlMapGenericMask( &AccessState->RemainingDesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    RtlMapGenericMask( &AccessState->OriginalDesiredAccess,
                       &IoFileObjectType->TypeInfo.GenericMapping );

    SeSetAccessStateGenericMapping( AccessState, &IoFileObjectType->TypeInfo.GenericMapping );

    desiredAccess = AccessState->RemainingDesiredAccess;

    //
    // Compute the previous mode to be passed in to the privilege check
    //

    if (AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) {
        modeForPrivilegeCheck = UserMode;
    } else {
        modeForPrivilegeCheck = KernelMode;
    }

    IopCheckBackupRestorePrivilege( AccessState,
                                    &op->CreateOptions,
                                    modeForPrivilegeCheck,
                                    op->Disposition
                                    );

    //
    // If this is not the first time through here for this object, and the
    // object itself is being opened, then the desired access must also
    // include the previously granted access from the last pass.  Likewise,
    // if the privileges have been checked already, then this is another
    // pass through for a file, so add in the previously granted access.
    //

    if ((op->Override && !RemainingName->Length) ||
        AccessState->Flags & SE_BACKUP_PRIVILEGES_CHECKED) {
        desiredAccess |= AccessState->PreviouslyGrantedAccess;
    }

    //
    // If its a filesystem volume open and we are doing a relative open to it
    // then do the access check. Note that relative opens can be nested and we propagate
    // the fact that the relative open is for a volume using the FO_VOLUME_OPEN flag.
    //

    if (op->RelatedFileObject) {
        if ((op->RelatedFileObject->Flags & FO_VOLUME_OPEN) && RemainingName->Length == 0) {
            relativeVolumeOpen = TRUE;
        }
    }

    //
    // Now determine what type of security check should be made.  This is
    // based on whether the remaining name string is null.  If it is null,
    // then the device itself is being opened, so a full security check is
    // performed.  Otherwise, only a check to ensure that the caller can
    // traverse the device object is made.  Note that these checks are only
    // made if the caller's mode is user, or if access checking is being
    // forced.  Note also that if an access check was already made on the
    // device itself, and this code is being executed again because of a
    // reparse, then the access check need not be made the second time
    // around.
    //


    if ((AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) &&
        (!op->RelatedFileObject || relativeVolumeOpen) &&
        !op->Override) {

        BOOLEAN subjectContextLocked = FALSE;
        BOOLEAN accessGranted;
        ACCESS_MASK grantedAccess;

        //
        // The caller's mode is either user or access checking is being
        // forced.  Perform the appropriate access check on the device
        // object.
        //

        if (!RemainingName->Length) {

            UNICODE_STRING nameString;
            PPRIVILEGE_SET privileges = NULL;

            //
            // The device itself is being opened.  Make a full security check
            // to ensure that the caller has the appropriate access.
            //

            KeEnterCriticalRegionThread( &CurrentThread->Tcb );
            ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

            SeLockSubjectContext( &AccessState->SubjectSecurityContext );
            subjectContextLocked = TRUE;

            accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                           &AccessState->SubjectSecurityContext,
                                           subjectContextLocked,
                                           desiredAccess,
                                           0,
                                           &privileges,
                                           &IoFileObjectType->TypeInfo.GenericMapping,
                                           UserMode,
                                           &grantedAccess,
                                           &status );

            if (privileges) {
                (VOID) SeAppendPrivileges( AccessState,
                                           privileges );
                SeFreePrivileges( privileges );
            }

            if (accessGranted) {
                AccessState->PreviouslyGrantedAccess |= grantedAccess;
                AccessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
                op->Override = TRUE;
            }

            nameString.Length = 8;
            nameString.MaximumLength = 8;
            nameString.Buffer = L"File";

            SeOpenObjectAuditAlarm( &nameString,
                                    parseDeviceObject,
                                    CompleteName,
                                    parseDeviceObject->SecurityDescriptor,
                                    AccessState,
                                    FALSE,
                                    accessGranted,
                                    UserMode,
                                    &AccessState->GenerateOnClose );

            ExReleaseResourceLite( &IopSecurityResource );
            KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

        } else {

            //
            // The device is not being opened, rather, a file on the device
            // is being opened or created.  Therefore, only perform a check
            // here for traverse access to the device.
            //

            //
            // First determine if we have to perform traverse checking at all.
            // Traverse checking only needs to be done if the device being
            // traversed is a disk, or if the caller does not already have
            // traverse checking privilege.  Note that the former case is so
            // that an administrator can turn off access to the "system
            // partition", or someone would be able to install a trojan horse
            // into the system by simply replacing one of the files there with
            // something of their own.
            //

            if (!(AccessState->Flags & TOKEN_HAS_TRAVERSE_PRIVILEGE) ||
                parseDeviceObject->DeviceType == FILE_DEVICE_DISK ||
                parseDeviceObject->DeviceType == FILE_DEVICE_CD_ROM ) {

                KeEnterCriticalRegionThread( &CurrentThread->Tcb );
                ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

                accessGranted = SeFastTraverseCheck( parseDeviceObject->SecurityDescriptor,
                                                     AccessState,
                                                     FILE_TRAVERSE,
                                                     UserMode );

                if (!accessGranted) {

                    PPRIVILEGE_SET privileges = NULL;

                    //
                    // The caller was not granted traverse access through the
                    // normal fast path lookup.  Perform a full-blown access
                    // check to determine whether some other ACE allows traverse
                    // access.
                    //

                    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

                    subjectContextLocked = TRUE;

                    accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                                   &AccessState->SubjectSecurityContext,
                                                   subjectContextLocked,
                                                   FILE_TRAVERSE,
                                                   0,
                                                   &privileges,
                                                   &IoFileObjectType->TypeInfo.GenericMapping,
                                                   UserMode,
                                                   &grantedAccess,
                                                   &status );

                    if (privileges) {

                        (VOID) SeAppendPrivileges( AccessState,
                                                   privileges );
                        SeFreePrivileges( privileges );
                    }

                }

                ExReleaseResourceLite( &IopSecurityResource );
                KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

            } else {

                accessGranted = TRUE;
            }
        }

        //
        // Unlock the subject's security context so that it can be changed,
        // if it was locked.
        //

        if (subjectContextLocked) {
            SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
        }

        //
        // Finally, determine whether or not access was granted to the device.
        // If not, clean everything up and get out now without even invoking
        // the device driver.
        //

        if (!accessGranted) {

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );
            return STATUS_ACCESS_DENIED;
        }

    }

    realFileObjectRequired = !(op->QueryOnly || op->DeleteOnly);

    if (RemainingName->Length == 0 &&
        op->RelatedFileObject == NULL &&
        ((desiredAccess & ~(SYNCHRONIZE |
                            FILE_READ_ATTRIBUTES |
                            READ_CONTROL |
                            ACCESS_SYSTEM_SECURITY |
                            WRITE_OWNER |
                            WRITE_DAC)) == 0) &&
        realFileObjectRequired) {

        //
        // If the name of the object being opened is just the name of the
        // device itself, and there is no related file object, and the caller
        // is opening the device for only read attributes access, then this
        // device will not be mounted.  This allows applications to obtain
        // attributes about the device without actually mounting it.
        //
        // Note that if this *is* a direct device open, then the normal path
        // through the I/O system and drivers may never be used, even if
        // the device appears to be mounted.  This is because the user may
        // remove the media from the drive (even though it is mounted), and
        // now attempting to determine what type of drive it is will still
        // fail, this time very hard, because a whole mount process is now
        // required, thus defeating this feature.
        //

        directDeviceOpen = TRUE;

    } else {

        //
        // Otherwise, this is a normal open of a file, directory, device, or
        // volume.
        //

        directDeviceOpen = FALSE;
    }

    //
    // There are now five different cases.  These are as follows:
    //
    //    1)  This is a relative open, in which case we want to send the
    //        request to then same device that opened the relative file object.
    //
    //    2)  The VPB pointer in the device object is NULL.  This means that
    //        this device does not support a file system.  This includes
    //        devices such as terminals, etc.
    //
    //    3)  The VPB pointer in the device object is not NULL and:
    //
    //        a)  The VPB is "blank".  That is, the VPB has never been filled
    //            in, which means that the device has never been mounted.
    //
    //        b)  The VPB is non-blank, but the verify flag on the device is
    //            set, indicating that the door to the drive may have been
    //            opened and the media may therefore have been changed.
    //
    //        c)  The VPB is non-blank and the verify flag is not set.
    //
    //        Both of the latter are not explicitly checked for, as #c is
    //        the normal case, and #b is the responsibility of the file
    //        system to check.
    //

    //
    //  If this is a file system that supports volumes, vpbRefCount will
    //  be filled in to point to the reference count in the Vpb.  Error
    //  exits paths later on key off this value to see if they should
    //  decrement the ref count.  Note that a direct device open does not
    //  make it to the file system, so no increment is needed, and no
    //  decrement will be performed in objsup.c IopDeleteFile().
    //

    vpb = NULL;

    //
    // If the related open was a direct device open then we should go through the full mount
    // path for this open as this may not be a direct device open.
    //
    if (op->RelatedFileObject && (!(op->RelatedFileObject->Flags & FO_DIRECT_DEVICE_OPEN))) {

        deviceObject = (PDEVICE_OBJECT)ParseObject;

        if (op->RelatedFileObject->Vpb) {

            vpb = op->RelatedFileObject->Vpb;

            //
            // Synchronize here with the file system to make sure that
            // volumes don't go away while en route to the FS.
            //

            IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                          (PLONG) &vpb->ReferenceCount);
        }
        
        if (op->InternalFlags & IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT) {

            if (vpb) {
                deviceObject = vpb->DeviceObject;
            }

            checkDeviceHint = TRUE;
        }

    } else {

        deviceObject = parseDeviceObject;

        if (parseDeviceObject->Vpb && !directDeviceOpen) {
            vpb = IopCheckVpbMounted( op,
                                      parseDeviceObject,
                                      RemainingName,
                                      &status );
            //
            // Device object reference is decremented in IopCheckVpbMounted.
            //

            if ( !vpb ) {
                return status;
            }

            //
            // Set the address of the device object associated with the VPB.
            //

            deviceObject = vpb->DeviceObject;
        }


        //
        // If the top deviceobject hint is set use the hint if possible.
        //

        if (op->InternalFlags & IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT) {

            checkDeviceHint = TRUE;

        } else {

            //
            // Walk the attached device list.
            //

            if (deviceObject->AttachedDevice) {
                deviceObject = IoGetAttachedDevice( deviceObject );
            }
        }
    }

    if (checkDeviceHint) {

        status = IopCheckTopDeviceHint( &deviceObject,
                                        op,
                                        directDeviceOpen );

        if (!NT_SUCCESS(status)) {

            if (vpb) {
                IopDereferenceVpbAndFree( vpb );
            }

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            return status;
        }

    }

    //
    //  If the TraversedMountPoint flag is still set, clear it now.  We needed
    //  to keep it to return the correct status if IopVerifyDeviceObjectOnStack
    //  failed above.
    //

    if (op->TraversedMountPoint) {
        op->TraversedMountPoint = FALSE;
    }

    //
    //  If the driver says that the IO manager should do the access checks, lets do it here.
    //  We do the check against the parse device object as that device object has a name
    //  and we can set an ACL against it.
    //  We only worry about related opens of devices as the other case is taken care of in the
    //  filesystem.
    //
    if ((deviceObject->Characteristics & FILE_DEVICE_SECURE_OPEN) &&
        (AccessMode != KernelMode || op->Options & IO_FORCE_ACCESS_CHECK) &&
        (op->RelatedFileObject || RemainingName->Length) &&  (!relativeVolumeOpen)) {

        BOOLEAN subjectContextLocked = FALSE;
        BOOLEAN accessGranted;
        ACCESS_MASK grantedAccess;
        UNICODE_STRING nameString;
        PPRIVILEGE_SET privileges = NULL;

        //
        // If the device wants to ensure secure opens then lets check the two
        // cases which were skipped earlier. These cases are if its a relative
        // open or if there are trailing names.
        //

        KeEnterCriticalRegionThread( &CurrentThread->Tcb );
        ExAcquireResourceSharedLite( &IopSecurityResource, TRUE );

        SeLockSubjectContext( &AccessState->SubjectSecurityContext );
        subjectContextLocked = TRUE;

        accessGranted = SeAccessCheck( parseDeviceObject->SecurityDescriptor,
                                       &AccessState->SubjectSecurityContext,
                                       subjectContextLocked,
                                       desiredAccess,
                                       0,
                                       &privileges,
                                       &IoFileObjectType->TypeInfo.GenericMapping,
                                       UserMode,
                                       &grantedAccess,
                                       &status );

        if (privileges) {
            (VOID) SeAppendPrivileges( AccessState,
                                       privileges );
            SeFreePrivileges( privileges );
        }

        if (accessGranted) {
            AccessState->PreviouslyGrantedAccess |= grantedAccess;
            AccessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        }

        nameString.Length = 8;
        nameString.MaximumLength = 8;
        nameString.Buffer = L"File";

        SeOpenObjectAuditAlarm( &nameString,
                                deviceObject,
                                CompleteName,
                                parseDeviceObject->SecurityDescriptor,
                                AccessState,
                                FALSE,
                                accessGranted,
                                UserMode,
                                &AccessState->GenerateOnClose );

        SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
        ExReleaseResourceLite( &IopSecurityResource );
        KeLeaveCriticalRegionThread( &CurrentThread->Tcb );

        if (!accessGranted) {
            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
                IopDereferenceVpbAndFree(vpb);
            }
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Allocate and fill in the I/O Request Packet (IRP) to use in interfacing
    // to the driver.  The allocation is done using an exception handler in
    // case the caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if (vpb) {
            IopDereferenceVpbAndFree(vpb);
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = AccessMode;
    irp->Flags = IRP_CREATE_OPERATION | IRP_SYNCHRONOUS_API | IRP_DEFER_IO_COMPLETION;

    securityContext.SecurityQos = SecurityQos;
    securityContext.AccessState = AccessState;
    securityContext.DesiredAccess = desiredAccess;
    securityContext.FullCreateOptions = op->CreateOptions;

    //
    // Get a pointer to the stack location for the first driver.  This is where
    // the original function codes and parameters are passed.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Control = 0;

    if (op->CreateFileType == CreateFileTypeNone) {

        //
        // This is a normal file open or create function.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE;
        irpSp->Parameters.Create.EaLength = op->EaLength;
        irpSp->Flags = (UCHAR) op->Options;
        if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
            irpSp->Flags |= SL_CASE_SENSITIVE;
        }

    } else if (op->CreateFileType == CreateFileTypeNamedPipe) {

        //
        // A named pipe is being created.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE_NAMED_PIPE;
        irpSp->Parameters.CreatePipe.Parameters = op->ExtraCreateParameters;

    } else {

        //
        // A mailslot is being created.
        //

        irpSp->MajorFunction = IRP_MJ_CREATE_MAILSLOT;
        irpSp->Parameters.CreateMailslot.Parameters = op->ExtraCreateParameters;
    }

    //
    // Also fill in the NtCreateFile service's caller's parameters.
    //

    irp->Overlay.AllocationSize = op->AllocationSize;
    irp->AssociatedIrp.SystemBuffer = op->EaBuffer;
    irpSp->Parameters.Create.Options = (op->Disposition << 24) | (op->CreateOptions & 0x00ffffff);
    irpSp->Parameters.Create.FileAttributes = op->FileAttributes;
    irpSp->Parameters.Create.ShareAccess = op->ShareAccess;
    irpSp->Parameters.Create.SecurityContext = &securityContext;

    //
    // Fill in local parameters so this routine can determine when the I/O is
    // finished, and the normal I/O completion code will not get any errors.
    //

    irp->UserIosb = &ioStatus;
    irp->MdlAddress = (PMDL) NULL;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->UserEvent = (PKEVENT) NULL;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;

    //
    // Allocate and initialize the file object that will be used in dealing
    // with the device for the remainder of this session with the user.  How
    // the file object is allocated is based on whether or not a real file
    // object is actually required.  It is not required for the query and
    // delete only operations.
    //

    if (realFileObjectRequired) {

        OBJECT_ATTRIBUTES objectAttributes;
        ULONG             fileObjectSize;

        //
        // A real, full-blown file object is actually required.
        //

        InitializeObjectAttributes( &objectAttributes,
                                    (PUNICODE_STRING) NULL,
                                    Attributes,
                                    (HANDLE) NULL,
                                    (PSECURITY_DESCRIPTOR) NULL
                                  );

        if (op->InternalFlags &
            (IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT|
             IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK|
             IOP_CREATE_DEVICE_OBJECT_EXTENSION)) {
            fileObjectSize = sizeof(FILE_OBJECT) + sizeof(IOP_FILE_OBJECT_EXTENSION);
        } else {
            fileObjectSize = sizeof(FILE_OBJECT);
        }

        status = ObCreateObject( KernelMode,
                                 IoFileObjectType,
                                 &objectAttributes,
                                 AccessMode,
                                 (PVOID) NULL,
                                 fileObjectSize,
                                 0,
                                 0,
                                 (PVOID *) &fileObject );

        if (!NT_SUCCESS( status )) {
            IoFreeIrp( irp );

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
               IopDereferenceVpbAndFree(vpb);
            }
            return op->FinalStatus = status;
        }

        IopPerfLogFileCreate(fileObject, CompleteName);

        RtlZeroMemory( fileObject, sizeof( FILE_OBJECT ) );
        if (op->CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) {
            fileObject->Flags = FO_SYNCHRONOUS_IO;
            if (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) {
                fileObject->Flags |= FO_ALERTABLE_IO;
            }
        }

        if (op->InternalFlags &
            (IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT|
             IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK|
             IOP_CREATE_DEVICE_OBJECT_EXTENSION)) {

            PIOP_FILE_OBJECT_EXTENSION  fileObjectExtension;

            fileObject->Flags |= FO_FILE_OBJECT_HAS_EXTENSION;
            fileObjectExtension = (PIOP_FILE_OBJECT_EXTENSION)(fileObject + 1);
            fileObjectExtension->FileObjectExtensionFlags = 0;
            fileObjectExtension->TopDeviceObjectHint = NULL;
            fileObjectExtension->FilterContext = NULL;

            if (op->InternalFlags & IOP_CREATE_USE_TOP_DEVICE_OBJECT_HINT) {
                fileObjectExtension->TopDeviceObjectHint = deviceObject;
            }

            if (op->InternalFlags & IOP_CREATE_IGNORE_SHARE_ACCESS_CHECK) {
                fileObjectExtension->FileObjectExtensionFlags |=FO_EXTENSION_IGNORE_SHARE_ACCESS_CHECK;
            }
        }

        //
        // Now fill in the file object as best is possible at this point and set
        // a pointer to it in the IRP so everyone else can find it.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            KeInitializeEvent( &fileObject->Lock, SynchronizationEvent, FALSE );
            fileObject->Waiters = 0;
            fileObject->CurrentByteOffset.QuadPart = 0;
        }
        if (op->CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING) {
            fileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;
        }
        if (op->CreateOptions & FILE_WRITE_THROUGH) {
            fileObject->Flags |= FO_WRITE_THROUGH;
        }
        if (op->CreateOptions & FILE_SEQUENTIAL_ONLY) {
            fileObject->Flags |= FO_SEQUENTIAL_ONLY;
        }
        if (op->CreateOptions & FILE_RANDOM_ACCESS) {
            fileObject->Flags |= FO_RANDOM_ACCESS;
        }

    } else {

        //
        // This is either a quick delete or query operation.  For these cases,
        // it is possible to optimize the Object Manager out of the picture by
        // simply putting together something that "looks" like a file object,
        // and then operating on it.
        //

        localFileObject = op->LocalFileObject;
        RtlZeroMemory( localFileObject, sizeof( DUMMY_FILE_OBJECT ) );
        fileObject = (PFILE_OBJECT) &localFileObject->ObjectHeader.Body;
        localFileObject->ObjectHeader.Type = IoFileObjectType;
        localFileObject->ObjectHeader.PointerCount = 1;
    }

    if (directDeviceOpen) {
        fileObject->Flags |= FO_DIRECT_DEVICE_OPEN;
    }
    if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
        fileObject->Flags |= FO_OPENED_CASE_SENSITIVE;
    }

    fileObject->Type = IO_TYPE_FILE;
    fileObject->Size = sizeof( FILE_OBJECT );
    fileObject->RelatedFileObject = op->RelatedFileObject;
    fileObject->DeviceObject = parseDeviceObject;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // Allocate a file name string buffer which is large enough to contain
    // the entire remaining name string and initialize the maximum length.
    //

    if (RemainingName->Length) {
        fileObject->FileName.MaximumLength = RoundNameSize( RemainingName->Length );
        fileObject->FileName.Buffer = ExAllocatePoolWithTag( PagedPool,
                                                             fileObject->FileName.MaximumLength,
                                                             'mNoI' );
        if (!fileObject->FileName.Buffer) {
            IoFreeIrp( irp );

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
               IopDereferenceVpbAndFree(vpb);
            }
            fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;
            if (realFileObjectRequired) {
                ObDereferenceObject( fileObject );
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Now copy the name string into the file object from the remaining name
    // that is being reparsed.  If the driver decides to reparse, then it must
    // replace this name.
    //

    RtlCopyUnicodeString( &fileObject->FileName, RemainingName );

    //
    // Before invoking the driver's open routine, check to see whether or not
    // this is a fast network attributes query and, if so, and the driver
    // implements the function, attempt to call it here.
    //

    if (op->QueryOnly) {
        PFAST_IO_DISPATCH fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;
        BOOLEAN result;

        if (fastIoDispatch &&
            fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoQueryOpen ) &&
            fastIoDispatch->FastIoQueryOpen) {

            IoSetNextIrpStackLocation( irp );
            irpSp->DeviceObject = deviceObject;
            result = (fastIoDispatch->FastIoQueryOpen)( irp,
                                                        op->NetworkInformation,
                                                        deviceObject );
            if (result) {
                op->FinalStatus = irp->IoStatus.Status;
                op->Information = irp->IoStatus.Information;

                //
                // The operation worked, so simply dereference and free the
                // resources acquired up to this point.
                //

                if ((op->FinalStatus == STATUS_REPARSE) &&
                    irp->Tail.Overlay.AuxiliaryBuffer) {
                    ASSERT( op->Information > IO_REPARSE_TAG_RESERVED_ONE );
                    ExFreePool( irp->Tail.Overlay.AuxiliaryBuffer );
                    irp->Tail.Overlay.AuxiliaryBuffer = NULL;
                    op->RelatedFileObject = (PFILE_OBJECT) NULL;
                }

                if (fileObject->FileName.Length) {
                    ExFreePool( fileObject->FileName.Buffer );
                }

                IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

                if (vpb) {
                    IopDereferenceVpbAndFree(vpb);
                }

#if DBG
                irp->CurrentLocation = irp->StackCount + 2;
#endif // DBG

                IoFreeIrp( irp );

                //
                // Finally, indicate that the parse routine was actually
                // invoked and that the information returned herein can be
                // used.
                //

                op->ParseCheck = OPEN_PACKET_PATTERN;
                status = STATUS_SUCCESS;

                if (!op->FullAttributes) {
                    try {
                        op->BasicInformation->FileAttributes = op->NetworkInformation->FileAttributes;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        status = GetExceptionCode();
                    }
                }

                return status;

            } else {

                //
                // The fast I/O operation did not work, so take the longer
                // route.
                //

                irp->Tail.Overlay.CurrentStackLocation++;
                irp->CurrentLocation++;
            }
        }
    }

    //
    // Finally, initialize the file object's event to the Not Signaled state
    // and remember that a file object was created.
    //

    KeInitializeEvent( &fileObject->Event, NotificationEvent, FALSE );
    op->FileObject = fileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now invoke the driver itself to open the file.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // One of four things may have happened when the driver was invoked:
    //
    //    1.  The I/O operation is pending (Status == STATUS_PENDING).  This can
    //        occur on devices which need to perform some sort of device
    //        manipulation (such as opening a file for a file system).
    //
    //    2.  The driver returned an error (Status < 0). This occurs when either
    //        a supplied parameter was in error, or the device or file system
    //        incurred or discovered an error.
    //
    //    3.  The operation ended in a reparse (Status == STATUS_REPARSE).  This
    //        occurs when a file system opens the file, only to discover that it
    //        represents a symbolic link.
    //
    //    4.  The operation is complete and was successful (Status ==
    //        STATUS_SUCCESS).  Note that for this case the only action is to
    //        return a pointer to the file object.
    //

    if (status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &fileObject->Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;

    } else {

        //
        // The I/O operation was completed without returning a status of
        // pending.  This means that at this point, the IRP has not been
        // fully completed.  Complete it now.
        //

        KIRQL irql;

        ASSERT( !irp->PendingReturned );
        ASSERT( !irp->MdlAddress );

        //
        // In the case of name junctions do the transmogrify work.
        //

        if (irp->IoStatus.Status == STATUS_REPARSE &&
            irp->IoStatus.Information == IO_REPARSE_TAG_MOUNT_POINT ) {

            PREPARSE_DATA_BUFFER reparseBuffer = NULL;

            ASSERT ( irp->Tail.Overlay.AuxiliaryBuffer != NULL );

            reparseBuffer = (PREPARSE_DATA_BUFFER) irp->Tail.Overlay.AuxiliaryBuffer;

            ASSERT( reparseBuffer->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT );
            ASSERT( reparseBuffer->ReparseDataLength < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );
            ASSERT( reparseBuffer->Reserved < MAXIMUM_REPARSE_DATA_BUFFER_SIZE );


            IopDoNameTransmogrify( irp,
                                   fileObject,
                                   reparseBuffer );

        }

        //
        // Now finish up the request.
        //

        KeRaiseIrql( APC_LEVEL, &irql );

        //
        // Note that normally the system would simply call IopCompleteRequest
        // here to complete the packet.  However, because this is a create
        // operation, several assumptions can be made that make it much faster
        // to perform the couple of operations that completing the request
        // would perform.  These include:  copying the I/O status block,
        // dequeueing the IRP and freeing it, and setting the file object's
        // event to the signaled state.  The latter is done here by hand,
        // since it is known that it is not possible for any thread to be
        // waiting on the event.
        //

        ioStatus = irp->IoStatus;
        status = ioStatus.Status;

        fileObject->Event.Header.SignalState = 1;

        IopDequeueThreadIrp( irp );

        //
        // The SystemBuffer is in some cases used by the driver, and
        // needs to be freed if present.
        //

        if ((irp->Flags & IRP_BUFFERED_IO) && (irp->Flags & IRP_DEALLOCATE_BUFFER)) {
            ExFreePool(irp->AssociatedIrp.SystemBuffer);
        }

        IoFreeIrp( irp );

        KeLowerIrql( irql );
    }

    //
    // Copy the information field of the I/O status block back to the
    // original caller in case it is required.
    //

    op->Information = ioStatus.Information;

    if (!NT_SUCCESS( status )) {

        //
        // If we are canceling the open of a real file object, we simply
        // dereference it.  The object manager does the rest, i.e. the file
        // system and filters will get their cleanup and close at the correct
        // time.
        //

        if (fileObject->Flags & FO_FILE_OPEN_CANCELLED) {
            if (realFileObjectRequired) {
                ObDereferenceObject(fileObject);
            } else {

                IopDeleteFile( fileObject );
            }

        } else {

            //
            // The operation ended in an error.  Kill the file object, dereference
            // the device object, and return a null pointer.
            //

            if (fileObject->FileName.Length) {
                ExFreePool( fileObject->FileName.Buffer );
                fileObject->FileName.Length = 0;
            }

            fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

            if (realFileObjectRequired) {
                ObDereferenceObject( fileObject );
            }

            IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

            if (vpb) {
                IopDereferenceVpbAndFree(vpb);
            }
        }

        op->FileObject = (PFILE_OBJECT) NULL;

        return op->FinalStatus = status;

    } else if (status == STATUS_REPARSE) {

        //
        // The operation resulted in a reparse.  This means that the file
        // name in the file object is the new name to be looked up. Replace
        // the complete name string with the new name and return STATUS_REPARSE
        // so the object manager knows to start over again.  Note, however,
        // that the file name buffer in the file object itself is kept intact
        // so that it can be reused when coming back here again.
        //
        // A reparse status may also have been returned from the file system if
        // the volume that was in a drive needed to have been verified, but
        // the verification failed, and a new volume was mounted.  In this
        // case, everything starts over again using the new volume.
        //

        ASSERT( IO_REPARSE == IO_REPARSE_TAG_RESERVED_ZERO );

        if ((ioStatus.Information == IO_REPARSE) ||
            (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT)) {

            //
            // If the complete name buffer isn't large enough, reallocate it.
            //

            if (CompleteName->MaximumLength < fileObject->FileName.Length) {

                PVOID buffer;

                buffer = ExAllocatePoolWithTag( PagedPool,
                                                fileObject->FileName.Length,
                                                'cFoI' );
                if (!buffer) {
                    return op->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    if (CompleteName->Buffer) {
                        ExFreePool( CompleteName->Buffer );
                    }
                    CompleteName->Buffer = buffer;
                    CompleteName->MaximumLength = fileObject->FileName.Length;
                }
            }

            RtlCopyUnicodeString( CompleteName, &fileObject->FileName );

            //
            // For NTFS directory junction points we NULL the RelatedFileObject.
            // If the prior call was a relative open, the subsequent one will
            // not be.
            //

            if (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {

                op->RelatedFileObject = (PFILE_OBJECT) NULL;
            }
        }

        //
        // Kill the file object, dereference the device object, and return a
        // null pointer.
        //

        if (fileObject->FileName.Length) {
            ExFreePool( fileObject->FileName.Buffer );
            fileObject->FileName.Length = 0;
        }

        fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

        if (realFileObjectRequired) {
            ObDereferenceObject( fileObject );
        }
        op->FileObject = (PFILE_OBJECT) NULL;

        IopDecrementDeviceObjectRef( parseDeviceObject, FALSE, FALSE );

        if (vpb) {
            IopDereferenceVpbAndFree(vpb);
        }

        ASSERT( IO_REMOUNT == IO_REPARSE_TAG_RESERVED_ONE );

        if (ioStatus.Information == IO_REPARSE_TAG_RESERVED_ONE) {

            //
            // If we are reparsing to verify a volume, restart the reparse
            // by attempting to parse the device once again.  Note that it
            // would be best to simply recurse, but it's not possible since
            // there is a limited amount of stack available to kernel mode
            // and a limit needs to be enforced for the number of times that
            // verify reparse can occur.
            //

            if (++retryCount > IO_MAX_REMOUNT_REPARSE_ATTEMPTS) {

                return STATUS_UNSUCCESSFUL;
            }
            goto reparse_loop;

        } else {

            //
            // Really reparsing a symbolic link, so go back to the object
            // manager so it can begin the parse from the top.
            //

            op->RelatedFileObject = (PFILE_OBJECT) NULL;

            //
            // Note that the mountpoint should be set only for the correct
            // tag. IO_REMOUNT is sent by FAT,CDFS and UDFS to remount a volume.
            // IO_REPARSE is set by the network filesystems to just use a different path.
            //

            if (ioStatus.Information == IO_REPARSE_TAG_MOUNT_POINT) {
                op->TraversedMountPoint = TRUE;
            }

            //
            // No driver should return this status for a volume open.
            // If they do then we would skip the security check as override is true.
            // To catch that case we bugcheck here.
            //

            if (op->Override) {
                KeBugCheckEx(DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN,
                             (ULONG_PTR)parseDeviceObject,
                             (ULONG_PTR)deviceObject,
                             (ULONG_PTR)CompleteName,
                             (ULONG_PTR)ioStatus.Information
                             );
            }

            return STATUS_REPARSE;
        }

    } else {

        //
        // The operation was successful. The first thing to do is to see if
        // the device that processed the open also opened the file. If
        // not, we need to adjust the vpb reference counts. Then, if this is
        // not a query or a delete, but rather a normal open/create, return
        // the address of the FileObject to the caller and set the
        // information returned in the original requestor's I/O status block.
        // Also set the value of the parse check field in the open packet to
        // a value which will let the caller know that this routine was
        // successful in creating the file object. Finally, return the status
        // of the operation to the caller.
        //

        PDEVICE_OBJECT deviceObjectThatOpenedFile;

        deviceObjectThatOpenedFile = IoGetRelatedDeviceObject(fileObject);
        if (deviceObject != deviceObjectThatOpenedFile) {
            PVPB    newVpb;

            //
            // The device that opened the related file is not the one
            // that opened this file. So, readjust the vpb reference
            // counts.
            //

            newVpb = fileObject->Vpb;

            //
            // If the new VPB is not the same as the original VPB
            // then reference the new one before freeing the old one.
            // If a filter was just added to the fileobject stack the VPB will not
            // change. So check for a difference in VPB as well.
            //

            if (newVpb != vpb) {
                if (newVpb) {
                    IopInterlockedIncrementUlong( LockQueueIoVpbLock,
                                                  (PLONG) &newVpb->ReferenceCount);
                }

                if (vpb) {
                    IopDereferenceVpbAndFree(vpb);
                }
            }
        }

        if (realFileObjectRequired) {

            *Object = fileObject;
            op->ParseCheck = OPEN_PACKET_PATTERN;

            //
            // Add a reference so the file object cannot go away before
            // the create routine gets chance to flag the object for handle
            // create.
            //

            ObReferenceObject( fileObject );

            //
            // If the filename length is zero and its not a relative open or
            // its a relative open to a volume open then set the volume open flag.
            // Also set it only for filesystem device object volume.
            //
            if ((!fileObject->RelatedFileObject || fileObject->RelatedFileObject->Flags & FO_VOLUME_OPEN) &&
                (!fileObject->FileName.Length)) {
                switch (deviceObjectThatOpenedFile->DeviceType) {
                case FILE_DEVICE_DISK_FILE_SYSTEM:
                case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
                case FILE_DEVICE_TAPE_FILE_SYSTEM:
                case FILE_DEVICE_FILE_SYSTEM:

                    fileObject->Flags |= FO_VOLUME_OPEN;
                    break;

                default:
                    break;
                }
            }

            return op->FinalStatus = ioStatus.Status;

        } else {

            //
            // This is either a quick query or delete operation.  Determine
            // which it is and quickly perform the operation.
            //

            if (op->QueryOnly) {
                PFAST_IO_DISPATCH fastIoDispatch;
                BOOLEAN queryResult = FALSE;

                fastIoDispatch = deviceObjectThatOpenedFile->DriverObject->FastIoDispatch;

                if (!op->FullAttributes) {
                    PFILE_BASIC_INFORMATION basicInfo = NULL;

                    //
                    // This is a simple FAT file attribute query.  Attempt to
                    // obtain the basic information about the file.
                    //

                    try {

                        if (fastIoDispatch && fastIoDispatch->FastIoQueryBasicInfo) {
                            queryResult = fastIoDispatch->FastIoQueryBasicInfo(
                                            fileObject,
                                            TRUE,
                                            op->BasicInformation,
                                            &ioStatus,
                                            deviceObjectThatOpenedFile
                                            );
                        }
                        if (!queryResult) {

                            basicInfo = ExAllocatePool( NonPagedPool,
                                                        sizeof( FILE_BASIC_INFORMATION ) );
                            if (basicInfo) {
                                status = IoQueryFileInformation(
                                            fileObject,
                                            FileBasicInformation,
                                            sizeof( FILE_BASIC_INFORMATION ),
                                            basicInfo,
                                            &returnedLength
                                            );
                                if (NT_SUCCESS( status )) {
                                    RtlCopyMemory( op->BasicInformation,
                                                   basicInfo,
                                                   returnedLength );
                                }
                                ExFreePool( basicInfo );
                            } else {
                                status = STATUS_INSUFFICIENT_RESOURCES;
                            }
                        } else {
                            status = ioStatus.Status;
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        if (basicInfo) {
                            ExFreePool( basicInfo );
                        }
                        status = GetExceptionCode();
                    }

                } else {

                    //
                    // This is a full attribute query.  Attempt to obtain the
                    // full network attributes for the file.  This includes
                    // both the basic and standard information about the
                    // file.  Try the fast path first, if it exists.
                    //

                    if (fastIoDispatch &&
                        fastIoDispatch->SizeOfFastIoDispatch > FIELD_OFFSET( FAST_IO_DISPATCH, FastIoQueryNetworkOpenInfo ) &&
                        fastIoDispatch->FastIoQueryNetworkOpenInfo) {
                        queryResult = fastIoDispatch->FastIoQueryNetworkOpenInfo(
                                        fileObject,
                                        TRUE,
                                        op->NetworkInformation,
                                        &ioStatus,
                                        deviceObjectThatOpenedFile
                                        );
                    }
                    if (!queryResult) {

                        //
                        // Either the fast dispatch routine did not exist, or
                        // it simply wasn't callable at this time.  Attempt to
                        // obtain all of the information at once via an IRP-
                        // based call.
                        //

                        status = IoQueryFileInformation(
                                    fileObject,
                                    FileNetworkOpenInformation,
                                    sizeof( FILE_NETWORK_OPEN_INFORMATION ),
                                    op->NetworkInformation,
                                    &returnedLength
                                    );

                        if (!NT_SUCCESS( status )) {
                            if (status == STATUS_INVALID_PARAMETER ||
                                status == STATUS_NOT_IMPLEMENTED) {
                                status = IopGetNetworkOpenInformation(fileObject, op);
                            }
                        }
                    }
                }

            } else {

                //
                // There is nothing to do for a quick delete since the caller
                // set the FILE_DELETE_ON_CLOSE CreateOption so it is already
                // set in the file system.
                //

                NOTHING;

            }

            op->ParseCheck = OPEN_PACKET_PATTERN;
            if (realFileObjectRequired) {
                ObDereferenceObject( fileObject );
            } else {
                IopDeleteFile( fileObject );
            }
            op->FileObject = (PFILE_OBJECT) NULL;

            op->FinalStatus = status;

            return status;
        }
    }
}

NTSTATUS
IopGetNetworkOpenInformation(
    IN  PFILE_OBJECT    FileObject,
    IN  POPEN_PACKET    Op
    )
/*++

Routine Description:

    This routines gets the network information in two steps.
    Its called out as a separate routine from IopParseDevice to save stack for
    common create paths.

Arguments:

    FileObject  - Pointer to the fileobject for the opened file.

    Op          - Pointer to the open packet.


Return Value:

    NTSTATUS

--*/
{
#define COPY_ATTRIBUTES( n, b, s ) {                                    \
        (n)->CreationTime.QuadPart = (b)->CreationTime.QuadPart;        \
        (n)->LastAccessTime.QuadPart = (b)->LastAccessTime.QuadPart;    \
        (n)->LastWriteTime.QuadPart = (b)->LastWriteTime.QuadPart;      \
        (n)->ChangeTime.QuadPart = (b)->ChangeTime.QuadPart;            \
        (n)->AllocationSize.QuadPart = (s)->AllocationSize.QuadPart;    \
        (n)->EndOfFile.QuadPart = (s)->EndOfFile.QuadPart;              \
        (n)->FileAttributes = (b)->FileAttributes; }

    FILE_BASIC_INFORMATION     basicInfo;
    FILE_STANDARD_INFORMATION  stdInfo;
    ULONG                      returnedLength;
    NTSTATUS                   status;

    PAGED_CODE();

    //
    // The IRP-based call did not work either, so
    // simply try to obtain the information by
    // doing IRP-based queries for the basic and
    // standard information and piecing together
    // the results into the caller's buffer.  Note
    // that it might be possible to perform fast
    // I/O operations to get the data, but it
    // might also fail because of the above.  So
    // simply query the information the long way.
    //

    status = IoQueryFileInformation(
                FileObject,
                FileBasicInformation,
                sizeof( FILE_BASIC_INFORMATION ),
                &basicInfo,
                &returnedLength
                );

    if (NT_SUCCESS( status )) {
        status = IoQueryFileInformation(
                    FileObject,
                    FileStandardInformation,
                    sizeof( FILE_STANDARD_INFORMATION ),
                    &stdInfo,
                    &returnedLength
                    );
        if (NT_SUCCESS( status )) {
            COPY_ATTRIBUTES( Op->NetworkInformation,
                             &basicInfo,
                             &stdInfo );
        }
    }
    return status;
}

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and is
    also given a handle to a directory file object that the operation is to be
    performed relative to.  This routine is specified as the parse routine for
    all file objects.

    This routine simply invokes the parse routine for the appropriate device
    that is associated with the file object.  It is the responsibility of that
    routine to perform the operation.

Arguments:

    ParseObject - Pointer to the file object that the name is to be opened or
        created relative to.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    AccessMode - Access mode of the original caller.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    SecurityQos - Supplies a pointer to the captured QOS information
        if available.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{
    PDEVICE_OBJECT deviceObject;
    POPEN_PACKET op;

    PAGED_CODE();

    //
    // Get the address of the Open Packet (OP).
    //

    op = (POPEN_PACKET) Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Get a pointer to the device object for this file.
    //

    deviceObject = IoGetRelatedDeviceObject( (PFILE_OBJECT) ParseObject );

    //
    // Pass the related file object to the device object parse routine.
    //

    op->RelatedFileObject = (PFILE_OBJECT) ParseObject;

    //
    // Open or create the specified file.
    //

    return IopParseDevice( deviceObject,
                           ObjectType,
                           AccessState,
                           AccessMode,
                           Attributes,
                           CompleteName,
                           RemainingName,
                           Context,
                           SecurityQos,
                           Object );
}

NTSTATUS
IopQueryNameInternal(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    IN BOOLEAN UseDosDeviceName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE  Mode
    )

/*++

Routine Description:

    This function implements the query name procedure for the Object Manager
    for querying the names of file objects.

Arguments:

    Object - Pointer to the file object whose name is to be retrieved.

    HasObjectName - Indicates whether or not the object has a name.

    UseDosDeviceName - Indicates whether to translate the device object part
                        of the fileobject into the dosdevice name space or the
                        regular \device namespace via ob

    ObjectNameInfo - Buffer in which to return the name.

    Length - Specifies the length of the output buffer, in bytes.

    ReturnLength - Specifies the number of bytes actually returned in the
        output buffer or the number of bytes needed if Length is smaller
        than needed.

Return Value:

    The function return value is the final status of the query operation.

--*/

{
    NTSTATUS status;
    ULONG lengthNeeded;
    PFILE_OBJECT fileObject;
    PUCHAR buffer;
    PWSTR p;
    POBJECT_NAME_INFORMATION deviceNameInfo;
    PFILE_NAME_INFORMATION fileNameInfo;
    ULONG length;
    BOOLEAN deviceNameOverflow;
    BOOLEAN dosLookupSuccess = 0;

    UNREFERENCED_PARAMETER( HasObjectName );

    PAGED_CODE();

    ASSERT( FIELD_OFFSET( FILE_NAME_INFORMATION, FileName ) < sizeof( OBJECT_NAME_INFORMATION ) );

    //
    // Ensure that the size of the output buffer is at least the minimum
    // size required to include the basic object name information structure.
    //

    if (Length < sizeof( OBJECT_NAME_INFORMATION )) {
        *ReturnLength = sizeof(OBJECT_NAME_INFORMATION);
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Begin by allocating a buffer in which to build the name of the file.
    //

    buffer = ExAllocatePoolWithTag( PagedPool, Length, '  oI' );

    if (!buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the name of the device on which the file is open.
    //

    fileObject = (PFILE_OBJECT) Object;
    deviceNameInfo = (POBJECT_NAME_INFORMATION) buffer;

    if (UseDosDeviceName) {
        if (fileObject->DeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM) {

            lengthNeeded = sizeof(OBJECT_NAME_INFORMATION) + 2*sizeof(WCHAR); // For the extra '\' and '\0'

            if (lengthNeeded > Length) {
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

            deviceNameInfo->Name.Length = sizeof(WCHAR);
            deviceNameInfo->Name.MaximumLength = sizeof(WCHAR);
            p = (PWSTR) (deviceNameInfo + 1);
            *p = '\\'; // Start with a '\' as RDR does not return the extra
            deviceNameInfo->Name.Buffer = p;

        } else {
            status = IoVolumeDeviceToDosName( fileObject->DeviceObject, &deviceNameInfo->Name );
            lengthNeeded = sizeof(OBJECT_NAME_INFORMATION) + deviceNameInfo->Name.Length + sizeof(WCHAR);
        }

        //
        // If querying the dos name fails try to atleast get the real device name
        //

        if (!NT_SUCCESS(status)) {
            status = ObQueryNameString( (PVOID) fileObject->DeviceObject,
                                    deviceNameInfo,
                                    Length,
                                    &lengthNeeded );
        } else {
            dosLookupSuccess++;
        }
    } else {
        status = ObQueryNameString( (PVOID) fileObject->DeviceObject,
                                deviceNameInfo,
                                Length,
                                &lengthNeeded );
    }

    if (!NT_SUCCESS( status )) {
        if (status != STATUS_INFO_LENGTH_MISMATCH) {
            return status;
        }
    }

    //
    // Ensure that there is enough room in the output buffer to return the
    // name and copy it.
    //

    p = (PWSTR) (ObjectNameInfo + 1);

    //
    // If we got a DOS name, note the name isn't contiguous to the device name info,
    // and that we should free it (the Rtl call did not know we allocated this big
    // buffer, and made a new one).
    //

    try {

        if (UseDosDeviceName && dosLookupSuccess) {

            ULONG BaseCopyLength;
            ULONG NameCopyLength;

            //
            // We will never take an exception in this path. That's why we don't have to free
            // the device name buffer in the exception handler.
            //

            ASSERT(Mode == KernelMode);

            //
            //  Figure out how much of each part we can copy.
            //

            BaseCopyLength = sizeof(UNICODE_STRING);

            if ( Length < lengthNeeded ) {
                if ( Length < sizeof(UNICODE_STRING)) {
                    BaseCopyLength = Length;
                    NameCopyLength = 0;
                } else {
                    NameCopyLength = Length - BaseCopyLength;
                }
            } else {
                NameCopyLength = deviceNameInfo->Name.Length;
            }

            //
            // Copy in two parts - the base chunk of the UNICODE_STRING and then
            // as much of the name as will fit.
            //

            RtlCopyMemory( ObjectNameInfo,
                           deviceNameInfo,
                           BaseCopyLength );
            RtlCopyMemory( p,
                           deviceNameInfo->Name.Buffer,
                           NameCopyLength );

            if (fileObject->DeviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM) {
                ExFreePool( deviceNameInfo->Name.Buffer );
            }

        } else {

            RtlCopyMemory( ObjectNameInfo,
                           deviceNameInfo,
                           lengthNeeded > Length ? Length : lengthNeeded );
        }

        ObjectNameInfo->Name.Buffer = p;
        p = (PWSTR) ((PCHAR) p + deviceNameInfo->Name.Length);

        //
        // If the buffer is already full, note and continue to pick up the filename length.
        // We want to return the required length for the entire result.
        //

        deviceNameOverflow = FALSE;
        if (lengthNeeded > Length) {
            *ReturnLength = lengthNeeded;
            deviceNameOverflow = TRUE;
        }

        //
        // Reset the state for the buffer to obtain the filename portion of the
        // name and calculate the remaining length of the caller's buffer.  Note
        // that in the following calculations, there are two assumptions and
        // and dependencies:
        //
        //     1)  The above query of the device name's returned length needed
        //         include a NULL character which will be included at the end
        //         of the entire name.  This is included in the calculations
        //         although it does not appear to be included.
        //
        //     2)  The sizeof the object name information buffer is assumed
        //         (and guaranteed because it can never change) to be larger
        //         than the filename offset in a file name information buffer.
        //         Therefore it is known that the new length of the "buffer"
        //         variable can be set to the remaining length plus at least 4.
        //

        fileNameInfo = (PFILE_NAME_INFORMATION) buffer;

        if (deviceNameOverflow) {
            length = Length;
        } else {
            length = Length - lengthNeeded;
            length += FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
        }

        if (((Mode == UserMode) && (!UseDosDeviceName)) ||
            !(fileObject->Flags & FO_SYNCHRONOUS_IO)) {

            //
            // Query the name of the file based using an intermediary buffer.
            //

            status = IopQueryXxxInformation( fileObject,
                                             FileNameInformation,
                                             length,
                                             Mode,
                                             (PVOID) fileNameInfo,
                                             &lengthNeeded,
                                             TRUE );
        } else {

            //
            // This is a kernel mode request for a file that was opened for
            // synchronous I/O.  A special function that does not obtain the
            // file object lock is required, otherwise the request may deadlock
            // since the lock is probably already owned.
            //

            status = IopGetFileInformation( fileObject,
                                     length,
                                     FileNameInformation,
                                     fileNameInfo,
                                     &lengthNeeded );
        }

        //
        // If an error occurred attempting to obtain the filename return now.  Note
        // that buffer overflow is a warning, not an error.
        //

        if (NT_ERROR( status )) {
            if (status == STATUS_INVALID_PARAMETER ||
                status == STATUS_INVALID_DEVICE_REQUEST ||
                status == STATUS_NOT_IMPLEMENTED ||
                status == STATUS_INVALID_INFO_CLASS) {

                lengthNeeded = FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
                fileNameInfo->FileNameLength = 0;
                fileNameInfo->FileName[0] = OBJ_NAME_PATH_SEPARATOR;
                status = STATUS_SUCCESS;
            } else {
                leave;
            }
        }  else if (lengthNeeded < FIELD_OFFSET( FILE_NAME_INFORMATION, FileName )) {
            lengthNeeded = FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
        }

        //
        // Compute the correct length
        // Note that ReturnLength already contains a space for NULL added by the previous ObQueryNameString.
        //

        if (deviceNameOverflow) {
            *ReturnLength += fileNameInfo->FileNameLength;
            status = STATUS_BUFFER_OVERFLOW;
            leave;
        }

        //
        // Set the remaining length of the caller's buffer as well as the total
        // length needed to contain the entire name of the file.
        //

        length = lengthNeeded - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName );
        lengthNeeded = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo) + fileNameInfo->FileNameLength;

        //
        // Attempt to copy the name of the file into the output buffer.  Note
        // that if the file name does not begin w/a '\', then it is not volume
        // relative, so the name of the file cannot be expressed as the
        // concatenation of the name of the device and the file.  Therefore an
        // error is returned.
        //
        // The only example of this situation known at this time is when one
        // opens a directory by file ID, and then opens a file relative to that
        // directory.  When attempting to query the path, if the caller did not
        // have traverse access to open the directory, then the only name that
        // can be returned is the path name to the file from the directory, but
        // the volume-relative name cannot be returned.  Therefore, the file
        // system returns only the name of the directory and the path to the
        // file, but this is not volume-relative so the only recourse is to
        // return an error.
        //
        // Note that if the caller were to call NtQueryInformationFile and
        // request FileNameInformation, then the name above named will be
        // successfully returned from the file system.
        //

        if (fileNameInfo->FileName[0] != OBJ_NAME_PATH_SEPARATOR) {
            status = STATUS_OBJECT_PATH_INVALID;
            leave;
        }

        RtlCopyMemory( p,
                       fileNameInfo->FileName,
                       length );
        p = (PWSTR) ((PCH) p + length);
        *p = '\0';
        lengthNeeded += sizeof( WCHAR );

        *ReturnLength = lengthNeeded;

        length = (ULONG)((PUCHAR) p - (PUCHAR) ObjectNameInfo);
        ObjectNameInfo->Name.Length = (USHORT) (length - sizeof( *ObjectNameInfo ));
        ObjectNameInfo->Name.MaximumLength =  (USHORT) ((length - sizeof( *ObjectNameInfo )) + sizeof( WCHAR ));
    }

    finally {

        //
        // Finally, free the temporary buffer.
        //

        ExFreePool( buffer );
    }

    return status;
}

NTSTATUS
IopQueryName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength,
    IN KPROCESSOR_MODE Mode
    )

/*++

Routine Description:

    This function implements the query name procedure for the Object Manager
    for querying the names of file objects.

Arguments:

    Object - Pointer to the file object whose name is to be retrieved.

    HasObjectName - Indicates whether or not the object has a name.

    ObjectNameInfo - Buffer in which to return the name.

    Length - Specifies the length of the output buffer, in bytes.

    ReturnLength - Specifies the number of bytes actually returned in the
        output buffer.

    Mode = Processor mode of the caller

Return Value:

    The function return value is the final status of the query operation.

--*/

{
    UNREFERENCED_PARAMETER (Mode);

    return IopQueryNameInternal( Object,
                                 HasObjectName,
                                 FALSE,
                                 ObjectNameInfo,
                                 Length,
                                 ReturnLength,
                                 Mode );
}



VOID
IopCheckBackupRestorePrivilege(
    IN PACCESS_STATE AccessState,
    IN OUT PULONG CreateOptions,
    IN KPROCESSOR_MODE PreviousMode,
    IN ULONG Disposition
    )

/*++

Routine Description:

    This function will determine if the caller is asking for any accesses
    that may be satisfied by Backup or Restore privileges, and if so,
    perform the privilege checks.  If the privilege checks succeed, then
    the appropriate bits will be moved out of the RemainingDesiredAccess
    field in the AccessState structure and placed into the PreviouslyGrantedAccess
    field.

    Note that access is not denied if the caller does not have either or
    both of the privileges, since he may be granted the desired access
    via the security descriptor on the object.

    This routine will also set a flag in the AccessState structure so that
    it will not perform these privilege checks again in case we come through
    this way again due to a reparse.

Arguments:

    AccessState - The AccessState containing the current state of this access
        attempt.

    CreateOptions - The CreateOptions field from the OPEN_PACKET structure for
        this open attempt.

    PreviousMode - The processor mode to be used in checking parameters.

    Disposition - The create disposition for this request.

Return Value:

    None.

--*/

{
    ACCESS_MASK desiredAccess;
    ACCESS_MASK readAccess;
    ACCESS_MASK writeAccess;
    PRIVILEGE_SET requiredPrivileges;
    BOOLEAN accessGranted;
    BOOLEAN keepBackupIntent = FALSE;
    BOOLEAN ForceRestoreCheck = FALSE;

    PAGED_CODE();

    //
    // Check to determine whether or not this check has already been made.
    // If so, simply return back to the caller.
    //

    if (AccessState->Flags & SE_BACKUP_PRIVILEGES_CHECKED) {
        return;
    }

    if (*CreateOptions & FILE_OPEN_FOR_BACKUP_INTENT) {
        AccessState->Flags |= SE_BACKUP_PRIVILEGES_CHECKED;

        readAccess = READ_CONTROL | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_READ | FILE_TRAVERSE;
        writeAccess = WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY | FILE_GENERIC_WRITE | FILE_ADD_FILE | FILE_ADD_SUBDIRECTORY | DELETE;

        desiredAccess = AccessState->RemainingDesiredAccess;

        //
        // If the caller has requested MAXIMUM_ALLOWED, then make it appear as
        // if the request was for everything permitted by Backup and Restore,
        // and then grant everything that can actually be granted.
        //

        if (desiredAccess & MAXIMUM_ALLOWED) {
            desiredAccess |= ( readAccess | writeAccess );
        }

        //
        // If the disposition says that we're opening the file, check for both backup
        // and restore privilege, depending on what's in the desired access.
        //
        // If the disposition says that we're creating or trying to overwrite the file,
        // then all we need to do is to check for restore privilege, and if it's there,
        // grant every possible access.
        //

        if ((Disposition == FILE_OPEN )  || (Disposition == FILE_OPEN_IF) || (Disposition == FILE_OVERWRITE_IF)) {

            //
            // If the request was for any of the bits in the read access mask, then
            // assume that this is a backup operation, and check for the Backup
            // privilege.  If the caller has it, then grant the intersection of
            // the desired access and read access masks.
            //

            if (readAccess & desiredAccess) {

                requiredPrivileges.PrivilegeCount = 1;
                requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
                requiredPrivileges.Privilege[0].Luid = SeBackupPrivilege;
                requiredPrivileges.Privilege[0].Attributes = 0;

                accessGranted = SePrivilegeCheck( &requiredPrivileges,
                                                  &AccessState->SubjectSecurityContext,
                                                  PreviousMode );

                if (accessGranted) {

                    //
                    // The caller has Backup privilege, so grant the appropriate
                    // accesses.
                    //

                    keepBackupIntent = TRUE;
                    (VOID) SeAppendPrivileges( AccessState, &requiredPrivileges );
                    AccessState->PreviouslyGrantedAccess |= ( desiredAccess & readAccess );
                    AccessState->RemainingDesiredAccess &= ~readAccess;
                    desiredAccess &= ~readAccess;
                    AccessState->Flags |= TOKEN_HAS_BACKUP_PRIVILEGE;
                }
            }

        } else {

            ForceRestoreCheck = TRUE;
        }

        //
        // If the request was for any of the bits in the write access mask, then
        // assume that this is a restore operation, so check for the Restore
        // privilege.  If the caller has it, then grant the intersection of
        // the desired access and write access masks.
        //

        if ((writeAccess & desiredAccess) || ForceRestoreCheck) {

            requiredPrivileges.PrivilegeCount = 1;
            requiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
            requiredPrivileges.Privilege[0].Luid = SeRestorePrivilege;
            requiredPrivileges.Privilege[0].Attributes = 0;

            accessGranted = SePrivilegeCheck( &requiredPrivileges,
                                              &AccessState->SubjectSecurityContext,
                                              PreviousMode );

            if (accessGranted) {

                //
                // The caller has Restore privilege, so grant the appropriate
                // accesses.
                //

                keepBackupIntent = TRUE;
                (VOID) SeAppendPrivileges( AccessState, &requiredPrivileges );
                AccessState->PreviouslyGrantedAccess |= (desiredAccess & writeAccess);
                AccessState->RemainingDesiredAccess &= ~writeAccess;
                AccessState->Flags |= TOKEN_HAS_RESTORE_PRIVILEGE;
            }
        }

        //
        // If either of the access types was granted because the caller had
        // backup or restore privilege, then the backup intent flag is kept.
        // Otherwise, it is cleared so that it is not passed onto the driver
        // so that it is not incorrectly propagated anywhere else, since this
        // caller does not actually have the privilege enabled.
        //

        if (!keepBackupIntent) {
            *CreateOptions &= ~FILE_OPEN_FOR_BACKUP_INTENT;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\qsinfo.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    qsinfo.c

Abstract:

    This module contains the code to implement the NtQueryInformationFile and
    NtSetInformationFile system services for the NT I/O system.

--*/

#include "iomgr.h"

//
// Create local definitions for long flag names to make code slightly more
// readable.
//

#define FSIO_A  FILE_SYNCHRONOUS_IO_ALERT
#define FSIO_NA FILE_SYNCHRONOUS_IO_NONALERT

//
// Forward declarations of local routines.
//

ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    );

#pragma alloc_text(PAGE, IopGetModeInformation)
#pragma alloc_text(PAGE, NtQueryInformationFile)
#pragma alloc_text(PAGE, NtSetInformationFile)

ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This encapsulates extracting and translating the mode bits from
    the passed file object, to be returned from a query information call.

Arguments:

    FileObject - Specifies the file object for which to return Mode info.

Return Value:

    The translated mode information is returned.

--*/

{
    ULONG mode = 0;

    if (FileObject->Flags & FO_WRITE_THROUGH) {
        mode = FILE_WRITE_THROUGH;
    }
    if (FileObject->Flags & FO_SEQUENTIAL_ONLY) {
        mode |= FILE_SEQUENTIAL_ONLY;
    }
    if (FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        mode |= FILE_NO_INTERMEDIATE_BUFFERING;
    }
    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        if (FileObject->Flags & FO_ALERTABLE_IO) {
            mode |= FILE_SYNCHRONOUS_IO_ALERT;
        } else {
            mode |= FILE_SYNCHRONOUS_IO_NONALERT;
        }
    }
    if (FileObject->Flags & FO_DELETE_ON_CLOSE) {
        mode |= FILE_DELETE_ON_CLOSE;
    }
    return mode;
}

NTSTATUS
NtQueryInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file about which the requested
        information should be returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus = {0};
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN synchronousIo;
    BOOLEAN skipDriver;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FileInformationClass parameter is legal for querying
        // information about the file.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Ensure that the supplied buffer is large enough to contain the
        // information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FileInformation buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( FileInformation, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( FileInformation,
                               Length,
                               IopQuerySetAlignmentRequirement[FileInformationClass] );
            }
#else
            ProbeForWrite( FileInformation,
                           Length,
                           IopQuerySetAlignmentRequirement[FileInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters.  Simply return an appropriate error status
            // code.
            //


            return GetExceptionCode();
        }

#if DBG

    } else {

        //
        // The caller's mode is kernel.  Ensure that at least the information
        // class and lengths are appropriate.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

#endif // DBG

    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopQueryOperationAccess[FileInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);

    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.  Also get the address of the Fast Io
    // dispatch structure.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }
    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to query the file position pointer.  If so, then
        // return it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested the current file position context
            // information.  This is a relatively frequent call, so it is
            // optimized here to cut through the normal IRP path.
            //
            // Begin by establishing a condition handler and attempting to
            // return both the file position information as well as the I/O
            // status block.  If writing the output buffer fails, then return
            // an appropriate error status code.  If writing the I/O status
            // block fails, then ignore the error.  This is what would
            // normally happen were everything to go through normal special
            // kernel APC processing.
            //

            BOOLEAN writingBuffer = TRUE;
            PFILE_POSITION_INFORMATION fileInformation = FileInformation;

            try {

                //
                // Return the current position information.
                //

                fileInformation->CurrentByteOffset = fileObject->CurrentByteOffset;
                writingBuffer = FALSE;

                //
                // Write the I/O status block.
                //

                IoStatusBlock->Status = STATUS_SUCCESS;
                IoStatusBlock->Information = sizeof( FILE_POSITION_INFORMATION );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                // One of writing the caller's buffer or writing the I/O
                // status block failed.  Set the final status appropriately.
                //

                if (writingBuffer) {
                    status = GetExceptionCode();
                }

            }

            //
            // Note that the state of the event in the file object has not yet
            // been reset, so it need not be set either.  Therefore, simply
            // cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;

        //
        // Also do a special check if the caller it doing a query for basic or
        // standard information and if so then try the fast query calls if they
        // exist.
        //

        } else if (fastIoDispatch &&
                   (((FileInformationClass == FileBasicInformation) &&
                     fastIoDispatch->FastIoQueryBasicInfo) ||
                    ((FileInformationClass == FileStandardInformation) &&
                     fastIoDispatch->FastIoQueryStandardInfo))) {

            IO_STATUS_BLOCK localIoStatus;
            BOOLEAN queryResult = FALSE;
            BOOLEAN writingStatus = FALSE;

            //
            // Do the query and setting of the IoStatusBlock inside an exception
            // handler.  Note that if an exception occurs, other than writing
            // the status back, then the IRP route will be taken.  If an error
            // occurs attempting to write the status back to the caller's buffer
            // then it will be ignored, just as it would be on the long path.
            //

            try {

                if (FileInformationClass == FileBasicInformation) {
                    queryResult = fastIoDispatch->FastIoQueryBasicInfo( fileObject,
                                                                        TRUE,
                                                                        FileInformation,
                                                                        &localIoStatus,
                                                                        deviceObject );
                } else {
                    queryResult = fastIoDispatch->FastIoQueryStandardInfo( fileObject,
                                                                           TRUE,
                                                                           FileInformation,
                                                                           &localIoStatus,
                                                                           deviceObject );
                }

                if (queryResult) {
                    status = localIoStatus.Status;
                    writingStatus = TRUE;
                    *IoStatusBlock = localIoStatus;
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                //
                // If the result of the preceding block is an exception that
                // occurred after the Fast I/O path itself, then the query
                // actually succeeded so everything is done already, but the
                // user's I/O status buffer is not writable.  This case is
                // ignored to be consistent w/the long path.
                //

                if (!writingStatus) {
                    status = GetExceptionCode();
                }
            }

            //
            // If the results of the preceding statement block is true, then
            // the fast query call succeeded, so simply cleanup and return.
            //

            if (queryResult) {

                //
                // Note that once again, the event in the file object has not
                // yet been set reset, so it need not be set to the Signaled
                // state, so simply cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer which should be used to put the information into by
    // the driver.  This will be copied back to the caller's buffer when the
    // service completes.  This is done by setting the flag which says that
    // this is an input operation.
    //

    irp->UserBuffer = FileInformation;
    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        //
        // Allocate the system buffer using an exception handler so that
        // errors can be caught and handled.
        //

        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred by attempting to allocate the intermediary
        // system buffer.  Cleanup everything and return an appropriate error
        // status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();
    }

    irp->Flags |= IRP_BUFFERED_IO |
                  IRP_DEALLOCATE_BUFFER |
                  IRP_INPUT_OPERATION |
                  IRP_DEFER_IO_COMPLETION;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // is device independent.  If this is the case, then the request can
    // be satisfied here without having to have all of the drivers implement
    // the same code.  Note that having the IRP is still necessary since
    // the I/O completion code requires it.
    //

    skipDriver = FALSE;

    if (FileInformationClass == FileAccessInformation) {

        PFILE_ACCESS_INFORMATION accessBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the access information for this file.
        //

        accessBuffer->AccessFlags = handleInformation.GrantedAccess;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ACCESS_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the mode information for this file.
        //

        modeBuffer->Mode = IopGetModeInformation( fileObject );

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_MODE_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAlignmentInformation) {

        PFILE_ALIGNMENT_INFORMATION alignmentInformation = irp->AssociatedIrp.SystemBuffer;

        //
        // Return the alignment information for this file.
        //

        alignmentInformation->AlignmentRequirement = deviceObject->AlignmentRequirement;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ALIGNMENT_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAllInformation) {

        PFILE_ALL_INFORMATION allInformation = irp->AssociatedIrp.SystemBuffer;

        //
        // The caller has requested all of the information about the file.
        // This request is handled specially because the service will fill
        // in the Access and Mode and Alignment information in the buffer
        // and then pass the buffer to the driver to fill in the remainder.
        //
        // Begin by returning the Access information for the file.
        //

        allInformation->AccessInformation.AccessFlags =
            handleInformation.GrantedAccess;

        //
        // Return the mode information for this file.
        //

        allInformation->ModeInformation.Mode =
            IopGetModeInformation( fileObject );

        //
        // Return the alignment information for this file.
        //

        allInformation->AlignmentInformation.AlignmentRequirement =
            deviceObject->AlignmentRequirement;

        //
        // Finally, set the information field of the IoStatus block in the IRP
        // to account for the amount information already filled in and invoke
        // the driver to fill in the remainder.
        //

        irp->IoStatus.Information = sizeof( FILE_ACCESS_INFORMATION ) +
                                    sizeof( FILE_MODE_INFORMATION ) +
                                    sizeof( FILE_ALIGNMENT_INFORMATION );
    }

    if (skipDriver) {

        //
        // The requested operation has already been performed.  Simply
        // set the final status in the packet and the return state.
        //

        status = STATUS_SUCCESS;
        irp->IoStatus.Status = STATUS_SUCCESS;

    } else {

        //
        // This is not a request that can be [completely] performed here, so
        // invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            requestorMode,
                                            (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists so that synchronization
                // with the file object will remain intact.
                //

                IopCancelAlertedRequest( &fileObject->Event, irp );

            }

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( event,
                                            Executive,
                                            requestorMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists or the event will not
                // be around to set to the Signaled state.
                //

                IopCancelAlertedRequest( event, irp );

            }

            status = localIoStatus.Status;

            try {

                *IoStatusBlock = localIoStatus;

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred attempting to write the caller's I/O
                // status block.  Simply change the final status of the operation
                // to the exception code.
                //

                status = GetExceptionCode();
            }

            ExFreePool( event );

        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
            ExFreePool( event );
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return status;
}

NTSTATUS
NtSetInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service changes the provided information about a specified file.  The
    information that is changed is determined by the FileInformationClass that
    is specified.  The new information is taken from the FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the information which should
        be changed on the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        changed about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus = {0};
    HANDLE targetHandle = (HANDLE) NULL;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // Ensure that the FileInformationClass parameter is legal for setting
        // information about the file.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopSetOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        //
        // Ensure that the supplied buffer is large enough to contain the
        // information associated with the specified set operation that is
        // to be performed.
        //

        if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        //
        // The caller's access mode is user, so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The FileInformation buffer must be readable by the caller.
            //

#if defined(_X86_)
            ProbeForRead( FileInformation,
                          Length,
                          Length == sizeof( BOOLEAN ) ? sizeof( BOOLEAN ) : sizeof( ULONG ) );
#elif defined(_WIN64)
            // If we are a wow64 process, follow the X86 rules
            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForRead( FileInformation,
                              Length,
                              Length == sizeof( BOOLEAN ) ? sizeof( BOOLEAN ) : sizeof( ULONG ) );
            }
            else {
                ProbeForRead( FileInformation,
                              Length,
                              IopQuerySetAlignmentRequirement[FileInformationClass] );
            }
#else
            ProbeForRead( FileInformation,
                          Length,
                          IopQuerySetAlignmentRequirement[FileInformationClass] );
#endif

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's parameters.
            // Simply return an appropriate error status code.
            //

            return GetExceptionCode();

        }

#if DBG

    } else {

        //
        // The caller's mode is kernel.  Ensure that at least the information
        // class and lengths are appropriate.
        //

        if ((ULONG) FileInformationClass >= FileMaximumInformation ||
            !IopSetOperationLength[FileInformationClass]) {
            return STATUS_INVALID_INFO_CLASS;
        }

        if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

#endif // DBG

    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        IopSetOperationAccess[FileInformationClass],
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.  If this file represents
    // a device that was opened directly, then simply use the device or its
    // attached device(s) directly.
    //

    if (!(fileObject->Flags & FO_DIRECT_DEVICE_OPEN)) {
        deviceObject = IoGetRelatedDeviceObject( fileObject );
    } else {
        deviceObject = IoGetAttachedDevice( fileObject->DeviceObject );
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to set the file position pointer information.  If so,
        // then set it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested setting the current file position
            // context information.  This is a relatively frequent call, so
            // it is optimized here to cut through the normal IRP path.
            //
            // Begin by checking to see whether the file was opened with no
            // intermediate buffering.  If so, then the file pointer must be
            // set in a manner consistent with the alignment requirement of
            // read and write operations to a non-buffered file.
            //

            PFILE_POSITION_INFORMATION fileInformation = FileInformation;
            LARGE_INTEGER currentByteOffset;

            try {

                //
                // Attempt to read the position information from the buffer.
                //

                currentByteOffset.QuadPart = fileInformation->CurrentByteOffset.QuadPart;

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return GetExceptionCode();
            }

            if ((fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING &&
                 (deviceObject->SectorSize &&
                 (currentByteOffset.LowPart &
                 (deviceObject->SectorSize - 1)))) ||
                 currentByteOffset.HighPart < 0) {

                    status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Set the current file position information.
                //

                fileObject->CurrentByteOffset.QuadPart = currentByteOffset.QuadPart;

                try {

                    //
                    // Write the I/O status block.
                    //

                    IoStatusBlock->Status = STATUS_SUCCESS;
                    IoStatusBlock->Information = 0;

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    //
                    // Writes to I/O status blocks are ignored since the
                    // operation succeeded.
                    //

                    NOTHING;

                }

            }

            //
            // Update the transfer count statistic for the current process for
            // operations other than read and write.
            //
        
            IopUpdateOtherTransferCount( Length );

            //
            // Note that the file object's event has not yet been reset,
            // so it is not necessary to set it to the Signaled state, since
            // that is it's state at this point by definition.  Therefore,
            // simply cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (event == NULL) {
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // If a link is being tracked, handle this out-of-line.
    //

    if (FileInformationClass == FileTrackingInformation) {
        status = IopTrackLink( fileObject,
                               &localIoStatus,
                               FileInformation,
                               Length,
                               synchronousIo ? &fileObject->Event : event,
                               requestorMode );
        if (NT_SUCCESS( status )) {
            try {
                IoStatusBlock->Information = 0;
                IoStatusBlock->Status = status;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                NOTHING;
            }
        }

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        } else {
            ExFreePool( event );
        }
        ObDereferenceObject( fileObject );
        return status;
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Allocate a buffer and copy the information that is to be set on the
    // file into it.  Also, set the flags so that the completion code will
    // properly handle getting rid of the buffer and will not attempt to
    // copy data.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    try {

        PVOID systemBuffer;

        systemBuffer =
        irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                                   Length );
        RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                       FileInformation,
                       Length );

        //
        //  Negative file offsets are illegal.
        //

        ASSERT((FIELD_OFFSET(FILE_END_OF_FILE_INFORMATION, EndOfFile) |
                FIELD_OFFSET(FILE_ALLOCATION_INFORMATION, AllocationSize) |
                FIELD_OFFSET(FILE_POSITION_INFORMATION, CurrentByteOffset)) == 0);

        if (((FileInformationClass == FileEndOfFileInformation) ||
             (FileInformationClass == FileAllocationInformation) ||
             (FileInformationClass == FilePositionInformation)) &&
            (((PFILE_POSITION_INFORMATION)systemBuffer)->CurrentByteOffset.HighPart < 0)) {

            ExRaiseStatus(STATUS_INVALID_PARAMETER);
        }



    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while allocating the intermediary
        // system buffer or while copying the caller's data into the
        // buffer. Cleanup and return an appropriate error status code.
        //

        IopExceptionCleanup( fileObject,
                             irp,
                             (PKEVENT) NULL,
                             event );

        return GetExceptionCode();

    }

    irp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_DEFER_IO_COMPLETION;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Update the operation count statistic for the current process for
    // operations other than read and write.
    //

    IopUpdateOtherOperationCount();


    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // to set is device independent.  If this is the case, then the request
    // can be satisfied here without having to have all of the drivers
    // implement the same code.  Note that having the IRP is still necessary
    // since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // Set the various flags in the mode field for the file object, if
        // they are reasonable.  There are 4 different invalid combinations
        // that the caller may not specify:
        //
        //     1)  An invalid flag was set in the mode field.  Not all Create/
        //         Open options may be changed.
        //
        //     2)  The caller set one of the synchronous I/O flags (alert or
        //         nonalert), but the file is not opened for synchronous I/O.
        //
        //     3)  The file is opened for synchronous I/O but the caller did
        //         not set either of the synchronous I/O flags (alert or non-
        //         alert).
        //
        //     4)  The caller set both of the synchronous I/O flags (alert and
        //         nonalert).
        //

        if ((modeBuffer->Mode & ~FILE_VALID_SET_FLAGS) ||
            ((modeBuffer->Mode & (FSIO_A | FSIO_NA)) && (!(fileObject->Flags & FO_SYNCHRONOUS_IO))) ||
            ((!(modeBuffer->Mode & (FSIO_A | FSIO_NA))) && (fileObject->Flags & FO_SYNCHRONOUS_IO)) ||
            (((modeBuffer->Mode & FSIO_A) && (modeBuffer->Mode & FSIO_NA) ))) {
            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Set or clear the appropriate flags in the file object.
            //

            if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING)) {
                if (modeBuffer->Mode & FILE_WRITE_THROUGH) {
                    fileObject->Flags |= FO_WRITE_THROUGH;
                } else {
                    fileObject->Flags &= ~FO_WRITE_THROUGH;
                }
            }

            if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
                fileObject->Flags |= FO_SEQUENTIAL_ONLY;
            } else {
                fileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
            }

            if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
                if (modeBuffer->Mode & FSIO_A) {
                    fileObject->Flags |= FO_ALERTABLE_IO;
                } else {
                    fileObject->Flags &= ~FO_ALERTABLE_IO;
                }
            }

            status = STATUS_SUCCESS;
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0L;

    } else if (FileInformationClass == FileRenameInformation ||
               FileInformationClass == FileLinkInformation ||
               FileInformationClass == FileMoveClusterInformation) {

        //
        // Note that following code depends on the fact that the rename
        // information, link information and copy-on-write information
        // structures look exactly the same.
        //

        PFILE_RENAME_INFORMATION renameBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // The information being set is a variable-length structure with
        // embedded size information.  Walk the structure to ensure that
        // it is valid so the driver does not walk off the end and incur
        // an access violation in kernel mode.
        //
 
        if (renameBuffer->FileNameLength <= 0 || (renameBuffer->FileNameLength & (sizeof(WCHAR) -1))) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;
        } else if ((ULONG) (Length - FIELD_OFFSET( FILE_RENAME_INFORMATION, FileName[0] )) < renameBuffer->FileNameLength) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        } else {

            //
            // Copy the value of the replace BOOLEAN (or the ClusterCount field)
            // from the caller's buffer to the I/O stack location parameter
            // field where it is expected by file systems.
            //

            if (FileInformationClass == FileMoveClusterInformation) {
                irpSp->Parameters.SetFile.ClusterCount =
                    ((FILE_MOVE_CLUSTER_INFORMATION *) renameBuffer)->ClusterCount;
            } else {
                irpSp->Parameters.SetFile.ReplaceIfExists = renameBuffer->ReplaceIfExists;
            }

            //
            // Check to see whether or not a fully qualified pathname was
            // supplied.  If so, then more processing is required.
            //

            if (renameBuffer->FileName[0] == (WCHAR) OBJ_NAME_PATH_SEPARATOR ||
                renameBuffer->RootDirectory) {

                //
                // A fully qualified file name was specified as the target of
                // the rename operation.  Attempt to open the target file and
                // ensure that the replacement policy for the file is consistent
                // with the caller's request, and ensure that the file is on the
                // same volume.
                //

                status = IopOpenLinkOrRenameTarget( &targetHandle,
                                                    irp,
                                                    renameBuffer,
                                                    fileObject );
                if (!NT_SUCCESS( status )) {
                    irp->IoStatus.Status = status;

                } else {

                    //
                    // The fully qualified file name specifies a file on the
                    // same volume and if it exists, then the caller specified
                    // that it should be replaced.
                    //

                    status = IoCallDriver( deviceObject, irp );

                }

            } else {

                //
                // This is a simple rename operation, so call the driver and
                // let it perform the rename operation within the same directory
                // as the source file.
                //

                status = IoCallDriver( deviceObject, irp );

            }
        }

    } else if (FileInformationClass == FileShortNameInformation) {

        PFILE_NAME_INFORMATION shortnameBuffer = irp->AssociatedIrp.SystemBuffer;

        //
        // The information being set is a variable-length structure with
        // embedded size information.  Walk the structure to ensure that
        // it is valid so the driver does not walk off the end and incur
        // an access violation in kernel mode.
        //
 
        if (shortnameBuffer->FileNameLength <= 0) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;
        } else if ((ULONG) (Length - FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] )) < shortnameBuffer->FileNameLength) {
            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        //
        // The short name must not begin with a separator character.
        //

        } else if (shortnameBuffer->FileName[0] == (WCHAR) OBJ_NAME_PATH_SEPARATOR) {

            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;

        //
        // Pass the request to the driver below.
        //

        } else {

            status = IoCallDriver( deviceObject, irp );
        }

    } else if (FileInformationClass == FileDispositionInformation) {

        PFILE_DISPOSITION_INFORMATION disposition = irp->AssociatedIrp.SystemBuffer;

        //
        // Check to see whether the disposition delete field has been set to
        // TRUE and, if so, copy the handle being used to do this to the IRP
        // stack location parameter.
        //

        if (disposition->DeleteFile) {
            irpSp->Parameters.SetFile.DeleteHandle = FileHandle;
        }

        //
        // Simply invoke the driver to perform the (un)delete operation.
        //

        status = IoCallDriver( deviceObject, irp );

    } else if (FileInformationClass == FileCompletionInformation) {

        PFILE_COMPLETION_INFORMATION completion = irp->AssociatedIrp.SystemBuffer;
        PIO_COMPLETION_CONTEXT context;
        PVOID portObject;

        //
        // It is an error if this file object already has an LPC port associated
        // with it.
        //

        if (fileObject->CompletionContext || fileObject->Flags & FO_SYNCHRONOUS_IO) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Attempt to reference the port object by its handle and convert it
            // into a pointer to the port object itself.
            //

            status = ObReferenceObjectByHandle( completion->Port,
                                                IO_COMPLETION_MODIFY_STATE,
                                                IoCompletionObjectType,
                                                requestorMode,
                                                (PVOID *) &portObject,
                                                NULL );
            if (NT_SUCCESS( status )) {

                //
                // Allocate the memory to be associated w/this file object
                //

                context = ExAllocatePoolWithTag( PagedPool,
                                                 sizeof( IO_COMPLETION_CONTEXT ),
                                                 'cCoI' );
                if (!context) {

                    ObDereferenceObject( portObject );
                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Everything was successful.  Capture the completion port
                    // and the key.
                    //

                    context->Port = portObject;
                    context->Key = completion->Key;

                    if (!InterlockedCompareExchangePointer( &fileObject->CompletionContext, context, NULL )) {

                        status = STATUS_SUCCESS;

                    } else {

                        //
                        // Someone set the completion context after the check.
                        // Simply drop everything on the floor and return an
                        // error.
                        //

                        ExFreePool( context );
                        ObDereferenceObject( portObject );
                        status = STATUS_PORT_ALREADY_SET;
                    }
                }
            }
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            status = KeWaitForSingleObject( &fileObject->Event,
                                            Executive,
                                            requestorMode,
                                            (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists so that synchronization
                // with the file object will remain intact.
                //

                IopCancelAlertedRequest( &fileObject->Event, irp );

            }

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( event,
                                            Executive,
                                            requestorMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            if (status == STATUS_ALERTED || status == STATUS_USER_APC) {

                //
                // The wait request has ended either because the thread was
                // alerted or an APC was queued to this thread, because of
                // thread rundown or CTRL/C processing.  In either case, try
                // to bail out of this I/O request carefully so that the IRP
                // completes before this routine exists or the event will not
                // be around to set to the Signaled state.
                //

                IopCancelAlertedRequest( event, irp );

            }

            status = localIoStatus.Status;

            try {

                *IoStatusBlock = localIoStatus;

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception occurred attempting to write the caller's I/O
                // status block.  Simply change the final status of the
                // operation to the exception code.
                //

                status = GetExceptionCode();
            }

            ExFreePool( event );

        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
            ExFreePool( event );
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }

    }

    //
    // If there was a target handle generated because of a rename operation,
    // close it now.
    //

    if (targetHandle) {
        ObCloseHandle( targetHandle, KernelMode );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\PNPMGR\pplastgood.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    PpLastGood.h

Abstract:

    This header exposed various routines needed for last known good processing
    in the IO subsystem.

--*/

VOID
PpLastGoodDoBootProcessing(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\write.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    write.c

Abstract:

    This module contains the code to implement the NtWriteFile system service.

--*/

#include "iomgr.h"

#pragma alloc_text(PAGE, NtWriteFile)
#pragma alloc_text(PAGE, NtWriteFileGather)

NTSTATUS
NtWriteFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    file associated with FileHandle starting at StartingBlock|ByteOffset.
    The actual number of bytes written to the file will be returned in the
    second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    Buffer - Supplies the address of the buffer containing data to be written
        to the file.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl;
    PIO_STACK_LOCATION irpSp;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    NTSTATUS exceptionCode;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceFileObjectForWrite( FileHandle,
                                            requestorMode,
                                            (PVOID *) &fileObject,
                                            &handleInformation);

    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Attempt to probe the caller's parameters within the exception
        // handler block.
        //

        exceptionCode = STATUS_SUCCESS;

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus(IoStatusBlock);

            //
            // If this is a 32-bit asynchronous IO, then mark the Iosb being sent as so.
            //

            IopMarkApcRoutineIfAsyncronousIo32(IoStatusBlock,ApcRoutine,(fileObject->Flags & FO_SYNCHRONOUS_IO));


            //
            // The caller's data buffer must be readable from the caller's
            // mode.  This check ensures that this is the case.  Since the
            // buffer address is captured, the caller cannot change it,
            // even though he/she can change the protection from another
            // thread.  This error will be caught by the probe/lock or
            // buffer copy operations later.
            //

            ProbeForRead( Buffer, Length, sizeof( UCHAR ) );

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Check that the ByteOffset parameter is readable from the
            // caller's mode, if one was specified, and capture it.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following Buffer
            // and ByteOffset parameter checks differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of the block size.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1))) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ||
                        (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it is
                // is of the proper type.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                        fileOffset.HighPart == -1) {
                        NOTHING;
                    } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                               fileOffset.HighPart == -1 &&
                               (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                        NOTHING;
                    } else if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Simply cleanup, dereference the file
            // object, and return with the appropriate status code.
            //

            ObDereferenceObject( fileObject );
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the appropriate parameters to
        // their expected locations without making all of the checks.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }
#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the Buffer is properly aligned, and that the
            // length is an integral number of the block size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1))) ||
                (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it is
            // is of the proper type.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                    fileOffset.HighPart == -1) {
                    NOTHING;
                } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                           fileOffset.HighPart == -1 &&
                           (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                    NOTHING;
                } else if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG

    }

    //
    // If the caller has only append access to the file, ignore the input
    // parameters and set the ByteOffset to indicate that this write is
    // to the end of the file.  Otherwise, ensure that the parameters are
    // valid.
    //

    if (SeComputeGrantedAccesses( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {

        //
        // This is an append operation to the end of a file.  Set the
        // ByteOffset parameter to give drivers a consistent view of
        // this type of call.
        //

        fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        fileOffset.HighPart = -1;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the fast io dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        //
        // Turbo write support.  If the file is currently cached on this
        // file object, then call the Cache Manager directly via FsRtl
        // and try to successfully complete the request here.  Note if
        // FastIoWrite returns FALSE or we get an I/O error, we simply
        // fall through and go the "long way" and create an Irp.
        //

        if (fileObject->PrivateCacheMap) {

            IO_STATUS_BLOCK localIoStatus;

            ASSERT(fastIoDispatch && fastIoDispatch->FastIoWrite);

            //
            //  Negative file offsets are illegal.
            //

            if (fileOffset.HighPart < 0 &&
                (fileOffset.HighPart != -1 ||
                fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            if (fastIoDispatch->FastIoWrite( fileObject,
                                             &fileOffset,
                                             Length,
                                             TRUE,
                                             keyValue,
                                             Buffer,
                                             &localIoStatus,
                                             deviceObject )

                    &&

                (localIoStatus.Status == STATUS_SUCCESS)) {

                IopUpdateWriteOperationCount( );
                IopUpdateWriteTransferCount( (ULONG)localIoStatus.Information );

                //
                // Carefully return the I/O status.

                try {
                    *IoStatusBlock = localIoStatus;
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    localIoStatus.Status = GetExceptionCode();
                    localIoStatus.Information = 0;
                }

                //
                // If an event was specified, set it.
                //

                if (ARGUMENT_PRESENT( Event )) {
                    KeSetEvent( eventObject, 0, FALSE );
                    ObDereferenceObject( eventObject );
                }

                //
                // Note that the file object event need not be set to the
                // Signaled state, as it is already set.
                //

                //
                // Cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return localIoStatus.Status;
            }
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function code here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) irpSp;
    *majorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer,
        // and copy the caller's data into it.  This is done using an
        // exception handler that will perform cleanup if the operation
        // fails.  Note that this is only done if the operation has a non-zero
        // length.
        //

        if (Length) {

            try {

                //
                // Allocate the intermediary system buffer from nonpaged pool,
                // charge quota for it, and copy the caller's data into it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPoolCacheAligned, Length );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer, Buffer, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer, allocating the system buffer, or copying the data
                // from the caller's buffer to the system buffer.  Determine
                // what actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

            //
            // Set the IRP_BUFFERED_IO flag in the IRP so that I/O completion
            // will know that this is not a direct I/O operation.  Also set the
            // IRP_DEALLOCATE_BUFFER flag so it will deallocate the buffer.
            //

            irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

        } else {

            //
            // This is a zero-length write.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->Flags = IRP_BUFFERED_IO;
        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

        mdl = (PMDL) NULL;
        irp->Flags = 0;

        if (Length) {

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of
                // the IRP.  Probe and lock the pages associated with the
                // caller's buffer for read access and fill in the MDL with
                // the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }

                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either allocating the MDL
                // or while attempting to probe and lock the caller's buffer.
                // Determine what actually happened, clean everything up, and
                // return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();
            }

        }

    } else {

        //
        // Pass the address of the caller's buffer to the device driver.  It
        // is now up to the driver to do everything.
        //

        irp->Flags = 0;
        irp->UserBuffer = Buffer;

    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.Key = keyValue;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        WriteTransfer );

    return status;
}

NTSTATUS
NtWriteFileGather (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PFILE_SEGMENT_ELEMENT SegmentArray,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's segment
    buffers to the file associated with FileHandle starting at
    StartingBlock|ByteOffset. The actual number of bytes written to the file
    will be returned in the second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be read from.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:
    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFILE_SEGMENT_ELEMENT capturedArray = NULL;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl;
    PIO_STACK_LOCATION irpSp;
    ACCESS_MASK grantedAccess;
    OBJECT_HANDLE_INFORMATION handleInformation;
    NTSTATUS exceptionCode;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG elementCount;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    ULONG i;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0L,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        &handleInformation);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    grantedAccess = handleInformation.GrantedAccess;

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Verify this is a valid gather write request.  In particular it must
    // be non cached, asynchronous, use completion ports, non buffer I/O
    // device and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (fileObject->Flags & FO_SYNCHRONOUS_IO) ||
        deviceObject->Flags & DO_BUFFERED_IO ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS &&
         deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME)) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES( Length );

    //
    // Check to see if the requestor mode was user.  If so, perform a bunch
    // of extra checks.
    //

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        //
        // Check to ensure that the caller has either WRITE_DATA or APPEND_DATA
        // access to the file.  If not, cleanup and return an access denied
        // error status value.  Note that if this is a pipe then the APPEND_DATA
        // access check may not be made since this access code is overlaid with
        // CREATE_PIPE_INSTANCE access.
        //

        if (!SeComputeGrantedAccesses( grantedAccess, (!(fileObject->Flags & FO_NAMED_PIPE) ? FILE_APPEND_DATA : 0) | FILE_WRITE_DATA )) {
            ObDereferenceObject( fileObject );
            return STATUS_ACCESS_DENIED;
        }

        exceptionCode = STATUS_SUCCESS;

        //
        // Attempt to probe the caller's parameters within the exception
        // handler block.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus(IoStatusBlock);

            //
            // If this is a 32-bit asynchronous IO, then mark the Iosb being sent as so.
            // Note: IopMarkApcRoutineIfAsyncronousIo32 must be called after probing
            //       the IoStatusBlock structure for write.
            //

            IopMarkApcRoutineIfAsyncronousIo32(IoStatusBlock,ApcRoutine,(fileObject->Flags & FO_SYNCHRONOUS_IO));


            //
            // The SegmentArray parameter must be accessible.
            //

#ifdef _X86_
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          sizeof( ULONG )
                          );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcess()->Wow64Process) {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              sizeof( ULONG )
                              );
            } else {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                              );
            }
#else
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                          );
#endif

            if (Length != 0) {

                //
                // Capture the segment array so it cannot be changed after
                // it has been looked at.
                //

                capturedArray = ExAllocatePoolWithQuota( PagedPool,
                                                         elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                                                         );

                RtlCopyMemory( capturedArray,
                               SegmentArray,
                               elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                               );

                SegmentArray = capturedArray;

                //
                // Verify that all the addresses are page aligned.
                //

                for (i = 0; i < elementCount; i++) {

                    if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
            }

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {

                ExRaiseStatus(STATUS_INVALID_PARAMETER);

            }

            //
            // Check that the ByteOffset parameter is readable from the
            // caller's mode, if one was specified, and capture it.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following ByteOffset
            // parameter check differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1)))) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ) {

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it is
                // is of the proper type.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                        fileOffset.HighPart == -1) {
                        NOTHING;
                    } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                               fileOffset.HighPart == -1 &&
                               (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                        NOTHING;
                    } else if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {

                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Simply cleanup, dereference the file
            // object, and return with the appropriate status code.
            //

            ObDereferenceObject( fileObject );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }

            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the appropriate parameters to
        // their expected locations without making all of the checks.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }
#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the the length is an integral number of the block
            //  size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1)))) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize)) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it is
            // is of the proper type.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (fileOffset.LowPart == FILE_WRITE_TO_END_OF_FILE &&
                    fileOffset.HighPart == -1) {
                    NOTHING;
                } else if (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
                           fileOffset.HighPart == -1 &&
                           (fileObject->Flags & FO_SYNCHRONOUS_IO)) {
                    NOTHING;
                } else if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        if (Length != 0) {

            //
            // Verify that all the addresses are page aligned.
            //

            for (i = 0; i < elementCount; i++) {

                if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {

                    ObDereferenceObject( fileObject );
                    ASSERT(FALSE);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG

    }

    //
    // If the caller has only append access to the file, ignore the input
    // parameters and set the ByteOffset to indicate that this write is
    // to the end of the file.  Otherwise, ensure that the parameters are
    // valid.
    //

    if (SeComputeGrantedAccesses( grantedAccess, FILE_APPEND_DATA | FILE_WRITE_DATA ) == FILE_APPEND_DATA) {

        //
        // This is an append operation to the end of a file.  Set the
        // ByteOffset parameter to give drivers a consistent view of
        // this type of call.
        //

        fileOffset.LowPart = FILE_WRITE_TO_END_OF_FILE;
        fileOffset.HighPart = -1;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the fast io dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                if (capturedArray != NULL) {
                    ExFreePool( capturedArray );
                }
                return status;
            }
        }

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function code here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) irpSp;
    *majorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;
    if (fileObject->Flags & FO_WRITE_THROUGH) {
        irpSp->Flags = SL_WRITE_THROUGH;
    }

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the caller's data is copied into it.  Otherwise, a Memory
    // Descriptor List (MDL) is allocated and the caller's buffer is locked
    // down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    //
    // This is a direct I/O operation.  Allocate an MDL and invoke the
    // memory management routine to lock the buffer into memory.  This
    // is done using an exception handler that will perform cleanup if
    // the operation fails.  Note that no MDL is allocated, nor is any
    // memory probed or locked if the length of the request was zero.
    //

    mdl = (PMDL) NULL;
    irp->Flags = 0;

    if (Length) {

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of
            // the IRP.  Probe and lock the pages associated with the
            // caller's buffer for write access and fill in the MDL with
            // the PFNs of those pages.
            //

            mdl = IoAllocateMdl( (PVOID) Ptr64ToPtr (SegmentArray[0].Buffer), Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            // The address of the first file segment is used as a base
            // address.
            //

            MmProbeAndLockSelectedPages( mdl,
                                         SegmentArray,
                                         requestorMode,
                                         IoReadAccess );

            irp->UserBuffer = (PVOID) Ptr64ToPtr (SegmentArray[0].Buffer);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either allocating the MDL
            // or while attempting to probe and lock the caller's buffer.
            // Determine what actually happened, clean everything up, and
            // return an appropriate error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
           return GetExceptionCode();
        }

    }

    //
    // We are done with the captured buffer.
    //

    if (capturedArray != NULL) {
        ExFreePool( capturedArray );
    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.Key = keyValue;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        requestorMode,
                                        synchronousIo,
                                        WriteTransfer );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\qsquota.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    qsquota.c

Abstract:

    This module contains the code to implement the NtQueryQuotaInformationFile
    and the NtSetQuotaInformationFile system services for the NT I/O system.

--*/

#include "iomgr.h"

#pragma alloc_text(PAGE, NtQueryQuotaInformationFile)
#pragma alloc_text(PAGE, NtSetQuotaInformationFile)

NTSTATUS
NtQueryQuotaInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in BOOLEAN ReturnSingleEntry,
    __in_bcount_opt(SidListLength) PVOID SidList,
    __in ULONG SidListLength,
    __in_opt PULONG StartSid,
    __in BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service returns quota entries associated with the volume specified
    by the FileHandle parameter.  The amount of information returned is based
    on the size of the quota information associated with the volume, the size
    of the buffer, and whether or not a specific set of entries has been
    requested.

Arguments:

    FileHandle - Supplies a handle to the file/volume for which the quota
        information is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer to receive the quota information for the volume.

    Length - Supplies the length, in bytes, of the buffer.

    ReturnSingleEntry - Indicates that only a single entry should be returned
        rather than filling the buffer with as many entries as possible.

    SidList - Optionally supplies a list of SIDs whose quota information is to
        be returned.

    SidListLength - Supplies the length of the SID list, if one was specified.

    StartSid - Supplies an optional SID that indicates that the returned
        information is to start with an entry other than the first.  This
        parameter is ignored if a SidList is specified.

    RestartScan - Indicates whether the scan of the quota information is to be
        restarted from the beginning.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{

#define ALIGN_LONG( Address ) ( (Address + 3) & ~3 )

    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT event = (PKEVENT) NULL;
    PCHAR auxiliaryBuffer = (PCHAR) NULL;
    ULONG startSidLength = 0;
    PSID startSid = (PSID) NULL;
    PFILE_GET_QUOTA_INFORMATION sidList = (PFILE_GET_QUOTA_INFORMATION) NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    UCHAR subCount;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus( IoStatusBlock );

            //
            // The buffer must be writeable by the caller.
            //

#if defined(_X86_)
            ProbeForWrite( Buffer, Length, sizeof( ULONG ) );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcessByThread(CurrentThread)->Wow64Process) {
                ProbeForWrite( Buffer, Length, sizeof( ULONG ) );
            } else {
                ProbeForWrite( Buffer, Length, sizeof( ULONGLONG ) );
            }
#else
            ProbeForWrite( Buffer, Length, sizeof( ULONGLONG ) );
#endif

            //
            // If the optional StartSid parameter was specified, then it must
            // be readable by the caller.  Begin by capturing the length of
            // the SID so that the SID itself can be captured.
            //

            if (ARGUMENT_PRESENT( StartSid )) {

                subCount = ProbeAndReadUchar( &(((SID *)(StartSid))->SubAuthorityCount) );
                startSidLength = RtlLengthRequiredSid( subCount );
                ProbeForRead( StartSid, startSidLength, sizeof( ULONG ) );
            }
            else {
                subCount = 0;
            }

            //
            // If the optional SidList parameter was specified, then it must
            // be readable by the caller.  Validate that the buffer contains
            // a legal get information structure.
            //

            if (ARGUMENT_PRESENT( SidList ) && SidListLength) {

                ProbeForRead( SidList, SidListLength, sizeof( ULONG ) );
                auxiliaryBuffer = ExAllocatePoolWithQuota( NonPagedPool,
                                                           ALIGN_LONG( SidListLength ) +
                                                           startSidLength );
                sidList = (PFILE_GET_QUOTA_INFORMATION) auxiliaryBuffer;

                RtlCopyMemory( auxiliaryBuffer, SidList, SidListLength );

            } else {

                //
                // No SidList was specified.  Check to see whether or not a
                // StartSid was specified and, if so, capture it.  Note that
                // the SID has already been probed.
                //

                SidListLength = 0;
                if (ARGUMENT_PRESENT( StartSid )) {
                    auxiliaryBuffer = ExAllocatePoolWithQuota( PagedPool,
                                                               startSidLength );
                }
            }

            //
            // If a StartSid was specified tack it onto the end of the auxiliary
            // buffer.
            //

            if (ARGUMENT_PRESENT( StartSid )) {
                startSid = (PSID) (auxiliaryBuffer + ALIGN_LONG( SidListLength ));

                RtlCopyMemory( startSid, StartSid, startSidLength );
                ((SID *) startSid)->SubAuthorityCount = subCount;
            }


        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while probing the caller's
            // parameters, allocating the pool buffer, or copying the
            // caller's EA list to the buffer.  Cleanup and return an
            // appropriate error status code.
            //

            if (auxiliaryBuffer) {
                ExFreePool( auxiliaryBuffer );
            }

            return GetExceptionCode();

        }

    } else {

        //
        // The caller's mode was KernelMode.  Simply allocate pool for the
        // SidList, if one was specified, and copy the string to it.  Also,
        // if a StartSid was specified copy it as well.
        //

        if (ARGUMENT_PRESENT( SidList ) && SidListLength) {
            sidList = SidList;
        }

        if (ARGUMENT_PRESENT( StartSid )) {
            startSid = StartSid;
        }
    }

    //
    // Always check the validity of the buffer since the server uses this 
    // routine.
    //

    if (sidList != NULL) {

        ULONG_PTR   errorOffset = 0;

        status = IopCheckGetQuotaBufferValidity( sidList,
                                                 SidListLength,
                                                 (PULONG_PTR)&errorOffset );

        if (!NT_SUCCESS( status )) {

            try {

                IoStatusBlock->Information = errorOffset;

            } except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
            }

            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }
            return status;
        }
    }

    if (startSid != NULL) {

        if (!RtlValidSid( startSid )) {
            if (auxiliaryBuffer != NULL) {
                ExFreePool( auxiliaryBuffer );
            }
            return STATUS_INVALID_SID;
        }
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        0,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        event = ExAllocatePool( NonPagedPool, sizeof( KEVENT ) );
        if (!event) {
            if (auxiliaryBuffer) {
                ExFreePool( auxiliaryBuffer );
            }
            ObDereferenceObject( fileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KeInitializeEvent( event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize, FALSE );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
            ExFreePool( event );
        }

        IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );

        if (auxiliaryBuffer) {
            ExFreePool( auxiliaryBuffer );
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->RequestorMode = requestorMode;

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserEvent = (PKEVENT) NULL;
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = event;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_QUOTA;
    irpSp->FileObject = fileObject;

    //
    // If the caller specified an SID list of names to be queried, then pass
    // the address of the intermediary buffer containing the list to the
    // driver.
    //

    irp->Tail.Overlay.AuxiliaryBuffer = auxiliaryBuffer;
    irpSp->Parameters.QueryQuota.SidList = sidList;
    irpSp->Parameters.QueryQuota.SidListLength = SidListLength;

    //
    // Now determine whether this driver expects to have data buffered
    // to it or whether it performs direct I/O.  This is based on the
    // DO_BUFFERED_IO flag in the device object.  If the flag is set,
    // then a system buffer is allocated and the driver's data will be
    // copied to it.  If the DO_DIRECT_IO flag is set in the device
    // object, then a Memory Descriptor List (MDL) is allocated and
    // the caller's buffer is locked down using it.  Finally, if the
    // driver specifies neither of the flags, then simply pass the
    // address and length of the buffer and allow the driver to perform
    // all of the checking and buffering if any is required.
    //

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The driver wishes the caller's buffered be copied into an
        // intermediary buffer.  Allocate the system buffer and specify
        // that it should be deallocated on completion.  Also indicate
        // that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception
        // handler that will perform cleanup if the operation fails.
        //

        if (Length) {
            try {

                //
                // Allocate the intermediary system buffer from nonpaged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPool, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the system buffer.
                // Determine what actually happened, clean everything
                // up, and return an appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();
            }

            //
            // Remember the address of the caller's buffer so the copy can
            // take place during I/O completion.  Also, set the flags so
            // that the completion code knows to do the copy and to deallocate
            // the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags |= (ULONG) (IRP_BUFFERED_IO |
                                   IRP_DEALLOCATE_BUFFER |
                                   IRP_INPUT_OPERATION);
        } else {
            irp->AssociatedIrp.SystemBuffer = NULL;
            irp->UserBuffer = Buffer;
        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        PMDL mdl;

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke
        // the memory management routine to lock the buffer into memory.
        // This is done using an exception handler that will perform
        // cleanup if the operation fails.
        //

        mdl = (PMDL) NULL;

        if (Length) {
            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off
                // of the IRP.  Probe and lock the pages associated with
                // the caller's buffer for write access and fill in the MDL
                // with the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (!mdl) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the
                // caller's buffer or allocating the MDL.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     (PKEVENT) NULL,
                                     event );

                if (auxiliaryBuffer) {
                    ExFreePool( auxiliaryBuffer );
                }

                return GetExceptionCode();

            }
        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access
        // to it.  It is now the driver's responsibility to do everything.
        //

        irp->UserBuffer = Buffer;

    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryQuota.Length = Length;
    irpSp->Parameters.QueryQuota.StartSid = StartSid;
    irpSp->Flags = 0;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }
    if (ReturnSingleEntry) {
        irpSp->Flags |= SL_RETURN_SINGLE_ENTRY;
    }
    if (ARGUMENT_PRESENT( StartSid )) {
        irpSp->Flags |= SL_INDEX_SPECIFIED;
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        requestorMode,
                                        synchronousIo,
                                        OtherTransfer );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               event,
                                               irp,
                                               requestorMode,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtSetQuotaInformationFile (
    __in HANDLE FileHandle,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length
    )

/*++

Routine Description:

    This service changes quota entries for the volume associated with the
    FileHandle parameter.  All of the quota entries in the specified buffer
    are applied to the volume.

Arguments:

    FileHandle - Supplies a handle to the file/volume for which the quota
        entries are to be applied.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Supplies a buffer containing the new quota entries that should
        be applied to the volume.

    Length - Supplies the length, in bytes, of the buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply return the status from the internal common routine for setting
    // EAs on a file or quotas on a volume.
    //

    return IopSetEaOrQuotaInformationFile( FileHandle,
                                           IoStatusBlock,
                                           Buffer,
                                           Length,
                                           FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\PNPMGR\ppvutil.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ppvutil.h

Abstract:

    This header exposes various utilities required to do driver verification.

--*/

#ifndef _PPVUTIL_H_
#define _PPVUTIL_H_

typedef enum {

    PPVERROR_DUPLICATE_PDO_ENUMERATED           = 0,
    PPVERROR_MISHANDLED_TARGET_DEVICE_RELATIONS,
    PPVERROR_DDI_REQUIRES_PDO

} PPVFAILURE_TYPE;

typedef enum {

    PPVREMOVAL_SHOULD_DELETE           = 0,
    PPVREMOVAL_SHOULDNT_DELETE,
    PPVREMOVAL_MAY_DEFER_DELETION

} PPVREMOVAL_OPTION;

VOID
FASTCALL
PpvUtilInit(
    VOID
    );

NTSTATUS
FASTCALL
PpvUtilCallAddDevice(
    IN  PDEVICE_OBJECT      PhysicalDeviceObject,
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDRIVER_ADD_DEVICE  AddDeviceFunction,
    IN  VF_DEVOBJ_TYPE      DevObjType
    );

VOID
FASTCALL
PpvUtilTestStartedPdoStack(
    IN  PDEVICE_OBJECT  DeviceObject
    );

PPVREMOVAL_OPTION
FASTCALL
PpvUtilGetDevnodeRemovalOption(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

VOID
FASTCALL
PpvUtilFailDriver(
    IN  PPVFAILURE_TYPE FailureType,
    IN  PVOID           CulpritAddress,
    IN  PDEVICE_OBJECT  DeviceObject    OPTIONAL,
    IN  PVOID           ExtraneousInfo  OPTIONAL
    );

BOOLEAN
FASTCALL
PpvUtilIsHardwareBeingVerified(
    IN  PDEVICE_OBJECT  PhysicalDeviceObject
    );

#endif // _PPVUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\io\iomgr\read.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    read.c

Abstract:

    This module contains the code to implement the NtReadFile system service.

--*/

#include "iomgr.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

const KPRIORITY IopCacheHitIncrement = IO_NO_INCREMENT;

#pragma alloc_text(PAGE, NtReadFile)
#pragma alloc_text(PAGE, NtReadFileScatter)

NTSTATUS
NtReadFile (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    Buffer.  If the end of the file is reached before Length bytes have
    been read, then the operation will terminate.  The actual length of
    the data read from the file will be returned in the second longword
    of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Optionally supplies an event to be signaled when the read operation
        is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Address of buffer to receive the data read from the file.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

    Key - Optionally specifies a key to be used if there are locks associated
        with the file.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS exceptionCode;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //

    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_DATA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        exceptionCode = STATUS_SUCCESS;

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus(IoStatusBlock);

            //
            // If this is a 32-bit asynchronous IO, then mark the Iosb being sent as so.
            // Note: IopMarkApcRoutineIfAsyncronousIo32 must be called after probing
            //       the IoStatusBlock structure for write.
            //

            IopMarkApcRoutineIfAsyncronousIo32(IoStatusBlock,ApcRoutine,(fileObject->Flags & FO_SYNCHRONOUS_IO));

            //
            // The caller's data buffer must be writable from the caller's
            // mode.  This check ensures that this is the case.  Since the
            // buffer address is captured, the caller cannot change it,
            // even though he/she can change the protection from another
            // thread.  This error will be caught by the probe/lock or
            // buffer copy operations later.
            //

            ProbeForWrite( Buffer, Length, sizeof( UCHAR ) );

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Also ensure that the ByteOffset parameter is readable from
            // the caller's mode and capture it if it is present.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following Buffer
            // and ByteOffset parameter checks differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1))) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize) ||
                        (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it
                // is a valid argument.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the same parameters that are
        // required from any other mode.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }

#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the Buffer is properly aligned, and that the
            // length is an integral number of the block size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1))) ||
                (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize) ||
                    (ULONG_PTR) Buffer & deviceObject->AlignmentRequirement) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it
            // is a valid argument.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the driver object's Fast I/O dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                return status;
            }
        }

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        //
        // Turbo read support.  If the file is currently cached on this
        // file object, then call the Cache Manager directly via FastIoRead
        // and try to successfully complete the request here.  Note if
        // FastIoRead returns FALSE or we get an I/O error, we simply
        // fall through and go the "long way" and create an Irp.
        //

        if (fileObject->PrivateCacheMap) {

            IO_STATUS_BLOCK localIoStatus;

            ASSERT(fastIoDispatch && fastIoDispatch->FastIoRead);

            //
            //  Negative file offsets are illegal.
            //

            if (fileOffset.HighPart < 0) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            if (fastIoDispatch->FastIoRead( fileObject,
                                            &fileOffset,
                                            Length,
                                            TRUE,
                                            keyValue,
                                            Buffer,
                                            &localIoStatus,
                                            deviceObject )

                    &&

                ((localIoStatus.Status == STATUS_SUCCESS) ||
                 (localIoStatus.Status == STATUS_BUFFER_OVERFLOW) ||
                 (localIoStatus.Status == STATUS_END_OF_FILE))) {

                //
                // Boost the priority of the current thread so that it appears
                // as if it just did I/O.  This causes background jobs that
                // get cache hits to be more responsive in terms of getting
                // more CPU time.
                //

                if (IopCacheHitIncrement) {
                    KeBoostPriorityThread( &CurrentThread->Tcb,
                                           IopCacheHitIncrement );
                }

                //
                // Carefully return the I/O status.
                //

                IopUpdateReadOperationCount( );
                IopUpdateReadTransferCount( (ULONG)localIoStatus.Information );

                try {
                    *IoStatusBlock = localIoStatus;
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    localIoStatus.Status = GetExceptionCode();
                    localIoStatus.Information = 0;
                }

                //
                // If an event was specified, set it.
                //

                if (ARGUMENT_PRESENT( Event )) {
                    KeSetEvent( eventObject, 0, FALSE );
                    ObDereferenceObject( eventObject );
                }

                //
                // Note that the file object event need not be set to the
                // Signaled state, as it is already set.
                //

                //
                // Cleanup and return.
                //

                IopReleaseFileObjectLock( fileObject );
                ObDereferenceObject( fileObject );

                return localIoStatus.Status;
            }
        }
        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether this device expects to have data buffered to it
    // or whether it performs direct I/O.  This is based on the DO_BUFFERED_IO
    // flag in the device object.  If the flag is set, then a system buffer is
    // allocated and the driver's data will be copied into it.  Otherwise, a
    // Memory Descriptor List (MDL) is allocated and the caller's buffer is
    // locked down using it.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;

    if (deviceObject->Flags & DO_BUFFERED_IO) {

        //
        // The device does not support direct I/O.  Allocate a system buffer
        // and specify that it should be deallocated on completion.  Also
        // indicate that this is an input operation so the data will be copied
        // into the caller's buffer.  This is done using an exception handler
        // that will perform cleanup if the operation fails.  Note that this
        // is only done if the operation has a non-zero length.
        //

        if (Length) {

            try {

                //
                // Allocate the intermediary system buffer from nonpaged pool
                // and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithQuota( NonPagedPoolCacheAligned, Length );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the system buffer.  Determine what
                // actually happened, clean everything up, and return an
                // appropriate error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

            //
            // Remember the address of the caller's buffer so the copy can take
            // place during I/O completion.  Also, set the flags so that the
            // completion code knows to do the copy and to deallocate the buffer.
            //

            irp->UserBuffer = Buffer;
            irp->Flags = IRP_BUFFERED_IO |
                         IRP_DEALLOCATE_BUFFER |
                         IRP_INPUT_OPERATION;

        } else {

            //
            // This is a zero-length read.  Simply indicate that this is
            // buffered I/O, and pass along the request.  The buffer will
            // not be set to deallocate so the completion path does not
            // have to special-case the length.
            //

            irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;

        }

    } else if (deviceObject->Flags & DO_DIRECT_IO) {

        //
        // This is a direct I/O operation.  Allocate an MDL and invoke the
        // memory management routine to lock the buffer into memory.  This
        // is done using an exception handler that will perform cleanup if
        // the operation fails.  Note that no MDL is allocated, nor is any
        // memory probed or locked if the length of the request was zero.
        //

        PMDL mdl;

        irp->Flags = 0;

        if (Length) {

            try {

                //
                // Allocate an MDL, charging quota for it, and hang it off of
                // the IRP.  Probe and lock the pages associated with the
                // caller's buffer for write access and fill in the MDL with
                // the PFNs of those pages.
                //

                mdl = IoAllocateMdl( Buffer, Length, FALSE, TRUE, irp );
                if (mdl == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( mdl, requestorMode, IoWriteAccess );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // An exception was incurred while either probing the caller's
                // buffer or allocating the MDL.  Determine what actually
                // happened, clean everything up, and return an appropriate
                // error status code.
                //

                IopExceptionCleanup( fileObject,
                                     irp,
                                     eventObject,
                                     (PKEVENT) NULL );

                return GetExceptionCode();

            }

        }

    } else {

        //
        // Pass the address of the user's buffer so the driver has access to
        // it.  It is now the driver's responsibility to do everything.
        //

        irp->Flags = 0;
        irp->UserBuffer = Buffer;
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.Key = keyValue;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         requestorMode,
                                         synchronousIo,
                                         ReadTransfer );

    return status;
}

NTSTATUS
NtReadFileScatter (
    __in HANDLE FileHandle,
    __in_opt HANDLE Event,
    __in_opt PIO_APC_ROUTINE ApcRoutine,
    __in_opt PVOID ApcContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in PFILE_SEGMENT_ELEMENT SegmentArray,
    __in ULONG Length,
    __in_opt PLARGE_INTEGER ByteOffset,
    __in_opt PULONG Key
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    buffer segments.  The buffer segments are not virtually contiguous,
    but are 8 KB in length and alignment. If the end of the file is reached
    before Length bytes have been read, then the operation will terminate.
    The actual length of the data read from the file will be returned in
    the second longword of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Unused the I/O must use a completion port.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be placed.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

    Key - Unused.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:

    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PFILE_SEGMENT_ELEMENT capturedArray = NULL;
    KPROCESSOR_MODE requestorMode;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS exceptionCode;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG keyValue = 0;
    ULONG elementCount;
    LARGE_INTEGER fileOffset = {0,0};
    PULONG majorFunction;
    ULONG i;
    BOOLEAN synchronousIo;
    PETHREAD CurrentThread;

    PAGED_CODE();

    //
    // Get the previous mode;  i.e., the mode of the caller.
    //
    CurrentThread = PsGetCurrentThread ();
    requestorMode = KeGetPreviousModeByThread(&CurrentThread->Tcb);

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        FILE_READ_DATA,
                                        IoFileObjectType,
                                        requestorMode,
                                        (PVOID *) &fileObject,
                                        NULL );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = IoGetRelatedDeviceObject( fileObject );

    //
    // Verify this is a valid scatter read request.  In particular it must be
    // non cached, asynchronous, use completion ports, non buffer I/O device
    // and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (fileObject->Flags & FO_SYNCHRONOUS_IO) ||
        deviceObject->Flags & DO_BUFFERED_IO ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS &&
         deviceObject->DeviceType != FILE_DEVICE_TAPE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_NETWORK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_DFS_VOLUME )) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES(Length);

    if (requestorMode != KernelMode) {

        //
        // The caller's access mode is not kernel so probe each of the arguments
        // and capture them as necessary.  If any failures occur, the condition
        // handler will be invoked to handle them.  It will simply cleanup and
        // return an access violation status code back to the system service
        // dispatcher.
        //

        exceptionCode = STATUS_SUCCESS;

        try {

            //
            // The IoStatusBlock parameter must be writeable by the caller.
            //

            ProbeForWriteIoStatus(IoStatusBlock);

            //
            // If this is a 32-bit asynchronous IO, then mark the Iosb being sent as so.
            // Note: IopMarkApcRoutineIfAsyncronousIo32 must be called after probing
            //       the IoStatusBlock structure for write.
            //

            IopMarkApcRoutineIfAsyncronousIo32(IoStatusBlock,ApcRoutine,(fileObject->Flags & FO_SYNCHRONOUS_IO));

            //
            // If this file has an I/O completion port associated w/it, then
            // ensure that the caller did not supply an APC routine, as the
            // two are mutually exclusive methods for I/O completion
            // notification.
            //

            if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
                ObDereferenceObject( fileObject );
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Also ensure that the ByteOffset parameter is readable from
            // the caller's mode and capture it if it is present.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                ProbeForReadSmallStructure( ByteOffset,
                                            sizeof( LARGE_INTEGER ),
                                            sizeof( ULONG ) );
                fileOffset = *ByteOffset;
            }

            //
            // Check to see whether the caller has opened the file without
            // intermediate buffering.  If so, perform the following ByteOffset
            // parameter check differently.
            //

            if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

                //
                // The file was opened without intermediate buffering enabled.
                // Check that the Buffer is properly aligned, and that the
                // length is an integral number of 512-byte blocks.
                //

                if ((deviceObject->SectorSize &&
                    (Length & (deviceObject->SectorSize - 1)))) {

                    //
                    // Check for sector sizes that are not a power of two.
                    //

                    if ((deviceObject->SectorSize &&
                        Length % deviceObject->SectorSize)) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }

                //
                // If a ByteOffset parameter was specified, ensure that it
                // is a valid argument.
                //

                if (ARGUMENT_PRESENT( ByteOffset )) {
                    if (deviceObject->SectorSize &&
                        (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                        ObDereferenceObject( fileObject );
                        return STATUS_INVALID_PARAMETER;
                    }
                }
            }

            //
            // The SegmentArray parameter must be accessible.
            //

#ifdef _X86_
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          sizeof( ULONG )
                          );
#elif defined(_WIN64)

            //
            // If we are a wow64 process, follow the X86 rules
            //

            if (PsGetCurrentProcess()->Wow64Process) {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              sizeof( ULONG )
                              );
            } else {
                ProbeForRead( SegmentArray,
                              elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                              TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                              );
            }
#else
            ProbeForRead( SegmentArray,
                          elementCount * sizeof( FILE_SEGMENT_ELEMENT ),
                          TYPE_ALIGNMENT( FILE_SEGMENT_ELEMENT )
                          );
#endif

            if (Length != 0) {

                //
                // Capture the segment array so it cannot be changed after
                // it has been looked at.
                //

                capturedArray = ExAllocatePoolWithQuota( PagedPool,
                                                elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                                                );

                RtlCopyMemory( capturedArray,
                               SegmentArray,
                               elementCount * sizeof( FILE_SEGMENT_ELEMENT )
                               );

                SegmentArray = capturedArray;

                //
                // Verify that all the addresses are page aligned.
                //

                for (i = 0; i < elementCount; i++) {

                    if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }
                }
            }

            //
            // Finally, ensure that if there is a key parameter specified it
            // is readable by the caller.
            //

            if (ARGUMENT_PRESENT( Key )) {
                keyValue = ProbeAndReadUlong( Key );
            }

        } except(IopExceptionFilter( GetExceptionInformation(), &exceptionCode )) {

            //
            // An exception was incurred while attempting to probe the
            // caller's parameters.  Dereference the file object and return
            // an appropriate error status code.
            //

            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return exceptionCode;

        }

    } else {

        //
        // The caller's mode is kernel.  Get the same parameters that are
        // required from any other mode.
        //

        if (ARGUMENT_PRESENT( ByteOffset )) {
            fileOffset = *ByteOffset;
        }

        if (ARGUMENT_PRESENT( Key )) {
            keyValue = *Key;
        }

#if DBG
        if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {

            //
            // The file was opened without intermediate buffering enabled.
            // Check that the the length is an integral number of the block
            //  size.
            //

            if ((deviceObject->SectorSize &&
                (Length & (deviceObject->SectorSize - 1)))) {

                //
                // Check for sector sizes that are not a power of two.
                //

                if ((deviceObject->SectorSize &&
                    Length % deviceObject->SectorSize)) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }

            //
            // If a ByteOffset parameter was specified, ensure that it
            // is a valid argument.
            //

            if (ARGUMENT_PRESENT( ByteOffset )) {
                if (deviceObject->SectorSize &&
                    (fileOffset.LowPart & (deviceObject->SectorSize - 1))) {
                    ObDereferenceObject( fileObject );
                    ASSERT( FALSE );
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }

        if (Length != 0) {

            //
            // Verify that all the addresses are page aligned.
            //

            for (i = 0; i < elementCount; i++) {

                if ( SegmentArray[i].Alignment & (PAGE_SIZE - 1)) {

                    ObDereferenceObject( fileObject );
                    ASSERT(FALSE);
                    return STATUS_INVALID_PARAMETER;
                }
            }
        }
#endif // DBG
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            EVENT_MODIFY_STATE,
                                            ExEventObjectType,
                                            requestorMode,
                                            (PVOID *) &eventObject,
                                            NULL );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Get the address of the driver object's Fast I/O dispatch structure.
    //

    fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        BOOLEAN interrupted;

        if (!IopAcquireFastLock( fileObject )) {
            status = IopAcquireFileObjectLock( fileObject,
                                               requestorMode,
                                               (BOOLEAN) ((fileObject->Flags & FO_ALERTABLE_IO) != 0),
                                               &interrupted );
            if (interrupted) {
                if (eventObject) {
                    ObDereferenceObject( eventObject );
                }
                ObDereferenceObject( fileObject );
                if (capturedArray != NULL) {
                    ExFreePool( capturedArray );
                }
                return status;
            }
        }

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset ) && !(fileObject->Flags & (FO_NAMED_PIPE | FO_MAILSLOT))) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IopAllocateIrp( deviceObject->StackSize, !synchronousIo );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        IopAllocateIrpCleanup( fileObject, eventObject );

        if (capturedArray != NULL) {
            ExFreePool( capturedArray );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = CurrentThread;
    irp->Tail.Overlay.AuxiliaryBuffer = (PVOID) NULL;
    irp->RequestorMode = requestorMode;
    irp->PendingReturned = FALSE;
    irp->Cancel = FALSE;
    irp->CancelRoutine = (PDRIVER_CANCEL) NULL;

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.  Note that
    // setting the major function here also sets:
    //
    //      MinorFunction = 0;
    //      Flags = 0;
    //      Control = 0;
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    majorFunction = (PULONG) (&irpSp->MajorFunction);
    *majorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Always allocate a Memory Descriptor List (MDL) and lock down the
    // caller's buffer. This way the file system do not have change to
    // build a scatter MDL. Note buffered I/O is not supported for this
    // routine.
    //

    irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;
    irp->MdlAddress = (PMDL) NULL;


    //
    // This is a direct I/O operation.  Allocate an MDL and invoke the
    // memory management routine to lock the buffer into memory.  This
    // is done using an exception handler that will perform cleanup if
    // the operation fails.  Note that no MDL is allocated, nor is any
    // memory probed or locked if the length of the request was zero.
    //

    irp->Flags = 0;

    if (Length) {

        PMDL mdl;

        try {

            //
            // Allocate an MDL, charging quota for it, and hang it off of
            // the IRP.  Probe and lock the pages associated with the
            // caller's buffer for write access and fill in the MDL with
            // the PFNs of those pages.
            //

            mdl = IoAllocateMdl( (PVOID) Ptr64ToPtr (SegmentArray[0].Buffer), Length, FALSE, TRUE, irp );
            if (mdl == NULL) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            //
            // The address of the first file segment is used as a base
            // address.
            //

            MmProbeAndLockSelectedPages( mdl,
                                         SegmentArray,
                                         requestorMode,
                                         IoWriteAccess );

            irp->UserBuffer = (PVOID) Ptr64ToPtr (SegmentArray[0].Buffer);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // An exception was incurred while either probing the caller's
            // buffer or allocating the MDL.  Determine what actually
            // happened, clean everything up, and return an appropriate
            // error status code.
            //

            IopExceptionCleanup( fileObject,
                                 irp,
                                 eventObject,
                                 (PKEVENT) NULL );

            if (capturedArray != NULL) {
                ExFreePool( capturedArray );
            }
            return GetExceptionCode();

        }

    }

    //
    // We are done with the captured buffer.
    //

    if (capturedArray != NULL) {
        ExFreePool( capturedArray );
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.Key = keyValue;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         requestorMode,
                                         synchronousIo,
                                         ReadTransfer );

    return status;

}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\apcobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    apcobj.c

Abstract:

    This module implements the kernel APC object. Functions are provided
    to initialize, flush, insert, and remove APC objects.

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input apc is
// really a kapc and not something else, like deallocated pool.
//

#define ASSERT_APC(E) ASSERT((E)->Type == ApcObject)

VOID
KeInitializeApc (
    __out PRKAPC Apc,
    __in PRKTHREAD Thread,
    __in KAPC_ENVIRONMENT Environment,
    __in PKKERNEL_ROUTINE KernelRoutine,
    __in_opt PKRUNDOWN_ROUTINE RundownRoutine,
    __in_opt PKNORMAL_ROUTINE NormalRoutine,
    __in_opt KPROCESSOR_MODE ApcMode,
    __in_opt PVOID NormalContext
    )

/*++

Routine Description:

    This function initializes a kernel APC object. The thread, kernel
    routine, and optionally a normal routine, processor mode, and normal
    context parameter are stored in the APC object.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Environment - Supplies the environment in which the APC will execute.
        Valid values for this parameter are: OriginalApcEnvironment,
        AttachedApcEnvironment, CurrentApcEnvironment, or InsertApcEnvironment

    KernelRoutine - Supplies a pointer to a function that is to be
        executed at IRQL APC_LEVEL in kernel mode.

    RundownRoutine - Supplies an optional pointer to a function that is to be
        called if the APC is in a thread's APC queue when the thread terminates.

    NormalRoutine - Supplies an optional pointer to a function that is
        to be executed at IRQL 0 in the specified processor mode. If this
        parameter is not specified, then the ProcessorMode and NormalContext
        parameters are ignored.

    ApcMode - Supplies the processor mode in which the function specified
        by the NormalRoutine parameter is to be executed.

    NormalContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the NormalRoutine parameter.

Return Value:

    None.

--*/

{

    ASSERT(Environment <= InsertApcEnvironment);

    //
    // Initialize standard control object header.
    //

    Apc->Type = ApcObject;
    Apc->Size = sizeof(KAPC);

    //
    // Initialize the APC environment, thread address, kernel routine address,
    // rundown routine address, normal routine address, processor mode, and
    // normal context parameter. If the normal routine address is null, then
    // the processor mode is defaulted to KernelMode and the APC is a special
    // APC. Otherwise, the processor mode is taken from the argument list.
    //

    if (Environment == CurrentApcEnvironment) {
        Apc->ApcStateIndex = Thread->ApcStateIndex;

    } else {

        ASSERT((Environment <= Thread->ApcStateIndex) || (Environment == InsertApcEnvironment));

        Apc->ApcStateIndex = (CCHAR)Environment;
    }

    Apc->Thread = Thread;
    Apc->KernelRoutine = KernelRoutine;
    Apc->RundownRoutine = RundownRoutine;
    Apc->NormalRoutine = NormalRoutine;
    if (ARGUMENT_PRESENT(NormalRoutine)) {
        Apc->ApcMode = ApcMode;
        Apc->NormalContext = NormalContext;

    } else {
        Apc->ApcMode = KernelMode;
        Apc->NormalContext = NIL;
    }

    Apc->Inserted = FALSE;
    return;
}

PLIST_ENTRY
KeFlushQueueApc (
    __inout PKTHREAD Thread,
    __in KPROCESSOR_MODE ApcMode
    )

/*++

Routine Description:

    This function flushes the APC queue selected by the specified processor
    mode for the specified thread. An APC queue is flushed by removing the
    listhead from the list, scanning the APC entries in the list, setting
    their inserted variables to FALSE, and then returning the address of the
    doubly linked list as the function value.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    ApcMode - Supplies the processor mode of the APC queue that is to
        be flushed.

Return Value:

    The address of the first entry in the list of APC objects that were flushed
    from the specified APC queue.

--*/

{

    PKAPC Apc;
    PLIST_ENTRY FirstEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the APC mode is user mode, then acquire the thread APC queue lock
    // to ensure that no further APCs are queued after a possible setting of
    // the thread APC queueable state.
    //

    if (ApcMode == UserMode) {
        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
        if (IsListEmpty(&Thread->ApcState.ApcListHead[ApcMode])) {
            KeReleaseInStackQueuedSpinLock(&LockHandle);
            return NULL;
        }

    } else {
        if (IsListEmpty(&Thread->ApcState.ApcListHead[ApcMode])) {
            return NULL;

        } else {
            KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
        }
    }

    //
    // Get address of first APC in the list and check if the list is
    // empty or contains entries that should be flushed. If entries
    // should be flushed, then scan the list of APC objects and set their
    // inserted state to FALSE.
    //

    FirstEntry = Thread->ApcState.ApcListHead[ApcMode].Flink;
    if (FirstEntry == &Thread->ApcState.ApcListHead[ApcMode]) {
        FirstEntry = (PLIST_ENTRY)NULL;

    } else {
        RemoveEntryList(&Thread->ApcState.ApcListHead[ApcMode]);
        NextEntry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            Apc->Inserted = FALSE;
            NextEntry = NextEntry->Flink;
        } while (NextEntry != FirstEntry);

        //
        // Reinitialize the header so the current thread may safely attach
        // to another process.
        //

        InitializeListHead(&Thread->ApcState.ApcListHead[ApcMode]);
    }

    //
    // Unlock the thread APC queue lock, lower IRQL to its previous value,
    // and return address of the first entry in list of APC objects that
    // were flushed.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return FirstEntry;
}

BOOLEAN
KeInsertQueueApc (
    __inout PRKAPC Apc,
    __in_opt PVOID SystemArgument1,
    __in_opt PVOID SystemArgument2,
    __in KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into the APC queue specifed by the
    thread and processor mode fields of the APC object. If the APC object
    is already in an APC queue or APC queuing is disabled, then no operation
    is performed. Otherwise the APC object is inserted in the specified queue
    and appropriate scheduling decisions are made.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    SystemArgument1, SystemArgument2 - Supply a set of two arguments that
        contain untyped data provided by the executive.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    If the APC object is already in an APC queue or APC queuing is disabled,
    then a value of FALSE is returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the thread APC queue lock.
    //

    Thread = Apc->Thread;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);

    //
    // If APC queuing is disabled or the APC is already inserted, then set
    // inserted to FALSE. Otherwise, set the system  parameter values in the
    // APC object, insert the APC in the thread APC queue, and set inserted to
    // true.
    //

    if ((Thread->ApcQueueable == FALSE) ||
        (Apc->Inserted == TRUE)) {
        Inserted = FALSE;

    } else {
        Apc->Inserted = TRUE;
        Apc->SystemArgument1 = SystemArgument1;
        Apc->SystemArgument2 = SystemArgument2;
        KiInsertQueueApc(Apc, Increment);
        Inserted = TRUE;
    }

    //
    // Unlock the thread APC queue lock, exit the scheduler, and return
    // whether the APC was inserted.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return Inserted;
}

BOOLEAN
KeRemoveQueueApc (
    __inout PKAPC Apc
    )

/*++

Routine Description:

    This function removes an APC object from an APC queue. If the APC object
    is not in an APC queue, then no operation is performed. Otherwise the
    APC object is removed from its current queue and its inserted state is
    set FALSE.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

Return Value:

    If the APC object is not in an APC queue, then a value of FALSE is returned.
    Otherwise a value of TRUE is returned.

--*/

{

    PKAPC_STATE ApcState;
    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the thread APC queue lock.
    //

    Thread = Apc->Thread;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);

    //
    // If the APC object is in an APC queue, then remove it from the queue
    // and set its inserted state to FALSE. If the queue becomes empty, set
    // the APC pending state to FALSE.
    //

    Inserted = Apc->Inserted;
    if (Inserted != FALSE) {
        Apc->Inserted = FALSE;
        ApcState = Thread->ApcStatePointer[Apc->ApcStateIndex];
        KiLockDispatcherDatabaseAtSynchLevel();
        if (RemoveEntryList(&Apc->ApcListEntry) != FALSE) {
            if (Apc->ApcMode == KernelMode) {
                ApcState->KernelApcPending = FALSE;

            } else {
                ApcState->UserApcPending = FALSE;
            }
        }

        KiUnlockDispatcherDatabaseFromSynchLevel();
    }

    //
    // Release the thread APC queue lock, lower IRQL to its previous value,
    // and return whether an APC object was removed from the APC queue.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\apcsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    apcsup.c

Abstract:

    This module contains the support routines for the APC object. Functions
    are provided to insert in an APC queue and to deliver user and kernel
    mode APC's.

--*/

#include "ki.h"

VOID
KiCheckForKernelApcDelivery (
    VOID
    )

/*++

Routine Description:

    This function checks to detemine if a kernel APC can be delivered
    immediately to the current thread or a kernel APC interrupt should
    be requested. On entry to this routine the following conditions are
    true:

    1. Special kernel APCs are enabled for the current thread.

    2. Normal kernel APCs may also be enabled for the current thread.

    3. The kernel APC queue is not empty.

    N.B. This routine is only called by kernel code that leaves a guarded
         or critcial region.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // If the current IRQL is passive level, then a kernel APC can be
    // delivered immediately. Otherwise, an APC interrupt must be
    // requested.
    //

    if (KeGetCurrentIrql() == PASSIVE_LEVEL) {
        KfRaiseIrql(APC_LEVEL);
        KiDeliverApc(KernelMode, NULL, NULL);
        KeLowerIrql(PASSIVE_LEVEL);

    } else {
        KeGetCurrentThread()->ApcState.KernelApcPending = TRUE;                 
        KiRequestSoftwareInterrupt(APC_LEVEL);                      
    }

    return;
}

VOID
KiDeliverApc (
    IN KPROCESSOR_MODE PreviousMode,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called from the APC interrupt code and when one or
    more of the APC pending flags are set at system exit and the previous
    IRQL is zero. All special kernel APC's are delivered first, followed
    by normal kernel APC's if one is not already in progress, and finally
    if the user APC queue is not empty, the user APC pending flag is set,
    and the previous mode is user, then a user APC is delivered. On entry
    to this routine IRQL is set to APC_LEVEL.

    N.B. The exception frame and trap frame addresses are only guaranteed
         to be valid if, and only if, the previous mode is user.

Arguments:

    PreviousMode - Supplies the previous processor mode.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{

    PKAPC Apc;
    PKKERNEL_ROUTINE KernelRoutine;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PVOID NormalContext;
    PKNORMAL_ROUTINE NormalRoutine;
    PKTRAP_FRAME OldTrapFrame;
    PKPROCESS Process;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PKTHREAD Thread;

    //
    // If the thread was interrupted in the middle of the SLIST pop code,
    // then back up the PC to the start of the SLIST pop. 
    //

    if (TrapFrame != NULL) {
        KiCheckForSListAddress(TrapFrame);
    }

    //
    // Save the current thread trap frame address and set the thread trap
    // frame address to the new trap frame. This will prevent a user mode
    // exception from being raised within an APC routine.
    //

    Thread = KeGetCurrentThread();
    OldTrapFrame = Thread->TrapFrame;
    Thread->TrapFrame = TrapFrame;

    //
    // If special APC are not disabled, then attempt to deliver one or more
    // APCs.
    //

    Process = Thread->ApcState.Process;
    Thread->ApcState.KernelApcPending = FALSE;
    if (Thread->SpecialApcDisable == 0) {

        //
        // If the kernel APC queue is not empty, then attempt to deliver a
        // kernel APC.
        //
        // N.B. The following test is not synchronized with the APC insertion
        //      code. However, when an APC is inserted in the kernel queue of
        //      a running thread an APC interrupt is requested. Therefore, if
        //      the following test were to falsely return that the kernel APC
        //      queue was empty, an APC interrupt would immediately cause this
        //      code to be executed a second time in which case the kernel APC
        //      queue would found to contain an entry.
        //

        KeMemoryBarrier();
        while (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {

            //
            // Raise IRQL to dispatcher level, lock the APC queue, and check
            // if any kernel mode APC's can be delivered.
            //
            // If the kernel APC queue is now empty because of the removal of
            // one or more entries, then release the APC lock, and attempt to
            // deliver a user APC.
            //

            KeAcquireInStackQueuedSpinLock(&Thread->ApcQueueLock, &LockHandle);
            NextEntry = Thread->ApcState.ApcListHead[KernelMode].Flink;
            if (NextEntry == &Thread->ApcState.ApcListHead[KernelMode]) {
                KeReleaseInStackQueuedSpinLock(&LockHandle);
                break;
            }

            //
            // Clear kernel APC pending, get the address of the APC object,
            // and determine the type of APC.
            //
            // N.B. Kernel APC pending must be cleared each time the kernel
            //      APC queue is found to be non-empty.
            //

            Thread->ApcState.KernelApcPending = FALSE;
            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            ReadForWriteAccess(Apc);
            KernelRoutine = Apc->KernelRoutine;
            NormalRoutine = Apc->NormalRoutine;
            NormalContext = Apc->NormalContext;
            SystemArgument1 = Apc->SystemArgument1;
            SystemArgument2 = Apc->SystemArgument2;
            if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) {
    
                //
                // First entry in the kernel APC queue is a special kernel APC.
                // Remove the entry from the APC queue, set its inserted state
                // to FALSE, release dispatcher database lock, and call the kernel
                // routine. On return raise IRQL to dispatcher level and lock
                // dispatcher database lock.
                //
    
                RemoveEntryList(NextEntry);
                Apc->Inserted = FALSE;
                KeReleaseInStackQueuedSpinLock(&LockHandle);
                (KernelRoutine)(Apc,
                                &NormalRoutine,
                                &NormalContext,
                                &SystemArgument1,
                                &SystemArgument2);
    
#if DBG
    
                if (KeGetCurrentIrql() != LockHandle.OldIrql) {
                    KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                                 KeGetCurrentIrql() << 16 | LockHandle.OldIrql << 8,
                                 (ULONG_PTR)KernelRoutine,
                                 (ULONG_PTR)Apc,
                                 (ULONG_PTR)NormalRoutine);
                }
    
#endif

            } else {
    
                //
                // First entry in the kernel APC queue is a normal kernel APC.
                // If there is not a normal kernel APC in progress and kernel
                // APC's are not disabled, then remove the entry from the APC
                // queue, set its inserted state to FALSE, release the APC queue
                // lock, call the specified kernel routine, set kernel APC in
                // progress, lower the IRQL to zero, and call the normal kernel
                // APC routine. On return raise IRQL to dispatcher level, lock
                // the APC queue, and clear kernel APC in progress.
                //
    
                if ((Thread->ApcState.KernelApcInProgress == FALSE) &&
                   (Thread->KernelApcDisable == 0)) {

                    RemoveEntryList(NextEntry);
                    Apc->Inserted = FALSE;
                    KeReleaseInStackQueuedSpinLock(&LockHandle);
                    (KernelRoutine)(Apc,
                                    &NormalRoutine,
                                    &NormalContext,
                                    &SystemArgument1,
                                    &SystemArgument2);
    
#if DBG
    
                    if (KeGetCurrentIrql() != LockHandle.OldIrql) {
                        KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                                     KeGetCurrentIrql() << 16 | LockHandle.OldIrql << 8 | 1,
                                     (ULONG_PTR)KernelRoutine,
                                     (ULONG_PTR)Apc,
                                     (ULONG_PTR)NormalRoutine);
                    }
    
#endif
    
                    if (NormalRoutine != (PKNORMAL_ROUTINE)NULL) {
                        Thread->ApcState.KernelApcInProgress = TRUE;
                        KeLowerIrql(0);
                        (NormalRoutine)(NormalContext,
                                        SystemArgument1,
                                        SystemArgument2);
    
                        KeRaiseIrql(APC_LEVEL, &LockHandle.OldIrql);
                    }
    
                    Thread->ApcState.KernelApcInProgress = FALSE;
    
                } else {
                    KeReleaseInStackQueuedSpinLock(&LockHandle);
                    goto CheckProcess;
                }
            }
        }

        //
        // Kernel APC queue is empty. If the previous mode is user, user APC
        // pending is set, and the user APC queue is not empty, then remove
        // the first entry from the user APC queue, set its inserted state to
        // FALSE, clear user APC pending, release the dispatcher database lock,
        // and call the specified kernel routine. If the normal routine address
        // is not NULL on return from the kernel routine, then initialize the
        // user mode APC context and return. Otherwise, check to determine if
        // another user mode APC can be processed.
        //
        // N.B. There is no race condition associated with checking the APC
        //      queue outside the APC lock. User APCs are always delivered at
        //      system exit and never interrupt the execution of the thread
        //      in the kernel.
        //
    
        if ((PreviousMode == UserMode) &&
            (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE) &&
            (Thread->ApcState.UserApcPending != FALSE)) {

            //
            // Raise IRQL to dispatcher level, lock the APC queue, and deliver
            // a user mode APC.
            //

            KeAcquireInStackQueuedSpinLock(&Thread->ApcQueueLock, &LockHandle);

            //
            // If the user APC queue is now empty because of the removal of
            // one or more entries, then release the APC lock and exit.
            //

            Thread->ApcState.UserApcPending = FALSE;
            NextEntry = Thread->ApcState.ApcListHead[UserMode].Flink;
            if (NextEntry == &Thread->ApcState.ApcListHead[UserMode]) {
                KeReleaseInStackQueuedSpinLock(&LockHandle);
                goto CheckProcess;
            }

            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            ReadForWriteAccess(Apc);
            KernelRoutine = Apc->KernelRoutine;
            NormalRoutine = Apc->NormalRoutine;
            NormalContext = Apc->NormalContext;
            SystemArgument1 = Apc->SystemArgument1;
            SystemArgument2 = Apc->SystemArgument2;
            RemoveEntryList(NextEntry);
            Apc->Inserted = FALSE;
            KeReleaseInStackQueuedSpinLock(&LockHandle);
            (KernelRoutine)(Apc,
                            &NormalRoutine,
                            &NormalContext,
                            &SystemArgument1,
                            &SystemArgument2);
    
            if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) {
                KeTestAlertThread(UserMode);
    
            } else {
                KiInitializeUserApc(ExceptionFrame,
                                    TrapFrame,
                                    NormalRoutine,
                                    NormalContext,
                                    SystemArgument1,
                                    SystemArgument2);
            }
        }
    }

    //
    // Check if process was attached during the APC routine.
    //

CheckProcess:
    if (Thread->ApcState.Process != Process) {
        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                     (ULONG_PTR)Process,
                     (ULONG_PTR)Thread->ApcState.Process,
                     (ULONG)Thread->ApcStateIndex,
                     (ULONG)KeIsExecutingDpc());
    }

    //
    // Restore the previous thread trap frame address.
    //

    Thread->TrapFrame = OldTrapFrame;
    return;
}

VOID
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into a thread's APC queue. The address
    of the thread object, the APC queue, and the type of APC are all derived
    from the APC object. If the APC object is already in an APC queue, then
    no operation is performed and a function value of FALSE is returned. Else
    the APC is inserted in the specified APC queue, its inserted state is set
    to TRUE, and a function value of TRUE is returned. The APC will actually
    be delivered when proper enabling conditions exist.

    N.B. The thread APC queue lock must be held when this routine is called.

    N.B. It is the responsibility of the caller to ensure that the APC is not
         already inserted in an APC queue and to set the Inserted field of
         the APC.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    None.

--*/

{

    KPROCESSOR_MODE ApcMode;
    PKAPC ApcEntry;
    PKAPC_STATE ApcState;
    PKGATE GateObject;
    PLIST_ENTRY ListEntry;
    PKQUEUE Queue;
    BOOLEAN RequestInterrupt;
    PKTHREAD Thread;
    KTHREAD_STATE ThreadState;

    //
    // Insert the APC object in the specified APC queue, set the APC inserted
    // state to TRUE, and check to determine if the APC should be delivered
    // immediately.
    //
    // For multiprocessor performance, the following code utilizes the fact
    // that kernel APC disable count is incremented before checking whether
    // the kernel APC queue is nonempty.
    //
    // See KeLeaveCriticalRegion().
    //

    Thread = Apc->Thread;
    if (Apc->ApcStateIndex == InsertApcEnvironment) {
        Apc->ApcStateIndex = Thread->ApcStateIndex;
    }

    ApcState = Thread->ApcStatePointer[Apc->ApcStateIndex];

    //
    // Insert the APC after all other special APC entries selected by
    // the processor mode if the normal routine value is NULL. Else
    // insert the APC object at the tail of the APC queue selected by
    // the processor mode unless the APC mode is user and the address
    // of the special APC routine is exit thread, in which case insert
    // the APC at the front of the list and set user APC pending.
    //

    ApcMode = Apc->ApcMode;

    ASSERT (Apc->Inserted == TRUE);

    if (Apc->NormalRoutine != NULL) {
        if ((ApcMode != KernelMode) && (Apc->KernelRoutine == PsExitSpecialApc)) {
            Thread->ApcState.UserApcPending = TRUE;
            InsertHeadList(&ApcState->ApcListHead[ApcMode],
                           &Apc->ApcListEntry);

        } else {
            InsertTailList(&ApcState->ApcListHead[ApcMode],
                           &Apc->ApcListEntry);
        }

    } else {
        ListEntry = ApcState->ApcListHead[ApcMode].Blink;
        while (ListEntry != &ApcState->ApcListHead[ApcMode]) {
            ApcEntry = CONTAINING_RECORD(ListEntry, KAPC, ApcListEntry);
            if (ApcEntry->NormalRoutine == NULL) {
                break;
            }

            ListEntry = ListEntry->Blink;
        }

        InsertHeadList(ListEntry, &Apc->ApcListEntry);
    }

    //
    // If the APC index from the APC object matches the APC Index of
    // the thread, then check to determine if the APC should interrupt
    // thread execution or sequence the thread out of a wait state.
    //

    if (Apc->ApcStateIndex == Thread->ApcStateIndex) {

        //
        // If the target thread is the current thread, then the thread state
        // is running and cannot change.
        //

        if (Thread == KeGetCurrentThread()) {

            ASSERT(Thread->State == Running);

            //
            // If the APC mode is kernel, then set kernel APC pending and
            // request an APC interrupt if special APC's are not disabled.
            //

            if (ApcMode == KernelMode) {
                Thread->ApcState.KernelApcPending = TRUE;
                if (Thread->SpecialApcDisable == 0) {
                    KiRequestSoftwareInterrupt(APC_LEVEL);
                }
            }

            return;
        }

        //
        // Lock the dispatcher database and test the processor mode.
        //
        // If the processor mode of the APC is kernel, then check if
        // the APC should either interrupt the thread or sequence the
        // thread out of a Waiting state. Else check if the APC should
        // sequence the thread out of an alertable Waiting state.
        //

        RequestInterrupt = FALSE;
        KiLockDispatcherDatabaseAtSynchLevel();
        if (ApcMode == KernelMode) {

            //
            // Thread transitions from the standby state to the running
            // state can occur from the idle thread without holding the
            // dispatcher lock. Reading the thread state after setting
            // the kernel APC pending flag prevents the code from not
            // delivering the APC interrupt in this case.
            //
            // N.B. Transitions from gate wait to running are synchronized
            //      using the thread lock. Transitions from running to gate
            //      wait are synchronized using the APC queue lock.
            //
            // N.B. If the target thread is found to be in the running state,
            //      then the APC interrupt request can be safely deferred to
            //      after the dispatcher lock is released even if the thread
            //      were to be switched to another processor, i.e., the APC
            //      would be delivered by the context switch code.
            //

            Thread->ApcState.KernelApcPending = TRUE;
            KeMemoryBarrier();
            ThreadState = Thread->State;
            if (ThreadState == Running) {
                RequestInterrupt = TRUE;

            } else if ((ThreadState == Waiting) &&
                       (Thread->WaitIrql == 0) &&
                       (Thread->SpecialApcDisable == 0) &&
                       ((Apc->NormalRoutine == NULL) ||
                        ((Thread->KernelApcDisable == 0) &&
                         (Thread->ApcState.KernelApcInProgress == FALSE)))) {

                KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment);

            } else if (Thread->State == GateWait) {
                KiAcquireThreadLock(Thread);
                if ((Thread->State == GateWait) &&
                    (Thread->WaitIrql == 0) &&
                    (Thread->SpecialApcDisable == 0) &&
                    ((Apc->NormalRoutine == NULL) ||
                     ((Thread->KernelApcDisable == 0) &&
                      (Thread->ApcState.KernelApcInProgress == FALSE)))) {

                    GateObject = Thread->GateObject;
                    KiAcquireKobjectLock(GateObject);
                    RemoveEntryList(&Thread->WaitBlock[0].WaitListEntry);
                    KiReleaseKobjectLock(GateObject);
                    if ((Queue = Thread->Queue) != NULL) {
                        Queue->CurrentCount += 1;
                    }

                    Thread->WaitStatus = STATUS_KERNEL_APC;
                    KiInsertDeferredReadyList(Thread);
                }

                KiReleaseThreadLock(Thread);
            }

        } else if ((Thread->State == Waiting) &&
                  (Thread->WaitMode == UserMode) &&
                  (Thread->Alertable || Thread->ApcState.UserApcPending)) {

            Thread->ApcState.UserApcPending = TRUE;
            KiUnwaitThread(Thread, STATUS_USER_APC, Increment);
        }

        //
        // Unlock the dispatcher database and request an APC interrupt if
        // required.
        //

        KiUnlockDispatcherDatabaseFromSynchLevel();
        if (RequestInterrupt == TRUE) {
            KiRequestApcInterrupt(Thread->NextProcessor);
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\balmgr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    balmgr.c

Abstract:

    This module implements the NT balance set manager. Normally the kernel
    does not contain "policy" code. However, the balance set manager needs
    to be able to traverse the kernel data structures and, therefore, the
    code has been located as logically part of the kernel.

    The balance set manager performs the following operations:

        1. Makes the kernel stack of threads that have been waiting for a
           certain amount of time, nonresident.

        2. Removes processes from the balance set when memory gets tight
           and brings processes back into the balance set when there is
           more memory available.

        3. Makes the kernel stack resident for threads whose wait has been
           completed, but whose stack is nonresident.

        4. Arbitrarily boosts the priority of a selected set of threads
           to prevent priority inversion in variable priority levels.

    In general, the balance set manager only is active during periods when
    memory is tight.

--*/

#include "ki.h"

//
// Define balance set wait object types.
//

typedef enum _BALANCE_OBJECT {
    TimerExpiration,
    WorkingSetManagerEvent,
    MaximumObject
    } BALANCE_OBJECT;

//
// Define maximum number of thread stacks that can be out swapped in
// a single time period.
//

#define MAXIMUM_THREAD_STACKS 5

//
// Define periodic wait interval value.
//

#define PERIODIC_INTERVAL (1 * 1000 * 1000 * 10)

//
// Define amount of time a thread can be in the ready state without having
// is priority boosted (approximately 4 seconds).
//

#define READY_WITHOUT_RUNNING  (4 * 75)

//
// Define kernel stack protect time. For small systems the protect time
// is 3 seconds. For all other systems, the protect time is 5x seconds.
//

#define SMALL_SYSTEM_STACK_PROTECT_TIME (3 * 75)
#define LARGE_SYSTEM_STACK_PROTECT_TIME (SMALL_SYSTEM_STACK_PROTECT_TIME * 5)
#define STACK_SCAN_PERIOD 4
ULONG KiStackProtectTime;

//
// Define number of threads to scan each period and the priority boost bias.
//

#define THREAD_BOOST_BIAS 1
#define THREAD_BOOST_PRIORITY (LOW_REALTIME_PRIORITY - THREAD_BOOST_BIAS)
#define THREAD_SCAN_PRIORITY (THREAD_BOOST_PRIORITY - 1)
#define THREAD_READY_COUNT 10
#define THREAD_SCAN_COUNT 16

//
// Define the last processor examined.
//

ULONG KiLastProcessor = 0;
ULONG KiReadyScanLast = 0;

//
// Define local procedure prototypes.
//

VOID
KiAdjustIrpCredits (
    VOID
    );

VOID
KiInSwapKernelStacks (
    IN PSINGLE_LIST_ENTRY SwapEntry
    );

VOID
KiInSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    );

VOID
KiOutSwapKernelStacks (
    VOID
    );

VOID
KiOutSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    );

VOID
KiScanReadyQueues (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define swap request flag.
//

LONG KiStackOutSwapRequest = FALSE;

VOID
KeBalanceSetManager (
    IN PVOID Context
    )

/*++

Routine Description:

    This function is the startup code for the balance set manager. The
    balance set manager thread is created during system initialization
    and begins execution in this function.

Arguments:

    Context - Supplies a pointer to an arbitrary data structure (NULL).

Return Value:

    None.

--*/

{

    LARGE_INTEGER DueTime;
    KIRQL OldIrql;
    KTIMER PeriodTimer;
    KDPC ScanDpc;
    ULONG StackScanPeriod;
    ULONG StackScanTime;
    NTSTATUS Status;
    PKTHREAD Thread;
    KWAIT_BLOCK WaitBlockArray[MaximumObject];
    PVOID WaitObjects[MaximumObject];

    UNREFERENCED_PARAMETER(Context);

    //
    // Raise the thread priority to the lowest realtime level.
    //

    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    //
    // Initialize the periodic timer, initialize the ready queue scan DPC,
    // and set the periodic timer it to expire one period from now.
    //

    KeInitializeTimerEx(&PeriodTimer, SynchronizationTimer);
    KeInitializeDpc(&ScanDpc, &KiScanReadyQueues, &KiReadyScanLast); 
    DueTime.QuadPart = - PERIODIC_INTERVAL;
    KeSetTimerEx(&PeriodTimer,
                 DueTime,
                 PERIODIC_INTERVAL / (10 * 1000),
                 &ScanDpc);

    //
    // Compute the stack protect and scan period time based on the system
    // size.
    //

    if (MmQuerySystemSize() == MmSmallSystem) {
        KiStackProtectTime = SMALL_SYSTEM_STACK_PROTECT_TIME;
        StackScanTime = STACK_SCAN_PERIOD;

    } else {
        KiStackProtectTime = LARGE_SYSTEM_STACK_PROTECT_TIME;
        StackScanTime = STACK_SCAN_PERIOD * 2;
    }

    StackScanPeriod = StackScanTime;

    //
    // Initialize the wait objects array.
    //

    WaitObjects[TimerExpiration] = (PVOID)&PeriodTimer;
    WaitObjects[WorkingSetManagerEvent] = (PVOID)&MmWorkingSetManagerEvent;

    //
    // Loop forever processing balance set manager events.
    //

    do {

        //
        // Wait for a memory management memory low event, a swap event,
        // or the expiration of the period timeout rate that the balance
        // set manager runs at.
        //

        Status = KeWaitForMultipleObjects(MaximumObject,
                                          &WaitObjects[0],
                                          WaitAny,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL,
                                          &WaitBlockArray[0]);

        //
        // Switch on the wait status.
        //

        switch (Status) {

            //
            // Periodic timer expiration.
            //

        case TimerExpiration:

            //
            // Adjust I/O lookaside credits.
            //

#if !defined(NT_UP)

            KiAdjustIrpCredits();

#endif

            //
            // Adjust the depth of lookaside lists.
            //

            ExAdjustLookasideDepth();

            //
            // Execute the virtual memory working set manager.
            //

            MmWorkingSetManager();

            //
            // Attempt to initiate outswapping of kernel stacks.
            //
            // N.B. If outswapping is initiated, then the dispatcher
            //      lock is not released until the wait at the top
            //      of the loop is executed.
            //

            StackScanPeriod -= 1;
            if (StackScanPeriod == 0) {
                StackScanPeriod = StackScanTime;
                if (InterlockedCompareExchange(&KiStackOutSwapRequest,
                                               TRUE,
                                               FALSE) == FALSE) {

                    KiLockDispatcherDatabase(&OldIrql);
                    KiSetInternalEvent(&KiSwapEvent, KiSwappingThread);
                    Thread = KeGetCurrentThread();
                    Thread->WaitNext = TRUE;
                    Thread->WaitIrql = OldIrql;
                }
            }

            break;

            //
            // Working set manager event.
            //

        case WorkingSetManagerEvent:

            //
            // Call the working set manager to trim working sets.
            //

            MmWorkingSetManager();
            break;

            //
            // Illegal return status.
            //

        default:
            KdPrint(("BALMGR: Illegal wait status, %lx =\n", Status));
            break;
        }

    } while (TRUE);
    return;
}

VOID
KeSwapProcessOrStack (
    IN PVOID Context
    )

/*++

Routine Description:

    This thread controls the swapping of processes and kernel stacks. The
    order of evaluation is:

        Outswap kernel stacks
        Outswap processes
        Inswap processes
        Inswap kernel stacks

Arguments:

    Context - Supplies a pointer to the routine context - not used.

Return Value:

    None.

--*/

{

    PSINGLE_LIST_ENTRY SwapEntry;

    UNREFERENCED_PARAMETER(Context);

    //
    // Set address of swap thread object and raise the thread priority to
    // the lowest realtime level + 7 (i.e., priority 23).
    //

    KiSwappingThread = KeGetCurrentThread();
    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY + 7);

    //
    // Loop for ever processing swap events.
    //
    // N.B. This is the ONLY thread that processes swap events.
    //

    do {

        //
        // Wait for a swap event to occur.
        //

        KeWaitForSingleObject(&KiSwapEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        //
        // The following events are processed one after the other. If
        // another event of a particular type arrives after having
        // processed the respective event type, them the swap event
        // will have been set and the above wait will immediately be
        // satisfied.
        //
        // Check to determine if there is a kernel stack out swap scan
        // request pending.
        //

        if (InterlockedCompareExchange(&KiStackOutSwapRequest,
                                       FALSE,
                                       TRUE) == TRUE) {

            KiOutSwapKernelStacks();
        }

        //
        // Check if there are any process out swap requests pending.
        //

        SwapEntry = InterlockedFlushSingleList(&KiProcessOutSwapListHead);
        if (SwapEntry != NULL) {
            KiOutSwapProcesses(SwapEntry);
        }

        //
        // Check if there are any process in swap requests pending.
        //

        SwapEntry = InterlockedFlushSingleList(&KiProcessInSwapListHead);
        if (SwapEntry != NULL) {
            KiInSwapProcesses(SwapEntry);
        }

        //
        // Check if there are any kernel stack in swap requests pending.
        //

        SwapEntry = InterlockedFlushSingleList(&KiStackInSwapListHead);
        if (SwapEntry != NULL) {
            KiInSwapKernelStacks(SwapEntry);
        }

    } while (TRUE);

    return;
}

#if !defined(NT_UP)

VOID
KiAdjustIrpCredits (
    VOID
    )

/*++

Routine Description:

    This function adjusts the lookaside IRP float credits for two processors
    during each one second scan interval. IRP credits are adjusted by using
    a moving average of two processors. It is possible for the IRP credits
    for a processor to become negative, but this condition will be self
    correcting.

Arguments:

    None.

Return Value:

    None.

--*/

{

    LONG Average;
    LONG Adjust;
    ULONG Index;
    ULONG Number;
    PKPRCB Prcb;
    LONG TotalAdjust;

    //
    // Adjust IRP credits if there are two or more processors.
    //

    Number = KeNumberProcessors;
    if (Number > 1) {

        //
        // Compute the target average value by averaging the IRP credits
        // across all processors.
        //

        Index = 0;
        Average = 0;
        do {
            Average += KiProcessorBlock[Index]->LookasideIrpFloat;
            Index += 1;
        } while (Index < Number);


        //
        // Adjust IRP credits for processor 0..n-1.
        //

        Average /= (LONG)Number;
        Number -= 1;
        Index = 0;
        TotalAdjust = 0;
        do {
            Prcb = KiProcessorBlock[Index];
            Adjust = Average - Prcb->LookasideIrpFloat;
            if (Adjust != 0) {
                InterlockedExchangeAdd(&Prcb->LookasideIrpFloat, Adjust);
                TotalAdjust += Adjust;
            }

            Index += 1;
        } while (Index < Number);

        //
        // Adjust IRP credit for last processor.
        //

        if (TotalAdjust != 0) {
            Prcb = KiProcessorBlock[Index];
            InterlockedExchangeAdd(&Prcb->LookasideIrpFloat, -TotalAdjust);
        }
    }

    return;
}

#endif

VOID
KiInSwapKernelStacks (
    IN PSINGLE_LIST_ENTRY SwapEntry
    )

/*++

Routine Description:

    This function in swaps the kernel stack for threads whose wait has been
    completed and whose kernel stack is nonresident.

Arguments:

    SwapEntry - Supplies a pointer to the first entry in the in swap list.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTHREAD Thread;

    //
    // Process the stack in swap SLIST and for each thread removed from the
    // SLIST, make its kernel stack resident, and ready it for execution.
    //

    do {
        Thread = CONTAINING_RECORD(SwapEntry, KTHREAD, SwapListEntry);

        ASSERT(Thread->KernelStackResident == FALSE);

        SwapEntry = SwapEntry->Next;
        MmInPageKernelStack(Thread);
        KiLockDispatcherDatabase(&OldIrql);
        Thread->KernelStackResident = TRUE;
        KiInsertDeferredReadyList(Thread);
        KiUnlockDispatcherDatabase(OldIrql);
    } while (SwapEntry != NULL);

    return;
}

VOID
KiInSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    )

/*++

Routine Description:

    This function in swaps processes.

Arguments:

    SwapEntry - Supplies a pointer to the first entry in the SLIST.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;

    //
    // Process the process in swap list and for each process removed from
    // the list, make the process resident, and process its ready list.
    //

    do {
        Process = CONTAINING_RECORD(SwapEntry, KPROCESS, SwapListEntry);
        SwapEntry = SwapEntry->Next;
        Process->State = ProcessInSwap;
        MmInSwapProcess(Process);
        KiLockDispatcherDatabase(&OldIrql);
        Process->State = ProcessInMemory;
        NextEntry = Process->ReadyListHead.Flink;
        while (NextEntry != &Process->ReadyListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            RemoveEntryList(NextEntry);
            Thread->ProcessReadyQueue = FALSE;
            KiReadyThread(Thread);
            NextEntry = Process->ReadyListHead.Flink;
        }

        KiUnlockDispatcherDatabase(OldIrql);
    } while (SwapEntry != NULL);

    return;
}

VOID
KiOutSwapKernelStacks (
    VOID
    )

/*++

Routine Description:

    This function attempts to out swap the kernel stack for threads whose
    wait mode is user and which have been waiting longer than the stack
    protect time.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    ULONG NumberOfThreads;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    PKTHREAD Thread;
    PKTHREAD ThreadObjects[MAXIMUM_THREAD_STACKS];
    ULONG WaitLimit;

    //
    // Scan the waiting in list and check if the wait time exceeds the
    // stack protect time. If the protect time is exceeded, then make
    // the kernel stack of the waiting thread nonresident. If the count
    // of the number of stacks that are resident for the process reaches
    // zero, then insert the process in the outswap list and set its state
    // to transition.
    //
    // Raise IRQL and lock the dispatcher database.
    //

    NumberOfThreads = 0;
    Prcb = KiProcessorBlock[KiLastProcessor];
    WaitLimit = KiQueryLowTickCount() - KiStackProtectTime;
    KiLockDispatcherDatabase(&OldIrql);
    NextEntry = Prcb->WaitListHead.Flink;
    while ((NextEntry != &Prcb->WaitListHead) &&
           (NumberOfThreads < MAXIMUM_THREAD_STACKS)) {

        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);

        ASSERT(Thread->WaitMode == UserMode);

        NextEntry = NextEntry->Flink;

        //
        // Threads are inserted at the end of the wait list in very nearly
        // reverse time order, i.e., the longest waiting thread is at the
        // beginning of the list followed by the next oldest, etc. Thus when
        // a thread is encountered which still has a protected stack it is
        // known that all further threads in the wait also have protected
        // stacks, and therefore, the scan can be terminated.
        //
        // N.B. It is possible due to a race condition in wait that a high
        //      priority thread was placed in the wait list. If this occurs,
        //      then the thread is removed from the wait list without swapping
        //      the stack.
        //

        if (WaitLimit < Thread->WaitTime) {
            break;

        } else if (Thread->Priority >= (LOW_REALTIME_PRIORITY + 9)) {
            RemoveEntryList(&Thread->WaitListEntry);
            Thread->WaitListEntry.Flink = NULL;

        } else if (KiIsThreadNumericStateSaved(Thread)) {
            Thread->KernelStackResident = FALSE;
            ThreadObjects[NumberOfThreads] = Thread;
            NumberOfThreads += 1;
            RemoveEntryList(&Thread->WaitListEntry);
            Thread->WaitListEntry.Flink = NULL;
            Process = Thread->ApcState.Process;

            ASSERT(Process->StackCount != 0);

            ASSERT(Process->State == ProcessInMemory);

            Process->StackCount -= 1;
            if (Process->StackCount == 0) {
                Process->State = ProcessOutTransition;
                InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                               &Process->SwapListEntry);

                KiSwapEvent.Header.SignalState = 1;
            }
        }
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Increment the last processor number.
    //

    KiLastProcessor += 1;
    if (KiLastProcessor == (ULONG)KeNumberProcessors) {
        KiLastProcessor = 0;
    }

    //
    // Out swap the kernel stack for the selected set of threads.
    //

    while (NumberOfThreads > 0) {
        NumberOfThreads -= 1;
        Thread = ThreadObjects[NumberOfThreads];

        //
        // Wait until the context has been swapped for the thread and outswap
        // the thread stack.
        //

        KeWaitForContextSwap(Thread);
        MmOutPageKernelStack(Thread);
    }

    return;
}

VOID
KiOutSwapProcesses (
    IN PSINGLE_LIST_ENTRY SwapEntry
    )

/*++

Routine Description:

    This function out swaps processes.

Arguments:

    SwapEntry - Supplies a pointer to the first entry in the SLIST.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;

    //
    // Process the process out swap list and for each process removed from
    // the list, make the process nonresident, and process its ready list.
    //

    do {
        Process = CONTAINING_RECORD(SwapEntry, KPROCESS, SwapListEntry);
        SwapEntry = SwapEntry->Next;

        //
        // If there are any threads in the process ready list, then don't
        // out swap the process and ready all threads in the process ready
        // list. Otherwise, out swap the process.
        //

        KiLockDispatcherDatabase(&OldIrql);
        NextEntry = Process->ReadyListHead.Flink;
        if (NextEntry != &Process->ReadyListHead) {
            Process->State = ProcessInMemory;
            while (NextEntry != &Process->ReadyListHead) {
                Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
                RemoveEntryList(NextEntry);
                Thread->ProcessReadyQueue = FALSE;
                KiReadyThread(Thread);
                NextEntry = Process->ReadyListHead.Flink;
            }

            KiUnlockDispatcherDatabase(OldIrql);

        } else {
            Process->State = ProcessOutSwap;
            KiUnlockDispatcherDatabase(OldIrql);
            MmOutSwapProcess(Process);

            //
            // While the process was being outswapped there may have been one
            // or more threads that attached to the process. If the process
            // ready list is not empty, then in swap the process. Otherwise,
            // mark the process as out of memory.
            //

            KiLockDispatcherDatabase(&OldIrql);
            NextEntry = Process->ReadyListHead.Flink;
            if (NextEntry != &Process->ReadyListHead) {
                Process->State = ProcessInTransition;
                InterlockedPushEntrySingleList(&KiProcessInSwapListHead,
                                               &Process->SwapListEntry);

                KiSwapEvent.Header.SignalState = 1;

            } else {
                Process->State = ProcessOutOfMemory;
            }

            KiUnlockDispatcherDatabase(OldIrql);
        }

    } while (SwapEntry != NULL);

    return;
}

VOID
KiScanReadyQueues (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function scans a section of the ready queues and attempts to
    boost the priority of threads that run at variable priority levels.

    N.B. This function is executed as a DPC from the periodic timer that
         drives the balance set manager.

Arguments:

    Dpc - Supplies a pointer to a DPC object - not used.

    DeferredContext - Supplies the DPC context - not used.

    SystemArgument1 - Supplies the first system argument - note used.

    SystemArgument2 - Supplies the second system argument - note used.

Return Value:

    None.

--*/

{

    ULONG Count = 0;
    PLIST_ENTRY Entry;
    ULONG Index;
    PLIST_ENTRY ListHead;
    ULONG Number = 0;
    KIRQL OldIrql;
    PKPRCB Prcb;
    ULONG ScanIndex;
    PULONG ScanLast;
    ULONG Summary;
    PKTHREAD Thread;
    ULONG WaitLimit;

    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    //
    // Get the address of the queue index variable.
    //
    // N.B. If a fault occurs accessing queue index value, then the exception
    //      handler is either executed or a bugcheck occurs.
    //

    ScanLast = (PULONG)DeferredContext;

#if defined(_AMD64_)

    try {
        ScanIndex = *ScanLast;

    } except(KiKernelDpcFilter(Dpc, GetExceptionInformation())) {
        return;
    }

#else

    UNREFERENCED_PARAMETER(Dpc);

    ScanIndex = *ScanLast;

#endif

    //
    // Lock the dispatcher database, acquire the PRCB lock, and check if
    // there are any ready threads queued at the scanable priority levels.
    //

    Count = THREAD_READY_COUNT;
    Number = THREAD_SCAN_COUNT;
    Prcb = KiProcessorBlock[ScanIndex];
    Index = Prcb->QueueIndex;
    WaitLimit = KiQueryLowTickCount() - READY_WITHOUT_RUNNING;
    KiLockDispatcherDatabase(&OldIrql);
    KiAcquirePrcbLock(Prcb);
    Summary = Prcb->ReadySummary & ((1 << THREAD_BOOST_PRIORITY) - 2);
    if (Summary != 0) {
        do {

            //
            // If the current ready queue index is beyond the end of the range
            // of priorities that are scanned, then wrap back to the beginning
            // priority.
            //

            if (Index > THREAD_SCAN_PRIORITY) {
                Index = 1;
            }

            //
            // If there are any ready threads queued at the current priority
            // level, then attempt to boost the thread priority.
            //

            if (Summary & PRIORITY_MASK(Index)) {

                ASSERT(IsListEmpty(&Prcb->DispatcherReadyListHead[Index]) == FALSE);

                Summary ^= PRIORITY_MASK(Index);
                ListHead = &Prcb->DispatcherReadyListHead[Index];
                Entry = ListHead->Flink;
                do {

                    //
                    // If the thread has been waiting for an extended period,
                    // then boost the priority of the selected.
                    //

                    Thread = CONTAINING_RECORD(Entry, KTHREAD, WaitListEntry);

                    ASSERT(Thread->Priority == (KPRIORITY)Index);

                    if (WaitLimit >= Thread->WaitTime) {

                        //
                        // Remove the thread from the respective ready queue.
                        //

                        Entry = Entry->Blink;

                        ASSERT((Prcb->ReadySummary & PRIORITY_MASK(Index)) != 0);

                        if (RemoveEntryList(Entry->Flink) != FALSE) {
                            Prcb->ReadySummary ^= PRIORITY_MASK(Index);
                        }

                        //
                        // Compute the priority decrement value, set the new
                        // thread priority, set the thread quantum to a value
                        //  appropriate for lock ownership, and insert the
                        // thread in the ready list.
                        //

                        ASSERT((Thread->PriorityDecrement >= 0) &&
                               (Thread->PriorityDecrement <= Thread->Priority));

                        Thread->PriorityDecrement +=
                                    (THREAD_BOOST_PRIORITY - Thread->Priority);

                        ASSERT((Thread->PriorityDecrement >= 0) &&
                               (Thread->PriorityDecrement <= THREAD_BOOST_PRIORITY));

                        Thread->Priority = THREAD_BOOST_PRIORITY;
                        Thread->Quantum = LOCK_OWNERSHIP_QUANTUM;
                        KiInsertDeferredReadyList(Thread);
                        Count -= 1;
                    }

                    Entry = Entry->Flink;
                    Number -= 1;
                } while ((Entry != ListHead) && (Number != 0) && (Count != 0));
            }

            Index += 1;
        } while ((Summary != 0) && (Number != 0) && (Count != 0));
    }

    //
    // Release the PRCB lock, unlock the dispatcher database, and save the
    // last ready queue index for the next scan.
    //

    KiReleasePrcbLock(Prcb);
    KiUnlockDispatcherDatabase(OldIrql);
    if ((Count != 0) && (Number != 0)) {
        Prcb->QueueIndex = 1;

    } else {
        Prcb->QueueIndex = Index;
    }

    //
    // Increment the processor number.
    //

    ScanIndex += 1;
    if (ScanIndex == (ULONG)KeNumberProcessors) {
        ScanIndex = 0;
    }

    *ScanLast = ScanIndex;
    return;
}

#if defined(_AMD64_)

NTSTATUS
KeExpandKernelStackAndCallout (
    __in PEXPAND_STACK_CALLOUT Callout,
    __in_opt PVOID Parameter,
    __in SIZE_T Size
    )

/*++

Routine Description:

    This function checks to determine if there is enough space in the
    current stack to execute the specified function. If enough space is
    not available, then the stack is expanded as necessary.

Arguments:

    Callout - Supplies the address of a function to call with an expanded
        stack.

    Parameter - Supplies a parameter to be passed to the callout function.

    Size - Supplies the size of the kernel stack needed to execute the
        callout function.

ReturnValue:

    If the stack allocation is successful and the callout is performed, then
    STATUS_SUCCESS is returned. Otherwise, STATUS_INVALID_PARAMETER_3 or
    STATUS_NO_MEMORY is returned.

--*/

{

    ULONG_PTR ActualLimit;
    BOOLEAN CalloutActive;
    ULONG_PTR CurrentLimit;
    ULONG_PTR CurrentStack;
    KIRQL ExitIrql;
    volatile BOOLEAN InCallout;
    PVOID LargeStack;
    PKNODE Node;
    KIRQL OldIrql;
    NTSTATUS Status;
    PKTHREAD Thread;

    //
    // If the current IRQL is not less than or equal to APC_LEVEL, then
    // bugcheck.
    //

    if ((OldIrql = KeGetCurrentIrql()) > APC_LEVEL) {
        KeBugCheckEx(IRQL_NOT_LESS_OR_EQUAL, APC_LEVEL, OldIrql, 0, 0);
    }

    //
    // If the stack request is for more than a large kernel stack, then return
    // invalid parameter.
    //

    if (Size > MAXIMUM_EXPANSION_SIZE) {
        return STATUS_INVALID_PARAMETER_3;
    }

    //
    // If enough stack space is already available, then execute the callout
    // function using the current stack. Otherwise, allocate a new stack
    // segment and execute the callout function using the new stack segment.
    //
    // There are three cases to consider:
    //
    //    1. There is committed space in the current stack for the specified
    //       allocation.
    //
    //    2. There is uncommitted space in the current stack that can be
    //       committed for the specified allocation.
    //
    //    3. There is not enough committed or uncommitted space in the
    //       current stack for the specified allocation.
    //

    Thread = KeGetCurrentThread();
    CurrentStack = KeGetCurrentStackPointer();
    CurrentLimit = (ULONG_PTR)Thread->StackLimit;
    ActualLimit = KiGetActualStackLimit(Thread);
    if ((CurrentStack - ActualLimit) >= Size) {
        if ((CurrentStack - CurrentLimit) < Size) {
    
            //
            // There is uncommitted space in the current stack that can be
            // committed for the specified allocation.
            //
    
            Status = MmGrowKernelStackEx((PVOID)CurrentStack, Size);
            if (NT_SUCCESS(Status) == FALSE) {
                return STATUS_NO_MEMORY;
            }
        }

        ASSERT((CurrentStack - (ULONG_PTR)Thread->StackLimit) >= Size);

        Status = STATUS_SUCCESS;
        CalloutActive = Thread->CalloutActive;
        Thread->CalloutActive = TRUE;
        InCallout = TRUE;
        try {
            try {
                (Callout)(Parameter);
                InCallout = FALSE;

            } except (EXCEPTION_EXECUTE_HANDLER) {
                KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
            }
    
        } finally {
            if (InCallout == TRUE) {
                KeBugCheck(KMODE_EXCEPTION_NOT_HANDLED);
            }
        }

    } else {

        //
        // There is not enough committed or uncommitted space in the
        // current stack for the specfied allocation.
        //

        Node = KiProcessorBlock[Thread->IdealProcessor]->ParentNode;
        LargeStack = MmCreateKernelStack(TRUE, Node->NodeNumber);
        if (LargeStack == NULL) {
            return STATUS_NO_MEMORY;
        }

        CalloutActive = Thread->CalloutActive;
        Thread->CalloutActive = TRUE;
        Status = KiSwitchKernelStackAndCallout(Parameter,
                                               Callout,
                                               LargeStack,
                                               Size);

        MmDeleteKernelStack(LargeStack, TRUE);
    }

    //
    // If the current IRQL is not the same as the entry IRQL, then bugcheck.
    //

    Thread->CalloutActive = CalloutActive;
    if ((ExitIrql = KeGetCurrentIrql()) != OldIrql) {
        KeBugCheckEx(IRQL_UNEXPECTED_VALUE, OldIrql, ExitIrql, 0, 0);
    }

    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\debug.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    stubs.c

Abstract:

    This module implements kernel debugger synchronization routines.

--*/

#include "ki.h"

//
// KiDebugRoutine - This is the address of the kernel debugger. Initially
//      this is filled with the address of a routine that just returns. If
//      the system debugger is present in the system, then it sets this
//      location to the address of the system debugger's routine.
//

PKDEBUG_ROUTINE KiDebugRoutine = &KdpStub;

#if defined(_AMD64_)
#define IDBG    0
#else
#define IDBG    1
#endif


//
// Define flags bits.
//

#define FREEZE_ACTIVE           0x20

//
// Define local storage to save the old IRQL.
//

KIRQL KiOldIrql;                                  

#ifndef NT_UP
PKPRCB KiFreezeOwner;
#endif

BOOLEAN
KeFreezeExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function freezes the execution of all other processors in the host
    configuration and then returns to the caller.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to an exception frame that
        describes the trap.

Return Value:

    Previous interrupt enable.

--*/

{

    BOOLEAN Enable;

#if !defined(NT_UP)

    PKPRCB Prcb;
    KAFFINITY TargetSet;
    ULONG BitNumber;
    KIRQL OldIrql;

#if IDBG

    ULONG Count = 30000;

#endif

#if !defined(_AMD64_)
    BOOLEAN Flag;
#endif

#else

    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);

#endif

    //
    // Disable interrupts.
    //

    Enable = KeDisableInterrupts();
    KiFreezeFlag = FREEZE_FROZEN;

    //
    // Raise IRQL to HIGH_LEVEL.
    //

#if !defined(NT_UP)

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    if (FrozenState(KeGetCurrentPrcb()->IpiFrozen) == FREEZE_OWNER) {

        //
        // This processor already owns the freeze lock.
        // Return without trying to re-acquire lock or without
        // trying to IPI the other processors again
        //

        return Enable;
    }

#if defined(_AMD64_)

    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);

    //
    // Acquire the KiFreezeExecutionLock.  No need to check for FREEZE
    // IPIs as these come in as NMIs anyway.
    //

    KeAcquireSpinLockAtDpcLevel(&KiFreezeExecutionLock);

#else

    //
    // Try to acquire the KiFreezeExecutionLock before sending the request.
    // To prevent deadlock from occurring, we need to accept and process
    // incoming FreezeExecution requests while we are waiting to acquire
    // the FreezeExecutionFlag.
    //

    while (KeTryToAcquireSpinLockAtDpcLevel(&KiFreezeExecutionLock) == FALSE) {

        //
        // FreezeExecutionLock is busy.  Another processor may be trying
        // to IPI us - go service any IPI.
        //

        KeEnableInterrupts(Enable);
        Flag = KiIpiServiceRoutine((PVOID)TrapFrame, (PVOID)ExceptionFrame);
        KeDisableInterrupts();

#if IDBG

        if (Flag != FALSE) {
            Count = 30000;
            continue;
        }

        KeStallExecutionProcessor (100);
        if (!Count--) {
            Count = 30000;
            if (KeTryToAcquireSpinLockAtDpcLevel(&KiFreezeLockBackup) == TRUE) {
                KiFreezeFlag |= FREEZE_BACKUP;
                break;
            }
        }

#endif

    }

#endif

    //
    // After acquiring the lock flag, we send Freeze request to each processor
    // in the system (other than us) and wait for it to become frozen.
    //

    Prcb = KeGetCurrentPrcb();  // Do this after spinlock is acquired.
    TargetSet = KeActiveProcessors & ~(AFFINITY_MASK(Prcb->Number));
    if (TargetSet) {

#if IDBG
        Count = 4000;
#endif

        KiFreezeOwner = Prcb;
        Prcb->IpiFrozen = FREEZE_OWNER | FREEZE_ACTIVE;
        Prcb->SkipTick  = TRUE;
        KiSendFreeze(&TargetSet, (KeBugCheckActive != 2));
        while (TargetSet != 0) {
            KeFindFirstSetLeftAffinity(TargetSet, &BitNumber);
            ClearMember(BitNumber, TargetSet);
            Prcb = KiProcessorBlock[BitNumber];

#if IDBG

            while (Prcb->IpiFrozen != TARGET_FROZEN) {
                if (Count == 0) {
                    KiFreezeFlag |= FREEZE_SKIPPED_PROCESSOR;
                    break;
                }

                KeStallExecutionProcessor (10000);
                Count--;
            }

#else

            while (Prcb->IpiFrozen != TARGET_FROZEN) {
                KeYieldProcessor();
            }
#endif

        }
    }

    //
    // Save the old IRQL.
    //

    KiOldIrql = OldIrql;

#else

    //
    // Save the current IRQL.
    //

    KiOldIrql = KeGetCurrentIrql();

#endif      // !defined(NT_UP)

    //
    // Return whether interrupts were previous enabled.
    //

    return Enable;
}

VOID
KiFreezeTargetExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function freezes the execution of the current running processor.
    If a trapframe is supplied to current state is saved into the prcb
    for the debugger.

Arguments:

    TrapFrame - Supplies a pointer to the trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to the exception frame that
        describes the trap.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    KIRQL OldIrql;
    PKPRCB Prcb;
    BOOLEAN Enable;
    KCONTINUE_STATUS Status;
    EXCEPTION_RECORD ExceptionRecord;

    //
    // If the freeze lock is not held, then a debugger freeze was missed.
    //

    if ((KiFreezeExecutionLock == 0) && 
        (KiFreezeLockBackup == 0) &&
        (KeBugCheckActive == FALSE)) {
#if DBG

        DbgBreakPoint();

#endif

        return;
    }

    Enable = KeDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    Prcb = KeGetCurrentPrcb();
    Prcb->IpiFrozen = TARGET_FROZEN;
    Prcb->SkipTick  = TRUE;
    if (TrapFrame != NULL) {
        KiSaveProcessorState(TrapFrame, ExceptionFrame);
    }

    //
    // Sweep the data cache in case this is a system crash and the bugcheck
    // code is attempting to write a crash dump file.
    //

    KeSweepCurrentDcache();

    //
    //  Wait for person requesting us to freeze to
    //  clear our frozen flag
    //

    while (FrozenState(Prcb->IpiFrozen) == TARGET_FROZEN) {
        if (Prcb->IpiFrozen & FREEZE_ACTIVE) {

            //
            // This processor has been made the active processor
            //
            if (TrapFrame) {
                RtlZeroMemory (&ExceptionRecord, sizeof ExceptionRecord);
                ExceptionRecord.ExceptionCode = STATUS_WAKE_SYSTEM_DEBUGGER;
                ExceptionRecord.ExceptionRecord  = &ExceptionRecord;
                ExceptionRecord.ExceptionAddress =
                    (PVOID)CONTEXT_TO_PROGRAM_COUNTER (&Prcb->ProcessorState.ContextFrame);

                Status = (KiDebugSwitchRoutine) (
                            &ExceptionRecord,
                            &Prcb->ProcessorState.ContextFrame,
                            FALSE
                            );

            } else {
                Status = ContinueError;
            }

            //
            // If status is anything other then, continue with next
            // processor then reselect master
            //

            if (Status != ContinueNextProcessor) {
                Prcb->IpiFrozen &= ~FREEZE_ACTIVE;
                KiFreezeOwner->IpiFrozen |= FREEZE_ACTIVE;
            }
        }
        KeYieldProcessor();
    }

    if (TrapFrame != NULL) {
        KiRestoreProcessorState(TrapFrame, ExceptionFrame);
    }

    Prcb->IpiFrozen = RUNNING;
    KeFlushCurrentTb();
    KeSweepCurrentIcache();
    KeLowerIrql(OldIrql);
    KeEnableInterrupts(Enable);

#else

    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);

#endif      // !define(NT_UP)

    return;
}

KCONTINUE_STATUS
KeSwitchFrozenProcessor (
    IN ULONG ProcessorNumber
    )
{

#if !defined(NT_UP)

    PKPRCB TargetPrcb, CurrentPrcb;

    //
    // If Processor number is out of range, reselect current processor
    //

    if (ProcessorNumber >= (ULONG) KeNumberProcessors) {
        return ContinueProcessorReselected;
    }

    TargetPrcb = KiProcessorBlock[ProcessorNumber];
    CurrentPrcb = KeGetCurrentPrcb();

    //
    // Move active flag to correct processor.
    //

    CurrentPrcb->IpiFrozen &= ~FREEZE_ACTIVE;
    TargetPrcb->IpiFrozen  |= FREEZE_ACTIVE;

    //
    // If this processor is frozen in KiFreezeTargetExecution, return to it
    //

    if (FrozenState(CurrentPrcb->IpiFrozen) == TARGET_FROZEN) {
        return ContinueNextProcessor;
    }

    //
    // This processor must be FREEZE_OWNER, wait to be reselected as the
    // active processor
    //

    if (FrozenState(CurrentPrcb->IpiFrozen) != FREEZE_OWNER) {
        return ContinueError;
    }

    while (!(CurrentPrcb->IpiFrozen & FREEZE_ACTIVE)) {
        KeYieldProcessor();
    }

#else

    UNREFERENCED_PARAMETER(ProcessorNumber);

#endif  // !defined(NT_UP)

    //
    // Reselect this processor
    //

    return ContinueProcessorReselected;
}

VOID
KeThawExecution (
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function thaws the execution of all other processors in the host
    configuration and then returns to the caller. It is intended for use by
    the kernel debugger.

Arguments:

    Enable - Supplies the previous interrupt enable that is to be restored
        after having thawed the execution of all other processors.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    KIRQL OldIrql;

#if IDBG
    ULONG Flag;
#endif

    KiSendThawExecution (TRUE);

    //
    // Capture the previous IRQL before releasing the freeze lock.
    //

    OldIrql = KiOldIrql;

#if IDBG

    Flag = KiFreezeFlag;
    KiFreezeFlag = 0;

    if ((Flag & FREEZE_BACKUP) != 0) {
        KiReleaseSpinLock(&KiFreezeLockBackup);
    } else {
        KiReleaseSpinLock(&KiFreezeExecutionLock);
    }

#else

    KiFreezeFlag = 0;
    KiReleaseSpinLock(&KiFreezeExecutionLock);

#endif
#endif  // !defined (NT_UP)


    //
    // Flush the current TB, instruction cache, and data cache.
    //

    KeFlushCurrentTb();
    KeSweepCurrentIcache();
    KeSweepCurrentDcache();

    //
    // Lower IRQL and restore interrupt enable
    //

#if !defined(NT_UP)
    KeLowerIrql(OldIrql);
#endif
    KeEnableInterrupts(Enable);
    return;
}

VOID
KiPollFreezeExecution(
    VOID
    )

/*++

Routine Description:

    This routine is called from code that is spinning with interrupts
    disabled, waiting for something to happen, when there is some
    (possibly extremely small) chance that that thing will not happen
    because a system freeze has been initiated.

    N.B. Interrupts are disabled.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if defined(_AMD64_)

    KeYieldProcessor();

#else

    //
    // Check to see if a freeze is pending for this processor.
    //

    PKPRCB Prcb = KeGetCurrentPrcb();

    if ((Prcb->RequestSummary & IPI_FREEZE) != 0) {

        //
        // Clear the freeze request and freeze this processor.
        //

        InterlockedExchangeAdd((PLONG)&Prcb->RequestSummary, -(IPI_FREEZE));
        KiFreezeTargetExecution(NULL, NULL);

    } else {

        //
        // No freeze pending, assume this processor is spinning.
        //

        KeYieldProcessor();
    }

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\eventobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    eventobj.c

Abstract:

    This module implements the kernel event objects. Functions are
    provided to initialize, pulse, read, reset, and set event objects.

--*/

#include "ki.h"

#pragma alloc_text (PAGE, KeInitializeEventPair)

#undef KeClearEvent

//
// The following assert macro is used to check that an input event is
// really a kernel event and not something else, like deallocated pool.
//

#define ASSERT_EVENT(E) {                             \
    ASSERT((E)->Header.Type == NotificationEvent ||   \
           (E)->Header.Type == SynchronizationEvent); \
}

//
// The following assert macro is used to check that an input event is
// really a kernel event pair and not something else, like deallocated
// pool.
//

#define ASSERT_EVENT_PAIR(E) {                        \
    ASSERT((E)->Type == EventPairObject);             \
}

#undef KeInitializeEvent

VOID
KeInitializeEvent (
    __out PRKEVENT Event,
    __in EVENT_TYPE Type,
    __in BOOLEAN State
    )

/*++

Routine Description:

    This function initializes a kernel event object. The initial signal
    state of the object is set to the specified value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Type - Supplies the type of event; NotificationEvent or
        SynchronizationEvent.

    State - Supplies the initial signal state of the event object.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header, set initial signal
    // state of event object, and set the type of event object.
    //

    Event->Header.Type = (UCHAR)Type;
    Event->Header.Size = sizeof(KEVENT) / sizeof(LONG);
    Event->Header.SignalState = State;
    InitializeListHead(&Event->Header.WaitListHead);
    return;
}

VOID
KeInitializeEventPair (
    __inout PKEVENT_PAIR EventPair
    )

/*++

Routine Description:

    This function initializes a kernel event pair object. A kernel event
    pair object contains two separate synchronization event objects that
    are used to provide a fast interprocess synchronization capability.

Arguments:

    EventPair - Supplies a pointer to a control object of type event pair.

Return Value:

    None.

--*/

{

    //
    // Initialize the type and size of the event pair object and initialize
    // the two event object as synchronization events with an initial state
    // of FALSE.
    //

    EventPair->Type = (USHORT)EventPairObject;
    EventPair->Size = sizeof(KEVENT_PAIR);
    KeInitializeEvent(&EventPair->EventLow, SynchronizationEvent, FALSE);
    KeInitializeEvent(&EventPair->EventHigh, SynchronizationEvent, FALSE);
    return;
}

VOID
KeClearEvent (
    __inout PRKEVENT Event
    )

/*++

Routine Description:

    This function clears the signal state of an event object.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    None.

--*/

{

    ASSERT_EVENT(Event);

    //
    // Clear signal state of event object.
    //

    Event->Header.SignalState = 0;
    return;
}

LONG
KePulseEvent (
    __inout PRKEVENT Event,
    __in KPRIORITY Increment,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This function atomically sets the signal state of an event object to
    signaled, attempts to satisfy as many waits as possible, and then resets
    the signal state of the event object to Not-Signaled. The previous signal
    state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KePulseEvent will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the current state of the event object is Not-Signaled and
    // the wait queue is not empty, then set the state of the event
    // to Signaled, satisfy as many Waits as possible, and then reset
    // the state of the event to Not-Signaled.
    //

    OldState = ReadForWriteAccess(&Event->Header.SignalState);
    if ((OldState == 0) &&
        (IsListEmpty(&Event->Header.WaitListHead) == FALSE)) {

        Event->Header.SignalState = 1;
        KiWaitTest(Event, Increment);
    }

    Event->Header.SignalState = 0;

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to the
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitIrql = OldIrql;
        Thread->WaitNext = Wait;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeReadStateEvent (
    __in PRKEVENT Event
    )

/*++

Routine Description:

    This function reads the current signal state of an event object.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    The current signal state of the event object.

--*/

{

    ASSERT_EVENT(Event);

    //
    // Return current signal state of event object.
    //

    return Event->Header.SignalState;
}

LONG
KeResetEvent (
    __inout PRKEVENT Event
    )

/*++

Routine Description:

    This function resets the signal state of an event object to
    Not-Signaled. The previous state of the event object is returned
    as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of event object and then reset
    // the state of the event object to Not-Signaled.
    //

    OldState = ReadForWriteAccess(&Event->Header.SignalState);
    Event->Header.SignalState = 0;

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeSetEvent (
    __inout PRKEVENT Event,
    __in KPRIORITY Increment,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This function sets the signal state of an event object to signaled
    and attempts to satisfy as many waits as possible. The previous
    signal state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       set event will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the event is a notification event, the event is already signaled,
    // and wait is false, then there is no need to set the event.
    //

    if ((Event->Header.Type == EventNotificationObject) &&
        (Event->Header.SignalState == 1) &&
        (Wait == FALSE)) {

        return 1;
    }

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the old state and set the new state to signaled.
    //
    // If the old state is not-signaled and the wait list is not empty,
    // then satisfy as many waits as possible.
    //

    OldState = ReadForWriteAccess(&Event->Header.SignalState);
    Event->Header.SignalState = 1;
    if ((OldState == 0) &&
        (IsListEmpty(&Event->Header.WaitListHead) == FALSE)) {

        if (Event->Header.Type == EventNotificationObject) {
            KiWaitTestWithoutSideEffects(Event, Increment);

        } else {
            KiWaitTestSynchronizationObject(Event, Increment);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
       Thread = KeGetCurrentThread();
       Thread->WaitNext = Wait;
       Thread->WaitIrql = OldIrql;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

VOID
KeSetEventBoostPriority (
    __inout PRKEVENT Event,
    __in_opt PRKTHREAD *Thread
    )

/*++

Routine Description:

    This function conditionally sets the signal state of an event object
    to signaled, and attempts to unwait the first waiter, and optionally
    returns the thread address of the unwaited thread.

    N.B. This function can only be called with synchronization events.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Thread - Supplies an optional pointer to a variable that receives
        the address of the thread that is awakened.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    KIRQL OldIrql;
    PKWAIT_BLOCK WaitBlock;
    PRKTHREAD WaitThread;

    ASSERT(Event->Header.Type == SynchronizationEvent);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    CurrentThread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the the wait list is not empty, then satisfy the wait of the
    // first thread in the wait list. Otherwise, set the signal state
    // of the event object.
    //

    if (IsListEmpty(&Event->Header.WaitListHead) != FALSE) {
        Event->Header.SignalState = 1;

    } else {

        //
        // Get the address of the first wait block in the event list.
        // If the wait is a wait any, then set the state of the event
        // to signaled and attempt to satisfy as many waits as possible.
        // Otherwise, unwait the first thread and apply an appropriate
        // priority boost to help prevent lock convoys from forming.
        //
        // N.B. Internal calls to this function for resource and fast
        //      mutex boosts NEVER call with a possibility of having
        //      a wait type of WaitAll. Calls from the NT service to
        //      set event and boost priority are restricted as to the
        //      event type, but not the wait type.
        //

        WaitBlock = CONTAINING_RECORD(Event->Header.WaitListHead.Flink,
                                      KWAIT_BLOCK,
                                      WaitListEntry);

        if (WaitBlock->WaitType == WaitAll) {
            Event->Header.SignalState = 1;
            KiWaitTestSynchronizationObject(Event, EVENT_INCREMENT);

        } else {

            //
            // Get the address of the waiting thread and return the address
            // if requested.
            //

            WaitThread = WaitBlock->Thread;
            if (ARGUMENT_PRESENT(Thread)) {
                *Thread = WaitThread;
            }

            //
            // Compute the new thread priority.
            //

            CurrentThread->Priority = KiComputeNewPriority(CurrentThread, 0);

            //
            // Unlink the thread from the appropriate wait queues and set
            // the wait completion status.
            //

            KiUnlinkThread(WaitThread, STATUS_SUCCESS);

            //
            // Set unwait priority adjustment parameters.
            //

            WaitThread->AdjustIncrement = CurrentThread->Priority;
            WaitThread->AdjustReason = (UCHAR)AdjustBoost;

            //
            // Ready the thread for execution.
            //

            KiReadyThread(WaitThread);
        }
    }

    //
    // Unlock dispatcher database lock and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\bugcheck.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    bugcheck.c

Abstract:

    This module implements bugcheck and system shutdown code.

--*/

#include "ki.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include <inbv.h>
#include <hdlsterm.h>


extern KDDEBUGGER_DATA64 KdDebuggerDataBlock;

extern PVOID ExPoolCodeStart;
extern PVOID ExPoolCodeEnd;
extern PVOID MmPoolCodeStart;
extern PVOID MmPoolCodeEnd;
extern PVOID MmPteCodeStart;
extern PVOID MmPteCodeEnd;

extern PWD_HANDLER ExpWdHandler;
extern PVOID       ExpWdHandlerContext;

#if defined(_AMD64_)

#define PROGRAM_COUNTER(_trapframe) ((_trapframe)->Rip)

#elif defined(_X86_)

#define PROGRAM_COUNTER(_trapframe) ((_trapframe)->Eip)

#else

#error "no target architecture"

#endif

//
// Define max buffer size for the file - this value is 
// based on the previous max value used in this file
//
#define MAX_BUFFER      128

//
// Define external referenced prototypes.
//

VOID
KiDumpParameterImages (
    IN PCHAR Buffer,
    IN PULONG_PTR BugCheckParameters,
    IN ULONG NumberOfParameters,
    IN PKE_BUGCHECK_UNICODE_TO_ANSI UnicodeToAnsiRoutine
    );

VOID
KiDisplayBlueScreen (
    IN ULONG PssMessage,
    IN BOOLEAN HardErrorCalled,
    IN PCHAR HardErrorCaption,
    IN PCHAR HardErrorMessage,
    IN PCHAR StateString
    );

//
// Define forward referenced prototypes.
//

VOID
KiScanBugCheckCallbackList (
    VOID
    );

VOID
KiInvokeBugCheckEntryCallbacks (
    VOID
    );

//
// Define bugcheck recursion counter.
//

LONG KeBugCheckCount = 1;

//
// Define an owner recursion counter is used to count the number of recursive
// bugchecks taken on the bugcheck owner processor.
//

ULONG KeBugCheckOwnerRecursionCount;

//
// Define the bugcheck owner flag.  This flag is used to track the processor
// that "owns" an active bugcheck operation by virtue of the fact that it
// decremented the bugcheck recursion counter to zero.
//

#if !defined(NT_UP)

#define BUGCHECK_UNOWNED ((ULONG) -1)

volatile ULONG KeBugCheckOwner = BUGCHECK_UNOWNED;

#endif

//
// Define bugcheck active indicator.
//

BOOLEAN KeBugCheckActive = FALSE;

#if !defined(_AMD64_)

VOID
KeBugCheck (
    __in ULONG BugCheckCode
    )
{
    KeBugCheck2(BugCheckCode, 0, 0, 0, 0, NULL);
}

VOID
KeBugCheckEx (
    __in ULONG BugCheckCode,
    __in ULONG_PTR P1,
    __in ULONG_PTR P2,
    __in ULONG_PTR P3,
    __in ULONG_PTR P4
    )
{
    KeBugCheck2(BugCheckCode, P1, P2, P3, P4, NULL);
}

#endif

ULONG_PTR KiBugCheckData[5];
PUNICODE_STRING KiBugCheckDriver;

BOOLEAN
KeGetBugMessageText (
    __in ULONG MessageId,
    __out_opt PANSI_STRING ReturnedString
    )
{
    SIZE_T  i;
    PCHAR   s;
    PMESSAGE_RESOURCE_BLOCK MessageBlock;
    PCHAR Buffer;
    BOOLEAN Result;

    Result = FALSE;
    try {
        if (KiBugCodeMessages != NULL) {
            MmMakeKernelResourceSectionWritable ();
            MessageBlock = &KiBugCodeMessages->Blocks[0];
            for (i = KiBugCodeMessages->NumberOfBlocks; i; i -= 1) {
                if (MessageId >= MessageBlock->LowId &&
                    MessageId <= MessageBlock->HighId) {

                    s = (PCHAR)KiBugCodeMessages + MessageBlock->OffsetToEntries;
                    for (i = MessageId - MessageBlock->LowId; i; i -= 1) {
                        s += ((PMESSAGE_RESOURCE_ENTRY)s)->Length;
                    }

                    Buffer = (PCHAR)((PMESSAGE_RESOURCE_ENTRY)s)->Text;

                    i = strlen(Buffer) - 1;
                    while (i > 0 && (Buffer[i] == '\n'  ||
                                     Buffer[i] == '\r'  ||
                                     Buffer[i] == 0
                                    )
                          ) {
                        if (!ARGUMENT_PRESENT( ReturnedString )) {
                            Buffer[i] = 0;
                        }
                        i -= 1;
                    }

                    if (!ARGUMENT_PRESENT( ReturnedString )) {
                        InbvDisplayString((PUCHAR)Buffer);
                        InbvDisplayString((PUCHAR)"\r");
                        }
                    else {
                        ReturnedString->Buffer = Buffer;
                        ReturnedString->Length = (USHORT)(i+1);
                        ReturnedString->MaximumLength = (USHORT)(i+1);
                    }
                    Result = TRUE;
                    break;
                }
                MessageBlock += 1;
            }
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ;
    }

    return Result;
}

PCHAR
KeBugCheckUnicodeToAnsi (
    IN PUNICODE_STRING UnicodeString,
    OUT PCHAR AnsiBuffer,
    IN ULONG MaxAnsiLength
    )
{
    PCHAR Dst;
    PWSTR Src;
    ULONG Length;

    Length = UnicodeString->Length / sizeof( WCHAR );
    if (Length >= MaxAnsiLength) {
        Length = MaxAnsiLength - 1;
        }
    Src = UnicodeString->Buffer;
    Dst = AnsiBuffer;
    while (Length--) {
        *Dst++ = (UCHAR)*Src++;
        }
    *Dst = '\0';
    return AnsiBuffer;
}

VOID
KiBugCheckDebugBreak (
    IN ULONG    BreakStatus
    )
{
    do {

        try {

            //
            // Issue a breakpoint
            //

            DbgBreakPointWithStatus (BreakStatus);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            HEADLESS_RSP_QUERY_INFO Response;
            NTSTATUS Status;
            SIZE_T Length;

            //
            // Failed to issue the breakpoint, must be no debugger.  Now, give
            // the headless terminal a chance to reboot the system, if there is one.
            //
            Length = sizeof(HEADLESS_RSP_QUERY_INFO);
            Status = HeadlessDispatch(HeadlessCmdQueryInformation,
                                      NULL,
                                      0,
                                      &Response,
                                      &Length
                                     );

            if (NT_SUCCESS(Status) &&
                (Response.PortType == HeadlessSerialPort) &&
                Response.Serial.TerminalAttached) {

                HeadlessDispatch(HeadlessCmdPutString,
                                 "\r\n",
                                 sizeof("\r\n"),
                                 NULL,
                                 NULL
                                );

                for (;;) {
                    HeadlessDispatch(HeadlessCmdDoBugCheckProcessing, NULL, 0, NULL, NULL);
                }

            }

            //
            // No terminal, or it failed, halt the system
            //

            try {

                HalHaltSystem();

            } except(EXCEPTION_EXECUTE_HANDLER) {

                for (;;) {
                }

            }
        }
    } while (BreakStatus != DBG_STATUS_BUGCHECK_FIRST);
}

PVOID
KiPcToFileHeader (
    IN PVOID PcValue,
    OUT PLDR_DATA_TABLE_ENTRY *DataTableEntry,
    IN LOGICAL DriversOnly,
    OUT PBOOLEAN InKernelOrHal
    )

/*++

Routine Description:

    This function returns the base of an image that contains the
    specified PcValue. An image contains the PcValue if the PcValue
    is within the ImageBase, and the ImageBase plus the size of the
    virtual image.

Arguments:

    PcValue - Supplies a PcValue.

    DataTableEntry - Supplies a pointer to a variable that receives the
        address of the data table entry that describes the image.

    DriversOnly - Supplies TRUE if the kernel and HAL should be skipped.

    InKernelOrHal - Set to TRUE if the PcValue is in the kernel or the HAL.
        This only has meaning if DriversOnly is FALSE.

Return Value:

    NULL - No image was found that contains the PcValue.

    NON-NULL - Returns the base address of the image that contains the
        PcValue.

--*/

{

    ULONG i;
    PLIST_ENTRY ModuleListHead;
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Next;
    ULONG_PTR Bounds;
    PVOID ReturnBase, Base;

    //
    // If the module list has been initialized, then scan the list to
    // locate the appropriate entry.
    //

    if (KeLoaderBlock != NULL) {
        ModuleListHead = &KeLoaderBlock->LoadOrderListHead;

    } else {
        ModuleListHead = &PsLoadedModuleList;
    }

    *InKernelOrHal = FALSE;
    ReturnBase = NULL;
    Next = ModuleListHead->Flink;
    if (Next != NULL) {
        i = 0;
        while (Next != ModuleListHead) {
            if (MmIsAddressValid(Next) == FALSE) {
                return NULL;
            }

            i += 1;
            if ((i <= 2) && (DriversOnly == TRUE)) {
                Next = Next->Flink;
                continue;
            }

            Entry = CONTAINING_RECORD(Next,
                                      LDR_DATA_TABLE_ENTRY,
                                      InLoadOrderLinks);

            Next = Next->Flink;
            Base = Entry->DllBase;
            Bounds = (ULONG_PTR)Base + Entry->SizeOfImage;
            if ((ULONG_PTR)PcValue >= (ULONG_PTR)Base && (ULONG_PTR)PcValue < Bounds) {
                *DataTableEntry = Entry;
                ReturnBase = Base;
                if (i <= 2) {
                    *InKernelOrHal = TRUE;
                }

                break;
            }
        }
    }

    return ReturnBase;
}

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
KeBugCheck2 (
    __in ULONG BugCheckCode,
    __in ULONG_PTR BugCheckParameter1,
    __in ULONG_PTR BugCheckParameter2,
    __in ULONG_PTR BugCheckParameter3,
    __in ULONG_PTR BugCheckParameter4,
    __in_opt PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bugcheck.

    BugCheckParameter1-4 - Supplies additional bugcheck information.

    TrapFrame - Kernel trap frame associated with the system failure (can be NULL).

Return Value:

    None.

--*/

{
    CONTEXT ContextSave;
    ULONG PssMessage;
    PCHAR HardErrorCaption;
    PCHAR HardErrorMessage;
    KIRQL OldIrql;
    PVOID ExecutionAddress;
    PVOID ImageBase;
    PVOID VirtualAddress;
    PLDR_DATA_TABLE_ENTRY DataTableEntry;
    CHAR AnsiBuffer[MAX_BUFFER];
    PKTHREAD Thread;
    BOOLEAN InKernelOrHal;
    BOOLEAN Reboot;
    BOOLEAN HardErrorCalled;

#if !defined(NT_UP)

    KAFFINITY TargetSet;
    ULONG CurrentProcessor;
    ULONG WaitCount;

#endif

    HardErrorCalled = FALSE;
    HardErrorCaption = NULL;
    HardErrorMessage = NULL;
    ExecutionAddress = NULL;
    Thread = KeGetCurrentThread();

    //
    // Initialization
    //

    Reboot = FALSE;
    KiBugCheckDriver = NULL;
    KeBugCheckActive = TRUE;

    //
    // Try to simulate a power failure for Cluster testing
    //

    if (BugCheckCode == POWER_FAILURE_SIMULATE) {
        KiScanBugCheckCallbackList();
        HalReturnToFirmware(HalRebootRoutine);
    }

#if !defined(_AMD64_)

    //
    // Save the current IRQL in the Prcb so the debugger can extract it
    // later on for debugging purposes.
    //

    KeGetCurrentPrcb()->DebuggerSavedIRQL = KeGetCurrentIrql();

    //
    // Capture the callers context as closely as possible into the debugger's
    // processor state area of the Prcb.
    //
    // N.B. There may be some prologue code that shuffles registers such that
    //      they get destroyed.
    //

    InterlockedIncrement(&KiHardwareTrigger);
    RtlCaptureContext(&KeGetCurrentPrcb()->ProcessorState.ContextFrame);
    KiSaveProcessorControlState(&KeGetCurrentPrcb()->ProcessorState);

#endif

    //
    // This is necessary on machines where the virtual unwind that happens
    // during KeDumpMachineState() destroys the context record.
    //

    ContextSave = KeGetCurrentPrcb()->ProcessorState.ContextFrame;


    //
    // Stop the watchdog timer
    //

    if (ExpWdHandler != NULL) {
        ExpWdHandler( WdActionStopTimer, ExpWdHandlerContext, NULL, TRUE );
    }

    //
    // Get the correct string for bugchecks
    //


    switch (BugCheckCode) {

        case SYSTEM_THREAD_EXCEPTION_NOT_HANDLED:
        case KERNEL_MODE_EXCEPTION_NOT_HANDLED:
        case KMODE_EXCEPTION_NOT_HANDLED:
            PssMessage = KMODE_EXCEPTION_NOT_HANDLED;
            break;

        case DATA_BUS_ERROR:
        case NO_MORE_SYSTEM_PTES:
        case INACCESSIBLE_BOOT_DEVICE:
        case UNEXPECTED_KERNEL_MODE_TRAP:
        case ACPI_BIOS_ERROR:
        case ACPI_BIOS_FATAL_ERROR:
        case FAT_FILE_SYSTEM:
        case DRIVER_CORRUPTED_EXPOOL:
        case THREAD_STUCK_IN_DEVICE_DRIVER:
            PssMessage = BugCheckCode;
            break;

        case DRIVER_CORRUPTED_MMPOOL:
            PssMessage = DRIVER_CORRUPTED_EXPOOL;
            break;

        case NTFS_FILE_SYSTEM:
            PssMessage = FAT_FILE_SYSTEM;
            break;

        case STATUS_SYSTEM_IMAGE_BAD_SIGNATURE:
            PssMessage = BUGCODE_PSS_MESSAGE_SIGNATURE;
            break;
        default:
            PssMessage = BUGCODE_PSS_MESSAGE;
        break;
    }

    //
    // Do further processing on bugcheck codes
    //

    KiBugCheckData[0] = BugCheckCode;
    KiBugCheckData[1] = BugCheckParameter1;
    KiBugCheckData[2] = BugCheckParameter2;
    KiBugCheckData[3] = BugCheckParameter3;
    KiBugCheckData[4] = BugCheckParameter4;

    switch (BugCheckCode) {

    case FATAL_UNHANDLED_HARD_ERROR:
        //
        // If we are called by hard error then we don't want to dump the
        // processor state on the machine.
        //
        // We know that we are called by hard error because the bugcheck
        // code will be FATAL_UNHANDLED_HARD_ERROR.  If this is so then the
        // error status passed to harderr is the first parameter, and a pointer
        // to the parameter array from hard error is passed as the second
        // argument.
        //
        // The third argument is the OemCaption to be printed.
        // The last argument is the OemMessage to be printed.
        //
        {
        PULONG_PTR parameterArray;

        HardErrorCalled = TRUE;

        HardErrorCaption = (PCHAR)BugCheckParameter3;
        HardErrorMessage = (PCHAR)BugCheckParameter4;
        parameterArray = (PULONG_PTR)BugCheckParameter2;
        KiBugCheckData[0] = (ULONG)BugCheckParameter1;
        KiBugCheckData[1] = parameterArray[0];
        KiBugCheckData[2] = parameterArray[1];
        KiBugCheckData[3] = parameterArray[2];
        KiBugCheckData[4] = parameterArray[3];
        }
        break;

    case IRQL_NOT_LESS_OR_EQUAL:

        ExecutionAddress = (PVOID)BugCheckParameter4;

        if (ExecutionAddress >= ExPoolCodeStart && ExecutionAddress < ExPoolCodeEnd) {
            KiBugCheckData[0] = DRIVER_CORRUPTED_EXPOOL;
        }
        else if (ExecutionAddress >= MmPoolCodeStart && ExecutionAddress < MmPoolCodeEnd) {
            KiBugCheckData[0] = DRIVER_CORRUPTED_MMPOOL;
        }
        else if (ExecutionAddress >= MmPteCodeStart && ExecutionAddress < MmPteCodeEnd) {
            KiBugCheckData[0] = DRIVER_CORRUPTED_SYSPTES;
        }
        else {
            ImageBase = KiPcToFileHeader (ExecutionAddress,
                                          &DataTableEntry,
                                          FALSE,
                                          &InKernelOrHal);
            if (InKernelOrHal == TRUE) {

                //
                // The kernel faulted at raised IRQL.  Quite often this
                // is a driver that has unloaded without deleting its
                // lookaside lists or other resources.  Or its resources
                // are marked pageable and shouldn't be.  Detect both
                // cases here and identify the offending driver
                // whenever possible.
                //

                VirtualAddress = (PVOID)BugCheckParameter1;

                ImageBase = KiPcToFileHeader (VirtualAddress,
                                              &DataTableEntry,
                                              TRUE,
                                              &InKernelOrHal);

                if (ImageBase != NULL) {
                    KiBugCheckDriver = &DataTableEntry->BaseDllName;
                    KiBugCheckData[0] = DRIVER_PORTION_MUST_BE_NONPAGED;
                }
                else {
                    KiBugCheckDriver = MmLocateUnloadedDriver (VirtualAddress);
                    if (KiBugCheckDriver != NULL) {
                        KiBugCheckData[0] = SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD;
                    }
                }
            }
            else {
                KiBugCheckData[0] = DRIVER_IRQL_NOT_LESS_OR_EQUAL;
            }
        }

        ExecutionAddress = NULL;
        break;

    case ATTEMPTED_WRITE_TO_READONLY_MEMORY:
    case ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY:
    case KERNEL_MODE_EXCEPTION_NOT_HANDLED:

        if ((TrapFrame == NULL) && (BugCheckParameter3 != (ULONG_PTR)NULL)) {
            TrapFrame = (PKTRAP_FRAME)BugCheckParameter3;
        }

        //
        // Extract the execution address from the trap frame to
        // identify the component.
        //

        if ((TrapFrame != NULL) && 
            (BugCheckCode != KERNEL_MODE_EXCEPTION_NOT_HANDLED)) {
            ExecutionAddress = (PVOID) PROGRAM_COUNTER (TrapFrame);
        }

        break;

    case DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS:

        ExecutionAddress = (PVOID)BugCheckParameter1;
        break;

    case DRIVER_USED_EXCESSIVE_PTES:

        DataTableEntry = (PLDR_DATA_TABLE_ENTRY)BugCheckParameter1;
        KiBugCheckDriver = &DataTableEntry->BaseDllName;

        break;

    case PAGE_FAULT_IN_NONPAGED_AREA:

        ImageBase = NULL;

        //
        // Extract the execution address from the trap frame to identify
        // component. Note a passed trap frame takes precedence over the
        // the third bugcheck parameter.
        //
        if ((TrapFrame == NULL) && (BugCheckParameter3 != (ULONG_PTR)NULL)) {
            TrapFrame = (PKTRAP_FRAME)BugCheckParameter3;
        }

        if (TrapFrame != NULL) {

            ExecutionAddress = (PVOID)PROGRAM_COUNTER
                ((PKTRAP_FRAME)TrapFrame);

            KiBugCheckData[3] = (ULONG_PTR)ExecutionAddress;

            ImageBase = KiPcToFileHeader (ExecutionAddress,
                                          &DataTableEntry,
                                          FALSE,
                                          &InKernelOrHal);
        }
        else {

            //
            // No trap frame, so no execution address either.
            //

            InKernelOrHal = TRUE;
        }

        VirtualAddress = (PVOID)BugCheckParameter1;

        if (MmIsSpecialPoolAddress (VirtualAddress) == TRUE) {

            //
            // Update the bugcheck number so the administrator gets
            // useful feedback that enabling special pool has enabled
            // the system to locate the corruptor.
            //

            if (MmIsSpecialPoolAddressFree (VirtualAddress) == TRUE) {
                if (InKernelOrHal == TRUE) {
                    KiBugCheckData[0] = PAGE_FAULT_IN_FREED_SPECIAL_POOL;
                }
                else {
                    KiBugCheckData[0] = DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL;
                }
            }
            else {
                if (InKernelOrHal == TRUE) {
                    KiBugCheckData[0] = PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
                }
                else {
                    KiBugCheckData[0] = DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION;
                }
            }
        }
        else if ((ExecutionAddress == VirtualAddress) &&
                (MmIsSessionAddress (VirtualAddress) == TRUE) &&
                ((Thread->Teb == NULL) || (IS_SYSTEM_ADDRESS(Thread->Teb)))) {
            //
            // This is a driver reference to session space from a
            // worker thread.  Since the system process has no session
            // space this is illegal and the driver must be fixed.
            //

            KiBugCheckData[0] = TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE;
        }
        else if (ImageBase == NULL) {
            KiBugCheckDriver = MmLocateUnloadedDriver (VirtualAddress);
            if (KiBugCheckDriver != NULL) {
                KiBugCheckData[0] = DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS;
            }
        }

        break;

    case THREAD_STUCK_IN_DEVICE_DRIVER:

        KiBugCheckDriver = (PUNICODE_STRING) BugCheckParameter3;
        break;

    default:
        break;
    }

    if (KiBugCheckDriver) {
        KeBugCheckUnicodeToAnsi(KiBugCheckDriver,
                                AnsiBuffer,
                                sizeof(AnsiBuffer));
    } else {

        //
        // This will set KiBugCheckDriver to 1 if successful.
        //

        if (ExecutionAddress) {
            KiDumpParameterImages(AnsiBuffer,
                                  (PULONG_PTR)&ExecutionAddress,
                                  1,
                                  KeBugCheckUnicodeToAnsi);
        }
    }

    if (KdPitchDebugger == FALSE ) {
        KdDebuggerDataBlock.SavedContext = (ULONG_PTR) &ContextSave;
    }

    //
    // If the user manually crashed the machine, skips the DbgPrints and
    // go to the crashdump.
    // Trying to do DbgPrint causes us to reeeter the debugger which causes
    // some problems.
    //
    // Otherwise, if the debugger is enabled, print out the information and
    // stop.
    //

    if ((BugCheckCode != MANUALLY_INITIATED_CRASH) &&
        (KdDebuggerEnabled)) {

        DbgPrint("\n*** Fatal System Error: 0x%08lx\n"
                 "                       (0x%p,0x%p,0x%p,0x%p)\n\n",
                 (ULONG)KiBugCheckData[0],
                 KiBugCheckData[1],
                 KiBugCheckData[2],
                 KiBugCheckData[3],
                 KiBugCheckData[4]);

        //
        // If the debugger is not actually connected, or the user manually
        // crashed the machine by typing .crash in the debugger, proceed to
        // "blue screen" the system.
        //
        // The call to DbgPrint above will have set the state of
        // KdDebuggerNotPresent if the debugger has become disconnected
        // since the system was booted.
        //

        if (KdDebuggerNotPresent == FALSE) {

            if (KiBugCheckDriver != NULL) {
                DbgPrint("Driver at fault: %s.\n", AnsiBuffer);
            }

            if (HardErrorCalled != FALSE) {
                if (HardErrorCaption) {
                    DbgPrint(HardErrorCaption);
                }
                if (HardErrorMessage) {
                    DbgPrint(HardErrorMessage);
                }
            }

            KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_FIRST);
        }
    }

    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KeDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);


    //
    // Retrieve the current processor number.
    //

#if !defined(NT_UP)

    CurrentProcessor = (ULONG) KeGetCurrentPrcb()->Number;

#endif

    //
    // Don't attempt to display message more than once.
    //

    if (InterlockedDecrement (&KeBugCheckCount) == 0) {

        //
        // Set the bugcheck owner flag so that we'll be able to distinguish
        // between recursive bugchecks and bugchecks occurring on different
        // processors.
        //

#if !defined(NT_UP)

        KeBugCheckOwner = CurrentProcessor;

        //
        // Attempt to get the other processors frozen now, but don't wait
        // for them to freeze (in case someone is stuck).
        //

        TargetSet = KeActiveProcessors & ~KeGetCurrentPrcb()->SetMember;
        if (TargetSet != 0) {
            KiSendFreeze(&TargetSet, FALSE);

            //
            // Indicate to KeFreezeExecution() that KiSendFreeze() must
            // not wait for targets to be in a RUNNING state before
            // transitioning to FREEZE.
            //
    
            KeBugCheckActive = 2;

            //
            // Give the other processors one second to flush their data caches.
            //
            // N.B. This cannot be synchronized since the reason for the bugcheck
            //      may be one of the other processors failed.
            //

            KeStallExecutionProcessor(1000 * 1000);
        }

#endif

        //
        // Display the blue screen.
        //

        KiDisplayBlueScreen (PssMessage,
                             HardErrorCalled,
                             HardErrorCaption,
                             HardErrorMessage,
                             AnsiBuffer);

        //
        // Invoke bugcheck callbacks.
        //

        KiInvokeBugCheckEntryCallbacks();

        //
        // If the debugger is not enabled, attempt to enable it.
        //

        if (KdDebuggerEnabled == FALSE && KdPitchDebugger == FALSE ) {
            KdEnableDebuggerWithLock(FALSE);
        } else {
            InbvDisplayString((PUCHAR)"\r\n");
        }

        // Restore the original Context frame
        KeGetCurrentPrcb()->ProcessorState.ContextFrame = ContextSave;

        //
        // For some bugchecks we want to change the thread and context before
        // it is written to the dump file IFF it is a minidump.
        // Look at the original bugcheck data, not the processed data from
        // above
        //

#define MINIDUMP_BUGCHECK 0x10000000

        if (IoIsTriageDumpEnabled()) {
#if defined(_X86_)
            if (TrapFrame != NULL) {      
                
                //
                // Build a context frame from the provided trap frame.
                //
                
                ContextSave.ContextFlags = 
                    CONTEXT_CONTROL | CONTEXT_SEGMENTS | CONTEXT_INTEGER;
                
                KeContextFromKframes(TrapFrame, NULL, &ContextSave);
                KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
            } else 
#endif
            {
                switch (BugCheckCode) {

                //
                // System thread stores a context record as the 4th parameter.
                // use that.
                // Also save the context record in case someone needs to look
                // at it.
                //

                case SYSTEM_THREAD_EXCEPTION_NOT_HANDLED:
                    if (BugCheckParameter4) {
                        ContextSave = *((PCONTEXT)BugCheckParameter4);

                        KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
                    }
                    break;

#if defined (_X86_)

                case THREAD_STUCK_IN_DEVICE_DRIVER:

                    // Extract the address of the spinning code from the thread
                    // object, so the dump is based off this thread.

                    Thread = (PKTHREAD) BugCheckParameter1;

                    if (Thread->State == Running)
                    {
                        //
                        // If the thread was running, the thread is now in a
                        // frozen state and the registers are in the PRCB
                        // context
                        //
                        ULONG Processor = Thread->NextProcessor;
                        ASSERT(Processor < (ULONG) KeNumberProcessors);
                        ContextSave =
                          KiProcessorBlock[Processor]->ProcessorState.ContextFrame;
                    }
                    else
                    {
                        //
                        // This should be a uniproc machine, and the thread
                        // should be suspended.  Just get the data off the
                        // switch frame.
                        //

                        PKSWITCHFRAME SwitchFrame = (PKSWITCHFRAME)Thread->KernelStack;

                        ASSERT(Thread->State == Ready);

                        ContextSave.Esp = (ULONG)Thread->KernelStack + sizeof(KSWITCHFRAME);
                        ContextSave.Ebp = *((PULONG)(ContextSave.Esp));
                        ContextSave.Eip = SwitchFrame->RetAddr;
                    }

                    KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
                    break;

                case UNEXPECTED_KERNEL_MODE_TRAP:

                    //
                    // Double fault (fatal exceptions should have passed a trap frame above)
                    //

                    if (BugCheckParameter1 == 0x8)
                    {
                        // The thread is correct in this case.
                        // Second parameter is the TSS.  If we have a TSS, convert
                        // the context and mark the bugcheck as converted.

                        PKTSS Tss = (PKTSS) BugCheckParameter2;

                        if (Tss)
                        {
                            if (Tss->EFlags & EFLAGS_V86_MASK)
                            {
                                ContextSave.SegSs = Tss->Ss & 0xffff;
                            }
                            else if (Tss->Cs & 1)
                            {
                                //
                                // It's user mode.
                                // The HardwareSegSs contains R3 data selector.
                                //

                                ContextSave.SegSs = (Tss->Ss | 3) & 0xffff;
                            }
                            else
                            {
                                ContextSave.SegSs = KGDT_R0_DATA;
                            }

                            ContextSave.SegGs = Tss->Gs & 0xffff;
                            ContextSave.SegFs = Tss->Fs & 0xffff;
                            ContextSave.SegEs = Tss->Es & 0xffff;
                            ContextSave.SegDs = Tss->Ds & 0xffff;
                            ContextSave.SegCs = Tss->Cs & 0xffff;
                            ContextSave.Esp = Tss->Esp;
                            ContextSave.Eip = Tss->Eip;
                            ContextSave.Ebp = Tss->Ebp;
                            ContextSave.Eax = Tss->Eax;
                            ContextSave.Ebx = Tss->Ebx;
                            ContextSave.Ecx = Tss->Ecx;
                            ContextSave.Edx = Tss->Edx;
                            ContextSave.Edi = Tss->Edi;
                            ContextSave.Esi = Tss->Esi;
                            ContextSave.EFlags = Tss->EFlags;
                        }

                        KiBugCheckData[0] |= MINIDUMP_BUGCHECK;
                        break;
                    }
#endif
                default:
                    break;
                }
            }

            //
            // Write a crash dump and optionally reboot if the system has been
            // so configured.
            //

            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[1]), PAGE_SIZE);
            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[2]), PAGE_SIZE);
            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[3]), PAGE_SIZE);
            IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[4]), PAGE_SIZE);

            //
            // Check out if we need to save additional pages for 
            // special pool situations.
            //

            {
                ULONG_PTR CrashCode;

                CrashCode = KiBugCheckData[0] & ~MINIDUMP_BUGCHECK;

                if (CrashCode == PAGE_FAULT_BEYOND_END_OF_ALLOCATION ||
                    CrashCode == DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION) {

                    //
                    // If this is a special pool buffer overrun bugcheck save the previous
                    // page containing the overran buffer. 
                    //

                    IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[1] - PAGE_SIZE), PAGE_SIZE);
                }
                else if (CrashCode == DRIVER_IRQL_NOT_LESS_OR_EQUAL &&
                         MmIsSpecialPoolAddress((PVOID)(KiBugCheckData[1]))){

                    //
                    // A special pool buffer overrun at >=DPC level is classified as
                    // DRIVER_IRQL_NOT_LESS_OR_EQUAL. Take care of saving the previous
                    // page for better clues during debugging.
                    //

                    IoAddTriageDumpDataBlock(PAGE_ALIGN(KiBugCheckData[1] - PAGE_SIZE), PAGE_SIZE);
                }
            }

            //
            // If the DPC stack is active, save that data page as well.
            //

#if defined (_X86_)
            if (KeGetCurrentPrcb()->DpcRoutineActive)
            {
                IoAddTriageDumpDataBlock(PAGE_ALIGN(KeGetCurrentPrcb()->DpcRoutineActive), PAGE_SIZE);
            }
#endif
        }

        IoWriteCrashDump((ULONG)KiBugCheckData[0],
                         KiBugCheckData[1],
                         KiBugCheckData[2],
                         KiBugCheckData[3],
                         KiBugCheckData[4],
                         &ContextSave,
                         Thread,
                         &Reboot);

    } else {

        //
        // If we reach this point then the bugcheck recursion count had
        // already been decremented by the time we decremented it above.  This
        // means that we're either bugchecking on multiple processors
        // simultaneously or that we took a recursive fault causing us to
        // reenter the bugcheck routine.
        //
        // In the multiprocessor kernel, start by waiting for the bugcheck
        // owner (that is, the agent that decremented the bugcheck recursion
        // count to 0) to move the bugcheck owner flag away from its initial
        // distinguished value.
        //
        // N.B. There is a very small window where the owner could take a
        //      recursive bugcheck after decrementing the bugcheck recursion
        //      counter and before setting the bugcheck owner flag.  If we
        //      time out waiting for the flag to change, then assume we've hit
        //      this window and try to enter the kernel debugger.
        //

#if !defined(NT_UP)

        WaitCount = 0;
        while (KeBugCheckOwner == BUGCHECK_UNOWNED) {
            if (WaitCount == 200) {
                KiBugCheckDebugBreak(DBG_STATUS_BUGCHECK_SECOND);
            }

            KeStallExecutionProcessor(1000);
            WaitCount += 1;
        }

        //
        // If this is a recursive bugcheck, then continue to the recursive
        // bugcheck handling code.  Otherwise, wait here forever in order to
        // let the bugcheck owner carry out the bugcheck operation,
        // periodically checking for freeze requests from the bugcheck owner.
        //

        if (CurrentProcessor != KeBugCheckOwner) {
            while (1) {
                KiPollFreezeExecution();
            }
        }

#endif // !defined(NT_UP)

        //
        // Let the first recursive bugcheck fall through to the remainder of
        // the bugcheck processing code.  If this generates a second recursive
        // bugcheck, then try to halt the processor, breaking into the
        // debugger if possible.  If this generates a third recursive
        // bugcheck, then halt the processor here.
        //

        KeBugCheckOwnerRecursionCount += 1;
        if (KeBugCheckOwnerRecursionCount == 1) {
            NOTHING;

        } else if (KeBugCheckOwnerRecursionCount == 2) {
            KiBugCheckDebugBreak(DBG_STATUS_BUGCHECK_SECOND);

        } else {
            while (1) {
                PAUSE_PROCESSOR;
            }
        }
    }

    //
    // Invoke bugcheck callbacks after crashdump, so the callbacks will
    // not prevent us from crashdumping.
    //

    KiScanBugCheckCallbackList();

    //
    // Start the watchdog timer
    //

    if (ExpWdHandler != NULL) {
        ExpWdHandler( WdActionStartTimer, ExpWdHandlerContext, NULL, TRUE );
    }

    //
    // Reboot the machine if necessary.
    //

    if (Reboot) {

#if defined(_AMD64_) && !defined(NT_UP)

        //
        // Unfreeze any frozen processors.  This is needed for the two 
        // functions below working properly.
        //

        KiResumeForReboot = TRUE;
        KiSendThawExecution (FALSE);
#endif

        DbgUnLoadImageSymbols (NULL, (PVOID)-1, 0);
        HalReturnToFirmware (HalRebootRoutine);
    }

    //
    // Attempt to enter the kernel debugger.
    //

    KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_SECOND);
}

#ifdef _X86_
#pragma optimize("", on)
#endif

VOID
KeEnterKernelDebugger (
    VOID
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner attempting
    to invoke the kernel debugger.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(i386)

    KIRQL OldIrql;

#endif

    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KiHardwareTrigger = 1;
    KeDisableInterrupts();
#if !defined(i386)
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
#endif
    if (InterlockedDecrement (&KeBugCheckCount) == 0) {
        if (KdDebuggerEnabled == FALSE) {
            if ( KdPitchDebugger == FALSE ) {
                KdInitSystem(0, NULL);
            }
        }
    }

    KiBugCheckDebugBreak (DBG_STATUS_FATAL);
}

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckCallback (
    __inout PKBUGCHECK_CALLBACK_RECORD CallbackRecord
    )

/*++

Routine Description:

    This function deregisters a bugcheck callback record.

Arguments:

    CallbackRecord - Supplies a pointer to a bugcheck callback record.

Return Value:

    If the specified bugcheck callback record is successfully deregistered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Deregister;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bugcheck callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently registered, then
    // deregister the callback record.
    //

    Deregister = FALSE;
    if (CallbackRecord->State == BufferInserted) {
        CallbackRecord->State = BufferEmpty;
        RemoveEntryList(&CallbackRecord->Entry);
        Deregister = TRUE;
    }

    //
    // Release the bugcheck callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // deregistered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);
    return Deregister;
}

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckCallback (
    __out PKBUGCHECK_CALLBACK_RECORD CallbackRecord,
    __in PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine,
    __in PVOID Buffer,
    __in ULONG Length,
    __in PUCHAR Component
    )

/*++

Routine Description:

    This function registers a bugcheck callback record. If the system
    crashes, then the specified function will be called during bugcheck
    processing so it may dump additional state in the specified bugcheck
    buffer.

    N.B. Bugcheck callback routines are called in reverse order of
         registration, i.e., in LIFO order.

Arguments:

    CallbackRecord - Supplies a pointer to a callback record.

    CallbackRoutine - Supplies a pointer to the callback routine.

    Buffer - Supplies a pointer to the bugcheck buffer.

    Length - Supplies the length of the bugcheck buffer in bytes.

    Component - Supplies a pointer to a zero terminated component
        identifier.

Return Value:

    If the specified bugcheck callback record is successfully registered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bugcheck callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently not registered, then
    // register the callback record.
    //

    Inserted = FALSE;
    if (CallbackRecord->State == BufferEmpty) {
        CallbackRecord->CallbackRoutine = CallbackRoutine;
        CallbackRecord->Buffer = Buffer;
        CallbackRecord->Length = Length;
        CallbackRecord->Component = Component;
        CallbackRecord->Checksum =
            ((ULONG_PTR)CallbackRoutine + (ULONG_PTR)Buffer + Length + (ULONG_PTR)Component);

        CallbackRecord->State = BufferInserted;
        InsertHeadList(&KeBugCheckCallbackListHead, &CallbackRecord->Entry);
        Inserted = TRUE;
    }

    //
    // Release the bugcheck callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // registered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);
    return Inserted;
}

VOID
KiScanBugCheckCallbackList (
    VOID
    )

/*++

Routine Description:

    This function scans the bugcheck callback list and calls each bugcheck
    callback routine so it can dump component specific information
    that may identify the cause of the bugcheck.

    N.B. The scan of the bugcheck callback list is performed VERY
        carefully. Bugcheck callback routines are called at HIGH_LEVEL
        and may not acquire ANY resources.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKBUGCHECK_CALLBACK_RECORD CallbackRecord;
    ULONG_PTR Checksum;
    ULONG Index;
    PLIST_ENTRY LastEntry;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PUCHAR Source;

    //
    // If the bugcheck callback listhead is not initialized, then the
    // bugcheck has occured before the system has gotten far enough
    // in the initialization code to enable anyone to register a callback.
    //

    ListHead = &KeBugCheckCallbackListHead;
    if ((ListHead->Flink != NULL) && (ListHead->Blink != NULL)) {

        //
        // Scan the bugcheck callback list.
        //

        LastEntry = ListHead;
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {

            //
            // The next entry address must be aligned properly, the
            // callback record must be readable, and the callback record
            // must have back link to the last entry.
            //

            if (((ULONG_PTR)NextEntry & (sizeof(ULONG_PTR) - 1)) != 0) {
                return;

            } else {
                CallbackRecord = CONTAINING_RECORD(NextEntry,
                                                   KBUGCHECK_CALLBACK_RECORD,
                                                   Entry);

                Source = (PUCHAR)CallbackRecord;
                for (Index = 0; Index < sizeof(KBUGCHECK_CALLBACK_RECORD); Index += 1) {
                    if (MmIsAddressValid((PVOID)Source) == FALSE) {
                        return;
                    }

                    Source += 1;
                }

                if (CallbackRecord->Entry.Blink != LastEntry) {
                    return;
                }

                //
                // If the callback record has a state of inserted and the
                // computed checksum matches the callback record checksum,
                // then call the specified bugcheck callback routine.
                //

                Checksum = (ULONG_PTR)CallbackRecord->CallbackRoutine;
                Checksum += (ULONG_PTR)CallbackRecord->Buffer;
                Checksum += CallbackRecord->Length;
                Checksum += (ULONG_PTR)CallbackRecord->Component;
                if ((CallbackRecord->State == BufferInserted) &&
                    (CallbackRecord->Checksum == Checksum)) {

                    //
                    // Call the specified bugcheck callback routine and
                    // handle any exceptions that occur.
                    //

                    CallbackRecord->State = BufferStarted;
                    try {
                        (CallbackRecord->CallbackRoutine)(CallbackRecord->Buffer,
                                                          CallbackRecord->Length);

                        CallbackRecord->State = BufferFinished;

                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        CallbackRecord->State = BufferIncomplete;
                    }
                }
            }

            LastEntry = NextEntry;
            NextEntry = NextEntry->Flink;
        }
    }

    return;
}

NTKERNELAPI
BOOLEAN
KeDeregisterBugCheckReasonCallback (
    __inout PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord
    )

/*++

Routine Description:

    This function deregisters a bugcheck callback record.

Arguments:

    CallbackRecord - Supplies a pointer to a bugcheck callback record.

Return Value:

    If the specified bugcheck callback record is successfully deregistered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Deregister;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bugcheck callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently registered, then
    // deregister the callback record.
    //

    Deregister = FALSE;
    if (CallbackRecord->State == BufferInserted) {
        CallbackRecord->State = BufferEmpty;
        RemoveEntryList(&CallbackRecord->Entry);
        Deregister = TRUE;
    }

    //
    // Release the bugcheck callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // deregistered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);
    return Deregister;
}

NTKERNELAPI
BOOLEAN
KeRegisterBugCheckReasonCallback (
    __out PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
    __in PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
    __in KBUGCHECK_CALLBACK_REASON Reason,
    __in PUCHAR Component
    )

/*++

Routine Description:

    This function registers a bugcheck callback record. If the system
    crashes, then the specified function will be called during bugcheck
    processing.

    N.B. Bugcheck callback routines are called in reverse order of
         registration, i.e., in LIFO order.

Arguments:

    CallbackRecord - Supplies a pointer to a callback record.

    CallbackRoutine - Supplies a pointer to the callback routine.

    Reason - Specifies the conditions under which the callback
             should be called.

    Component - Supplies a pointer to a zero terminated component
        identifier.

Return Value:

    If the specified bugcheck callback record is successfully registered,
    then a value of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    //
    // Raise IRQL to HIGH_LEVEL and acquire the bugcheck callback list
    // spinlock.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    KiAcquireSpinLock(&KeBugCheckCallbackLock);

    //
    // If the specified callback record is currently not registered, then
    // register the callback record.
    //

    Inserted = FALSE;
    if (CallbackRecord->State == BufferEmpty) {
        CallbackRecord->CallbackRoutine = CallbackRoutine;
        CallbackRecord->Reason = Reason;
        CallbackRecord->Component = Component;
        CallbackRecord->Checksum =
            ((ULONG_PTR)CallbackRoutine + Reason + (ULONG_PTR)Component);

        CallbackRecord->State = BufferInserted;
        InsertHeadList(&KeBugCheckReasonCallbackListHead,
                       &CallbackRecord->Entry);
        Inserted = TRUE;
    }

    //
    // Release the bugcheck callback spinlock, lower IRQL to its previous
    // value, and return whether the callback record was successfully
    // registered.
    //

    KiReleaseSpinLock(&KeBugCheckCallbackLock);
    KeLowerIrql(OldIrql);

    return Inserted;
}

VOID
KiInvokeBugCheckEntryCallbacks (
    VOID
    )

/*++

Routine Description:

    This function scans the bugcheck reason callback list and calls
    each bugcheck entry callback routine.

    This may seem like a duplication of KiScanBugCheckCallbackList
    but the critical difference is that the bugcheck entry callbacks
    are called immediately upon entry to KeBugCheck2 whereas
    KSBCCL does not invoke its callbacks until after all bugcheck
    processing has finished.

    In order to avoid people from abusing this callback it's
    semi-private and the reason -- KbCallbackReserved1 -- has
    an obscure name.

    N.B. The scan of the bugcheck callback list is performed VERY
        carefully. Bugcheck callback routines may be called at HIGH_LEVEL
        and may not acquire ANY resources.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord;
    ULONG_PTR Checksum;
    PLIST_ENTRY LastEntry;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PUCHAR Va;
    ULONG Pages;

    //
    // If the bugcheck callback listhead is not initialized, then the
    // bugcheck has occured before the system has gotten far enough
    // in the initialization code to enable anyone to register a callback.
    //

    ListHead = &KeBugCheckReasonCallbackListHead;
    if (ListHead->Flink == NULL || ListHead->Blink == NULL) {
        return;
    }

    //
    // Scan the bugcheck callback list.
    //

    LastEntry = ListHead;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {

        //
        // The next entry address must be aligned properly, the
        // callback record must be readable, and the callback record
        // must have back link to the last entry.
        //

        if (((ULONG_PTR)NextEntry & (sizeof(ULONG_PTR) - 1)) != 0) {
            return;
        }

        CallbackRecord = CONTAINING_RECORD(NextEntry,
                                           KBUGCHECK_REASON_CALLBACK_RECORD,
                                           Entry);

        //
        // Verify that the callback record is still valid.
        //

        Va = (PUCHAR) PAGE_ALIGN (CallbackRecord);
        Pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES (CallbackRecord,
                                                sizeof (*CallbackRecord));

        while (Pages) {
            if (!MmIsAddressValid (Va)) {
                return;
            }
            Va += PAGE_SIZE;
            Pages--;
        }

        if (CallbackRecord->Entry.Blink != LastEntry) {
            return;
        }

        LastEntry = NextEntry;
        NextEntry = NextEntry->Flink;

        //
        // If the callback record has a state of inserted and the
        // computed checksum matches the callback record checksum,
        // then call the specified bugcheck callback routine.
        //

        Checksum = (ULONG_PTR)CallbackRecord->CallbackRoutine;
        Checksum += (ULONG_PTR)CallbackRecord->Reason;
        Checksum += (ULONG_PTR)CallbackRecord->Component;
        if ((CallbackRecord->State != BufferInserted) ||
            (CallbackRecord->Checksum != Checksum) ||
            (CallbackRecord->Reason != KbCallbackReserved1) ||
            MmIsAddressValid((PVOID)(ULONG_PTR)CallbackRecord->
                             CallbackRoutine) == FALSE) {

            continue;
        }

        //
        // Call the specified bugcheck callback routine and
        // handle any exceptions that occur.
        //

        try {
            (CallbackRecord->CallbackRoutine)(KbCallbackReserved1,
                                              CallbackRecord,
                                              NULL, 0);
            CallbackRecord->State = BufferFinished;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            CallbackRecord->State = BufferIncomplete;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\config.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    config.c

Abstract:

    This module implements the code to find an ARC configuration tree
    entry as constructed by the OS Loader.

--*/

#include "ki.h"

#pragma alloc_text(INIT,KeFindConfigurationEntry)
#pragma alloc_text(INIT,KeFindConfigurationNextEntry)

PCONFIGURATION_COMPONENT_DATA
KeFindConfigurationEntry (
    IN PCONFIGURATION_COMPONENT_DATA Child,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This function search the specified configuration tree and returns a
    pointer to an entry that matches the specified class, type, and key
    parameters.

    This routine is the same as KeFindConfurationEntryNext expect
    that the search is performed from the first entry

    N.B. This routine can only be called during system initialization.

--*/

{

    PCONFIGURATION_COMPONENT_DATA Resume;

    Resume = NULL;
    return KeFindConfigurationNextEntry (Child, Class, Type, Key, &Resume);
}

PCONFIGURATION_COMPONENT_DATA
KeFindConfigurationNextEntry (
    IN PCONFIGURATION_COMPONENT_DATA Child,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN PULONG Key OPTIONAL,
    IN PCONFIGURATION_COMPONENT_DATA *Resume
    )

/*++

Routine Description:

    This function search the specified configuration tree and returns a
    pointer to an entry that matches the specified class, type, and key
    parameters.

    N.B. This routine can only be called during system initialization.

Arguments:

    Child - Supplies an optional pointer to an NT configuration component.

    Class - Supplies the configuration class of the entry to locate.

    Type - Supplies the configuration type of the entry to locate.

    Key - Supplies a pointer to an optional key value to use in locating
        the specified entry.

    Resume - Supplies the last returned entry for which the search
        should resume from.

Return Value:

    If the specified entry is located, then a pointer to the configuration
    entry is returned as the function value. Otherwise, NULL is returned.

--*/

{

    PCONFIGURATION_COMPONENT_DATA Entry;
    ULONG MatchKey;
    ULONG MatchMask;
    PCONFIGURATION_COMPONENT_DATA Sibling;

    //
    // Initialize the match key and mask based on whether the optional key
    // value is specified.
    //

    if (ARGUMENT_PRESENT(Key)) {
        MatchMask = 0xffffffff;
        MatchKey = *Key;

    } else {
        MatchMask = 0;
        MatchKey = 0;
    }

    //
    // Search specified configuration tree for an entry that matches the
    // the specified class, type, and key.
    //

    while (Child != NULL) {
        if (*Resume) {
            //
            // If resume location found, clear resume location and continue
            // search with next entry
            //

            if (Child == *Resume) {
                *Resume = NULL;
            }
        } else {

            //
            // If the class, type, and key match, then return a pointer to
            // the child entry.
            //

            if ((Child->ComponentEntry.Class == Class) &&
                (Child->ComponentEntry.Type == Type) &&
                ((Child->ComponentEntry.Key & MatchMask) == MatchKey)) {
                return Child;
            }
        }

        //
        // If the child has a sibling list, then search the sibling list
        // for an entry that matches the specified class, type, and key.
        //

        Sibling = Child->Sibling;
        while (Sibling != NULL) {
            if (*Resume) {
                //
                // If resume location found, clear resume location and continue
                // search with next entry
                //

                if (Sibling == *Resume) {
                    *Resume = NULL;
                }
            } else {

                //
                // If the class, type, and key match, then return a pointer to
                // the child entry.
                //

                if ((Sibling->ComponentEntry.Class == Class) &&
                    (Sibling->ComponentEntry.Type == Type) &&
                    ((Sibling->ComponentEntry.Key & MatchMask) == MatchKey)) {
                    return Sibling;
                }
            }

            //
            // If the sibling has a child tree, then search the child tree
            // for an entry that matches the specified class, type, and key.
            //

            if (Sibling->Child != NULL) {
               Entry = KeFindConfigurationNextEntry (
                                Sibling->Child,
                                Class,
                                Type,
                                Key,
                                Resume
                                );

               if (Entry != NULL) {
                   return Entry;
               }
            }

            Sibling = Sibling->Sibling;
        }

        Child = Child->Child;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\devquobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    devquobj.c

Abstract:

    This module implements the kernel device queue object. Functions are
    provided to initialize a device queue object and to insert and remove
    device queue entries in a device queue object.

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input device queue
// is really a kdevice_queue and not something else, like deallocated pool.
//

#define ASSERT_DEVICE_QUEUE(E) {            \
    ASSERT((E)->Type == DeviceQueueObject); \
}

//
// Device Queue Hint is enabled for AMD64 only, because the DEVICE_QUEUE
// structure has sufficient padding in which to store the hint only on
// WIN64, and IA64 kernel mode addresses cannot have the MSB truncated
// and reconstructed via sign extension.
// 

#if defined(_AMD64_)

#define _DEVICE_QUEUE_HINT_

#endif

#if defined(_DEVICE_QUEUE_HINT_)

FORCEINLINE
PKDEVICE_QUEUE_ENTRY
KiGetDeviceQueueKeyHint (
    IN PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function extracts a device queue entry address as a hint from a
    device queue object.

    N.B. Hints are stored as 56-bit sign extended value.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device
        queue.

Return Value:

    Returns the device queue hint, or NULL of a hint does not exist.

--*/

{

    return (PKDEVICE_QUEUE_ENTRY)(DeviceQueue->Hint);
}

FORCEINLINE
VOID
KiSetDeviceQueueKeyHint (
    IN OUT PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function stores a device queue entry address as a hint in a device
    queue object.

    N.B. Hints are stored as 56-bit sign extended value.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device
        queue.

Return Value:

    Returns the device queue hint, or NULL of a hint does not exist.

--*/

{
    DeviceQueue->Hint = (LONG64)DeviceQueueEntry;
}

FORCEINLINE
VOID
KiInvalidateDeviceQueueKeyHint (
    IN OUT PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function is invoked when a device queue entry is removed from a
    device queue to determine whether the device queue entry matches the
    hint value for the device queue, and if so to invalidate it.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device
        queue.

    DeviceQueueEntry - Supplies a pointer to the queue entry that has been
        removed from the queue.

Return Value:

    None.

--*/

{
    if (DeviceQueueEntry == KiGetDeviceQueueKeyHint(DeviceQueue)) {
        KiSetDeviceQueueKeyHint(DeviceQueue,NULL);
    }

    return;
}

#else

#define KiInvalidateDeviceQueueKeyHint(q, e)
#define KiSetDeviceQueueKeyHint(q, e)

#endif

VOID
KeInitializeDeviceQueue (
    __out PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function initializes a kernel device queue object.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device
        queue.

    SpinLock - Supplies a pointer to an executive spin lock.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    DeviceQueue->Type = DeviceQueueObject;
    DeviceQueue->Size = sizeof(KDEVICE_QUEUE);

    //
    // Initialize the device queue list head, spin lock, busy indicator,
    // and hint.
    //

    InitializeListHead(&DeviceQueue->DeviceListHead);
    KeInitializeSpinLock(&DeviceQueue->Lock);
    DeviceQueue->Busy = FALSE;
    KiSetDeviceQueueKeyHint(DeviceQueue, NULL);
    return;
}

BOOLEAN
KeInsertDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __inout PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function inserts a device queue entry at the tail of the specified
    device queue. If the device is not busy, then it is set busy and the entry
    is not placed in the device queue. Otherwise the specified entry is placed
    at the end of the device queue.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Busy;
    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT_DEVICE_QUEUE(DeviceQueue);

    //
    // Set inserted to FALSE and lock specified device queue.
    //

    Inserted = FALSE;
    KiAcquireInStackQueuedSpinLockForDpc(&DeviceQueue->Lock, &LockHandle);

    //
    // Insert the specified device queue entry at the end of the device queue
    // if the device queue is busy. Otherwise set the device queue busy and
    // don't insert the device queue entry.
    //

    Busy = DeviceQueue->Busy;
    DeviceQueue->Busy = TRUE;
    if (Busy == TRUE) {
        InsertTailList(&DeviceQueue->DeviceListHead,
                       &DeviceQueueEntry->DeviceListEntry);

        Inserted = TRUE;
    }

    DeviceQueueEntry->Inserted = Inserted;

    //
    // Unlock specified device queue.
    //

    KiReleaseInStackQueuedSpinLockForDpc(&LockHandle);
    return Inserted;
}

BOOLEAN
KeInsertByKeyDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __inout PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    __in ULONG SortKey
    )

/*++

Routine Description:

    This function inserts a device queue entry into the specified device
    queue according to a sort key. If the device is not busy, then it is
    set busy and the entry is not placed in the device queue. Otherwise
    the specified entry is placed in the device queue at a position such
    that the specified sort key is greater than or equal to its predecessor
    and less than its successor.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

    SortKey - Supplies the sort key by which the position to insert the device
        queue entry is to be determined.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Busy;
    BOOLEAN Inserted;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PKDEVICE_QUEUE_ENTRY QueueEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);

    //
    // Set inserted to FALSE and lock specified device queue.
    //

    Inserted = FALSE;
    DeviceQueueEntry->SortKey = SortKey;
    KiAcquireInStackQueuedSpinLockForDpc(&DeviceQueue->Lock, &LockHandle);

    //
    // Insert the specified device queue entry in the device queue at the
    // position specified by the sort key if the device queue is busy.
    // Otherwise set the device queue busy an don't insert the device queue
    // entry.
    //

    Busy = DeviceQueue->Busy;
    DeviceQueue->Busy = TRUE;
    if (Busy == TRUE) {
        NextEntry = &DeviceQueue->DeviceListHead;
        if (IsListEmpty(NextEntry) == FALSE) {

            //
            // Check the last queue entry in the list, which will have the
            // highest sort key. If this key is greater than or equal to
            // the specified sort key, then the insertion point has been
            // found. Otherwise, walk the list forward until the insertion
            // point is found.
            //

            QueueEntry = CONTAINING_RECORD(NextEntry->Blink,
                                           KDEVICE_QUEUE_ENTRY,
                                           DeviceListEntry);

            if (SortKey < QueueEntry->SortKey) {
                do {
                    NextEntry = NextEntry->Flink;
                    QueueEntry = CONTAINING_RECORD(NextEntry,
                                                   KDEVICE_QUEUE_ENTRY,
                                                   DeviceListEntry);

                } while (SortKey >= QueueEntry->SortKey);
            }
        }

        InsertTailList(NextEntry, &DeviceQueueEntry->DeviceListEntry);
        Inserted = TRUE;
    }

    DeviceQueueEntry->Inserted = Inserted;

    //
    // Unlock specified device queue.
    //

    KiReleaseInStackQueuedSpinLockForDpc(&LockHandle);
    return Inserted;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function removes an entry from the head of the specified device
    queue. If the device queue is empty, then the device is set Not-Busy
    and a NULL pointer is returned. Otherwise the next entry is removed
    from the head of the device queue and the address of device queue entry
    is returned.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);

    //
    // Set device queue entry NULL and lock specified device queue.
    //

    DeviceQueueEntry = NULL;
    KiAcquireInStackQueuedSpinLockForDpc(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    ASSERT(DeviceQueue->Busy == TRUE);

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;

    } else {
        NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
        DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                             KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);

        DeviceQueueEntry->Inserted = FALSE;
        KiInvalidateDeviceQueueKeyHint(DeviceQueue,DeviceQueueEntry);
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KiReleaseInStackQueuedSpinLockForDpc(&LockHandle);
    return DeviceQueueEntry;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __in ULONG SortKey
    )

/*++

Routine Description:

    This function removes an entry from the specified device queue. If the
    device queue is empty, then the device is set Not-Busy and a NULL pointer
    is returned. Otherwise the an entry is removed from the device queue and
    the address of device queue entry is returned. The queue is search for the
    first entry which has a value greater than or equal to the specified sort
    key. If no such entry is found, then the first entry of the queue is
    returned.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

#if defined(_DEVICE_QUEUE_HINT_)

    PKDEVICE_QUEUE_ENTRY DeviceQueueHint;

#endif

    ASSERT_DEVICE_QUEUE(DeviceQueue);

    //
    // Set device queue entry NULL and lock specified device queue.
    //

    DeviceQueueEntry = NULL;
    KiAcquireInStackQueuedSpinLockForDpc(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    ASSERT(DeviceQueue->Busy == TRUE);

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;

    } else {

        NextEntry = &DeviceQueue->DeviceListHead;
        DeviceQueueEntry = CONTAINING_RECORD(NextEntry->Blink,
                                             KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);

        //
        // First check to see whether the last entry in the sorted list
        // is <= SortKey.  If so, no need to search the list, instead
        // return the first entry directly.
        //

        if (DeviceQueueEntry->SortKey <= SortKey) {
            DeviceQueueEntry = CONTAINING_RECORD(NextEntry->Flink,
                                                 KDEVICE_QUEUE_ENTRY,
                                                 DeviceListEntry);
        } else {

            //
            // Check whether the hint provides a good starting point
            // in the list.  If not, begin the search at the start of
            // the list.
            //

#if defined(_DEVICE_QUEUE_HINT_)

            DeviceQueueHint = KiGetDeviceQueueKeyHint(DeviceQueue);
            if ((DeviceQueueHint != NULL) &&
                (SortKey > DeviceQueueHint->SortKey)) {
                NextEntry = &DeviceQueueHint->DeviceListEntry;

            } else
#endif
            {
                NextEntry = DeviceQueue->DeviceListHead.Flink;
            }

            while (TRUE) {
                DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                                     KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);
    
                if (SortKey <= DeviceQueueEntry->SortKey) {
                    break;
                }
    
                NextEntry = NextEntry->Flink;
            }
        }

        //
        // We have an entry. If it is not the first entry in the list, then
        // store the address of the previous node as a hint. Otherwise. clear
        // the hint.
        //

#if defined(_DEVICE_QUEUE_HINT_)

        NextEntry = DeviceQueueEntry->DeviceListEntry.Blink;
        if (NextEntry == &DeviceQueue->DeviceListHead) {
            DeviceQueueHint = NULL;

        } else {
            DeviceQueueHint = CONTAINING_RECORD(NextEntry,
                                                KDEVICE_QUEUE_ENTRY,
                                                DeviceListEntry);
        }

        KiSetDeviceQueueKeyHint(DeviceQueue,DeviceQueueHint);

#endif

        RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);
        DeviceQueueEntry->Inserted = FALSE;
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KiReleaseInStackQueuedSpinLockForDpc(&LockHandle);
    return DeviceQueueEntry;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueueIfBusy (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __in ULONG SortKey
    )

/*++

Routine Description:

    This function removes an entry from the specified device queue if and
    only if the device is currently busy. If the device queue is empty or
    the device is not busy, then the device is set Not-Busy and a NULL is
    returned. Otherwise, an entry is removed from the device queue and the
    address of device queue entry is returned. The queue is search for the
    first entry which has a value greater than or equal to the SortKey. If
    no such entry is found then the first entry of the queue is returned.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);

    //
    // Set device queue entry NULL and lock specified device queue.
    //

    DeviceQueueEntry = NULL;
    KiAcquireInStackQueuedSpinLockForDpc(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue is busy, then attempt to remove an entry from
    // the queue using the sort key. Otherwise, set the device queue not
    // busy.
    //

    if (DeviceQueue->Busy != FALSE) {
        if (IsListEmpty(&DeviceQueue->DeviceListHead) != FALSE) {
            DeviceQueue->Busy = FALSE;

        } else {
            NextEntry = DeviceQueue->DeviceListHead.Flink;
            while (NextEntry != &DeviceQueue->DeviceListHead) {
                DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                                     KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);

                if (SortKey <= DeviceQueueEntry->SortKey) {
                    break;
                }

                NextEntry = NextEntry->Flink;
            }

            if (NextEntry != &DeviceQueue->DeviceListHead) {
                RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);

            } else {
                NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
                DeviceQueueEntry = CONTAINING_RECORD(NextEntry,
                                                     KDEVICE_QUEUE_ENTRY,
                                                     DeviceListEntry);
            }

            DeviceQueueEntry->Inserted = FALSE;
            KiInvalidateDeviceQueueKeyHint(DeviceQueue,DeviceQueueEntry);
        }
    }

    //
    // Unlock specified device queue and return address of device queue
    // entry.
    //

    KiReleaseInStackQueuedSpinLockForDpc(&LockHandle);
    return DeviceQueueEntry;
}

BOOLEAN
KeRemoveEntryDeviceQueue (
    __inout PKDEVICE_QUEUE DeviceQueue,
    __inout PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function removes a specified entry from the the specified device
    queue. If the device queue entry is not in the device queue, then no
    operation is performed. Otherwise the specified device queue entry is
    removed from the device queue and its inserted status is set to FALSE.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry which is to
        be removed from its device queue.

Return Value:

    A value of TRUE is returned if the device queue entry is removed from its
    device queue. Otherwise a value of FALSE is returned.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    BOOLEAN Removed;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock specified device queue.
    //

    KeAcquireInStackQueuedSpinLock(&DeviceQueue->Lock, &LockHandle);

    //
    // If the device queue entry is not in a device queue, then no operation
    // is performed. Otherwise remove the specified device queue entry from its
    // device queue.
    //

    Removed = DeviceQueueEntry->Inserted;
    if (Removed == TRUE) {
        DeviceQueueEntry->Inserted = FALSE;
        RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);
        KiInvalidateDeviceQueueKeyHint(DeviceQueue,DeviceQueueEntry);
    }

    //
    // Unlock specified device queue, lower IRQL to its previous level, and
    // return whether the device queue entry was removed from its queue.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Removed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\dpclock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dpclock.c

Abstract:

    This module contains the implementation for threaded DPC spin lock
    acquire and release functions.

--*/

#include "ki.h"

KIRQL
FASTCALL
KeAcquireSpinLockForDpc (
    __inout PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function conditionally raises IRQL to DISPATCH_LEVEL and acquires
    the specified spin lock.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    SpinLock - Supplies the address of a spin lock.

Return Value:

    If the IRQL is raised, then the previous IRQL is returned. Otherwise, zero
    is returned.

--*/

{

    return KiAcquireSpinLockForDpc(SpinLock);
}

VOID
FASTCALL
KeReleaseSpinLockForDpc (
    __inout PKSPIN_LOCK SpinLock,
    __in KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases the specified spin lock and conditionally lowers
    IRQL to its previous value.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    SpinLock - Supplies the address of a spin lock.

    OldIrql - Supplies the previous IRQL.

Return Value:

    None.

--*/

{

    KiReleaseSpinLockForDpc(SpinLock, OldIrql);
    return;
}


VOID
FASTCALL
KeAcquireInStackQueuedSpinLockForDpc (
    __inout PKSPIN_LOCK SpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function conditionally raises IRQL to DISPATCH_LEVEL and acquires
    the specified in-stack spin lock.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    SpinLock - Supplies the address of a spin lock.

    LockHandle - Supplies the address of a lock handle.

Return Value:

    None.

--*/

{

    KiAcquireInStackQueuedSpinLockForDpc(SpinLock, LockHandle);
    return;
}

VOID
FASTCALL
KeReleaseInStackQueuedSpinLockForDpc (
    __in PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function releases the specified in-stack spin lock and conditionally
    lowers IRQL to its previous value.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    LockHandle - Supplies the address of a lock handle.

Return Value:

    None.

--*/

{

    KiReleaseInStackQueuedSpinLockForDpc(LockHandle);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\dpcobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dpcobj.c

Abstract:

    This module implements the kernel DPC object. Functions are provided
    to initialize, insert, and remove DPC objects.

--*/

#include "ki.h"

//
// Define deferred reverse barrier structure.
//

#define DEFERRED_REVERSE_BARRIER_SYNCHRONIZED 0x80000000

typedef struct _DEFERRED_REVERSE_BARRIER {
    ULONG Barrier;
    ULONG TotalProcessors;
} DEFERRED_REVERSE_BARRIER, *PDEFERRED_REVERSE_BARRIER;

FORCEINLINE
PKDPC_DATA
KiSelectDpcData (
    IN PKPRCB Prcb,
    IN PKDPC Dpc
    )

/*++

Routine Description:

    This function selects the appropriate DPC data structure in the specified
    processor control block based on the type of DPC and whether threaded DPCs
    are enabled.

Arguments:

    Prcb - Supplies the address of a processor control block.

    Dpc - Supplies the address of a control object of type DPC.

Return Value:

    The address of the appropriate DPC data structure is returned.

--*/

{

    //
    // If the DPC is a threaded DPC and thread DPCs are enabled, then set
    // the address of the threaded DPC data. Otherwise, set the address of
    // the normal DPC structure.
    //
    
    if ((Dpc->Type == (UCHAR)ThreadedDpcObject) &&                           
        (Prcb->ThreadDpcEnable != FALSE)) {                                 
                                                                            
        return &Prcb->DpcData[DPC_THREADED];

    } else {
        return &Prcb->DpcData[DPC_NORMAL];                                   
    }
}

VOID
KiInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext,
    IN KOBJECTS DpcType
    )

/*++

Routine Description:

    This function initializes a kernel DPC object. The deferred routine,
    context parameter, and object type are stored in the DPC object.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredRoutine - Supplies a pointer to a function that is called when
        the DPC object is removed from the current processor's DPC queue.

    DeferredContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the DeferredRoutine parameter.

    DpcType - Supplies the type of DPC object.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    Dpc->Type = (UCHAR)DpcType;
    Dpc->Importance = MediumImportance;
    Dpc->Number = 0;
    Dpc->Expedite = 0;

    //
    // Initialize deferred routine address and deferred context parameter.
    //

    Dpc->DeferredRoutine = DeferredRoutine;
    Dpc->DeferredContext = DeferredContext;
    Dpc->DpcData = NULL;
    return;
}

VOID
KeInitializeDpc (
    __out PRKDPC Dpc,
    __in PKDEFERRED_ROUTINE DeferredRoutine,
    __in_opt PVOID DeferredContext
    )

/*++

Routine Description:

    This function initializes a kernel DPC object.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredRoutine - Supplies a pointer to a function that is called when
        the DPC object is removed from the current processor's DPC queue.

    DeferredContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the DeferredRoutine parameter.

Return Value:

    None.

--*/

{

    KiInitializeDpc(Dpc, DeferredRoutine, DeferredContext, DpcObject);
    return;
}

VOID
KeInitializeThreadedDpc (
    __out PRKDPC Dpc,
    __in PKDEFERRED_ROUTINE DeferredRoutine,
    __in_opt PVOID DeferredContext
    )

/*++

Routine Description:

    This function initializes a kernel Threaded DPC object.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredRoutine - Supplies a pointer to a function that is called when
        the DPC object is removed from the current processor's DPC queue.

    DeferredContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the DeferredRoutine parameter.

Return Value:

    None.

--*/

{

    KiInitializeDpc(Dpc, DeferredRoutine, DeferredContext, ThreadedDpcObject);
    return;
}

BOOLEAN
KeInsertQueueDpc (
    __inout PRKDPC Dpc,
    __in_opt PVOID SystemArgument1,
    __in_opt PVOID SystemArgument2
    )

/*++

Routine Description:

    This function inserts a DPC object into the DPC queue. If the DPC object
    is already in the DPC queue, then no operation is performed. Otherwise,
    the DPC object is inserted in the DPC queue and a dispatch interrupt is
    requested.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    SystemArgument1, SystemArgument2  - Supply a set of two arguments that
        contain untyped data provided by the executive.

Return Value:

    If the DPC object is already in a DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    PKPRCB CurrentPrcb;
    PKDPC_DATA DpcData;
    BOOLEAN Inserted;

#if !defined(NT_UP)

    ULONG_PTR Number;

#endif

    KIRQL OldIrql;
    BOOLEAN RequestInterrupt;
    PKPRCB TargetPrcb;

    ASSERT_DPC(Dpc);

    //
    // Disable interrupts and acquire the DPC queue lock for the specified
    // target processor.
    //
    // N.B. Disable interrupt cannot be used here since it causes the
    //      software interrupt request code to get confused on some
    //      platforms.
    //

    RequestInterrupt = FALSE;
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    CurrentPrcb = KeGetCurrentPrcb();

#if !defined(NT_UP)

    if (Dpc->Number >= MAXIMUM_PROCESSORS) {
        Number = Dpc->Number - MAXIMUM_PROCESSORS;
        TargetPrcb = KiProcessorBlock[Number];

    } else {
        Number = CurrentPrcb->Number;
        TargetPrcb = CurrentPrcb;
    }

    DpcData = KiSelectDpcData(TargetPrcb, Dpc);
    KiAcquireSpinLock(&DpcData->DpcLock);

#else

    TargetPrcb = CurrentPrcb;
    DpcData = KiSelectDpcData(TargetPrcb, Dpc);

#endif

    //
    // If the DPC object is not in a DPC queue, then store the system
    // arguments, insert the DPC object in the DPC queue, increment the
    // number of DPCs queued to the target processor, increment the DPC
    // queue depth, set the address of the DPC target DPC spinlock, and
    // request a dispatch interrupt if appropriate.
    //

    Inserted = FALSE;
    if (InterlockedCompareExchangePointer(&Dpc->DpcData,
                                          DpcData,
                                          NULL) == NULL) {

        DpcData->DpcQueueDepth += 1;
        DpcData->DpcCount += 1;
        Dpc->SystemArgument1 = SystemArgument1;
        Dpc->SystemArgument2 = SystemArgument2;

        //
        // If the DPC is of high importance, then insert the DPC at the
        // head of the DPC queue. Otherwise, insert the DPC at the end
        // of the DPC queue.
        //

        Inserted = TRUE;
        if (Dpc->Importance == HighImportance) {
            InsertHeadList(&DpcData->DpcListHead, &Dpc->DpcListEntry);

        } else {
            InsertTailList(&DpcData->DpcListHead, &Dpc->DpcListEntry);
        }

        KeMemoryBarrier();

        //
        // If the DPC is a normal DPC, then determine if a DPC interrupt
        // should be request. Otherwise, check if the DPC thread should
        // be activated.
        //

        if (DpcData == &TargetPrcb->DpcData[DPC_THREADED]) {

            //
            // If the DPC thread is not active on the target processor and
            // a thread activation has not been requested, then request a
            // dispatch interrupt on the target processor.
            //

            if ((TargetPrcb->DpcThreadActive == FALSE) &&
                (TargetPrcb->DpcThreadRequested == FALSE)) {

                InterlockedExchange(&TargetPrcb->DpcSetEventRequest, TRUE);
                TargetPrcb->DpcThreadRequested = TRUE;
                TargetPrcb->QuantumEnd = TRUE;

#if defined(NT_UP)

                RequestInterrupt = TRUE;

#else

                if (CurrentPrcb != TargetPrcb) {
                    if (((KiIdleSummary & AFFINITY_MASK(Number)) == 0) ||
                        (KeIsIdleHaltSet(TargetPrcb, Number) != FALSE)) {

                        RequestInterrupt = TRUE;
                    }
    
                } else {
                    RequestInterrupt = TRUE;
                }
                
#endif

            }

        } else {

            //
            // If a DPC routine is not active on the target processor and
            // an interrupt has not been requested, then request a dispatch
            // interrupt on the target processor if appropriate.
            //
    
            if ((TargetPrcb->DpcRoutineActive == FALSE) &&
                (TargetPrcb->DpcInterruptRequested == FALSE)) {
    
                //
                // Request a dispatch interrupt on the current processor if
                // the DPC is not of low importance, the length of the DPC
                // queue has exceeded the maximum threshold, or if the DPC
                // request rate is below the minimum threshold.
                //

#if defined(NT_UP)

                if ((Dpc->Importance != LowImportance) ||
                    (DpcData->DpcQueueDepth >= TargetPrcb->MaximumDpcQueueDepth) ||
                    (TargetPrcb->DpcRequestRate < TargetPrcb->MinimumDpcRate)) {
    
                    TargetPrcb->DpcInterruptRequested = TRUE;
                    RequestInterrupt = TRUE;
                }

#endif

                //
                // If the DPC is being queued to another processor and the
                // DPC is of high importance, or the length of the other
                // processor's DPC queue has exceeded the maximum threshold,
                // then request a dispatch interrupt. Otherwise, request a
                // dispatch interrupt on the current processor if the DPC is
                // not of low importance, the length of the DPC queue has
                // exceeded the maximum threshold, or if the DPC request rate
                // is below the minimum threshold.
                //

#if !defined(NT_UP)

                if (CurrentPrcb != TargetPrcb) {
                    if (((Dpc->Importance == HighImportance) ||
                         (DpcData->DpcQueueDepth >= TargetPrcb->MaximumDpcQueueDepth))) {
    
                        if (((KiIdleSummary & AFFINITY_MASK(Number)) == 0) ||
                            (KeIsIdleHaltSet(TargetPrcb, Number) != FALSE)) {
    
                            TargetPrcb->DpcInterruptRequested = TRUE;
                            RequestInterrupt = TRUE;
                        }
                    }
    
                } else {
                    if ((Dpc->Importance != LowImportance) ||
                        (DpcData->DpcQueueDepth >= TargetPrcb->MaximumDpcQueueDepth) ||
                        (TargetPrcb->DpcRequestRate < TargetPrcb->MinimumDpcRate)) {
    
                        TargetPrcb->DpcInterruptRequested = TRUE;
                        RequestInterrupt = TRUE;
                    }
                }

#endif

            }
        }
    }

    //
    // Release the DPC lock, request a DPC interrupt if required, enable
    // interrupts, and return whether the DPC was queued or not.
    //

#if !defined(NT_UP)

    KiReleaseSpinLock(&DpcData->DpcLock);

#endif

    if (RequestInterrupt == TRUE) {

#if defined(NT_UP)

        KiRequestSoftwareInterrupt(DISPATCH_LEVEL);

#else

        if (TargetPrcb != CurrentPrcb) {
            KiSendSoftwareInterrupt(AFFINITY_MASK(Number), DISPATCH_LEVEL);
    
        } else {
            KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
        }       

#endif

    }

    KeLowerIrql(OldIrql);
    return Inserted;
}

BOOLEAN
KeRemoveQueueDpc (
    __inout PRKDPC Dpc
    )

/*++

Routine Description:

    This function removes a DPC object from the DPC queue. If the DPC object
    is not in the DPC queue, then no operation is performed. Otherwise, the
    DPC object is removed from the DPC queue and its inserted state is set
    FALSE.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

Return Value:

    If the DPC object is not in the DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    PKDPC_DATA DpcData;
    BOOLEAN Enable;

    ASSERT_DPC(Dpc);

    //
    // If the DPC object is in the DPC queue, then remove it from the queue
    // and set its inserted state to FALSE.
    //

    Enable = KeDisableInterrupts();
    DpcData = Dpc->DpcData;
    if (DpcData != NULL) {

        //
        // Acquire the DPC lock of the target processor.
        //

#if !defined(NT_UP)

        KiAcquireSpinLock(&DpcData->DpcLock);

#endif

        //
        // If the specified DPC is still in the DPC queue, then remove
        // it.
        //
        // N.B. It is possible for specified DPC to be removed from the
        //      specified DPC queue before the DPC lock is obtained.
        //
        //

        if (DpcData == Dpc->DpcData) {
            DpcData->DpcQueueDepth -= 1;
            RemoveEntryList(&Dpc->DpcListEntry);
            Dpc->DpcData = NULL;
        }

        //
        // Release the DPC lock of the target processor.
        //

#if !defined(NT_UP)

        KiReleaseSpinLock(&DpcData->DpcLock);

#endif

    }

    //
    // Enable interrupts and return whether the DPC was removed from a DPC
    // queue.
    //

    KeEnableInterrupts(Enable);
    return (DpcData != NULL ? TRUE : FALSE);
}

VOID
KeFlushQueuedDpcs (
    VOID
    )

/*++

Routine Description:

    This function causes all current DPCs on all processors to execute to
    completion. This function is used at driver unload to make sure all
    driver DPC processing has exited the driver image before the code and
    data is deleted.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    PKTHREAD CurrentThread;
    KPRIORITY OldPriority;
    KAFFINITY ProcessorMask;
    KAFFINITY SentDpcMask;
    KAFFINITY CurrentProcessorMask;
    BOOLEAN SetAffinity;
    ULONG CurrentProcessor;
    KIRQL OldIrql;

#endif

    PKPRCB CurrentPrcb;

    PAGED_CODE ();

#if defined(NT_UP)

    CurrentPrcb = KeGetCurrentPrcb();
    if ((CurrentPrcb->DpcData[DPC_NORMAL].DpcQueueDepth > 0) ||
        (CurrentPrcb->DpcData[DPC_THREADED].DpcQueueDepth > 0)) {
        KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
    }

#else

#if DBG

    if (KeActiveProcessors == (KAFFINITY)1) {
        CurrentPrcb = KeGetCurrentPrcb();
        if ((CurrentPrcb->DpcData[DPC_NORMAL].DpcQueueDepth > 0) ||
            (CurrentPrcb->DpcData[DPC_THREADED].DpcQueueDepth > 0)) {
            KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
        }
        return;
    }

#endif

    //
    // Set the priority of this thread high so it will run quickly on the
    // target processor.
    //

    CurrentThread = KeGetCurrentThread();
    OldPriority = KeSetPriorityThread(CurrentThread, HIGH_PRIORITY);
    ProcessorMask = KeActiveProcessors;
    SetAffinity = FALSE;
    SentDpcMask = 0;

    //
    // Clear the current processor from the affinity set and switch to the
    // remaining processors in the affinity set so it can be guaranteed that
    // respective DPCs have been completed processed.
    //

    while (1) {
       CurrentPrcb = KeGetCurrentPrcb();
       CurrentProcessor = CurrentPrcb->Number;
       CurrentProcessorMask = AFFINITY_MASK(CurrentProcessor);

       //
       // Check to determine if there are DPCs that haven't been delivered yet.
       // Low importance DPCs do not run right away and need to be forced to
       // run now. This only needs to do this once per processor.
       //

       if ((SentDpcMask & CurrentProcessorMask) == 0 &&
           (CurrentPrcb->DpcData[DPC_NORMAL].DpcQueueDepth > 0) || (CurrentPrcb->DpcData[DPC_THREADED].DpcQueueDepth > 0)) {

           SentDpcMask |= CurrentProcessorMask;
           KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
           KiSendSoftwareInterrupt(CurrentProcessorMask, DISPATCH_LEVEL);
           KeLowerIrql(OldIrql);

           //
           // If processors have not been swapped, then the DPCs must have run
           // to completion. If processors have been swapped, then just repeat
           // for the current processor.
           //

           if (KeGetCurrentPrcb() != CurrentPrcb) {
               continue;
           }
       }

       ProcessorMask &= ~CurrentProcessorMask;
       if (ProcessorMask == 0) {
           break;
       }

       KeSetSystemAffinityThread(ProcessorMask);
       SetAffinity = TRUE;
    }

    //
    // Restore the affinity of the current thread if it was changed and
    // restore the original thread priority.
    //

    if (SetAffinity) {
        KeRevertToUserAffinityThread ();
    }

    KeSetPriorityThread(CurrentThread, OldPriority);

#endif

    return;
}

VOID
KeGenericCallDpc (
    __in PKDEFERRED_ROUTINE Routine,
    __in_opt PVOID Context
    )

/*++

Routine Description:

    This function acquires the DPC call lock, initializes a processor specific
    DPC for each process with the specified deferred routine and context, and
    queues the DPC for execution. When all DPCs routines have executed, the
    DPC call lock is released.

Arguments:

    Routine - Supplies the address of the deferred routine to be called.

    Context - Supplies the context that is passed to the deferred routine.

Return Value:

    None.

--*/

{

    ULONG Barrier;

#if !defined(NT_UP)

    PKDPC Dpc;
    ULONG Index;
    ULONG Limit;
    ULONG Number;

#endif

    KIRQL OldIrql;
    DEFERRED_REVERSE_BARRIER ReverseBarrier;

    ASSERT(KeGetCurrentIrql () < DISPATCH_LEVEL);

    Barrier = KeNumberProcessors;
    ReverseBarrier.Barrier = Barrier;
    ReverseBarrier.TotalProcessors = Barrier;

#if !defined(NT_UP)

    Index = 0;
    Limit = Barrier;

#endif

    //
    // Switch to processor one to synchronize with other DPCs.
    //

#if !defined(NT_UP)

    KeSetSystemAffinityThread(1);

    //
    // Acquire generic call DPC mutex.
    //

    ExAcquireFastMutex(&KiGenericCallDpcMutex);

#endif

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

    //
    // Loop through all the target processors, initialize the deferred
    // routine address, context parameter, barrier parameter, and queue
    // the DPC to the target processor.
    //

#if !defined(NT_UP)

    Number = KeGetCurrentProcessorNumber();
    do {

        //
        // If the target processor is not the current processor, then
        // initialize and queue the generic call DPC.
        //

        if (Number != Index) {
            Dpc = &KiProcessorBlock[Index]->CallDpc;
            Dpc->DeferredRoutine = Routine;
            Dpc->DeferredContext = Context;
            KeInsertQueueDpc(Dpc, &Barrier, &ReverseBarrier);
        }

        Index += 1;
    } while (Index < Limit);

#endif

    //
    // Call deferred routine on current processor.
    //

    (Routine)(&KeGetCurrentPrcb()->CallDpc, Context, &Barrier, &ReverseBarrier);

    //
    // Wait for all target DPC routines to finish execution.
    //

#if !defined(NT_UP)

    while (*((ULONG volatile *)&Barrier) != 0) {
        KeYieldProcessor();
    }

#endif

    //
    // Release generic all DPC mutex and lower IRQL to previous level.
    //

    KeLowerIrql(OldIrql);

#if !defined(NT_UP)

    ExReleaseFastMutex(&KiGenericCallDpcMutex);
    KeRevertToUserAffinityThread();

#endif
    return;
}

VOID
KeSignalCallDpcDone (
    __in PVOID SystemArgument1
    )

/*++

Routine Description:

    This function decrements the generic DPC call barrier whose address
    was passed to the deferred DPC function as the first system argument.

Arguments:

    SystemArgument1 - Supplies the address of the call barrier.

    N.B. This must be the system argument value that is passed to the
         target deferred routine.

Return Value:

    None.

--*/

{

    InterlockedDecrement((LONG volatile *)SystemArgument1);
    return;
}

LOGICAL
KeSignalCallDpcSynchronize (
    __in PVOID SystemArgument2
    )

/*++

Routine Description:

    This function decrements the generic DPC call reverse barrier whose
    address was passed to the deferred DPC function as the second system
    argument.

Arguments:

    SystemArgument2 - Supplies the address of the call barrier.

    N.B. This must be the second system argument value that is passed to
         the target deferred routine.

Return Value:

    LOGICAL - Tie breaker value. One processor receives the value TRUE,
              all others receive FALSE.  

--*/

{

#if !defined(NT_UP)

    PDEFERRED_REVERSE_BARRIER ReverseBarrier = SystemArgument2;
    LONG volatile *Barrier;

    //
    // Wait while other processors exit any previous synchronization.
    //

    Barrier = (LONG volatile *)&ReverseBarrier->Barrier;
    while ((*Barrier & DEFERRED_REVERSE_BARRIER_SYNCHRONIZED) != 0) {
        KeYieldProcessor();
    }

    //
    // The barrier value is now of the form 1..MaxProcessors. Decrement this
    // processor's contribution and wait till the value goes to zero.
    //

    if (InterlockedDecrement(Barrier) == 0) {
        if (ReverseBarrier->TotalProcessors == 1) {
            InterlockedExchange(Barrier, ReverseBarrier->TotalProcessors);
        } else {
            InterlockedExchange(Barrier, DEFERRED_REVERSE_BARRIER_SYNCHRONIZED + 1);
        }
        return TRUE;
    }

    //
    // Wait until the last processor reaches this point.
    //

    while ((*Barrier & DEFERRED_REVERSE_BARRIER_SYNCHRONIZED) == 0) {
        KeYieldProcessor();
    }

    //
    // Signal other processors that the synchronization has occurred. If this
    // is the last processor, then reset the barrier.
    //

    if ((ULONG)InterlockedIncrement(Barrier) == (ReverseBarrier->TotalProcessors | DEFERRED_REVERSE_BARRIER_SYNCHRONIZED)) {
        InterlockedExchange(Barrier, ReverseBarrier->TotalProcessors);
    }

    return FALSE;

#else

    UNREFERENCED_PARAMETER(SystemArgument2);

    return TRUE;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\dpcsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    dpcsup.c

Abstract:

    This module contains the support routines for the system DPC objects.
    Functions are provided to process quantum end, the power notification
    queue, and timer expiration.

Environment:

    IRQL DISPATCH_LEVEL.

--*/

#include "ki.h"

//
// Define DPC entry structure and maximum DPC List size.
//

#define MAXIMUM_DPC_TABLE_SIZE 16

typedef struct _DPC_ENTRY {
    PRKDPC Dpc;
    PKDEFERRED_ROUTINE Routine;
    PVOID Context;
} DPC_ENTRY, *PDPC_ENTRY;

//
// Define maximum number of timers that can be examined or processed before
// dropping the dispatcher database lock.
//

#define MAXIMUM_TIMERS_EXAMINED 24
#define MAXIMUM_TIMERS_PROCESSED 4

VOID
KiExecuteDpc (
    IN PVOID Context
    )

/*++

Routine Description:

    This function is executed by the DPC thread for each processor. DPC
    threads are started during kernel initialization after having started
    all processors and it is determined that the host configuation should
    execute threaded DPCs in a DPC thread.
    
Arguments:

    Context - Supplies a pointer to the processor control block for the
        processor on which the DPC thread is to run.

Return Value:

    None.

--*/

{

    PKDPC Dpc;
    PVOID DeferredContext;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PERFINFO_DPC_INFORMATION DpcInformation;
    PLIST_ENTRY Entry;
    PLIST_ENTRY ListHead;
    LOGICAL Logging;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PKTHREAD Thread;
    LARGE_INTEGER TimeStamp = {0};

    //
    // Get PRCB and set the DPC thread address.
    //

    Prcb = Context; 
    Thread = KeGetCurrentThread();
    Prcb->DpcThread = Thread;

    //
    // Set the DPC thread priority to the highest level, set the thread
    // affinity, and enable threaded DPCs on this processor.
    //

    KeSetPriorityThread(Thread, HIGH_PRIORITY);
    KeSetSystemAffinityThread(Prcb->SetMember);
    Prcb->ThreadDpcEnable = TRUE;

    //
    // Loop processing DPC list entries until the specified DPC list is empty.
    //
    // N.B. This following code appears to have a redundant loop, but it does
    //      not. The point of this code is to avoid as many dispatch interrupts
    //      as possible.
    //

    ListHead = &Prcb->DpcData[DPC_THREADED].DpcListHead;
    do {
        Prcb->DpcThreadActive = TRUE;

        //
        // If the DPC list is not empty, then process the DPC list.
        //

        if (Prcb->DpcData[DPC_THREADED].DpcQueueDepth != 0) {

            //
            // Acquire the DPC lock for the current processor and check if
            // the DPC list is empty. If the DPC list is not empty, then
            // remove the first entry from the DPC list, capture the DPC
            // parameters, set the DPC inserted state false, decrement the
            // DPC queue depth, release the DPC lock, enable interrupts, and
            // call the specified DPC routine. Otherwise, release the DPC
            // lock and enable interrupts.
            //

            Logging = PERFINFO_IS_GROUP_ON(PERF_DPC);
            do {
                KeRaiseIrql(HIGH_LEVEL, &OldIrql);
                KeAcquireSpinLockAtDpcLevel(&Prcb->DpcData[DPC_THREADED].DpcLock);
                Entry = ListHead->Flink;
                if (Entry != ListHead) {
                    RemoveEntryList(Entry);
                    Dpc = CONTAINING_RECORD(Entry, KDPC, DpcListEntry);
                    DeferredRoutine = Dpc->DeferredRoutine;
                    DeferredContext = Dpc->DeferredContext;
                    SystemArgument1 = Dpc->SystemArgument1;
                    SystemArgument2 = Dpc->SystemArgument2;
                    Dpc->DpcData = NULL;
                    Prcb->DpcData[DPC_THREADED].DpcQueueDepth -= 1;
                    KeReleaseSpinLockFromDpcLevel(&Prcb->DpcData[DPC_THREADED].DpcLock);
                    KeLowerIrql(OldIrql);

                    //
                    // If event tracing is enabled, capture the start time.
                    //

                    if (Logging != FALSE) {
                        PerfTimeStamp(TimeStamp);
                    }

                    //
                    // Call the DPC routine.
                    //

                    (DeferredRoutine)(Dpc,
                                      DeferredContext,
                                      SystemArgument1,
                                      SystemArgument2);

                    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

                    ASSERT(Thread->Affinity == Prcb->SetMember);

                    ASSERT(Thread->Priority == HIGH_PRIORITY);

                    //
                    // If event tracing is enabled, then log the start time
                    // and routine address.
                    //

                    if (Logging != FALSE) {
                        DpcInformation.InitialTime = TimeStamp.QuadPart;
                        DpcInformation.DpcRoutine = (PVOID)(ULONG_PTR)DeferredRoutine;
                        PerfInfoLogBytes(PERFINFO_LOG_TYPE_DPC,
                                         &DpcInformation,
                                         sizeof(DpcInformation));
                    }

                } else {

                    ASSERT(Prcb->DpcData[DPC_THREADED].DpcQueueDepth == 0);

                    KeReleaseSpinLockFromDpcLevel(&Prcb->DpcData[DPC_THREADED].DpcLock);
                    KeLowerIrql(OldIrql);
                }

            } while (Prcb->DpcData[DPC_THREADED].DpcQueueDepth != 0);
        }

        Prcb->DpcThreadActive = FALSE;
        Prcb->DpcThreadRequested = FALSE;
        KeMemoryBarrier();

        //
        // If the thread DPC list is empty, then wait until the DPC event
        // for the current processor is set.
        //

        if (Prcb->DpcData[DPC_THREADED].DpcQueueDepth == 0) {
            KeWaitForSingleObject(&Prcb->DpcEvent, 
                                  Suspended,               
                                  KernelMode, 
                                  FALSE,
                                  NULL);
     
        }

    } while (TRUE);

    return;
}

VOID
KiQuantumEnd (
    VOID
    )

/*++

Routine Description:

    This function is called when a quantum end event occurs on the current
    processor. Its function is to determine whether the thread priority should
    be decremented and whether a redispatch of the processor should occur.

    N.B. This function is called at DISPATCH level and returns at DISPATCH
         level.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;
    PKPROCESS Process;
    PRKTHREAD Thread;
    PRKTHREAD NewThread;

    //
    // If DPC thread activation is requested, then set the DPC event.
    //

    Prcb = KeGetCurrentPrcb();
    Thread = KeGetCurrentThread();
    if (InterlockedExchange(&Prcb->DpcSetEventRequest, FALSE) == TRUE) {
        KeSetEvent(&Prcb->DpcEvent, 0, FALSE);
    }

    //
    // Raise IRQL to SYNCH level, acquire the thread lock, and acquire the
    // PRCB lock.
    //
    // If the quantum has expired for the current thread, then update its
    // quantum and priority.
    //

    KeRaiseIrqlToSynchLevel();
    KiAcquireThreadLock(Thread);
    KiAcquirePrcbLock(Prcb);
    if (Thread->Quantum <= 0) {

        //
        // If quantum runout is disabled for the thread's process and
        // the thread is running at a realtime priority, then set the
        // thread quantum to the highest value and do not round robin
        // at the thread's priority level. Otherwise, reset the thread
        // quantum and decay the thread's priority as appropriate.
        //

        Process = Thread->ApcState.Process;
        if ((Process->DisableQuantum != FALSE) &&
            (Thread->Priority >= LOW_REALTIME_PRIORITY)) {

            Thread->Quantum = MAXCHAR;

        } else {
            Thread->Quantum = Thread->QuantumReset;

            //
            // Compute the new thread priority and attempt to reschedule the
            // current processor.
            //
            // N.B. The new priority will never be greater than the previous
            //      priority.
            //

            Thread->Priority = KiComputeNewPriority(Thread, 1);
            if (Prcb->NextThread == NULL) {
                if ((NewThread = KiSelectReadyThread(Thread->Priority, Prcb)) != NULL) {
                    NewThread->State = Standby;
                    Prcb->NextThread = NewThread;
                }

            } else {
                Thread->Preempted = FALSE;
            }
        }
    }

    //
    // Release the thread lock.
    //
    // If a thread was scheduled for execution on the current processor, then
    // acquire the PRCB lock, set the current thread to the new thread, set
    // next thread to NULL, set the thread state to running, release the PRCB
    // lock, set the wait reason, ready the old thread, and swap context to
    // the new thread.
    //

    KiReleaseThreadLock(Thread);
    if (Prcb->NextThread != NULL) {
        KiSetContextSwapBusy(Thread);
        NewThread = Prcb->NextThread;
        Prcb->NextThread = NULL;
        Prcb->CurrentThread = NewThread;
        NewThread->State = Running;
        Thread->WaitReason = WrQuantumEnd;
        KxQueueReadyThread(Thread, Prcb);
        Thread->WaitIrql = APC_LEVEL;
        KiSwapContext(Thread, NewThread);

    } else {
        KiReleasePrcbLock(Prcb);
    }

    //
    // Lower IRQL to DISPATCH level and return.
    //

    KeLowerIrql(DISPATCH_LEVEL);
    return;
}

#if DBG

VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER CurrentTime
    )

{

    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;

    //
    // Raise IRQL to highest level and scan timer table for timers that
    // have expired.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index].Entry;
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            NextEntry = NextEntry->Flink;
            if (Timer->DueTime.QuadPart <= CurrentTime.QuadPart) {

                //
                // If the timer expiration DPC is queued, then the time has
                // been change and the DPC has not yet had the chance to run
                // and clear out the expired timers.
                //

                if ((KeGetCurrentPrcb()->TimerRequest == 0) &&
                    *((volatile PKSPIN_LOCK *)(&KiTimerExpireDpc.DpcData)) == NULL) {
                    DbgBreakPoint();
                }
            }
        }

        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);

    //
    // Lower IRQL to the previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

#endif

FORCEINLINE
VOID
KiProcessTimerDpcTable (
    IN PULARGE_INTEGER SystemTime,
    IN PDPC_ENTRY DpcTable,
    IN ULONG Count
    )

/**++

Routine Description:

    This function processes the time DPC table which is a array of DPCs that
    are to be called on the current processor.

    N.B. This routine is entered with the dispatcher database locked.

    N.B. This routine returns with the dispatcher database unlocked.

Arguments:

    SystemTime - Supplies a pointer to the timer expiration time.

    DpcTable - Supplies a pointer to an array of DPC entries.

    Count - Supplies a count of the number of entries in the DPC table.

Return Value:

    None.

--*/

{

    PERFINFO_DPC_INFORMATION DpcInformation;
    LOGICAL Logging;
    LARGE_INTEGER TimeStamp = {0};

    //
    // Unlock the dispatcher database and lower IRQL to dispatch level.
    //

    KiUnlockDispatcherDatabase(DISPATCH_LEVEL);

    //
    // Process DPC table entries.
    //

    Logging = PERFINFO_IS_GROUP_ON(PERF_DPC);
    while (Count != 0) {

        //
        // Reset the debug DPC count to avoid a timeout and breakpoint.
        //

#if DBG

        KeGetCurrentPrcb()->DebugDpcTime = 0;

#endif

        //
        // If event tracing is enabled, capture the start time.
        //

        if (Logging != FALSE) {
            PerfTimeStamp(TimeStamp);
        }

        //
        // Call the DPC routine.
        //

        (DpcTable->Routine)(DpcTable->Dpc,
                            DpcTable->Context,
                            ULongToPtr(SystemTime->LowPart),
                            ULongToPtr(SystemTime->HighPart));

        //
        // If event tracing is enabled, then log the start time and
        // routine address.
        //

        if (Logging != FALSE) {
            DpcInformation.InitialTime = TimeStamp.QuadPart;
            DpcInformation.DpcRoutine = (PVOID)(ULONG_PTR)DpcTable->Routine;
            PerfInfoLogBytes(PERFINFO_LOG_TYPE_TIMERDPC,
                             &DpcInformation,
                             sizeof(DpcInformation));
        }

        DpcTable += 1;
        Count -= 1;
    }

    return;
}

VOID
KiTimerExpiration (
    IN PKDPC TimerDpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called when the clock interupt routine discovers that
    a timer has expired.

    N.B. This function executes on the same processor that receives clock
         interrupts.

Arguments:

    TimerDpc - Not used.

    DeferredContext - Not used.

    SystemArgument1 - Supplies the starting timer table index value to
        use for the timer table scan.

    SystemArgument2 - Not used.

Return Value:

    None.

--*/

{

    ULARGE_INTEGER CurrentTime;
    ULONG DpcCount;
    PKDPC Dpc;
    DPC_ENTRY DpcTable[MAXIMUM_TIMERS_PROCESSED];
    KIRQL DummyIrql;
    LONG HandLimit;
    LONG Index;
    LARGE_INTEGER Interval;
    PLIST_ENTRY ListHead;
    PKSPIN_LOCK_QUEUE LockQueue;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    LONG Period;

#if !defined(NT_UP) || defined(_WIN64)

    PKPRCB Prcb = KeGetCurrentPrcb();

#endif

    ULARGE_INTEGER SystemTime;
    PKTIMER Timer;
    ULONG TimersExamined;
    ULONG TimersProcessed;

    UNREFERENCED_PARAMETER(TimerDpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument2);

    //
    // Capture the timer expiration time, the current interrupt time, and
    // the low tick count.
    //
    // N.B. Interrupts are disabled to ensure that interrupt activity on the
    //      current processor does not cause the values read to be skewed.
    //

    _disable();
    KiQuerySystemTime((PLARGE_INTEGER)&SystemTime);
    KiQueryInterruptTime((PLARGE_INTEGER)&CurrentTime);
    HandLimit = (LONG)KiQueryLowTickCount();
    _enable();

    //
    // If the timer table has not wrapped, then start with the specified
    // timer table index value, and scan for timer entries that have expired.
    // Otherwise, start with the specified timer table index value and scan
    // the entire table for timer entries that have expired.
    //
    // N.B. This later condition exists when DPC processing is blocked for a
    //      period longer than one round trip throught the timer table.
    //
    // N.B. The current instance of the timer expiration execution will only
    //      process the timer queue entries specified by the computed index
    //      and hand limit. If another timer expires while the current scan
    //      is in progress, then another scan will occur when the current one
    //      is finished.
    //

    Index = PtrToLong(SystemArgument1);
    if ((ULONG)(HandLimit - Index) >= TIMER_TABLE_SIZE) {
        HandLimit = Index + TIMER_TABLE_SIZE - 1;
    }

    Index -= 1;
    HandLimit &= (TIMER_TABLE_SIZE - 1);

    //
    // Acquire the dispatcher database lock and read the current interrupt
    // time to determine which timers have expired.
    //

    DpcCount = 0;
    TimersExamined = MAXIMUM_TIMERS_EXAMINED;
    TimersProcessed = MAXIMUM_TIMERS_PROCESSED;
    KiLockDispatcherDatabase(&OldIrql);
    do {
        Index = (Index + 1) & (TIMER_TABLE_SIZE - 1);
        ListHead = &KiTimerTableListHead[Index].Entry;
        while (ListHead != ListHead->Flink) {
            LockQueue = KiAcquireTimerTableLock(Index);
            NextEntry = ListHead->Flink;
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            TimersExamined -= 1;
            if ((NextEntry != ListHead) &&
                (Timer->DueTime.QuadPart <= CurrentTime.QuadPart)) {

                //
                // The next timer in the current timer list has expired.
                // Remove the entry from the timer tree and set the signal
                // state of the timer.
                //

                TimersProcessed -= 1;
                KiRemoveEntryTimer(Timer);
                Timer->Header.Inserted = FALSE;
                KiReleaseTimerTableLock(LockQueue);
                Timer->Header.SignalState = 1;

                //
                // Capture the DPC and period fields from the timer object.
                // Once wait test is called, the timer must not be touched
                // again unless it is periodic. The reason for this is that
                // a thread may allocate a timer on its local stack and wait
                // on it. Wait test can cause that thread to immediately
                // start running on another processor on an MP system. If
                // the thread returns, then the timer will be corrupted.
                // 
        
                Dpc = Timer->Dpc;
                Period = Timer->Period;
                if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
                    if (Timer->Header.Type == TimerNotificationObject) {
                        KiWaitTestWithoutSideEffects(Timer, TIMER_EXPIRE_INCREMENT);

                    } else {
                        KiWaitTestSynchronizationObject(Timer, TIMER_EXPIRE_INCREMENT);
                    }
                }

                //
                // If the timer is periodic, then compute the next interval
                // time and reinsert the timer in the timer tree.
                //
                // N.B. Even though the timer insertion is relative, it can
                //      still fail if the period of the timer elapses in
                //      between computing the time and inserting the timer.
                //      If this happens, then the insertion is retried.
                //

                if (Period != 0) {
                    Interval.QuadPart = Int32x32To64(Period, - 10 * 1000);
                    do {
                    } while (KiInsertTreeTimer(Timer, Interval) == FALSE);
                }

                //
                // If a DPC is specified, then insert it in the target
                // processor's DPC queue or capture the parameters in
                // the DPC table for subsequent execution on the current
                // processor.
                //

                if (Dpc != NULL) {

#if defined(NT_UP)

                    DpcTable[DpcCount].Dpc = Dpc;
                    DpcTable[DpcCount].Routine = Dpc->DeferredRoutine;
                    DpcTable[DpcCount].Context = Dpc->DeferredContext;
                    DpcCount += 1;

#else

                    if (((Dpc->Number >= MAXIMUM_PROCESSORS) &&
                         (((LONG)Dpc->Number - MAXIMUM_PROCESSORS) != Prcb->Number)) ||
                        ((Dpc->Type == (UCHAR)ThreadedDpcObject) &&
                         (Prcb->ThreadDpcEnable != FALSE))) {

                        KeInsertQueueDpc(Dpc,
                                         ULongToPtr(SystemTime.LowPart),
                                         ULongToPtr(SystemTime.HighPart));
        
                    } else {
                        DpcTable[DpcCount].Dpc = Dpc;
                        DpcTable[DpcCount].Routine = Dpc->DeferredRoutine;
                        DpcTable[DpcCount].Context = Dpc->DeferredContext;
                        DpcCount += 1;
                    }

#endif

                }

                //
                // If the maximum number of timers have been processed or
                // the maximum number of timers have been examined, then
                // drop the dispatcher lock and process the DPC table.
                //

                if ((TimersProcessed == 0) || (TimersExamined == 0)) {
                    KiProcessTimerDpcTable(&SystemTime, &DpcTable[0], DpcCount);

                    //
                    // Initialize the DPC count, the scan counters, and
                    // acquire the dispatcher database lock.
                    //
                    // N.B. Control is returned with the dispatcher database
                    //      unlocked.
                    //

                    DpcCount = 0;
                    TimersExamined = MAXIMUM_TIMERS_EXAMINED;
                    TimersProcessed = MAXIMUM_TIMERS_PROCESSED;

#if defined(_WIN64)

                    if (KiTryToLockDispatcherDatabase(&DummyIrql) == FALSE) {
                        Prcb->TimerHand = 0x100000000I64 + Index;
                        return;
                    }

#else

                    KiLockDispatcherDatabase(&DummyIrql);

#endif

                }

            } else {

                //
                // If the timer table list is not empty, then set the due time
                // to the first entry in the respective timer table entry.
                //
                // N.B. On the x86 the write of the due time is not atomic.
                //      Therefore, interrupts must be disabled to synchronize
                //      with the clock interrupt so the clock interupt code
                //      does not observe a partial update of the due time.
                //
                // Release the timer table lock.
                //

                if (NextEntry != ListHead) {

                    ASSERT(KiTimerTableListHead[Index].Time.QuadPart <= Timer->DueTime.QuadPart);

#if defined(_X86_)

                    _disable();
                    KiTimerTableListHead[Index].Time.QuadPart = Timer->DueTime.QuadPart;
                    _enable();

#else

                    KiTimerTableListHead[Index].Time.QuadPart = Timer->DueTime.QuadPart;

#endif

                }

                KiReleaseTimerTableLock(LockQueue);

                //
                // If the maximum number of timers have been scanned, then
                // drop the dispatcher lock and process the DPC table.
                //

                if (TimersExamined == 0) {
                    KiProcessTimerDpcTable(&SystemTime, &DpcTable[0], DpcCount);

                    //
                    // Initialize the DPC count, the scan counters, and
                    // acquire the dispatcher database lock.
                    //
                    // N.B. Control is returned with the dispatcher database
                    //      unlocked.
                    //

                    DpcCount = 0;
                    TimersExamined = MAXIMUM_TIMERS_EXAMINED;
                    TimersProcessed = MAXIMUM_TIMERS_PROCESSED;

#if defined(_WIN64)

                    if (KiTryToLockDispatcherDatabase(&DummyIrql) == FALSE) {
                        Prcb->TimerHand = 0x100000000I64 + Index;
                        return;
                    }

#else

                    KiLockDispatcherDatabase(&DummyIrql);

#endif

                }

                break;
            }
        }

    } while(Index != HandLimit);

#if DBG

    if (KeNumberProcessors == 1) {
        KiCheckTimerTable(CurrentTime);
    }

#endif

    //
    // If the DPC table is not empty, then process the remaining DPC table
    // entries and lower IRQL. Otherwise, unlock the dispatcher database.
    //
    // N.B. Control is returned from the DPC processing routine with the
    //      dispatcher database unlocked.
    //

    if (DpcCount != 0) {
        KiProcessTimerDpcTable(&SystemTime, &DpcTable[0], DpcCount);
        if (OldIrql != DISPATCH_LEVEL) {
            KeLowerIrql(OldIrql);
        }

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return;
}

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function is called to process a list of timers that have expired.

    N.B. This function is called with the dispatcher database locked and
        returns with the dispatcher database unlocked.

Arguments:

    ExpiredListHead - Supplies a pointer to a list of timers that have
        expired.

    OldIrql - Supplies the previous IRQL.

Return Value:

    None.

--*/

{

    LONG Count;
    PKDPC Dpc;
    DPC_ENTRY DpcTable[MAXIMUM_DPC_TABLE_SIZE];
    LARGE_INTEGER Interval;
    KIRQL OldIrql1;

#if !defined(NT_UP)

    PKPRCB Prcb = KeGetCurrentPrcb();

#endif

    ULARGE_INTEGER SystemTime;
    PKTIMER Timer;
    LONG Period;

    //
    // Capture the timer expiration time.
    //

    KiQuerySystemTime((PLARGE_INTEGER)&SystemTime);

    //
    // Remove the next timer from the expired timer list, set the state of
    // the timer to signaled, reinsert the timer in the timer tree if it is
    // periodic, and optionally call the DPC routine if one is specified.
    //

RestartScan:
    Count = 0;
    while (ExpiredListHead->Flink != ExpiredListHead) {
        Timer = CONTAINING_RECORD(ExpiredListHead->Flink, KTIMER, TimerListEntry);
        RemoveEntryList(&Timer->TimerListEntry);

#if DBG

        Timer->TimerListEntry.Flink = NULL;
        Timer->TimerListEntry.Blink = NULL;

#endif

        Timer->Header.Inserted = FALSE;
        Timer->Header.SignalState = 1;

        //
        // Capture the DPC and period fields from the timer object. Once wait
        // test is called, the timer must not be touched again unless it is
        // periodic. The reason for this is that a thread may allocate a timer
        // on its local stack and wait on it. Wait test can cause that thread
        // to immediately start running on another processor on an MP system.
        // If the thread returns, then the timer will be corrupted.
        // 
        
        Dpc = Timer->Dpc;
        Period = Timer->Period;
        if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
            if (Timer->Header.Type == TimerNotificationObject) {
                KiWaitTestWithoutSideEffects(Timer, TIMER_EXPIRE_INCREMENT);

            } else {
                KiWaitTestSynchronizationObject(Timer, TIMER_EXPIRE_INCREMENT);
            }
        }

        //
        // If the timer is periodic, then compute the next interval time
        // and reinsert the timer in the timer tree.
        //
        // N.B. Even though the timer insertion is relative, it can still
        //      fail if the period of the timer elapses in between computing
        //      the time and inserting the timer. If this happens, then the
        //      insertion is retried.
        //

        if (Period != 0) {
            Interval.QuadPart = Int32x32To64(Period, - 10 * 1000);
            do {
            } while (KiInsertTreeTimer(Timer, Interval) == FALSE);
        }

        //
        // If a DPC is specified, then insert it in the target  processor's
        // DPC queue or capture the parameters in the DPC table for subsequent
        // execution on the current processor.
        //

        if (Dpc != NULL) {

            //
            // If the DPC is explicitly targeted to another processor, then
            // queue the DPC to the target processor. Otherwise, capture the
            // DPC parameters for execution on the current processor.
            //

#if defined(NT_UP)

            DpcTable[Count].Dpc = Dpc;
            DpcTable[Count].Routine = Dpc->DeferredRoutine;
            DpcTable[Count].Context = Dpc->DeferredContext;
            Count += 1;
            if (Count == MAXIMUM_DPC_TABLE_SIZE) {
                break;
            }

#else

            if (((Dpc->Number >= MAXIMUM_PROCESSORS) &&
                 (((LONG)Dpc->Number - MAXIMUM_PROCESSORS) != Prcb->Number)) ||
                ((Dpc->Type == (UCHAR)ThreadedDpcObject) &&
                 (Prcb->ThreadDpcEnable != FALSE))) {

                KeInsertQueueDpc(Dpc,
                                 ULongToPtr(SystemTime.LowPart),
                                 ULongToPtr(SystemTime.HighPart));
        
            } else {
                DpcTable[Count].Dpc = Dpc;
                DpcTable[Count].Routine = Dpc->DeferredRoutine;
                DpcTable[Count].Context = Dpc->DeferredContext;
                Count += 1;
                if (Count == MAXIMUM_DPC_TABLE_SIZE) {
                    break;
                }
            }

#endif

        }
    }

    //
    // Unlock the dispatcher database and process DPC list entries.
    //

    if (Count != 0) {
        KiProcessTimerDpcTable(&SystemTime, &DpcTable[0], Count);

        //
        // If processing of the expired timer list was terminated because
        // the DPC List was full, then process any remaining entries.
        //

        if (Count == MAXIMUM_DPC_TABLE_SIZE) {
            KiLockDispatcherDatabase(&OldIrql1);
            goto RestartScan;
        }

        KeLowerIrql(OldIrql);

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return;
}

VOID
FASTCALL
KiRetireDpcList (
    PKPRCB Prcb
    )

/*++

Routine Description:

    This function processes the DPC list for the specified processor,
    processes timer expiration, and processes the deferred ready list.

    N.B. This function is entered with interrupts disabled and exits with
         interrupts disabled.

Arguments:

    Prcb - Supplies the address of the processor block.

Return Value:

    None.

--*/

{

    PKDPC Dpc;
    PKDPC_DATA DpcData;
    PVOID DeferredContext;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PERFINFO_DPC_INFORMATION DpcInformation;
    PLIST_ENTRY Entry;
    PLIST_ENTRY ListHead;
    LOGICAL Logging;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    ULONG_PTR TimerHand;
    LARGE_INTEGER TimeStamp = {0};

    //
    // Loop processing DPC list entries until the specified DPC list is empty.
    //
    // N.B. This following code appears to have a redundant loop, but it does
    //      not. The point of this code is to avoid as many dispatch interrupts
    //      as possible.
    //

    DpcData = &Prcb->DpcData[DPC_NORMAL];
    ListHead = &DpcData->DpcListHead;
    Logging = PERFINFO_IS_GROUP_ON(PERF_DPC);
    do {
        Prcb->DpcRoutineActive = TRUE;

        //
        // If the timer hand value is nonzero, then process expired timers.
        //

        if (Prcb->TimerRequest != 0) {
            TimerHand = Prcb->TimerHand;
            Prcb->TimerRequest = 0;
            _enable();
            KiTimerExpiration(NULL, NULL, (PVOID) TimerHand, NULL);
            _disable();
        }

        //
        // If the DPC list is not empty, then process the DPC list.
        //

        if (DpcData->DpcQueueDepth != 0) {

            //
            // Acquire the DPC lock for the current processor and check if
            // the DPC list is empty. If the DPC list is not empty, then
            // remove the first entry from the DPC list, capture the DPC
            // parameters, set the DPC inserted state false, decrement the
            // DPC queue depth, release the DPC lock, enable interrupts, and
            // call the specified DPC routine. Otherwise, release the DPC
            // lock and enable interrupts.
            //

            do {
                KeAcquireSpinLockAtDpcLevel(&DpcData->DpcLock);
                Entry = ListHead->Flink;
                if (Entry != ListHead) {
                    RemoveEntryList(Entry);
                    Dpc = CONTAINING_RECORD(Entry, KDPC, DpcListEntry);
                    DeferredRoutine = Dpc->DeferredRoutine;
                    DeferredContext = Dpc->DeferredContext;
                    SystemArgument1 = Dpc->SystemArgument1;
                    SystemArgument2 = Dpc->SystemArgument2;
                    Dpc->DpcData = NULL;
                    DpcData->DpcQueueDepth -= 1;

#if DBG

                    Prcb->DebugDpcTime = 0;

#endif

                    KeReleaseSpinLockFromDpcLevel(&DpcData->DpcLock);
                    _enable();

                    //
                    // If event tracing is enabled, capture the start time.
                    //

                    if (Logging != FALSE) {
                        PerfTimeStamp(TimeStamp);
                    }

                    //
                    // Call the DPC routine.
                    //

                    (DeferredRoutine)(Dpc,
                                      DeferredContext,
                                      SystemArgument1,
                                      SystemArgument2);

                    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

                    //
                    // If event tracing is enabled, then log the start time
                    // and routine address.
                    //

                    if (Logging != FALSE) {
                        DpcInformation.InitialTime = TimeStamp.QuadPart;
                        DpcInformation.DpcRoutine = (PVOID) (ULONG_PTR) DeferredRoutine;
                        PerfInfoLogBytes(PERFINFO_LOG_TYPE_DPC,
                                         &DpcInformation,
                                         sizeof(DpcInformation));
                    }

                    _disable();

                } else {

                    ASSERT(DpcData->DpcQueueDepth == 0);

                    KeReleaseSpinLockFromDpcLevel(&DpcData->DpcLock);
                }

            } while (DpcData->DpcQueueDepth != 0);
        }

        Prcb->DpcRoutineActive = FALSE;
        Prcb->DpcInterruptRequested = FALSE;
        KeMemoryBarrier();

        //
        // Process the deferred ready list if the list is not empty.
        //

#if !defined(NT_UP)

        if (Prcb->DeferredReadyListHead.Next != NULL) {

            KIRQL OldIrql;

            _enable();
            OldIrql = KeRaiseIrqlToSynchLevel();
            KiProcessDeferredReadyList(Prcb);
            KeLowerIrql(OldIrql);
            _disable();
        }
#endif

#if defined(_WIN64)

    } while ((DpcData->DpcQueueDepth != 0) || (Prcb->TimerRequest != 0));

#else

    } while (DpcData->DpcQueueDepth != 0);

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\hifreqlk.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    hifreqlk.c

Abstract:

    This module contains the declaration and allocation of high frequency
    spin locks.

--*/

#include "ki.h"

#if !defined(NT_UP)

#pragma data_seg("SPINLOCK")

#endif

//
// Cache manager spin locks.
//

ALIGNED_SPINLOCK CcMasterSpinLock = 0;
ALIGNED_SPINLOCK CcWorkQueueSpinLock = 0;
ALIGNED_SPINLOCK CcVacbSpinLock = 0;
ALIGNED_SPINLOCK CcDeferredWriteSpinLock = 0;
ALIGNED_SPINLOCK CcDebugTraceLock = 0;
ALIGNED_SPINLOCK CcBcbSpinLock = 0;

//
// Execute spin locks.
//

ALIGNED_SPINLOCK NonPagedPoolLock = 0;
ALIGNED_SPINLOCK ExpResourceSpinLock = 0;

//
// I/O spin locks.
//

ALIGNED_SPINLOCK IopCompletionLock = 0;
ALIGNED_SPINLOCK IopCancelSpinLock = 0;
ALIGNED_SPINLOCK IopVpbSpinLock = 0;
ALIGNED_SPINLOCK IopDatabaseLock = 0;
ALIGNED_SPINLOCK IopErrorLogLock = 0;
ALIGNED_SPINLOCK IopTimerLock = 0;
ALIGNED_SPINLOCK IoStatisticsLock = 0;

//
// Kernel debugger spin locks.
//

ALIGNED_SPINLOCK KdpDebuggerLock = 0;

//
// Kernel spin locks.
//

ALIGNED_SPINLOCK KiDispatcherLock = 0;
ALIGNED_SPINLOCK KiFreezeExecutionLock = 0;
ALIGNED_SPINLOCK KiFreezeLockBackup = 0;
ALIGNED_SPINLOCK KiProcessListLock = 0;
ALIGNED_SPINLOCK KiProfileLock = 0;
ALIGNED_SPINLOCK KiReverseStallIpiLock = 0;
ALIGNED_SPINLOCK_STRUCT KiTimerTableLock[LOCK_QUEUE_TIMER_TABLE_LOCKS] = {0};

#if defined(_AMD64_)

ALIGNED_SPINLOCK KiNMILock = 0;

#endif

//
// Memory management spin locks.
//

ALIGNED_SPINLOCK MmPfnLock = 0;
ALIGNED_SPINLOCK MmSystemSpaceLock = 0;
ALIGNED_SPINLOCK MmNonPagedPoolLock = 0;

//
// Process structure spin locks.
//

ALIGNED_SPINLOCK PsLoadedModuleSpinLock = 0;

//
// Ntfs spin locks.
//

ALIGNED_SPINLOCK NtfsStructLock = 0;

//
// Afd spin locks.
//

ALIGNED_SPINLOCK AfdWorkQueueSpinLock = 0;

//
// Dummy lock for alignment.
//

ALIGNED_SPINLOCK KiDummyLock = 0;

#pragma data_seg()

//
// Hardware trigger.
//

volatile LONG KiHardwareTrigger = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\gateobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    gateobj.c

Abstract:

    This module implements the kernel gate object. Functions are provided to
    initialize, signal, and wait for gate objects.

--*/

#include "ki.h"

VOID
FASTCALL
KeInitializeGate (
    __out PKGATE Gate
    )

/*++

Routine Description:

    This function initializes a kernel gate object.

Arguments:

    Gate - Supplies a pointer to a dispatcher object of type gate.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header.
    //

    Gate->Header.Type = (UCHAR)GateObject;
    Gate->Header.Size = sizeof(KGATE) / sizeof(LONG);
    Gate->Header.SignalState = 0;
    InitializeListHead(&Gate->Header.WaitListHead);
    return;
}

VOID
FASTCALL
KeSignalGateBoostPriority (
    __inout PKGATE Gate
    )

/*++

Routine Description:

    This function conditionally sets the signal state of a gate object and
    attempts to unwait the first waiter.

Arguments:

    Gate - Supplies a pointer to a dispatcher object of type gate.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    PLIST_ENTRY Entry;
    KIRQL OldIrql;
    SCHAR Priority;
    PKQUEUE Queue;
    PKWAIT_BLOCK WaitBlock;
    PKTHREAD WaitThread;

    ASSERT_GATE(Gate);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the object lock.
    //
    // If the object is not already signaled, then attempt to wake a waiter.
    //

    CurrentThread = KeGetCurrentThread();
    do {
        OldIrql = KeRaiseIrqlToSynchLevel();
        KiAcquireKobjectLock(Gate);
        if (Gate->Header.SignalState == 0) {
    
            //
            // If there are any waiters, then remove and ready the first
            // waiter. Otherwise, set the signal state.
            //
    
            if (IsListEmpty(&Gate->Header.WaitListHead) == FALSE) {
                Entry = Gate->Header.WaitListHead.Flink;
                WaitBlock = CONTAINING_RECORD(Entry, KWAIT_BLOCK, WaitListEntry);
                WaitThread = WaitBlock->Thread;

                //
                // Try to acquire the thread lock.
                //
                // If the thread lock cannot be acquired, then release the
                // object lock, lower IRQL to is previous value, and try to
                // signal the gate again. Otherwise, remove the entry from
                // the list, set the wait completion status to success, set
                // the deferred processor number, set the thread state to
                // deferred ready, release the thread lock, release the
                // object lock, compute the new thread priority, ready the
                // thread for execution, and exit the dispatcher.
                //

                if (KiTryToAcquireThreadLock(WaitThread)) {
                    RemoveEntryList(Entry);
                    WaitThread->WaitStatus = STATUS_SUCCESS;
                    WaitThread->State = DeferredReady;
                    WaitThread->DeferredProcessor = KeGetCurrentPrcb()->Number;
                    KiReleaseKobjectLock(Gate);
                    KiReleaseThreadLock(WaitThread);
                    Priority = CurrentThread->Priority;
                    if (Priority < LOW_REALTIME_PRIORITY) {
                        Priority = Priority - CurrentThread->PriorityDecrement;
                        if (Priority < CurrentThread->BasePriority) {
                            Priority = CurrentThread->BasePriority;
                        }

                        if (CurrentThread->PriorityDecrement != 0) {
                            CurrentThread->PriorityDecrement = 0;
                            CurrentThread->Quantum = CLOCK_QUANTUM_DECREMENT;
                        }
                    }

                    WaitThread->AdjustIncrement = Priority;
                    WaitThread->AdjustReason = (UCHAR)AdjustBoost;

                    //
                    // If the wait thread is associated with a queue, then
                    // increment the concurrency level.
                    //
                    // N.B. This can be done after dropping all other locks,
                    //      but must be done holding the dispatcher lock
                    //      since the concurrency count is not accessed with
                    //      interlocked operations elsewhere.
                    //    

                    if (WaitThread->Queue != NULL) {
                        KiLockDispatcherDatabaseAtSynchLevel();
                        if ((Queue = WaitThread->Queue) != NULL) {
                            Queue->CurrentCount += 1;
                        }

                        KiUnlockDispatcherDatabaseFromSynchLevel();
                    }

                    KiDeferredReadyThread(WaitThread);
                    KiExitDispatcher(OldIrql);
                    return;

                } else {
                    KiReleaseKobjectLock(Gate);
                    KeLowerIrql(OldIrql);
                    continue;
                }

    
            } else {
                Gate->Header.SignalState = 1;
                break;
            }

        } else {
            break;
        }

    } while (TRUE);

    //
    // Release the object lock and lower IRQL to its previous value.
    //

    KiReleaseKobjectLock(Gate);
    KeLowerIrql(OldIrql);
    return;
}

VOID
FASTCALL
KeWaitForGate (
    __inout PKGATE Gate,
    __in KWAIT_REASON WaitReason,
    __in KPROCESSOR_MODE WaitMode
    )

/*++

Routine Description:

    This function waits until the signal state of a gate object is set. If
    the state of the gate object is signaled when the wait is executed, then
    no wait will occur.

Arguments:

    Gate - Supplies a pointer to a dispatcher object of type Gate.

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    KLOCK_QUEUE_HANDLE LockHandle;
    PKQUEUE Queue;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;

    ASSERT_GATE(Gate);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the APC queue lock.
    //

    CurrentThread = KeGetCurrentThread();
    do {
        KeAcquireInStackQueuedSpinLockRaiseToSynch(&CurrentThread->ApcQueueLock,
                                                   &LockHandle);

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending, the special APC disable count is zero,
        // and the previous IRQL was less than APC_LEVEL, then a kernel APC
        // was queued by another processor just after IRQL was raised to
        // SYNCH_LEVEL, but before the APC queue lock was acquired.
        //
        // N.B. This can only happen in a multiprocessor system.
        //

        if (CurrentThread->ApcState.KernelApcPending &&
            (CurrentThread->SpecialApcDisable == 0) &&
            (LockHandle.OldIrql < APC_LEVEL)) {

            //
            // Unlock the APC queue lock and lower IRQL to its previous value.
            // An APC interrupt will immediately occur which will result in
            // the delivery of the kernel APC if possible.
            //

            KeReleaseInStackQueuedSpinLock(&LockHandle);
            continue;
        }

        //
        // If the current thread is associated with a queue object, then
        // acquire the dispatcher lock.
        //

        if ((Queue = CurrentThread->Queue) != NULL) {
            KiLockDispatcherDatabaseAtSynchLevel();
        }

        //
        // Acquire the thread lock and the object lock.
        //
        // If the object is already signaled, then clear the signaled state,
        // release the object lock, release the thread lock, and lower IRQL
        // to its previous value. Otherwise, set the thread state to gate
        // wait, set the address of the gate object, insert the thread in the
        // object wait list, set context swap busy, release the object lock,
        // release the thread lock, and switch to a new thread.
        //

        KiAcquireThreadLock(CurrentThread);
        KiAcquireKobjectLock(Gate);
        if (Gate->Header.SignalState != 0) {
            Gate->Header.SignalState = 0;
            KiReleaseKobjectLock(Gate);
            KiReleaseThreadLock(CurrentThread);
            if (Queue != NULL) {
                KiUnlockDispatcherDatabaseFromSynchLevel();
            }

            KeReleaseInStackQueuedSpinLock(&LockHandle);
            break;
    
        } else {
            WaitBlock = &CurrentThread->WaitBlock[0];
            WaitBlock->Object = Gate;
            WaitBlock->Thread = CurrentThread;
            CurrentThread->WaitMode = WaitMode;
            CurrentThread->WaitReason = WaitReason;
            CurrentThread->WaitIrql = LockHandle.OldIrql;
            CurrentThread->State = GateWait;
            CurrentThread->GateObject = Gate;
            InsertTailList(&Gate->Header.WaitListHead, &WaitBlock->WaitListEntry);
            KiReleaseKobjectLock(Gate);
            KiSetContextSwapBusy(CurrentThread);
            KiReleaseThreadLock(CurrentThread);

            //
            // If the current thread is associated with a queue object, then
            // activate another thread if possible.
            //

            if (Queue != NULL) {
                if ((Queue = CurrentThread->Queue) != NULL) {
                    KiActivateWaiterQueue(Queue);
                }

                KiUnlockDispatcherDatabaseFromSynchLevel();
            }

            KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
            WaitStatus = (NTSTATUS)KiSwapThread(CurrentThread, KeGetCurrentPrcb());
            if (WaitStatus == STATUS_SUCCESS) {
                return;
            }
        }

    } while (TRUE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\kernldat.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    kernldat.c

Abstract:

    This module contains the declaration and allocation of kernel data
    structures.

--*/

#include "ki.h"

//
// KiTimerTableListHead - This is an array of tiemr table entries that anchor
//      the individual timer lists.
//

DECLSPEC_CACHEALIGN KTIMER_TABLE_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];

//
// KiQueuedLockTableSize - This is the size of the PRCB based numbered queued
//      lock table used by the kernel debugger extensions.
//

#if defined(_WIN64)

#pragma comment(linker, "/include:KiQueuedLockTableSize")

#endif

ULONG KiQueuedLockTableSize = LockQueueMaximumLock;

//
// KiTimerSystemSharedData - This is the address of the kernel view of the
//      user shared data.
//

#if defined(_WIN64)

#pragma comment(linker, "/include:KiSystemSharedData")

#endif

ULONG_PTR KiSystemSharedData = KI_USER_SHARED_DATA;

//
// KiTimerTableSize - This is the size of the timer table and is used by the
//      kernel debugger extensions.
//

#if defined(_WIN64)

#pragma comment(linker, "/include:KiTimerTableSize")

#endif

ULONG KiTimerTableSize = TIMER_TABLE_SIZE;

//
//
// Public kernel data declaration and allocation.
//
// KeActiveProcessors - This is the set of processors that active in the
//      system.
//

KAFFINITY KeActiveProcessors = 0;

//
// KeBootTime - This is the absolute time when the system was booted.
//

LARGE_INTEGER KeBootTime;

//
// KeBootTimeBias - The time for which KeBootTime has ever been biased
//

ULONGLONG KeBootTimeBias;

//
// KeInterruptTimeBias - The time for which InterrupTime has ever been biased
//

ULONGLONG KeInterruptTimeBias;

//
// KeBugCheckCallbackListHead - This is the list head for registered
//      bugcheck callback routines.
//

LIST_ENTRY KeBugCheckCallbackListHead;
LIST_ENTRY KeBugCheckReasonCallbackListHead;

//
// KeBugCheckCallbackLock - This is the spin lock that guards the bugcheck
//      callback list.
//

KSPIN_LOCK KeBugCheckCallbackLock;

//
// KeGdiFlushUserBatch - This is the address of the GDI user batch flush
//      routine which is initialized when the win32k subsystem is loaded.
//

PGDI_BATCHFLUSH_ROUTINE KeGdiFlushUserBatch;

//
// KeLoaderBlock - This is a pointer to the loader parameter block which is
//      constructed by the OS Loader.
//

PLOADER_PARAMETER_BLOCK KeLoaderBlock = NULL;

//
// KeMinimumIncrement - This is the minimum time between clock interrupts
//      in 100ns units that is supported by the host HAL.
//

ULONG KeMinimumIncrement;

//
// KeThreadDpcEnable - This is the system wide enable for threaded DPCs that
//      is read from the registry.
//

ULONG KeThreadDpcEnable = FALSE; // TRUE;

//
// KeNumberProcessors - This is the number of processors in the configuration.
//      If is used by the ready thread and spin lock code to determine if a
//      faster algorithm can be used for the case of a single processor system.
//      The value of this variable is set when processors are initialized.
//

CCHAR KeNumberProcessors = 0;

//
// KeNumprocSpecified - This is the number of processors specified by the
//      /NUMPROC=x osloader option. If this value is set with the number
//      of processors option, then it specifies the total number of logical
//      processors that can be started.
//    

#if !defined(NT_UP)

ULONG KeNumprocSpecified = 0;

#endif

//
// KeProcessorArchitecture - Architecture of all processors present in system.
//      See PROCESSOR_ARCHITECTURE_ defines in ntexapi.h
//

USHORT KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;

//
// KeProcessorLevel - Architectural specific processor level of all processors
//      present in system.
//

USHORT KeProcessorLevel = 0;

//
// KeProcessorRevision - Architectural specific processor revision number that is
//      the least common denominator of all processors present in system.
//

USHORT KeProcessorRevision = 0;

//
// KeFeatureBits - Architectural specific processor features present
// on all processors.
//

ULONG KeFeatureBits = 0;

//
// KeServiceDescriptorTable - This is a table of descriptors for system
//      service providers. Each entry in the table describes the base
//      address of the dispatch table and the number of services provided.
//

DECLSPEC_CACHEALIGN KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable[NUMBER_SERVICE_TABLES];
DECLSPEC_CACHEALIGN KSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTableShadow[NUMBER_SERVICE_TABLES];

//
// KeThreadSwitchCounters - These counters record the number of times a
//      thread can be scheduled on the current processor, any processor,
//      or the last processor it ran on.
//

KTHREAD_SWITCH_COUNTERS KeThreadSwitchCounters;

//
// KeTimeIncrement - This is the nominal number of 100ns units that are to
//      be added to the system time at each interval timer interupt. This
//      value is set by the HAL and is used to compute the due time for
//      timer table entries.
//

ULONG KeTimeIncrement;

//
// KeTimeSynchronization - This variable controls whether time synchronization
//      is performed using the realtime clock (TRUE) or whether it is under the
//      control of a service (FALSE).
//

BOOLEAN KeTimeSynchronization = TRUE;

//
// KeUserApcDispatcher - This is the address of the user mode APC dispatch
//      code. This address is looked up in NTDLL.DLL during initialization
//      of the system.
//

PVOID KeUserApcDispatcher;

//
// KeUserCallbackDispatcher - This is the address of the user mode callback
//      dispatch code. This address is looked up in NTDLL.DLL during
//      initialization of the system.
//

PVOID KeUserCallbackDispatcher;

//
// KeUserExceptionDispatcher - This is the address of the user mode exception
//      dispatch code. This address is looked up in NTDLL.DLL during system
//      initialization.
//

PVOID KeUserExceptionDispatcher;

//
// KeUserPopEntrySListEnd - This is the ending address of the user mode SLIST
//      code.
//

PVOID KeUserPopEntrySListEnd;

//
// KeUserPopEntrySListFault - This is the address of the user mode code that
//      may generate a "benign" pagefault.
//

PVOID KeUserPopEntrySListFault;

//
// KeUserPopEntrySListResume - This is the address of the user mode code that
//      execution will be restarted at upon a fault at the above address.
//

PVOID KeUserPopEntrySListResume;

//
// Same as above, for 32-bit ntdll.
//

#if defined(_WIN64)

PVOID KeUserPopEntrySListEndWow64;
PVOID KeUserPopEntrySListFaultWow64;
PVOID KeUserPopEntrySListResumeWow64;

#endif

//
// KeRaiseUserExceptionDispatcher - This is the address of the raise user
//      mode exception dispatch code. This address is looked up in NTDLL.DLL
//      during system initialization.
//

PVOID KeRaiseUserExceptionDispatcher;

//
// KeLargestCacheLine - This variable contains the size in bytes of
//      the largest cache line discovered during system initialization.
//      It is used to provide the recommend alignment (and padding)
//      for data that may be used heavily by more than one processor.
//      The initial value was chosen as a reasonable value to use on
//      systems where the discovery process doesn't find a value.
//

ULONG KeLargestCacheLine = 64;

//
// Private kernel data declaration and allocation.
//
// KiBugCodeMessages - Address of where the BugCode messages can be found.
//

PMESSAGE_RESOURCE_DATA KiBugCodeMessages = NULL;

//
// KiDmaIoCoherency - This determines whether the host platform supports
//      coherent DMA I/O.
//

ULONG KiDmaIoCoherency;

//
// KiDPCTimeout - This is the DPC time out time in ticks on checked builds.
//

ULONG KiDPCTimeout = 110;

//
// KiDebugSwitchRoutine - This is the address of the kernel debugger
//      processor switch routine.  This is used on an MP system to
//      switch host processors while debugging.
//

PKDEBUG_SWITCH_ROUTINE KiDebugSwitchRoutine;

//
// KiGenericCallDpcMutex - This is the fast mutex that guards generic DPC calls.
//

FAST_MUTEX KiGenericCallDpcMutex;

//
// KiFreezeFlag - For debug builds only.  Flags to track and signal non-
//      normal freezelock conditions.
//

ULONG KiFreezeFlag;

//
// KiInitialProcess - This is the initial process that is created when the
//      system is booted.
//

DECLSPEC_CACHEALIGN EPROCESS KiInitialProcess;

//
// KiInitialThread - This is the initial thread that is created when the
//      system is booted.
//

DECLSPEC_CACHEALIGN ETHREAD KiInitialThread;

//
// KiSpinlockTimeout - This is the spin lock time out time in ticks on checked
//      builds.
//

ULONG KiSpinlockTimeout = 55;

//
// KiSuspenState - Flag to track suspend/resume state of processors.
//

volatile ULONG KiSuspendState;

//
// KiProcessorBlock - This is an array of pointers to processor control blocks.
//      The elements of the array are indexed by processor number. Each element
//      is a pointer to the processor control block for one of the processors
//      in the configuration. This array is used by various sections of code
//      that need to effect the execution of another processor.
//

DECLSPEC_CACHEALIGN PKPRCB KiProcessorBlock[MAXIMUM_PROCESSORS];

//
// KeNumberNodes - This is the number of ccNUMA nodes in the system. Logically
// an SMP system is the same as a single node ccNUMA system.
//

UCHAR KeNumberNodes = 1;

//
// KeNodeBlock - This is an array of pointers to KNODE structures. A KNODE
// structure describes the resources of a NODE in a ccNUMA system.
//

KNODE KiNode0;

UCHAR KeProcessNodeSeed;

#if defined(KE_MULTINODE)

DECLSPEC_CACHEALIGN PKNODE KeNodeBlock[MAXIMUM_CCNUMA_NODES];

#else

PKNODE KeNodeBlock[1] = {&KiNode0};

#endif

//
// KiSwapEvent - This is the event that is used to wake up the balance set
//      thread to inswap processes, outswap processes, and to inswap kernel
//      stacks.
//

KEVENT KiSwapEvent;

//
// KiSwappingThread - This is a pointer to the swap thread object.
//

PKTHREAD KiSwappingThread;

//
// KiProcessListHead - This is the list of processes that have active threads.
//

LIST_ENTRY KiProcessListHead;

//
// KiProcessInSwapListHead - This is the list of processes that are waiting
//      to be inswapped.
//

SINGLE_LIST_ENTRY KiProcessInSwapListHead;

//
// KiProcessOutSwapListHead - This is the list of processes that are waiting
//      to be outswapped.
//

SINGLE_LIST_ENTRY KiProcessOutSwapListHead;

//
// KiStackInSwapListHead - This is the list of threads that are waiting
//      to get their stack inswapped before they can run. Threads are
//      inserted in this list in ready thread and removed by the balance
//      set thread.
//

SINGLE_LIST_ENTRY KiStackInSwapListHead;

//
// KiProfileSourceListHead - The list of profile sources that are currently
//      active.
//

LIST_ENTRY KiProfileSourceListHead;

//
// KiProfileAlignmentFixup - Indicates whether alignment fixup profiling
//      is active.
//

BOOLEAN KiProfileAlignmentFixup;

//
// KiProfileAlignmentFixupInterval - Indicates the current alignment fixup
//      profiling interval.
//

ULONG KiProfileAlignmentFixupInterval;

//
// KiProfileAlignmentFixupCount - Indicates the current alignment fixup
//      count.
//

ULONG KiProfileAlignmentFixupCount;

//
// KiProfileInterval - The profile interval in 100ns units.
//

ULONG KiProfileInterval = DEFAULT_PROFILE_INTERVAL;

//
// KiProfileListHead - This is the list head for the profile list.
//

LIST_ENTRY KiProfileListHead;

//
// KiTimerExpireDpc - This is the Deferred Procedure Call (DPC) object that
//      is used to process the timer queue when a timer has expired.
//

KDPC KiTimerExpireDpc;

//
// KiEnableTimerWatchdog at one point controlled a HAL clock interrupt
// watchdog that is now obsolete.  This symbol was present in Server 2003,
// meaning that it still has to be exported from the Server 2003 service pack
// kernels so that custom HALs built for Server 2003 RTM won't fail with an
// unresolved import after applying the service pack.  We only need to do this
// for x86 since the other architectures don't allow custom HALs.
//

#if defined(_X86_)

ULONG KiEnableTimerWatchdog = 0;

#endif

#if defined(_APIC_TPR_)

PUCHAR HalpIRQLToTPR;
PUCHAR HalpVectorToIRQL;

#endif

//
// Flag to indicate that frozen processors should resume to a benign looping
// state in preparation for a reboot.
//

#if defined(_AMD64_) && !defined(NT_UP)

BOOLEAN KiResumeForReboot = FALSE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\idsched.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    idsched.c

Abstract:

    This module implement idle scheduling. Idle scheduling is performed when
    the current thread is entering a wait state or must be rescheduled for
    any other reason (e.g., affinity change), and a suitable thread cannot be
    found after searching a suitable subset of the processor ready queues.

--*/

#include "ki.h"

#if !defined(NT_UP)

PKTHREAD
FASTCALL
KiIdleSchedule (
    PKPRCB CurrentPrcb
    )

/*++

Routine Description:

    This function is called when the idle schedule flag is set in the current
    PRCB. This flag is set when the current thread is entering a wait state
    or must be rescheduled for any other reason (e.g., affinity change) and
    a suitable thread cannot be found after searching all the processor ready
    queues outside the dispatcher database lock. A second pass over the ready
    queues is required since the processor was not idle during the first scan,
    and therefore, a potential candidate thread may have been missed.

Arguments:

    CurrentPrcb - Supplies a pointer to the current processor block.

Return Value:

    If a thread is found to run, then a pointer to the thread is returned.
    Otherwise, NULL is returned.

    N.B. If a thread is found, then IRQL is returned at SYNCH_LEVEL. If a
         thread is not found, then IRQL is returned at DISPATCH_LEVEL.

--*/

{

    LONG Index;
    LONG Limit;
    LONG Number;
    PKTHREAD NewThread;
    ULONG Processor;
    PKPRCB TargetPrcb;

    ASSERT (CurrentPrcb == KeGetCurrentPrcb());

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the current PRCB lock, and clear
    // idle schedule.
    //

    KeRaiseIrqlToSynchLevel();
    KiAcquirePrcbLock(CurrentPrcb);
    CurrentPrcb->IdleSchedule = FALSE;

    //
    // If the idle thread has been selected to run on current processor, then
    // clear the idle thread selection.
    //
    // N.B. This condition can occur when another thread is scheduled to run
    //      on the current processor, then becomes ineligible to run and the
    //      processor goes idle again.
    //

    if (CurrentPrcb->NextThread == CurrentPrcb->IdleThread) {
        CurrentPrcb->NextThread = NULL;
    }

    //
    // If a thread has already been selected to run on the current processor,
    // then select that thread. Otherwise, attempt to select a thread from
    // the current processor dispatcher ready queues.
    //

    if ((NewThread = CurrentPrcb->NextThread) != NULL) {

        //
        // Clear the next thread address, set the current thread address, and
        // set the thread state to running.
        //

        CurrentPrcb->NextThread = NULL;
        CurrentPrcb->CurrentThread = NewThread;
        NewThread->State = Running;

    } else {

        //
        // Attempt to select a thread from the current processor dispatcher
        // ready queues.
        //

        NewThread = KiSelectReadyThread(0, CurrentPrcb);
        if (NewThread != NULL) {
            CurrentPrcb->NextThread = NULL;
            CurrentPrcb->CurrentThread = NewThread;
            NewThread->State = Running;

        } else {

            //
            // Release the current PRCB lock and attempt to select a thread
            // from any processor dispatcher ready queues.
            //
            // If this is a multinode system, then start with the processors
            // on the same node. Otherwise, start with the current processor.
            //

            KiReleasePrcbLock(CurrentPrcb);
            Processor = CurrentPrcb->Number;
            Index = Processor;
            if (KeNumberNodes > 1) {
                KeFindFirstSetLeftAffinity(CurrentPrcb->ParentNode->ProcessorMask,
                                           (PULONG)&Index);
            }
        
            Limit = KeNumberProcessors - 1;
            Number = Limit;
            do {
                TargetPrcb = KiProcessorBlock[Index];
                if (CurrentPrcb != TargetPrcb) {
                    if (TargetPrcb->ReadySummary != 0) {

                        //
                        // Acquire the current and target PRCB locks.
                        //

                        KiAcquireTwoPrcbLocks(CurrentPrcb, TargetPrcb);

                        //
                        // If a new thread has not been selected to run on
                        // the current processor, then attempt to select a
                        // thread to run on the current processor.
                        //

                        if ((NewThread = CurrentPrcb->NextThread) == NULL) {
                            if ((TargetPrcb->ReadySummary != 0) &&
                                (NewThread = KiFindReadyThread(Processor,
                                                               TargetPrcb)) != NULL) {
    
                                //
                                // A new thread has been found to run on the
                                // current processor.
                                //
    
                                NewThread->State = Running;
                                KiReleasePrcbLock(TargetPrcb);
                                CurrentPrcb->NextThread = NULL;
                                CurrentPrcb->CurrentThread = NewThread;

                                //
                                // Clear idle on the current processor
                                // and update the idle SMT summary set to
                                // indicate the set is not idle.
                                //

                                KiClearIdleSummary(AFFINITY_MASK(Processor));
                                KiClearSMTSummary(CurrentPrcb->MultiThreadProcessorSet);
                                goto ThreadFound;

                            } else {
                                KiReleasePrcbLock(CurrentPrcb);
                                KiReleasePrcbLock(TargetPrcb);
                            }

                        } else {

                            //
                            // A thread has already been selected to run on
                            // the current processor. It is possible that
                            // the thread is the idle thread due to a state
                            // change that made a scheduled runable thread
                            // unrunable.
                            //
                            // N.B. If the idle thread is selected, then the
                            //      current processor is idle. Otherwise,
                            //      the current processor is not idle.
                            //

                            if (NewThread == CurrentPrcb->IdleThread) {
                                CurrentPrcb->NextThread = NULL;
                                CurrentPrcb->IdleSchedule = FALSE;
                                KiReleasePrcbLock(CurrentPrcb);
                                KiReleasePrcbLock(TargetPrcb);
                                continue;

                            } else {
                                NewThread->State = Running;
                                KiReleasePrcbLock(TargetPrcb);
                                CurrentPrcb->NextThread = NULL;
                                CurrentPrcb->CurrentThread = NewThread;
                                goto ThreadFound;
                            }
                        }
                    }
                }
        
                Index -= 1;
                if (Index < 0) {
                    Index = Limit;
                }
        
                Number -= 1;
            } while (Number >= 0);
        }
    }

    //
    // If a new thread has been selected for execution, then release the
    // PRCB lock and acquire the idle thread lock. Otherwise, lower IRQL
    // to DISPATCH_LEVEL.
    //

ThreadFound:;
    if (NewThread == NULL) {
        KeLowerIrql(DISPATCH_LEVEL);

    } else {
        KiSetContextSwapBusy(CurrentPrcb->IdleThread);
        KiReleasePrcbLock(CurrentPrcb);
    }

    return NewThread;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\interobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    interobj.c

Abstract:

    This module implements functions to acquire and release the spin lock
    associated with an interrupt object.

--*/

#include "ki.h"

KIRQL
KeAcquireInterruptSpinLock (
    __inout PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function raises the IRQL to the interrupt synchronization level
    and acquires the actual spin lock associated with an interrupt object.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to interrupt synchronization level and acquire the actual
    // spin lock associated with the interrupt object.
    //

    KeRaiseIrql(Interrupt->SynchronizeIrql, &OldIrql);
    KeAcquireSpinLockAtDpcLevel(Interrupt->ActualLock);
    return OldIrql;
}

VOID
KeReleaseInterruptSpinLock (
    __inout PKINTERRUPT Interrupt,
    __in KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases the actual spin lock associated with an interrupt
    object and lowers the IRQL to its previous value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    OldIrql - Supplies the previous IRQL value.

Return Value:

    None.

--*/

{

    //
    // Release the actual spin lock associated with the interrupt object
    // and lower IRQL to its previous value.
    //

    KeReleaseSpinLockFromDpcLevel(Interrupt->ActualLock);
    KeLowerIrql(OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\kevutil.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    kevutil.c

Abstract:

    This module implements various utilities required to do driver verification.

--*/

#include "ki.h"

#pragma alloc_text(PAGEVRFY, KevUtilAddressToFileHeader)

NTSTATUS
KevUtilAddressToFileHeader(
    IN  PVOID                   Address,
    OUT UINT_PTR                *OffsetIntoImage,
    OUT PUNICODE_STRING         *DriverName,
    OUT BOOLEAN                 *InVerifierList
    )

/*++

Routine Description:

    This function returns the name of a driver based on the specified
    Address. In addition, the offset into the driver is returned along
    with an indication as to whether the driver is among the list of those
    being verified.

Arguments:

    Address         - Supplies an address to resolve to a driver name.

    OffsetIntoImage - Receives the offset relative to the base of the driver.

    DriverName      - Receives a pointer to the name of the driver.

    InVerifierList  - Receives TRUE if the driver is in the verifier list,
                      FALSE otherwise.

Return Value:

    NTSTATUS (On failure, OffsetIntoImage receives NULL, DriverName receives
              NULL, and InVerifierList receives FALSE).

--*/

{

    PLIST_ENTRY pModuleListHead, next;
    PLDR_DATA_TABLE_ENTRY pDataTableEntry;
    UINT_PTR bounds, pCurBase;

    //
    // Preinit for failure
    //

    *DriverName = NULL;
    *InVerifierList = FALSE;
    *OffsetIntoImage = 0;

    //
    // Set initial values for the module walk
    //

    pModuleListHead = &PsLoadedModuleList;

    //
    // It would be nice if we could call MiLookupDataTableEntry, but it's
    // pageable, so we do what the bugcheck stuff does...
    //

    next = pModuleListHead->Flink;
    if (next != NULL) {
        while (next != pModuleListHead) {

            //
            // Extract the data table entry
            //
            pDataTableEntry = CONTAINING_RECORD(
                next,
                LDR_DATA_TABLE_ENTRY,
                InLoadOrderLinks
                );

            next = next->Flink;
            pCurBase = (UINT_PTR) pDataTableEntry->DllBase;
            bounds = pCurBase + pDataTableEntry->SizeOfImage;
            if ((UINT_PTR)Address >= pCurBase && (UINT_PTR)Address < bounds) {

                //
                // We have a match, record it and get out of here.
                //

                *OffsetIntoImage = (UINT_PTR) Address - pCurBase;
                *DriverName = &pDataTableEntry->BaseDllName;

                //
                // Now record whether this is in the verifying table.
                //

                if (pDataTableEntry->Flags & LDRP_IMAGE_VERIFYING) {

                    *InVerifierList = TRUE;
                }

                return STATUS_SUCCESS;
            }
        }
    }

    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\kiinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    kiinit.c

Abstract:

    This module implements architecture independent kernel initialization.

--*/

#include "ki.h"

//
// External data.
//

extern ALIGNED_SPINLOCK AfdWorkQueueSpinLock;
extern ALIGNED_SPINLOCK CcBcbSpinLock;
extern ALIGNED_SPINLOCK CcMasterSpinLock;
extern ALIGNED_SPINLOCK CcVacbSpinLock;
extern ALIGNED_SPINLOCK CcWorkQueueSpinLock;
extern ALIGNED_SPINLOCK IopCancelSpinLock;
extern ALIGNED_SPINLOCK IopCompletionLock;
extern ALIGNED_SPINLOCK IopDatabaseLock;
extern ALIGNED_SPINLOCK IopVpbSpinLock;
extern ALIGNED_SPINLOCK NtfsStructLock;
extern ALIGNED_SPINLOCK MmPfnLock;
extern ALIGNED_SPINLOCK NonPagedPoolLock;
extern ALIGNED_SPINLOCK MmNonPagedPoolLock;
extern ALIGNED_SPINLOCK MmSystemSpaceLock;

#if defined(KE_MULTINODE)

extern PHALNUMAQUERYPROCESSORNODE KiQueryProcessorNode;
extern PHALNUMAPAGETONODE MmPageToNode;

#endif

//
// Put all code for kernel initialization in the INIT section. It will be
// deallocated by memory management when phase 1 initialization is completed.
//

#pragma alloc_text(INIT, KeInitSystem)
#pragma alloc_text(INIT, KiInitSpinLocks)
#pragma alloc_text(INIT, KiInitSystem)
#pragma alloc_text(INIT, KeNumaInitialize)

BOOLEAN
KeInitSystem (
    VOID
    )

/*++

Routine Description:

    This function initializes executive structures implemented by the
    kernel.

    N.B. This function is only called during phase 1 initialization.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if initialization is successful. Otherwise,
    a value of FALSE is returned.

--*/

{

    HANDLE Handle;
    ULONG Index;
    ULONG Limit;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKPRCB Prcb;
    NTSTATUS Status;

    //
    // If threaded DPCs are enabled for the host system, then create a DPC
    // thread for each processor.
    //

    if (KeThreadDpcEnable != FALSE) {
        Index = 0;
        Limit = (ULONG)KeNumberProcessors;
        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL);
        do {
            Prcb = KiProcessorBlock[Index];
            KeInitializeEvent(&Prcb->DpcEvent, SynchronizationEvent, FALSE);
            InitializeListHead(&Prcb->DpcData[DPC_THREADED].DpcListHead);
            KeInitializeSpinLock(&Prcb->DpcData[DPC_THREADED].DpcLock);
            Prcb->DpcData[DPC_THREADED].DpcQueueDepth = 0;
            Status = PsCreateSystemThread(&Handle,
                                          THREAD_ALL_ACCESS,
                                          &ObjectAttributes,
                                          NULL,
                                          NULL,
                                          KiExecuteDpc,
                                          Prcb);

            if (!NT_SUCCESS(Status)) {
                return FALSE;
            }

            ZwClose(Handle);
            Index += 1;
        } while (Index < Limit);
    }

    //
    // Perform platform dependent initialization.
    //

    return KiInitMachineDependent();
}

VOID
KiInitSpinLocks (
    PKPRCB Prcb,
    ULONG Number
    )

/*++

Routine Description:

    This function initializes the spinlock structures in the per processor
    PRCB. This function is called once for each processor.

Arguments:

    Prcb - Supplies a pointer to a PRCB.

    Number - Supplies the number of respective processor.

Return Value:

    None.

--*/

{

    ULONG Index;

    //
    // Initialize dispatcher ready queue list heads, the ready summary, and
    // the deferred ready list head.
    //

    Prcb->QueueIndex = 1;
    Prcb->ReadySummary = 0;
    Prcb->DeferredReadyListHead.Next = NULL;
    for (Index = 0; Index < MAXIMUM_PRIORITY; Index += 1) {
        InitializeListHead(&Prcb->DispatcherReadyListHead[Index]);
    }

    //
    // Initialize the normal DPC data.
    //

    InitializeListHead(&Prcb->DpcData[DPC_NORMAL].DpcListHead);
    KeInitializeSpinLock(&Prcb->DpcData[DPC_NORMAL].DpcLock);
    Prcb->DpcData[DPC_NORMAL].DpcQueueDepth = 0;
    Prcb->DpcData[DPC_NORMAL].DpcCount = 0;
    Prcb->DpcRoutineActive = 0;
    Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
    Prcb->MinimumDpcRate = KiMinimumDpcRate;
    Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

    //
    // Initialize the generic call DPC structure, set the target processor
    // number, and set the DPC importance.
    //

    KeInitializeDpc(&Prcb->CallDpc, NULL, NULL);
    KeSetTargetProcessorDpc(&Prcb->CallDpc, (CCHAR)Number);
    KeSetImportanceDpc(&Prcb->CallDpc, HighImportance);

    //
    // Initialize wait list.
    //

    InitializeListHead(&Prcb->WaitListHead);

    //
    // Initialize general numbered queued spinlock structures.
    //

#if defined(_AMD64_)

    KeGetPcr()->LockArray = &Prcb->LockQueue[0];

#endif

    Prcb->LockQueue[LockQueueDispatcherLock].Next = NULL;
    Prcb->LockQueue[LockQueueDispatcherLock].Lock = &KiDispatcherLock;

    Prcb->LockQueue[LockQueueUnusedSpare1].Next = NULL;
    Prcb->LockQueue[LockQueueUnusedSpare1].Lock = NULL;

    Prcb->LockQueue[LockQueuePfnLock].Next = NULL;
    Prcb->LockQueue[LockQueuePfnLock].Lock = &MmPfnLock;

    Prcb->LockQueue[LockQueueSystemSpaceLock].Next = NULL;
    Prcb->LockQueue[LockQueueSystemSpaceLock].Lock = &MmSystemSpaceLock;

    Prcb->LockQueue[LockQueueBcbLock].Next = NULL;
    Prcb->LockQueue[LockQueueBcbLock].Lock = &CcBcbSpinLock;

    Prcb->LockQueue[LockQueueMasterLock].Next = NULL;
    Prcb->LockQueue[LockQueueMasterLock].Lock = &CcMasterSpinLock;

    Prcb->LockQueue[LockQueueVacbLock].Next = NULL;
    Prcb->LockQueue[LockQueueVacbLock].Lock = &CcVacbSpinLock;

    Prcb->LockQueue[LockQueueWorkQueueLock].Next = NULL;
    Prcb->LockQueue[LockQueueWorkQueueLock].Lock = &CcWorkQueueSpinLock;

    Prcb->LockQueue[LockQueueNonPagedPoolLock].Next = NULL;
    Prcb->LockQueue[LockQueueNonPagedPoolLock].Lock = &NonPagedPoolLock;

    Prcb->LockQueue[LockQueueMmNonPagedPoolLock].Next = NULL;
    Prcb->LockQueue[LockQueueMmNonPagedPoolLock].Lock = &MmNonPagedPoolLock;

    Prcb->LockQueue[LockQueueIoCancelLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoCancelLock].Lock = &IopCancelSpinLock;

    Prcb->LockQueue[LockQueueIoVpbLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoVpbLock].Lock = &IopVpbSpinLock;

    Prcb->LockQueue[LockQueueIoDatabaseLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoDatabaseLock].Lock = &IopDatabaseLock;

    Prcb->LockQueue[LockQueueIoCompletionLock].Next = NULL;
    Prcb->LockQueue[LockQueueIoCompletionLock].Lock = &IopCompletionLock;

    Prcb->LockQueue[LockQueueNtfsStructLock].Next = NULL;
    Prcb->LockQueue[LockQueueNtfsStructLock].Lock = &NtfsStructLock;

    Prcb->LockQueue[LockQueueAfdWorkQueueLock].Next = NULL;
    Prcb->LockQueue[LockQueueAfdWorkQueueLock].Lock = &AfdWorkQueueSpinLock;

    Prcb->LockQueue[LockQueueUnusedSpare16].Next = NULL;
    Prcb->LockQueue[LockQueueUnusedSpare16].Lock = NULL;

    //
    // Initialize the timer table numbered queued spinlock structures.
    //

    for (Index = 0; Index < LOCK_QUEUE_TIMER_TABLE_LOCKS; Index += 1) {
        KeInitializeSpinLock(&KiTimerTableLock[Index].Lock);
        Prcb->LockQueue[LockQueueTimerTableLock + Index].Next = NULL;
        Prcb->LockQueue[LockQueueTimerTableLock + Index].Lock = &KiTimerTableLock[Index].Lock;
    }

    //
    // Initialize processor control block lock.
    //

    KeInitializeSpinLock(&Prcb->PrcbLock);

    //
    // If this is processor zero, then also initialize the queued spin lock
    // home address.
    //

    if (Number == 0) {
        KeInitializeSpinLock(&KiDispatcherLock);
        KeInitializeSpinLock(&KiReverseStallIpiLock);
        KeInitializeSpinLock(&MmPfnLock);
        KeInitializeSpinLock(&MmSystemSpaceLock);
        KeInitializeSpinLock(&CcBcbSpinLock);
        KeInitializeSpinLock(&CcMasterSpinLock);
        KeInitializeSpinLock(&CcVacbSpinLock);
        KeInitializeSpinLock(&CcWorkQueueSpinLock);
        KeInitializeSpinLock(&IopCancelSpinLock);
        KeInitializeSpinLock(&IopCompletionLock);
        KeInitializeSpinLock(&IopDatabaseLock);
        KeInitializeSpinLock(&IopVpbSpinLock);
        KeInitializeSpinLock(&NonPagedPoolLock);
        KeInitializeSpinLock(&MmNonPagedPoolLock);
        KeInitializeSpinLock(&NtfsStructLock);
        KeInitializeSpinLock(&AfdWorkQueueSpinLock);
    }

    return;
}

VOID
KiInitSystem (
    VOID
    )

/*++

Routine Description:

    This function initializes architecture independent kernel structures.

    N.B. This function is only called on processor 0.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Index;

    //
    // Initialize bugcheck callback listhead and spinlock.
    //

    InitializeListHead(&KeBugCheckCallbackListHead);
    InitializeListHead(&KeBugCheckReasonCallbackListHead);
    KeInitializeSpinLock(&KeBugCheckCallbackLock);

    //
    // Initialize the timer expiration DPC object and set the destination
    // processor to processor zero.
    //

    KeInitializeDpc(&KiTimerExpireDpc, KiTimerExpiration, NULL);
    KeSetTargetProcessorDpc(&KiTimerExpireDpc, 0);

    //
    // Initialize the profile listhead and profile locks
    //

    KeInitializeSpinLock(&KiProfileLock);
    InitializeListHead(&KiProfileListHead);

    //
    // Initialize the active profile source listhead.
    //

    InitializeListHead(&KiProfileSourceListHead);

    //
    // Initialize the timer table and the timer table due time table.
    //
    // N.B. Each entry in the timer table due time table is set to an infinite
    //      absolute due time.
    //

    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
        InitializeListHead(&KiTimerTableListHead[Index].Entry);
        KiTimerTableListHead[Index].Time.HighPart = 0xffffffff;
        KiTimerTableListHead[Index].Time.LowPart = 0;
    }

    //
    // Initialize the swap event, the process inswap listhead, the
    // process outswap listhead, and the kernel stack inswap listhead.
    //

    KeInitializeEvent(&KiSwapEvent,
                      SynchronizationEvent,
                      FALSE);

    KiProcessInSwapListHead.Next = NULL;
    KiProcessOutSwapListHead.Next = NULL;
    KiStackInSwapListHead.Next = NULL;

    //
    // Initialize the generic DPC call fast mutex.
    //

    ExInitializeFastMutex(&KiGenericCallDpcMutex);

    //
    // Initialize the system service descriptor table.
    //

    KeServiceDescriptorTable[0].Base = &KiServiceTable[0];
    KeServiceDescriptorTable[0].Count = NULL;
    KeServiceDescriptorTable[0].Limit = KiServiceLimit;
    KeServiceDescriptorTable[0].Number = KiArgumentTable;
    for (Index = 1; Index < NUMBER_SERVICE_TABLES; Index += 1) {
        KeServiceDescriptorTable[Index].Limit = 0;
    }

    //
    // Copy the system service descriptor table to the shadow table
    // which is used to record the Win32 system services.
    //

    RtlCopyMemory(KeServiceDescriptorTableShadow,
                  KeServiceDescriptorTable,
                  sizeof(KeServiceDescriptorTable));

    return;
}

ULARGE_INTEGER
KeComputeReciprocal (
    IN LONG Divisor,
    OUT PCCHAR Shift
    )

/*++

Routine Description:

    This function computes the 64-bit reciprocal of the specified value.

Arguments:

    Divisor - Supplies the value for which the large integer reciprocal is
        computed.

    Shift - Supplies a pointer to a variable that receives the computed
        shift count.

Return Value:

    The 64-bit reciprocal is returned as the function value.

--*/

{

    LARGE_INTEGER Fraction;
    LONG NumberBits;
    LONG Remainder;

    //
    // Compute the large integer reciprocal of the specified value.
    //

    NumberBits = 0;
    Remainder = 1;
    Fraction.LowPart = 0;
    Fraction.HighPart = 0;
    while (Fraction.HighPart >= 0) {
        NumberBits += 1;
        Fraction.HighPart = (Fraction.HighPart << 1) | (Fraction.LowPart >> 31);
        Fraction.LowPart <<= 1;
        Remainder <<= 1;
        if (Remainder >= Divisor) {
            Remainder -= Divisor;
            Fraction.LowPart |= 1;
        }
    }

    if (Remainder != 0) {
        if ((Fraction.LowPart == 0xffffffff) && (Fraction.HighPart == 0xffffffff)) {
            Fraction.LowPart = 0;
            Fraction.HighPart = 0x80000000;
            NumberBits -= 1;

        } else {
            if (Fraction.LowPart == 0xffffffff) {
                Fraction.LowPart = 0;
                Fraction.HighPart += 1;

            } else {
                Fraction.LowPart += 1;
            }
        }
    }

    //
    // Compute the shift count value and return the reciprocal fraction.
    //

    *Shift = (CCHAR)(NumberBits - 64);
    return *((PULARGE_INTEGER)&Fraction);
}

ULONG
KeComputeReciprocal32 (
    IN LONG Divisor,
    OUT PCCHAR Shift
    )

/*++

Routine Description:

    This function computes the 32-bit reciprocal of the specified value.

Arguments:

    Divisor - Supplies the value for which the large integer reciprocal is
        computed.

    Shift - Supplies a pointer to a variable that receives the computed
        shift count.

Return Value:

    The 32-bit reciprocal is returned as the function value.

--*/

{

    LONG Fraction;
    LONG NumberBits;
    LONG Remainder;

    //
    // Compute the 32-bit reciprocal of the specified value.
    //

    NumberBits = 0;
    Remainder = 1;
    Fraction = 0;
    while (Fraction >= 0) {
        NumberBits += 1;
        Fraction <<= 1;
        Remainder <<= 1;
        if (Remainder >= Divisor) {
            Remainder -= Divisor;
            Fraction |= 1;
        }
    }

    if (Remainder != 0) {
        if (Fraction == 0xffffffff) {
            Fraction = 0x80000000;
            NumberBits -= 1;

        } else {
            Fraction += 1;
        }
    }

    //
    // Compute the shift count value and return the reciprocal fraction.
    //

    *Shift = (CCHAR)(NumberBits - 32);
    return Fraction;
}

VOID
KeNumaInitialize (
    VOID
    )

/*++

Routine Description:

    Initialize the kernel structures needed to support NUMA systems.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if defined(KE_MULTINODE)

    ULONG Length;
    HAL_NUMA_TOPOLOGY_INTERFACE NumaInformation;
    NTSTATUS Status;

    //
    // Query the NUMA topology of the system.
    //

    Status = HalQuerySystemInformation(HalNumaTopologyInterface,
                                       sizeof(HAL_NUMA_TOPOLOGY_INTERFACE),
                                       &NumaInformation,
                                       &Length);

    //
    // If the query was successful and the number of nodes in the host
    // system is greater than one, then set the number of nodes and the
    // address of the page to node and query processor functions.
    //

    if (NT_SUCCESS(Status)) {

        ASSERT(Length == sizeof(HAL_NUMA_TOPOLOGY_INTERFACE));
        ASSERT(NumaInformation.NumberOfNodes <= MAXIMUM_CCNUMA_NODES);
        ASSERT(NumaInformation.QueryProcessorNode != NULL);
        ASSERT(NumaInformation.PageToNode != NULL);

        if (NumaInformation.NumberOfNodes > 1) {
            KeNumberNodes = (UCHAR)NumaInformation.NumberOfNodes;
            MmPageToNode = NumaInformation.PageToNode;
            KiQueryProcessorNode = NumaInformation.QueryProcessorNode;
        }
    }

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\genxx.inc ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    genxx.inc

Abstract:

    This file contains common code to generate assembler definitions.

--*/

    //
    // Size of a pointer in bytes.
    //

    genCom("Pointer size in bytes")

    genVal(SizeofPointer, sizeof(PVOID))

    //
    // Process state enumerated type definitions.
    //

    genCom("Process State Enumerated Type Values")

    genVal(ProcessInMemory, ProcessInMemory)
    genVal(ProcessOutOfMemory, ProcessOutOfMemory)
    genVal(ProcessInTransition, ProcessInTransition)

    //
    // Thread state enumerated type definitions.
    //

    genCom("Thread State Enumerated Type Values")

    genVal(Initialized, Initialized)
    genVal(Ready, Ready)
    genVal(Running, Running)
    genVal(Standby, Standby)
    genVal(Terminated, Terminated)
    genVal(Waiting, Waiting)

    //
    // Wait reason and wait type enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Wait Reason and Wait Type Enumerated Type Values")

    genVal(WrExecutive, Executive)
    
    DisableInc(HAL)

    genVal(WrMutex, WrMutex)
    genVal(WrDispatchInt, WrDispatchInt)
    genVal(WrQuantumEnd, WrQuantumEnd)
    genVal(WrEventPair, WrEventPair)
    genVal(WaitAny, WaitAny)
    genVal(WaitAll, WaitAll)

    //
    // APC state structure offset definitions.
    //

    genCom("Apc State Structure Offset Definitions")

    genDef(As, KAPC_STATE, ApcListHead)
    EnableInc(HAL)
    genDef(As, KAPC_STATE, Process)
    DisableInc(HAL)
    genDef(As, KAPC_STATE, KernelApcInProgress)
    genDef(As, KAPC_STATE, KernelApcPending)
    genDef(As, KAPC_STATE, UserApcPending)

    //
    // Bugcheck code definitions
    //

    EnableInc(HAL)

    genCom("Bugcheck Code Definitions")

    genVal(APC_INDEX_MISMATCH, APC_INDEX_MISMATCH)
    genVal(ATTEMPTED_SWITCH_FROM_DPC, ATTEMPTED_SWITCH_FROM_DPC)
    genVal(DATA_BUS_ERROR, DATA_BUS_ERROR)
    genVal(DATA_COHERENCY_EXCEPTION, DATA_COHERENCY_EXCEPTION)
    genVal(HAL1_INITIALIZATION_FAILED, HAL1_INITIALIZATION_FAILED)
    genVal(INSTRUCTION_BUS_ERROR, INSTRUCTION_BUS_ERROR)
    genVal(INSTRUCTION_COHERENCY_EXCEPTION, INSTRUCTION_COHERENCY_EXCEPTION)
    genVal(INTERRUPT_EXCEPTION_NOT_HANDLED, INTERRUPT_EXCEPTION_NOT_HANDLED)
    genVal(INTERRUPT_UNWIND_ATTEMPTED, INTERRUPT_UNWIND_ATTEMPTED)
    genVal(INVALID_AFFINITY_SET, INVALID_AFFINITY_SET)
    genVal(INVALID_DATA_ACCESS_TRAP, INVALID_DATA_ACCESS_TRAP)
    genVal(IRQL_GT_ZERO_AT_SYSTEM_SERVICE, IRQL_GT_ZERO_AT_SYSTEM_SERVICE)
    genVal(IRQL_NOT_LESS_OR_EQUAL, IRQL_NOT_LESS_OR_EQUAL)
    genVal(KMODE_EXCEPTION_NOT_HANDLED, KMODE_EXCEPTION_NOT_HANDLED)
    genVal(NMI_HARDWARE_FAILURE, NMI_HARDWARE_FAILURE)
    genVal(NO_USER_MODE_CONTEXT, NO_USER_MODE_CONTEXT)
    genVal(PAGE_FAULT_WITH_INTERRUPTS_OFF, PAGE_FAULT_WITH_INTERRUPTS_OFF)
    genVal(PANIC_STACK_SWITCH, PANIC_STACK_SWITCH)
    genVal(SPIN_LOCK_INIT_FAILURE, SPIN_LOCK_INIT_FAILURE)
    genVal(SYSTEM_EXIT_OWNED_MUTEX, SYSTEM_EXIT_OWNED_MUTEX)
    genVal(SYSTEM_SERVICE_EXCEPTION, SYSTEM_SERVICE_EXCEPTION)
    genVal(SYSTEM_UNWIND_PREVIOUS_USER, SYSTEM_UNWIND_PREVIOUS_USER)
    genVal(TRAP_CAUSE_UNKNOWN, TRAP_CAUSE_UNKNOWN)
    genVal(UNEXPECTED_KERNEL_MODE_TRAP, UNEXPECTED_KERNEL_MODE_TRAP)
    genVal(HARDWARE_INTERRUPT_STORM, HARDWARE_INTERRUPT_STORM)
    genVal(RECURSIVE_MACHINE_CHECK, RECURSIVE_MACHINE_CHECK)
    genVal(RECURSIVE_NMI, RECURSIVE_NMI)

    DisableInc(HAL)

    //
    // Breakpoint types
    //

    EnableInc(HAL)

    genCom("Breakpoint type definitions")

    genVal(DBG_STATUS_CONTROL_C, DBG_STATUS_CONTROL_C)
    genVal(STATUS_ASSERTION_FAILURE, STATUS_ASSERTION_FAILURE)

    DisableInc(HAL)

    //
    // Client Id structure offset definitions.
    //

    genCom("Client Id Structure Offset Definitions")

    genDef(Cid, CLIENT_ID, UniqueProcess)
    genDef(Cid, CLIENT_ID, UniqueThread)

    //
    // Critical section structure offset definitions.
    //

    genCom("Critical Section Structure Offset Definitions")

    genDef(Cs, RTL_CRITICAL_SECTION, DebugInfo)
    genDef(Cs, RTL_CRITICAL_SECTION, LockCount)
    genDef(Cs, RTL_CRITICAL_SECTION, RecursionCount)
    genDef(Cs, RTL_CRITICAL_SECTION, OwningThread)
    genDef(Cs, RTL_CRITICAL_SECTION, LockSemaphore)
    genDef(Cs, RTL_CRITICAL_SECTION, SpinCount)

    //
    // Critical section debug information structure offset definitions.
    //

    genCom("Critical Section Debug Information Structure Offset Definitions")

    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, Type)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, CreatorBackTraceIndex)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, CriticalSection)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, ProcessLocksList)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, EntryCount)
    genDef(Cs, RTL_CRITICAL_SECTION_DEBUG, ContentionCount)

    //
    // Exception record offset, flag, and enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Exception Record Offset, Flag, and Enumerated Type Definitions")

    genVal(EXCEPTION_NONCONTINUABLE, EXCEPTION_NONCONTINUABLE)
    genVal(EXCEPTION_UNWINDING, EXCEPTION_UNWINDING)
    genVal(EXCEPTION_EXIT_UNWIND, EXCEPTION_EXIT_UNWIND)
    genVal(EXCEPTION_STACK_INVALID, EXCEPTION_STACK_INVALID)
    genVal(EXCEPTION_NESTED_CALL, EXCEPTION_NESTED_CALL)
    genVal(EXCEPTION_TARGET_UNWIND, EXCEPTION_TARGET_UNWIND)
    genVal(EXCEPTION_COLLIDED_UNWIND, EXCEPTION_COLLIDED_UNWIND)
    genVal(EXCEPTION_UNWIND, EXCEPTION_UNWIND)
    genVal(EXCEPTION_EXECUTE_HANDLER, EXCEPTION_EXECUTE_HANDLER)
    genVal(EXCEPTION_CONTINUE_SEARCH, EXCEPTION_CONTINUE_SEARCH)
    genVal(EXCEPTION_CONTINUE_EXECUTION, EXCEPTION_CONTINUE_EXECUTION)

#if defined(_X86_)

    genVal(EXCEPTION_CHAIN_END, (ULONG)EXCEPTION_CHAIN_END)

    genVal(FIXED_NTVDMSTATE_LINEAR, (ULONG)FIXED_NTVDMSTATE_LINEAR_PC_AT)
#endif

    genSpc()

    genVal(ExceptionContinueExecution, ExceptionContinueExecution)
    genVal(ExceptionContinueSearch, ExceptionContinueSearch)
    genVal(ExceptionNestedException, ExceptionNestedException)
    genVal(ExceptionCollidedUnwind, ExceptionCollidedUnwind)

    genSpc()

    genDef(Er, EXCEPTION_RECORD, ExceptionCode)
    genDef(Er, EXCEPTION_RECORD, ExceptionFlags)
    genDef(Er, EXCEPTION_RECORD, ExceptionRecord)
    genDef(Er, EXCEPTION_RECORD, ExceptionAddress)
    genDef(Er, EXCEPTION_RECORD, NumberParameters)
    genDef(Er, EXCEPTION_RECORD, ExceptionInformation)
    genVal(ExceptionRecordLength, (sizeof(EXCEPTION_RECORD) + 15) & (~15))

    DisableInc(HAL)

    //
    // Fast Mutex structure offset definitions.
    //

    EnableInc(HAL)

    genCom("Fast Mutex Structure Offset Definitions")

    genDef(Fm, FAST_MUTEX, Count)
    genDef(Fm, FAST_MUTEX, Owner)
    genDef(Fm, FAST_MUTEX, Contention)
    genDef(Fm, FAST_MUTEX, Gate)
    genDef(Fm, FAST_MUTEX, OldIrql)

    //
    // Interrupt priority request level definitions
    //

    genCom("Interrupt Priority Request Level Definitions")

    genVal(PASSIVE_LEVEL, PASSIVE_LEVEL)
    genVal(APC_LEVEL, APC_LEVEL)
    genVal(DISPATCH_LEVEL, DISPATCH_LEVEL)

#if defined(_AMD64_)

    genVal(CLOCK_LEVEL, CLOCK_LEVEL)

#endif

#if defined(_X86_)

    genVal(CLOCK1_LEVEL, CLOCK1_LEVEL)
    genVal(CLOCK2_LEVEL, CLOCK2_LEVEL)

#endif

    genVal(IPI_LEVEL, IPI_LEVEL)
    genVal(POWER_LEVEL, POWER_LEVEL)
    genVal(PROFILE_LEVEL, PROFILE_LEVEL)
    genVal(HIGH_LEVEL, HIGH_LEVEL)

#if defined(_X86_) || defined(_AMD64_)

    genTxt("ifdef NT_UP\n")
    genVal(SYNCH_LEVEL, DISPATCH_LEVEL)
    genTxt("else\n")
    genVal(SYNCH_LEVEL, IPI_LEVEL - 2)
    genTxt("endif\n")

#else

    genTxt("#ifdef NT_UP\n")
    genVal(SYNCH_LEVEL, DISPATCH_LEVEL)
    genTxt("#else\n")
    genVal(SYNCH_LEVEL, IPI_LEVEL - 2)
    genTxt("#endif\n")

#endif

    //
    // Large integer structure offset definitions.
    //

    genCom("Large Integer Structure Offset Definitions")

    genDef(Li, LARGE_INTEGER, LowPart)
    genDef(Li, LARGE_INTEGER, HighPart)

    //
    // List entry structure offset definitions.
    //

    genCom("List Entry Structure Offset Definitions")

    genDef(Ls, LIST_ENTRY, Flink)
    genDef(Ls, LIST_ENTRY, Blink)

    //
    // String structure offset definitions.
    //

    genCom("String Structure Offset Definitions")

    genDef(Str, STRING, Length)
    genDef(Str, STRING, MaximumLength)
    genDef(Str, STRING, Buffer)

    //
    // System time structure offset definitions.
    //

#if defined(_X86_)

    genCom("System Time Structure Offset Definitions")

    genAlt(StLowTime, KSYSTEM_TIME, LowPart)
    genDef(St, KSYSTEM_TIME, High1Time)
    genDef(St, KSYSTEM_TIME, High2Time)

#endif

    //
    // User shared data offset definitions.
    //

    genCom("User Shared Data Structure Offset Definitions")

    genDef(Us, KUSER_SHARED_DATA, TickCountMultiplier)
    genDef(Us, KUSER_SHARED_DATA, InterruptTime)
    genDef(Us, KUSER_SHARED_DATA, SystemTime)
    genDef(Us, KUSER_SHARED_DATA, TimeZoneBias)
    genDef(Us, KUSER_SHARED_DATA, ImageNumberLow)
    genDef(Us, KUSER_SHARED_DATA, ImageNumberHigh)
    genDef(Us, KUSER_SHARED_DATA, NtSystemRoot)
    genDef(Us, KUSER_SHARED_DATA, MaxStackTraceDepth)
    genDef(Us, KUSER_SHARED_DATA, CryptoExponent)
    genDef(Us, KUSER_SHARED_DATA, TimeZoneId)
    genDef(Us, KUSER_SHARED_DATA, LargePageMinimum)
    genDef(Us, KUSER_SHARED_DATA, Reserved2)
    genDef(Us, KUSER_SHARED_DATA, NtProductType)
    genDef(Us, KUSER_SHARED_DATA, ProductTypeIsValid)
    genDef(Us, KUSER_SHARED_DATA, NtMajorVersion)
    genDef(Us, KUSER_SHARED_DATA, NtMinorVersion)
    genDef(Us, KUSER_SHARED_DATA, ProcessorFeatures)
    genDef(Us, KUSER_SHARED_DATA, Reserved1)
    genDef(Us, KUSER_SHARED_DATA, Reserved3)
    genDef(Us, KUSER_SHARED_DATA, TimeSlip)
    genDef(Us, KUSER_SHARED_DATA, AlternativeArchitecture)
    genDef(Us, KUSER_SHARED_DATA, SystemExpirationDate)
    genDef(Us, KUSER_SHARED_DATA, SuiteMask)
    genDef(Us, KUSER_SHARED_DATA, KdDebuggerEnabled)
    genDef(Us, KUSER_SHARED_DATA, ActiveConsoleId)
    genDef(Us, KUSER_SHARED_DATA, DismountCount)
    genDef(Us, KUSER_SHARED_DATA, ComPlusPackage)
    genDef(Us, KUSER_SHARED_DATA, LastSystemRITEventTickCount)
    genDef(Us, KUSER_SHARED_DATA, NumberOfPhysicalPages)
    genDef(Us, KUSER_SHARED_DATA, SafeBootMode)
    genDef(Us, KUSER_SHARED_DATA, TraceLogging)
    genDef(Us, KUSER_SHARED_DATA, TestRetInstruction)
    genDef(Us, KUSER_SHARED_DATA, SystemCall)
    genDef(Us, KUSER_SHARED_DATA, SystemCallReturn)
    genDef(Us, KUSER_SHARED_DATA, SystemCallPad)
    genDef(Us, KUSER_SHARED_DATA, TickCount)
    genDef(Us, KUSER_SHARED_DATA, TickCountQuad)
    genDef(Us, KUSER_SHARED_DATA, Wow64SharedInformation)

    //
    // Time structure offset definitions.
    //

    genCom("Time Structure Offset Definitions")

    genAlt(TmLowTime, LARGE_INTEGER, LowPart)
    genAlt(TmHighTime, LARGE_INTEGER , HighPart)

    DisableInc(HAL)

    //
    // Thread switch counter structure offset definitions.
    //

    genCom("Thread Switch Counter Offset Definitions")

    genDef(Tw, KTHREAD_SWITCH_COUNTERS, FindAny)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, FindIdeal)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, FindLast)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleAny)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleCurrent)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleIdeal)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, IdleLast)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, PreemptAny)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, PreemptCurrent)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, PreemptLast)
    genDef(Tw, KTHREAD_SWITCH_COUNTERS, SwitchToIdle)

    //
    // Status code definitions
    //

    genCom("Status Code Definitions")

    genVal(STATUS_ACCESS_VIOLATION, STATUS_ACCESS_VIOLATION)
    genVal(STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED)
    genVal(STATUS_BAD_COMPRESSION_BUFFER, STATUS_BAD_COMPRESSION_BUFFER)
    genVal(STATUS_BREAKPOINT, STATUS_BREAKPOINT)
    genVal(STATUS_CALLBACK_POP_STACK, STATUS_CALLBACK_POP_STACK)
    genVal(STATUS_DATATYPE_MISALIGNMENT, STATUS_DATATYPE_MISALIGNMENT)
    genVal(STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND)
    genVal(STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO)
    genVal(STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT)
    genVal(STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION)
    genVal(STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW)
    genVal(STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK)
    genVal(STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW)
    genVal(STATUS_FLOAT_MULTIPLE_FAULTS, STATUS_FLOAT_MULTIPLE_FAULTS)
    genVal(STATUS_FLOAT_MULTIPLE_TRAPS, STATUS_FLOAT_MULTIPLE_TRAPS)
    genVal(STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION)
    genVal(STATUS_ILLEGAL_FLOAT_CONTEXT, STATUS_ILLEGAL_FLOAT_CONTEXT)
    genVal(STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION)
    genVal(STATUS_INSTRUCTION_MISALIGNMENT, STATUS_INSTRUCTION_MISALIGNMENT)
    genVal(STATUS_INVALID_HANDLE, STATUS_INVALID_HANDLE)
    genVal(STATUS_INVALID_LOCK_SEQUENCE, STATUS_INVALID_LOCK_SEQUENCE)
    genVal(STATUS_INVALID_OWNER, STATUS_INVALID_OWNER)
    genVal(STATUS_INVALID_PARAMETER, STATUS_INVALID_PARAMETER)
    genVal(STATUS_INVALID_PARAMETER_1, STATUS_INVALID_PARAMETER_1)
    genVal(STATUS_INVALID_SYSTEM_SERVICE, STATUS_INVALID_SYSTEM_SERVICE)
    genVal(STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO)
    genVal(STATUS_INTEGER_OVERFLOW, STATUS_INTEGER_OVERFLOW)
    genVal(STATUS_IN_PAGE_ERROR, STATUS_IN_PAGE_ERROR)
    genVal(STATUS_KERNEL_APC, STATUS_KERNEL_APC)
    genVal(STATUS_LONGJUMP, STATUS_LONGJUMP)
    genVal(STATUS_NO_CALLBACK_ACTIVE, STATUS_NO_CALLBACK_ACTIVE)
    genVal(STATUS_NO_EVENT_PAIR, STATUS_NO_EVENT_PAIR)
    genVal(STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION)
    genVal(STATUS_SINGLE_STEP, STATUS_SINGLE_STEP)
    genVal(STATUS_STACK_BUFFER_OVERRUN, STATUS_STACK_BUFFER_OVERRUN)
    genVal(STATUS_STACK_OVERFLOW, STATUS_STACK_OVERFLOW)
    genVal(STATUS_SUCCESS, STATUS_SUCCESS)
    genVal(STATUS_THREAD_IS_TERMINATING, STATUS_THREAD_IS_TERMINATING)
    genVal(STATUS_TIMEOUT, STATUS_TIMEOUT)
    genVal(STATUS_UNWIND, STATUS_UNWIND)
    genVal(STATUS_UNWIND_CONSOLIDATE, STATUS_UNWIND_CONSOLIDATE)
    genVal(STATUS_USER_APC, STATUS_USER_APC)
    genVal(STATUS_WAKE_SYSTEM_DEBUGGER, STATUS_WAKE_SYSTEM_DEBUGGER)

    //
    // Define kernel object structure definitions.
    //
    // APC object structure defintions.
    //

    genCom("APC Object Structure Offset Definitions")

    genDef(Ap, KAPC, Type)
    genDef(Ap, KAPC, Size)
    genDef(Ap, KAPC, Thread)
    genDef(Ap, KAPC, ApcListEntry)
    genDef(Ap, KAPC, KernelRoutine)
    genDef(Ap, KAPC, RundownRoutine)
    genDef(Ap, KAPC, NormalRoutine)
    genDef(Ap, KAPC, NormalContext)
    genDef(Ap, KAPC, SystemArgument1)
    genDef(Ap, KAPC, SystemArgument2)
    genDef(Ap, KAPC, ApcStateIndex)
    genDef(Ap, KAPC, ApcMode)
    genDef(Ap, KAPC, Inserted)
    genVal(ApcObjectLength, sizeof(KAPC))

    //
    // DPC Object structure definitions.
    //

    EnableInc(HAL)

    genCom("DPC object Structure Offset Definitions")

    genDef(Dp, KDPC, Type)
    genDef(Dp, KDPC, Number)
    genDef(Dp, KDPC, Importance)
    genDef(Dp, KDPC, DpcListEntry)
    genDef(Dp, KDPC, DeferredRoutine)
    genDef(Dp, KDPC, DeferredContext)
    genDef(Dp, KDPC, SystemArgument1)
    genDef(Dp, KDPC, SystemArgument2)
    genDef(Dp, KDPC, DpcData)
    genVal(DpcObjectLength, sizeof(KDPC))

    DisableInc(HAL)

    //
    // Device queue object structure definitions.
    //

    genCom("Device Queue Object Structure Offset Definitions")

    genDef(Dv, KDEVICE_QUEUE, Type)
    genDef(Dv, KDEVICE_QUEUE, Size)
    genDef(Dv, KDEVICE_QUEUE, DeviceListHead)
    genAlt(DvSpinLock, KDEVICE_QUEUE, Lock)
    genDef(Dv, KDEVICE_QUEUE, Busy)
    genVal(DeviceQueueObjectLength, sizeof(KDEVICE_QUEUE))

    //
    // Device object entry structure definitions.
    //

    genCom("Device Queue Entry Structure Offset Definitions")

    genDef(De, KDEVICE_QUEUE_ENTRY, DeviceListEntry)
    genDef(De, KDEVICE_QUEUE_ENTRY, SortKey)
    genDef(De, KDEVICE_QUEUE_ENTRY, Inserted)
    genVal(DeviceQueueEntryLength, sizeof(KDEVICE_QUEUE_ENTRY))

    //
    // Event object structure definitions.
    //

    genCom("Event Object Structure Offset Definitions")

    genDef(Ev, DISPATCHER_HEADER, Type)
    genDef(Ev, DISPATCHER_HEADER, Size)
    genDef(Ev, DISPATCHER_HEADER, SignalState)
    genAlt(EvWaitListHead, KEVENT, Header.WaitListHead)
    genVal(EventObjectLength, sizeof(KEVENT))

    //
    // Event pair object structure definitions.
    //

    genCom("Event Pair Object Structure Offset Definitions")

    genDef(Ep, KEVENT_PAIR, Type)
    genDef(Ep, KEVENT_PAIR, Size)
    genDef(Ep, KEVENT_PAIR, EventLow)
    genDef(Ep, KEVENT_PAIR, EventHigh)

    //
    // Interrupt object structure definitions.
    //

#if defined(_AMD64_)

    EnableInc(HAL)

#endif

    genCom("Interrupt Object Structure Offset Definitions")

    genVal(InLevelSensitive, LevelSensitive)
    genVal(InLatched, Latched)

    genSpc()

    genDef(In, KINTERRUPT, Type)
    genDef(In, KINTERRUPT, Size)
    genDef(In, KINTERRUPT, InterruptListEntry)
    genDef(In, KINTERRUPT, ServiceRoutine)
    genDef(In, KINTERRUPT, ServiceContext)
    genDef(In, KINTERRUPT, SpinLock)
    genDef(In, KINTERRUPT, TickCount)
    genDef(In, KINTERRUPT, ActualLock)
    genDef(In, KINTERRUPT, DispatchAddress)
    genDef(In, KINTERRUPT, Vector)
    genDef(In, KINTERRUPT, Irql)
    genDef(In, KINTERRUPT, SynchronizeIrql)
    genDef(In, KINTERRUPT, FloatingSave)
    genDef(In, KINTERRUPT, Connected)
    genDef(In, KINTERRUPT, Number)
    genDef(In, KINTERRUPT, ShareVector)
    genDef(In, KINTERRUPT, Mode)
    genDef(In, KINTERRUPT, ServiceCount)
    genDef(In, KINTERRUPT, DispatchCount)

#if defined(_AMD64_)

    genDef(In, KINTERRUPT, TrapFrame)

#endif

    genDef(In, KINTERRUPT, DispatchCode)
    genVal(InterruptObjectLength, sizeof(KINTERRUPT))

#if defined(_X86_)

    genSpc()

    genVal(NORMAL_DISPATCH_LENGTH, NORMAL_DISPATCH_LENGTH * sizeof(ULONG))
    genVal(DISPATCH_LENGTH, DISPATCH_LENGTH * sizeof(ULONG))

#endif

#if defined(_AMD64_)

    DisableInc(HAL)

#endif

    //
    // Process object structure offset definitions.
    //

    genCom("Process Object Structure Offset Definitions")

    genDef(Pr, DISPATCHER_HEADER, Type)
    genDef(Pr, DISPATCHER_HEADER, Size)
    genDef(Pr, DISPATCHER_HEADER, SignalState)
    genDef(Pr, KPROCESS, ProfileListHead)
    EnableInc(HAL)
    genDef(Pr, KPROCESS, DirectoryTableBase)
    DisableInc(HAL)

#if defined(_X86_)

    EnableInc(HAL)
    genDef(Pr, KPROCESS, LdtDescriptor)
    genDef(Pr, KPROCESS, IopmOffset)
    DisableInc(HAL)
    genDef(Pr, KPROCESS, Int21Descriptor)
    genDef(Pr, KPROCESS, Iopl)
    genDef(Pr, KPROCESS, VdmTrapcHandler)
    genDef(Pr, EPROCESS, VdmObjects)
    genDef(Pr, EPROCESS, Flags)

#endif

#if defined(_AMD64_)

    genDef(Pr, KPROCESS, IopmOffset)

#endif

    genDef(Pr, KPROCESS, ActiveProcessors)
    genDef(Pr, KPROCESS, KernelTime)
    genDef(Pr, KPROCESS, UserTime)
    genDef(Pr, KPROCESS, ReadyListHead)
    genDef(Pr, KPROCESS, SwapListEntry)
    genDef(Pr, KPROCESS, ThreadListHead)
    genDef(Pr, KPROCESS, ProcessLock)
    genDef(Pr, KPROCESS, Affinity)
    genDef(Pr, KPROCESS, ProcessFlags)
    genDef(Pr, KPROCESS, BasePriority)
    genDef(Pr, KPROCESS, QuantumReset)
    genDef(Pr, KPROCESS, State)
    genDef(Pr, KPROCESS, StackCount)
    genVal(KernelProcessObjectLength, sizeof(KPROCESS))
    genVal(ExecutiveProcessObjectLength, sizeof(EPROCESS))

    //
    // Profile object structure offset definitions.
    //

    genCom("Profile Object Structure Offset Definitions")

    genDef(Pf, KPROFILE, Type)
    genDef(Pf, KPROFILE, Size)
    genDef(Pf, KPROFILE, ProfileListEntry)
    genDef(Pf, KPROFILE, Process)
    genDef(Pf, KPROFILE, RangeBase)
    genDef(Pf, KPROFILE, RangeLimit)
    genDef(Pf, KPROFILE, BucketShift)
    genDef(Pf, KPROFILE, Buffer)
    genDef(Pf, KPROFILE, Segment)
    genDef(Pf, KPROFILE, Affinity)
    genDef(Pf, KPROFILE, Source)
    genDef(Pf, KPROFILE, Started)
    genVal(ProfileObjectLength, sizeof(KPROFILE))

    //
    // Queue object structure offset definitions.
    //

    genCom("Queue Object Structure Offset Definitions")

    genDef(Qu, DISPATCHER_HEADER, Type)
    genDef(Qu, DISPATCHER_HEADER, Size)
    genDef(Qu, DISPATCHER_HEADER, SignalState)
    genDef(Qu, KQUEUE, EntryListHead)
    genDef(Qu, KQUEUE, CurrentCount)
    genDef(Qu, KQUEUE, MaximumCount)
    genDef(Qu, KQUEUE, ThreadListHead)
    genVal(QueueObjectLength, sizeof(KQUEUE))

    //
    // Thread object structure offset definitions
    //

    genCom("Thread Object Structure Offset Definitions")

    genDef(Ee, EEVENT_PAIR, KernelEventPair)
    genDef(Et, ETHREAD, Cid)

#if defined (PERF_DATA)

    genDef(Et, ETHREAD, PerformanceCountLow)
    genDef(Et, ETHREAD, PerformanceCountHigh)

#endif

    genSpc()

    genDef(Th, DISPATCHER_HEADER, Type)
    genDef(Th, DISPATCHER_HEADER, NpxIrql)
    genDef(Th, DISPATCHER_HEADER, Size)

    EnableInc(HAL)

    genDef(Th, DISPATCHER_HEADER, DebugActive)

    DisableInc(HAL)

    genDef(Th, DISPATCHER_HEADER, SignalState)
    genDef(Th, KTHREAD, MutantListHead)
    genDef(Th, KTHREAD, InitialStack)

    EnableInc(HAL)

    genDef(Th, KTHREAD, StackLimit)

    DisableInc(HAL)

    genDef(Th, KTHREAD, KernelStack)
    genDef(Th, KTHREAD, ThreadLock)

    EnableInc(HAL)

    genDef(Th, KTHREAD, ApcState)

    DisableInc(HAL)

    genDef(Th, KTHREAD, ApcQueueable)
    genDef(Th, KTHREAD, NextProcessor)
    genDef(Th, KTHREAD, DeferredProcessor)
    genDef(Th, KTHREAD, AdjustReason)
    genDef(Th, KTHREAD, AdjustIncrement)
    genDef(Th, KTHREAD, ApcQueueLock)

#if !defined(_AMD64_)

    genDef(Th, KTHREAD, ContextSwitches)
    genDef(Th, KTHREAD, State)
    genDef(Th, KTHREAD, NpxState)
    genDef(Th, KTHREAD, WaitIrql)
    genDef(Th, KTHREAD, WaitMode)

#endif

    genDef(Th, KTHREAD, WaitStatus)
    genDef(Th, KTHREAD, WaitBlockList)
    genDef(Th, KTHREAD, GateObject)
    genDef(Th, KTHREAD, Alertable)
    genDef(Th, KTHREAD, WaitNext)
    genDef(Th, KTHREAD, WaitReason)
    genDef(Th, KTHREAD, Priority)
    genDef(Th, KTHREAD, EnableStackSwap)
    genDef(Th, KTHREAD, SwapBusy)
    genDef(Th, KTHREAD, Alerted)
    genDef(Th, KTHREAD, WaitListEntry)
    genDef(Th, KTHREAD, SwapListEntry)
    genDef(Th, KTHREAD, Queue)

#if !defined(_AMD64_)

    genDef(Th, KTHREAD, WaitTime)
    genDef(Th, KTHREAD, CombinedApcDisable)
    genDef(Th, KTHREAD, KernelApcDisable)
    genDef(Th, KTHREAD, SpecialApcDisable)

#endif

    genDef(Th, KTHREAD, Teb)
    genDef(Th, KTHREAD, Timer)
    genDef(Th, KTHREAD, ThreadFlags)
    genDef(Th, KTHREAD, WaitBlock)
    genDef(Th, KTHREAD, SystemAffinityActive)
    genDef(Th, KTHREAD, PreviousMode)
    genDef(Th, KTHREAD, ResourceIndex)
    genDef(Th, KTHREAD, LargeStack)

#if defined(_AMD64_)

    genDef(Th, KTHREAD, ContextSwitches)
    genDef(Th, KTHREAD, State)
    genDef(Th, KTHREAD, NpxState)
    genDef(Th, KTHREAD, WaitIrql)
    genDef(Th, KTHREAD, WaitMode)
    genDef(Th, KTHREAD, WaitTime)
    genDef(Th, KTHREAD, CombinedApcDisable)
    genDef(Th, KTHREAD, KernelApcDisable)
    genDef(Th, KTHREAD, SpecialApcDisable)

#endif

    genDef(Th, KTHREAD, QueueListEntry)
    genDef(Th, KTHREAD, TrapFrame)
    genDef(Th, KTHREAD, CallbackStack)
    genDef(Th, KTHREAD, ServiceTable)

#if defined(_AMD64_)

    genDef(Th, KTHREAD, KernelLimit)

#endif

    genDef(Th, KTHREAD, ApcStateIndex)
    genDef(Th, KTHREAD, IdealProcessor)
    genDef(Th, KTHREAD, Preempted)
    genDef(Th, KTHREAD, ProcessReadyQueue)

#if defined(_AMD64_)

    genDef(Th, KTHREAD, Win32kTable)
    genDef(Th, KTHREAD, Win32kLimit)

#endif

    genDef(Th, KTHREAD, KernelStackResident)
    genDef(Th, KTHREAD, BasePriority)
    genDef(Th, KTHREAD, PriorityDecrement)
    genDef(Th, KTHREAD, Saturation)
    genDef(Th, KTHREAD, UserAffinity)
    genDef(Th, KTHREAD, Process)
    genDef(Th, KTHREAD, Affinity)
    genDef(Th, KTHREAD, ApcStatePointer)
    genDef(Th, KTHREAD, SavedApcState)
    genDef(Th, KTHREAD, FreezeCount)
    genDef(Th, KTHREAD, SuspendCount)
    genDef(Th, KTHREAD, UserIdealProcessor)
    genDef(Th, KTHREAD, CalloutActive)

#if defined(_AMD64_)

    genDef(Th, KTHREAD, CodePatchInProgress)

#elif defined(_X86_)

    genDef(Th, KTHREAD, Iopl)

#endif

    genDef(Th, KTHREAD, Win32Thread)
    genDef(Th, KTHREAD, StackBase)
    genDef(Th, KTHREAD, SuspendApc)
    genDef(Th, KTHREAD, Quantum)
    genDef(Th, KTHREAD, QuantumReset)
    genDef(Th, KTHREAD, KernelTime)
    genDef(Th, KTHREAD, TlsArray)
    genDef(Th, KTHREAD, BBTData)
    genDef(Th, KTHREAD, PowerState)
    genDef(Th, KTHREAD, UserTime)
    genDef(Th, KTHREAD, SuspendSemaphore)
    genDef(Th, KTHREAD, SListFaultCount)
    genDef(Th, KTHREAD, ThreadListEntry)
    genDef(Th, KTHREAD, SListFaultAddress)
    genSpc()
    genVal(KI_SLIST_FAULT_COUNT_MAXIMUM, KI_SLIST_FAULT_COUNT_MAXIMUM)
    genVal(KTHREAD_AUTO_ALIGNMENT_BIT, KTHREAD_AUTO_ALIGNMENT_BIT)
    genSpc()
    genVal(KernelThreadObjectLength, sizeof(KTHREAD))
    genVal(ExecutiveThreadObjectLength, sizeof(ETHREAD))
    genSpc()

#if defined(_X86_)

    genVal(NPX_STATE_NOT_LOADED, NPX_STATE_NOT_LOADED)
    genVal(NPX_STATE_LOADED, NPX_STATE_LOADED)

#endif

    //
    // Timer object structure offset definitions
    //

    genCom("Timer object Structure Offset Definitions")

    genDef(Ti, DISPATCHER_HEADER, Type)
    genDef(Ti, DISPATCHER_HEADER, Size)
    genDef(Ti, DISPATCHER_HEADER, Inserted)
    genDef(Ti, DISPATCHER_HEADER, SignalState)
    genDef(Ti, KTIMER, DueTime)
    genDef(Ti, KTIMER, TimerListEntry)
    genDef(Ti, KTIMER, Dpc)
    genDef(Ti, KTIMER, Period)
    genVal(TimerObjectLength, sizeof(KTIMER))

    genSpc()

    //
    // Timer table entry offset definitions.
    //

    genCom("Timer Table Entry Structure Offset Definitions")

    genDef(Tt, KTIMER_TABLE_ENTRY, Entry)
    genDef(Tt, KTIMER_TABLE_ENTRY, Time)
    genVal(TIMER_ENTRY_SIZE, sizeof(KTIMER_TABLE_ENTRY))
    genVal(TIMER_TABLE_SIZE, TIMER_TABLE_SIZE)

    //
    // Wait block structure offset definitions
    //

    genCom("Wait Block Structure Offset Definitions")

    genDef(Wb, KWAIT_BLOCK, WaitListEntry)
    genDef(Wb, KWAIT_BLOCK, Thread)
    genDef(Wb, KWAIT_BLOCK, Object)
    genDef(Wb, KWAIT_BLOCK, NextWaitBlock)
    genDef(Wb, KWAIT_BLOCK, WaitKey)
    genDef(Wb, KWAIT_BLOCK, WaitType)

    //
    // Fiber structure offset definitions.
    //

    genCom("Fiber Structure Offset Definitions")

    genDef(Fb, FIBER, FiberData)
    genDef(Fb, FIBER, ExceptionList)
    genDef(Fb, FIBER, StackBase)
    genDef(Fb, FIBER, StackLimit)
    genDef(Fb, FIBER, DeallocationStack)
    genDef(Fb, FIBER, FiberContext)
    genDef(Fb, FIBER, Wx86Tib)
    genDef(Fb, FIBER, ActivationContextStackPointer)
    genDef(Fb, FIBER, FlsData)
    genDef(Fb, FIBER, GuaranteedStackBytes)

    //
    // Process environment block structure offset definitions.
    //

    genCom("Process Environment Block Structure Offset Definitions")

    genDef(Pe, PEB, KernelCallbackTable)

    genVal(ProcessEnvironmentBlockLength, sizeof(PEB))

    //
    // Define System Service Descriptor Table structures.
    //

    genCom("System Service Descriptor Table Structure Definitions")

    genVal(NUMBER_SERVICE_TABLES, NUMBER_SERVICE_TABLES)
    genVal(SERVICE_NUMBER_MASK, SERVICE_NUMBER_MASK)
    genVal(SERVICE_TABLE_SHIFT, SERVICE_TABLE_SHIFT)
    genVal(SERVICE_TABLE_MASK, SERVICE_TABLE_MASK)
    genVal(SERVICE_TABLE_TEST, SERVICE_TABLE_TEST)

    genSpc()

#if defined(_AMD64_)

    genVal(ThBase, 0)
    genVal(ThLimit, 8)

#endif

    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Base)
    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Count)
    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Limit)
    genDef(Sd, KSERVICE_TABLE_DESCRIPTOR, Number)
    genVal(SdLength, sizeof(KSERVICE_TABLE_DESCRIPTOR))

    //
    // Common TEB structure offset definitions
    //

    genCom("Thread Environment Block Structure Offset Definitions")

#if defined(_WIN64)

    genAlt(TeCmTeb, NT_TIB, ExceptionList)

#endif

#if defined(_X86_)

    genDef(Te, NT_TIB, ExceptionList)

#endif

    genDef(Te, NT_TIB, StackBase)
    genDef(Te, NT_TIB, StackLimit)
    genDef(Te, NT_TIB, FiberData)
    genDef(Te, NT_TIB, Self)
    genDef(Te, TEB, EnvironmentPointer)
    genDef(Te, TEB, ClientId)
    genDef(Te, TEB, ActiveRpcHandle)
    genDef(Te, TEB, ThreadLocalStoragePointer)
    genDef(Te, TEB, CountOfOwnedCriticalSections)
    genAlt(TePeb, TEB, ProcessEnvironmentBlock)
    genDef(Te, TEB, CsrClientThread)
    genDef(Te, TEB, WOW32Reserved)
    genAlt(TeSoftFpcr, TEB, FpSoftwareStatusRegister)
    genDef(Te, TEB, ExceptionCode)
    genDef(Te, TEB, ActivationContextStackPointer)
    genDef(Te, TEB, GdiClientPID)
    genDef(Te, TEB, GdiClientTID)
    genDef(Te, TEB, GdiThreadLocalInfo)
    genDef(Te, TEB, glDispatchTable)
    genDef(Te, TEB, glReserved1)
    genDef(Te, TEB, glReserved2)
    genDef(Te, TEB, glSectionInfo)
    genDef(Te, TEB, glSection)
    genDef(Te, TEB, glTable)
    genDef(Te, TEB, glCurrentRC)
    genDef(Te, TEB, glContext)
    genDef(Te, TEB, DeallocationStack)
    genDef(Te, TEB, TlsSlots)
    genDef(Te, TEB, TlsExpansionSlots)
    genDef(Te, TEB, LastErrorValue)
    genDef(Te, TEB, Vdm)
    genDef(Te, TEB, Instrumentation)
    genDef(Te, TEB, GdiBatchCount)
    genDef(Te, TEB, GuaranteedStackBytes)
    genDef(Te, TEB, SafeThunkCall)
    genDef(Te, TEB, FlsData)

    genVal(ThreadEnvironmentBlockLength, sizeof(TEB))

    genVal(CmThreadEnvironmentBlockOffset, ROUND_TO_PAGES(sizeof(TEB)))

    genNam(TLS_MINIMUM_AVAILABLE)
    genNam(TLS_EXPANSION_SLOTS)

    //
    // Lock Queue structure definitions.
    //

#if defined(_X86_)

    EnableInc(HAL)

#endif

    genCom("Lock Queue Structure Offset Definitions")

    genNam(LOCK_QUEUE_WAIT)
    genNam(LOCK_QUEUE_OWNER)
    genVal(LOCK_QUEUE_HEADER_SIZE, sizeof(KSPIN_LOCK_QUEUE))
    genSpc()

    genNam(LockQueueDispatcherLock)
    genSpc()

    genDef(Lq, KSPIN_LOCK_QUEUE, Next)
    genDef(Lq, KSPIN_LOCK_QUEUE, Lock)
    genSpc()

    genAlt(LqhNext, KLOCK_QUEUE_HANDLE, LockQueue.Next)
    genAlt(LqhLock, KLOCK_QUEUE_HANDLE, LockQueue.Lock)
    genAlt(LqhOldIrql, KLOCK_QUEUE_HANDLE, OldIrql)

#if defined(_X86_)

    DisableInc(HAL)

#endif

    genCom("Performance Definitions")

    genVal(PERF_CONTEXTSWAP_OFFSET,
           PERF_GET_MASK_INDEX(PERF_CONTEXT_SWITCH) * sizeof(ULONG))

    genVal(PERF_CONTEXTSWAP_FLAG, PERF_GET_MASK_GROUP(PERF_CONTEXT_SWITCH))
    genVal(PERF_INTERRUPT_OFFSET,
           PERF_GET_MASK_INDEX(PERF_INTERRUPT) * sizeof(ULONG))

    genVal(PERF_INTERRUPT_FLAG, PERF_GET_MASK_GROUP(PERF_INTERRUPT))
    genVal(PERF_PROFILE_OFFSET,
           PERF_GET_MASK_INDEX(PERF_PROFILE) * sizeof(ULONG))

    genVal(PERF_PROFILE_FLAG, PERF_GET_MASK_GROUP(PERF_PROFILE))
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\ki.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ki.h

Abstract:

    This module contains the private (internal) header file for the
    kernel.

--*/

#ifndef _KI_
#define _KI_

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4706)   // assignment within conditional expression
#pragma warning(disable:4206)   // translation unit empty

#include "ntos.h"
#include "stdio.h"
#include "stdlib.h"
#include "wow64t.h"
#include "zwapi.h"

//
// Define function prototypes for labels that delineate the bounds of the
// pop SLIST code that is susceptible to causing corruption on suspend
// operations and dispatch interrupts.
//

VOID
ExpInterlockedPopEntrySListEnd (
    VOID
    );

VOID
ExpInterlockedPopEntrySListFault (
    VOID
    );

VOID
ExpInterlockedPopEntrySListResume (
    VOID
    );

VOID
FASTCALL
KiCheckForSListAddress (
    PKTRAP_FRAME TrapFrame
    );

VOID
KiLargePageSafetyCheck(
    VOID
    );

//
// Define spin lock array structure.
//

typedef struct _ALIGNED_SPINLOCK_STRUCT {
    ALIGNED_SPINLOCK Lock;
} ALIGNED_SPINLOCK_STRUCT, *PALIGNED_SPINLOCK_STRUCT;

//
// Priority increment value definitions
//

#define ALERT_INCREMENT 2           // Alerted unwait priority increment
#define BALANCE_INCREMENT 10        // Balance set priority increment
#define RESUME_INCREMENT 0          // Resume thread priority increment
#define TIMER_EXPIRE_INCREMENT 0    // Timer expiration priority increment

//
// Define time critical priority class base.
//

#define TIME_CRITICAL_PRIORITY_BOUND 14

//
// Define NIL pointer value.
//

#define NIL (PVOID)NULL             // Null pointer to void

//
// Define macros which are used in the kernel only
//
// Clear member in set
//

#define ClearMember(Member, Set) \
    Set = Set & (~((ULONG_PTR)1 << (Member)))

//
// Set member in set
//

#define SetMember(Member, Set) \
    Set = Set | ((ULONG_PTR)1 << (Member))

//
// Define flag to identify internally raised exceptions and define internal
// exception codes.
//

#define KI_EXCEPTION_INTERNAL               0x10000000
#define KI_EXCEPTION_GP_FAULT               (KI_EXCEPTION_INTERNAL | 0x1)
#define KI_EXCEPTION_INVALID_OP             (KI_EXCEPTION_INTERNAL | 0x2)
#define KI_EXCEPTION_INTEGER_DIVIDE_BY_ZERO (KI_EXCEPTION_INTERNAL | 0x3)
#define KI_EXCEPTION_ACCESS_VIOLATION       (KI_EXCEPTION_INTERNAL | 0x4)

//
// Query DisableThunkEmulation flag for the current thread.
//

#define KiQueryNxThunkEmulationState() \
            KeGetCurrentThread()->ApcState.Process->Flags.DisableThunkEmulation

LOGICAL
KiEmulateAtlThunk (
    IN OUT ULONG *InstructionPointer,
    IN OUT ULONG *StackPointer,
    IN OUT ULONG *Eax,
    IN OUT ULONG *Ecx,
    IN OUT ULONG *Edx
    );

FORCEINLINE
LOGICAL
FASTCALL
KiCheckDueTime (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function checks to determine if the specified timer has already
    expired.

    N.B. This function is called at raised IRQL with the dispatcher lock held.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    If the specified timer has not expired, then a value of TRUE is returned.
    Otherwise, a value of FALSE is returned.

--*/

{

    LARGE_INTEGER InterruptTime;

    //
    // Get the current interrupt time and compare with the timer due time.
    //

    KiQueryInterruptTime(&InterruptTime);
    if ((ULONG64)InterruptTime.QuadPart >= Timer->DueTime.QuadPart) {
        return FALSE;

    } else {
        Timer->Header.Inserted = TRUE;
        return TRUE;
    }
}

FORCEINLINE
SCHAR
KiComputeNewPriority (
    IN PKTHREAD Thread,
    IN SCHAR Adjustment
    )

/*++

Routine Description:

    This function computes a new priority for the specified thread by
    subtracting the priority decrement value plus the adjustment from
    the thread priority.

Arguments:

    Thread - Supplies a pointer to a thread object.

    Adjustment - Supplies an additional adjustment value.

Return Value:

    The new priority is returned as the function value.

--*/

{

    SCHAR Priority;

    //
    // Compute the new thread priority.
    //

    ASSERT((Thread->PriorityDecrement >= 0) && (Thread->PriorityDecrement <= Thread->Priority));

    ASSERT((Thread->Priority < LOW_REALTIME_PRIORITY) ? TRUE : (Thread->PriorityDecrement == 0));

    Priority = Thread->Priority;
    if (Priority < LOW_REALTIME_PRIORITY) {
        Priority = Priority - Thread->PriorityDecrement - Adjustment;
        if (Priority < Thread->BasePriority) {
            Priority = Thread->BasePriority;
        }
    
        Thread->PriorityDecrement = 0;
    }

    ASSERT((Thread->BasePriority == 0) || (Priority != 0));

    return Priority;
}

VOID
FASTCALL
KiExitDispatcher (
    IN KIRQL OldIrql
    );

FORCEINLINE
VOID
KiAcquireKobjectLock (
    IN PVOID Object
    )

/*++

Routine Description:

    This function acquires a kernel dispatcher object lock.

    N.B. This function must be called at an IRQL greater than or equal
         to dispatch level.

Arguments:

    Object - Supplies a pointer to a kernel dispatcher object.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    PKEVENT Event = Object;

#if !defined(_AMD64_)

    LONG Lock;

#endif

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

#if defined(_AMD64_)

    while (InterlockedBitTestAndSet((LONG *)&Event->Header.Lock, KOBJECT_LOCK_BIT_NUMBER)) {
        do {
            KeYieldProcessor();
        } while ((Event->Header.Lock & KOBJECT_LOCK_BIT) != 0);
    }

#else

    do {
        while (((Lock = Event->Header.Lock) & KOBJECT_LOCK_BIT) != 0) {
            KeYieldProcessor();
        }

    } while (InterlockedCompareExchange(&Event->Header.Lock,
                                        Lock | KOBJECT_LOCK_BIT,
                                        Lock) != Lock);

#endif

#else

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    UNREFERENCED_PARAMETER(Object);

#endif // !defined(NT_UP)

    return;
}

FORCEINLINE
VOID
KiReleaseKobjectLock (
    IN PVOID Object
    )

/*++

Routine Description:

    This function releases a kernel dispatcher object lock.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    Object - Supplies a pointer to a kernel dispatcher object.

Return Value:

    None.

--*/

{


#if !defined(NT_UP)

    PKEVENT Event = Object;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    InterlockedAnd(&Event->Header.Lock, ~KOBJECT_LOCK_BIT);

#else

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    UNREFERENCED_PARAMETER(Object);

#endif

    return;
}
              
FORCEINLINE
KIRQL
FASTCALL
KiAcquireSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function conditionally raises IRQL to DISPATCH_LEVEL and acquires
    the specified spin lock.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    SpinLock - Supplies the address of a spin lock.

Return Value:

    If the IRQL is raised, then the previous IRQL is returned. Otherwise, zero
    is returned.

--*/

{

    KIRQL OldIrql;

    //
    // If the DPC thread is active, then raise IRQL and acquire the specified
    // spin lock. Otherwise, zero the previous IRQL and acquire the specified
    // spin lock at DISPATCH_LEVEL.
    //

    if (KeGetCurrentPrcb()->DpcThreadActive != FALSE) {
        KeAcquireSpinLock(SpinLock, &OldIrql);

    } else {

        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

        OldIrql = DISPATCH_LEVEL;
        KeAcquireSpinLockAtDpcLevel(SpinLock);
    }

    return OldIrql;
}

FORCEINLINE
VOID
FASTCALL
KiReleaseSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases the specified spin lock and conditionally lowers
    IRQL to its previous value.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    SpinLock - Supplies the address of a spin lock.

    OldIrql - Supplies the previous IRQL.

Return Value:

    None.

--*/

{

    //
    // If the DPC thread is active, then release the specified spin lock and
    // lower IRQL to its previous value. Otherwise, release specified spin
    // lock from DISPATCH_LEVEL.
    //

    if (KeGetCurrentPrcb()->DpcThreadActive != FALSE) {
        KeReleaseSpinLock(SpinLock, OldIrql);

    } else {

        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

        KeReleaseSpinLockFromDpcLevel(SpinLock);
    }

    return;
}

FORCEINLINE
VOID
FASTCALL
KiAcquireInStackQueuedSpinLockForDpc (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function conditionally raises IRQL to DISPATCH_LEVEL and acquires
    the specified in-stack spin lock.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    SpinLock - Supplies the address of a spin lock.

    LockHandle - Supplies the address of a lock handle.

Return Value:

    None.

--*/

{
    //
    // If the DPC thread is active, then raise IRQL and acquire the specified
    // in-stack spin lock. Otherwise, acquire the specified in-stack spin lock
    // at DISPATCH_LEVEL.
    //

    if (KeGetCurrentPrcb()->DpcThreadActive != FALSE) {
        KeAcquireInStackQueuedSpinLock(SpinLock, LockHandle);

    } else {

        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

        KeAcquireInStackQueuedSpinLockAtDpcLevel(SpinLock, LockHandle);
    }

    return;
}

FORCEINLINE
VOID
FASTCALL
KiReleaseInStackQueuedSpinLockForDpc (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function releases the specified in-stack spin lock and conditionally
    lowers IRQL to its previous value.

    N.B. The conditional IRQL raise is predicated on whether a thread DPC 
         is enabled.

Arguments:

    LockHandle - Supplies the address of a lock handle.

Return Value:

    None.

--*/

{

    //
    // If threaded DPCs are enabled, then release the specified in-stack
    // spin lock and lower IRQL to its previous value. Otherwise, release
    // the specified in-stack spin lock from DISPATCH_LEVEL.
    //

    if (KeGetCurrentPrcb()->DpcThreadActive != FALSE) {
        KeReleaseInStackQueuedSpinLock(LockHandle);

    } else {

        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

        KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle);
    }

    return;
}

FORCEINLINE
VOID
KzAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function acquires a spin lock at the current IRQL.

Arguments:

    SpinLock - Supplies a pointer to an spin lock.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

#if defined(_WIN64)

#if defined(_AMD64_)
    while (InterlockedBitTestAndSet64((LONG64 *)SpinLock, 0))
#else
    while (InterlockedExchangeAcquire64((PLONGLONG)SpinLock, 1) != 0)
#endif

#else   // defined(_WIN64)
    while (InterlockedExchange((PLONG)SpinLock, 1) != 0)
#endif
    {
        do {
            KeYieldProcessor();
        } while (*(volatile LONG_PTR *)SpinLock != 0);
    }

#else  // !defined(NT_UP)

    UNREFERENCED_PARAMETER(SpinLock);

#endif // !defined(NT_UP)

    return;
}

FORCEINLINE
BOOLEAN
KzTryToAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function attempts acquires a spin lock at the current IRQL. If
    the spinlock is already owned, then FALSE is returned. Otherwise,
    TRUE is returned.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned as the function value.

--*/

{

    //
    // Try to acquire the specified spin lock at the current IRQL.
    //

#if !defined(NT_UP)

#if defined(_AMD64_)

    if (*(volatile LONG64 *)SpinLock == 0) {
        return !InterlockedBitTestAndSet64((LONG64 *)SpinLock, 0);

#else

    if (*(volatile LONG_PTR *)SpinLock == 0) {
        return (BOOLEAN)(InterlockedExchange((PLONG)SpinLock, 1) == 0);

#endif

    } else {
        return FALSE;
    }

#else

    UNREFERENCED_PARAMETER(SpinLock);

    return TRUE;

#endif // !defined(NT_UP)

}

FORCEINLINE
VOID
KiAcquirePrcbLock (
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This routine acquires the PRCB lock for the specified processor.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    Prcb - Supplies a pointer to a processor control block.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    KzAcquireSpinLock(&Prcb->PrcbLock);
    return;
}

FORCEINLINE
VOID
KiAcquireTwoPrcbLocks (
    IN PKPRCB FirstPrcb,
    IN PKPRCB SecondPrcb
    )

/*++

Routine Description:

    This routine acquires the specified PRCB locks in address order.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    FirstPrcb - Supplies a pointer to a processor control block.

    SecondPrcb - Supplies a pointer to a processor control block.

Return Value:

    None.

--*/

{

    PKPRCB LowPrcb;
    PKPRCB HighPrcb;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    LowPrcb = FirstPrcb;
    HighPrcb = SecondPrcb;
    if (FirstPrcb > SecondPrcb) {
        LowPrcb = SecondPrcb;
        HighPrcb = FirstPrcb;
    }

    KzAcquireSpinLock(&LowPrcb->PrcbLock);
    if (LowPrcb != HighPrcb) {
        KzAcquireSpinLock(&HighPrcb->PrcbLock);
    }

    return;
}

FORCEINLINE
VOID
KiReleasePrcbLock (
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This routine release the PRCB lock for the specified processor.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    Prcb - Supplies a pointer to a processor control block.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

#if !defined(NT_UP)

    ASSERT(Prcb->PrcbLock != 0);
    
#if defined(_X86_)

    InterlockedAnd((volatile LONG *)&Prcb->PrcbLock, 0);

#elif defined(_AMD64_)

    InterlockedAnd64((volatile LONG64 *)&Prcb->PrcbLock, 0);

#else

#error "no target architecture"

#endif

#else

    UNREFERENCED_PARAMETER(Prcb);

#endif

    return;
}

FORCEINLINE
VOID
KiReleaseTwoPrcbLocks (
    IN PKPRCB FirstPrcb,
    IN PKPRCB SecondPrcb
    )

/*++

Routine Description:

    This routine releases the specified PRCB locks.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    FirstPrcb - Supplies a pointer to a processor control block.

    SecondPrcb - Supplies a pointer to a processor control block.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

#if !defined(NT_UP)

    KiReleasePrcbLock (FirstPrcb);
    if (FirstPrcb != SecondPrcb) {
        KiReleasePrcbLock(SecondPrcb);
    }

#else

    UNREFERENCED_PARAMETER(FirstPrcb);
    UNREFERENCED_PARAMETER(SecondPrcb);

#endif

    return;
}

FORCEINLINE
VOID
KiAcquireThreadLock (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This routine acquires the thread lock for the specified thread.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    Thread - Supplies a pointer to a thread object.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    KzAcquireSpinLock(&Thread->ThreadLock);
    return;
}

FORCEINLINE
BOOLEAN
KiTryToAcquireThreadLock (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This routine tried to acquire the thread lock for the specified thread.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    Thread - Supplies a pointer to a thread object.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    return KzTryToAcquireSpinLock(&Thread->ThreadLock);
}

FORCEINLINE
VOID
KiReleaseThreadLock (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This routine releases the thread lock for the specified thread.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    Thread - Supplies a pointer to a thread object.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

#if !defined(NT_UP)

    KeMemoryBarrierWithoutFence();

#if defined(_X86_)

    InterlockedAnd((volatile LONG *)&Thread->ThreadLock, 0);

#elif defined(_AMD64_)

    InterlockedAnd64((volatile LONG64 *)&Thread->ThreadLock, 0);

#else

#error "no target architecture"

#endif

#else

    UNREFERENCED_PARAMETER(Thread);

#endif

    return;
}

extern ALIGNED_SPINLOCK_STRUCT KiTimerTableLock[LOCK_QUEUE_TIMER_TABLE_LOCKS];

FORCEINLINE
PKSPIN_LOCK_QUEUE
KiAcquireTimerTableLock (
    __in ULONG Hand
    )

/*++

Routine Description:

    This routine acquires the timer table lock.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    Hand - Supplies the timer table hand value.

Return Value:

    None.

--*/

{

#if defined(NT_UP)

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    UNREFERENCED_PARAMETER(Hand);

    return NULL;

#else

    PKSPIN_LOCK_QUEUE LockQueue;
    ULONG Number;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    Number = (Hand >> LOCK_QUEUE_TIMER_LOCK_SHIFT) & (LOCK_QUEUE_TIMER_TABLE_LOCKS - 1);
    Number += LockQueueTimerTableLock;
    LockQueue = KeQueuedSpinLockContext(Number);
    KeAcquireQueuedSpinLockAtDpcLevel(LockQueue);
    return LockQueue;

#endif

}

FORCEINLINE
VOID
KiReleaseTimerTableLock (
    __inout PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This routine releases the timer table lock.

    N.B. This routine must be called from an IRQL greater than or equal to
         dispatch level.

Arguments:

    LockQueue - Supplies a pointer to the queued spin lock.

Return Value:

    None.

--*/

{

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);


#if defined(NT_UP)

    UNREFERENCED_PARAMETER(LockQueue);

#else

    KeReleaseQueuedSpinLockFromDpcLevel(LockQueue);

#endif

    return;
}

extern ULARGE_INTEGER KiTimeIncrementReciprocal;
extern CCHAR KiTimeIncrementShiftCount;

#if defined(_WIN64)

FORCEINLINE
ULONG
KiComputeTimerTableIndex (
    IN ULONG64 DueTime
    )

/*++

Routine Description:

    This function computes the timer table index for the specified due time.

    The formula for the index calculation is:

    Index = (Due Time / Maximum time increment) & (Table Size - 1)

    The time increment division is performed using reciprocal multiplication.

    N.B. The maximum time increment determines the interval corresponding
         to a tick.

Arguments:

    DueTime - Supplies the timer due time.

Return Value:

    The time table index is returned as the function value.

--*/

{

    ULONG64 HighTime;
    ULONG Index;

    //
    // Compute the timer table index.
    //

    HighTime = UnsignedMultiplyHigh(DueTime,
                                    KiTimeIncrementReciprocal.QuadPart);

    Index = (ULONG)(HighTime >> KiTimeIncrementShiftCount);
    return (Index & (TIMER_TABLE_SIZE - 1));
}

#else

ULONG
KiComputeTimerTableIndex (
    IN ULONG64 DueTime
    );

#endif

FORCEINLINE
LOGICAL
FASTCALL
KiComputeDueTime (
    IN PKTIMER Timer,
    IN LARGE_INTEGER Interval,
    OUT PULONG Hand
    )

/*++

Routine Description:

    This function computes the due time for the specified interval value and
    stores the due time in the specified timer.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Interval - Supplies the absolute or relative time at which the time
        is to expire.

    Hand - Supplies a pointer to a variable that receives the computed hand
        value.

Return Value:

    If the computed due time has not already elapsed, then a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG64 DueTime;
    LARGE_INTEGER InterruptTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER TimeDifference;

    //
    // If the specified interval is not a relative time (i.e., is an absolute
    // time), then convert it to relative time.
    //

    Timer->Header.Absolute = FALSE;
    if (Interval.HighPart >= 0) {
        KiQuerySystemTime(&SystemTime);
        TimeDifference.QuadPart = SystemTime.QuadPart - Interval.QuadPart;

        //
        // If the resultant relative time is greater than or equal to zero,
        // then the timer has already expired.
        //

        Timer->Header.Absolute = TRUE;
        if (TimeDifference.HighPart >= 0) {
            Timer->Header.SignalState = TRUE;
            Timer->DueTime.QuadPart = 0;
            Timer->Header.Hand = 0;
            *Hand = 0;
            return FALSE;
        }

        Interval = TimeDifference;
    }

    //
    // Get the current interrupt time, compute the timer due time, and insert
    // the timer in the timer table.
    //

    KiQueryInterruptTime(&InterruptTime);
    DueTime = InterruptTime.QuadPart - Interval.QuadPart;
    Timer->DueTime.QuadPart = DueTime;
    *Hand = KiComputeTimerTableIndex(DueTime);
    Timer->Header.Hand = (UCHAR)*Hand;
    Timer->Header.Inserted = TRUE;
    return TRUE;
}

FORCEINLINE
VOID
KiClearIdleSummary (
    IN KAFFINITY Mask
    )

/*++

Routine Description:

    This function interlocked clears the specified mask into the current idle
    summary.

Arguments:

    Mask - Supplies the affinity mask to merge.

Return Value:

    None.

--*/

{

#if defined(NT_UP)

    KiIdleSummary &= ~Mask;

#else

#if defined(_X86_)

    InterlockedAnd((volatile LONG *)&KiIdleSummary, ~(LONG)Mask);

#else

    InterlockedAnd64((volatile LONG64 *)&KiIdleSummary, ~(LONG64)Mask);

#endif

#endif

    return;
}

FORCEINLINE
VOID
FASTCALL
KiSetDueTime (
    IN PKTIMER Timer,
    IN LARGE_INTEGER Interval,
    OUT PULONG Hand
    )

/*++

Routine Description:

    This function computes the due time for the specified interval value and
    stores the due time in the specified timer.

    N.B. This function is called at raised IRQL.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Interval - Supplies the absolute or relative time at which the time
        is to expire.

    Hand - Supplies a pointer to a variable that receives the computed hand
        value.

Return Value:

    None.

--*/

{

    ULONG64 DueTime;
    LARGE_INTEGER InterruptTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER TimeDifference;

    //
    // If the specified interval is not a relative time (i.e., is an absolute
    // time), then attempt to convert it to relative time.
    //

    Timer->Header.Absolute = FALSE;
    if (Interval.HighPart >= 0) {

        //
        // Compute the relative time as the system time minus the absolute
        // time.
        //
        // If the resultant relative time is greater than or equal to zero,
        // then the timer has already expired.
        //
        // N.B. A explicit due time of zero will result is a difference that
        //      is greater than or equal to zero.
        //

        KiQuerySystemTime(&SystemTime);
        TimeDifference.QuadPart = SystemTime.QuadPart - Interval.QuadPart;
        Timer->Header.Absolute = TRUE;
        if (TimeDifference.HighPart >= 0) {
            Timer->DueTime.QuadPart = 0;
            *Hand = 0;
            Timer->Header.Hand = 0;
            return;
        }

        Interval = TimeDifference;
    }

    //
    // Get the current interrupt time, compute the timer due time, and compute
    // the timer hand value.
    //

    KiQueryInterruptTime(&InterruptTime);
    DueTime = InterruptTime.QuadPart - Interval.QuadPart;
    Timer->DueTime.QuadPart = DueTime;
    *Hand = KiComputeTimerTableIndex(DueTime);
    Timer->Header.Hand = (UCHAR)*Hand;
    return;
}

FORCEINLINE
VOID
KiSetIdleSummary (
    IN KAFFINITY Mask
    )

/*++

Routine Description:

    This function interlocked merges the specified mask into the current idle
    summary.

Arguments:

    Mask - Supplies the affinity mask to merge.

Return Value:

    None.

--*/

{

#if defined(NT_UP)

    KiIdleSummary |= Mask;

#else

#if defined(_X86_)

    InterlockedOr((volatile LONG *)&KiIdleSummary, (LONG)Mask);

#else

    InterlockedOr64((volatile LONG64 *)&KiIdleSummary, (LONG64)Mask);

#endif

#endif

    return;
}

extern volatile KAFFINITY KiIdleSMTSummary;

FORCEINLINE
VOID
KiClearSMTSummary (
    IN KAFFINITY Mask
    )

/*++

Routine Description:

    This function interlocked clears the specified mask into the current SMT
    summary.

Arguments:

    Mask - Supplies the affinity mask to merge.

Return Value:

    None.

--*/

{

#if defined(NT_SMT)

#if defined(_X86_)

    InterlockedAnd((volatile LONG *)&KiIdleSMTSummary, ~(LONG)Mask);

#else

    InterlockedAnd64((volatile LONG64 *)&KiIdleSMTSummary, ~(LONG64)Mask);

#endif

#else

    UNREFERENCED_PARAMETER(Mask);

#endif

    return;
}

FORCEINLINE
VOID
KiSetSMTSummary (
    IN KAFFINITY Mask
    )

/*++

Routine Description:

    This function interlocked merges the specified mask into the current SMT
    summary.

Arguments:

    Mask - Supplies the affinity mask to merge.

Return Value:

    None.

--*/

{

#if defined(NT_SMT)

#if defined(_X86_)

    InterlockedOr((volatile LONG *)&KiIdleSMTSummary, (LONG)Mask);

#else

    InterlockedOr64((volatile LONG64 *)&KiIdleSMTSummary, (LONG64)Mask);

#endif

#else

    UNREFERENCED_PARAMETER(Mask);

#endif

    return;
}

FORCEINLINE
VOID
KiBoostPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function boosts the priority of the specified thread using
    the same algorithm used when a thread gets a boost from a wait
    operation.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    KPRIORITY NewPriority;                                    

    //
    // If the thread is not a real time thread and does not already
    // have an unusual boost, then boost the priority as specified.
    //

    KiAcquireThreadLock(Thread);                                
    if ((Thread->Priority < LOW_REALTIME_PRIORITY) &&
        (Thread->PriorityDecrement == 0)) {

        NewPriority = Thread->BasePriority + Increment; 
        if (NewPriority > Thread->Priority) {             
            if (NewPriority >= LOW_REALTIME_PRIORITY) {     
                NewPriority = LOW_REALTIME_PRIORITY - 1;    
            }                                               
                                                            
            Thread->Quantum = Thread->QuantumReset;     
            KiSetPriorityThread(Thread, NewPriority);     
        }                                                   
    }

    KiReleaseThreadLock(Thread);
    return;
}

BOOLEAN
KiHandleNmi (
    VOID
    );

FORCEINLINE
LOGICAL
KiIsKernelStackSwappable (
    IN KPROCESSOR_MODE WaitMode,
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function determines whether the kernel stack is swappable for the
    the specified thread in a wait operation.

Arguments:

    WaitMode - Supplies the processor mode of the wait operation.

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    If the kernel stack for the specified thread is swappable, then TRUE is
    returned. Otherwise, FALSE is returned.

--*/

{

    return ((WaitMode != KernelMode) &&                         
            (Thread->EnableStackSwap != FALSE) &&               
            (Thread->Priority < (LOW_REALTIME_PRIORITY + 9)));
}

VOID
FASTCALL
KiRetireDpcList (
    PKPRCB Prcb
    );

FORCEINLINE
VOID
FASTCALL
KiUnlockDispatcherDatabase (
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function unlocks the dispatcher database and exits the scheduler.

Arguments:

    OldIrql - Supplies the previous IRQL.

Return Value:

    None.

--*/

{

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KiExitDispatcher(OldIrql);
    return;
}

//
// Private (internal) structure definitions.
//
// APC Parameter structure.
//

typedef struct _KAPC_RECORD {
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC_RECORD, *PKAPC_RECORD;

//
// Executive initialization.
//

VOID
ExpInitializeExecutive (
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// Interprocessor interrupt function definitions.
//
// Define immediate interprocessor commands.
//

#if !defined(_AMD64_)

#define IPI_APC 1                       // APC interrupt request
#define IPI_DPC 2                       // DPC interrupt request
#define IPI_FREEZE 4                    // freeze execution request
#define IPI_PACKET_READY 8              // packet ready request
#define IPI_SYNCH_REQUEST 16            // reverse stall packet request

#else

#define TARGET_FREEZE 0x05

#endif

//
// Define interprocess interrupt types.
//

typedef ULONG KIPI_REQUEST;

#define IPI_INSTRUMENT_COUNT(a,b)

#if !defined(_AMD64_)

VOID
FASTCALL
KiIpiSend (
    IN KAFFINITY TargetProcessors,
    IN KIPI_REQUEST Request
    );

#endif

VOID
KiIpiSendPacket (
    IN KAFFINITY TargetProcessors,
    IN PKIPI_WORKER WorkerFunction,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
FASTCALL
KiIpiSignalPacketDone (
    IN PKIPI_CONTEXT SignalDone
    );

FORCEINLINE
VOID
KiIpiStallOnPacketTargetsPrcb (
    KAFFINITY TargetSet,
    PKPRCB Prcb
    )

/*++

Routine Description:

    This function waits until the specified set of processors have signaled
    their completion of a requested function.

    N.B. The exact protocol used between the source and the target of an
         interprocessor request is not specified. Minimally the source
         must construct an appropriate packet and send the packet to a set
         of specified targets. Each target receives the address of the packet
         address as an argument, and minimally must clear the packet address
         when the mutually agreed upon protocol allows. The target has three
         options:

         1. Capture necessary information, release the source by clearing
            the packet address, execute the request in parallel with the
            source, and return from the interrupt.

         2. Execute the request in series with the source, release the
            source by clearing the packet address, and return from the
            interrupt.

         3. Execute the request in series with the source, release the
            source, wait for a reply from the source based on a packet
            parameter, and return from the interrupt.

    This function is provided to enable the source to synchronize with the
    target for cases 2 and 3 above.

    N.B. There is no support for method 3 above.

Arguments:

    TargetSet - Supplies the the target set of IPI processors.

    Prcb - Supplies the address of the current PRCB.

Return Value:

    None.

--*/

{

    KAFFINITY volatile *Barrier;

    ASSERT(Prcb == KeGetCurrentPrcb());

    //
    // If there is one and only one bit set in the target set, then wait
    // on the target set. Otherwise, wait on the packet barrier.
    //

    Barrier = &Prcb->TargetSet;
    if ((TargetSet & (TargetSet - 1)) != 0) {
       Barrier = &Prcb->PacketBarrier;
    }

    while (*Barrier != 0) {
        KeYieldProcessor();
    }

    return;
}

FORCEINLINE
VOID
KiIpiStallOnPacketTargets (
    KAFFINITY TargetSet
    )

/*++

Routine Description:

    This function waits until the specified set of processors have signaled
    their completion of a requested function.

Arguments:

    TargetSet - Supplies the the target set of IPI processors.

Return Value:

    None.

--*/

{

    KiIpiStallOnPacketTargetsPrcb(TargetSet, KeGetCurrentPrcb());
    return;
}

//
// Private (internal) function definitions.
//

VOID
FASTCALL
KiUnwaitThread (
    IN PKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment
    );

FORCEINLINE
VOID
KiActivateWaiterQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function is called when the current thread is about to enter a
    wait state and is currently processing a queue entry. The current
    number of threads processign entries for the queue is decrement and
    an attempt is made to activate another thread if the current count
    is less than the maximum count, there is a waiting thread, and the
    queue is not empty.

    N.B. It is possible that this function is called on one processor
         holding the dispatcher database lock while the state of the
         specified queue object is being modified on another processor
         while holding only the queue object lock. This does not cause
         a problem since holding the queue object lock ensures that
         there are no waiting threads.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

Return Value:

    None.

--*/

{

    PRLIST_ENTRY Entry;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PRLIST_ENTRY WaitEntry;

    //
    // Decrement the current count of active threads and check if another
    // thread can be activated. If the current number of active threads is
    // less than the target maximum number of threads, there is a entry in
    // in the queue, and a thread is waiting, then remove the entry from the
    // queue, decrement the number of entries in the queue, and unwait the
    // respective thread.
    //

    Queue->CurrentCount -= 1;
    if (Queue->CurrentCount < Queue->MaximumCount) {
        Entry = Queue->EntryListHead.Flink;
        WaitEntry = Queue->Header.WaitListHead.Blink;
        if ((Entry != &Queue->EntryListHead) &&
            (WaitEntry != &Queue->Header.WaitListHead)) {

            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            Queue->Header.SignalState -= 1;
            WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
            Thread = WaitBlock->Thread;
            KiUnwaitThread(Thread, (LONG_PTR)Entry, 0);
        }
    }

    return;
}

#if !defined(_AMD64_)

VOID
KiAllProcessorsStarted (
    VOID
    );

#endif

VOID
KiApcInterrupt (
    VOID
    );

NTSTATUS
KiCallUserMode (
    IN PVOID *OutputBuffer,
    IN PULONG OutputLength
    );

typedef struct {
    ULONGLONG Adjustment;
    LARGE_INTEGER NewCount;
    volatile LONG KiNumber;
    volatile LONG HalNumber;
    volatile LONG Barrier;
} ADJUST_INTERRUPT_TIME_CONTEXT, *PADJUST_INTERRUPT_TIME_CONTEXT;

VOID
KiCalibrateTimeAdjustment (
    PADJUST_INTERRUPT_TIME_CONTEXT Adjust
    );

VOID
KiChainedDispatch (
    VOID
    );

#if DBG

VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER SystemTime
    );

#endif

typedef struct _KTIMER_TABLE_ENTRY {
    LIST_ENTRY Entry;
    ULARGE_INTEGER Time;
} KTIMER_TABLE_ENTRY, *PKTIMER_TABLE_ENTRY;

extern DECLSPEC_CACHEALIGN KTIMER_TABLE_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];

FORCEINLINE
VOID
KiRemoveEntryTimer (
    __inout PKTIMER Timer
    )

/*++

Routine Description:

    This function removes the specified timer object from the timer table
    without acquiring the timer table lock.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    None.

--*/

{

    ULONG Hand;
    PKTIMER_TABLE_ENTRY TableEntry;

    //
    // Remove the timer from the timer table. If the timer table list is
    // empty, then set the respective timer table due time to an infinite
    // absolute time.
    //
    // N.B. It is the responsibility of the caller to set the timer inserted
    //      state.
    //

    Hand = Timer->Header.Hand;
    if (RemoveEntryList(&Timer->TimerListEntry) != FALSE) {
        TableEntry = &KiTimerTableListHead[Hand];
        if (&TableEntry->Entry == TableEntry->Entry.Flink) {
            TableEntry->Time.HighPart = 0xffffffff;
        }
    }

#if DBG

    Timer->TimerListEntry.Flink = NULL;
    Timer->TimerListEntry.Blink = NULL;

#endif

    return;
}

FORCEINLINE
VOID
KiRemoveTreeTimer (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function removes the specified timer object from the timer table
    under the timer table lock.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    None.

--*/

{

    ULONG Hand;
    PKSPIN_LOCK_QUEUE LockQueue;
    PKTIMER_TABLE_ENTRY TableEntry;

    //
    // Acquire the timer table lock, set the insert state of the timer to
    // FALSE, and remove the timer from the timer table. If the time table
    // list is empty, then set the respective timer table due time to an
    // infinite absolute time. Release the timer table lock.
    //

    Hand = Timer->Header.Hand;
    LockQueue = KiAcquireTimerTableLock(Hand); 
    Timer->Header.Inserted = FALSE;
    if (RemoveEntryList(&Timer->TimerListEntry) != FALSE) {
        TableEntry = &KiTimerTableListHead[Hand];
        if (&TableEntry->Entry == TableEntry->Entry.Flink) {
            TableEntry->Time.HighPart = 0xffffffff;
        }
    }

    KiReleaseTimerTableLock(LockQueue);

#if DBG

    Timer->TimerListEntry.Flink = NULL;
    Timer->TimerListEntry.Blink = NULL;

#endif

    return;
}

LOGICAL
FASTCALL
KiInsertTimerTable (
    IN PKTIMER Timer,
    IN ULONG Hand
    );

FORCEINLINE
LOGICAL
FASTCALL
KiInsertTreeTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function inserts a timer object in the timer queue.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Interval - Supplies the absolute or relative time at which the time
        is to expire.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    LOGICAL Inserted;
    ULONG Hand;
    PKSPIN_LOCK_QUEUE LockQueue;

    //
    // Compute the the due time of the timer and attempt to insert the timer
    // in the timer table.
    //

    Inserted = FALSE;
    if (KiComputeDueTime(Timer, Interval, &Hand) == TRUE) {
        LockQueue = KiAcquireTimerTableLock(Hand);
        if (KiInsertTimerTable(Timer, Hand) == TRUE) {
            KiRemoveEntryTimer(Timer);
            Timer->Header.Inserted = FALSE;

        } else {
            Inserted = TRUE;
        }

        KiReleaseTimerTableLock(LockQueue);
    }

    return Inserted;
}

VOID
FASTCALL
KiCompleteTimer (
    __inout PKTIMER Timer,
    __inout PKSPIN_LOCK_QUEUE LockQueue
    );

BOOLEAN
FASTCALL
KiSignalTimer (
    __inout PKTIMER Timer
    );

FORCEINLINE
VOID
KiInsertOrSignalTimer (
    __inout PKTIMER Timer,
    __in ULONG Hand
    )

/*++

Routine Description:

    This function inserts the specified timer in the timer table if the
    due time has not already expired. Otherwise, the timer is signaled.

    N.B. This function must be called with the dispatcher lock held. It
         returns with the dispatcher lock released at raised IRQL.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Hand - Supplies the timer table hand value.

Return Value:

    None.

-*/

{

    PKSPIN_LOCK_QUEUE LockQueue;

    //
    // Acquire the specified timer table lock lock and release the dispatcher
    // lock.
    //
    // Attempt to insert the timer in the timer table. If the attempt fails,
    // then signal the timer.
    //
    // N.B. Complete timer releases the timer table lock.
    //

    LockQueue = KiAcquireTimerTableLock(Hand);
    KiUnlockDispatcherDatabaseFromSynchLevel();
    if (KiInsertTimerTable(Timer, Hand) == TRUE) {
        KiCompleteTimer(Timer, LockQueue);

    } else {
        KiReleaseTimerTableLock(LockQueue);
    }

    return;
}

PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    );

NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiDeliverApc (
    IN KPROCESSOR_MODE PreviousMode,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    );

VOID
KiExecuteDpc (
    IN PVOID Context
    );

KCONTINUE_STATUS
KiSetDebugProcessor (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN KPROCESSOR_MODE PreviousMode
    );

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    );

VOID
KiDispatchInterrupt (
    VOID
    );

VOID
FASTCALL
KiDeferredReadyThread (
    IN PKTHREAD Thread
    );

PKTHREAD
FASTCALL
KiFindReadyThread (
    IN ULONG Processor,
    IN PKPRCB Prcb
    );

VOID
KiFloatingDispatch (
    VOID
    );

FORCEINLINE
VOID
KiSetTbFlushTimeStampBusy (
   VOID
   )

/*++

Routine Description:

    This function sets the TB flush time stamp busy by setting the high
    order bit of the TB flush time stamp. All readers of the time stamp
    value will spin until the bit is cleared.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(_AMD64_)

    LONG Value;

#endif

    //
    // While the TB flush time stamp counter is being updated the low
    // order bit of the time stamp value is set. Otherwise, the bit is
    // clear.
    //

#if defined(_AMD64_)

    while (InterlockedBitTestAndSet((LONG *)&KiTbFlushTimeStamp, 0)) {
        do {
            KeYieldProcessor();
        } while ((KiTbFlushTimeStamp & 1) != 0);
    }

#else

    do {
        while ((Value = KiTbFlushTimeStamp) & 1) {
            KeYieldProcessor();
        }

        //
        // Attempt to set the low order bit.
        //

    } while (InterlockedCompareExchange((PLONG)&KiTbFlushTimeStamp,
                                        Value | 1,
                                        Value) != Value);

#endif

    return;
}

FORCEINLINE
VOID
KiClearTbFlushTimeStampBusy (
   VOID
   )

/*++

Routine Description:

    This function ckears the TB flush time stamp busy by clearing the high
    order bit of the TB flush time stamp and incrementing the low 32-bit
    value.

    N.B. It is assumed that the low order bit of the time stamp value
         is set on entry to this routine.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // N.B. Incrementing the time stamp clears the low order bit.
    //

    ASSERT ((KiTbFlushTimeStamp & 1) == 1);

    InterlockedIncrement((PLONG)&KiTbFlushTimeStamp);
    return;
}

PULONG
KiGetUserModeStackAddress (
    VOID
    );

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL
    );


VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
KiInitSpinLocks (
    PKPRCB Prcb,
    ULONG Number
    );

VOID
KiInitSystem (
    VOID
    );

BOOLEAN
KiInitMachineDependent (
    VOID
    );

VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

FORCEINLINE
VOID
FASTCALL
KiInsertDeferredReadyList (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function pushes an entry onto the current processor's deferred
    ready list.

Arguments:

    Thread - Supplies a pointer to a thread object.

Return Value:

    None.

--*/

{

    //
    // On the MP system, insert the specified thread in the deferred ready
    // list. On the UP system, ready the thread immediately.
    //

#if defined(NT_UP)

    Thread->State = DeferredReady;
    Thread->DeferredProcessor = 0;
    KiDeferredReadyThread(Thread);

#else

    PKPRCB Prcb;

    Prcb = KeGetCurrentPrcb();
    Thread->State = DeferredReady;
    Thread->DeferredProcessor = Prcb->Number;
    PushEntryList(&Prcb->DeferredReadyListHead,
                  &Thread->SwapListEntry);

#endif

    return;
}

LONG
FASTCALL
KiInsertQueue (
    __inout PKQUEUE Queue,
    __inout PLIST_ENTRY Entry,
    __in BOOLEAN Head
    );

VOID
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    );

VOID
KiInterruptDispatch (
    VOID
    );

VOID
KiInterruptDispatchRaise (
    IN PKINTERRUPT Interrupt
    );

VOID
KiInterruptDispatchSame (
    IN PKINTERRUPT Interrupt
    );

VOID
KiPassiveRelease (
    VOID
    );

VOID
FASTCALL
KiProcessDeferredReadyList (
    IN PKPRCB CurrentPrcb
    );

VOID
KiQuantumEnd (
    VOID
    );

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    );

VOID
FASTCALL
KiReadyThread (
    IN PKTHREAD Thread
    );

FORCEINLINE
VOID
KxQueueReadyThread (
    IN PKTHREAD Thread,
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This function inserts the previously current thread in the current
    processor's dispatcher ready queues if the thread can run on the
    curent processor. Otherwise, the specified thread is readied for
    execution.

    N.B. This function is called with the current PRCB lock held and returns
         with the PRCB lock not held.

Arguments:

    Thread - Supplies a pointer to a thread object.

    Prcb - Supplies a pointer to a the current PRCB.

Return Value:

    None.

--*/

{

    BOOLEAN Preempted;
    KPRIORITY Priority;

    ASSERT(Prcb == KeGetCurrentPrcb());
    ASSERT(Thread->State == Running);
    ASSERT(Thread->NextProcessor == Prcb->Number);

    //
    // If the thread can run on the specified processor, then insert the
    // thread in the appropriate dispatcher ready queue for the specified
    // processor and release the specified PRCB lock. Otherwise, release
    // the specified PRCB lock and ready the thread for execution.
    //

#if !defined(NT_UP)

    if ((Thread->Affinity & Prcb->SetMember) != 0) {

#endif

        Thread->State = Ready;
        Preempted = Thread->Preempted;
        Thread->Preempted = FALSE;
        Thread->WaitTime = KiQueryLowTickCount();
        Priority = Thread->Priority;

        ASSERT((Priority >= 0) && (Priority <= HIGH_PRIORITY));

        if (Preempted != FALSE) {
            InsertHeadList(&Prcb->DispatcherReadyListHead[Priority],
                           &Thread->WaitListEntry);
    
        } else {
            InsertTailList(&Prcb->DispatcherReadyListHead[Priority],
                           &Thread->WaitListEntry);
        }

        Prcb->ReadySummary |= PRIORITY_MASK(Priority);

        ASSERT(Priority == Thread->Priority);

        KiReleasePrcbLock(Prcb);

#if !defined(NT_UP)

    } else {
        Thread->State = DeferredReady;
        Thread->DeferredProcessor = Prcb->Number;
        KiReleasePrcbLock(Prcb);
        KiDeferredReadyThread(Thread);
    }

#endif

    return;
}

LOGICAL
FASTCALL
KiReinsertTreeTimer (
    IN PKTIMER Timer,
    IN ULARGE_INTEGER DueTime
    );

FORCEINLINE
VOID
KiSendSoftwareInterrupt (
    IN KAFFINITY Affinity,
    IN KIRQL Level
    )

/*++

Routine Description:

    This function will generate an APC or DPC interrupt on the target
    set of processors.

Arguments:

    Affinity - Supplies the set of processors upon which to generate the
               interrupt.

    Level - APC_LEVEL or DISPATCH_LEVEL.

Return Value:

    None.

--*/

{

#if defined(_AMD64_)

    HalSendSoftwareInterrupt(Affinity, Level);

#else

    if (Level == APC_LEVEL) {
        KiIpiSend(Affinity, IPI_APC);

    } else {
        KiIpiSend(Affinity, IPI_DPC);
    }

#endif

}

#if defined(_AMD64_)

NTSTATUS
KiSwitchKernelStackAndCallout (
    IN PVOID Parameter,
    IN PEXPAND_STACK_CALLOUT Callout,
    IN PVOID LargeStack,
    IN SIZE_T CommitSize
    );

#endif

//
// Define freeze states.
//

#define RUNNING 0x00
#define TARGET_FROZEN 0x02
#define TARGET_THAW 0x03
#define FREEZE_OWNER 0x04

#define FrozenState(a) ((a) & 0xF)

FORCEINLINE
VOID
KiSendFreeze (
    IN OUT KAFFINITY *Affinity,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function will generate a FREEZE ipi on the target set of processors.

Arguments:

    Affinity - Supplies the set of processors upon which to generate the
               interrupt.

    Wait - If TRUE, will wait until all of the target processors are
           RUNNING before sending the IPI.

           If FALSE, will send the IPI only to those processors that are
           RUNNING.

Return Value:

    None.

--*/

{

#if defined(_AMD64_)

    ULONG BitNumber;
    PKPRCB Prcb;
    KAFFINITY TargetSet;

    TargetSet = *Affinity;
    do {
        KeFindFirstSetLeftAffinity(TargetSet, &BitNumber);
        ClearMember(BitNumber, TargetSet);
        Prcb = KiProcessorBlock[BitNumber];

        if (Wait) {

            //
            // Spin until this processor sets the target debug state
            // to TARGET_FREEZE.
            // 

            while (InterlockedCompareExchange((LONG *)&Prcb->IpiFrozen,
                                              TARGET_FREEZE,
                                              RUNNING) != RUNNING) {
                do {
                    KeYieldProcessor();
                } while (Prcb->IpiFrozen != RUNNING);
            }

        } else {

            //
            // Attempt to set the target debug state to TARGET_FREEZE.
            //
            // If unsuccessful, clear the target from the target affinity
            // mask.
            //

            if (InterlockedCompareExchange((LONG *)&Prcb->IpiFrozen,
                                           TARGET_FREEZE,
                                           RUNNING) != RUNNING) {
                ClearMember(BitNumber, *Affinity);
            }
        }

    } while (TargetSet != 0);

    HalSendNMI( *Affinity );

#else

    UNREFERENCED_PARAMETER(Wait);

    KiIpiSend(*Affinity, IPI_FREEZE);

#endif

}

#if defined(_AMD64_) && !defined(NT_UP)

extern BOOLEAN KiResumeForReboot;

#endif

FORCEINLINE
VOID
KiSendThawExecution (
    IN BOOLEAN Wait
    )
{

#if !defined(NT_UP)

    KAFFINITY TargetSet;
    ULONG BitNumber;
    PKPRCB Prcb;

    KeGetCurrentPrcb()->IpiFrozen = RUNNING;

    TargetSet = KeActiveProcessors & ~(AFFINITY_MASK(KeGetCurrentProcessorNumber()));
    while (TargetSet != 0) {
        KeFindFirstSetLeftAffinity(TargetSet, &BitNumber);
        ClearMember(BitNumber, TargetSet);
        Prcb = KiProcessorBlock[BitNumber];

#if IDBG

	//
        // If the target processor was not frozen, then don't wait
        // for target to unfreeze.
        //

        if (FrozenState(Prcb->IpiFrozen) != TARGET_FROZEN) {
            Prcb->IpiFrozen = RUNNING;
            continue;
        }

#endif

        //
        // Do not try to thaw a processor which is not in frozen state 
        // at reboot. This is to handle the case when the freeze owner 
        // spins at waiting to be reselected as active processor and
        // .reboot is issued on another processor. At this point the
        // freeze owner should not and can not be thawed.
        //

#if defined(_AMD64_)

        if ((KiResumeForReboot == TRUE) &&
            (FrozenState(Prcb->IpiFrozen) != TARGET_FROZEN)) {

            continue;
        }

#endif

        Prcb->IpiFrozen = TARGET_THAW;
        if (Wait) {
            while (Prcb->IpiFrozen == TARGET_THAW) {
            KeYieldProcessor();
            }
        }
    }

#else

    UNREFERENCED_PARAMETER(Wait);
    
#endif  // !defined (NT_UP)

}

#if defined(NT_UP)

#define KiRequestApcInterrupt(Processor) KiRequestSoftwareInterrupt(APC_LEVEL)

#else

#define KiRequestApcInterrupt(Processor)                  \
    if (KeGetCurrentProcessorNumber() == Processor) {     \
        KiRequestSoftwareInterrupt(APC_LEVEL);            \
    } else {                                              \
        KiSendSoftwareInterrupt(AFFINITY_MASK(Processor), APC_LEVEL);     \
    }

#endif

#if defined(NT_UP)

#define KiRequestDispatchInterrupt(Processor)

#else

#define KiRequestDispatchInterrupt(Processor)             \
    if (KeGetCurrentProcessorNumber() != Processor) {     \
        KiSendSoftwareInterrupt(AFFINITY_MASK(Processor), DISPATCH_LEVEL);     \
    }

#endif

PKTHREAD
FASTCALL
KiSelectNextThread (
    IN PKPRCB Prcb
    );

KAFFINITY
FASTCALL
KiSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    );

FORCEINLINE
VOID
KiSetContextSwapBusy (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This routine sets context swap busy for the specified thread.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    ASSERT(Thread->SwapBusy == FALSE);

    Thread->SwapBusy = TRUE;

#else

    UNREFERENCED_PARAMETER(Thread);

#endif

    return;
}

FORCEINLINE
VOID
KiSetContextSwapIdle (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This routine sets context swap idle for the specified thread.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    ASSERT(Thread->SwapBusy == TRUE);

    Thread->SwapBusy = FALSE;

#else

    UNREFERENCED_PARAMETER(Thread);

#endif

    return;
}

VOID
KiSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    );

VOID
KiSuspendNop (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
KiSuspendRundown (
    IN PKAPC Apc
    );

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
KiSwapProcess (
    IN PKPROCESS NewProcess,
    IN PKPROCESS OldProcess
    );

LONG_PTR
FASTCALL
KiSwapThread (
    IN PKTHREAD OldThread,
    IN PKPRCB CurrentPrcb
    );

VOID
KiThreadStartup (
    IN PVOID StartContext
    );

VOID
KiTimerExpiration (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    );

VOID
KiUnexpectedInterrupt (
    VOID
    );

FORCEINLINE
VOID
FASTCALL
KiUnlinkThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus
    )

/*++

Routine Description:

    This function unlinks a thread from the appropriate wait queues and sets
    the thread's wait completion status.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    WaitStatus - Supplies the wait completion status.

Return Value:

    None.

--*/

{

    PKQUEUE Queue;
    PKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;

    //
    // Set wait completion status, remove wait blocks from object wait
    // lists, and remove thread from wait list.
    //

    Thread->WaitStatus |= WaitStatus;
    WaitBlock = Thread->WaitBlockList;
    do {
        RemoveEntryList(&WaitBlock->WaitListEntry);
        WaitBlock = WaitBlock->NextWaitBlock;
    } while (WaitBlock != Thread->WaitBlockList);

    if (Thread->WaitListEntry.Flink != NULL) {
        RemoveEntryList(&Thread->WaitListEntry);
    }

    //
    // If thread timer is still active, then cancel thread timer.
    //

    Timer = &Thread->Timer;
    if (Timer->Header.Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // If the thread is processing a queue entry, then increment the
    // count of currently active threads.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        Queue->CurrentCount += 1;
    }

    return;
}

VOID
KiUserApcDispatcher (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN PKNORMAL_ROUTINE NormalRoutine
    );

VOID
KiUserExceptionDispatcher (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextFrame
    );

VOID
KiVerifyReadySummary (
    PKPRCB Prcb
    );

BOOLEAN
FASTCALL
KiSwapContext (
    IN PKTHREAD OldThread,
    IN PKTHREAD NewThread
    );

//
// VOID
// FASTCALL
// KiWaitSatisfyAny (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object and performs
//    any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyAny(_Object_, _Thread_) {                               \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    } else if ((_Object_)->Header.Type == MutantObject) {                    \
        (_Object_)->Header.SignalState -= 1;                                 \
        if ((_Object_)->Header.SignalState == 0) {                           \
            (_Thread_)->KernelApcDisable = (_Thread_)->KernelApcDisable - (_Object_)->ApcDisable; \
            (_Object_)->OwnerThread = (_Thread_);                            \
            if ((_Object_)->Abandoned == TRUE) {                             \
                (_Object_)->Abandoned = FALSE;                               \
                (_Thread_)->WaitStatus = STATUS_ABANDONED;                   \
            }                                                                \
                                                                             \
            InsertHeadList((_Thread_)->MutantListHead.Blink,                 \
                           &(_Object_)->MutantListEntry);                    \
        }                                                                    \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyMutant (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for a mutant object.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyMutant(_Object_, _Thread_) {                            \
    (_Object_)->Header.SignalState -= 1;                                     \
    if ((_Object_)->Header.SignalState == 0) {                               \
        (_Thread_)->KernelApcDisable = (_Thread_)->KernelApcDisable - (_Object_)->ApcDisable; \
        (_Object_)->OwnerThread = (_Thread_);                                \
        if ((_Object_)->Abandoned == TRUE) {                                 \
            (_Object_)->Abandoned = FALSE;                                   \
            (_Thread_)->WaitStatus = STATUS_ABANDONED;                       \
        }                                                                    \
                                                                             \
        InsertHeadList((_Thread_)->MutantListHead.Blink,                     \
                       &(_Object_)->MutantListEntry);                        \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyOther (
//    IN PKMUTANT Object
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object except a mutant
//    and performs any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyOther(_Object_) {                                       \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    }                                                                        \
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    );

FORCEINLINE
VOID
KiWaitTestSynchronizationObject (
    IN PVOID Object,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function tests if a wait can be satisfied when a synchronization
    dispatcher object attains a state of signaled. Synchronization objects
    include synchronization events and synchronization timers.

Arguments:

    Object - Supplies a pointer to an event object.

    Increment - Supplies the priority increment.

Return Value:

    None.

--*/

{

    PKEVENT Event = Object;
    PLIST_ENTRY ListHead;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    //
    // As long as the signal state of the specified event is signaled and
    // there are waiters in the event wait list, then try to satisfy a wait.
    //

    ListHead = &Event->Header.WaitListHead;

    ASSERT(IsListEmpty(&Event->Header.WaitListHead) == FALSE);

    WaitEntry = ListHead->Flink;
    do {

        //
        // Get the address of the wait block and the thread doing the wait.
        //

        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;

        //
        // If the wait type is wait any, then satisfy the wait, unwait the
        // thread with the wait key status, and exit loop. Otherwise, unwait
        // the thread with a kernel APC status and continue the loop.
        //

        if (WaitBlock->WaitType == WaitAny) {
            Event->Header.SignalState = 0;
            KiUnwaitThread(Thread, (NTSTATUS)WaitBlock->WaitKey, Increment);
            break;
        }

        KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment);
        WaitEntry = ListHead->Flink;
    } while (WaitEntry != ListHead);

    return;
}

FORCEINLINE
VOID
KiWaitTestWithoutSideEffects (
    IN PVOID Object,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function tests if a wait can be satisfied when a dispatcher object
    without side effects attains a state of signaled. Dispatcher objects
    that have no side effects when a wait is satisfied include notification
    events, notification timers, processes, and threads.

Arguments:

    Object - Supplies a pointer to a dispatcher object that has no side
        effects when a wait is satisfied.

    Increment - Supplies the priority increment.

Return Value:

    None.

--*/

{

    PKEVENT Event = Object;
    PLIST_ENTRY ListHead;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    //
    // Empty the entire list of waiters since the specified object has
    // no side effects when a wait is satisfied.
    //

    ListHead = &Event->Header.WaitListHead;

    ASSERT(IsListEmpty(&Event->Header.WaitListHead) == FALSE);

    WaitEntry = ListHead->Flink;
    do {

        //
        // Get the address of the wait block and the thread doing the wait.
        //

        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;

        //
        // If the wait type is wait any, then unwait the thread with the
        // wait key status. Otherwise, unwait the thread with a kernel APC
        // status.
        //

        if (WaitBlock->WaitType == WaitAny) {
            KiUnwaitThread(Thread, (NTSTATUS)WaitBlock->WaitKey, Increment);

        } else {
            KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment);
        }

        WaitEntry = ListHead->Flink;
    } while (WaitEntry != ListHead);

    return;
}

VOID
KiFreezeTargetExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KiPollFreezeExecution (
    VOID
    );

VOID
KiSaveProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KiSaveProcessorControlState (
    IN PKPROCESSOR_STATE ProcessorState
    );

VOID
KiRestoreProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KiRestoreProcessorControlState (
    IN PKPROCESSOR_STATE ProcessorState
    );

#define KiEnableAlignmentExceptions()
#define KiDisableAlignmentExceptions()

BOOLEAN
KiHandleAlignmentFault(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance,
    OUT BOOLEAN *ExceptionForwarded
    );

//
// External references to private kernel data structures
//

extern PMESSAGE_RESOURCE_DATA  KiBugCodeMessages;
extern FAST_MUTEX KiGenericCallDpcMutex;
extern ULONG KiDmaIoCoherency;
extern ULONG KiIdealDpcRate;
extern LONG KiMaximumDpcQueueDepth;
extern ULONG KiMinimumDpcRate;
extern ULONG KiAdjustDpcThreshold;
extern PKDEBUG_ROUTINE KiDebugRoutine;
extern PKDEBUG_SWITCH_ROUTINE KiDebugSwitchRoutine;
extern CALL_PERFORMANCE_DATA KiFlushSingleCallData;
extern volatile LONG KiHardwareTrigger;
extern DECLSPEC_CACHEALIGN EPROCESS KiInitialProcess;
extern DECLSPEC_CACHEALIGN ETHREAD KiInitialThread;
extern KEVENT KiSwapEvent;
extern PKTHREAD KiSwappingThread;
extern KNODE KiNode0;
extern KNODE KiNodeInit[];
extern LIST_ENTRY KiProcessListHead;
extern ALIGNED_SPINLOCK KiProcessListLock;
extern SINGLE_LIST_ENTRY KiProcessInSwapListHead;
extern SINGLE_LIST_ENTRY KiProcessOutSwapListHead;
extern SINGLE_LIST_ENTRY KiStackInSwapListHead;
extern LIST_ENTRY KiProfileSourceListHead;
extern BOOLEAN KiProfileAlignmentFixup;
extern ULONG KiProfileAlignmentFixupInterval;
extern ULONG KiProfileAlignmentFixupCount;
extern ALIGNED_SPINLOCK KiReverseStallIpiLock;
extern ULONG KiProfileInterval;
extern LIST_ENTRY KiProfileListHead;
extern ALIGNED_SPINLOCK KiProfileLock;

#if defined(_AMD64_)

#define KiArgumentTable NULL

#else

extern UCHAR KiArgumentTable[];

#endif

extern ULONG KiServiceLimit;
extern ULONG_PTR KiServiceTable[];
extern CALL_PERFORMANCE_DATA KiSetEventCallData;
extern ULONG KiTickOffset;
extern KAFFINITY KiTimeProcessor;
extern KDPC KiTimerExpireDpc;
extern ALIGNED_SPINLOCK KiFreezeExecutionLock;
extern CALL_PERFORMANCE_DATA KiWaitSingleCallData;
extern ULONG KiEnableTimerWatchdog;
extern ALIGNED_SPINLOCK KiFreezeLockBackup;
extern ULONG KiFreezeFlag;
extern volatile ULONG KiSuspendState;

#define KiIncrementSwitchCounter(Member)

FORCEINLINE
PKTHREAD
KiSelectReadyThread (
    IN KPRIORITY LowPriority,
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This function searches the dispatcher ready queues from the specified
    low priority to the highest priority in an attempt to find a thread
    that can execute on the specified processor.

Arguments:

    LowPriority - Supplies the lowest priority dispatcher ready queue to
        examine.

    Prcb - Supplies a pointer to a processor control block.

Return Value:

    If a thread is located that can execute on the specified processor, then
    the address of the thread object is returned. Otherwise a null pointer
    is returned.

--*/

{

    ULONG HighPriority;
    PRLIST_ENTRY ListEntry;
    ULONG PrioritySet;
    PKTHREAD Thread;

    //
    // Compute the set of priority levels that should be scanned in an attempt
    // to find a thread that can run on the current processor.
    //

    PrioritySet = Prcb->ReadySummary >> LowPriority;
    Thread = NULL;
    if (PrioritySet != 0) {
        KeFindFirstSetLeftMember(PrioritySet, &HighPriority);

        ASSERT((PrioritySet & PRIORITY_MASK(HighPriority)) != 0);

        HighPriority += LowPriority;

        ASSERT(IsListEmpty(&Prcb->DispatcherReadyListHead[HighPriority]) == FALSE);

        ListEntry = Prcb->DispatcherReadyListHead[HighPriority].Flink;
        Thread = CONTAINING_RECORD(ListEntry, KTHREAD, WaitListEntry);

        ASSERT((KPRIORITY)HighPriority == Thread->Priority);

        ASSERT((Thread->Affinity & AFFINITY_MASK(Prcb->Number)) != 0);

        ASSERT(Thread->NextProcessor == Prcb->Number);

        if (RemoveEntryList(&Thread->WaitListEntry) != FALSE) {
            Prcb->ReadySummary ^= PRIORITY_MASK(HighPriority);
        }
    }

    //
    // Return thread address if one could be found.
    //

    ASSERT((Thread == NULL) || (Thread->BasePriority == 0) || (Thread->Priority != 0));

    return Thread;
}

VOID
KiSetInternalEvent (
    IN PKEVENT Event,
    IN PKTHREAD Thread
    );

//
// Include platform specific internal kernel header file.
//

#if defined(_AMD64_)

#include "amd64\kiamd64.h"

#elif defined(_X86_)

#include "i386\kix86.h"

#endif // defined(_AMD64_)

#endif // defined(_KI_)
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\procobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    procobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel process object. Functions are provided to initialize, attach,
    detach, exclude, include, and set the base priority of process objects.

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeInitializeProcess)

//
// Define forward referenced function prototypes.
//

VOID
KiAttachProcess (
    __inout PRKTHREAD Thread,
    __in PRKPROCESS Process,
    __in PKLOCK_QUEUE_HANDLE LockHandle,
    __out PRKAPC_STATE SavedApcState
    );

VOID
KiMoveApcState (
    __in PKAPC_STATE Source,
    __out PKAPC_STATE Destination
    );

#if !defined(NT_UP)

FORCEINLINE
VOID
KiSetIdealNodeProcess (
    __inout PKPROCESS Process,
    __in KAFFINITY Affinity
    )

/*++

Routine Description:

    This function sets the ideal node for a process based on the specified
    affinity and the node generation seed.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    Affinity - Supplies the set of processors on which children threads
        of the process can execute.

Return Value:

    None.

--*/

{

    ULONG Index;
    PKNODE Node;
    ULONG NodeNumber;

    //
    // Select the ideal node for the process.
    //

    if (KeNumberNodes > 1) {
        NodeNumber = (KeProcessNodeSeed + 1) % KeNumberNodes;
        KeProcessNodeSeed = (UCHAR)NodeNumber;
        Index = 0;
        do {      
            if ((KeNodeBlock[NodeNumber]->ProcessorMask & Affinity) != 0) {
                break;
            }

            Index += 1;
            NodeNumber += 1;
            if (NodeNumber >= KeNumberNodes) {
                NodeNumber -= KeNumberNodes;
            }

        } while (Index < KeNumberNodes);

    } else {
        NodeNumber = 0;
    }

    Process->IdealNode = (UCHAR)NodeNumber;
    Node = KeNodeBlock[NodeNumber];

    ASSERT((Node->ProcessorMask & Affinity) != 0);

    Process->ThreadSeed = (UCHAR)KeFindNextRightSetAffinity(Node->Seed,
                                                            Node->ProcessorMask & Affinity);

    Node->Seed = Process->ThreadSeed;
    return;
}

#endif

VOID
KeInitializeProcess (
    __out PRKPROCESS Process,
    __in KPRIORITY BasePriority,
    __in KAFFINITY Affinity,
    __in ULONG_PTR DirectoryTableBase[2],
    __in BOOLEAN Enable
    )

/*++

Routine Description:

    This function initializes a kernel process object. The base priority,
    affinity, and page frame numbers for the process page table directory
    and hyper space are stored in the process object.

    N.B. It is assumed that the process object is zeroed.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    BasePriority - Supplies the base priority of the process.

    Affinity - Supplies the set of processors on which children threads
        of the process can execute.

    DirectoryTableBase - Supplies a pointer to an array whose fist element
        is the value that is to be loaded into the Directory Table Base
        register when a child thread is dispatched for execution and whose
        second element contains the page table entry that maps hyper space.

    Enable - Supplies a boolean value that determines the default
        handling of data alignment exceptions for child threads. A value
        of TRUE causes all data alignment exceptions to be automatically
        handled by the kernel. A value of FALSE causes all data alignment
        exceptions to be actually raised as exceptions.

Return Value:

    None.

--*/

{

    //
    // Initialize the standard dispatcher object header and set the initial
    // signal state of the process object.
    //

    Process->Header.Type = ProcessObject;
    Process->Header.Size = sizeof(KPROCESS) / sizeof(LONG);
    InitializeListHead(&Process->Header.WaitListHead);

    //
    // Initialize the base priority, affinity, directory table base values,
    // autoalignment, and stack count.
    //

    Process->BasePriority = (SCHAR)BasePriority;
    Process->Affinity = Affinity;
    Process->AutoAlignment = Enable;
    Process->DirectoryTableBase[0] = DirectoryTableBase[0];
    Process->DirectoryTableBase[1] = DirectoryTableBase[1];

    //
    // Initialize the stack count, profile listhead, ready queue list head,
    // accumulated runtime, process quantum, thread quantum, and thread list
    // head.
    //

    InitializeListHead(&Process->ProfileListHead);
    InitializeListHead(&Process->ReadyListHead);
    InitializeListHead(&Process->ThreadListHead);
    Process->QuantumReset = THREAD_QUANTUM;

    //
    // Initialize the process state and set the thread processor selection
    // seed.
    //

    Process->State = ProcessInMemory;

    //
    // Select the ideal node for the process.
    //

#if !defined(NT_UP)

    KiSetIdealNodeProcess(Process, Affinity);

#endif

    //
    // Initialize IopmBase and Iopl flag for this process (i386 only)
    //

#if defined(_X86_)

    Process->IopmOffset = KiComputeIopmOffset(IO_ACCESS_MAP_NONE);

#endif // defined(_X86_)

    return;
}

VOID
KeAttachProcess (
    __inout PRKPROCESS Process
    )

/*++

Routine Description:

    This function attaches a thread to a target process' address space
    if, and only if, there is not already a process attached.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the target process is not the current process, then attach the
    // target process.
    //

    Thread = KeGetCurrentThread();
    if (Thread->ApcState.Process != Process) {

        //
        // If the current thread is already attached or executing a DPC, then
        // bugcheck.
        //
    
        if ((Thread->ApcStateIndex != 0) ||
            (KeIsExecutingDpc() != FALSE)) {
    
            KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                         (ULONG_PTR)Process,
                         (ULONG_PTR)Thread->ApcState.Process,
                         (ULONG)Thread->ApcStateIndex,
                         (ULONG)KeIsExecutingDpc());
        }
    
        //
        // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock,
        // acquire the dispatcher database lock, and attach to the specified
        // process.
        //
        // N.B. All lock are released by the internal attach routine.
        //

        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                   &LockHandle);

        KiLockDispatcherDatabaseAtSynchLevel();
        KiAttachProcess(Thread, Process, &LockHandle, &Thread->SavedApcState);
    }

    return;
}

LOGICAL
KeForceAttachProcess (
    __inout PRKPROCESS Process
    )

/*++

Routine Description:

    This function forces an attach of a thread to a target process' address
    space if the process is not current being swapped into or out of memory.

    N.B. This function is for use by memory management ONLY.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the current thread is already attached or executing a DPC, then
    // bugcheck.
    //

    Thread = KeGetCurrentThread();
    if ((Thread->ApcStateIndex != 0) ||
        (KeIsExecutingDpc() != FALSE)) {

        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                     (ULONG_PTR)Process,
                     (ULONG_PTR)Thread->ApcState.Process,
                     (ULONG)Thread->ApcStateIndex,
                     (ULONG)KeIsExecutingDpc());
    }

    //
    // If the target process is not the current process, then attach the
    // target process if the process is not currently being swapped in or
    // out of memory.
    //

    if (Thread->ApcState.Process != Process) {

        //
        // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and
        // acquire the dispatcher database lock.
        //

        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                   &LockHandle);

        KiLockDispatcherDatabaseAtSynchLevel();

        //
        // If the target process is currently being swapped into or out of
        // memory, then return a value of FALSE. Otherwise, force the process
        // to be inswapped.
        //

        if ((Process->State == ProcessInSwap) ||
            (Process->State == ProcessInTransition) ||
            (Process->State == ProcessOutTransition) ||
            (Process->State == ProcessOutSwap)) {
            KiUnlockDispatcherDatabaseFromSynchLevel();
            KeReleaseInStackQueuedSpinLock(&LockHandle);
            return FALSE;

        } else {

            //
            // Force the process state to in memory and attach the target process.
            //
            // N.B. All lock are released by the internal attach routine.
            //

            Process->State = ProcessInMemory;
            KiAttachProcess(Thread, Process, &LockHandle, &Thread->SavedApcState);
        }
    }

    return TRUE;
}

VOID
KeStackAttachProcess (
    __inout PRKPROCESS Process,
    __out PRKAPC_STATE ApcState
    )

/*++

Routine Description:

    This function attaches a thread to a target process' address space
    and returns information about a previous attached process.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the current thread is executing a DPC, then bugcheck.
    //

    Thread = KeGetCurrentThread();
    if (KeIsExecutingDpc() != FALSE) {
        KeBugCheckEx(INVALID_PROCESS_ATTACH_ATTEMPT,
                     (ULONG_PTR)Process,
                     (ULONG_PTR)Thread->ApcState.Process,
                     (ULONG)Thread->ApcStateIndex,
                     (ULONG)KeIsExecutingDpc());
    }

    //
    // If the target process is not the current process, then attach the
    // target process. Otherwise, return a distinguished process value to
    // indicate that an attach was not performed.
    //

    if (Thread->ApcState.Process == Process) {
        ApcState->Process = (PRKPROCESS)1;

    } else {

        //
        // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and
        // acquire the dispatcher database lock.
        //

        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                   &LockHandle);

        KiLockDispatcherDatabaseAtSynchLevel();

        //
        // If the current thread is attached to a process, then save the
        // current APC state in the callers APC state structure. Otherwise,
        // save the current APC state in the saved APC state structure, and
        // return a NULL process pointer.
        //
        // N.B. All lock are released by the internal attach routine.
        //

        if (Thread->ApcStateIndex != 0) {
            KiAttachProcess(Thread, Process, &LockHandle, ApcState);

        } else {
            KiAttachProcess(Thread, Process, &LockHandle, &Thread->SavedApcState);
            ApcState->Process = NULL;
        }
    }

    return;
}

VOID
KeDetachProcess (
    VOID
    )

/*++

Routine Description:

    This function detaches a thread from another process' address space.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PKPROCESS Process;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the current thread is attached to another process, then detach
    // it.
    //

    Thread = KeGetCurrentThread();
    if (Thread->ApcStateIndex != 0) {

        //
        // Raise IRQL to SYNCH_LEVEL and acquire the thread APC queue lock.
        //

        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                   &LockHandle);

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending, the special APC disable count is zero,
        // and the previous IRQL was less than APC_LEVEL, then a kernel APC
        // was queued by another processor just after IRQL was raised to
        // DISPATCH_LEVEL, but before the dispatcher database was locked.
        //
        // N.B. This can only happen in a multiprocessor system.
        //

#if !defined(NT_UP)

        while (Thread->ApcState.KernelApcPending &&
               (Thread->SpecialApcDisable == 0) &&
               (LockHandle.OldIrql < APC_LEVEL)) {

            //
            // Unlock the thread APC lock and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will
            // result in the delivery of the kernel APC if possible.
            //

            KeReleaseInStackQueuedSpinLock(&LockHandle);
            KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                       &LockHandle);
        }

#endif

        //
        // If a kernel APC is in progress, the kernel APC queue is not empty,
        // or the user APC queues is not empty, then bugcheck.
        //

#if DBG

        if ((Thread->ApcState.KernelApcInProgress) ||
            (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) ||
            (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE)) {

            KeBugCheck(INVALID_PROCESS_DETACH_ATTEMPT);
        }

#endif

        //
        // Lock the dispatcher database, unbias current process stack count,
        // and check if the process should be swapped out of memory.
        //

        Process = Thread->ApcState.Process;
        KiLockDispatcherDatabaseAtSynchLevel();

        ASSERT(Process->StackCount != 0);

        ASSERT(Process->State == ProcessInMemory);

        Process->StackCount -= 1;
        if ((Process->StackCount == 0) &&
            (IsListEmpty(&Process->ThreadListHead) == FALSE)) {

            Process->State = ProcessOutTransition;
            InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                           &Process->SwapListEntry);

            KiSetInternalEvent(&KiSwapEvent, KiSwappingThread);
        }

        //
        // Unlock dispatcher database, but remain at SYNCH_LEVEL.
        //
    
        KiUnlockDispatcherDatabaseFromSynchLevel();

        //
        // Restore APC state and check whether the kernel APC queue contains
        // an entry. If the kernel APC queue contains an entry then set kernel
        // APC pending and request a software interrupt at APC_LEVEL.
        //

        KiMoveApcState(&Thread->SavedApcState, &Thread->ApcState);
        Thread->SavedApcState.Process = (PKPROCESS)NULL;
        Thread->ApcStatePointer[0] = &Thread->ApcState;
        Thread->ApcStatePointer[1] = &Thread->SavedApcState;
        Thread->ApcStateIndex = 0;

        //
        // Release the thread APC queue lock, swap the address space back to
        // the parent process, and exit the scheduler.
        //
    
        KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
        KiSwapProcess(Thread->ApcState.Process, Process);
        KiExitDispatcher(LockHandle.OldIrql);

        //
        // Initiate an APC interrupt if there are pending kernel APC's.
        //

        if (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {
            Thread->ApcState.KernelApcPending = TRUE;
            KiRequestSoftwareInterrupt(APC_LEVEL);
        }
    }

    return;
}

VOID
KeUnstackDetachProcess (
    __in PRKAPC_STATE ApcState
    )

/*++

Routine Description:

    This function detaches a thread from another process' address space
    and restores previous attach state.

Arguments:

    ApcState - Supplies a pointer to an APC state structure that was returned
        from a previous call to stack attach process.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PKPROCESS Process;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the APC state has a distinguished process pointer value, then no
    // attach was performed on the paired call to stack attach process.
    //

    if (ApcState->Process != (PRKPROCESS)1) {

        //
        // Raise IRQL to SYNCH_LEVEL and acquire the thread APC queue lock.
        //

        Thread = KeGetCurrentThread();
        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                   &LockHandle);

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending, the special APC disable count is zero,
        // and the previous IRQL was less than APC_LEVEL, then a kernel APC
        // was queued by another processor just after IRQL was raised to
        // DISPATCH_LEVEL, but before the dispatcher database was locked.
        //
        // N.B. This can only happen in a multiprocessor system.
        //

#if !defined(NT_UP)

        while (Thread->ApcState.KernelApcPending &&
               (Thread->SpecialApcDisable == 0) &&
               (LockHandle.OldIrql < APC_LEVEL)) {

            //
            // Unlock the thread APC lock and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will
            // result in the delivery of the kernel APC if possible.
            //

            KeReleaseInStackQueuedSpinLock(&LockHandle);
            KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                       &LockHandle);
        }

#endif

        //
        // If the APC state is the original APC state, a kernel APC is in
        // progress, the kernel APC is nbot empty, or the user APC queues is
        // not empty, then bugcheck.
        //

        if ((Thread->ApcStateIndex == 0) ||
             (Thread->ApcState.KernelApcInProgress) ||
             (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) ||
             (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE)) {

            KeBugCheck(INVALID_PROCESS_DETACH_ATTEMPT);
        }

        //
        // Lock the dispatcher database, unbias current process stack count,
        // and check if the process should be swapped out of memory.
        //

        Process = Thread->ApcState.Process;
        KiLockDispatcherDatabaseAtSynchLevel();

        ASSERT(Process->StackCount != 0);

        ASSERT(Process->State == ProcessInMemory);

        Process->StackCount -= 1;
        if ((Process->StackCount == 0) &&
            (IsListEmpty(&Process->ThreadListHead) == FALSE)) {

            Process->State = ProcessOutTransition;
            InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                           &Process->SwapListEntry);

            KiSetInternalEvent(&KiSwapEvent, KiSwappingThread);
        }

        //
        // Unlock dispatcher database, but remain at SYNCH_LEVEL.
        //
    
        KiUnlockDispatcherDatabaseFromSynchLevel();

        //
        // Restore APC state and check whether the kernel APC queue contains
        // an entry. If the kernel APC queue contains an entry then set kernel
        // APC pending and request a software interrupt at APC_LEVEL.
        //

        if (ApcState->Process != NULL) {
            KiMoveApcState(ApcState, &Thread->ApcState);

        } else {
            KiMoveApcState(&Thread->SavedApcState, &Thread->ApcState);
            Thread->SavedApcState.Process = (PKPROCESS)NULL;
            Thread->ApcStatePointer[0] = &Thread->ApcState;
            Thread->ApcStatePointer[1] = &Thread->SavedApcState;
            Thread->ApcStateIndex = 0;
        }

        //
        // Release the thread APC queue lock, swap the address space back to
        // the parent process, and exit the scheduler.
        //
    
        KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
        KiSwapProcess(Thread->ApcState.Process, Process);
        KiExitDispatcher(LockHandle.OldIrql);

        //
        // Initiate an APC interrupt if we need to
        //

        if (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {
            Thread->ApcState.KernelApcPending = TRUE;
            KiRequestSoftwareInterrupt(APC_LEVEL);
        }
    }

    return;
}

ULONG
KeQueryRuntimeProcess (
    __in PKPROCESS Process,
    __out PULONG UserTime
    )

/*++

Routine Description:

    This function queries the user and kernel runtime for the specifed process.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    UserTime - Supplies a pointer to a variable that receives the total
        user time.

Return Value:

    The total kernel time is returned as the function value.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG KernelTime;
    PLIST_ENTRY NextEntry;
    PKTHREAD Thread;
    ULONG TotalTime;

    ASSERT_PROCESS(Process);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH level and acquire the process lock.
    //
    // Sum the process current kernel and user time with the kernel and user
    // time of all the process threads.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KernelTime = Process->KernelTime;
    TotalTime = Process->UserTime;
    NextEntry = Process->ThreadListHead.Flink;
    while (NextEntry != &Process->ThreadListHead) {
        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);
        KernelTime += Thread->KernelTime;
        TotalTime += Thread->UserTime;
        NextEntry = NextEntry->Flink;
    }

    //
    // Unlock the process lock and return the total user and kernel time.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    *UserTime = TotalTime;
    return KernelTime;
}

VOID
KeQueryValuesProcess (
    __in PKPROCESS Process,
    __out PKPROCESS_VALUES Values
    )

/*++

Routine Description:

    This function queries the user runtime, the kernel runtime, and the I/O
    statistics for the specifed process.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    Values - Supplies a pointer to a structure that will receive the runtime
        and I/O statistics values.

Return Value:

    None.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG KernelTime;
    PLIST_ENTRY NextEntry;
    PKTHREAD Thread;
    ULONG UserTime;

    ASSERT_PROCESS(Process);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH level and acquire the process lock.
    //
    // Sum the process current kernel time, user time, and I/O statistics
    // with the kernel time, user time, and I/O statistics for all of the
    // process threads.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KernelTime = Process->KernelTime;
    UserTime = Process->UserTime;
    Values->ReadOperationCount = ((PEPROCESS)Process)->ReadOperationCount.QuadPart;
    Values->WriteOperationCount = ((PEPROCESS)Process)->WriteOperationCount.QuadPart;
    Values->OtherOperationCount = ((PEPROCESS)Process)->OtherOperationCount.QuadPart;
    Values->ReadTransferCount = ((PEPROCESS)Process)->ReadTransferCount.QuadPart;
    Values->WriteTransferCount = ((PEPROCESS)Process)->WriteTransferCount.QuadPart;
    Values->OtherTransferCount = ((PEPROCESS)Process)->OtherTransferCount.QuadPart;
    NextEntry = Process->ThreadListHead.Flink;
    while (NextEntry != &Process->ThreadListHead) {
        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);
        KernelTime += Thread->KernelTime;
        UserTime += Thread->UserTime;

#if defined(_WIN64)

        Values->ReadOperationCount += Thread->ReadOperationCount;
        Values->WriteOperationCount += Thread->WriteOperationCount;
        Values->OtherOperationCount += Thread->OtherOperationCount;
        Values->ReadTransferCount += Thread->ReadTransferCount;
        Values->WriteTransferCount += Thread->WriteTransferCount;
        Values->OtherTransferCount += Thread->OtherTransferCount;

#endif

        NextEntry = NextEntry->Flink;
    }

    //
    // Unlock the process lock and return the total user and kernel time.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    Values->KernelTime = UInt32x32To64(KernelTime, KeMaximumIncrement);
    Values->UserTime = UInt32x32To64(UserTime, KeMaximumIncrement);
    return;
}

LONG
KeReadStateProcess (
    __in PRKPROCESS Process
    )

/*++

Routine Description:

    This function reads the current signal state of a process object.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

Return Value:

    The current signal state of the process object.

--*/

{

    ASSERT_PROCESS(Process);

    //
    // Return current signal state of process object.
    //

    return Process->Header.SignalState;
}

LONG
KeSetProcess (
    __inout PRKPROCESS Process,
    __in KPRIORITY Increment,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This function sets the signal state of a process object to Signaled
    and attempts to satisfy as many Waits as possible. The previous
    signal state of the process object is returned as the function value.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    Increment - Supplies the priority increment that is to be applied
       if setting the process causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KeSetProcess will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the process object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the previous state of the process object is Not-Signaled and
    // the wait queue is not empty, then satisfy as many Waits as
    // possible.
    //

    OldState = Process->Header.SignalState;
    Process->Header.SignalState = 1;
    if ((OldState == 0) &&
        (IsListEmpty(&Process->Header.WaitListHead) == FALSE)) {

        KiWaitTestWithoutSideEffects(Process, Increment);
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait) {
        Thread = KeGetCurrentThread();
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of process object.
    //

    return OldState;
}

KAFFINITY
KeSetAffinityProcess (
    __inout PKPROCESS Process,
    __in KAFFINITY Affinity
    )

/*++

Routine Description:

    This function sets the affinity of a process to the specified value and
    also sets the affinity of each thread in the process to the specified
    value.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    Affinity - Supplies the new of set of processors on which the threads
        in the process can run.

Return Value:

    The previous affinity of the specified process is returned as the function
    value.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    KAFFINITY OldAffinity;
    PKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT((Affinity & KeActiveProcessors) != 0);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the process lock, and acquire the
    // dispatcher databack lock at SYNCH_LEVEL.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Capture the current affinity of the specified process and set the
    // affinity of the process.
    //

    OldAffinity = Process->Affinity;
    Process->Affinity = Affinity;

    //
    // If the new affinity does not intersect with the process ideal node
    // affinity, then select a new process ideal node.
    //

#if !defined(NT_UP)

    if ((Affinity & KeNodeBlock[Process->IdealNode]->ProcessorMask) == 0) {
        KiSetIdealNodeProcess(Process, Affinity);
    }

#endif

    //
    // Set the affinity of all process threads.
    //

    NextEntry = Process->ThreadListHead.Flink;
    while (NextEntry != &Process->ThreadListHead) {
        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);
        KiSetAffinityThread(Thread, Affinity);
        NextEntry = NextEntry->Flink;
    }

    //
    // Unlock dispatcher database, unlock the process lock, exit the
    // scheduler, and return the previous process affinity.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return OldAffinity;
}

KPRIORITY
KeSetPriorityAndQuantumProcess (
    __inout PKPROCESS Process,
    __in KPRIORITY NewBase,
    __in SCHAR QuantumReset
    )

/*++

Routine Description:

    This function sets the base priority and quantum reset of a process to a
    new value and adjusts the priority, base priority, and quantum reset value
    of all child threads as appropriate. 

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    NewBase - Supplies the new base priority of the process.

    QuantumReset - Supplies the new quantum rest value if nonzero.

Return Value:

    The previous base priority of the process.

--*/

{

    KPRIORITY Adjustment;
    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    KPRIORITY NewPriority;
    KPRIORITY OldBase;
    PKTHREAD Thread;

    ASSERT_PROCESS(Process);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the new priority is equal to the old priority, then do not change
    // the process priority or the quantum reset value and return the old
    // priority.
    //
    // N.B. This check can be made without holding the dispatcher lock since
    // nothing needs to be protected, and any race condition that can exist
    // calling this routine exists with or without the lock being held.
    //

    if (Process->BasePriority == NewBase) {
        return NewBase;
    }

    //
    // If the new base priority is zero, then default it to one.
    //

    if (NewBase == 0) {
        NewBase = 1;
    }

    //
    // Raise IRQL to SYNCH level, acquire the process lock, and lock the
    // dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If the quantum reset value is nonzsro, then set the new quantum reset
    // value of the process.
    //

    if (QuantumReset != 0) {
        Process->QuantumReset = QuantumReset;
    }

    //
    // Save the current process base priority, set the new process base
    // priority, compute the adjustment value, and adjust the priority
    // and base priority of all child threads as appropriate.
    //

    OldBase = Process->BasePriority;
    Process->BasePriority = (SCHAR)NewBase;
    Adjustment = NewBase - OldBase;
    NextEntry = Process->ThreadListHead.Flink;
    if (NewBase >= LOW_REALTIME_PRIORITY) {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // If the quantum reset value is nonzsro, then set the new quantum
            // reset value of the thread.
            //
        
            if (QuantumReset != 0) {
                Thread->QuantumReset = QuantumReset;
            }
        
            //
            // Acquire the thread lock and compute the new base priority of
            // the thread.
            //

            KiAcquireThreadLock(Thread);
            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the realtime class,
            // then limit the change to the realtime class.
            //

            if (NewPriority < LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY;

            } else if (NewPriority > HIGH_PRIORITY) {
                NewPriority = HIGH_PRIORITY;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the appropriate value.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from variable to realtime, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase < LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = HIGH_PRIORITY;

                } else if (Thread->Saturation < 0) {
                    NewPriority = LOW_REALTIME_PRIORITY;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Thread->QuantumReset;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            KiReleaseThreadLock(Thread);
            NextEntry = NextEntry->Flink;
        }

    } else {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // If the quantum reset value is nonzsro, then set the new quantum
            // reset value of the thread.
            //
        
            if (QuantumReset != 0) {
                Thread->QuantumReset = QuantumReset;
            }
        
            //
            // Acquire the thread lock and compute the new base priority of
            // the thread.
            //

            KiAcquireThreadLock(Thread);
            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the variable class,
            // then limit the change to the variable class.
            //

            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;

            } else if (NewPriority <= LOW_PRIORITY) {
                NewPriority = 1;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the computed value and reset the thread quantum.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from realtime to variable, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase >= LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = LOW_REALTIME_PRIORITY - 1;

                } else if (Thread->Saturation < 0) {
                    NewPriority = 1;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Thread->QuantumReset;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            KiReleaseThreadLock(Thread);
            NextEntry = NextEntry->Flink;
        }
    }

    //
    // Unlock dispatcher database, unlock the process lock, exit the
    // scheduler, and return the previous base priority.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return OldBase;
}

VOID
KeSetQuantumProcess (
    __inout PKPROCESS Process,
    __in SCHAR QuantumReset
    )

/*++

Routine Description:

    This function sets the quantum for a process to a new value and sets
    the quantum reset value of all child threads.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    QuantumReset - Supplies the new quantum reset value of the process.

Return Value:

    The previous base priority of the process.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    PLIST_ENTRY NextEntry;
    PKTHREAD Thread;

    ASSERT_PROCESS(Process);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH level and acquire the process lock.
    //
    // Set the new process quantum reset value and the quantum reset value
    // of all child threads.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);
    Process->QuantumReset = QuantumReset;
    NextEntry = Process->ThreadListHead.Flink;
    while (NextEntry != &Process->ThreadListHead) {
        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);
        Thread->QuantumReset = QuantumReset;
        NextEntry = NextEntry->Flink;
    }

    //
    // Unlock the process lock and return.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return;
}

LOGICAL
KeSetAutoAlignmentProcess (
    __inout PKPROCESS Process,
    __in LOGICAL Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    process.

Arguments:

    Process  - Supplies a pointer to a dispatcher object of type process.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the specified process.

Return Value:

    The previous value of auto alignment for the specified process is returned
    as the function value.

--*/

{

    ASSERT_PROCESS(Process);

    //
    // Capture the previous data alignment handling mode and set the specified
    // data alignment mode.
    //

    if (Enable != FALSE) {
        return InterlockedBitTestAndSet(&Process->ProcessFlags,
                                        KPROCESS_AUTO_ALIGNMENT_BIT);

    } else {
        return InterlockedBitTestAndReset(&Process->ProcessFlags,
                                          KPROCESS_AUTO_ALIGNMENT_BIT);
    }
}

LOGICAL
KeSetDisableBoostProcess (
    __inout PKPROCESS Process,
    __in LOGICAL Disable
    )

/*++

Routine Description:

    This function disables or enables priority boosts for the specified
    process.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    Disable - Supplies a logical value that determines whether priority
        boosts are enabled or disabled for the specfied process.

Return Value:

    The previous value of disable priority boost for the specified process
    is returned as the function value.

--*/

{

    ASSERT_PROCESS(Process);

    //
    // Capture the current state of disable boost and set its state to the
    // specified value.
    //

    if (Disable != FALSE) {
        return InterlockedBitTestAndSet(&Process->ProcessFlags,
                                        KPROCESS_DISABLE_BOOST_BIT);

    } else {
        return InterlockedBitTestAndReset(&Process->ProcessFlags,
                                          KPROCESS_DISABLE_BOOST_BIT);
    }
}

LOGICAL
KeSetDisableQuantumProcess (
    __inout PKPROCESS Process,
    __in LOGICAL Disable
    )

/*++

Routine Description:

    This function disables or enables quantum runout for realtime threads in
    the specified process.

Arguments:

    Process  - Supplies a pointer to a dispatcher object of type process.

    Disable - Supplies a logical value that determines whether quantum
        runout is disabled or enabled for the specified process.

Return Value:

    The previous value of the disable quantum state for the specified process
    is returned as the function value.

--*/

{

    ASSERT_PROCESS(Process);

    //
    // Capture the current state of disable quantum and set its state to the
    // specified value.
    //

    if (Disable != FALSE) {
        return InterlockedBitTestAndSet(&Process->ProcessFlags,
                                        KPROCESS_DISABLE_QUANTUM_BIT);

    } else {
        return InterlockedBitTestAndReset(&Process->ProcessFlags,
                                          KPROCESS_DISABLE_QUANTUM_BIT);
    }
}

VOID
KiAttachProcess (
    __inout PRKTHREAD Thread,
    __in PKPROCESS Process,
    __in PKLOCK_QUEUE_HANDLE LockHandle,
    __out PRKAPC_STATE SavedApcState
    )

/*++

Routine Description:

    This function attaches a thread to a target process' address space.

    N.B. The dispatcher database lock and the thread APC queue lock must be
         held when this routine is called.

Arguments:

    Thread - Supplies a pointer to the current thread object.

    Process - Supplies a pointer to the current process object.

    Lockhandle - Supplies the address of the lock handle that was used to
        acquire the thread APC lock.

    SavedApcState - Supplies a pointer to the APC state structure that
        receives the saved APC state.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    PRKTHREAD OutThread;

    ASSERT(Process != Thread->ApcState.Process);

    //
    // Bias the stack count of the target process to signify that a
    // thread exists in that process with a stack that is resident.
    //

    ASSERT(Process->StackCount != MAXULONG_PTR);

    Process->StackCount += 1;

    //
    // Save current APC state and initialize a new APC state.
    //

    KiMoveApcState(&Thread->ApcState, SavedApcState);
    InitializeListHead(&Thread->ApcState.ApcListHead[KernelMode]);
    InitializeListHead(&Thread->ApcState.ApcListHead[UserMode]);
    Thread->ApcState.KernelApcInProgress = FALSE;
    Thread->ApcState.KernelApcPending  = FALSE;
    Thread->ApcState.UserApcPending = FALSE;
    if (SavedApcState == &Thread->SavedApcState) {
        Thread->ApcStatePointer[0] = &Thread->SavedApcState;
        Thread->ApcStatePointer[1] = &Thread->ApcState;
        Thread->ApcStateIndex = 1;
    }

    //
    // If the target process is in memory, then immediately enter the
    // new address space by loading a new Directory Table Base. Otherwise,
    // insert the current thread in the target process ready list, inswap
    // the target process if necessary, select a new thread to run on the
    // the current processor and context switch to the new thread.
    //

    if (Process->State == ProcessInMemory) {
        Thread->ApcState.Process = Process;

        //
        // It is possible that the process is in memory, but there exist
        // threads in the process ready list. This can happen when memory
        // management forces a process attach.
        //

        NextEntry = Process->ReadyListHead.Flink;
        while (NextEntry != &Process->ReadyListHead) {
            OutThread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            RemoveEntryList(NextEntry);
            OutThread->ProcessReadyQueue = FALSE;
            KiReadyThread(OutThread);
            NextEntry = Process->ReadyListHead.Flink;
        }

        //
        // Unlock dispatcher database, unlock the thread APC lock, swap the
        // address space to the target process, and exit the scheduler.
        //
    
        KiUnlockDispatcherDatabaseFromSynchLevel();
        KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle);
        KiSwapProcess(Process, SavedApcState->Process);
        KiExitDispatcher(LockHandle->OldIrql);

    } else {
        Thread->State = Ready;
        Thread->ProcessReadyQueue = TRUE;
        InsertTailList(&Process->ReadyListHead, &Thread->WaitListEntry);
        if (Process->State == ProcessOutOfMemory) {
            Process->State = ProcessInTransition;
            InterlockedPushEntrySingleList(&KiProcessInSwapListHead,
                                           &Process->SwapListEntry);

            KiSetInternalEvent(&KiSwapEvent, KiSwappingThread);
        }

        //
        // Set the current thread wait IRQL, release the thread APC lock,
        // set swap busy for the current thread, unlock the dispatcher
        // database, and swap context to a new thread.
        //

        Thread->WaitIrql = LockHandle->OldIrql;
        KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle);
        KiSetContextSwapBusy(Thread);
        KiUnlockDispatcherDatabaseFromSynchLevel();
        KiSwapThread(Thread, KeGetCurrentPrcb());

        //
        // Acquire the APC lock, acquire the dispatcher database lock, set
        // the new process object address, unlock the dispatcher database,
        // unlock the APC lock, swap the address space to the target process,
        // and exit the scheduler.
        //

        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                                   LockHandle);

        KiLockDispatcherDatabaseAtSynchLevel();
        Thread->ApcState.Process = Process;
        KiUnlockDispatcherDatabaseFromSynchLevel();
        KeReleaseInStackQueuedSpinLockFromDpcLevel(LockHandle);
        KiSwapProcess(Process, SavedApcState->Process);
        KiExitDispatcher(LockHandle->OldIrql);
    }

    return;
}

VOID
KiMoveApcState (
    __in PKAPC_STATE Source,
    __out PKAPC_STATE Destination
    )

/*++

Routine Description:

    This function moves the APC state from the source structure to the
    destination structure and reinitializes list headers as appropriate.

Arguments:

    Source - Supplies a pointer to the source APC state structure.

    Destination - Supplies a pointer to the destination APC state structure.


Return Value:

    None.

--*/

{

    PLIST_ENTRY First;
    PLIST_ENTRY Last;

    //
    // Copy the APC state from the source to the destination.
    //
    // N.B. Only the actual data in the APC state structure is moved without
    //      moving any of the padding.
    //

    RtlCopyMemory(Destination, Source, KAPC_STATE_ACTUAL_LENGTH);
    if (IsListEmpty(&Source->ApcListHead[KernelMode]) != FALSE) {
        InitializeListHead(&Destination->ApcListHead[KernelMode]);

    } else {
        First = Source->ApcListHead[KernelMode].Flink;
        Last = Source->ApcListHead[KernelMode].Blink;
        Destination->ApcListHead[KernelMode].Flink = First;
        Destination->ApcListHead[KernelMode].Blink = Last;
        First->Blink = &Destination->ApcListHead[KernelMode];
        Last->Flink = &Destination->ApcListHead[KernelMode];
    }

    if (IsListEmpty(&Source->ApcListHead[UserMode]) != FALSE) {
        InitializeListHead(&Destination->ApcListHead[UserMode]);

    } else {
        First = Source->ApcListHead[UserMode].Flink;
        Last = Source->ApcListHead[UserMode].Blink;
        Destination->ApcListHead[UserMode].Flink = First;
        Destination->ApcListHead[UserMode].Blink = Last;
        First->Blink = &Destination->ApcListHead[UserMode];
        Last->Flink = &Destination->ApcListHead[UserMode];
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\profobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    profobj.c

Abstract:

    This module implements the kernel Profile Object. Functions are
    provided to initialize, start, and stop profile objects and to set
    and query the profile interval.

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeQueryIntervalProfile)

//
// The following assert macro is used to check that an input profile object is
// really a kprofile and not something else, like deallocated pool.
//

#define ASSERT_PROFILE(E) {             \
    ASSERT((E)->Type == ProfileObject); \
}

//
// Structure representing an active profile source
//

typedef struct _KACTIVE_PROFILE_SOURCE {
    LIST_ENTRY ListEntry;
    KPROFILE_SOURCE Source;
    KAFFINITY Affinity;
    ULONG ProcessorCount[1];            // variable-sized, one per processor
} KACTIVE_PROFILE_SOURCE, *PKACTIVE_PROFILE_SOURCE;

//
// Prototypes for IPI target functions
//

VOID
KiStartProfileInterrupt (
    __inout PKIPI_CONTEXT SignalDone,
    __in PVOID Parameter1,
    __in PVOID Parameter2,
    __in PVOID Parameter3
    );

VOID
KiStopProfileInterrupt (
    __inout PKIPI_CONTEXT SignalDone,
    __in PVOID Parameter1,
    __in PVOID Parameter2,
    __in PVOID Parameter3
    );

VOID
KeInitializeProfile (
    __out PKPROFILE Profile,
    __in_opt PKPROCESS Process,
    __in_opt PVOID RangeBase,
    __in SIZE_T RangeSize,
    __in ULONG BucketSize,
    __in ULONG Segment,
    __in KPROFILE_SOURCE ProfileSource,
    __in KAFFINITY ProfileAffinity
    )

/*++

Routine Description:

    This function initializes a kernel profile object. The process,
    address range, bucket size, and buffer are set. The profile is
    set to the stopped state.

Arguments:

    Profile - Supplies a pointer to control object of type profile.

    Process - Supplies an optional pointer to a process object that
        describes the address space to profile. If not specified,
        then all address spaces are included in the profile.

    RangeBase - Supplies the address of the first byte of the address
        range for which profiling information is to be collected.

    RangeSize - Supplies the size of the address range for which profiling
        information is to be collected.  The RangeBase and RangeSize
        parameters are interpreted such that RangeBase <= address <
        RangeBase + RangeSize generates a profile hit.

    BucketSize - Supplies the log base 2 of the size of a profiling bucket.
        Thus, BucketSize = 2 yields 4-byte buckets, BucketSize = 7 yields
        128-byte buckets.

    Segment - Supplies the non-Flat code segment to profile.  If this
        is zero, then the flat profiling is done.  This will only
        be non-zero on an x86 machine.

    ProfileSource - Supplies the profile interrupt source.

    ProfileAffinity - Supplies the set of processor to count hits for.

Return Value:

    None.

--*/

{

#if !defined(i386)

    ASSERT(Segment == 0);

#endif

    //
    // Initialize the standard control object header.
    //

    Profile->Type = ProfileObject;
    Profile->Size = sizeof(KPROFILE);

    //
    // Initialize the process address space, range base, range limit,
    // bucket shift count, and set started FALSE.
    //

    if (ARGUMENT_PRESENT(Process)) {
        Profile->Process = Process;

    } else {
        Profile->Process = NULL;
    }

    Profile->RangeBase = RangeBase;
    Profile->RangeLimit = (PUCHAR)RangeBase + RangeSize;
    Profile->BucketShift = BucketSize - 2;
    Profile->Started = FALSE;
    Profile->Segment = Segment;
    Profile->Source = (CSHORT)ProfileSource;
    Profile->Affinity = ProfileAffinity & KeActiveProcessors;
    if (Profile->Affinity == 0) {
        Profile->Affinity = KeActiveProcessors;
    }

    return;
}

ULONG
KeQueryIntervalProfile (
    __in KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This function returns the profile sample interval the system is
    currently using.

Arguments:

    ProfileSource - Supplies the profile source to be queried.

Return Value:

    Sample interval in units of 100ns.

--*/

{

    HAL_PROFILE_SOURCE_INFORMATION ProfileSourceInfo;
    ULONG ReturnedLength;
    NTSTATUS Status;

    if (ProfileSource == ProfileTime) {

        //
        // Return the current sampling interval in 100ns units.
        //

        return KiProfileInterval;

    } else

    if (ProfileSource == ProfileAlignmentFixup) {
        return KiProfileAlignmentFixupInterval;

    } else {

        //
        // The HAL is responsible for tracking this profile interval.
        //

        ProfileSourceInfo.Source = ProfileSource;
        Status = HalQuerySystemInformation(HalProfileSourceInformation,
                                           sizeof(HAL_PROFILE_SOURCE_INFORMATION),
                                           &ProfileSourceInfo,
                                           &ReturnedLength);

        if (NT_SUCCESS(Status) && ProfileSourceInfo.Supported) {
            return ProfileSourceInfo.Interval;

        } else {
            return 0;
        }
    }
}

VOID
KeSetIntervalProfile (
    __in ULONG Interval,
    __in KPROFILE_SOURCE Source
    )

/*++

Routine Description:

    This function sets the profile sampling interval. The interval is in
    100ns units. The interval will actually be set to some value in a set
    of preset values (at least on pc based hardware), using the one closest
    to what the user asked for.

Arguments:

    Interval - Supplies the length of the sampling interval in 100ns units.

Return Value:

    None.

--*/

{

    HAL_PROFILE_SOURCE_INTERVAL ProfileSourceInterval;

    if (Source == ProfileTime) {

        //
        // If the specified sampling interval is less than the minimum
        // sampling interval, then set the sampling interval to the minimum
        // sampling interval.
        //

        if (Interval < MINIMUM_PROFILE_INTERVAL) {
            Interval = MINIMUM_PROFILE_INTERVAL;
        }

        //
        // Set the sampling interval.
        //

        KiProfileInterval = (ULONG)KeIpiGenericCall(HalSetProfileInterval, Interval);

    } else

    if (Source == ProfileAlignmentFixup) {
        KiProfileAlignmentFixupInterval = Interval;

    } else {

        //
        // The HAL is responsible for setting this profile interval.
        //

        ProfileSourceInterval.Source = Source;
        ProfileSourceInterval.Interval = Interval;
        HalSetSystemInformation(HalProfileSourceInterval,
                                sizeof(HAL_PROFILE_SOURCE_INTERVAL),
                                &ProfileSourceInterval);
    }

    return;
}

BOOLEAN
KeStartProfile (
    __inout PKPROFILE Profile,
    __out_opt PULONG Buffer
    )

/*++

Routine Description:

    This function starts profile data gathering on the specified profile
    object. The profile object is marked started, and is registered with
    the profile interrupt procedure.

    If the number of active profile objects was previously zero, then the
    profile interrupt is enabled.

    N.B. For the current implementation, an arbitrary number of profile
        objects may be active at once. This can present a large system
        overhead. It is assumed that the caller appropriately limits the
        the number of active profiles.

Arguments:

    Profile - Supplies a pointer to a control object of type profile.

    Buffer - Supplies a pointer to an optional array of counters which record
        the number of hits in the corresponding bucket.

Return Value:

    A value of TRUE is returned if profiling was previously stopped for
    the specified profile object. Otherwise, a value of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    PKPROCESS Process;
    BOOLEAN Started;
    KAFFINITY TargetProcessors;
    PKPRCB Prcb;
    PKACTIVE_PROFILE_SOURCE ActiveSource = NULL;
    PKACTIVE_PROFILE_SOURCE CurrentActiveSource;
    PKACTIVE_PROFILE_SOURCE AllocatedPool;
    PLIST_ENTRY ListEntry;
    ULONG SourceSize;
    KAFFINITY AffinitySet;
    PULONG Reference;

    ASSERT_PROFILE(Profile);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Allocate pool that may be required before raising to PROFILE_LEVEL.
    //

    SourceSize =
        sizeof(KACTIVE_PROFILE_SOURCE) + sizeof(ULONG) * (KeNumberProcessors - 1);

    AllocatedPool = ExAllocatePoolWithTag(NonPagedPool, SourceSize, 'forP');
    if (AllocatedPool == NULL) {
        return(TRUE);
    }

    //
    // Raise IRQL to profile level and acquire the profile lock.
    //

    OldIrql = KfRaiseIrql(KiProfileIrql);
    KeAcquireSpinLockAtDpcLevel(&KiProfileLock);

    //
    // Assume object already started.
    //

    Started = FALSE;
    AffinitySet = 0L;
    TargetProcessors = 0L;

    //
    // If the specified profile object is not started, set started to TRUE,
    // set the address of the profile buffer, set the profile object to started,
    // insert the profile object in the appropriate profile list, and start
    // profile interrupts if the number of active profile objects was previously zero.
    //

    Prcb = KeGetCurrentPrcb();
    if (Profile->Started == FALSE) {
        Started = TRUE;
        Profile->Buffer = Buffer;
        Profile->Started = TRUE;
        Process = Profile->Process;

        //
        // If a profile buffer is specified, then profile either the process
        // or system. Otherwise, profile events.
        //

        if (Profile->Buffer != NULL) {
            if (Process != NULL) {
                InsertTailList(&Process->ProfileListHead, &Profile->ProfileListEntry);

            } else {
                InsertTailList(&KiProfileListHead, &Profile->ProfileListEntry);
            }

        } else {
            InitializeListHead(&Profile->ProfileListEntry);
        }

        //
        // Check the profile source list to see if this profile source is
        // already started. If so, update the reference counts. If not,
        // allocate a profile source object, initialize the reference
        // counts, and add it to the list.
        //

        ListEntry = KiProfileSourceListHead.Flink;
        while (ListEntry != &KiProfileSourceListHead) {
            CurrentActiveSource = CONTAINING_RECORD(ListEntry,
                                                    KACTIVE_PROFILE_SOURCE,
                                                    ListEntry);

            if (CurrentActiveSource->Source == Profile->Source) {
                ActiveSource = CurrentActiveSource;
                break;
            }

            ListEntry = ListEntry->Flink;
        }

        if (ActiveSource == NULL) {

            //
            // This source was not found, allocate and initialize a new entry and add
            // it to the head of the list.
            //

            ActiveSource = AllocatedPool;
            AllocatedPool = NULL;
            RtlZeroMemory(ActiveSource, SourceSize);
            ActiveSource->Source = Profile->Source;
            InsertHeadList(&KiProfileSourceListHead, &ActiveSource->ListEntry);
            if (Profile->Source == ProfileAlignmentFixup) {
                KiProfileAlignmentFixup = TRUE;
            }
        }

        //
        // Increment the reference counts for each processor in the
        // affinity set.
        //

        AffinitySet = Profile->Affinity;
        Reference = &ActiveSource->ProcessorCount[0];
        while (AffinitySet != 0) {
            if (AffinitySet & 1) {
                *Reference = *Reference + 1;
            }

            AffinitySet = AffinitySet >> 1;
            Reference = Reference + 1;
        }

        //
        // Compute the processors which the profile interrupt is
        // required and not already started
        //

        AffinitySet = Profile->Affinity & ~ActiveSource->Affinity;
        TargetProcessors = AffinitySet & ~Prcb->SetMember;

        //
        // Update set of processors on which this source is active.
        //

        ActiveSource->Affinity |= Profile->Affinity;
    }

    //
    // Release the profile lock, lower IRQL to its previous value, and
    // return whether profiling was started.
    //

    KeReleaseSpinLockFromDpcLevel(&KiProfileLock);
    KeLowerIrql(DISPATCH_LEVEL);

    //
    // Start profile interrupt on pending processors.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiStartProfileInterrupt,
                        (PVOID)(ULONG_PTR)Profile->Source,
                        NULL,
                        NULL);
    }

#endif

    if (AffinitySet & Prcb->SetMember) {
        if (Profile->Source == ProfileAlignmentFixup) {
            KiEnableAlignmentExceptions();
        }

        KfRaiseIrql(KiProfileIrql);
        HalStartProfileInterrupt(Profile->Source);
        KeLowerIrql(DISPATCH_LEVEL);
    }

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargetsPrcb(TargetProcessors, Prcb);
    }

#endif

    //
    // Lower to original IRQL
    //

    KeLowerIrql(OldIrql);

    //
    // If the allocated pool was not used, free it now.
    //

    if (AllocatedPool != NULL) {
        ExFreePool(AllocatedPool);
    }

    return Started;
}

BOOLEAN
KeStopProfile (
    __inout PKPROFILE Profile
    )

/*++

Routine Description:

    This function stops profile data gathering on the specified profile
    object. The object is marked stopped, and is removed from the active
    profile list.

    If the number of active profile objects goes to zero, then the profile
    interrupt is disabled.

Arguments:

    Profile - Supplies a pointer to a control object of type profile.

Return Value:

    A value of TRUE is returned if profiling was previously started for
    the specified profile object. Otherwise, a value of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Stopped;
    KAFFINITY TargetProcessors;
    PKPRCB Prcb;
    PLIST_ENTRY ListEntry;
    PKACTIVE_PROFILE_SOURCE ActiveSource;
    PKACTIVE_PROFILE_SOURCE PoolToFree=NULL;
    KAFFINITY AffinitySet = 0;
    KAFFINITY CurrentProcessor;
    PULONG Reference;

    ASSERT_PROFILE(Profile);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Assume object already stopped
    //

    Stopped = FALSE;
    AffinitySet = 0L;
    TargetProcessors = 0L;

    //
    // Raise IRQL to profile level and acquire the profile lock.
    //

    OldIrql = KfRaiseIrql(KiProfileIrql);
    KeAcquireSpinLockAtDpcLevel(&KiProfileLock);

    //
    // If the specified profile object is not stopped, set stopped to TRUE, set
    // the profile object to stopped, remove the profile object object from the
    // appropriate profilelist, and stop profile interrupts if the number of
    // active profile objects is zero.
    //

    Prcb = KeGetCurrentPrcb();
    if (Profile->Started != FALSE) {
        Stopped = TRUE;
        Profile->Started = FALSE;
        if (!IsListEmpty(&Profile->ProfileListEntry)) {
            RemoveEntryList(&Profile->ProfileListEntry);
        }

        //
        // Search the profile source list to find the entry for this
        // profile source.
        //

        ListEntry = KiProfileSourceListHead.Flink;
        do {
            ASSERT(ListEntry != &KiProfileSourceListHead);
            ActiveSource = CONTAINING_RECORD(ListEntry,
                                             KACTIVE_PROFILE_SOURCE,
                                             ListEntry);

            ListEntry = ListEntry->Flink;
        } while (ActiveSource->Source != Profile->Source);

        //
        // Decrement the reference counts for each processor in the
        // affinity set and build up a mask of the processors that
        // now have a reference count of zero.
        //

        CurrentProcessor = 1;
        TargetProcessors = 0;
        AffinitySet = Profile->Affinity;
        Reference = &ActiveSource->ProcessorCount[0];
        while (AffinitySet != 0) {
            if (AffinitySet & 1) {
                *Reference = *Reference - 1;
                if (*Reference == 0) {
                    TargetProcessors = TargetProcessors | CurrentProcessor;
                }
            }

            AffinitySet = AffinitySet >> 1;
            Reference = Reference + 1;
            CurrentProcessor = CurrentProcessor << 1;
        }

        //
        // Compute the processors whose profile interrupt reference
        // count has dropped to zero.
        //

        AffinitySet = TargetProcessors;
        TargetProcessors = AffinitySet & ~Prcb->SetMember;

        //
        // Update set of processors on which this source is active.
        //

        ActiveSource->Affinity &= ~AffinitySet;

        //
        // Determine whether this profile source is stopped on all
        // processors. If so, remove it from the list and free it.
        //

        if (ActiveSource->Affinity == 0) {
            RemoveEntryList(&ActiveSource->ListEntry);
            PoolToFree = ActiveSource;
            if (Profile->Source == ProfileAlignmentFixup) {
                KiProfileAlignmentFixup = FALSE;
            }
        }
    }

    //
    // Release the profile lock, lower IRQL to its previous value, and
    // return whether profiling was stopped.
    //

    KeReleaseSpinLockFromDpcLevel(&KiProfileLock);
    KeLowerIrql(DISPATCH_LEVEL);

    //
    // Stop profile interrupt on pending processors
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiStopProfileInterrupt,
                        (PVOID)(ULONG_PTR)Profile->Source,
                        NULL,
                        NULL);
    }

#endif

    if (AffinitySet & Prcb->SetMember) {
        if (Profile->Source == ProfileAlignmentFixup) {
            KiDisableAlignmentExceptions();
        }

        KfRaiseIrql(KiProfileIrql);
        HalStopProfileInterrupt(Profile->Source);
        KeLowerIrql(DISPATCH_LEVEL);
    }

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargetsPrcb(TargetProcessors, Prcb);
    }

#endif

    //
    // Lower to original IRQL
    //

    KeLowerIrql(OldIrql);

    //
    // Now that IRQL has been lowered, free the profile source if
    // necessary.
    //

    if (PoolToFree != NULL) {
        ExFreePool(PoolToFree);
    }

    return Stopped;
}

#if !defined(NT_UP)

VOID
KiStopProfileInterrupt (
    __inout PKIPI_CONTEXT SignalDone,
    __in PVOID Parameter1,
    __in PVOID Parameter2,
    __in PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for stopping the profile interrupt on target
    processors.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed

    Parameter1 - Supplies the profile source

    Parameter2 - Parameter3 - not used

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    KPROFILE_SOURCE ProfileSource;

    UNREFERENCED_PARAMETER(Parameter2);
    UNREFERENCED_PARAMETER(Parameter3);

    //
    // Stop the profile interrupt on the current processor and clear the
    // data cache packet address to signal the source to continue.
    //

    ProfileSource = (KPROFILE_SOURCE)PtrToUlong(Parameter1);
    if (ProfileSource == ProfileAlignmentFixup) {
        KiDisableAlignmentExceptions();
    }

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < KiProfileIrql) {
        KfRaiseIrql(KiProfileIrql);
    }

    HalStopProfileInterrupt(ProfileSource);
    KeLowerIrql(OldIrql);
    KiIpiSignalPacketDone(SignalDone);
    return;
}

VOID
KiStartProfileInterrupt (
    __inout PKIPI_CONTEXT SignalDone,
    __in PVOID Parameter1,
    __in PVOID Parameter2,
    __in PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for stopping the profile interrupt on target
    processors.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed

    Parameter1 - Supplies the profile source

    Parameter2 - Parameter3 - not used

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    KPROFILE_SOURCE ProfileSource;

    UNREFERENCED_PARAMETER(Parameter2);
    UNREFERENCED_PARAMETER(Parameter3);

    //
    // Start the profile interrupt on the current processor and clear the
    // data cache packet address to signal the source to continue.
    //

    ProfileSource = (KPROFILE_SOURCE)PtrToUlong(Parameter1);
    if (ProfileSource == ProfileAlignmentFixup) {
        KiEnableAlignmentExceptions();
    }

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < KiProfileIrql) {
        KfRaiseIrql(KiProfileIrql);
    }

    HalStartProfileInterrupt(ProfileSource);
    KeLowerIrql(OldIrql);
    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\mutntobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    mutntobj.c

Abstract:

    This module implements the kernel mutant object. Functions are
    provided to initialize, read, and release mutant objects.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input mutant is
// really a kmutant and not something else, like deallocated pool.
//

#define ASSERT_MUTANT(E) {                    \
    ASSERT((E)->Header.Type == MutantObject); \
}

VOID
KeInitializeMutant (
    __out PRKMUTANT Mutant,
    __in BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function initializes a kernel mutant object.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    InitialOwner - Supplies a boolean value that determines whether the
        current thread is to be the initial owner of the mutant object.

Return Value:

    None.

--*/

{

    PLIST_ENTRY ListEntry;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    //
    // Initialize standard dispatcher object header, set the owner thread to
    // NULL, set the abandoned state to FALSE, and set the APC disable count
    // to zero (this is the only thing that distinguishes a mutex from a mutant).
    //

    Mutant->Header.Type = MutantObject;
    Mutant->Header.Size = sizeof(KMUTANT) / sizeof(LONG);
    if (InitialOwner == TRUE) {
        Thread = KeGetCurrentThread();
        Mutant->Header.SignalState = 0;
        Mutant->OwnerThread = Thread;
        KiLockDispatcherDatabase(&OldIrql);
        ListEntry = Thread->MutantListHead.Blink;
        InsertHeadList(ListEntry, &Mutant->MutantListEntry);
        KiUnlockDispatcherDatabase(OldIrql);

    } else {
        Mutant->Header.SignalState = 1;
        Mutant->OwnerThread = (PKTHREAD)NULL;
    }

    InitializeListHead(&Mutant->Header.WaitListHead);
    Mutant->Abandoned = FALSE;
    Mutant->ApcDisable = 0;
    return;
}

VOID
KeInitializeMutex (
    __out PRKMUTANT Mutant,
    __in ULONG Level
    )

/*++

Routine Description:

    This function initializes a kernel mutex object. The level number
    is ignored.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

Arguments:

    Mutex - Supplies a pointer to a dispatcher object of type mutex.

    Level - Ignored.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Level);

    //
    // Initialize standard dispatcher object header, set the owner thread to
    // NULL, set the abandoned state to FALSE, and set the APC disable count
    // to one (this is the only thing that distinguishes a mutex from a mutant).
    //

    Mutant->Header.Type = MutantObject;
    Mutant->Header.Size = sizeof(KMUTANT) / sizeof(LONG);
    Mutant->Header.SignalState = 1;
    InitializeListHead(&Mutant->Header.WaitListHead);
    Mutant->OwnerThread = (PKTHREAD)NULL;
    Mutant->Abandoned = FALSE;
    Mutant->ApcDisable = 1;
    return;
}

LONG
KeReadStateMutant (
    __in PRKMUTANT Mutant
    )

/*++

Routine Description:

    This function reads the current signal state of a mutant object.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

Return Value:

    The current signal state of the mutant object.

--*/

{

    ASSERT_MUTANT(Mutant);

    //
    // Return current signal state of mutant object.
    //

    return Mutant->Header.SignalState;
}

LONG
KeReleaseMutant (
    __inout PRKMUTANT Mutant,
    __in KPRIORITY Increment,
    __in BOOLEAN Abandoned,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a mutant object by incrementing the mutant
    count. If the resultant value is one, then an attempt is made to
    satisfy as many Waits as possible. The previous signal state of
    the mutant is returned as the function value. If the Abandoned
    parameter is TRUE, then the mutant object is released by settings
    the signal state to one.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    Increment - Supplies the priority increment that is to be applied
        if setting the event causes a Wait to be satisfied.

    Abandoned - Supplies a boolean value that signifies whether the
        mutant object is being abandoned.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseMutant will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the mutant object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;
    ULONG LeaveCriticalRegion;

    ASSERT_MUTANT(Mutant);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT((Mutant->ApcDisable == 0) || (Mutant->ApcDisable == 1));

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    LeaveCriticalRegion = 0;
    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the mutant object.
    //

    OldState = Mutant->Header.SignalState;

    //
    // If the Abandoned parameter is TRUE, then force the release of the
    // mutant object by setting its ownership count to one and setting its
    // abandoned state to TRUE. Otherwise increment mutant ownership count.
    // If the result count is one, then remove the mutant object from the
    // thread's owned mutant list, set the owner thread to NULL, and attempt
    // to satisfy a Wait for the mutant object if the mutant object wait
    // list is not empty.
    //

    if (Abandoned != FALSE) {
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;

    } else {

        //
        // If the Mutant object is not owned by the current thread, then
        // unlock the dispatcher data base and raise an exception. Otherwise
        // increment the ownership count.
        //

        if (Mutant->OwnerThread != Thread) {
            KiUnlockDispatcherDatabase(OldIrql);
            ExRaiseStatus(Mutant->Abandoned ?
                          STATUS_ABANDONED : STATUS_MUTANT_NOT_OWNED);
        }

        Mutant->Header.SignalState += 1;
    }

    if (Mutant->Header.SignalState == 1) {
        if (OldState <= 0) {
            RemoveEntryList(&Mutant->MutantListEntry);
            LeaveCriticalRegion = Mutant->ApcDisable;
        }

        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) == FALSE) {
            KiWaitTest(Mutant, Increment);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to
    // caller with IRQL raised and the dispatcher database locked.
    // Else release the dispatcher database lock and lower IRQL to
    // its previous value.
    //

    if (Wait != FALSE) {
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // If kernel APC disable was biased when the mutant was acquired (mutex
    // variant), then leave critical region.
    //

    if (LeaveCriticalRegion != 0) {
        KeLeaveCriticalRegionThread(Thread);
    }

    //
    // Return previous signal state of mutant object.
    //

    return OldState;
}

LONG
KeReleaseMutex (
    __inout PRKMUTANT Mutex,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a mutex object.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

Arguments:

    Mutex - Supplies a pointer to a dispatcher object of type mutex.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseMutex will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the mutex object.

--*/

{

    ASSERT_MUTANT(Mutex);

    //
    // Release the specified mutex object with defaults for increment
    // and abandoned parameters.
    //

    return KeReleaseMutant(Mutex, 1, FALSE, Wait);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\queueobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    queueobj.c

Abstract:

    This module implements the kernel queue object. Functions are provided
    to initialize, read, insert, and remove queue objects.

--*/

#include "ki.h"

VOID
KeInitializeQueue (
    __out PRKQUEUE Queue,
    __in ULONG Count
    )

/*++

Routine Description:

    This function initializes a kernel queue object.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

    Count - Supplies the target maximum number of threads that should
        be concurrently active. If this parameter is specified as zero,
        then the number of processors is used.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // state of queue object.
    //

    Queue->Header.Type = QueueObject;
    Queue->Header.Size = sizeof(KQUEUE) / sizeof(LONG);
    Queue->Header.SignalState = 0;
    InitializeListHead(&Queue->Header.WaitListHead);

    //
    // Initialize queue listhead, the thread list head, the current number
    // of threads, and the target maximum number of threads.
    //

    InitializeListHead(&Queue->EntryListHead);
    InitializeListHead(&Queue->ThreadListHead);
    Queue->CurrentCount = 0;
    if (ARGUMENT_PRESENT(Count)) {
        Queue->MaximumCount = Count;

    } else {
        Queue->MaximumCount = KeNumberProcessors;
    }

    return;
}

LONG
KeReadStateQueue (
    __in PRKQUEUE Queue
    )

/*++

Routine Description:

    This function reads the current signal state of a Queue object.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

Return Value:

    The current signal state of the Queue object.

--*/

{

    ASSERT_QUEUE(Queue);

    return Queue->Header.SignalState;
}

LONG
KeInsertQueue (
    __inout PRKQUEUE Queue,
    __inout PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is FIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH level and lock the dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, FALSE);

    //
    // Unlock the dispatcher database, exit the dispatcher, and return the
    // signal state of queue object.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KiExitDispatcher(OldIrql);
    return OldState;
}

LONG
KeInsertHeadQueue (
    __inout PRKQUEUE Queue,
    __inout PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH level and lock the dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, TRUE);

    //
    // Unlock the dispatcher database, exit the dispatcher, and return the
    // signal state of queue object.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KiExitDispatcher(OldIrql);
    return OldState;
}

//
// The following macro initializes thread local variables for the wait
// for single object kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeRemoveQueue()                                             \
    Thread->WaitBlockList = WaitBlock;                                      \
    WaitBlock->Object = (PVOID)Queue;                                       \
    WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);                          \
    WaitBlock->WaitType = WaitAny;                                          \
    WaitBlock->Thread = Thread;                                             \
    Thread->WaitStatus = 0;                                                 \
    if (ARGUMENT_PRESENT(Timeout)) {                                        \
        KiSetDueTime(Timer, *Timeout, &Hand);                               \
        DueTime.QuadPart = Timer->DueTime.QuadPart;                         \
        WaitBlock->NextWaitBlock = WaitTimer;                               \
        WaitTimer->NextWaitBlock = WaitBlock;                               \
        Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;       \
        Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;       \
    } else {                                                                \
        WaitBlock->NextWaitBlock = WaitBlock;                               \
    }                                                                       \
    Thread->Alertable = FALSE;                                              \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = WrQueue;                                           \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime= KiQueryLowTickCount()

PLIST_ENTRY
KeRemoveQueue (
    __inout PRKQUEUE Queue,
    __in KPROCESSOR_MODE WaitMode,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    This function removes the next entry from the Queue object entry
    list. If no list entry is available, then the calling thread is
    put in a wait state.

    N.B. The wait discipline for Queue object LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The address of the entry removed from the Queue object entry list or
    STATUS_TIMEOUT.

    N.B. These values can easily be distinguished by the fact that all
         addresses in kernel mode have the high order bit set.

--*/

{

    PKPRCB CurrentPrcb;
    LARGE_INTEGER DueTime;
    PLIST_ENTRY Entry;
    ULONG Hand;
    LARGE_INTEGER NewTime;
    PRKQUEUE OldQueue;
    PLARGE_INTEGER OriginalTime;
    LOGICAL StackSwappable;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;
    LONG_PTR WaitStatus;
    PRKWAIT_BLOCK WaitTimer;

    ASSERT_QUEUE(Queue);

    //
    // Set constant variables.
    //

    Hand = 0;
    OriginalTime = Timeout;
    Thread = KeGetCurrentThread();
    Timer = &Thread->Timer;
    WaitBlock = &Thread->WaitBlock[0];
    WaitTimer = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If the dispatcher database lock is already held, then initialize the
    // local variables. Otherwise, raise IRQL to SYNCH_LEVEL, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;
        InitializeRemoveQueue();

    } else {
        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();
        InitializeRemoveQueue();
        KiLockDispatcherDatabaseAtSynchLevel();
    }

    //
    // Check if the thread is currently processing a queue entry and whether
    // the new queue is the same as the old queue.
    //

    OldQueue = Thread->Queue;
    Thread->Queue = Queue;
    if (Queue != OldQueue) {

        //
        // If the thread was previously associated with a queue, then remove
        // the thread from the old queue object thread list and attempt to
        // activate another thread.
        //

        Entry = &Thread->QueueListEntry;
        if (OldQueue != NULL) {
            RemoveEntryList(Entry);
            KiActivateWaiterQueue(OldQueue);
        }

        //
        // Insert thread in the thread list of the new queue that the thread
        // will be associate with.
        //

        InsertTailList(&Queue->ThreadListHead, Entry);

    } else {

        //
        // The previous and current queue are the same queue - decrement the
        // current number of threads.
        //

        Queue->CurrentCount -= 1;
    }

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the
    // middle of the wait or a kernel APC is pending on the first attempt
    // through the loop.
    //
    // If the Queue object entry list is not empty, then remove the next
    // entry from the Queue object entry list. Otherwise, wait for an entry
    // to be inserted in the queue.
    //

    do {

        //
        // Check if there is a queue entry available and the current
        // number of active threads is less than target maximum number
        // of threads.
        //

        Entry = Queue->EntryListHead.Flink;
        if ((Entry != &Queue->EntryListHead) &&
            (Queue->CurrentCount < Queue->MaximumCount)) {

            //
            // Decrement the number of entries in the queue object entry list,
            // increment the number of active threads, remove the next entry
            // from the list, and set the forward link to NULL.
            //

            Queue->Header.SignalState -= 1;
            Queue->CurrentCount += 1;
            if ((Entry->Flink == NULL) || (Entry->Blink == NULL)) {
                KeBugCheckEx(INVALID_WORK_QUEUE_ITEM,
                             (ULONG_PTR)Entry,
                             (ULONG_PTR)Queue,
                             (ULONG_PTR)&ExWorkerQueue[0],
                             (ULONG_PTR)((PWORK_QUEUE_ITEM)Entry)->WorkerRoutine);
            }

            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            break;

        } else {

            //
            // Test to determine if a kernel APC is pending.
            //
            // If a kernel APC is pending, the special APC disable count is
            // zero, and the previous IRQL was less than APC_LEVEL, then a
            // kernel APC was queued by another processor just after IRQL was
            // raised to DISPATCH_LEVEL, but before the dispatcher database
            // was locked.
            //
            // N.B. This can only happen in a multiprocessor system.
            //

            if (Thread->ApcState.KernelApcPending &&
                (Thread->SpecialApcDisable == 0) &&
                (Thread->WaitIrql < APC_LEVEL)) {

                //
                // Increment the current thread count, unlock the dispatcher
                // database, and exit the dispatcher. An APC interrupt will 
                // immediately occur which will result in the delivery of the
                // kernel APC, if possible.
                //

                Queue->CurrentCount += 1;
                KiUnlockDispatcherDatabaseFromSynchLevel();
                KiExitDispatcher(Thread->WaitIrql);

            } else {

                //
                // Test if a user APC is pending.
                //

                if ((WaitMode != KernelMode) && (Thread->ApcState.UserApcPending)) {
                    Entry = (PLIST_ENTRY)ULongToPtr(STATUS_USER_APC);
                    Queue->CurrentCount += 1;
                    break;
                }

                //
                // Check to determine if a timeout value is specified.
                //

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // Check if the timer has already expired.
                    //
                    // N.B. The constant fields of the timer wait block are
                    //      initialized when the thread is initialized. The
                    //      constant fields include the wait object, wait key,
                    //      wait type, and the wait list entry link pointers.
                    //

                    if (KiCheckDueTime(Timer) == FALSE) {
                        Entry = (PLIST_ENTRY)ULongToPtr(STATUS_TIMEOUT);
                        Queue->CurrentCount += 1;
                        break;
                    }
                }

                //
                // Insert wait block in object wait list.
                //

                InsertTailList(&Queue->Header.WaitListHead, &WaitBlock->WaitListEntry);

                //
                // Set the thread wait parameters, set the thread dispatcher
                // state to Waiting, and insert the thread in the wait list.
                //

                CurrentPrcb = KeGetCurrentPrcb();
                Thread->State = Waiting;
                if (StackSwappable != FALSE) {
                    InsertTailList(&CurrentPrcb->WaitListHead, &Thread->WaitListEntry);
                }

                //
                // Set swap busy for the current thread, unlock the dispatcher
                // database, and switch to a new thread.
                //
                // Control is returned at the original IRQL.
                //

                ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

                KiSetContextSwapBusy(Thread);

                if (ARGUMENT_PRESENT(Timeout)) {
                    KiInsertOrSignalTimer(Timer, Hand);

                } else {
                    KiUnlockDispatcherDatabaseFromSynchLevel();
                }

                WaitStatus = KiSwapThread(Thread, CurrentPrcb);

                //
                // If the thread was not awakened to deliver a kernel mode APC,
                // then return wait status.
                //

                Thread->WaitReason = 0;
                if (WaitStatus != STATUS_KERNEL_APC) {
                    return (PLIST_ENTRY)WaitStatus;
                }

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // Reduce the amount of time remaining before timeout occurs.
                    //

                    Timeout = KiComputeWaitInterval(OriginalTime,
                                                    &DueTime,
                                                    &NewTime);
                }
            }

            //
            // Raise IRQL to SYNCH level, initialize the local variables,
            // lock the dispatcher database, and decrement the count of
            // active threads.
            //

            Thread->WaitIrql = KeRaiseIrqlToSynchLevel();
            InitializeRemoveQueue();
            KiLockDispatcherDatabaseAtSynchLevel();
            Queue->CurrentCount -= 1;
        }

    } while (TRUE);

    //
    // Unlock the dispatcher database, exit the dispatcher, and return the
    // list entry address or a status of timeout.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KiExitDispatcher(Thread->WaitIrql);
    return Entry;
}

PLIST_ENTRY
KeRundownQueue (
    __inout PRKQUEUE Queue
    )

/*++

Routine Description:

    This function runs down the specified queue by removing the listhead
    from the queue list, removing any associated threads from the thread
    list, and returning the address of the first entry.


Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

Return Value:

    If the queue list is not empty, then the address of the first entry in
    the queue is returned as the function value. Otherwise, a value of NULL
    is returned.

--*/

{

    PLIST_ENTRY Entry;
    PLIST_ENTRY FirstEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(IsListEmpty(&Queue->Header.WaitListHead));

    //
    // Raise IRQL to SYNCH level and lock the dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Get the address of the first entry in the queue and check if the
    // list is empty or contains entries that should be flushed. If there
    // are no entries in the list, then set the return value to NULL.
    // Otherwise, set the return value to the address of the first list
    // entry and remove the listhead from the list.
    //

    FirstEntry = Queue->EntryListHead.Flink;
    if (FirstEntry == &Queue->EntryListHead) {
        FirstEntry = NULL;

    } else {
        RemoveEntryList(&Queue->EntryListHead);
    }

    //
    // Remove all associated threads from the thread list of the queue.
    //

    while (Queue->ThreadListHead.Flink != &Queue->ThreadListHead) {
        Entry = Queue->ThreadListHead.Flink;
        Thread = CONTAINING_RECORD(Entry, KTHREAD, QueueListEntry);
        Thread->Queue = NULL;
        RemoveEntryList(Entry);
    }

#if DBG

    Queue->EntryListHead.Flink = Queue->EntryListHead.Blink = NULL;
    Queue->ThreadListHead.Flink = Queue->ThreadListHead.Blink = NULL;
    Queue->Header.WaitListHead.Flink = Queue->Header.WaitListHead.Blink = NULL;

#endif

    //
    // Unlock the dispatcher database, exit the dispatcher, and return the
    // function value.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KiExitDispatcher(OldIrql);
    return FirstEntry;
}

LONG
FASTCALL
KiInsertQueue (
    __inout PRKQUEUE Queue,
    __inout PLIST_ENTRY Entry,
    __in BOOLEAN Head
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

    Head - Supplies a boolean value that determines whether the queue
        entry is inserted at the head or tail of the queue if it can
        not be immediately dispatched.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    LONG OldState;
    PRKTHREAD Thread;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    ASSERT_QUEUE(Queue);

    //
    // Capture the current signal state of queue object and check if there
    // is a thread waiting on the queue object, the current number of active
    // threads is less than the target number of threads, and the wait reason
    // of the current thread is not queue wait or the wait queue is not the
    // same queue as the insertion queue. If these conditions are satisfied,
    // then satisfy the thread wait and pass the thread the address of the
    // queue entry as the wait status. Otherwise, set the state of the queue
    // object to signaled and insert the specified entry in the queue object
    // entry list.
    //

    OldState = Queue->Header.SignalState;
    Thread = KeGetCurrentThread();
    WaitEntry = Queue->Header.WaitListHead.Blink;
    if ((WaitEntry != &Queue->Header.WaitListHead) &&
        (Queue->CurrentCount < Queue->MaximumCount) &&
        ((Thread->Queue != Queue) ||
        (Thread->WaitReason != WrQueue))) {

        //
        // Remove the last wait block from the wait list and get the address
        // of the waiting thread object.
        //

        RemoveEntryList(WaitEntry);
        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;

        //
        // Set the wait completion status, remove the thread from its wait
        // list, increment the number of active threads, and clear the wait
        // reason.
        //

        Thread->WaitStatus = (LONG_PTR)Entry;
        if (Thread->WaitListEntry.Flink != NULL) {
            RemoveEntryList(&Thread->WaitListEntry);
        }

        Queue->CurrentCount += 1;
        Thread->WaitReason = 0;

        //
        // If thread timer is still active, then cancel thread timer.
        //

        Timer = &Thread->Timer;
        if (Timer->Header.Inserted == TRUE) {
            KiRemoveTreeTimer(Timer);
        }

        //
        // Ready the thread for execution.
        //

        KiReadyThread(Thread);

    } else {
        Queue->Header.SignalState += 1;
        if (Head != FALSE) {
            InsertHeadList(&Queue->EntryListHead, Entry);

        } else {
            InsertTailList(&Queue->EntryListHead, Entry);
        }
    }

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\miscc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    miscc.c

Abstract:

    This module implements machine independent miscellaneous kernel functions.

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeAddSystemServiceTable)
#pragma alloc_text(PAGE, KeRemoveSystemServiceTable)
#pragma alloc_text(PAGE, KeQueryActiveProcessors)
#pragma alloc_text(PAGE, KeQueryLogicalProcessorInformation)

#if defined(_AMD64_)

#pragma alloc_text(PAGE, KeQueryMultiThreadProcessorSet)

#endif

#pragma alloc_text(PAGELK, KiCalibrateTimeAdjustment)

#if !defined(_AMD64_)

ULONGLONG
KeQueryInterruptTime (
    VOID
    )

/*++

Routine Description:

    This function returns the current interrupt time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{

    LARGE_INTEGER CurrentTime;

    KiQueryInterruptTime(&CurrentTime);
    return CurrentTime.QuadPart;
}

VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function returns the current system time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{

    KiQuerySystemTime(CurrentTime);
    return;
}

VOID
KeQueryTickCount (
    OUT PLARGE_INTEGER CurrentCount
    )

/*++

Routine Description:

    This function returns the current tick count by determining when the
    count is stable and then returning its value.

Arguments:

    CurrentCount - Supplies a pointer to a variable that will receive the
        current tick count.

Return Value:

    None.

--*/

{

    KiQueryTickCount(CurrentCount);
    return;
}

#endif

ULONG
KeQueryTimeIncrement (
    VOID
    )

/*++

Routine Description:

    This function returns the time increment value in 100ns units. This
    is the value that is added to the system time at each interval clock
    interrupt.

Arguments:

    None.

Return Value:

    The time increment value is returned as the function value.

--*/

{

    return KeMaximumIncrement;
}

VOID
KeSetDmaIoCoherency (
    IN ULONG Attributes
    )

/*++

Routine Description:

    This function sets (enables/disables) DMA I/O coherency with data
    caches.

Arguments:

    Attributes - Supplies the set of DMA I/O coherency attributes for
        the host system.

Return Value:

    None.

--*/

{

    KiDmaIoCoherency = Attributes;
    return;
}

#if defined(_AMD64_) || defined(_X86_)

#pragma alloc_text(INIT, KeSetProfileIrql)

VOID
KeSetProfileIrql (
    IN KIRQL ProfileIrql
    )

/*++

Routine Description:

    This function sets the profile IRQL.

    N.B. There are only two valid values for the profile IRQL which are
        PROFILE_LEVEL and HIGH_LEVEL.

Arguments:

    Irql - Supplies the synchronization IRQL value.

Return Value:

    None.

--*/

{

    ASSERT((ProfileIrql == PROFILE_LEVEL) || (ProfileIrql == HIGH_LEVEL));

    KiProfileIrql = ProfileIrql;
    return;
}

#endif

VOID
KeSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime,
    IN BOOLEAN AdjustInterruptTime,
    IN PLARGE_INTEGER HalTimeToSet OPTIONAL
    )

/*++

Routine Description:

    This function sets the system time to the specified value and updates
    timer queue entries to reflect the difference between the old system
    time and the new system time.

Arguments:

    NewTime - Supplies a pointer to a variable that specifies the new system
        time.

    OldTime - Supplies a pointer to a variable that will receive the previous
        system time.

    AdjustInterruptTime - If TRUE the amount of time being adjusted is
        also applied to InterruptTime and TickCount.

    HalTimeToSet - Supplies an optional time that if specified is to be used
        to set the time in the realtime clock.

Return Value:

    None.

--*/

{

    LIST_ENTRY AbsoluteListHead;
    LIST_ENTRY ExpiredListHead;
    ULONG Hand;
    ULONG Index;
    PLIST_ENTRY ListHead;
    PKSPIN_LOCK_QUEUE LockQueue;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql1;
    KIRQL OldIrql2;
    LARGE_INTEGER TimeDelta;
    TIME_FIELDS TimeFields;
    PKTIMER Timer;

    ASSERT((NewTime->HighPart & 0xf0000000) == 0);

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // If a realtime clock value is specified, then convert the time value
    // to time fields.
    //

    if (ARGUMENT_PRESENT(HalTimeToSet)) {
        RtlTimeToTimeFields(HalTimeToSet, &TimeFields);
    }

    //
    // Set affinity to the processor that keeps the system time, raise IRQL
    // to dispatcher level and lock the dispatcher database, then raise IRQL
    // to HIGH_LEVEL to synchronize with the clock interrupt routine.
    //

    KeSetSystemAffinityThread((KAFFINITY)1);
    KiLockDispatcherDatabase(&OldIrql1);
    KeRaiseIrql(HIGH_LEVEL, &OldIrql2);

    //
    // Save the previous system time, set the new system time, and set
    // the realtime clock, if a time value is specified.
    //

    KiQuerySystemTime(OldTime);

#if defined(_AMD64_)

    SharedUserData->SystemTime.High2Time = NewTime->HighPart;
    *((volatile ULONG64 *)&SharedUserData->SystemTime) = NewTime->QuadPart;

#else

    SharedUserData->SystemTime.High2Time = NewTime->HighPart;
    SharedUserData->SystemTime.LowPart   = NewTime->LowPart;
    SharedUserData->SystemTime.High1Time = NewTime->HighPart;

#endif

    if (ARGUMENT_PRESENT(HalTimeToSet)) {
        ExCmosClockIsSane = HalSetRealTimeClock(&TimeFields);
    }

    //
    // Compute the difference between the previous system time and the new
    // system time.
    //

    TimeDelta.QuadPart = NewTime->QuadPart - OldTime->QuadPart;

    //
    // Update the boot time to reflect the delta. This keeps time based
    // on boot time constant
    //

    KeBootTime.QuadPart = KeBootTime.QuadPart + TimeDelta.QuadPart;

    //
    // Track the overall bias applied to the boot time.
    //

    KeBootTimeBias = KeBootTimeBias + TimeDelta.QuadPart;

    //
    // Lower IRQL to dispatch level and if needed adjust the physical
    // system interrupt time.
    //

    KeLowerIrql(OldIrql2);
    if (AdjustInterruptTime != FALSE) {
        AdjustInterruptTime = KeAdjustInterruptTime(TimeDelta.QuadPart);
    }

    //
    // If the physical interrupt time of the system was not adjusted, then
    // recompute any absolute timers in the system for the new system time.
    //

    if (AdjustInterruptTime == FALSE) {

        //
        // Acquire the timer table lock, remove all absolute timers from the
        // timer queue so their due time can be recomputed, and release the
        // timer table lock.
        //

        InitializeListHead(&AbsoluteListHead);
        for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
            ListHead = &KiTimerTableListHead[Index].Entry;
            LockQueue = KiAcquireTimerTableLock(Index);
            NextEntry = ListHead->Flink;
            while (NextEntry != ListHead) {
                Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
                NextEntry = NextEntry->Flink;
                if (Timer->Header.Absolute != FALSE) {
                    KiRemoveEntryTimer(Timer);
                    InsertTailList(&AbsoluteListHead, &Timer->TimerListEntry);
                }
            }

            KiReleaseTimerTableLock(LockQueue);
        }

        //
        // Recompute the due time and reinsert all absolute timers in the timer
        // tree. If a timer has already expired, then insert the timer in the
        // expired timer list.
        //

        InitializeListHead(&ExpiredListHead);
        while (AbsoluteListHead.Flink != &AbsoluteListHead) {
            Timer = CONTAINING_RECORD(AbsoluteListHead.Flink, KTIMER, TimerListEntry);
            RemoveEntryList(&Timer->TimerListEntry);
            Timer->DueTime.QuadPart -= TimeDelta.QuadPart;
            Hand = KiComputeTimerTableIndex(Timer->DueTime.QuadPart);
            Timer->Header.Hand = (UCHAR)Hand;
            LockQueue = KiAcquireTimerTableLock(Hand);
            if (KiInsertTimerTable(Timer, Hand) == TRUE) {
                KiRemoveEntryTimer(Timer);
                InsertTailList(&ExpiredListHead, &Timer->TimerListEntry);
            }

            KiReleaseTimerTableLock(LockQueue);
        }

        //
        // If any of the attempts to reinsert a timer failed, then timers have
        // already expired and must be processed.
        //
        // N.B. The following function returns with the dispatcher database
        //      unlocked.
        //

        KiTimerListExpire(&ExpiredListHead, OldIrql1);

    } else {
        KiUnlockDispatcherDatabase(OldIrql1);
    }

    //
    // Set affinity back to its original value.
    //

    KeRevertToUserAffinityThread();
    return;
}

BOOLEAN
KeAdjustInterruptTime (
    IN LONGLONG TimeDelta
    )

/*++

Routine Description:

    This function moves the physical interrupt time of the system forward by
    the specified time delta after a system wake has occurred.

Arguments:

    TimeDelta - Supplies the time delta to be added to the interrupt time, tick
        count and the performance counter in 100ns units.

Return Value:

    None.

--*/

{

    ADJUST_INTERRUPT_TIME_CONTEXT Adjust;

    //
    // Time can only be moved forward.
    //

    if (TimeDelta < 0) {
        return FALSE;

    } else {
        Adjust.KiNumber = KeNumberProcessors;
        Adjust.HalNumber = KeNumberProcessors;
        Adjust.Adjustment = (ULONGLONG) TimeDelta;
        Adjust.Barrier = 1;
        KeIpiGenericCall((PKIPI_BROADCAST_WORKER)KiCalibrateTimeAdjustment,
                         (ULONG_PTR)(&Adjust));

        return TRUE;
    }
}

VOID
KiCalibrateTimeAdjustment (
    PADJUST_INTERRUPT_TIME_CONTEXT Adjust
    )

/*++

Routine Description:

    This function calibrates the adjustment of time on all processors.

Arguments:

    Adjust - Supplies the operation context.

Return Value:

    None.

--*/

{

    ULONG cl;
    ULONG divisor;
    BOOLEAN Enable;
    LARGE_INTEGER InterruptTime;
    ULARGE_INTEGER li;
    PERFINFO_PO_CALIBRATED_PERFCOUNTER LogEntry;
    LARGE_INTEGER NewTickCount;
    ULONG NewTickOffset;
    LARGE_INTEGER PerfCount;
    LARGE_INTEGER PerfFreq;
    LARGE_INTEGER SetTime;

    //
    // As each processor arrives, decrement the remaining processor count. If
    // this is the last processor to arrive, then compute the time change, and
    // signal all processor when to apply the performance counter change.
    //

    if (InterlockedDecrement((PLONG)&Adjust->KiNumber)) {
        Enable = KeDisableInterrupts();

        //
        // It is possible to deadlock if one or more of the other processors
        // receives and processes a freeze request while this processor has
        // interrupts disabled. Poll for a freeze request until all processors
        // are known to be in this code.
        //

        do {
            KiPollFreezeExecution();
        } while (Adjust->KiNumber != (ULONG)-1);

        //
        // Wait to perform the time set.
        //

        while (Adjust->Barrier);

    } else {

        //
        // Set timer expiration dpc to scan the timer queues once for any
        // expired timers.
        //

        KeRemoveQueueDpc(&KiTimerExpireDpc);
        KeInsertQueueDpc(&KiTimerExpireDpc,
                         ULongToPtr(KiQueryLowTickCount() - TIMER_TABLE_SIZE),
                         NULL);

        //
        // Disable interrupts and indicate that this processor is now
        // in final portion of this code.
        //

        Enable = KeDisableInterrupts();
        InterlockedDecrement((PLONG) &Adjust->KiNumber);

        //
        // Adjust Interrupt Time.
        //

        InterruptTime.QuadPart = KeQueryInterruptTime() + Adjust->Adjustment;
        SetTime.QuadPart = Adjust->Adjustment;

        //
        // Get the current times
        //

        PerfCount = KeQueryPerformanceCounter(&PerfFreq);

        //
        // Compute performance counter for current time.
        //
        // Multiply SetTime * PerfCount and obtain 96-bit result in cl,
        // li.LowPart, li.HighPart.  Then divide the 96-bit result by
        // 10,000,000 to get new performance counter value.
        //

        li.QuadPart = RtlEnlargedUnsignedMultiply((ULONG)SetTime.LowPart,
                                                  (ULONG)PerfFreq.LowPart).QuadPart;

        cl = li.LowPart;
        li.QuadPart =
            li.HighPart + RtlEnlargedUnsignedMultiply((ULONG)SetTime.LowPart,
                                                      (ULONG)PerfFreq.HighPart).QuadPart;

        li.QuadPart =
            li.QuadPart + RtlEnlargedUnsignedMultiply((ULONG)SetTime.HighPart,
                                                      (ULONG)PerfFreq.LowPart).QuadPart;

        li.HighPart = li.HighPart + SetTime.HighPart * PerfFreq.HighPart;
        divisor = 10000000;
        Adjust->NewCount.HighPart = RtlEnlargedUnsignedDivide(li,
                                                              divisor,
                                                              &li.HighPart);

        li.LowPart = cl;
        Adjust->NewCount.LowPart = RtlEnlargedUnsignedDivide(li,
                                                             divisor,
                                                             NULL);

        Adjust->NewCount.QuadPart += PerfCount.QuadPart;

        //
        // Compute tick count and tick offset for current interrupt time.
        //

        NewTickCount = RtlExtendedLargeIntegerDivide(InterruptTime,
                                                     KeMaximumIncrement,
                                                     &NewTickOffset);

        //
        // Apply changes to interrupt time, tick count, tick offset, and the
        // performance counter.
        //

        KiTickOffset = KeMaximumIncrement - NewTickOffset;
        KeInterruptTimeBias += Adjust->Adjustment;
        SharedUserData->TickCount.High2Time = NewTickCount.HighPart;

#if defined(_WIN64)

        SharedUserData->TickCountQuad = NewTickCount.QuadPart;

#else

        SharedUserData->TickCount.LowPart   = NewTickCount.LowPart;
        SharedUserData->TickCount.High1Time = NewTickCount.HighPart;

#endif

        //
        // N.B. There is no global tick count variable on AMD64.
        //

#if defined(_X86_)

        KeTickCount.High2Time = NewTickCount.HighPart;
        KeTickCount.LowPart   = NewTickCount.LowPart;
        KeTickCount.High1Time = NewTickCount.HighPart;

#endif

#if defined(_AMD64_)

        SharedUserData->InterruptTime.High2Time = InterruptTime.HighPart;
        *((volatile ULONG64 *)&SharedUserData->InterruptTime) = InterruptTime.QuadPart;

#else

        SharedUserData->InterruptTime.High2Time = InterruptTime.HighPart;
        SharedUserData->InterruptTime.LowPart   = InterruptTime.LowPart;
        SharedUserData->InterruptTime.High1Time = InterruptTime.HighPart;

#endif

        //
        // Apply the performance counter change.
        //

        Adjust->Barrier = 0;
    }

    KeGetCurrentPrcb()->TickOffset = KiTickOffset;

#if defined(_AMD64_)

    KeGetCurrentPrcb()->MasterOffset = KiTickOffset;

#endif

    HalCalibratePerformanceCounter((LONG volatile *)&Adjust->HalNumber,
                                   (ULONGLONG)Adjust->NewCount.QuadPart);

    //
    // Log an event that the performance counter has been calibrated
    // properly and indicate the new performance counter value.
    //

    if (PERFINFO_IS_GROUP_ON(PERF_POWER)) {
        LogEntry.PerformanceCounter = KeQueryPerformanceCounter(NULL);
        PerfInfoLogBytes(PERFINFO_LOG_TYPE_PO_CALIBRATED_PERFCOUNTER,
                         &LogEntry,
                         sizeof(LogEntry));
    }

    KeEnableInterrupts(Enable);
    return;
}

VOID
KeSetTimeIncrement (
    IN ULONG MaximumIncrement,
    IN ULONG MinimumIncrement
    )

/*++

Routine Description:

    This function sets the time increment value in 100ns units. This
    value is added to the system time at each interval clock interrupt.

Arguments:

    MaximumIncrement - Supplies the maximum time between clock interrupts
        in 100ns units supported by the host HAL.

    MinimumIncrement - Supplies the minimum time between clock interrupts
        in 100ns units supported by the host HAL.

Return Value:

    None.

--*/

{

    KeMaximumIncrement = MaximumIncrement;
    KeMinimumIncrement = max(MinimumIncrement, 10 * 1000);
    KeTimeAdjustment = MaximumIncrement;
    KeTimeIncrement = MaximumIncrement;
    KiTickOffset = MaximumIncrement;

#if defined(_AMD64_)

    KiProcessorBlock[0]->MasterOffset = MaximumIncrement;

#endif

    return;
}

BOOLEAN
KeAddSystemServiceTable (
    IN PULONG_PTR Base,
    IN PULONG Count OPTIONAL,
    IN ULONG Limit,
    IN PUCHAR Number,
    IN ULONG Index
    )

/*++

Routine Description:

    This function adds the specified system service table to the system.

Arguments:

    Base - Supplies the address of the system service table dispatch table.

    Count - Supplies an optional pointer to a table of per system service
        counters.

    Limit - Supplies the limit of the service table. Services greater
        than or equal to this limit will fail.

    Arguments - Supplies the address of the argument count table.

    Index - Supplies index of the service table.

Return Value:

    TRUE - The operation was successful.

    FALSE - the operation failed. A service table is already bound to
        the specified location, or the specified index is larger than
        the maximum allowed index.

--*/

{

    PAGED_CODE();

    //
    // If a system service table is already defined for the specified
    // index, then return FALSE. Otherwise, establish the new system
    // service table.
    //

    if ((Index > NUMBER_SERVICE_TABLES - 1) ||
        (KeServiceDescriptorTable[Index].Base != NULL) ||
        (KeServiceDescriptorTableShadow[Index].Base != NULL)) {

        return FALSE;

    } else {

        //
        // If the service table index is equal to the Win32 table, then
        // only update the shadow system service table. Otherwise, both
        // the shadow and static system service tables are updated.
        //

        KeServiceDescriptorTableShadow[Index].Base = Base;
        KeServiceDescriptorTableShadow[Index].Count = Count;
        KeServiceDescriptorTableShadow[Index].Limit = Limit;
        KeServiceDescriptorTableShadow[Index].Number = Number;
        if (Index != WIN32K_SERVICE_INDEX) {
            KeServiceDescriptorTable[Index].Base = Base;
            KeServiceDescriptorTable[Index].Count = Count;
            KeServiceDescriptorTable[Index].Limit = Limit;
            KeServiceDescriptorTable[Index].Number = Number;
        }

        return TRUE;
    }
}

BOOLEAN
KeRemoveSystemServiceTable (
    IN ULONG Index
    )

/*++

Routine Description:

    This function removes a system service table from the system.

Arguments:

    Index - Supplies index of the service table.

Return Value:

    TRUE - The operation was successful.

    FALSE - the operation failed. A service table is is not bound or is illegal to remove

--*/

{

    PAGED_CODE();

    if ((Index > NUMBER_SERVICE_TABLES - 1) ||
        ((KeServiceDescriptorTable[Index].Base == NULL) &&
         (KeServiceDescriptorTableShadow[Index].Base == NULL))) {

        return FALSE;

    } else {
        KeServiceDescriptorTableShadow[Index].Base = NULL;
        KeServiceDescriptorTableShadow[Index].Count = 0;
        KeServiceDescriptorTableShadow[Index].Limit = 0;
        KeServiceDescriptorTableShadow[Index].Number = 0;
        if (Index != WIN32K_SERVICE_INDEX) {
            KeServiceDescriptorTable[Index].Base = NULL;
            KeServiceDescriptorTable[Index].Count = 0;
            KeServiceDescriptorTable[Index].Limit = 0;
            KeServiceDescriptorTable[Index].Number = 0;
        }

        return TRUE;
    }
}

KAFFINITY
KeQueryActiveProcessors (
    VOID
    )

/*++

Routine Description:

    This function returns the current set of active processors in the system.

Arguments:

    None.

Return Value:

    The set of active processors is returned as the function value.

--*/

{

    PAGED_CODE();

    return KeActiveProcessors;
}

NTSTATUS
KeQueryLogicalProcessorInformation (
    OUT PVOID SystemInformation,
    IN ULONG SystemInformationLength,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This function returns information about the physical processors and nodes
    in the host system.

    Information is returned for each physical processor in the host system
    that describes any associated logical processors if present.

    Information is returned for each node in the host system that describes
    the processors associated with the node.

    N.B. It assumed that specified buffer is either accessible or access
         is protected by an outer try/except block.

Arguments:

    SystemInformation - Supplies a pointer to a buffer which receives the
        specified information.

    SystemInformationLength - Supplies the length of the output buffer in
        bytes.

    ReturnLength - Supples a pointer to a variable which receives the number
        of bytes necessary to return all of the information records available.

Return Value:

    NTSTATUS

--*/

{

    KAFFINITY ActiveProcessors;
    ULONG CurrentLength;
    UCHAR Flags;
    ULONG Index;
    ULONG Level;
    KAFFINITY Mask;

#if defined(KE_MULTINODE)

    PKNODE Node;

#endif

    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Output;
    PKPRCB Prcb;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Add a record for each physical processor in the host system.
    //

    CurrentLength = 0;
    Output = SystemInformation;
    ActiveProcessors = KeActiveProcessors;
    Index = (ULONG)(-1);
    do {
        Flags = 0;
        Index += 1;
        Prcb = KiProcessorBlock[Index];
        if ((ActiveProcessors & 1) != 0) {
    
            //
            // Skip logical processors that are not the master of their thread
            // set.
            //

#if defined(NT_SMT)

            if (Prcb != Prcb->MultiThreadSetMaster) {
                continue;
            }
    
            //
            // If this physical processor has more than one logical processor,
            // then mark it as an SMT relationship.
            //

            Mask = Prcb->MultiThreadProcessorSet;
            if (Prcb->SetMember != Mask) {
                Flags = LTP_PC_SMT;
            }

#else

            Mask = Prcb->SetMember;

#endif

            CurrentLength += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
            if (CurrentLength <= SystemInformationLength) {
                Output->ProcessorMask = Mask;
                Output->Relationship = RelationProcessorCore;
                Output->Reserved[0] = Output->Reserved[1] = 0;
                Output->ProcessorCore.Flags = Flags;
                Output += 1;
    
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            
            //
            // Add a record for each cache level associated with the physical
            // processor.
            //
    
#if defined(_AMD64_)

            for (Level = 0; Level < Prcb->CacheCount; Level += 1) {
                CurrentLength += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
                if (CurrentLength <= SystemInformationLength) {
                    Output->ProcessorMask = Mask;
                    Output->Relationship = RelationCache;
                    Output->Reserved[0] = Output->Reserved[1] = 0;
                    Output->Cache = Prcb->Cache[Level];
                    Output += 1;
    
                } else {
                    Status = STATUS_INFO_LENGTH_MISMATCH;
                }
           }

#else

            Level = 0;

#endif

        }

    } while((ActiveProcessors >>= 1) != 0);

    //
    // Add a record for each node in the host system.
    //

    Index = 0;
    do {

#if defined(KE_MULTINODE)

        Node = KeNodeBlock[Index];
        if (Node->ProcessorMask == 0) {
            Index += 1;
            continue;
        }

        Mask = Node->ProcessorMask;

#else

        Mask = KeActiveProcessors;

#endif

        CurrentLength += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);
        if (CurrentLength <= SystemInformationLength) {
            Output->ProcessorMask = Mask;
            Output->Relationship = RelationNumaNode;
            Output->Reserved[0] = Output->Reserved[1] = 0;
            Output->NumaNode.NodeNumber = Index;
            Output += 1;
    
        } else {
            Status = STATUS_INFO_LENGTH_MISMATCH;
        }

        Index += 1;
    } while (Index < KeNumberNodes);

    // 
    // Return the length of the buffer required to hold the entire set of
    // information.
    //

    *ReturnedLength = CurrentLength;
    return Status;
}

#if defined(_AMD64_)

KAFFINITY
KeQueryMultiThreadProcessorSet (
    ULONG Number
    )

/*++

Routine Description:

    This function queries the master multithread set for the specified
    processor.

Arguments:

    Number - Supplies the number of the processor to query.

Return Value:

    The master multithread set is returned as the function value.

--*/

{

    PKPRCB Prcb;

    //
    // Query the specified multithread processor set.
    //

    Prcb = KiProcessorBlock[Number];
    Prcb = Prcb->MultiThreadSetMaster;
    return Prcb->MultiThreadProcessorSet;
}

#endif

#undef KeIsAttachedProcess

BOOLEAN
KeIsAttachedProcess (
    VOID
    )

/*++

Routine Description:

    This function determines if the current thread is attached to a process.

Arguments:

    None.

Return Value:

    TRUE is returned if the current thread is attached to a process. Otherwise,
    FALSE is returned.

--*/

{
    return KiIsAttachedProcess() ? TRUE : FALSE;
}

ULONG
KeGetRecommendedSharedDataAlignment (
    VOID
    )

/*++

Routine Description:

    This function returns the size of the largest cache line in the system.
    This value should be used as a recommended alignment / granularity for
    shared data.

Arguments:

    None.

Return Value:

    The size of the largest cache line in the system is returned as the
    function value.

--*/

{
    return KeLargestCacheLine;
}

PKPRCB
KeGetPrcb (
    ULONG ProcessorNumber
    )

/*++

Routine Description:

    This function returns the address of the Processor Control Block (PRCB)
    for the specified processor.

Arguments:

    ProcessorNumber - Supplies the number of the processor the PRCB
    is to be returned for.

Return Value:

    Returns the address of the requested PRCB or NULL if ProcessorNumber
    is not valid.

--*/

{

    ASSERT(ProcessorNumber < MAXIMUM_PROCESSORS);

    if (ProcessorNumber < (ULONG)KeNumberProcessors) {
        return KiProcessorBlock[ProcessorNumber];
    }

    return NULL;
}

typedef struct _KNMI_HANDLER_CALLBACK {
    struct _KNMI_HANDLER_CALLBACK * Next;
    PNMI_CALLBACK Callback;
    PVOID Context;
    PVOID Handle;
} KNMI_HANDLER_CALLBACK, *PKNMI_HANDLER_CALLBACK;

PKNMI_HANDLER_CALLBACK KiNmiCallbackListHead;
KSPIN_LOCK KiNmiCallbackListLock;

BOOLEAN
KiHandleNmi (
    VOID
    )

/*++

Routine Description:

    This routine is called to process the list of registered Non-Maskable-
    Interrupt (NMI) handlers in the system.  This routine is called from
    the NMI interrupt vector, the IRQL is unknown and must be treated as
    if at HIGH_LEVEL.   Neither this function or any called function can
    alter system IRQL.

    The list of handlers must be edited in such a way that it is always
    valid.   This routine cannot acquire a lock before transiting the list.

Arguments:

    None.

Return Value:

    Returns TRUE is any handler on the list claims to have handled the
    interrupt, FALSE otherwise.

--*/

{

    BOOLEAN Handled;
    PKNMI_HANDLER_CALLBACK Handler;

    Handler = KiNmiCallbackListHead;
    Handled = FALSE;
    while (Handler != NULL) {
        Handled |= Handler->Callback(Handler->Context, Handled);
        Handler = Handler->Next;
    }

    return Handled;
}

PVOID
KeRegisterNmiCallback (
    __in PNMI_CALLBACK CallbackRoutine,
    __in_opt PVOID Context
    )

/*++

Routine Description:

    This routine is called to add a callback to the list of Non-Maskable-
    Interrupt (NMI) handlers.

    This routine must be called at IRQL < DISPATCH_LEVEL.

    List insertion must be such that the list is ALWAYS valid, an NMI
    could occur during insertion and the NMI handler must be able to
    safely transit the list.

Arguments:

    CallbackRoutine supplies a pointer to the routine to be called on NMI.
    Context         supplies an arbitary value which will be passed
                    to the CallbackRoutine.

Return Value:

    Returns an arbitary handle that must be passed to KeDeregisterNmiCallback
    or NULL if registration was unsuccessful.

--*/

{

    PKNMI_HANDLER_CALLBACK Handler;
    PKNMI_HANDLER_CALLBACK Next;
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Allocate memory for the callback object.
    //

    Handler = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(KNMI_HANDLER_CALLBACK),
                                    'IMNK');

    if (Handler == NULL) {
        return Handler;
    }

    //
    // Fill in the non-protected elements.
    //

    Handler->Callback = CallbackRoutine;
    Handler->Context = Context;
    Handler->Handle = Handler;

    //
    // Insert the handler onto the front of the list.
    //

    KeAcquireSpinLock(&KiNmiCallbackListLock, &OldIrql);
    Handler->Next = KiNmiCallbackListHead;

    //
    // Because the lock is held, the following can't fail but is needed
    // to ensure the compiler doesn't store KiNmiCallbackList before
    // storing Handler->Next because the NMI handler may run down this
    // list and does not (can not) take the lock.
    //

    Next = InterlockedCompareExchangePointer(&KiNmiCallbackListHead,
                                             Handler,
                                             Handler->Next);

    ASSERT(Next == Handler->Next);

    KeReleaseSpinLock(&KiNmiCallbackListLock, OldIrql);

    //
    // Return the address of this handler as an opaque handle.
    //

    return Handler->Handle;
}

NTSTATUS
KeDeregisterNmiCallback (
    __in PVOID Handle
    )

/*++

Routine Description:

    This routine is called to remove a callback from the list of Non-
    Maskable-Interrupt callbacks.

    This routine must be called at IRQL < DISPATCH_LEVEL.

    List removal must be such that the list is ALWAYS valid, an NMI
    could occur during removal and the NMI handler must be able to
    safely transit the list.

Arguments:

    Handle  supplied an opaque handle to the callback object that was
            returned by KeRegisterNmiCallback.

Return Value:

    Returns STATUS_SUCCESS if the object was successfully removed from
    the list.   STATUS_INVALID_HANDLE otherwise.

--*/

{

    PKNMI_HANDLER_CALLBACK Handler;
    PKNMI_HANDLER_CALLBACK *PreviousNext;
    KIRQL OldIrql;

#if !defined(NT_UP)

    KAFFINITY ActiveProcessors;
    KAFFINITY CurrentAffinity;

#endif


    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    KeAcquireSpinLock(&KiNmiCallbackListLock, &OldIrql);


    //
    // Find the handler given the list of handlers.
    //
    // N.B. In the current implementation, the handle is the address
    // of the handler however this code is designed for a more opaque
    // handle.
    //

    PreviousNext = &KiNmiCallbackListHead;
    for (Handler = *PreviousNext;
         Handler;
         PreviousNext = &Handler->Next, Handler = Handler->Next) {

        if (Handler->Handle == Handle) {
            ASSERT(Handle == Handler);
            break;
        }
    }

    if ((Handler == NULL) || (Handler->Handle != Handle)) {
        KeReleaseSpinLock(&KiNmiCallbackListLock, OldIrql);
        return STATUS_INVALID_HANDLE;
    }

    //
    // Remove this handler from the list.
    //

    *PreviousNext = Handler->Next;
    KeReleaseSpinLock(&KiNmiCallbackListLock, OldIrql);

    //
    // Cycle through each processor in the system to ensure that any
    // NMI which has begun execution on another processor has completed
    // execution before releasing the memory for the NMI callback object.
    //

#if !defined(NT_UP)

    ActiveProcessors = KeActiveProcessors;
    for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {
        if (ActiveProcessors & CurrentAffinity) {
            ActiveProcessors &= ~CurrentAffinity;
            KeSetSystemAffinityThread(CurrentAffinity);
        }
    }

    KeRevertToUserAffinityThread();

#endif

    ExFreePoolWithTag(Handler, 'IMNK');
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\raisexcp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    raisexcp.c

Abstract:

    This module implements the internal kernel code to continue execution
    and raise a exception.

--*/

#include "ki.h"

#if !defined(_AMD64_)

DECLSPEC_NOINLINE
VOID
KiContinuePreviousModeUser (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to copy the specified context record when the
    previous mode is user. Its only purpose is to save stack space in the
    caller. 

    N.B. This routine assumes that the caller has protected access to the
       specified context record.

Arguments:

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord2;

    //
    // Probe and copy the context record to a stack local context record.
    //

    ProbeForReadSmallStructure(ContextRecord, sizeof(CONTEXT), CONTEXT_ALIGN);
    RtlCopyMemory(&ContextRecord2, ContextRecord, sizeof(CONTEXT));

    //
    // Move information from the context record to the exception and trap
    // frames.
    //

    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &ContextRecord2,
                       ContextRecord2.ContextFlags,
                       UserMode);

    return;
}

NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to copy the specified context frame to the
    specified exception and trap frames for the continue system service.

Arguments:

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if the context record is not readable
        from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the context record is not
        properly aligned.

    STATUS_SUCCESS is returned if the context frame is copied successfully
        to the specified exception and trap frames.

--*/

{

    KIRQL OldIrql;
    NTSTATUS Status;

    //
    // Synchronize with other context operations.
    //
    // If the current IRQL is less than APC_LEVEL, then raise IRQL to APC level.
    // 

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < APC_LEVEL) {
        KfRaiseIrql(APC_LEVEL);
    }

    //
    // If the previous mode was not kernel mode, then use wrapper function
    // to copy context to kernel frames. Otherwise, copy context to kernel
    // frames directly.
    // 
      
    Status = STATUS_SUCCESS;
    if (KeGetPreviousMode() != KernelMode) {
        try {
            KiContinuePreviousModeUser(ContextRecord,
                                       ExceptionFrame,
                                       TrapFrame);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

    } else {
        KeContextToKframes(TrapFrame,
                           ExceptionFrame,
                           ContextRecord,
                           ContextRecord->ContextFlags,
                           KernelMode);
    }

    //
    // If the old IRQL was less than APC level, then lower the IRQL to its
    // previous value.
    //

    if (OldIrql < APC_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    return Status;
}

#endif

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to raise an exception. The exception can be
    raised as a first or second chance exception.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if either the exception or the context
        record is not readable from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the exception record or the
        context record are not properly aligned.

    STATUS_INVALID_PARAMETER is returned if the number of exception parameters
        is greater than the maximum allowable number of exception parameters.

    STATUS_SUCCESS is returned if the exception is dispatched and handled.

--*/

{

    CONTEXT ContextRecord2;
    EXCEPTION_RECORD ExceptionRecord2;
    ULONG Length;
    ULONG Parameters;
    KPROCESSOR_MODE PreviousMode;

    //
    // Get the previous processor mode and probe the specified exception and
    // context records if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    if (PreviousMode != KernelMode) {
        try {
            ProbeForReadSmallStructure(ContextRecord,
                                       sizeof(CONTEXT),
                                       sizeof(UCHAR));
    
            Parameters = ProbeAndReadUlong(&ExceptionRecord->NumberParameters);
            if (Parameters > EXCEPTION_MAXIMUM_PARAMETERS) {
                return STATUS_INVALID_PARAMETER;
            }
    
            //
            // The exception record structure is defined unlike others with
            // trailing information as being its maximum size rather than
            // just a single trailing element.
            //
    
            Length = FIELD_OFFSET(EXCEPTION_RECORD, ExceptionInformation[Parameters]);

            __assume(Length != 0);

            ProbeForRead(ExceptionRecord, Length, sizeof(UCHAR));
    
            //
            // Copy the exception and context record to local storage so an
            // access violation cannot occur during exception dispatching.
            //
    
            RtlCopyMemory(&ContextRecord2, ContextRecord, sizeof(CONTEXT));
            RtlCopyMemory(&ExceptionRecord2, ExceptionRecord, Length);
            ContextRecord = &ContextRecord2;
            ExceptionRecord = &ExceptionRecord2;
    
            //
            // Make sure the number of parameter is correct in the copied
            // exception record.
            //
    
            ExceptionRecord->NumberParameters = Parameters;
    
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    //
    // Move information from the context record to the exception and trap
    // frames.
    //

    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       ContextRecord,
                       ContextRecord->ContextFlags,
                       PreviousMode);

    //
    // Make sure the reserved bit is clear in the exception code and
    // perform exception dispatching.
    //
    // N.B. The reserved bit is used to differentiate internally generated
    //      codes from codes generated by application programs.
    //

    ExceptionRecord->ExceptionCode &= ~KI_EXCEPTION_INTERNAL;
    KiDispatchException(ExceptionRecord,
                        ExceptionFrame,
                        TrapFrame,
                        PreviousMode,
                        FirstChance);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\thkemul.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    thkemul.c

Abstract:

    This module implements machine independent functions involved with
    emulating known code sequences in NX regions.

--*/

#include "ki.h"

LOGICAL
KiEmulateAtlThunk (
    IN OUT ULONG *InstructionPointer,
    IN OUT ULONG *StackPointer,
    IN OUT ULONG *Eax,
    IN OUT ULONG *Ecx,
    IN OUT ULONG *Edx
    )

/*++

Routine Description:

    This routine is called to determine whether the 32-bit X86 IStream
    contains a recognized ATL thunk sequence and if so, performs
    the emulation.

Arguments:

    InstructionPointer - Supplies a pointer to the value of the 32-bit
        instruction pointer at the time of the fault.

    StackPointer - Supplies a pointer to the value of the 32-bit stack
        pointer at the time of the fault.

    Ecx - Supplies a pointer to the value of ecx at the time of the fault.

    Edx - Supplies a pointer to the value of edx at the time of the fault.

Return Value:

    Returns TRUE if an ATL thunk was recognized and emulated, FALSE if not.


    It is up to the caller to first ensure:

    - The fault occured while executing 32-bit code
    - The fault occured as a result of attempting to execute NX code

--*/

{
    LONG branchTarget;
    LONG imm32;
    PVOID rip;
    PUCHAR rsp;
    BOOLEAN safeThunkCall;
    BOOLEAN *safeThunkCallPtr;
    LOGICAL validThunk;

    //
    // Three types of ATL thunks of interest
    //

    #pragma pack(1)

    struct {
        LONG Mov;           // 0x042444C7   mov [esp+4], imm32
        LONG MovImmediate;
        UCHAR Jmp;          // 0xe9         jmp imm32
        LONG JmpImmediate;
    } *thunk1;

    struct {
        UCHAR Mov;          // 0xb9         mov ecx, imm32
        LONG EcxImmediate;
        UCHAR Jmp;          // 0xe9         jmp imm32
        LONG JmpImmediate;
    } *thunk2;

    struct {
        UCHAR MovEdx;       // 0xba         mov edx, imm32
        LONG EdxImmediate;
        UCHAR MovEcx;       // 0xb9         mov ecx, imm32
        LONG EcxImmediate;
        USHORT JmpEcx;      // 0xe1ff       jmp ecx
    } *thunk3;

    struct {
        UCHAR MovEcx;       // 0xb9         mov ecx, imm32
        LONG EcxImmediate;
        UCHAR MovEax;       // 0xb8         mov eax, imm32
        LONG EaxImmediate;
        USHORT JmpEax;      // 0xe0ff       jmp eax
    } *thunk4;

    struct {
        UCHAR PopEcx;       // 0x59
        UCHAR PopEax;       // 0x58
        UCHAR PushEcx;      // 0x51
        UCHAR Jmp[3];       // 0xFF 0x60 0x04   jmp [eax+4]
    } *thunk7;

    #pragma pack()

    rip = UlongToPtr(*InstructionPointer);
    rsp = UlongToPtr(*StackPointer);

    thunk1 = rip;
    thunk2 = rip;
    thunk3 = rip;
    thunk4 = rip;
    thunk7 = rip;

    validThunk = FALSE;

    //
    // If thunk emulation is disabled, then do not attempt to emulate any
    // thunks.
    //

    if (KiQueryNxThunkEmulationState() != 0) {
        return FALSE;
    }

    //
    // Carefully examine the instruction stream.  If it matches a known
    // ATL thunk template, then emulate it.
    //

    try {
        ProbeAndReadUchar((PUCHAR)rip);

#if defined(_WIN64)
        safeThunkCallPtr = &NtCurrentTeb32()->SafeThunkCall;
#else
        safeThunkCallPtr = &NtCurrentTeb()->SafeThunkCall;
#endif

        safeThunkCall = *safeThunkCallPtr;
        if (safeThunkCall != FALSE) {
            *safeThunkCallPtr = FALSE;
        }

        if ((thunk1->Mov == 0x042444C7) && (thunk1->Jmp == 0xe9)) {

            //
            // Type 1 thunk.
            //

            //
            // emulate: jmp imm32
            //

            imm32 = thunk1->JmpImmediate +
                    PtrToUlong(rip) +
                    sizeof(*thunk1);

            //
            // Determine if it is safe to emulate this code stream.
            //

            if ((MmCheckForSafeExecution (rip,
                                          rsp,
                                          UlongToPtr (imm32),
                                          TRUE) == FALSE) ||
                (safeThunkCall == FALSE)) {
                goto Done;
            }
            
            //
            // emulate: mov [esp+4], imm32
            // 

            ProbeAndWriteUlong((PULONG)(rsp+4), thunk1->MovImmediate);
            *InstructionPointer = imm32;
            validThunk = TRUE;

        } else if ((thunk2->Mov == 0xb9) && (thunk2->Jmp == 0xe9)) {

            //
            // Type 2 thunk.
            //

            //
            // emulate: jmp imm32
            //

            imm32 = thunk2->JmpImmediate +
                    PtrToUlong(rip) +
                    sizeof(*thunk2);

            //
            // Determine if it is safe to emulate this code stream.
            //

            if ((MmCheckForSafeExecution (rip,
                                          rsp,
                                          UlongToPtr (imm32),
                                          TRUE) == FALSE) ||
                (safeThunkCall == FALSE)) {
                goto Done;
            }

            //
            // emulate: mov ecx, imm32
            //

            *Ecx = thunk2->EcxImmediate;


            *InstructionPointer = imm32;
            validThunk = TRUE;

        } else if ((thunk3->MovEdx == 0xba) &&
                   (thunk3->MovEcx == 0xb9) &&
                   (thunk3->JmpEcx == 0xe1ff)) {

            //
            // Type 3 thunk.
            //

            //
            // emulate: mov ecx, imm32
            //

            imm32 = thunk3->EcxImmediate;

            //
            // Determine if it is safe to emulate this code stream.
            //

            if (MmCheckForSafeExecution (rip,
                                         rsp,
                                         UlongToPtr (imm32),
                                         FALSE) == FALSE) {
                goto Done;
            }

            //
            // emulate: mov edx, imm32
            //

            *Edx = thunk3->EdxImmediate;

            *Ecx = imm32;

            //
            // emulate: jmp ecx
            //

            *InstructionPointer = imm32;
            validThunk = TRUE;

        } else if ((thunk4->MovEcx == 0xb9) &&
                   (thunk4->MovEax == 0xb8) &&
                   (thunk4->JmpEax == 0xe0ff)) {

            //
            // Type 4 thunk
            //
            
            //
            // emulate: mov eax, imm32
            //

            imm32 = thunk4->EaxImmediate;

            //
            // Determine if it is safe to emulate this code stream.
            //

            if ((MmCheckForSafeExecution (rip,
                                          rsp,
                                          UlongToPtr (imm32),
                                          TRUE) == FALSE) ||
                (safeThunkCall == FALSE)) {
                goto Done;
            }

            //
            // emulate: mov ecx, imm32
            //

            *Ecx = thunk4->EcxImmediate;

            *Eax = imm32;

            //
            // emulate: jmp eax
            //

            *InstructionPointer = imm32;
            validThunk = TRUE;

        } else if (thunk7->PopEcx == 0x59 &&
                   thunk7->PopEax == 0x58 &&
                   thunk7->PushEcx == 0x51 &&
                   thunk7->Jmp[0] == 0xFF &&
                   thunk7->Jmp[1] == 0x60 &&
                   thunk7->Jmp[2] == 0x04) {

            //
            // Type 7 thunk
            //
            // This is used by VB6
            //

            //
            // First determine and validate the branch target
            //

            imm32 = ProbeAndReadUlong((PULONG)(rsp+4));
            branchTarget = ProbeAndReadUlong((PULONG)(UlongToPtr(imm32+4)));

            //
            // Determine if it is safe to emulate this code stream.
            //

            if (MmCheckForSafeExecution(rip,
                                        rsp,
                                        UlongToPtr(branchTarget),
                                        FALSE) == FALSE) {
                goto Done;
            }

            //
            // Emulate: pop ecx
            //

            *Ecx = *(PULONG)rsp;
            rsp += 4;

            //
            // Emulate: pop eax
            //          push ecx
            //

            *Eax = *(PULONG)rsp;
            *(PULONG)rsp = *Ecx;

            //
            // Emulate: jmp [eax+4]
            //

            *InstructionPointer = branchTarget;
            *StackPointer = PtrToUlong(rsp);
            validThunk = TRUE;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

Done:
    return validThunk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\semphobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    semphobj.c

Abstract:

    This module implements the kernel semaphore object. Functions
    are provided to initialize, read, and release semaphore objects.

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input semaphore is
// really a ksemaphore and not something else, like deallocated pool.
//

#define ASSERT_SEMAPHORE(E) {                    \
    ASSERT((E)->Header.Type == SemaphoreObject); \
}

VOID
KeInitializeSemaphore (
    __out PRKSEMAPHORE Semaphore,
    __in LONG Count,
    __in LONG Limit
    )

/*++

Routine Description:

    This function initializes a kernel semaphore object. The initial
    count and limit of the object are set to the specified values.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Count - Supplies the initial count value to be assigned to the
        semaphore.

    Limit - Supplies the maximum count value that the semaphore
        can attain.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // count and maximum count values.
    //

    Semaphore->Header.Type = SemaphoreObject;
    Semaphore->Header.Size = sizeof(KSEMAPHORE) / sizeof(LONG);
    Semaphore->Header.SignalState = Count;
    InitializeListHead(&Semaphore->Header.WaitListHead);
    Semaphore->Limit = Limit;
    return;
}

LONG
KeReadStateSemaphore (
    __in PRKSEMAPHORE Semaphore
    )

/*++

Routine Description:

    This function reads the current signal state of a semaphore object.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

Return Value:

    The current signal state of the semaphore object.

--*/

{

    ASSERT_SEMAPHORE( Semaphore );

    //
    // Return current signal state of semaphore object.
    //

    return Semaphore->Header.SignalState;
}

LONG
KeReleaseSemaphore (
    __inout PRKSEMAPHORE Semaphore,
    __in KPRIORITY Increment,
    __in LONG Adjustment,
    __in BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a semaphore by adding the specified adjustment
    value to the current semaphore count and attempts to satisfy as many
    Waits as possible. The previous signal state of the semaphore object
    is returned as the function value.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Increment - Supplies the priority increment that is to be applied
        if releasing the semaphore causes a Wait to be satisfied.

    Adjustment - Supplies value that is to be added to the current
        semaphore count.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseSemaphore will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the semaphore object.

--*/

{

    LONG NewState;
    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_SEMAPHORE( Semaphore );
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the semaphore object and
    // compute the new count value.
    //

    OldState = ReadForWriteAccess(&Semaphore->Header.SignalState);
    NewState = OldState + Adjustment;

    //
    // If the new state value is greater than the limit or a carry occurs,
    // then unlock the dispatcher database, and raise an exception.
    //

    if ((NewState > Semaphore->Limit) || (NewState < OldState)) {
        KiUnlockDispatcherDatabase(OldIrql);
        ExRaiseStatus(STATUS_SEMAPHORE_LIMIT_EXCEEDED);
    }

    //
    // Set the new signal state of the semaphore object and set the wait
    // next value. If the previous signal state was Not-Signaled (i.e.
    // the count was zero), and the wait queue is not empty, then attempt
    // to satisfy as many Waits as possible.
    //

    Semaphore->Header.SignalState = NewState;
    if ((OldState == 0) && (IsListEmpty(&Semaphore->Header.WaitListHead) == FALSE)) {
        KiWaitTest(Semaphore, Increment);
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of semaphore object.
    //

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\thredsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    thredsup.c

Abstract:

    This module contains the support routines for the thread object. It
    contains functions to boost the priority of a thread, find a ready
    thread, select the next thread, ready a thread, set priority of a
    thread, and to suspend a thread.

Environment:

    All of the functions in this module execute in kernel mode except
    the function that raises a user mode alert condition.

--*/

#include "ki.h"

VOID
KiSuspendNop (
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC for a
    thread. It is executed in kernel mode as the result of queuing the
    builtin suspend APC.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    NormalRoutine - not used

    NormalContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Apc);
    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    //
    // No operation is performed by this routine.
    //

    return;
}

VOID
KiSuspendRundown (
    IN PKAPC Apc
    )

/*++

Routine Description:

    This function is the rundown routine for the threads built in suspend APC.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.


Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Apc);

    //
    // No operation is performed by this routine.
    //

    return;
}

VOID
FASTCALL
KiDeferredReadyThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution and attempts to dispatch the
    thread for execution by either assigning the thread to an idle processor
    or preempting another lower priority thread.

    If the thread can be assigned to an idle processor, then the thread enters
    the standby state and the target processor will switch to the thread on
    its next iteration of the idle loop.

    If a lower priority thread can be preempted, then the thread enters the
    standby state and the target processor is requested to dispatch.

    If the thread cannot be assigned to an idle processor and another thread
    cannot be preempted, then the specified thread is inserted at the head or
    tail of the dispatcher ready selected by its priority depending on whether
    it was preempted or not.

    N.B. This function is called at SYNCH level with no PRCB locks held.

    N.B. This function may be called with the dispatcher database lock held.

    N.B. Neither the priority nor the affinity of a thread in the deferred
         ready state can be changed outside the PRCB lock of the respective
         processor.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    PKPRCB CurrentPrcb;
    BOOLEAN Preempted;
    KPRIORITY Priority;
    PKPROCESS Process;
    ULONG Processor;
    PKPRCB TargetPrcb;
    KPRIORITY ThreadPriority;
    PKTHREAD Thread1;

#if !defined(NT_UP)

    KAFFINITY Affinity;
    ULONG IdealProcessor;
    KAFFINITY IdleSummary;

#if defined(NT_SMT)

    KAFFINITY FavoredSMTSet;
    KAFFINITY IdleSMTSet;

#endif

    KAFFINITY IdleSet;
    PKNODE Node;

#endif

    ASSERT(Thread->State == DeferredReady);

    ASSERT((Thread->Priority >= 0) && (Thread->Priority <= HIGH_PRIORITY));

    //
    // Check if a priority adjustment is requested.
    //

    if (Thread->AdjustReason == AdjustNone) {

        //
        // No priority adjustment.
        //

        NOTHING;

    } else if (Thread->AdjustReason == AdjustBoost) {

        //
        // Priority adjustment as the result of a set event boost priority.
        //
        // The current thread priority is stored in the adjust increment
        // field of the thread object.
        //
        // Acquire the thread lock.
        //
        // If the priority of the waiting thread is less than or equal
        // to the priority of the current thread and the waiting thread
        // priority is less than the time critical priority bound and
        // boosts are not disabled for the waiting thread, then boost
        // the priority of the waiting thread to the minimum of the
        // priority of the current thread priority plus one and the time
        // critical bound minus one. This boost will be taken away at
        // quantum end.
        //

        KiAcquireThreadLock(Thread);
        if ((Thread->Priority <= Thread->AdjustIncrement) &&
            (Thread->Priority < (TIME_CRITICAL_PRIORITY_BOUND - 1)) &&
            (Thread->DisableBoost == FALSE)) {

            //
            // Compute the new thread priority.
            //

            Priority = min(Thread->AdjustIncrement + 1,
                           TIME_CRITICAL_PRIORITY_BOUND - 1);

            ASSERT((Thread->PriorityDecrement >= 0) &&
                   (Thread->PriorityDecrement <= Thread->Priority));

            Thread->PriorityDecrement += ((SCHAR)Priority - Thread->Priority);

            ASSERT((Thread->PriorityDecrement >= 0) &&
                   (Thread->PriorityDecrement <= Priority));

            Thread->Priority = (SCHAR)Priority;
        }

        //
        // Make sure the thread has a quantum that is appropriate for
        // lock ownership and charge quantum.
        //

        if (Thread->Quantum < LOCK_OWNERSHIP_QUANTUM) {
            Thread->Quantum = LOCK_OWNERSHIP_QUANTUM;
        }

        Thread->Quantum -= WAIT_QUANTUM_DECREMENT;

        //
        // Release the thread lock and set the adjust reason to none.
        //

        ASSERT((Thread->Priority >= 0) && (Thread->Priority <= HIGH_PRIORITY));

        KiReleaseThreadLock(Thread);
        Thread->AdjustReason = AdjustNone;

    } else if (Thread->AdjustReason == AdjustUnwait) {

        //
        // Priority adjustment as the result of an unwait operation.
        //
        // The priority increment is stored in the adjust increment field of
        // the thread object.
        //
        // Acquire the thread lock.
        //
        // If the thread runs at a realtime priority level, then reset the
        // thread quantum. Otherwise, compute the next thread priority and
        // charge the thread for the wait operation.
        //
    
        Process = Thread->ApcState.Process;
        KiAcquireThreadLock(Thread);
        if (Thread->Priority < LOW_REALTIME_PRIORITY) {

            //
            // If the thread base priority is time critical or higher, then
            // replenish the quantum.
            //

            if (Thread->BasePriority >= TIME_CRITICAL_PRIORITY_BOUND) {
                Thread->Quantum = Thread->QuantumReset;
    
            } else {

                //
                // If the thread has not received an unusual boost and the
                // priority increment is nonzero, then replenish the thread
                // quantum.
                //

                if ((Thread->PriorityDecrement == 0) && (Thread->AdjustIncrement > 0)) {
                    Thread->Quantum = Thread->QuantumReset;
                }

                //
                // If the thread was unwaited to execute a kernel APC,
                // then do not charge the thread any quantum. The wait
                // code will charge quantum after the kernel APC has
                // executed and the wait is actually satisfied. Otherwise,
                // reduce the thread quantum and compute the new thread
                // priority if quantum runout occurs.
                //
            
                if (Thread->WaitStatus != STATUS_KERNEL_APC) {
                    Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
                    if (Thread->Quantum <= 0) {
                        Thread->Quantum = Thread->QuantumReset;
                        Thread->Priority = KiComputeNewPriority(Thread, 1);
                    }
                }
            }

            //
            // If the thread is not running with an unusual boost and boosts
            // are not disabled, then attempt to apply the specified priority
            // increment.
            //

            if ((Thread->PriorityDecrement == 0) &&
                (Thread->DisableBoost == FALSE)) {
    
                //
                // If the specified thread is from a process with a foreground
                // memory priority, then add the foreground boost separation.
                //

                ASSERT(Thread->AdjustIncrement >= 0);

                Priority = Thread->BasePriority + Thread->AdjustIncrement;
                if (((PEPROCESS)Process)->Vm.Flags.MemoryPriority == MEMORY_PRIORITY_FOREGROUND) {
                    Priority += ((SCHAR)PsPrioritySeparation);
                }
    
                //
                // If the new thread priority is greater than the current
                // thread priority, then boost the thread priority, but not
                // above low real time minus one.
                //
    
                if (Priority > Thread->Priority) {
                    if (Priority >= LOW_REALTIME_PRIORITY) {
                        Priority = LOW_REALTIME_PRIORITY - 1;
                    }
    
                    //
                    // If the new thread priority is greater than the thread
                    // base priority plus the specified increment (i.e., the
                    // foreground separation was added), then set the priority
                    // decrement to remove the separation boost after one
                    // quantum.
                    //
    
                    if (Priority > (Thread->BasePriority + Thread->AdjustIncrement)) {
                        Thread->PriorityDecrement =
                            ((SCHAR)Priority - Thread->BasePriority - Thread->AdjustIncrement);
                    }

                    ASSERT((Thread->PriorityDecrement >= 0) &&
                           (Thread->PriorityDecrement <= Priority));

                    Thread->Priority = (SCHAR)Priority;
                }
            }
    
        } else {
            Thread->Quantum = Thread->QuantumReset;
        }

        //
        // Release the thread lock and set the adjust reason to none.
        //

        ASSERT((Thread->Priority >= 0) && (Thread->Priority <= HIGH_PRIORITY));

        KiReleaseThreadLock(Thread);
        Thread->AdjustReason = AdjustNone;

    } else {

        //
        // Invalid priority adjustment reason.
        //

        ASSERT(FALSE);

        Thread->AdjustReason = AdjustNone;
    }

    //
    // Save the value of thread's preempted flag and set thread preempted
    // FALSE,
    //

    Preempted = Thread->Preempted;
    Thread->Preempted = FALSE;

    //
    // If there is an idle processor, then schedule the thread on an
    // idle processor giving preference to:
    //
    // (a) the thread's ideal processor,
    //
    // (b) if the thread has a soft (preferred affinity set) and
    //     that set contains an idle processor, reduce the set to
    //     the intersection of the two sets.
    //
    // (c) if the processors are Simultaneous Multi Threaded, and the
    //     set contains physical processors with no busy logical
    //     processors, reduce the set to that subset.
    //
    // (d) if this thread last ran on a member of this remaining set,
    //     select that processor, otherwise,
    //
    // (e) if there are processors amongst the remainder which are
    //     not sleeping, reduce to that subset.
    //
    // (f) select the leftmost processor from this set.
    //

#if defined(NT_UP)

    Thread->NextProcessor = 0;
    TargetPrcb = KiProcessorBlock[0];
    if (KiIdleSummary != 0) {
        KiIdleSummary = 0;
        Thread->State = Standby;
        TargetPrcb->NextThread = Thread;
        return;
    }

    Processor = 0;
    CurrentPrcb = TargetPrcb;
    ThreadPriority = Thread->Priority;

#else

    //
    // Attempt to assign the thread on an idle processor.
    //

    CurrentPrcb = KeGetCurrentPrcb();

IdleAssignment:
    Affinity = Thread->Affinity;
    do {
        Processor = Thread->IdealProcessor;
        IdleSet = KiIdleSummary & Affinity;
        if (IdleSet != 0) {
            if ((IdleSet & AFFINITY_MASK(Processor)) == 0) {

                //
                // Ideal processor is not available.
                //
                // If the intersection of the idle set and the node
                // affinity is nonzero, then reduce the set of idle
                // processors by the node affinity.
                //

                Node = KiProcessorBlock[Processor]->ParentNode;
                if ((IdleSet & Node->ProcessorMask) != 0) {
                    IdleSet &= Node->ProcessorMask;
                }

                //
                // If the intersection of the idle set and the SMT idle
                // set is nonzero, then reduce the set of idle processors
                // by the SMT idle set.
                //
    
#if defined(NT_SMT)

                IdleSMTSet = KiIdleSMTSummary;
                if ((IdleSet & IdleSMTSet) != 0) {
                    IdleSet &= IdleSMTSet;
                }
    
#endif
    
                //
                // If the last processor the thread ran on is included in
                // the idle set, then attempt to select that processor.
                //

                IdealProcessor = Processor;
                Processor = Thread->NextProcessor;
                if ((IdleSet & AFFINITY_MASK(Processor)) == 0) {

                    //
                    // If the current processor is included in the idle,
                    // then attempt to select that processor. 
                    //

                    Processor = CurrentPrcb->Number;
                    if ((IdleSet & AFFINITY_MASK(Processor)) == 0) {

                        //
                        // If the intersection of the idle set and the
                        // logical processor set on the ideal processor
                        // node is nonzero, then reduce the set of idle
                        // processors by the logical processor set.
                        //
                        // Otherwise, if the intersection of the idle
                        // set and the logical processor set of the last
                        // processor node is nonzero, then reduce the set
                        // of idle processors by the logical processor set.
                        //
    
#if defined(NT_SMT)
    
                        FavoredSMTSet = KiProcessorBlock[IdealProcessor]->MultiThreadProcessorSet;
                        if ((IdleSet & FavoredSMTSet) != 0) {
                            IdleSet &= FavoredSMTSet;

                        } else {
                            FavoredSMTSet = KiProcessorBlock[Thread->NextProcessor]->MultiThreadProcessorSet;
                            if ((IdleSet & FavoredSMTSet) != 0) {
                                IdleSet &= FavoredSMTSet;
                            }
                        }
    
#endif
    
                        //
                        // Select an idle processor from the remaining
                        // set.
                        //

                        KeFindFirstSetLeftAffinity(IdleSet, &Processor);
                    }
                }
            }

            //
            // Acquire the current and target PRCB locks and ensure the
            // selected processor is still idle and the thread can still
            // run on the processor.
            //

            TargetPrcb = KiProcessorBlock[Processor];
            KiAcquireTwoPrcbLocks(CurrentPrcb, TargetPrcb);
            IdleSummary = ReadForWriteAccess(&KiIdleSummary);
            if (((IdleSummary & TargetPrcb->SetMember) != 0) &&
                ((Thread->Affinity & TargetPrcb->SetMember) != 0)) {

                //
                // Set the thread state to standby, set the processor
                // number the thread is being assigned to, and clear the
                // associated bit in idle summary.
                //

                Thread->State = Standby;
                Thread->NextProcessor = (UCHAR)Processor;
                KiClearIdleSummary(AFFINITY_MASK(Processor));
    
                ASSERT((TargetPrcb->NextThread == NULL) ||
                       (TargetPrcb->NextThread == TargetPrcb->IdleThread));
    
                TargetPrcb->NextThread = Thread;
    
                //
                // Update the idle SMT summary set to indicate that the
                // SMT set is not idle.
                //
    
                KiClearSMTSummary(TargetPrcb->MultiThreadProcessorSet);
                if ((TargetPrcb != CurrentPrcb) &&
                    (KeIsIdleHaltSet(TargetPrcb, Processor) != FALSE)) {

                    KiSendSoftwareInterrupt(AFFINITY_MASK(Processor), DISPATCH_LEVEL);
                }

                KiReleaseTwoPrcbLocks(CurrentPrcb, TargetPrcb);
                return;

            } else {
                KiReleaseTwoPrcbLocks(CurrentPrcb, TargetPrcb);
                continue;
            }

        } else {
            break;
        }

    } while (TRUE);

    //
    // Select the ideal processor as the processor to preempt, if possible.
    //

    TargetPrcb = KiProcessorBlock[Processor];

    //
    // There are no suitable idle processors to run the thread. Acquire
    // the current and target PRCB locks and ensure the target processor
    // is not idle and the thread can still run on the processor.
    //

    KiAcquireTwoPrcbLocks(CurrentPrcb, TargetPrcb);
    ThreadPriority = Thread->Priority;
    if (((KiIdleSummary & TargetPrcb->SetMember) == 0) &&
        (Thread->IdealProcessor == Processor)) {

        ASSERT((Thread->Affinity & TargetPrcb->SetMember) != 0);

#endif

        Thread->NextProcessor = (UCHAR)Processor;
        if ((Thread1 = TargetPrcb->NextThread) != NULL) {

            ASSERT(Thread1->State == Standby);

            if (ThreadPriority > Thread1->Priority) {
                Thread1->Preempted = TRUE;
                Thread->State = Standby;
                TargetPrcb->NextThread = Thread;
                Thread1->State = DeferredReady;
                Thread1->DeferredProcessor = CurrentPrcb->Number;
                KiReleaseTwoPrcbLocks(CurrentPrcb, TargetPrcb);
                KiDeferredReadyThread(Thread1);
                return;
            }

        } else {
            Thread1 = TargetPrcb->CurrentThread;
            if (ThreadPriority > Thread1->Priority) {
                if (Thread1->State == Running) {
                    Thread1->Preempted = TRUE;
                }

                Thread->State = Standby;
                TargetPrcb->NextThread = Thread;
                KiReleaseTwoPrcbLocks(CurrentPrcb, TargetPrcb);
                KiRequestDispatchInterrupt(Thread->NextProcessor);
                return;
            }
        }

#if !defined(NT_UP)

    } else {
        KiReleaseTwoPrcbLocks(CurrentPrcb, TargetPrcb);
        goto IdleAssignment;
    }

#endif

    //
    // No thread can be preempted.
    //
    // Insert the thread in the dispatcher queue selected by its priority.
    // If the thread was preempted, then insert the thread at the front of
    // the queue. Otherwise, insert the thread at the tail of the queue.
    //

    ASSERT((ThreadPriority >= 0) && (ThreadPriority <= HIGH_PRIORITY));

    Thread->State = Ready;
    Thread->WaitTime = KiQueryLowTickCount();
    if (Preempted != FALSE) {
        InsertHeadList(&TargetPrcb->DispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);

    } else {
        InsertTailList(&TargetPrcb->DispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);
    }

    TargetPrcb->ReadySummary |= PRIORITY_MASK(ThreadPriority);

    ASSERT(ThreadPriority == Thread->Priority);

    KiReleaseTwoPrcbLocks(CurrentPrcb, TargetPrcb);
    return;
}

#if !defined(NT_UP)

PKTHREAD
FASTCALL
KiFindReadyThread (
    IN ULONG Number,
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This function searches the dispatcher ready queues in an attempt to find
    a thread that can execute on the specified processor.

    N.B. This routine is called with the sources PRCB locked and the specified
         PRCB lock held and returns with both locks held.

    N.B. This routine is only called when it is known that the ready summary
         for the specified processor is nonzero.

Arguments:

    Number - Supplies the number of the processor to find a thread for.

    Prcb - Supplies a pointer to the processor control block whose ready
        queues are to be examined.

Return Value:

    If a thread is located that can execute on the specified processor, then
    the address of the thread object is returned. Otherwise a null pointer is
    returned.

--*/

{

    ULONG HighPriority;
    PRLIST_ENTRY ListHead;
    PRLIST_ENTRY NextEntry;
    ULONG PrioritySet;
    PKTHREAD Thread;

    //
    // Initialize the set of priority levels that should be scanned in an
    // attempt to find a thread that can run on the specified processor.
    //

    PrioritySet = Prcb->ReadySummary;

    ASSERT(PrioritySet != 0);

    KeFindFirstSetLeftMember(PrioritySet, &HighPriority);
    do {

        ASSERT((PrioritySet & PRIORITY_MASK(HighPriority)) != 0);
        ASSERT(IsListEmpty(&Prcb->DispatcherReadyListHead[HighPriority]) == FALSE);

        ListHead = &Prcb->DispatcherReadyListHead[HighPriority];
        NextEntry = ListHead->Flink;

        ASSERT(NextEntry != ListHead);

        //
        // Scan the specified dispatcher ready queue for a suitable
        // thread to execute.
        //
        // N.B. It is not necessary to attempt to find a better candidate
        //      on either multinode or non-multinode systems. For multinode
        //      systems, this routine is called sequentially specifying each
        //      processor on the current node before attempting to schedule
        //      from other processors. For non-multinode systems all threads
        //      run on a single node and there is no node distinction. In
        //      both cases threads are inserted in per-processor ready queues
        //      according to their ideal processor.
        //

        do {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            if ((Thread->Affinity & AFFINITY_MASK(Number)) != 0) {

                ASSERT((Prcb->ReadySummary & PRIORITY_MASK(HighPriority)) != 0);
                ASSERT((KPRIORITY)HighPriority == Thread->Priority);
                ASSERT(Thread->NextProcessor == Prcb->Number);

                if (RemoveEntryList(&Thread->WaitListEntry) != FALSE) {
                    Prcb->ReadySummary ^= PRIORITY_MASK(HighPriority);
                }

                Thread->NextProcessor = (UCHAR)Number;
                return Thread;
            }

            NextEntry = NextEntry->Flink;
        } while (NextEntry != ListHead);

        PrioritySet ^= PRIORITY_MASK(HighPriority);
        KeFindFirstSetLeftMember(PrioritySet, &HighPriority);
    } while (PrioritySet != 0);

    //
    // No thread could be found, return a null pointer.
    //

    return NULL;
}

VOID
FASTCALL
KiProcessDeferredReadyList (
    IN PKPRCB CurrentPrcb
    )

/*++

Routine Description:

    This function is called to process the deferred ready list.

    N.B. This function is called at SYNCH level with no locks held.

    N.B. This routine is only called when it is known that the deferred
         ready list is not empty.

    N.B. The deferred ready list is a per processor list and items are
         only inserted and removed from the respective processor. Thus
         no synchronization of the list is required.

Arguments:

    CurrentPrcb - Supplies a pointer to the current processor's PRCB.

Return Value:

    None.

--*/

{

    PSINGLE_LIST_ENTRY NextEntry;
    PKTHREAD Thread;

    ASSERT(CurrentPrcb->DeferredReadyListHead.Next != NULL);

    //
    // Save the address of the first entry in the deferred ready list and
    // set the list to empty.
    //

    NextEntry = CurrentPrcb->DeferredReadyListHead.Next;
    CurrentPrcb->DeferredReadyListHead.Next = NULL;

    //
    // Process each entry in deferred ready list and ready the specified
    // thread for execution.
    //

    do {
        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, SwapListEntry);
        NextEntry = NextEntry->Next;
        KiDeferredReadyThread(Thread);
    } while (NextEntry != NULL);

    ASSERT(CurrentPrcb->DeferredReadyListHead.Next == NULL);

    return;
}

#endif

VOID
FASTCALL
KiQueueReadyThread (
    IN PKTHREAD Thread,
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This function inserts the specified thread in the appropriate dispatcher
    ready queue for the specified processor if the thread can run on the
    specified processor. Otherwise, the specified thread is readied for
    execution.

    N.B. This function is called with the specified PRCB lock held and returns
         with the PRCB lock not held.

Arguments:

    Thread - Supplies a pointer to a dsispatcher object of type thread.

    Prcb - Supplies a pointer to a processor control block.

Return Value:

    None.

--*/

{

    KxQueueReadyThread(Thread, Prcb);
    return;
}

VOID
FASTCALL
KiReadyThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function inserts the specified thread in the process ready list if
    the thread's process is currently not in memory, inserts the specified
    thread in the kernel stack in swap list if the thread's kernel stack is
    not resident, or inserts the thread in the deferred ready list.

    N.B. This function is called with the dispatcher database lock held and
         returns with the lock held.

    N.B. The deferred ready list is a per processor list and items are
         only inserted and removed from the respective processor. Thus
         no synchronization of the list is required.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    PKPROCESS Process;

    //
    // If the thread's process is not in memory, then insert the thread in
    // the process ready queue and inswap the process.
    //

    Process = Thread->ApcState.Process;
    if (Process->State != ProcessInMemory) {
        Thread->State = Ready;
        Thread->ProcessReadyQueue = TRUE;
        InsertTailList(&Process->ReadyListHead, &Thread->WaitListEntry);
        if (Process->State == ProcessOutOfMemory) {
            Process->State = ProcessInTransition;
            InterlockedPushEntrySingleList(&KiProcessInSwapListHead,
                                           &Process->SwapListEntry);

            KiSetInternalEvent(&KiSwapEvent, KiSwappingThread);
        }

        return;

    } else if (Thread->KernelStackResident == FALSE) {

        //
        // The thread's kernel stack is not resident. Increment the process
        // stack count, set the state of the thread to transition, insert
        // the thread in the kernel stack inswap list, and set the kernel
        // stack inswap event.
        //

        ASSERT(Process->StackCount != MAXULONG_PTR);

        Process->StackCount += 1;

        ASSERT(Thread->State != Transition);

        Thread->State = Transition;
        InterlockedPushEntrySingleList(&KiStackInSwapListHead,
                                       &Thread->SwapListEntry);

        KiSetInternalEvent(&KiSwapEvent, KiSwappingThread);
        return;

    } else {

        //
        // Insert the specified thread in the deferred ready list.
        //

        KiInsertDeferredReadyList(Thread);
        return;
    }
}

PKTHREAD
FASTCALL
KiSelectNextThread (
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    This function selects the next thread to run on the specified processor.

    N.B. This function is called with the specified PRCB lock held and also
         returns with the lock held.

Arguments:

    Prcb - Supplies a  pointer to a processor block.

Return Value:

    The address of the selected thread object.

--*/

{

    PKTHREAD Thread;

    //
    // Find a ready thread to run from the specified PRCB dispatcher ready
    // queues.
    //

    if ((Thread = KiSelectReadyThread(0, Prcb)) == NULL) {

        //
        // A ready thread cannot be found in the specified PRCB dispatcher
        // ready queues. Select the idle thread and set idle schedule for
        // the specified processor.
        //
        // N.B. Selecting the idle thread with idle schedule set avoids doing
        //      a complete search of all the dispatcher queues for a suitable
        //      thread to run. A complete search will be performed by the idle
        //      thread outside the dispatcher lock.
        //
    
        Thread = Prcb->IdleThread;
        KiSetIdleSummary(Prcb->SetMember);
        Prcb->IdleSchedule = TRUE;
    
        //
        // If all logical processors of the physical processor are idle, then
        // update the idle SMT set summary.
        //
    
        if (KeIsSMTSetIdle(Prcb) == TRUE) {
            KiSetSMTSummary(Prcb->MultiThreadProcessorSet);
        }
    }

    ASSERT(Thread != NULL);

    //
    // Return address of selected thread object.
    //

    ASSERT((Thread->BasePriority == 0) || (Thread->Priority != 0));

    return Thread;
}

KAFFINITY
FASTCALL
KiSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    This function sets the affinity of a specified thread to a new value.
    If the new affinity is not a proper subset of the parent process affinity
    or is null, then a bugcheck occurs. If the specified thread is running on
    or about to run on a processor for which it is no longer able to run, then
    the target processor is rescheduled. If the specified thread is in a ready
    state and is not in the parent process ready queue, then it is rereadied
    to reevaluate any additional processors it may run on.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Affinity - Supplies the new of set of processors on which the thread
        can run.

Return Value:

    The previous affinity of the specified thread is returned as the function
    value.

--*/

{

    KAFFINITY OldAffinity;
    PKPRCB Prcb;
    PKPROCESS Process;
    ULONG Processor;

#if !defined(NT_UP)

    ULONG IdealProcessor;
    ULONG Index;
    PKNODE Node;
    ULONG NodeNumber;

#endif

    BOOLEAN RequestInterrupt;
    PKTHREAD Thread1;

    //
    // Capture the current affinity of the specified thread and get address
    // of parent process object.
    //

    OldAffinity = Thread->UserAffinity;
    Process = Thread->Process;

    //
    // If new affinity is not a proper subset of the parent process affinity
    // or the new affinity is null, then bugcheck.
    //

    if (((Affinity & Process->Affinity) != (Affinity)) || (!Affinity)) {
        KeBugCheck(INVALID_AFFINITY_SET);
    }

    //
    // Set the thread user affinity to the specified value.
    //

    Thread->UserAffinity = Affinity;

    //
    // If the thread user ideal processor is not a member of the new affinity
    // set, then recompute the user ideal processor.
    //

#if !defined(NT_UP)

    if ((Affinity & AFFINITY_MASK(Thread->UserIdealProcessor)) == 0) {
        if (KeNumberNodes > 1) {
            NodeNumber = (KeProcessNodeSeed + 1) % KeNumberNodes;
            KeProcessNodeSeed = (UCHAR)NodeNumber;
            Index = 0;
            do {      
                if ((KeNodeBlock[NodeNumber]->ProcessorMask & Affinity) != 0) {
                    break;
                }
    
                Index += 1;
                NodeNumber += 1;
                if (NodeNumber >= KeNumberNodes) {
                    NodeNumber -= KeNumberNodes;
                }
    
            } while (Index < KeNumberNodes);
    
        } else {
            NodeNumber = 0;
        }
    
        Node = KeNodeBlock[NodeNumber];

        ASSERT((Node->ProcessorMask & Affinity) != 0);

        IdealProcessor = KeFindNextRightSetAffinity(Node->Seed,
                                                    Node->ProcessorMask & Affinity);
    
        Thread->UserIdealProcessor = (UCHAR)IdealProcessor;
        Node->Seed = (UCHAR)IdealProcessor;
    }

#endif

    //
    // If the thread is not current executing with system affinity active,
    // then set the thread current affinity and switch on the thread state.
    //

    if (Thread->SystemAffinityActive == FALSE) {

        //
        // Switch on the thread state.
        //

        KiAcquireThreadLock(Thread);
        do {
            switch (Thread->State) {

                //
                // Ready State.
                //
                // If the thread is not in the process ready queue, then
                // remove the thread from its current dispatcher ready
                // queue and ready the thread for execution.
                //

            case Ready:
                if (Thread->ProcessReadyQueue == FALSE) {
                    Processor = Thread->NextProcessor;
                    Prcb = KiProcessorBlock[Processor];
                    KiAcquirePrcbLock(Prcb);
                    if ((Thread->State == Ready) &&
                        (Thread->NextProcessor == Prcb->Number)) {

                        Thread->Affinity = Affinity;

#if !defined(NT_UP)

                        Thread->IdealProcessor = Thread->UserIdealProcessor;

#endif

                        ASSERT((Prcb->ReadySummary & PRIORITY_MASK(Thread->Priority)) != 0);

                        if (RemoveEntryList(&Thread->WaitListEntry) != FALSE) {
                            Prcb->ReadySummary ^= PRIORITY_MASK(Thread->Priority);
                        }
        
                        KiInsertDeferredReadyList(Thread);
                        KiReleasePrcbLock(Prcb);

                    } else {
                        KiReleasePrcbLock(Prcb);
                        continue;
                    }

                } else {
                    Thread->Affinity = Affinity;

#if !defined(NT_UP)

                    Thread->IdealProcessor = Thread->UserIdealProcessor;

#endif

                }

                break;
    
                //
                // Standby State.
                //
                // If the target processor is not in the new affinity set,
                // then select a new thread to run on the target processor,
                // and ready the thread for execution.
                //
    
            case Standby:
                Processor = Thread->NextProcessor;
                Prcb = KiProcessorBlock[Processor];
                KiAcquirePrcbLock(Prcb);
                if (Thread == Prcb->NextThread) {
                    Thread->Affinity = Affinity;

#if !defined(NT_UP)

                    Thread->IdealProcessor = Thread->UserIdealProcessor;

#endif
        
                    if ((Prcb->SetMember & Affinity) == 0) {
                        Thread1 = KiSelectNextThread(Prcb);
                        Thread1->State = Standby;
                        Prcb->NextThread = Thread1;
                        KiInsertDeferredReadyList(Thread);
                        KiReleasePrcbLock(Prcb);
        
                    } else {
                        KiReleasePrcbLock(Prcb);
                    }

                } else {
                    KiReleasePrcbLock(Prcb);
                    continue;
                }

                break;
    
                //
                // Running State.
                //
                // If the target processor is not in the new affinity set and
                // another thread has not already been selected for execution
                // on the target processor, then select a new thread for the
                // target processor, and cause the target processor to be
                // redispatched.
                //
    
            case Running:
                Processor = Thread->NextProcessor;
                Prcb = KiProcessorBlock[Processor];
                RequestInterrupt = FALSE;
                KiAcquirePrcbLock(Prcb);
                if (Thread == Prcb->CurrentThread) {
                    Thread->Affinity = Affinity;

#if !defined(NT_UP)

                    Thread->IdealProcessor = Thread->UserIdealProcessor;

#endif

                    if (((Prcb->SetMember & Affinity) == 0) &&
                        (Prcb->NextThread == NULL)) {
        
                        Thread1 = KiSelectNextThread(Prcb);
                        Thread1->State = Standby;
                        Prcb->NextThread = Thread1;
                        RequestInterrupt = TRUE;
                    }

                    KiReleasePrcbLock(Prcb);
                    if (RequestInterrupt == TRUE) {
                        KiRequestDispatchInterrupt(Processor);
                    }

                } else {
                    KiReleasePrcbLock(Prcb);
                    continue;
                }
    
                break;

                //
                // Deferred Ready State:
                //
                // Set the affinity of the thread in a deferred ready state.
                //

            case DeferredReady:
                Processor = Thread->DeferredProcessor;
                Prcb = KiProcessorBlock[Processor];
                KiAcquirePrcbLock(Prcb);
                if ((Thread->State == DeferredReady) &&
                    (Thread->DeferredProcessor == Processor)) {

                    Thread->Affinity = Affinity;

#if !defined(NT_UP)

                    Thread->IdealProcessor = Thread->UserIdealProcessor;

#endif

                    KiReleasePrcbLock(Prcb);

                } else {
                    KiReleasePrcbLock(Prcb);
                    continue;
                }

                break;

                //
                // Initialized, GateWait, Terminated, Waiting, Transition
                // case - For these states it is sufficient to just set the
                // new thread affinity.
                //
    
            default:
                Thread->Affinity = Affinity;

#if !defined(NT_UP)

                Thread->IdealProcessor = Thread->UserIdealProcessor;

#endif

                break;
            }

            break;

        } while (TRUE);

        KiReleaseThreadLock(Thread);
    }

    //
    // Return the previous user affinity.
    //

    return OldAffinity;
}

VOID
KiSetInternalEvent (
    IN PKEVENT Event,
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function sets an internal event or unwaits the specfied thread.

    N.B. The dispatcher lock must be held to call this routine.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PLIST_ENTRY WaitEntry;

    //
    // If the swap event wait queue is not empty, then unwait the swap
    // thread (there is only one swap thread). Otherwise, set the swap
    // event.
    //

    WaitEntry = Event->Header.WaitListHead.Flink;
    if (WaitEntry != &Event->Header.WaitListHead) {
        KiUnwaitThread(Thread, 0, BALANCE_INCREMENT);

    } else {
        Event->Header.SignalState = 1;
    }

    return;
}

VOID
FASTCALL
KiSetPriorityThread (
    __inout PKTHREAD Thread,
    __in KPRIORITY Priority
    )

/*++

Routine Description:

    This function set the priority of the specified thread to the specified
    value. If the thread is in the standby or running state, then the processor
    may be redispatched. If the thread is in the ready state, then some other
    thread may be preempted.

    N.B. The thread lock is held on entry and exit to this function.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new thread priority value.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;
    ULONG Processor;
    BOOLEAN RequestInterrupt;
    KPRIORITY ThreadPriority;
    PKTHREAD Thread1;

    ASSERT((Priority >= 0) && (Priority <= HIGH_PRIORITY));

    //
    // If the new priority is not equal to the old priority, then set the
    // new priority of the thread and redispatch a processor if necessary.
    //

    if (Priority != Thread->Priority) {

        //
        //
        // Switch on the thread state.

        do {
            switch (Thread->State) {
    
                //
                // Ready State.
                //
                // If the thread is not in the process ready queue, then
                // remove the thread from its current dispatcher ready
                // queue and ready the thread for execution.
                //
    
            case Ready:
                if (Thread->ProcessReadyQueue == FALSE) {
                    Processor = Thread->NextProcessor;
                    Prcb = KiProcessorBlock[Processor];
                    KiAcquirePrcbLock(Prcb);
                    if ((Thread->State == Ready) &&
                        (Thread->NextProcessor == Prcb->Number)) {

                        ASSERT((Prcb->ReadySummary & PRIORITY_MASK(Thread->Priority)) != 0);

                        if (RemoveEntryList(&Thread->WaitListEntry) != FALSE) {
                            Prcb->ReadySummary ^= PRIORITY_MASK(Thread->Priority);
                        }

                        Thread->Priority = (SCHAR)Priority;
                        KiInsertDeferredReadyList(Thread);
                        KiReleasePrcbLock(Prcb);
    
                    } else {
                        KiReleasePrcbLock(Prcb);
                        continue;
                    }

                } else {
                    Thread->Priority = (SCHAR)Priority;
                }
    
                break;
    
                //
                // Standby State.
                // 
                // If the thread's priority is being lowered, then attempt
                // to find another thread to execute on the target processor.
                //
    
            case Standby:
                Processor = Thread->NextProcessor;
                Prcb = KiProcessorBlock[Processor];
                KiAcquirePrcbLock(Prcb);
                if (Thread == Prcb->NextThread) {
                    ThreadPriority = Thread->Priority;
                    Thread->Priority = (SCHAR)Priority;
                    if (Priority < ThreadPriority) {
                        if ((Thread1 = KiSelectReadyThread(Priority + 1, Prcb)) != NULL) {
                            Thread1->State = Standby;
                            Prcb->NextThread = Thread1;
                            KiInsertDeferredReadyList(Thread);
                            KiReleasePrcbLock(Prcb);
    
                        } else {
                            KiReleasePrcbLock(Prcb);
                        }

                    } else {
                        KiReleasePrcbLock(Prcb);
                    }

                } else {
                    KiReleasePrcbLock(Prcb);
                    continue;
                }
    
                break;
    
                //
                // Running State.
                //
                // If the thread's priority is being lowered, then attempt
                // to find another thread to execute on the target processor.
                //
    
            case Running:
                Processor = Thread->NextProcessor;
                Prcb = KiProcessorBlock[Processor];
                RequestInterrupt = FALSE;
                KiAcquirePrcbLock(Prcb);
                if (Thread == Prcb->CurrentThread) {
                    ThreadPriority = Thread->Priority;
                    Thread->Priority = (SCHAR)Priority;
                    if ((Priority < ThreadPriority) &&
                        (Prcb->NextThread == NULL)) {

                        if ((Thread1 = KiSelectReadyThread(Priority + 1, Prcb)) != NULL) {
                            Thread1->State = Standby;
                            Prcb->NextThread = Thread1;
                            RequestInterrupt = TRUE;
                        }
                    }

                    KiReleasePrcbLock(Prcb);
                    if (RequestInterrupt == TRUE) {
                        KiRequestDispatchInterrupt(Processor);
                    }

                } else {
                    KiReleasePrcbLock(Prcb);
                    continue;
                }
    
                break;

                //
                // Deferred Ready State:
                //
                // Set the priority of the thread in a deferred ready state.
                //

            case DeferredReady:
                Processor = Thread->DeferredProcessor;
                Prcb = KiProcessorBlock[Processor];
                KiAcquirePrcbLock(Prcb);
                if ((Thread->State == DeferredReady) &&
                    (Thread->DeferredProcessor == Processor)) {

                    Thread->Priority = (SCHAR)Priority;
                    KiReleasePrcbLock(Prcb);

                } else {
                    KiReleasePrcbLock(Prcb);
                    continue;
                }

                break;

                //
                // Initialized, GateWait, Terminated, Waiting, Transition
                // case - For these states it is sufficient to just set the
                // new thread priority.
                //
    
            default:
                Thread->Priority = (SCHAR)Priority;
                break;
            }

            break;

        } while(TRUE);
    }

    return;
}

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC of a
    thread. It is executed as the result of queuing the builtin suspend
    APC and suspends thread execution by waiting nonalerable on the thread's
    builtin suspend semaphore. When the thread is resumed, execution of
    thread is continued by simply returning.

Arguments:

    NormalContext - Not used.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    //
    // Get the address of the current thread object and Wait nonalertable on
    // the thread's builtin suspend semaphore.
    //

    Thread = KeGetCurrentThread();
    KeWaitForSingleObject(&Thread->SuspendSemaphore,
                          Suspended,
                          KernelMode,
                          FALSE,
                          NULL);

    return;
}

LONG_PTR
FASTCALL
KiSwapThread (
    IN PKTHREAD OldThread,
    IN PKPRCB CurrentPrcb
    )

/*++

Routine Description:

    This function selects the next thread to run on the current processor
    and swaps thread context to the selected thread. When the execution
    of the current thread is resumed, the IRQL is lowered to its previous
    value and the wait status is returned as the function value.

    N.B. This function is called with no locks held.

Arguments:

    Thread - Supplies a pointer to the current thread object.

    CurrentPrcb - Supplies a pointer to the current PRCB.

Return Value:

    The wait completion status is returned as the function value.

--*/

{

    PKTHREAD NewThread;
    BOOLEAN Pending;
    KIRQL WaitIrql;
    LONG_PTR WaitStatus;

#if !defined(NT_UP)
      
    LONG Index;
    LONG Limit;
    LONG Number;
    ULONG Processor;
    PKPRCB TargetPrcb;

#endif

    //
    // If the deferred ready list is not empty, then process the list.
    //

#if !defined(NT_UP)

    if (CurrentPrcb->DeferredReadyListHead.Next != NULL) {
        KiProcessDeferredReadyList(CurrentPrcb);
    }

#endif

    //
    // Acquire the current PRCB lock and check if a thread has been already
    // selected to run of this processor.
    //
    // If a thread has already been selected to run on the current processor,
    // then select that thread. Otherwise, attempt to select a thread from
    // the current processor dispatcher ready queues.
    //

    KiAcquirePrcbLock(CurrentPrcb);
    if ((NewThread = CurrentPrcb->NextThread) != NULL) {

        //
        // Clear the next thread address, set the current thread address, and
        // set the thread state to running.
        //

        CurrentPrcb->NextThread = NULL;
        CurrentPrcb->CurrentThread = NewThread;
        NewThread->State = Running;

    } else {

        //
        // Attempt to select a thread from the current processor dispatcher
        // ready queues.
        //

        if ((NewThread = KiSelectReadyThread(0, CurrentPrcb)) != NULL) {
            CurrentPrcb->CurrentThread = NewThread;
            NewThread->State = Running;

        } else {

            //
            // A thread could not be selected from the current processor
            // dispatcher ready queues. Set the current processor idle while
            // attempting to select a ready thread from any other processor
            // dispatcher ready queue.
            //
            // Setting the current processor idle allows the old thread to
            // masquerade as the idle thread while scanning other processor
            // dispatcher ready queues and avoids forcing the idle thread
            // to perform a complete scan should no suitable thread be found.
            // 

            KiSetIdleSummary(CurrentPrcb->SetMember);

            //
            // On a UP system, select the idle thread as the new thread.
            //
            // On an MP system, attempt to select a thread from another
            // processor's dispatcher ready queues as the new thread.
            //

#if defined(NT_UP)

            NewThread = CurrentPrcb->IdleThread;
            CurrentPrcb->CurrentThread = NewThread;
            NewThread->State = Running;
        }
    }

#else

            //
            // If all logical processors of the physical processor are idle,
            // then update the idle SMT summary set.
            //

            if (KeIsSMTSetIdle(CurrentPrcb) == TRUE) {
                KiSetSMTSummary(CurrentPrcb->MultiThreadProcessorSet);
            }

            //
            // Release the current PRCB lock and attempt to select a thread
            // from any processor dispatcher ready queues.
            //
            // If this is a multinode system, then start with the processors
            // on the same node. Otherwise, start with the current processor.
            //
            // N.B. It is possible to perform the below loop with minimal
            //      releases of the current PRCB lock. However, this limits
            //      parallelism.
            //

            KiReleasePrcbLock(CurrentPrcb);
            Processor = CurrentPrcb->Number;
            Index = Processor;
            if (KeNumberNodes > 1) {
                KeFindFirstSetLeftAffinity(CurrentPrcb->ParentNode->ProcessorMask,
                                           (PULONG)&Index);
            }

            Limit = KeNumberProcessors - 1;
            Number = Limit;

            ASSERT(Index <= Limit);

            do {
                TargetPrcb = KiProcessorBlock[Index];
                if (CurrentPrcb != TargetPrcb) {
                    if (TargetPrcb->ReadySummary != 0) {

                        //
                        // Acquire the current and target PRCB locks.
                        //

                        KiAcquireTwoPrcbLocks(CurrentPrcb, TargetPrcb);

                        //
                        // If a new thread has not been selected to run on
                        // the current processor, then attempt to select a
                        // thread to run on the current processor.
                        //

                        if ((NewThread = CurrentPrcb->NextThread) == NULL) {
                            if ((TargetPrcb->ReadySummary != 0) &&
                                (NewThread = KiFindReadyThread(Processor,
                                                               TargetPrcb)) != NULL) {
    
                                //
                                // A new thread has been found to run on the
                                // current processor. 
                                //
    
                                NewThread->State = Running;
                                KiReleasePrcbLock(TargetPrcb);
                                CurrentPrcb->CurrentThread = NewThread;

                                //
                                // Clear idle on the current processor and
                                // update the idle summary SMT set to indicate
                                // the physical processor is not entirely idle.
                                //

                                KiClearIdleSummary(AFFINITY_MASK(Processor));
                                KiClearSMTSummary(CurrentPrcb->MultiThreadProcessorSet);
                                goto ThreadFound;

                            } else {
                                KiReleasePrcbLock(CurrentPrcb);
                                KiReleasePrcbLock(TargetPrcb);
                            }

                        } else {

                            //
                            // A thread has already been selected to run on
                            // the current processor. It is possible that
                            // the thread is the idle thread due to a state
                            // change that made a scheduled runable thread
                            // unrunable.
                            //
                            // N.B. If the idle thread is selected, then the
                            //      current processor is idle. Otherwise,
                            //      the current processor is not idle.
                            //

                            if (NewThread == CurrentPrcb->IdleThread) {
                                CurrentPrcb->NextThread = NULL;
                                CurrentPrcb->IdleSchedule = FALSE;
                                KiReleasePrcbLock(CurrentPrcb);
                                KiReleasePrcbLock(TargetPrcb);
                                continue;

                            } else {
                                NewThread->State = Running;
                                KiReleasePrcbLock(TargetPrcb);
                                CurrentPrcb->NextThread = NULL;
                                CurrentPrcb->CurrentThread = NewThread;
                                goto ThreadFound;
                            }
                        }
                    }
                }
        
                Index -= 1;
                if (Index < 0) {
                    Index = Limit;
                }
        
                Number -= 1;
            } while (Number >= 0);

            //
            // Acquire the current PRCB lock and if a thread has not been
            // selected to run on the current processor, then select the
            // idle thread.
            //

            KiAcquirePrcbLock(CurrentPrcb);
            if ((NewThread = CurrentPrcb->NextThread) != NULL) {
                CurrentPrcb->NextThread = NULL;

            } else {
                NewThread = CurrentPrcb->IdleThread;
            }

            CurrentPrcb->CurrentThread = NewThread;
            NewThread->State = Running;
        }
    }

    //
    // If the new thread is not the idle thread, and the old thread is not
    // the new thread, and the new thread has not finished saving context,
    // then avoid a deadlock by scheduling the new thread via the idle thread.
    //

ThreadFound:;

    if ((NewThread != CurrentPrcb->IdleThread) &&
        (NewThread != OldThread) &&
        (NewThread->SwapBusy != FALSE)) {

        NewThread->State = Standby;
        CurrentPrcb->NextThread = NewThread;
        NewThread = CurrentPrcb->IdleThread;
        NewThread->State = Running;
        CurrentPrcb->CurrentThread = NewThread;
    }

#endif

    //
    // Release the current PRCB lock.
    //

    ASSERT(OldThread != CurrentPrcb->IdleThread);

    KiReleasePrcbLock(CurrentPrcb);

    //
    // If the old thread is the same as the new thread, then the current
    // thread has been readied for execution before the context was saved.
    // Release the old thread lock, and set the APC pending value. Otherwise,
    // swap context to the new thread.
    //

    WaitIrql = OldThread->WaitIrql;

#if !defined(NT_UP)

    if (OldThread == NewThread) {
        KiSetContextSwapIdle(OldThread);
        Pending = (BOOLEAN)((NewThread->ApcState.KernelApcPending != FALSE) &&
                            (NewThread->SpecialApcDisable == 0) &&
                            (WaitIrql == 0));

    } else {
        Pending = KiSwapContext(OldThread, NewThread);
    }

#else

    Pending = KiSwapContext(OldThread, NewThread);

#endif

    //
    // If a kernel APC should be delivered, then deliver it now.
    //

    WaitStatus = OldThread->WaitStatus;
    if (Pending != FALSE) {
        KeLowerIrql(APC_LEVEL);
        KiDeliverApc(KernelMode, NULL, NULL);

        ASSERT(WaitIrql == 0);
    }

    //
    // Lower IRQL to its level before the wait operation and return the wait
    // status.
    //

    KeLowerIrql(WaitIrql);
    return WaitStatus;
}

ULONG
KeFindNextRightSetAffinity (
    __in ULONG Number,
    __in KAFFINITY Set
    )

/*++

Routine Description:

    This function locates the left most set bit in the set immediately to
    the right of the specified bit. If no bits are set to the right of the
    specified bit, then the left most set bit in the complete set is located.

    N.B. Set must contain at least one bit.

Arguments:

    Number - Supplies the bit number from which the search to to begin.

    Set - Supplies the bit mask to search.

Return Value:

    The number of the found set bit is returned as the function value.

--*/

{

    KAFFINITY NewSet;
    ULONG Temp;

    ASSERT(Set != 0);

    //
    // Get a mask with all bits to the right of bit "Number" set.
    //

    NewSet = (AFFINITY_MASK(Number) - 1) & Set;

    //
    // If no bits are set to the right of the specified bit number, then use
    // the complete set.
    //

    if (NewSet == 0) {
        NewSet = Set;
    }

    //
    // Find leftmost bit in this set.
    //

    KeFindFirstSetLeftAffinity(NewSet, &Temp);
    return Temp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\timersup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    timersup.c

Abstract:

    This module contains the support routines for the timer object. It
    contains functions to insert and remove from the timer queue.

--*/

#include "ki.h"

VOID
FASTCALL
KiCompleteTimer (
    __inout PKTIMER Timer,
    __inout PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function completes a timer that could not be inserted in the timer
    table because its due time has already passed.

    N.B. This function must be called with the corresponding timer table
         entry locked at raised IRQL.

    N.B. This function returns with no locks held at raised IRQL.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    LockQueue - Supplies a pointer to a timer table lock queue entry.

Return Value:

    None.

-*/

{

    LIST_ENTRY ListHead;
    BOOLEAN RequestInterrupt;

    //
    // Remove the timer from the specified timer table list and insert
    // the timer in a dummy list in case the timer is cancelled while
    // releasing the timer table lock and acquiring the dispatcher lock.
    //

    KiRemoveEntryTimer(Timer);
    ListHead.Flink = &Timer->TimerListEntry;
    ListHead.Blink = &Timer->TimerListEntry;
    Timer->TimerListEntry.Flink = &ListHead;
    Timer->TimerListEntry.Blink = &ListHead;
    KiReleaseTimerTableLock(LockQueue);
    RequestInterrupt = FALSE;
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If the timer has not been removed from the dummy list, then signal
    // the timer.
    //

    if (ListHead.Flink != &ListHead) {
        RequestInterrupt = KiSignalTimer(Timer);
    }

    //
    // Release the dispatcher lock and request a DPC interrupt if required.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    if (RequestInterrupt == TRUE) {
        KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
    }

    return;
}

LOGICAL
FASTCALL
KiInsertTimerTable (
    IN PKTIMER Timer,
    IN ULONG Hand
    )

/*++

Routine Description:

    This function inserts a timer object in the timer table.

    N.B. This routine assumes that the timer table lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Hand - supplies the timer table hand value.

Return Value:

    If the timer has expired, than a value of TRUE is returned. Otherwise, a
    value of FALSE is returned.

--*/

{

    ULONG64 DueTime;
    LOGICAL Expired;
    ULARGE_INTEGER InterruptTime;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PKTIMER NextTimer;

    //
    // Set the signal state to FALSE if the period is zero.
    //
    // N.B. The timer state is set to inserted.
    //

    Expired = FALSE;
    if (Timer->Period == 0) {
        Timer->Header.SignalState = FALSE;
    }

    //
    // If the timer is due before the first entry in the computed list
    // or the computed list is empty, then insert the timer at the front
    // of the list and check if the timer has already expired. Otherwise,
    // insert then timer in the sorted order of the list searching from
    // the back of the list forward.
    //
    // N.B. The sequence of operations below is critical to avoid the race
    //      condition that exists between this code and the clock interrupt
    //      code that examines the timer table lists to detemine when timers
    //      expire.
    //

    DueTime = Timer->DueTime.QuadPart;

    ASSERT(Hand == KiComputeTimerTableIndex(DueTime));

    ListHead = &KiTimerTableListHead[Hand].Entry;
    NextEntry = ListHead->Blink;
    while (NextEntry != ListHead) {

        //
        // Compute the maximum search count.
        //

        NextTimer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
        if (DueTime >= (ULONG64)NextTimer->DueTime.QuadPart) {
            break;
        }

        NextEntry = NextEntry->Blink;
    }

    InsertHeadList(NextEntry, &Timer->TimerListEntry);
    if (NextEntry == ListHead) {

        //
        // The computed list is empty or the timer is due to expire before
        // the first entry in the list.
        //
        // Make sure the writes for the update of the due time table are done
        // before reading the interrupt time.
        //

        KiTimerTableListHead[Hand].Time.QuadPart = DueTime; 
        KeMemoryBarrier();
        KiQueryInterruptTime((PLARGE_INTEGER)&InterruptTime);
        if (DueTime <= (ULONG64)InterruptTime.QuadPart) {
            Expired = TRUE;
        }
    }

    return Expired;
}

BOOLEAN
FASTCALL
KiSignalTimer (
    __inout PKTIMER Timer
    )

/*++

Routine Description:

    This function signals a timer that could not be inserted in the timer
    table because its due time has already passed.

    N.B. This function must be called with the dispatcher database locked at
         at raised IRQL.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    If a software interrupt should be requested, then TRUE is returned.
    Otherwise, a value of FALSE is returned.

-*/

{

    PKDPC Dpc;
    LARGE_INTEGER Interval;
    LONG Period;
    BOOLEAN RequestInterrupt;
    LARGE_INTEGER SystemTime;

    //
    // Set time timer state to not inserted and the signal state to signaled.
    //

    RequestInterrupt = FALSE;
    Timer->Header.Inserted = FALSE;
    Timer->Header.SignalState = 1;

    //
    // Capture the DPC and period fields from the timer object. Once wait
    // test is called, the timer must not be touched again unless it is
    // periodic. The reason for this is that a thread may allocate a timer
    // on its local stack and wait on it. Wait test can cause that thread
    // to immediately start running on another processor on an MP system.
    // If the thread returns, then the timer will be corrupted.
    // 

    Dpc = Timer->Dpc;
    Period = Timer->Period;
    if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
        if (Timer->Header.Type == TimerNotificationObject) {
            KiWaitTestWithoutSideEffects(Timer, TIMER_EXPIRE_INCREMENT);

        } else {
            KiWaitTestSynchronizationObject(Timer, TIMER_EXPIRE_INCREMENT);
        }
    }

    //
    // If the timer is periodic, then compute the next interval time and
    // reinsert the timer in the timer tree.
    //
    // N.B. Even though the timer insertion is relative, it can still fail
    //      if the period of the timer elapses in between computing the time
    //      and inserting the timer. If this happens, then the insertion is
    //      retried.
    //

    if (Period != 0) {
        Interval.QuadPart = Int32x32To64(Period, - 10 * 1000);
        do {
        } while (KiInsertTreeTimer(Timer, Interval) == FALSE);
    }

    //
    // If a DPC is specified, then insert it in the target processor's DPC
    // queue or capture the parameters in the DPC table for subsequent
    // execution on the current processor.
    //
    // N.B. A dispatch interrupt must be forced on the current processor,
    //      however, this will occur very infrequently.
    //

    if (Dpc != NULL) {
        KiQuerySystemTime(&SystemTime);
        KeInsertQueueDpc(Dpc,
                         ULongToPtr(SystemTime.LowPart),
                         ULongToPtr(SystemTime.HighPart));

        RequestInterrupt = TRUE;
    }

    return RequestInterrupt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\waitsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    waitsup.c

Abstract:

    This module contains the support routines necessary to support the
    generic kernel wait functions. Functions are provided to test if a
    wait can be satisfied, to satisfy a wait, and to unwwait a thread.

--*/

#include "ki.h"

VOID
FASTCALL
KiExitDispatcher (
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function processes the deferred ready list, possibly switches to
    a new thread, and lowers IRQL to its previous value.

Arguments:

    OldIrql - Supplies the previous IRQL value.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    PKTHREAD NewThread;
    BOOLEAN Pending;
    PKPRCB Prcb;

    ASSERT(KeGetCurrentIrql() == SYNCH_LEVEL);

    //
    // Process the deferred ready list if the list is not empty.
    //

    Prcb = KeGetCurrentPrcb();

#if !defined(NT_UP)

    if (Prcb->DeferredReadyListHead.Next != NULL) {
        KiProcessDeferredReadyList(Prcb);
    }

#endif

    //
    // If the old IRQL is less than dispatch level, then a new thread can
    // be dispatcher immediately.
    //

    if (OldIrql < DISPATCH_LEVEL) {

        //
        // If there is a new thread selected for execution, then switch
        // context to the new thread.
        //

        if (Prcb->NextThread != NULL) {
            KiAcquirePrcbLock(Prcb);
            NewThread = Prcb->NextThread;
            CurrentThread = Prcb->CurrentThread;
            KiSetContextSwapBusy(CurrentThread);
            Prcb->NextThread = NULL;
            Prcb->CurrentThread = NewThread;
            NewThread->State = Running;
            KxQueueReadyThread(CurrentThread, Prcb);
            CurrentThread->WaitIrql = OldIrql;
            Pending = KiSwapContext(CurrentThread, NewThread);
            if (Pending != FALSE) {
                KeLowerIrql(APC_LEVEL);
                KiDeliverApc(KernelMode, NULL, NULL);
    
                ASSERT(OldIrql == 0);
            }
        }

    } else if ((Prcb->NextThread != NULL) &&
               (Prcb->DpcRoutineActive == FALSE)) {

        KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
    }

    //
    // Lower IRQL to its previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

VOID
FASTCALL
KiUnwaitThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function unwaits a thread, sets the thread's wait completion status,
    calculates the thread's new priority, and either readies the thread for
    execution or adds the thread to a list of threads to be readied later.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    WaitStatus - Supplies the wait completion status.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    //
    // Unlink thread from the appropriate wait queues and set the wait
    // completion status.
    //

    KiUnlinkThread(Thread, WaitStatus);

    //
    // Set unwait priority adjustment parameters.
    //

    ASSERT(Increment >= 0);

    Thread->AdjustIncrement = (SCHAR)Increment;
    Thread->AdjustReason = (UCHAR)AdjustUnwait;

    //
    // Ready the thread for execution.
    //

    KiReadyThread(Thread);
    return;
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function tests if a wait can be satisfied when an object attains
    a state of signaled. If a wait can be satisfied, then the subject thread
    is unwaited with a completion status that is the WaitKey of the wait
    block from the object wait list. As many waits as possible are satisfied.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

Return Value:

    None.

--*/

{

    PKEVENT Event;
    PLIST_ENTRY ListHead;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;
    NTSTATUS WaitStatus;

    //
    // As long as the signal state of the specified object is Signaled and
    // there are waiters in the object wait list, then try to satisfy a wait.
    //

    Event = (PKEVENT)Object;
    ListHead = &Event->Header.WaitListHead;
    WaitEntry = ListHead->Flink;
    while ((Event->Header.SignalState > 0) &&
           (WaitEntry != ListHead)) {

        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;
        WaitStatus = STATUS_KERNEL_APC;

        //
        // N.B. The below code only satisfies the wait for wait any types.
        //      Wait all types are satisfied in the wait code itself. This
        //      is done with a eye to the future when the dispatcher lock is
        //      split into a lock per waitable object type and a scheduling
        //      state lock. For now, a kernel APC is simulated for wait all
        //      types.
        //

        if (WaitBlock->WaitType == WaitAny) {
            WaitStatus = (NTSTATUS)WaitBlock->WaitKey;
            KiWaitSatisfyAny((PKMUTANT)Event, Thread);
        }

        KiUnwaitThread(Thread, WaitStatus, Increment);
        WaitEntry = ListHead->Flink;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\thredobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    threadobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel thread object. Functions are provided to initialize, ready,
    alert, test alert, boost priority, enable APC queuing, disable APC
    queuing, confine, set affinity, set priority, suspend, resume, alert
    resume, terminate, read thread state, freeze, unfreeze, query data
    alignment handling mode, force resume, and enter and leave critical
    regions for thread objects.

--*/

#include "ki.h"

#pragma alloc_text(INIT, KeInitializeThread)
#pragma alloc_text(PAGE, KeInitThread)
#pragma alloc_text(PAGE, KeUninitThread)

NTSTATUS
KeInitThread (
    __out PKTHREAD Thread,
    __in_opt PVOID KernelStack,
    __in PKSYSTEM_ROUTINE SystemRoutine,
    __in_opt PKSTART_ROUTINE StartRoutine,
    __in_opt PVOID StartContext,
    __in_opt PCONTEXT ContextFrame,
    __in_opt PVOID Teb,
    __in PKPROCESS Process
    )

/*++

Routine Description:

    This function initializes a thread object. The priority, affinity,
    and initial quantum are taken from the parent process object.

    N.B. This routine is carefully written so that if an access violation
        occurs while reading the specified context frame, then no kernel
        data structures will have been modified. It is the responsibility
        of the caller to handle the exception and provide necessary clean
        up.

    N.B. It is assumed that the thread object is zeroed.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelStack - Supplies a pointer to the base of a kernel stack on which
        the context frame for the thread is to be constructed.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextFrame - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

    Teb - Supplies an optional pointer to the user mode thread environment
        block. This parameter is specified if the thread is a user thread and
        will execute in user mode. This parameter is ignored if the ContextFrame
        parameter is not specified.

    Process - Supplies a pointer to a control object of type process.

Return Value:

    None.

--*/

{

    LONG Index;
    BOOLEAN KernelStackAllocated = FALSE;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;

    //
    // Initialize the standard dispatcher object header and set the initial
    // state of the thread object.
    //

    Thread->Header.Type = ThreadObject;
    Thread->Header.Size = sizeof(KTHREAD) / sizeof(LONG);
    InitializeListHead(&Thread->Header.WaitListHead);

    //
    // Initialize the owned mutant listhead.
    //

    InitializeListHead(&Thread->MutantListHead);

    //
    // Initialize the thread field of all builtin wait blocks.
    //

    for (Index = 0; Index < (THREAD_WAIT_OBJECTS + 1); Index += 1) {
        Thread->WaitBlock[Index].Thread = Thread;
    }

    //
    // Initialize the alerted, preempted, debugactive, autoalignment,
    // kernel stack resident, enable kernel stack swap, and process
    // ready queue boolean values.
    //
    // N.B. Only nonzero values are initialized.
    //

    Thread->AutoAlignment = Process->AutoAlignment;
    Thread->EnableStackSwap = TRUE;
    Thread->KernelStackResident = TRUE;
    Thread->SwapBusy = FALSE;

    //
    // Initialize the thread lock and priority adjustment reason.
    //

    KeInitializeSpinLock(&Thread->ThreadLock);
    Thread->AdjustReason = AdjustNone;

    //
    // Set the system service table pointer to the address of the static
    // system service descriptor table. If the thread is later converted
    // to a Win32 thread this pointer will be change to a pointer to the
    // shadow system service descriptor table.
    //

#if defined(_AMD64_)

    Thread->ServiceTable = KeServiceDescriptorTable[SYSTEM_SERVICE_INDEX].Base;
    Thread->KernelLimit = KeServiceDescriptorTable[SYSTEM_SERVICE_INDEX].Limit;

#else

    Thread->ServiceTable = (PVOID)&KeServiceDescriptorTable[0];

#endif

    //
    // Initialize the APC state pointers, the current APC state, the saved
    // APC state, and enable APC queuing.
    //

    Thread->ApcStatePointer[0] = &Thread->ApcState;
    Thread->ApcStatePointer[1] = &Thread->SavedApcState;
    InitializeListHead(&Thread->ApcState.ApcListHead[KernelMode]);
    InitializeListHead(&Thread->ApcState.ApcListHead[UserMode]);
    Thread->ApcState.Process = Process;
    Thread->Process = Process;
    Thread->ApcQueueable = TRUE;

    //
    // Initialize the kernel mode suspend APC and the suspend semaphore object.
    // and the builtin wait timeout timer object.
    //

    KeInitializeApc(&Thread->SuspendApc,
                    Thread,
                    OriginalApcEnvironment,
                    (PKKERNEL_ROUTINE)KiSuspendNop,
                    (PKRUNDOWN_ROUTINE)KiSuspendRundown,
                    KiSuspendThread,
                    KernelMode,
                    NULL);

    KeInitializeSemaphore(&Thread->SuspendSemaphore, 0L, 2L);

    //
    // Initialize the builtin timer wait block.
    //
    // N.B. This is the only time the wait block is initialized since this
    //      information is constant.
    //

    Timer = &Thread->Timer;
    KeInitializeTimer(Timer);
    WaitBlock = &Thread->WaitBlock[TIMER_WAIT_BLOCK];
    WaitBlock->Object = Timer;
    WaitBlock->WaitKey = (CSHORT)STATUS_TIMEOUT;
    WaitBlock->WaitType = WaitAny;
    WaitBlock->WaitListEntry.Flink = &Timer->Header.WaitListHead;
    WaitBlock->WaitListEntry.Blink = &Timer->Header.WaitListHead;

    //
    // Initialize the APC queue spinlock.
    //

    KeInitializeSpinLock(&Thread->ApcQueueLock);

    //
    // Initialize the Thread Environment Block (TEB) pointer (can be NULL).
    //

    Thread->Teb = Teb;

    //
    // Allocate a kernel stack if necessary and set the initial kernel stack,
    // stack base, and stack limit.
    //

    if (KernelStack == NULL) {
        KernelStack = MmCreateKernelStack(FALSE, Process->IdealNode);
        if (KernelStack == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KernelStackAllocated = TRUE;
    }

    Thread->InitialStack = KernelStack;
    Thread->StackBase = KernelStack;
    Thread->StackLimit = (PVOID)((ULONG_PTR)KernelStack - KERNEL_STACK_SIZE);

    //
    // Initialize the thread context.
    //

    try {
        KiInitializeContextThread(Thread,
                                  SystemRoutine,
                                  StartRoutine,
                                  StartContext,
                                  ContextFrame);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        if (KernelStackAllocated) {
            MmDeleteKernelStack(Thread->StackBase, FALSE);
            Thread->InitialStack = NULL;
        }

        return GetExceptionCode();
    }

    //
    // Set the base thread priority, the thread priority, the thread affinity,
    // the thread quantum, and the scheduling state.
    //

    Thread->State = Initialized;
    return STATUS_SUCCESS;
}

VOID
KeUninitThread (
    __inout PKTHREAD Thread
    )

/*++

Routine Description:

    This function frees the thread kernel stack and must be called before
    the thread is started.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.
--*/

{

    MmDeleteKernelStack(Thread->StackBase, FALSE);
    Thread->InitialStack = NULL;
    return;
}

VOID
KeStartThread (
    __inout PKTHREAD Thread
    )

/*++

Routine Description:

    This function initializes remaining thread fields and inserts the thread
    in the thread's process list. From this point on the thread must run.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

#if defined(_AMD64_)

    KLOCK_QUEUE_HANDLE ListHandle;

#endif

    KLOCK_QUEUE_HANDLE LockHandle;
    PKPROCESS Process;

#if !defined(NT_UP)

    ULONG IdealProcessor;
    KAFFINITY PreferredSet;

#if defined(NT_SMT)

    KAFFINITY TempSet;

#endif

#endif

    //
    // Set thread disable boost and IOPL.
    //

    Process = Thread->ApcState.Process;
    Thread->DisableBoost = Process->DisableBoost;

#if defined(_X86_)

    Thread->Iopl = Process->Iopl;

#endif

    //
    // Initialize the thread quantum and set system affinity false.
    //

    Thread->Quantum = Process->QuantumReset;
    Thread->QuantumReset = Process->QuantumReset;
    Thread->SystemAffinityActive = FALSE;

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the process lock.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock, &LockHandle);

    //
    // Set the thread priority and affinity.
    //

    Thread->BasePriority = Process->BasePriority;
    Thread->Priority = Thread->BasePriority;
    Thread->Affinity = Process->Affinity;
    Thread->UserAffinity = Process->Affinity;

    //
    // Initialize the ideal processor number and node for the thread.
    //
    // N.B. It is guaranteed that the process affinity intersects the process
    //      ideal node affinity.
    //

#if defined(NT_UP)

    Thread->IdealProcessor = 0;
    Thread->UserIdealProcessor = 0;

#else

    //
    // Initialize the ideal processor number.
    //
    // N.B. It is guaranteed that the process affinity intersects the process
    //      ideal node affinity.
    //
    // N.B. The preferred set, however, must be reduced by the process affinity.
    //

    IdealProcessor = Process->ThreadSeed;
    PreferredSet = KeNodeBlock[Process->IdealNode]->ProcessorMask & Process->Affinity;

    //
    // If possible bias the ideal processor to a different SMT set than the
    // last thread.
    //

#if defined(NT_SMT)

    TempSet = ~KiProcessorBlock[IdealProcessor]->MultiThreadProcessorSet;
    if ((PreferredSet & TempSet) != 0) {
        PreferredSet &= TempSet;
    }

#endif

    //
    // Find an ideal processor for thread and update the process thread seed.
    //

    IdealProcessor = KeFindNextRightSetAffinity(IdealProcessor, PreferredSet);
    Process->ThreadSeed = (UCHAR)IdealProcessor;

    ASSERT((Thread->UserAffinity & AFFINITY_MASK(IdealProcessor)) != 0);

    Thread->UserIdealProcessor = (UCHAR)IdealProcessor;
    Thread->IdealProcessor = (UCHAR)IdealProcessor;

#endif

    //
    // If the thread is the first entry in the process thread list and the
    // process is not the idle process, then insert the process in the kernel
    // process list.
    //

#if defined(_AMD64_)

    if ((IsListEmpty(&Process->ThreadListHead) == TRUE) &&
        (Process != &KiInitialProcess.Pcb)) {

        KeAcquireInStackQueuedSpinLockAtDpcLevel(&KiProcessListLock,
                                                 &ListHandle);

        InsertTailList(&KiProcessListHead, &Process->ProcessListEntry);
        KeReleaseInStackQueuedSpinLockFromDpcLevel(&ListHandle);
    }

#endif

    //
    // Lock the dispatcher database.
    //

    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Insert the thread in the process thread list and increment the kernel
    // stack count.
    //
    // N.B. The process is not swappable until its first thread has been
    //      initialized.
    //

    InsertTailList(&Process->ThreadListHead, &Thread->ThreadListEntry);

    ASSERT(Process->StackCount != MAXULONG_PTR);

    Process->StackCount += 1;

    //
    // Unlock the dispatcher database, release the process lock, and lower
    // IRQL to its previous value.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return;
}

NTSTATUS
KeInitializeThread (
    __out PKTHREAD Thread,
    __in_opt PVOID KernelStack,
    __in PKSYSTEM_ROUTINE SystemRoutine,
    __in_opt PKSTART_ROUTINE StartRoutine,
    __in_opt PVOID StartContext,
    __in_opt PCONTEXT ContextFrame,
    __in_opt PVOID Teb,
    __in PKPROCESS Process
    )

/*++

Routine Description:

    This function initializes a thread object. The priority, affinity,
    and initial quantum are taken from the parent process object. The
    thread object is inserted at the end of the thread list for the
    parent process.

    N.B. This routine is carefully written so that if an access violation
        occurs while reading the specified context frame, then no kernel
        data structures will have been modified. It is the responsibility
        of the caller to handle the exception and provide necessary clean
        up.

    N.B. It is assumed that the thread object is zeroed.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelStack - Supplies a pointer to the base of a kernel stack on which
        the context frame for the thread is to be constructed.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextFrame - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

    Teb - Supplies an optional pointer to the user mode thread environment
        block. This parameter is specified if the thread is a user thread and
        will execute in user mode. This parameter is ignored if the ContextFrame
        parameter is not specified.

    Process - Supplies a pointer to a control object of type process.

Return Value:

    NTSTATUS - Status of operation

--*/

{

    NTSTATUS Status;

    Status = KeInitThread(Thread,
                          KernelStack,
                          SystemRoutine,
                          StartRoutine,
                          StartContext,
                          ContextFrame,
                          Teb,
                          Process);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    KeStartThread(Thread);
    return STATUS_SUCCESS;
}

BOOLEAN
KeAlertThread (
    __inout PKTHREAD Thread,
    __in KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function attempts to alert a thread and cause its execution to
    be continued if it is currently in an alertable Wait state. Otherwise
    it just sets the alerted variable for the specified processor mode.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    AlertMode - Supplies the processor mode for which the thread is
        to be alerted.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KLOCK_QUEUE_HANDLE LockHandle;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // Capture the current state of the alerted variable for the specified
    // processor mode.
    //

    Alerted = Thread->Alerted[AlertMode];

    //
    // If the alerted state for the specified processor mode is Not-Alerted,
    // then attempt to alert the thread.
    //

    if (Alerted == FALSE) {

        //
        // If the thread is currently in a Wait state, the Wait is alertable,
        // and the specified processor mode is less than or equal to the Wait
        // mode, then the thread is unwaited with a status of "alerted".
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE) &&
            (AlertMode <= Thread->WaitMode)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT);

        } else {
            Thread->Alerted[AlertMode] = TRUE;
        }
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, release the thread
    // APC queue lock, exit the scheduler, and return the previous alerted
    // state for the specified mode.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return Alerted;
}

ULONG
KeAlertResumeThread (
    __inout PKTHREAD Thread
    )

/*++

Routine Description:

    This function attempts to alert a thread in kernel mode and cause its
    execution to be continued if it is currently in an alertable Wait state.
    In addition, a resume operation is performed on the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG OldCount;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the thread APC queue lock, and lock
    // the dispatcher database.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);
    KiLockDispatcherDatabaseAtSynchLevel();

    //
    // If the kernel mode alerted state is FALSE, then attempt to alert
    // the thread for kernel mode.
    //

    if (Thread->Alerted[KernelMode] == FALSE) {

        //
        // If the thread is currently in a Wait state and the Wait is alertable,
        // then the thread is unwaited with a status of "alerted". Else set the
        // kernel mode alerted variable.
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT);

        } else {
            Thread->Alerted[KernelMode] = TRUE;
        }
    }

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero and the freeze count is
        // zero, then resume the thread by releasing its suspend semaphore.
        //

        if ((Thread->SuspendCount == 0) && (Thread->FreezeCount == 0)) {
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        }
    }

    //
    // Unlock the dispatcher database from SYNCH_LEVEL, release the thread
    // APC queue lock, exit the scheduler, and return the previous suspend
    // count.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return OldCount;
}

VOID
KeBoostPriorityThread (
    __inout PKTHREAD Thread,
    __in KPRIORITY Increment
    )

/*++

Routine Description:

    This function boosts the priority of the specified thread using the
    same algorithm used when a thread gets a boost from a wait operation.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the thread does not run at a realtime priority level, then boost
    // the thread priority.
    //

    if (Thread->Priority < LOW_REALTIME_PRIORITY) {
        KiBoostPriorityThread(Thread, Increment);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

ULONG
KeForceResumeThread (
    __inout PKTHREAD Thread
    )

/*++

Routine Description:

    This function forces resumption of thread execution if the thread is
    suspended. If the specified thread is not suspended, then no operation
    is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The sum of the previous suspend count and the freeze count.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG OldCount;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the thread APC queue lock.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                               &LockHandle);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount + Thread->FreezeCount;

    //
    // If the thread is currently suspended, then force resumption of
    // thread execution.
    //

    if (OldCount != 0) {
        Thread->FreezeCount = 0;
        Thread->SuspendCount = 0;
        KiLockDispatcherDatabaseAtSynchLevel();
        Thread->SuspendSemaphore.Header.SignalState += 1;
        KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        KiUnlockDispatcherDatabaseFromSynchLevel();
    }

    //
    // Unlock he thread APC queue lock, exit the scheduler, and return the
    // previous suspend count.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return OldCount;
}

VOID
KeFreezeAllThreads (
    VOID
    )

/*++

Routine Description:

    This function suspends the execution of all thread in the current
    process except the current thread. If the freeze count overflows
    the maximum suspend count, then a condition is raised.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PKPROCESS Process;
    KLOCK_QUEUE_HANDLE ProcessHandle;
    PKTHREAD Thread;
    KLOCK_QUEUE_HANDLE ThreadHandle;
    ULONG OldCount;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Set the address of the current thread object and the current process
    // object.
    //

    CurrentThread = KeGetCurrentThread();
    Process = CurrentThread->ApcState.Process;

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the process lock.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock,
                                               &ProcessHandle);

    //
    // If the freeze count of the current thread is not zero, then there
    // is another thread that is trying to freeze this thread. Unlock the
    // the process lock and lower IRQL to its previous value, allow the
    // suspend APC to occur, then raise IRQL to SYNCH_LEVEL and lock the
    // process lock.
    //

    while (CurrentThread->FreezeCount != 0) {
        KeReleaseInStackQueuedSpinLock(&ProcessHandle);
        KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock,
                                                   &ProcessHandle);
    }

    KeEnterCriticalRegion();

    //
    // Freeze all threads except the current thread.
    //

    ListHead = &Process->ThreadListHead;
    NextEntry = ListHead->Flink;
    do {

        //
        // Get the address of the next thread.
        //

        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

        //
        // Acquire the thread APC queue lock.
        //

        KeAcquireInStackQueuedSpinLockAtDpcLevel(&Thread->ApcQueueLock,
                                                 &ThreadHandle);

        //
        // If the thread is not the current thread and APCs are queueable,
        // then attempt to suspend the thread.
        //

        if ((Thread != CurrentThread) && (Thread->ApcQueueable == TRUE)) {

            //
            // Increment the freeze count. If the thread was not previously
            // suspended, then queue the thread's suspend APC.
            //
            // N.B. The APC MUST be queued using the internal interface so
            //      the system argument fields of the APC do not get written.
            //

            OldCount = Thread->FreezeCount;

            ASSERT(OldCount != MAXIMUM_SUSPEND_COUNT);

            Thread->FreezeCount += 1;
            if ((OldCount == 0) && (Thread->SuspendCount == 0)) {
                if (Thread->SuspendApc.Inserted == TRUE) {
                    KiLockDispatcherDatabaseAtSynchLevel();
                    Thread->SuspendSemaphore.Header.SignalState -= 1;
                    KiUnlockDispatcherDatabaseFromSynchLevel();

                } else {
                    Thread->SuspendApc.Inserted = TRUE;
                    KiInsertQueueApc(&Thread->SuspendApc, RESUME_INCREMENT);
                }
            }
        }

        //
        // Release the thread APC queue lock.
        //

        KeReleaseInStackQueuedSpinLockFromDpcLevel(&ThreadHandle);
        NextEntry = NextEntry->Flink;
    } while (NextEntry != ListHead);

    //
    // Release the process lock and exit the scheduler.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&ProcessHandle);
    KiExitDispatcher(ProcessHandle.OldIrql);
    return;
}

LOGICAL
KeQueryAutoAlignmentThread (
    __in PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the data alignment handling mode for the specified
    thread.

Arguments:

    None.

Return Value:

    A value of TRUE is returned if data alignment exceptions are being
    automatically handled by the kernel. Otherwise, a value of FALSE
    is returned.

--*/

{

    ASSERT_THREAD(Thread);

    return Thread->AutoAlignment;
}

LONG
KeQueryBasePriorityThread (
    __in PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the base priority increment of the specified
    thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The base priority increment of the specified thread.

--*/

{

    LONG Increment;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH level and acquire the thread lock.
    //

    Process = Thread->Process;
    OldIrql = KeRaiseIrqlToSynchLevel();
    KiAcquireThreadLock(Thread);

    //
    // If priority saturation occured the last time the thread base priority
    // was set, then return the saturation increment value. Otherwise, compute
    // the increment value as the difference between the thread base priority
    // and the process base priority.
    //
           
    Increment = Thread->BasePriority - Process->BasePriority;
    if (Thread->Saturation != 0) {
        Increment = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    //
    // Release the thread lock, lower IRQL to its previous value, and
    // return the previous thread base priority increment.
    //

    KiReleaseThreadLock(Thread);
    KeLowerIrql(OldIrql);
    return Increment;
}

KPRIORITY
KeQueryPriorityThread (
    __in PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the current priority of the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The current priority of the specified thread.

--*/

{

    ASSERT_THREAD(Thread);

    return Thread->Priority;
}

ULONG
KeQueryRuntimeThread (
    __in PKTHREAD Thread,
    __out PULONG UserTime
    )

/*++

Routine Description:

    This function returns the kernel and user runtime for the specified
    thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    UserTime - Supplies a pointer to a variable that receives the user
        runtime for the specified thread.

Return Value:

    The kernel runtime for the specfied thread is returned.

--*/

{

    ASSERT_THREAD(Thread);

    *UserTime = Thread->UserTime;
    return Thread->KernelTime;
}

BOOLEAN
KeReadStateThread (
    __in PKTHREAD Thread
    )

/*++

Routine Description:

    This function reads the current signal state of a thread object.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The current signal state of the thread object.

--*/

{

    ASSERT_THREAD(Thread);

    //
    // Return current signal state of thread object.
    //

    return (BOOLEAN)Thread->Header.SignalState;
}

VOID
KeReadyThread (
    __inout PKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution. If the thread's process
    is currently not in the balance set, then the thread is inserted in the
    thread's process' ready queue. Else if the thread is higher priority than
    another thread that is currently running on a processor then the thread
    is selected for execution on that processor. Else the thread is inserted
    in the dispatcher ready queue selected by its priority.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, ready the
    // specified thread for execution, unlock the dispatcher database, and
    // lower IRQL to its previous value.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiReadyThread(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

ULONG
KeResumeThread (
    __inout PKTHREAD Thread
    )

/*++

Routine Description:

    This function resumes the execution of a suspended thread. If the
    specified thread is not suspended, then no operation is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG OldCount;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and lock the thread APC queue.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                               &LockHandle);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero and the freeze count is
        // zero, then resume the thread by releasing its suspend semaphore.
        //

        if ((Thread->SuspendCount == 0) && (Thread->FreezeCount == 0)) {
            KiLockDispatcherDatabaseAtSynchLevel();
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
            KiUnlockDispatcherDatabaseFromSynchLevel();
        }
    }

    //
    // Release the thread APC queue, exit the scheduler, and return the
    // previous suspend count.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return OldCount;
}

VOID
KeRevertToUserAffinityThread (
    VOID
    )

/*++

Routine Description:

    This function setss the affinity of the current thread to its user
    affinity.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;
    PKTHREAD NewThread;
    KIRQL OldIrql;
    PKPRCB Prcb;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    CurrentThread = KeGetCurrentThread();

    ASSERT(CurrentThread->SystemAffinityActive != FALSE);

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Set the current affinity to the user affinity and the ideal processor
    // to the user ideal processor.
    //

    CurrentThread->Affinity = CurrentThread->UserAffinity;

#if !defined(NT_UP)

    CurrentThread->IdealProcessor = CurrentThread->UserIdealProcessor;

#endif

    CurrentThread->SystemAffinityActive = FALSE;

    //
    // If the current processor is not in the new affinity set and another
    // thread has not already been selected for execution on the current
    // processor, then select a new thread for the current processor.
    //

    Prcb = KeGetCurrentPrcb();
    if ((Prcb->SetMember & CurrentThread->Affinity) == 0) {
        KiAcquirePrcbLock(Prcb);
        if (Prcb->NextThread == NULL) {
            NewThread = KiSelectNextThread(Prcb);
            NewThread->State = Standby;
            Prcb->NextThread = NewThread;
        }

        KiReleasePrcbLock(Prcb);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

VOID
KeRundownThread (
    VOID
    )

/*++

Routine Description:

    This function is called by the executive to rundown thread structures
    which must be guarded by the dispatcher database lock and which must
    be processed before actually terminating the thread. An example of such
    a structure is the mutant ownership list that is anchored in the kernel
    thread object.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKMUTANT Mutant;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the mutant list is empty, then return immediately.
    //

    Thread = KeGetCurrentThread();
    if (IsListEmpty(&Thread->MutantListHead)) {
        return;
    }

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Scan the list of owned mutant objects and release the mutant objects
    // with an abandoned status. If the mutant is a kernel mutex, then bugcheck.
    //

    NextEntry = Thread->MutantListHead.Flink;
    while (NextEntry != &Thread->MutantListHead) {
        Mutant = CONTAINING_RECORD(NextEntry, KMUTANT, MutantListEntry);
        if (Mutant->ApcDisable != 0) {
            KeBugCheckEx(THREAD_TERMINATE_HELD_MUTEX,
                         (ULONG_PTR)Thread,
                         (ULONG_PTR)Mutant, 0, 0);
        }

        RemoveEntryList(&Mutant->MutantListEntry);
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;
        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) != TRUE) {
            KiWaitTest(Mutant, MUTANT_INCREMENT);
        }

        NextEntry = Thread->MutantListHead.Flink;
    }

    //
    // Release dispatcher database lock and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

KAFFINITY
KeSetAffinityThread (
    __inout PKTHREAD Thread,
    __in KAFFINITY Affinity
    )

/*++

Routine Description:

    This function sets the affinity of a specified thread to a new value.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Affinity - Supplies the new of set of processors on which the thread
        can run.

Return Value:

    The previous affinity of the specified thread.

--*/

{

    KAFFINITY OldAffinity;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Set the thread affinity to the specified value.
    //

    OldAffinity = KiSetAffinityThread(Thread, Affinity);

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous user affinity.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldAffinity;
}

VOID
KeSetSystemAffinityThread (
    __in KAFFINITY Affinity
    )

/*++

Routine Description:

    This function set the system affinity of the current thread.

Arguments:

    Affinity - Supplies the new of set of processors on which the thread
        can run.

Return Value:

    None.

--*/

{

    PKTHREAD CurrentThread;

#if !defined(NT_UP)

    ULONG IdealProcessor;
    PKNODE Node;
    KAFFINITY TempSet;

#endif

    PKTHREAD NewThread;
    KIRQL OldIrql;
    PKPRCB Prcb;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT((Affinity & KeActiveProcessors) != 0);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    CurrentThread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Set the current affinity to the specified affinity and set system
    // affinity active.
    //

    CurrentThread->Affinity = Affinity;
    CurrentThread->SystemAffinityActive = TRUE;

    //
    // If the ideal processor is not a member of the new affinity set, then
    // recompute the ideal processor.
    //
    // N.B. System affinity is only set temporarily, and therefore, the
    //      ideal processor is set to a convenient value if it is not
    //      already a member of the new affinity set.
    //

#if !defined(NT_UP)

    if ((Affinity & AFFINITY_MASK(CurrentThread->IdealProcessor)) == 0) {
        TempSet = Affinity & KeActiveProcessors;
        Node = KiProcessorBlock[CurrentThread->IdealProcessor]->ParentNode;
        if ((TempSet & Node->ProcessorMask) != 0) {
            TempSet &= Node->ProcessorMask;
        }

        KeFindFirstSetLeftAffinity(TempSet, &IdealProcessor);
        CurrentThread->IdealProcessor = (UCHAR)IdealProcessor;
    }

#endif

    //
    // If the current processor is not in the new affinity set and another
    // thread has not already been selected for execution on the current
    // processor, then select a new thread for the current processor.
    //

    Prcb = KeGetCurrentPrcb();
    if ((Prcb->SetMember & CurrentThread->Affinity) == 0) {
        KiAcquirePrcbLock(Prcb);
        if (Prcb->NextThread == NULL) {
            NewThread = KiSelectNextThread(Prcb);
            NewThread->State = Standby;
            Prcb->NextThread = NewThread;
        }

        KiReleasePrcbLock(Prcb);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

LONG
KeSetBasePriorityThread (
    __inout PKTHREAD Thread,
    __in LONG Increment
    )

/*++

Routine Description:

    This function sets the base priority of the specified thread to a
    new value.  The new base priority for the thread is the process base
    priority plus the increment.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the base priority increment of the subject thread.

        N.B. If the absolute value of the increment is such that saturation
             of the base priority is forced, then subsequent changes to the
             parent process base priority will not change the base priority
             of the thread.

Return Value:

    The previous base priority increment of the specified thread.

--*/

{

    KPRIORITY NewBase;
    KPRIORITY NewPriority;
    KPRIORITY OldBase;
    LONG OldIncrement;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    Process = Thread->Process;
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Acquire the thread lock, capture the base priority of the specified
    // thread, and determine whether saturation if being forced.
    //

    KiAcquireThreadLock(Thread);
    OldBase = Thread->BasePriority;
    OldIncrement = OldBase - Process->BasePriority;
    if (Thread->Saturation != 0) {
        OldIncrement = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    Thread->Saturation = FALSE;
    if (abs(Increment) >= (HIGH_PRIORITY + 1) / 2) {
        Thread->Saturation = (Increment > 0) ? 1 : -1;
    }

    //
    // Set the base priority of the specified thread. If the thread's process
    // is in the realtime class, then limit the change to the realtime class.
    // Otherwise, limit the change to the variable class.
    //

    NewBase = Process->BasePriority + Increment;
    if (Process->BasePriority >= LOW_REALTIME_PRIORITY) {
        if (NewBase < LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY;

        } else if (NewBase > HIGH_PRIORITY) {
            NewBase = HIGH_PRIORITY;
        }

        //
        // Set the new priority of the thread to the new base priority.
        //

        NewPriority = NewBase;

    } else {
        if (NewBase >= LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY - 1;

        } else if (NewBase <= LOW_PRIORITY) {
            NewBase = 1;
        }

        //
        // Compute the new thread priority.
        //

        if (Thread->Saturation != 0) {
            NewPriority = NewBase;

        } else {

            //
            // Compute the new thread priority.
            //

            NewPriority = KiComputeNewPriority(Thread, 0);
            NewPriority += (NewBase - OldBase);
            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;

            } else if (NewPriority <= LOW_PRIORITY) {
                NewPriority = 1;
            }
        }
    }

    //
    // Set the new base priority and clear the priority decrement. If the
    // new priority is not equal to the old priority, then set the new thread
    // priority.
    //

    Thread->PriorityDecrement = 0;
    Thread->BasePriority = (SCHAR)NewBase;
    if (NewPriority != Thread->Priority) {
        Thread->Quantum = Thread->QuantumReset;
        KiSetPriorityThread(Thread, NewPriority);
    }

    //
    // Release the thread lock, unlock the dispatcher database, lower IRQL to
    // its previous value, and return the previous thread base priority.
    //

    KiReleaseThreadLock(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return OldIncrement;
}

LOGICAL
KeSetAutoAlignmentThread (
    __inout PKTHREAD Thread,
    __in LOGICAL Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    thread.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the specified thread.

Return Value:

    The previous value of auto alignment for the specified thread is returned
    as the function value.

--*/

{

    ASSERT_THREAD(Thread);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    if (Enable != FALSE) {
        return InterlockedBitTestAndSet(&Thread->ThreadFlags,
                                        KTHREAD_AUTO_ALIGNMENT_BIT);

    } else {
        return InterlockedBitTestAndReset(&Thread->ThreadFlags,
                                          KTHREAD_AUTO_ALIGNMENT_BIT);
    }
}

LOGICAL
KeSetDisableBoostThread (
    __inout PKTHREAD Thread,
    __in LOGICAL Disable
    )

/*++

Routine Description:

    This function sets the disable priority boost state for the specified
    thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Disable - Supplies a logical value that determines whether priority
        boosts are disabled or enabled.

Return Value:

    The previous value of the disable boost for the specfied thread is
    returned as the function value.

--*/

{

    ASSERT_THREAD(Thread);

    //
    // Capture the current state of the disable boost variable and set its
    // state to the specified value.
    //

    if (Disable != FALSE) {
        return InterlockedBitTestAndSet(&Thread->ThreadFlags,
                                        KTHREAD_DISABLE_BOOST_BIT);

    } else {
        return InterlockedBitTestAndReset(&Thread->ThreadFlags,
                                          KTHREAD_DISABLE_BOOST_BIT);
    }
}

UCHAR
KeSetIdealProcessorThread (
    __inout PKTHREAD Thread,
    __in UCHAR Processor
    )

/*++

Routine Description:

    This function sets the ideal processor for the specified thread execution.

    N.B. If the specified processor is less than the number of processors in
         the system and is a member of the specified thread's current affinity
         set, then the ideal processor is set. Otherwise, no operation is
         performed.

Arguments:

    Thread - Supplies a pointer to the thread whose ideal processor number is
        set to the specfied value.

    Processor - Supplies the number of the ideal processor.

Return Value:

    The previous ideal processor number.

--*/

{

    UCHAR OldProcessor;
    KIRQL OldIrql;

    ASSERT(Processor <= MAXIMUM_PROCESSORS);

    //
    // Raise IRQL, lock the dispatcher database, and capture the previous
    // ideal processor value.
    //

    KiLockDispatcherDatabase(&OldIrql);
    OldProcessor = Thread->UserIdealProcessor;

    //
    // If the specified processor is less than the number of processors in the
    // system and is a member of the specified thread's current affinity set,
    // then the ideal processor is set. Otherwise, no operation is performed.
    //

    if ((Processor < KeNumberProcessors) &&
        ((Thread->Affinity & AFFINITY_MASK(Processor)) != 0))  {

        Thread->IdealProcessor = Processor;
        if (Thread->SystemAffinityActive == FALSE) {
            Thread->UserIdealProcessor = Processor;
        }
    }

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous ideal processor.
    // 
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldProcessor;
}

BOOLEAN
KeSetKernelStackSwapEnable (
    __in BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the kernel stack swap enable value for the current
    thread and returns the old swap enable value.

Arguments:

    Enable - Supplies the new kernel stack swap enable value.

Return Value:

    The previous kernel stack swap enable value.

--*/

{

    BOOLEAN OldState;
    PKTHREAD Thread;

    //
    // Capture the previous kernel stack swap enable value, set the new
    // swap enable value, and return the old swap enable value for the
    // current thread;
    //

    Thread = KeGetCurrentThread();
    OldState = Thread->EnableStackSwap;
    Thread->EnableStackSwap = Enable;
    return OldState;
}

KPRIORITY
KeSetPriorityThread (
    __inout PKTHREAD Thread,
    __in KPRIORITY Priority
    )

/*++

Routine Description:

    This function sets the priority of the specified thread to a new value.
    If the new thread priority is lower than the old thread priority, then
    rescheduling may take place if the thread is currently running on, or
    about to run on, a processor.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new priority of the subject thread.

Return Value:

    The previous priority of the specified thread.

--*/

{

    KIRQL OldIrql;
    KPRIORITY OldPriority;

    ASSERT_THREAD(Thread);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT((Priority <= HIGH_PRIORITY) && (Priority >= LOW_PRIORITY));

    ASSERT(KeIsExecutingDpc() == FALSE);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //
    // Acquire the thread lock, capture the current thread priority, set the
    // thread priority to the the new value, and replenish the thread quantum.
    // It is assumed that the priority would not be set unless the thread had
    // already lost it initial quantum.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiAcquireThreadLock(Thread);
    OldPriority = Thread->Priority;
    Thread->PriorityDecrement = 0;
    if (Priority != Thread->Priority) {
        Thread->Quantum = Thread->QuantumReset;
        if ((Thread->BasePriority != 0) &&
            (Priority == 0)) {

            Priority = 1;
        }

        KiSetPriorityThread(Thread, Priority);
    }

    //
    // Release the thread lock, unlock the dispatcher database, lower IRQL to
    // its previous value, and return the previous thread priority.
    //

    KiReleaseThreadLock(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return OldPriority;
}

VOID
KeSetPriorityZeroPageThread (
    __in KPRIORITY Priority
    )

/*++

Routine Description:

    This function sets the priority and base priority of the current thread
    to a new value. If the new thread priority is lower than the old thread
    priority, then rescheduling may take place if the thread is currently
    running on, or about to run on, a processor.

    N.B. This function is for use only by memory managment to change the
         priority of the zero page thread.

    N.B. The priority can only to be set to a value of zero or one.

Arguments:

    Priority - Supplies the new priority of the subject thread.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    ASSERT((Priority == 0) || (Priority == 1));

    ASSERT(KeIsExecutingDpc() == FALSE);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //
    // Acquire the thread lock, capture the current thread priority, set the
    // thread priority to the the new value, and replenish the thread quantum.
    // It is assumed that the priority would not be set unless the thread had
    // already lost it initial quantum.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);
    KiAcquireThreadLock(Thread);
    Thread->BasePriority = (SCHAR)Priority;
    Thread->PriorityDecrement = 0;
    if (Priority != Thread->Priority) {
        Thread->Quantum = Thread->QuantumReset;
        KiSetPriorityThread(Thread, Priority);
    }

    //
    // Release the thread lock, unlock the dispatcher database, and lower
    // IRQL to its previous value.
    //

    KiReleaseThreadLock(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

ULONG
KeSuspendThread (
    __inout PKTHREAD Thread
    )

/*++

Routine Description:

    This function suspends the execution of a thread. If the suspend count
    overflows the maximum suspend count, then a condition is raised.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    KLOCK_QUEUE_HANDLE LockHandle;
    ULONG OldCount;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the thread APC queue lock.
    //

    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock, &LockHandle);

    //
    // Capture the current suspend count.
    //
    // If the suspend count is at its maximum value, then unlock the
    // dispatcher database, unlock the thread APC queue lock, lower IRQL
    // to its previous value, and raise an error condition.
    //

    OldCount = Thread->SuspendCount;
    if (OldCount == MAXIMUM_SUSPEND_COUNT) {
        KeReleaseInStackQueuedSpinLock(&LockHandle);
        ExRaiseStatus(STATUS_SUSPEND_COUNT_EXCEEDED);
    }

    //
    // Don't suspend the thread if APC queuing is disabled. In this case the
    // thread is being deleted.
    //

    if (Thread->ApcQueueable == TRUE) {

        //
        // Increment the suspend count. If the thread was not previously
        // suspended, then queue the thread's suspend APC.
        //
        // N.B. The APC MUST be queued using the internal interface so
        //      the system argument fields of the APC do not get written.
        //

        Thread->SuspendCount += 1;
        if ((OldCount == 0) && (Thread->FreezeCount == 0)) {
            if (Thread->SuspendApc.Inserted == TRUE) {
                KiLockDispatcherDatabaseAtSynchLevel();
                Thread->SuspendSemaphore.Header.SignalState -= 1;
                KiUnlockDispatcherDatabaseFromSynchLevel();

            } else {
                Thread->SuspendApc.Inserted = TRUE;
                KiInsertQueueApc(&Thread->SuspendApc, RESUME_INCREMENT);
            }
        }
    }

    //
    // Release the thread APC queue lock, exit the scheduler, and  return
    // the old count.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);
    KiExitDispatcher(LockHandle.OldIrql);
    return OldCount;
}

VOID
KeTerminateThread (
    __in KPRIORITY Increment
    )

/*++

Routine Description:

    This function terminates the execution of the current thread, sets the
    signal state of the thread to Signaled, and attempts to satisfy as many
    Waits as possible. The scheduling state of the thread is set to terminated,
    and a new thread is selected to run on the current processor. There is no
    return from this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if defined(_AMD64_)

    KLOCK_QUEUE_HANDLE ListHandle;

#endif

    PSINGLE_LIST_ENTRY ListHead;
    KLOCK_QUEUE_HANDLE LockHandle;
    PKPROCESS Process;
    PKQUEUE Queue;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Check if a kernel stack expand callout is active.
    //

#if defined(_AMD64_)

    KeCheckIfStackExpandCalloutActive();

#endif

    //
    // Raise IRQL to SYNCH_LEVEL, acquire the process lock, and set swap busy.
    //

    Thread = KeGetCurrentThread();
    Process = Thread->ApcState.Process;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock,
                                               &LockHandle);

    KiSetContextSwapBusy(Thread);

    //
    // If the thread is the last entry in the process thread list, then
    // remove the process from the kernel process list.
    //

#if defined(_AMD64_)

    if (Thread->ThreadListEntry.Flink == Thread->ThreadListEntry.Blink) {
        KeAcquireInStackQueuedSpinLockAtDpcLevel(&KiProcessListLock,
                                                 &ListHandle);

        RemoveEntryList(&Process->ProcessListEntry);
        KeReleaseInStackQueuedSpinLockFromDpcLevel(&ListHandle);
    }

#endif

    //
    // Sum the kernel and user time of the thread into the process kernel
    // and user times.
    //

    Process->KernelTime += Thread->KernelTime;
    Process->UserTime += Thread->UserTime;

    //
    // Sum the thread I/O statistics into the process I/O statistics.
    //

#if defined(_WIN64)

    ((PEPROCESS)Process)->ReadOperationCount.QuadPart += Thread->ReadOperationCount;
    ((PEPROCESS)Process)->WriteOperationCount.QuadPart += Thread->WriteOperationCount;
    ((PEPROCESS)Process)->OtherOperationCount.QuadPart += Thread->OtherOperationCount;
    ((PEPROCESS)Process)->ReadTransferCount.QuadPart += Thread->ReadTransferCount;
    ((PEPROCESS)Process)->WriteTransferCount.QuadPart += Thread->WriteTransferCount;
    ((PEPROCESS)Process)->OtherTransferCount.QuadPart += Thread->OtherTransferCount;

#endif

    //
    // Insert the thread in the reaper list.
    //
    // N.B. This code has knowledge of the reaper data structures and how
    //      worker threads are implemented.
    //

    ListHead = InterlockedPushEntrySingleList(&PsReaperListHead,
                                              (PSINGLE_LIST_ENTRY)&((PETHREAD)Thread)->ReaperLink);

    //
    // Acquire the dispatcher database and check if a reaper work item should
    // be queued.
    //

    KiLockDispatcherDatabaseAtSynchLevel();
    if (ListHead == NULL) {
        KiInsertQueue(&ExWorkerQueue[HyperCriticalWorkQueue].WorkerQueue,
                      &PsReaperWorkItem.List,
                      FALSE);
    }

    //
    // If the current thread is processing a queue entry, then remove
    // the thread from the queue object thread list and attempt to
    // activate another thread that is blocked on the queue object.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        RemoveEntryList(&Thread->QueueListEntry);
        KiActivateWaiterQueue(Queue);
    }

    //
    // Set the state of the current thread object to Signaled, and attempt
    // to satisfy as many Waits as possible.
    //

    Thread->Header.SignalState = TRUE;
    if (IsListEmpty(&Thread->Header.WaitListHead) != TRUE) {
        KiWaitTestWithoutSideEffects(Thread, Increment);
    }

    //
    // Remove thread from its parent process thread list. 
    //

    RemoveEntryList(&Thread->ThreadListEntry);

    //
    // Release the process lock, but don't lower the IRQL.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&LockHandle);

    //
    // Set thread scheduling state to terminated, decrement the process'
    // stack count, and initiate an outswap of the process if the stack
    // count is zero.
    //

    Thread->State = Terminated;

    ASSERT(Process->StackCount != 0);

    ASSERT(Process->State == ProcessInMemory);

    Process->StackCount -= 1;
    if ((Process->StackCount == 0) &&
        (IsListEmpty(&Process->ThreadListHead) == FALSE)) {

        Process->State = ProcessOutTransition;
        InterlockedPushEntrySingleList(&KiProcessOutSwapListHead,
                                       &Process->SwapListEntry);

        KiSetInternalEvent(&KiSwapEvent, KiSwappingThread);
    }

    //
    // Rundown any architectural specific structures
    //

    KiRundownThread(Thread);

    //
    // Unlock the dispatcher database and get off the processor for the last
    // time.
    //

    KiUnlockDispatcherDatabaseFromSynchLevel();
    KiSwapThread(Thread, KeGetCurrentPrcb());
    return;
}

BOOLEAN
KeTestAlertThread (
    __in KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function tests to determine if the alerted variable for the
    specified processor mode has a value of TRUE or whether a user mode
    APC should be delivered to the current thread.

Arguments:

    AlertMode - Supplies the processor mode which is to be tested
        for an alerted condition.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KLOCK_QUEUE_HANDLE LockHandle;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the thread APC queue lock.
    //

    Thread = KeGetCurrentThread();
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Thread->ApcQueueLock,
                                               &LockHandle);

    //
    // If the current thread is alerted for the specified processor mode,
    // then clear the alerted state. Else if the specified processor mode
    // is user and the current thread's user mode APC queue contains an
    // entry, then set user APC pending.
    //

    Alerted = Thread->Alerted[AlertMode];
    if (Alerted == TRUE) {
        Thread->Alerted[AlertMode] = FALSE;

    } else if ((AlertMode == UserMode) &&
              (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) != TRUE)) {

        Thread->ApcState.UserApcPending = TRUE;
    }

    //
    // Release the thread APC queue lock, lower IRQL to its previous value,
    // and return the previous alerted state for the specified mode.
    //

    KeReleaseInStackQueuedSpinLock(&LockHandle);
    return Alerted;
}

VOID
KeThawAllThreads (
    VOID
    )

/*++

Routine Description:

    This function resumes the execution of all suspended froozen threads
    in the current process.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    ULONG OldCount;
    PKPROCESS Process;
    KLOCK_QUEUE_HANDLE ProcessHandle;
    PKTHREAD Thread;
    KLOCK_QUEUE_HANDLE ThreadHandle;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the process lock.
    //

    Process = KeGetCurrentThread()->ApcState.Process;
    KeAcquireInStackQueuedSpinLockRaiseToSynch(&Process->ProcessLock,
                                               &ProcessHandle);

    //
    // Thaw the execution of all threads in the current process that have
    // been frozen.
    //

    ListHead = &Process->ThreadListHead;
    NextEntry = ListHead->Flink;
    do {

        //
        // Get the address of the next thread.
        //

        Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

        //
        // Acquire the thread APC queue lock.
        //

        KeAcquireInStackQueuedSpinLockAtDpcLevel(&Thread->ApcQueueLock,
                                                 &ThreadHandle);

        //
        // Thaw thread if its execution was previously froozen.
        //

        OldCount = Thread->FreezeCount;
        if (OldCount != 0) {
            Thread->FreezeCount -= 1;

            //
            // If the resultant suspend count is zero and the freeze count is
            // zero, then resume the thread by releasing its suspend semaphore.
            //

            if ((Thread->SuspendCount == 0) && (Thread->FreezeCount == 0)) {
                KiLockDispatcherDatabaseAtSynchLevel();
                Thread->SuspendSemaphore.Header.SignalState += 1;
                KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
                KiUnlockDispatcherDatabaseFromSynchLevel();
            }
        }

        //
        // Release the thread APC queue lock.
        //

        KeReleaseInStackQueuedSpinLockFromDpcLevel(&ThreadHandle);
        NextEntry = NextEntry->Flink;
    } while (NextEntry != ListHead);

    //
    // Release the process lock, exit the scheduler, and leave critical
    // region.
    //

    KeReleaseInStackQueuedSpinLockFromDpcLevel(&ProcessHandle);
    KiExitDispatcher(ProcessHandle.OldIrql);
    KeLeaveCriticalRegion();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\timerobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    timerobj.c

Abstract:

    This module implements the kernel timer object. Functions are
    provided to initialize, read, set, and cancel timer objects.

--*/

#include "ki.h"

//
// Flags controlling the nature of timer checks. This checks are triggered
// when driver verifier is active and default behavior is to check for active timers
// involved in pool free and driver unload operations.
//

#define KE_TIMER_CHECK_FREES 0x1
ULONG KeTimerCheckFlags = KE_TIMER_CHECK_FREES;

//
// The following assert macro is used to check that an input timer is
// really a ktimer and not something else, like deallocated pool.
//

#define ASSERT_TIMER(E) {                                                    \
    ASSERT(((E)->Header.Type == TimerNotificationObject) ||                  \
           ((E)->Header.Type == TimerSynchronizationObject));                \
}

VOID
KeInitializeTimer (
    __out PKTIMER Timer
    )

/*++

Routine Description:

    This function initializes a kernel timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    None.

--*/

{

    //
    // Initialize extended timer object with a type of notification and a
    // period of zero.
    //

    KeInitializeTimerEx(Timer, NotificationTimer);
    return;
}

VOID
KeInitializeTimerEx (
    __out PKTIMER Timer,
    __in TIMER_TYPE Type
    )

/*++

Routine Description:

    This function initializes an extended kernel timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Type - Supplies the type of timer object; NotificationTimer or
        SynchronizationTimer;

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // state of timer.
    //

    Timer->Header.Type = (UCHAR)(TimerNotificationObject + Type);
    Timer->Header.Inserted = FALSE;
    Timer->Header.Size = sizeof(KTIMER) / sizeof(LONG);
    Timer->Header.SignalState = FALSE;

#if DBG

    Timer->TimerListEntry.Flink = NULL;
    Timer->TimerListEntry.Blink = NULL;

#endif

    InitializeListHead(&Timer->Header.WaitListHead);
    Timer->DueTime.QuadPart = 0;
    Timer->Period = 0;
    return;
}

VOID
KeClearTimer (
    __inout PKTIMER Timer
    )

/*++

Routine Description:

    This function clears the signal state of an timer object.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    None.

--*/

{

    ASSERT_TIMER(Timer);

    //
    // Clear signal state of timer object.
    //

    Timer->Header.SignalState = 0;
    return;
}

BOOLEAN
KeCancelTimer (
    __inout PKTIMER Timer
    )

/*++

Routine Description:

    This function cancels a timer that was previously set to expire at
    a specified time. If the timer is not currently set, then no operation
    is performed. Canceling a timer does not set the state of the timer to
    Signaled.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    ASSERT_TIMER(Timer);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock the dispatcher database, and
    // capture the timer inserted status. If the timer is currently set,
    // then remove it from the timer list.
    //

    KiLockDispatcherDatabase(&OldIrql);
    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return boolean value that signifies whether the timer was set of not.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}

BOOLEAN
KeReadStateTimer (
    __in PKTIMER Timer
    )

/*++

Routine Description:

    This function reads the current signal state of a timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    The current signal state of the timer object.

--*/

{

    ASSERT_TIMER(Timer);

    //
    // Return current signal state of timer object.
    //

    return (BOOLEAN)Timer->Header.SignalState;
}

BOOLEAN
KeSetTimer (
    __inout PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in_opt PKDPC Dpc
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    //
    // Set the timer with a period of zero.
    //

    return KeSetTimerEx(Timer, DueTime, 0, Dpc);
}

BOOLEAN
KeSetTimerEx (
    __inout PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in LONG Period,
    __in_opt PKDPC Dpc
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Period - Supplies an optional period for the timer in milliseconds.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Hand;
    BOOLEAN Inserted;
    KIRQL OldIrql;
    BOOLEAN RequestInterrupt;

    ASSERT_TIMER(Timer);

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //
    // Capture the timer inserted status and if the timer is currently
    // set, then remove it from the timer list.
    //

    KiLockDispatcherDatabase(&OldIrql);
    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Set the DPC address, set the period, and compute the timer due time.
    // If the timer has already expired, then signal the timer. Otherwise,
    // set the signal state to false and attempt to insert the timer in the
    // timer table.
    //
    // N.B. The signal state must be cleared before it is inserted in the
    //      timer table in case the period is not zero.
    //

    Timer->Dpc = Dpc;
    Timer->Period = Period;
    if (KiComputeDueTime(Timer, DueTime, &Hand) == FALSE) {
        RequestInterrupt = KiSignalTimer(Timer);
        KiUnlockDispatcherDatabaseFromSynchLevel();
        if (RequestInterrupt == TRUE) {
            KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
        }

    } else {
        Timer->Header.SignalState = FALSE;
        KiInsertOrSignalTimer(Timer, Hand);
    }

    KiExitDispatcher(OldIrql);

    //
    // Return boolean value that signifies whether the timer was set or
    // not.
    //

    return Inserted;
}

ULONGLONG
KeQueryTimerDueTime (
    __in PKTIMER Timer
    )

/*++

Routine Description:

    This function returns the interrupt time at which the specified timer is
    due to expire. If the timer is not pending, then zero is returned.

    N.B. This function may only be called by the system sleep code.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    Returns the amount of time remaining on the timer, or 0 if the
    timer is not pending.

--*/

{

    ULONGLONG DueTime;
    KIRQL OldIrql;

    ASSERT_TIMER(Timer);


    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //
    // If the timer is currently pending, then return the due time. Otherwise,
    // return zero.
    //

    DueTime = 0;
    KiLockDispatcherDatabase(&OldIrql);
    if (Timer->Header.Inserted) {
        DueTime = Timer->DueTime.QuadPart;
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return the due time.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return DueTime;
}

VOID
KeCheckForTimer (
    __in_bcount(BlockSize) PVOID BlockStart,
    __in SIZE_T BlockSize
    )

/*++

Routine Description:

    This function checks to detemine if the specified block of memory
    overlaps the range of an active timer.

Arguments:

    BlockStart - Supplies a pointer to the block of memory to check.

    BlockSize - Supplies the size, in bytes, of the block of memory to check.

Return Value:

    None.

--*/

{

    PUCHAR Address;
    PUCHAR End;
    ULONG Index;
    PLIST_ENTRY ListHead;
    PKSPIN_LOCK_QUEUE LockQueue;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;
    PUCHAR Start;

    //
    // Make sure timer checks are enabled before proceeding.
    //

    if ((KeTimerCheckFlags & KE_TIMER_CHECK_FREES) == 0) {
        return;
    }

    //
    // Compute the ending memory location.
    //

    Start = (PUCHAR)BlockStart;
    End = Start + BlockSize;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //
    // Scan the timer database and check for any timers in the specified
    // memory block.
    //

    KiLockDispatcherDatabase(&OldIrql);
    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index].Entry;
        LockQueue = KiAcquireTimerTableLock(Index);
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            Address = (PUCHAR)Timer;
            NextEntry = NextEntry->Flink;

            //
            // Check that the timer object is not in the range.
            //

            if ((Address > (Start - sizeof(KTIMER))) &&
                (Address < End)) {
                KeBugCheckEx(TIMER_OR_DPC_INVALID,
                             0x0,
                             (ULONG_PTR)Address,
                             (ULONG_PTR)Start,
                             (ULONG_PTR)End);
            }

            if (Timer->Dpc) {

                //
                // Check that the timer DPC object is not in the range.
                //

                Address = (PUCHAR)Timer->Dpc;
                if ((Address > (Start - sizeof(KDPC))) &&
                    (Address < End)) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x1,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }

                //
                // Check that the timer DPC routine is not in the range.
                //

                Address = (PUCHAR)(ULONG_PTR) Timer->Dpc->DeferredRoutine;
                if (Address >= Start && Address < End) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x2,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }
            }
        }

        KiReleaseTimerTableLock(LockQueue);
        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);

    //
    // Unlock the dispatcher database and lower IRQL to its previous value
    //

    KiUnlockDispatcherDatabase(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\wait.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    wait.c

Abstract:

    This module implements the generic kernel wait routines. Functions
    are provided to delay execution, wait for multiple objects, wait for
    a single object, and ot set a client event and wait for a server event.

    N.B. This module is written to be a fast as possible and not as small
        as possible. Therefore some code sequences are duplicated to avoid
        procedure calls. It would also be possible to combine wait for
        single object into wait for multiple objects at the cost of some
        speed. Since wait for single object is the most common case, the
        two routines have been separated.

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeIsWaitListEmpty)

//
// Test for alertable condition.
//
// If alertable is TRUE and the thread is alerted for a processor
// mode that is equal to the wait mode, then return immediately
// with a wait completion status of ALERTED.
//
// Else if alertable is TRUE, the wait mode is user, and the user APC
// queue is not empty, then set user APC pending, and return immediately
// with a wait completion status of USER_APC.
//
// Else if alertable is TRUE and the thread is alerted for kernel
// mode, then return immediately with a wait completion status of
// ALERTED.
//
// Else if alertable is FALSE and the wait mode is user and there is a
// user APC pending, then return immediately with a wait completion
// status of USER_APC.
//

#define TestForAlertPending(Alertable) \
    if (Alertable) { \
        if (Thread->Alerted[WaitMode] != FALSE) { \
            Thread->Alerted[WaitMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } else if ((WaitMode != KernelMode) && \
                  (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode])) == FALSE) { \
            Thread->ApcState.UserApcPending = TRUE; \
            WaitStatus = STATUS_USER_APC; \
            break; \
        } else if (Thread->Alerted[KernelMode] != FALSE) { \
            Thread->Alerted[KernelMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } \
    } else if (Thread->ApcState.UserApcPending & WaitMode) { \
        WaitStatus = STATUS_USER_APC; \
        break; \
    }

VOID
KiAdjustQuantumThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    If the current thread is not a time critical or real time thread, then
    adjust its quantum in accordance with the adjustment that would have
    occurred if the thread had actually waited.

    N.B. This routine is entered at SYNCH_LEVEL and exits at the wait
         IRQL of the subject thread after having exited the scheduler.

Arguments:

    Thread - Supplies a pointer to the current thread.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;
    PKTHREAD NewThread;

    //
    // Acquire the thread lock and the PRCB lock.
    //
    // If the thread is not a real time or time critical thread, then adjust
    // the thread quantum.
    //

    Prcb = KeGetCurrentPrcb();
    KiAcquireThreadLock(Thread);
    KiAcquirePrcbLock(Prcb);
    if ((Thread->Priority < LOW_REALTIME_PRIORITY) &&
        (Thread->BasePriority < TIME_CRITICAL_PRIORITY_BOUND)) {

        Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
        if (Thread->Quantum <= 0) {

            //
            // Quantum end has occurred. Adjust the thread priority.
            //

            Thread->Quantum = Thread->QuantumReset;

            //
            // Compute the new thread priority and attempt to reschedule the
            // current processor as if a quantum end had occurred.
            //
            // N.B. The new priority will never be greater than the previous
            //      priority.
            //

            Thread->Priority = KiComputeNewPriority(Thread, 1);
            if (Prcb->NextThread == NULL) {
                if ((NewThread = KiSelectReadyThread(Thread->Priority, Prcb)) != NULL) {
                    NewThread->State = Standby;
                    Prcb->NextThread = NewThread;
                }

            } else {
                Thread->Preempted = FALSE;
            }
        }
    }

    //
    // Release the thread lock, release the PRCB lock, exit the scheduler,
    // and return.
    //

    KiReleasePrcbLock(Prcb);
    KiReleaseThreadLock(Thread);
    KiExitDispatcher(Thread->WaitIrql);
    return;
}

FORCEINLINE
PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    )

/*++

Routine Description:

    This function recomputes the wait interval after a thread has been
    awakened to deliver a kernel APC.

Arguments:

    OriginalTime - Supplies a pointer to the original timeout value.

    DueTime - Supplies a pointer to the previous due time.

    NewTime - Supplies a pointer to a variable that receives the
        recomputed wait interval.

Return Value:

    A pointer to the new time is returned as the function value.

--*/

{

    //
    // If the original wait time was absolute, then return the same
    // absolute time. Otherwise, reduce the wait time remaining before
    // the time delay expires.
    //

    if (OriginalTime->HighPart >= 0) {
        return OriginalTime;

    } else {
        KiQueryInterruptTime(NewTime);
        NewTime->QuadPart -= DueTime->QuadPart;
        return NewTime;
    }
}

//
// The following macro initializes thread local variables for the delay
// execution thread kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeDelayExecution()                                          \
    Thread->WaitBlockList = WaitBlock;                                      \
    Thread->WaitStatus = 0;                                                 \
    KiSetDueTime(Timer, *Interval, &Hand);                                  \
    DueTime.QuadPart = Timer->DueTime.QuadPart;                             \
    WaitBlock->NextWaitBlock = WaitBlock;                                   \
    Timer->Header.WaitListHead.Flink = &WaitBlock->WaitListEntry;           \
    Timer->Header.WaitListHead.Blink = &WaitBlock->WaitListEntry;           \
    Thread->Alertable = Alertable;                                          \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = DelayExecution;                                    \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime = KiQueryLowTickCount()

NTSTATUS
DECLSPEC_NOINLINE
KeDelayExecutionThread (
    __in KPROCESSOR_MODE WaitMode,
    __in BOOLEAN Alertable,
    __in PLARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function delays the execution of the current thread for the specified
    interval of time.

Arguments:

    WaitMode  - Supplies the processor mode in which the delay is to occur.

    Alertable - Supplies a boolean value that specifies whether the delay
        is alertable.

    Interval - Supplies a pointer to the absolute or relative time over which
        the delay is to occur.

Return Value:

    The wait completion status. A value of STATUS_SUCCESS is returned if
    the delay occurred. A value of STATUS_ALERTED is returned if the wait
    was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    ULONG Hand;
    LARGE_INTEGER NewTime;
    PLARGE_INTEGER OriginalTime;
    PKPRCB Prcb;
    PRKQUEUE Queue;
    LOGICAL StackSwappable;
    PKTHREAD Thread;
    PRKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;

    //
    // If the specfied wait interval is zero and the wait mode is not kernel
    // mode, then attempt to yield execution.
    //

    Hand = 0;
    Thread = KeGetCurrentThread();
    if ((Interval->QuadPart == 0) &&
        (WaitMode != KernelMode)) {

        if ((Alertable == FALSE) &&
            (Thread->ApcState.UserApcPending == FALSE)) {

            return NtYieldExecution();
        }
    }

    //
    // Set constant variables.
    //

    OriginalTime = Interval;
    Timer = &Thread->Timer;
    WaitBlock = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If the dispatcher database is already held, then initialize the thread
    // local variables. Otherwise, raise IRQL to DPC level, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (ReadForWriteAccess(&Thread->WaitNext) == FALSE) {
        goto WaitStart;
    }

    Thread->WaitNext = FALSE;
    InitializeDelayExecution();

    //
    // Start of delay loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the delay or a kernel APC is pending on the first attempt through
    // the loop.
    //

    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending, the special APC disable count is zero,
        // and the previous IRQL was less than APC_LEVEL, then a kernel APC
        // was queued by another processor just after IRQL was raised to
        // DISPATCH_LEVEL, but before the dispatcher database was locked.
        //
        // N.B. This can only happen in a multiprocessor system.
        //

        Thread->Preempted = FALSE;
        if (Thread->ApcState.KernelApcPending &&
            (Thread->SpecialApcDisable == 0) &&
            (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // Check if the timer has already expired.
            //
            // N.B. The constant fields of the timer wait block are
            //      initialized when the thread is initialized. The
            //      constant fields include the wait object, wait key,
            //      wait type, and the wait list entry link pointers.
            //

            Prcb = KeGetCurrentPrcb();
            if (KiCheckDueTime(Timer) == FALSE) {
                goto NoWait;
            }

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher
            // state to Waiting, and insert the thread in the wait list if
            // the kernel stack of the current thread is swappable.
            //

            Thread->State = Waiting;
            if (StackSwappable != FALSE) {
                InsertTailList(&Prcb->WaitListHead, &Thread->WaitListEntry);
            }

            //
            // Set swap busy for the current thread, unlock the dispatcher
            // database, and switch to a new thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            KiSetContextSwapBusy(Thread);
            KiInsertOrSignalTimer(Timer, Hand);
            WaitStatus = (NTSTATUS)KiSwapThread(Thread, Prcb);

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return the wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                if (WaitStatus == STATUS_TIMEOUT) {
                    WaitStatus = STATUS_SUCCESS;
                }

                return WaitStatus;
            }

            //
            // Reduce the time remaining before the time delay expires.
            //

            Interval = KiComputeWaitInterval(OriginalTime,
                                             &DueTime,
                                             &NewTime);
        }

        //
        // Raise IRQL to SYNCH level, initialize the thread local variables,
        // and lock the dispatcher database.
        //

WaitStart:

        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();
        InitializeDelayExecution();
        KiLockDispatcherDatabaseAtSynchLevel();

    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return the
    // wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // If the wait time is zero, then unlock the dispatcher database and
    // yield execution. Otherwise, unlock the dispatcher database, remain
    // at SYNCH level, adjust the thread quantum, exit the dispatcher, and
    // and return the wait completion status.
    //

NoWait:

    if (Interval->QuadPart == 0) {
        KiUnlockDispatcherDatabase(Thread->WaitIrql);
        return NtYieldExecution();

    } else {
        KiUnlockDispatcherDatabaseFromSynchLevel();
        KiAdjustQuantumThread(Thread);
        return STATUS_SUCCESS;
    }
}

BOOLEAN
KeIsWaitListEmpty (
    __in PVOID Object
    )

/*++

Routine Description:

    This function tests to determine if the wait list of the specified
    dispatcher object is empty.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

Return Value:

    If the wait list of the specified dispatcher object is empty, then a value
    of TRUE is returned. Otherwise, a value of FALSE is returned.

--*/

{

    PKEVENT Event = Object;
    PLIST_ENTRY ListHead;

    ListHead = &Event->Header.WaitListHead;
    KeMemoryBarrier();
    return (BOOLEAN)(ListHead == ListHead->Flink);
}

//
// The following macro initializes thread local variables for the wait
// for multiple objects kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeWaitMultiple()                                            \
    Thread->WaitBlockList = WaitBlockArray;                                 \
    Index = 0;                                                              \
    do {                                                                    \
        WaitBlock = &WaitBlockArray[Index];                                 \
        WaitBlock->Object = Object[Index];                                  \
        WaitBlock->WaitKey = (CSHORT)(Index);                               \
        WaitBlock->WaitType = WaitType;                                     \
        WaitBlock->Thread = Thread;                                         \
        WaitBlock->NextWaitBlock = &WaitBlockArray[Index + 1];              \
        Index += 1;                                                         \
    } while (Index < Count);                                                \
    WaitBlock->NextWaitBlock = &WaitBlockArray[0];                          \
    Thread->WaitStatus = 0;                                                 \
    if (ARGUMENT_PRESENT(Timeout)) {                                        \
        WaitTimer->NextWaitBlock = &WaitBlockArray[0];                      \
        KiSetDueTime(Timer, *Timeout, &Hand);                               \
        DueTime.QuadPart = Timer->DueTime.QuadPart;                         \
        InitializeListHead(&Timer->Header.WaitListHead);                    \
    }                                                                       \
    Thread->Alertable = Alertable;                                          \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = (UCHAR)WaitReason;                                 \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime = KiQueryLowTickCount()

NTSTATUS
KeWaitForMultipleObjects (
    __in ULONG Count,
    __in_ecount(Count) PVOID Object[],
    __in WAIT_TYPE WaitType,
    __in KWAIT_REASON WaitReason,
    __in KPROCESSOR_MODE WaitMode,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout,
    __out_opt PKWAIT_BLOCK WaitBlockArray
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled. The wait can be specified to wait until all of the objects
    attain a state of Signaled or until one of the objects attains a state
    of Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the objects
    attain a state of Signaled. If a timeout is specified, and the objects
    have not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Object[] - Supplies an array of pointers to dispatcher objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

    WaitBlockArray - Supplies an optional pointer to an array of wait blocks
        that are to used to describe the wait operation.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait. A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread. A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{

    PKPRCB CurrentPrcb;
    LARGE_INTEGER DueTime;
    ULONG Hand;
    ULONG_PTR Index;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    LOGICAL StackSwappable;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    //
    // Set constant variables.
    //

    Hand = 0;
    Thread = KeGetCurrentThread();
    OriginalTime = Timeout;
    Timer = &Thread->Timer;
    WaitTimer = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If a wait block array has been specified, then the maximum number of
    // objects that can be waited on is specified by MAXIMUM_WAIT_OBJECTS.
    // Otherwise the builtin wait blocks in the thread object are used and
    // the maximum number of objects that can be waited on is specified by
    // THREAD_WAIT_OBJECTS. If the specified number of objects is not within
    // limits, then bugcheck.
    //

    if (ARGUMENT_PRESENT(WaitBlockArray)) {
        if (Count > MAXIMUM_WAIT_OBJECTS) {
            KeBugCheck(MAXIMUM_WAIT_OBJECTS_EXCEEDED);
        }

    } else {
        if (Count > THREAD_WAIT_OBJECTS) {
            KeBugCheck(MAXIMUM_WAIT_OBJECTS_EXCEEDED);
        }

        WaitBlockArray = &Thread->WaitBlock[0];
    }

    ASSERT(Count != 0);

    //
    // If the dispatcher database is already held, then initialize the thread
    // local variables. Otherwise, raise IRQL to DPC level, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (ReadForWriteAccess(&Thread->WaitNext) == FALSE) {
        goto WaitStart;
    }

    Thread->WaitNext = FALSE;
    InitializeWaitMultiple();

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending, the special APC disable count is zero,
        // and the previous IRQL was less than APC_LEVEL, then a kernel APC
        // was queued by another processor just after IRQL was raised to
        // DISPATCH_LEVEL, but before the dispatcher database was locked.
        //
        // N.B. This can only happen in a multiprocessor system.
        //

        Thread->Preempted = FALSE;
        if (Thread->ApcState.KernelApcPending &&
            (Thread->SpecialApcDisable == 0) &&
            (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Construct wait blocks and check to determine if the wait is
            // already satisfied. If the wait is satisfied, then perform
            // wait completion and return. Else put current thread in a wait
            // state if an explicit timeout value of zero is not specified.
            //

            Index = 0;
            if (WaitType == WaitAny) {
                do {

                    //
                    // Test if wait can be satisfied immediately.
                    //
    
                    Objectx = (PKMUTANT)Object[Index];
    
                    ASSERT(Objectx->Header.Type != QueueObject);
    
                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MINLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is greater than zero, or the current thread is
                    // the owner of the mutant object, then satisfy the wait.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Objectx->Header.SignalState > 0) ||
                            (Thread == Objectx->OwnerThread)) {
                            if (Objectx->Header.SignalState != MINLONG) {
                                KiWaitSatisfyMutant(Objectx, Thread);
                                WaitStatus = (NTSTATUS)(Index | Thread->WaitStatus);
                                goto NoWait;

                            } else {
                                KiUnlockDispatcherDatabase(Thread->WaitIrql);
                                ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                            }
                        }

                    //
                    // If the signal state is greater than zero, then satisfy
                    // the wait.
                    //

                    } else if (Objectx->Header.SignalState > 0) {
                        KiWaitSatisfyOther(Objectx);
                        WaitStatus = (NTSTATUS)(Index);
                        goto NoWait;
                    }

                    Index += 1;

                } while(Index < Count);

            } else {
                do {

                    //
                    // Test if wait can be satisfied.
                    //
    
                    Objectx = (PKMUTANT)Object[Index];
    
                    ASSERT(Objectx->Header.Type != QueueObject);
    
                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MINLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is less than or equal to zero and the current
                    // thread is not the  owner of the mutant object, then the
                    // wait cannot be satisfied.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Thread == Objectx->OwnerThread) &&
                            (Objectx->Header.SignalState == MINLONG)) {
                            KiUnlockDispatcherDatabase(Thread->WaitIrql);
                            ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);

                        } else if ((Objectx->Header.SignalState <= 0) &&
                                  (Thread != Objectx->OwnerThread)) {
                            break;
                        }

                    //
                    // If the signal state is less than or equal to zero, then
                    // the wait cannot be satisfied.
                    //

                    } else if (Objectx->Header.SignalState <= 0) {
                        break;
                    }

                    Index += 1;

                } while(Index < Count);

                //
                // If all objects have been scanned, then satisfy the wait.
                //

                if (Index == Count) {
                    WaitBlock = &WaitBlockArray[0];
                    do {
                        Objectx = (PKMUTANT)WaitBlock->Object;
                        KiWaitSatisfyAny(Objectx, Thread);
                        WaitBlock = WaitBlock->NextWaitBlock;
                    } while (WaitBlock != &WaitBlockArray[0]);

                    WaitStatus = (NTSTATUS)Thread->WaitStatus;
                    goto NoWait;
                }
            }

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // Check to determine if a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Check if the timer has already expired.
                //
                // N.B. The constant fields of the timer wait block are
                //      initialized when the thread is initialized. The
                //      constant fields include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                if (KiCheckDueTime(Timer) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }

                WaitBlock->NextWaitBlock = WaitTimer;
            }

            //
            // Insert wait blocks in object wait lists.
            //

            WaitBlock = &WaitBlockArray[0];
            do {
                Objectx = (PKMUTANT)WaitBlock->Object;
                InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);
                WaitBlock = WaitBlock->NextWaitBlock;
            } while (WaitBlock != &WaitBlockArray[0]);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            CurrentPrcb = KeGetCurrentPrcb();
            Thread->State = Waiting;
            if (StackSwappable != FALSE) {
                InsertTailList(&CurrentPrcb->WaitListHead, &Thread->WaitListEntry);
            }

            //
            // Set swap busy for the current thread, unlock the dispatcher
            // database, and switch to a new thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            KiSetContextSwapBusy(Thread);
            if (ARGUMENT_PRESENT(Timeout)) {
                KiInsertOrSignalTimer(Timer, Hand);

            } else {
                KiUnlockDispatcherDatabaseFromSynchLevel();
            }

            WaitStatus = (NTSTATUS)KiSwapThread(Thread, CurrentPrcb);

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return the wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to SYNCH level, initialize the thread local variables,
        // and lock the dispatcher database.
        //

WaitStart:
        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();
        InitializeWaitMultiple();
        KiLockDispatcherDatabaseAtSynchLevel();

    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // Unlock the dispatcher database and remain at SYNCH level.
    //

NoWait:

    KiUnlockDispatcherDatabaseFromSynchLevel();

    //
    // Adjust the thread quantum, exit the scheduler, and return the wait
    // completion status.
    //

    KiAdjustQuantumThread(Thread);
    return WaitStatus;
}

//
// The following macro initializes thread local variables for the wait
// for single object kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeWaitSingle()                                              \
    Thread->WaitBlockList = WaitBlock;                                      \
    WaitBlock->Object = Object;                                             \
    WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);                          \
    WaitBlock->WaitType = WaitAny;                                          \
    Thread->WaitStatus = 0;                                                 \
    if (ARGUMENT_PRESENT(Timeout)) {                                        \
        KiSetDueTime(Timer, *Timeout, &Hand);                               \
        DueTime.QuadPart = Timer->DueTime.QuadPart;                         \
        WaitBlock->NextWaitBlock = WaitTimer;                               \
        WaitTimer->NextWaitBlock = WaitBlock;                               \
        Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;       \
        Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;       \
    } else {                                                                \
        WaitBlock->NextWaitBlock = WaitBlock;                               \
    }                                                                       \
    Thread->Alertable = Alertable;                                          \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = (UCHAR)WaitReason;                                 \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime = KiQueryLowTickCount()

NTSTATUS
KeWaitForSingleObject (
    __in PVOID Object,
    __in KWAIT_REASON WaitReason,
    __in KPROCESSOR_MODE WaitMode,
    __in BOOLEAN Alertable,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    This function waits until the specified object attains a state of
    Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the object
    attains a state of Signaled. If a timeout is specified, and the object
    has not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait. A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    PKPRCB CurrentPrcb;
    LARGE_INTEGER DueTime;
    ULONG Hand;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    LOGICAL StackSwappable;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    ASSERT((PsGetCurrentThread()->StartAddress != (PVOID)(ULONG_PTR)KeBalanceSetManager) || (ARGUMENT_PRESENT(Timeout)));

    //
    // Set constant variables.
    //

    Hand = 0;
    Thread = KeGetCurrentThread();
    Objectx = (PKMUTANT)Object;
    OriginalTime = Timeout;
    Timer = &Thread->Timer;
    WaitBlock = &Thread->WaitBlock[0];
    WaitTimer = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If the dispatcher database is already held, then initialize the thread
    // local variables. Otherwise, raise IRQL to DPC level, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (ReadForWriteAccess(&Thread->WaitNext) == FALSE) {
        goto WaitStart;
    }

    Thread->WaitNext = FALSE;
    InitializeWaitSingle();

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending, the special APC disable count is zero,
        // and the previous IRQL was less than APC_LEVEL, then a kernel APC
        // was queued by another processor just after IRQL was raised to
        // DISPATCH_LEVEL, but before the dispatcher database was locked.
        //
        // N.B. This can only happen in a multiprocessor system.
        //

        Thread->Preempted = FALSE;
        if (Thread->ApcState.KernelApcPending &&
            (Thread->SpecialApcDisable == 0) &&
            (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // If the object is a mutant object and the mutant object has been
            // recursively acquired MINLONG times, then raise an exception.
            // Otherwise if the signal state of the mutant object is greater
            // than zero, or the current thread is the owner of the mutant
            // object, then satisfy the wait.
            //

            ASSERT(Objectx->Header.Type != QueueObject);

            if (Objectx->Header.Type == MutantObject) {
                if ((Objectx->Header.SignalState > 0) ||
                    (Thread == Objectx->OwnerThread)) {
                    if (Objectx->Header.SignalState != MINLONG) {
                        KiWaitSatisfyMutant(Objectx, Thread);
                        WaitStatus = (NTSTATUS)(Thread->WaitStatus);
                        goto NoWait;

                    } else {
                        KiUnlockDispatcherDatabase(Thread->WaitIrql);
                        ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                    }
                }

            //
            // If the signal state is greater than zero, then satisfy the wait.
            //

            } else if (Objectx->Header.SignalState > 0) {
                KiWaitSatisfyOther(Objectx);
                WaitStatus = (NTSTATUS)(0);
                goto NoWait;
            }

            //
            // Construct a wait block for the object.
            //

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // The wait cannot be satisfied immediately. Check to determine if
            // a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Check if the timer has already expired.
                //
                // N.B. The constant fields of the timer wait block are
                //      initialized when the thread is initialized. The
                //      constant fields include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                if (KiCheckDueTime(Timer) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }
            }

            //
            // Insert wait block in object wait list.
            //

            InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->State = Waiting;
            CurrentPrcb = KeGetCurrentPrcb();
            if (StackSwappable != FALSE) {
                InsertTailList(&CurrentPrcb->WaitListHead, &Thread->WaitListEntry);
            }

            //
            // Set swap busy for the current thread, unlock the dispatcher
            // database, and switch to a new thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            KiSetContextSwapBusy(Thread);
            if (ARGUMENT_PRESENT(Timeout)) {
                KiInsertOrSignalTimer(Timer, Hand);

            } else {
                KiUnlockDispatcherDatabaseFromSynchLevel();
            }

            WaitStatus = (NTSTATUS)KiSwapThread(Thread, CurrentPrcb);

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to SYNCH level, initialize the thread local variables,
        // and lock the dispatcher database.
        //

WaitStart:
        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();
        InitializeWaitSingle();
        KiLockDispatcherDatabaseAtSynchLevel();

    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // Unlock the dispatcher database and remain at SYNCH level.
    //

NoWait:

    KiUnlockDispatcherDatabaseFromSynchLevel();

    //
    // Adjust the thread quantum, exit the scheduler, and return the wait
    // completion status.
    //

    KiAdjustQuantumThread(Thread);
    return WaitStatus;
}

NTSTATUS
KiSetServerWaitClientEvent (
    __inout PKEVENT ServerEvent,
    __inout PKEVENT ClientEvent,
    __in ULONG WaitMode
    )

/*++

Routine Description:

    This function sets the specified server event and waits on specified
    client event. The wait is performed such that an optimal switch to
    the waiting thread occurs if possible. No timeout is associated with
    the wait, and thus, the issuing thread will wait until the client event
    is signaled or an APC is delivered.

Arguments:

    ServerEvent - Supplies a pointer to a dispatcher object of type event.

    ClientEvent - Supplies a pointer to a dispatcher object of type event.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_SUCCESS is returned if
    the specified object satisfied the wait. A value of STATUS_USER_APC is
    returned if the wait was aborted to deliver a user APC to the current
    thread.

--*/

{

    //
    // Set server event and wait on client event atomically.
    //

    KeSetEvent(ServerEvent, EVENT_INCREMENT, TRUE);
    return KeWaitForSingleObject(ClientEvent,
                                 WrEventPair,
                                 (KPROCESSOR_MODE)WaitMode,
                                 FALSE,
                                 NULL);
}

VOID
FASTCALL
KiAcquireFastMutex (
    IN PFAST_MUTEX Mutex
    )

/*++

Routine Description:

    This function is the slow path for fast mutex acquires.

Arguments:

    Mutex - Supplies a pointer to a fast mutex.

Return Value:

    None.

--*/

{

#if !defined (_X86_)

    LONG BitsToChange;
    LONG NewValue;
    LONG OldValue;
    LONG WaitIncrement;

#endif

    //
    // Increment the contention count and wait or acquire fast mutex.
    //

    Mutex->Contention += 1;

#if defined (_X86_)

    KeWaitForSingleObject(&Mutex->Gate, WrMutex, KernelMode, FALSE, NULL);

#else

    BitsToChange = FM_LOCK_BIT;
    WaitIncrement = FM_LOCK_WAITER_INC;
    do {

        ASSERT((BitsToChange == FM_LOCK_BIT) ||
               (BitsToChange == (FM_LOCK_BIT | FM_LOCK_WAITER_WOKEN)));

        ASSERT((WaitIncrement == FM_LOCK_WAITER_INC) ||
               (WaitIncrement == FM_LOCK_WAITER_WOKEN));

        OldValue = Mutex->Count;
        do {
            if ((OldValue & FM_LOCK_BIT) != 0) {

                ASSERT((BitsToChange == FM_LOCK_BIT) ||
                       ((OldValue & FM_LOCK_WAITER_WOKEN) != 0));

                NewValue = OldValue ^ BitsToChange;
                if ((NewValue = InterlockedCompareExchange(&Mutex->Count, NewValue, OldValue)) == OldValue) {
                    return;
                }

            } else {
                NewValue = OldValue + WaitIncrement;
                if ((NewValue = InterlockedCompareExchange(&Mutex->Count, NewValue, OldValue)) == OldValue) {
                    break;
                }
            }

            OldValue = NewValue;

        } while (TRUE);

        //
        // Wait until woken.
        //

        KeWaitForGate((PKGATE)&Mutex->Gate, WrGuardedMutex, KernelMode);

        ASSERT((Mutex->Count & FM_LOCK_WAITER_WOKEN) != 0);

        //
        // Switch to trying to set the lock bit and clear the woken bit or
        // incrementing the waiters and clearing woken bit.
        //

        BitsToChange = FM_LOCK_BIT | FM_LOCK_WAITER_WOKEN;
        WaitIncrement = FM_LOCK_WAITER_WOKEN;

        ASSERT((FM_LOCK_WAITER_WOKEN * 2) == FM_LOCK_WAITER_INC);

    } while (TRUE);

#endif

    return;
}

VOID
FASTCALL
KiAcquireGuardedMutex (
    IN PKGUARDED_MUTEX Mutex
    )
/*++

Routine Description:

    This function is the slow path for guarded mutex acquires.

Arguments:

    Mutex - Supplies a pointer to a guarded mutex.

Return Value:

    None.

--*/

{

    LONG BitsToChange;
    LONG NewValue;
    LONG OldValue;
    LONG WaitIncrement;

    //
    // Increment the contention count and wait or acquire the guarded mutex.
    //

    Mutex->Contention += 1;
    BitsToChange = GM_LOCK_BIT;
    WaitIncrement = GM_LOCK_WAITER_INC;
    do {

        ASSERT((BitsToChange == GM_LOCK_BIT) ||
               (BitsToChange == (GM_LOCK_BIT | GM_LOCK_WAITER_WOKEN)));

        ASSERT((WaitIncrement == GM_LOCK_WAITER_INC) ||
               (WaitIncrement == GM_LOCK_WAITER_WOKEN));

        OldValue = Mutex->Count;
        do {
            if ((OldValue & GM_LOCK_BIT) != 0) {

                ASSERT((BitsToChange == GM_LOCK_BIT) ||
                       ((OldValue & GM_LOCK_WAITER_WOKEN) != 0));

                NewValue = OldValue ^ BitsToChange;
                if ((NewValue = InterlockedCompareExchange(&Mutex->Count, NewValue, OldValue)) == OldValue) {
                    return;
                }

            } else {
                NewValue = OldValue + WaitIncrement;
                if ((NewValue = InterlockedCompareExchange(&Mutex->Count, NewValue, OldValue)) == OldValue) {
                    break;
                }
            }
            OldValue = NewValue;
        } while (TRUE);

        //
        // Wait until woken.
        //

        KeWaitForGate(&Mutex->Gate, WrGuardedMutex, KernelMode);

        ASSERT((Mutex->Count & GM_LOCK_WAITER_WOKEN) != 0);

        //
        // Revert to trying to set the lock bit and clear the woken bit or
        // incrementing the waiters and clearing woken bit.
        //

        BitsToChange = GM_LOCK_BIT | GM_LOCK_WAITER_WOKEN;
        WaitIncrement = GM_LOCK_WAITER_WOKEN;

        ASSERT((GM_LOCK_WAITER_WOKEN * 2) == GM_LOCK_WAITER_INC);

    } while (TRUE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\xipi.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    xipi.c

Abstract:

    This module implements portable interprocessor interrupt routines.

--*/

#include "ki.h"

//
// Define forward reference function prototypes.
//

VOID
KiIpiGenericCallTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID BroadcastFunction,
    IN PVOID Context,
    IN PVOID Parameter3
    );

ULONG_PTR
KeIpiGenericCall (
    IN PKIPI_BROADCAST_WORKER BroadcastFunction,
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    This function executes the specified function on every processor in
    the host configuration in a synchronous manner, i.e., the function
    is executed on each target in series with the execution of the source
    processor.

Arguments:

    BroadcastFunction - Supplies the address of function that is executed
        on each of the target processors.

    Context - Supplies the value of the context parameter that is passed
        to each function.

Return Value:

    The value returned by the specified function on the source processor
    is returned as the function value.

--*/

{

    volatile LONG Count;
    KIRQL OldIrql;
    ULONG_PTR Status;

#if !defined(NT_UP)

    KAFFINITY TargetProcessors;

#endif

    //
    // Raise IRQL to synchronization level and acquire the reverse stall spin
    // lock to synchronize with other reverse stall functions.
    //

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < SYNCH_LEVEL) {
        KfRaiseIrql(SYNCH_LEVEL);
    }

#if !defined(NT_UP)

    Count = KeNumberProcessors;
    TargetProcessors = KeActiveProcessors & ~KeGetCurrentPrcb()->SetMember;

#endif

    KeAcquireSpinLockAtDpcLevel(&KiReverseStallIpiLock);

    //
    // Initialize the broadcast packet, compute the set of target processors,
    // and sent the packet to the target processors for execution.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiIpiGenericCallTarget,
                        (PVOID)(ULONG_PTR)BroadcastFunction,
                        (PVOID)Context,
                        (PVOID)&Count);
    }

    //
    // Wait until all processors have entered the target routine and are
    // waiting.
    //

    while (Count != 1) {
        KeYieldProcessor();
    }

#endif

    //
    // Raise IRQL to IPI_LEVEL, signal all other processors to proceed, and
    // call the specified function on the source processor.
    //

    KfRaiseIrql(IPI_LEVEL);
    Count = 0;
    Status = BroadcastFunction(Context);

    //
    // Wait until all of the target processors have finished capturing the
    // function parameters.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Release reverse stall spin lock, lower IRQL to its previous level,
    // and return the function execution status.
    //

    KeReleaseSpinLockFromDpcLevel(&KiReverseStallIpiLock);
    KeLowerIrql(OldIrql);
    return Status;
}

#if !defined(NT_UP)

VOID
KiIpiGenericCallTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID BroadcastFunction,
    IN PVOID Context,
    IN PVOID Count
    )

/*++

Routine Description:

    This function is the target jacket function to execute a broadcast
    function on a set of target processors. The broadcast packet address
    is obtained, the specified parameters are captured, the broadcast
    packet address is cleared to signal the source processor to continue,
    and the specified function is executed.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    BroadcastFunction - Supplies the address of function that is executed
        on each of the target processors.

    Context - Supplies the value of the context parameter that is passed
        to each function.

    Count - Supplies the address of a down count synchronization variable.

Return Value:

    None

--*/

{

    //
    // Decrement the synchronization count variable and wait for the value
    // to go to zero.
    //

    InterlockedDecrement((volatile LONG *)Count);
    while ((*(volatile LONG *)Count) != 0) {
        
        //
        // Check for any other IPI such as the debugger
        // while we wait.  Note this routine does a YEILD.
        //

        KiPollFreezeExecution();
    }

    //
    // Execute the specified function.
    //

    ((PKIPI_BROADCAST_WORKER)(ULONG_PTR)(BroadcastFunction))((ULONG_PTR)Context);
    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\allproc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    allproc.c

Abstract:

    This module allocates and initializes kernel resources required to
    start a new processor, and passes a complete process state structure
    to the hal to obtain a new processor.

--*/

#include "ki.h"
#include "pool.h"

//
// Define local macros.
//

#define ROUNDUP64(x) (((x) + 63) & ~63)

//
// Define prototypes for forward referenced functions.
//

#if !defined(NT_UP)

VOID
KiCopyDescriptorMemory (
   IN PKDESCRIPTOR Source,
   IN PKDESCRIPTOR Destination,
   IN PVOID Base
   );

VOID
KiSetDescriptorBase (
   IN USHORT Selector,
   IN PKGDTENTRY64 GdtBase,
   IN PVOID Base
   );

//
// Define processor node query function address.
//
// N.B. This function address is filled in during kernel initialization
//      if the host system is a multinode system.
//

PHALNUMAQUERYPROCESSORNODE KiQueryProcessorNode;

#pragma alloc_text(INIT, KiCopyDescriptorMemory)
#pragma alloc_text(INIT, KiSetDescriptorBase)

//
// Dummy NUMA node structures used during system initialization.
//

#pragma data_seg("INITDATA")

KNODE KiNodeInit[MAXIMUM_CCNUMA_NODES];

#pragma data_seg()

#endif // !defined(NT_UP)

#pragma alloc_text(INIT, KeStartAllProcessors)

ULONG KiBarrierWait = 0;
ULONG KeRegisteredProcessors;


VOID
KeStartAllProcessors (
    VOID
    )

/*++

Routine Description:

    This function is called during phase 1 initialization on the master boot
    processor to start all of the other registered processors.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    ULONG AllocationSize;
    PUCHAR Base;
    PKPCR CurrentPcr = KeGetPcr();
    PVOID DataBlock;
    PVOID DpcStack;
    PKGDTENTRY64 GdtBase;
    ULONG GdtOffset;
    ULONG IdtOffset;
    UCHAR Index;
    PVOID KernelStack;
    ULONG LogicalProcessors;
    ULONG MaximumProcessors;
    PKNODE Node;
    UCHAR NodeNumber = 0;
    UCHAR Number;
    KIRQL OldIrql;
    PKNODE OldNode;
    PKNODE ParentNode;
    PKPCR PcrBase;
    PKPRCB Prcb;
    USHORT ProcessorId;
    KPROCESSOR_STATE ProcessorState;
    PKTSS64 SysTssBase;
    PKGDTENTRY64 TebBase;
    PETHREAD Thread;

    //
    // Ensure that prefetch instructions in the IPI path are patched out
    // if necessary before starting other processors.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    KiIpiSendRequest(1, 0, 0, IPI_FLUSH_SINGLE);
    KeLowerIrql(OldIrql);

    //
    // Do not start additional processors if the relocate physical loader
    // switch has been specified.
    // 

    if (KeLoaderBlock->LoadOptions != NULL) {
        if (strstr(KeLoaderBlock->LoadOptions, "RELOCATEPHYSICAL") != NULL) {
            return;
        }
    }

    //
    // If this a multinode system and processor zero is not on node zero,
    // then move it to the appropriate node.
    //

    if (KeNumberNodes > 1) {
        if (NT_SUCCESS(KiQueryProcessorNode(0, &ProcessorId, &NodeNumber))) {
            if (NodeNumber != 0) {
                KiNode0.ProcessorMask = 0;
                KiNodeInit[0] = KiNode0;
                KeNodeBlock[0] = &KiNodeInit[0];
                KiNode0 = *KeNodeBlock[NodeNumber];
                KeNodeBlock[NodeNumber] = &KiNode0;
                KiNode0.ProcessorMask = 1;
            }

        } else {
            goto StartFailure;
        }
    }

    //
    // Calculate the size of the per processor data structures.
    //
    // This includes:
    //
    //   PCR (including the PRCB)
    //   System TSS
    //   Idle Thread Object
    //   Double Fault Stack
    //   Machine Check Stack
    //   NMI Stack
    //   Multinode structure
    //   GDT
    //   IDT
    //
    // A DPC and Idle stack are also allocated, but they are done separately.
    //

    AllocationSize = ROUNDUP64(sizeof(KPCR)) +
                     ROUNDUP64(sizeof(KTSS64)) +
                     ROUNDUP64(sizeof(ETHREAD)) +
                     ROUNDUP64(DOUBLE_FAULT_STACK_SIZE) +
                     ROUNDUP64(KERNEL_MCA_EXCEPTION_STACK_SIZE) +
                     ROUNDUP64(NMI_STACK_SIZE) +
                     ROUNDUP64(sizeof(KNODE));

    //
    // Save the offset of the GDT in the allocation structure and add in
    // the size of the GDT.
    //

    GdtOffset = AllocationSize;
    AllocationSize +=
            CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Gdtr.Limit + 1;

    //
    // Save the offset of the IDT in the allocation structure and add in
    // the size of the IDT.
    //

    IdtOffset = AllocationSize;
    AllocationSize +=
            CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Idtr.Limit + 1;

    //
    // If the registered number of processors is greater than the maximum
    // number of processors supported, then only allow the maximum number
    // of supported processors.
    //

    if (KeRegisteredProcessors > MAXIMUM_PROCESSORS) {
        KeRegisteredProcessors = MAXIMUM_PROCESSORS;
    }

    //
    // Set barrier that will prevent any other processor from entering the
    // idle loop until all processors have been started.
    //

    KiBarrierWait = 1;

    //
    // Initialize the fixed part of the processor state that will be used to
    // start processors. Each processor starts in the system initialization
    // code with address of the loader parameter block as an argument.
    //

    RtlZeroMemory(&ProcessorState, sizeof(KPROCESSOR_STATE));
    ProcessorState.ContextFrame.Rcx = (ULONG64)KeLoaderBlock;
    ProcessorState.ContextFrame.Rip = (ULONG64)KiSystemStartup;
    ProcessorState.ContextFrame.SegCs = KGDT64_R0_CODE;
    ProcessorState.ContextFrame.SegDs = KGDT64_R3_DATA | RPL_MASK;
    ProcessorState.ContextFrame.SegEs = KGDT64_R3_DATA | RPL_MASK;
    ProcessorState.ContextFrame.SegFs = KGDT64_R3_CMTEB | RPL_MASK;
    ProcessorState.ContextFrame.SegGs = KGDT64_R3_DATA | RPL_MASK;
    ProcessorState.ContextFrame.SegSs = KGDT64_R0_DATA;

    //
    // Check to determine if hyper-threading is really enabled. Intel chips
    // claim to be hyper-threaded with the number of logical processors
    // greater than one even when hyper-threading is disabled in the BIOS.
    //

    LogicalProcessors = KiLogicalProcessors;
    if (HalIsHyperThreadingEnabled() == FALSE) {
        LogicalProcessors = 1;
    }

    //
    // If the total number of logical processors has not been set with
    // the /NUMPROC loader option, then set the maximum number of logical
    // processors to the number of registered processors times the number
    // of logical processors per registered processor.
    //
    // N.B. The number of logical processors is never allowed to exceed
    //      the number of registered processors times the number of logical
    //      processors per physical processor.
    //

    MaximumProcessors = KeNumprocSpecified;
    if (MaximumProcessors == 0) {
        MaximumProcessors = KeRegisteredProcessors * LogicalProcessors;
    }

    //
    // Loop trying to start a new processors until a new processor can't be
    // started or an allocation failure occurs.
    //
    // N.B. The below processor start code relies on the fact a physical
    //      processor is started followed by all its logical processors.
    //      The HAL guarantees this by sorting the ACPI processor table
    //      by APIC id.
    //

    Index = 0;
    Number = 0;
    while ((Index < (MAXIMUM_PROCESSORS - 1)) &&
           ((ULONG)KeNumberProcessors < MaximumProcessors) &&
           ((ULONG)KeNumberProcessors / LogicalProcessors) < KeRegisteredProcessors) {

        //
        // If this is a multinode system and current processor does not
        // exist on any node, then skip it.
        //

        Index += 1;
        if (KeNumberNodes > 1) {
            if (!NT_SUCCESS(KiQueryProcessorNode(Index, &ProcessorId, &NodeNumber))) {
                continue;
            }
        }

        //
        // Increment the processor number.
        //

        Number += 1;

        //
        // Allocate memory for the new processor specific data. If the
        // allocation fails, then stop starting processors.
        //

        DataBlock = MmAllocateIndependentPages(AllocationSize, NodeNumber);
        if (DataBlock == NULL) {
            goto StartFailure;
        }

        //
        // Allocate a pool tag table for the new processor.
        //

        if (ExCreatePoolTagTable(Number, NodeNumber) == NULL) {
            goto StartFailure;
        }

        //
        // Zero the allocated memory.
        //

        Base = (PUCHAR)DataBlock;
        RtlZeroMemory(DataBlock, AllocationSize);

        //
        // Copy and initialize the GDT for the next processor.
        //

        KiCopyDescriptorMemory(&CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Gdtr,
                               &ProcessorState.SpecialRegisters.Gdtr,
                               Base + GdtOffset);

        GdtBase = (PKGDTENTRY64)ProcessorState.SpecialRegisters.Gdtr.Base;

        //
        // Encode the processor number in the upper 6 bits of the compatibility
        // mode TEB descriptor.
        //

        TebBase = (PKGDTENTRY64)((PCHAR)GdtBase + KGDT64_R3_CMTEB);
        TebBase->Bits.LimitHigh = Number >> 2;
        TebBase->LimitLow = ((Number & 0x3) << 14) | (TebBase->LimitLow & 0x3fff);

        //
        // Copy and initialize the IDT for the next processor.
        //

        KiCopyDescriptorMemory(&CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Idtr,
                               &ProcessorState.SpecialRegisters.Idtr,
                               Base + IdtOffset);

        //
        // Set the PCR base address for the next processor, set the processor
        // number, and set the processor speed.
        //
        // N.B. The PCR address is passed to the next processor by computing
        //      the containing address with respect to the PRCB.
        //

        PcrBase = (PKPCR)Base;
        PcrBase->ObsoleteNumber = Number;
        PcrBase->Prcb.Number = Number;
        PcrBase->Prcb.MHz = KeGetCurrentPrcb()->MHz;
        Base += ROUNDUP64(sizeof(KPCR));

        //
        // Set the system TSS descriptor base for the next processor.
        //

        SysTssBase = (PKTSS64)Base;
        KiSetDescriptorBase(KGDT64_SYS_TSS / 16, GdtBase, SysTssBase);
        Base += ROUNDUP64(sizeof(KTSS64));

        //
        // Initialize the panic stack address for double fault and NMI.
        //

        Base += DOUBLE_FAULT_STACK_SIZE;
        SysTssBase->Ist[TSS_IST_PANIC] = (ULONG64)Base;

        //
        // Initialize the machine check stack address.
        //

        Base += KERNEL_MCA_EXCEPTION_STACK_SIZE;
        SysTssBase->Ist[TSS_IST_MCA] = (ULONG64)Base;

        //
        // Initialize the NMI stack address.
        //

        Base += NMI_STACK_SIZE;
        SysTssBase->Ist[TSS_IST_NMI] = (ULONG64)Base;

        //
        // Idle Thread thread object.
        //

        Thread = (PETHREAD)Base;
        Base += ROUNDUP64(sizeof(ETHREAD));

        //
        // Set other special registers in the processor state.
        //

        ProcessorState.SpecialRegisters.Cr0 = ReadCR0();
        ProcessorState.SpecialRegisters.Cr3 = ReadCR3();
        ProcessorState.ContextFrame.EFlags = 0;
        ProcessorState.SpecialRegisters.Tr  = KGDT64_SYS_TSS;
        GdtBase[KGDT64_SYS_TSS / 16].Bytes.Flags1 = 0x89;
        ProcessorState.SpecialRegisters.Cr4 = ReadCR4();

        //
        // Allocate a kernel stack and a DPC stack for the next processor.
        //

        KernelStack = MmCreateKernelStack(FALSE, NodeNumber);
        if (KernelStack == NULL) {
            goto StartFailure;
        }

        DpcStack = MmCreateKernelStack(FALSE, NodeNumber);
        if (DpcStack == NULL) {
            goto StartFailure;
        }

        //
        // Initialize the kernel stack for the system TSS.
        //
        // N.B. System startup must be called with a stack pointer that is
        //      8 mod 16.
        //

        SysTssBase->Rsp0 = (ULONG64)KernelStack - sizeof(PVOID) * 4;
        ProcessorState.ContextFrame.Rsp = (ULONG64)KernelStack - 8;

        //
        // If this is the first processor on this node, then use the space
        // already allocated for the node. Otherwise, the space allocated
        // is not used.
        //

        Node = KeNodeBlock[NodeNumber];
        OldNode = Node;
        if (Node == &KiNodeInit[NodeNumber]) {
            Node = (PKNODE)Base;
            *Node = KiNodeInit[NodeNumber];
            KeNodeBlock[NodeNumber] = Node;
        }

        Base += ROUNDUP64(sizeof(KNODE));

        //
        // Set the parent node address.
        //

        PcrBase->Prcb.ParentNode = Node;

        //
        // Adjust the loader block so it has the next processor state. Ensure
        // that the kernel stack has space for home registers for up to four
        // parameters.
        //

        KeLoaderBlock->KernelStack = (ULONG64)DpcStack - (sizeof(PVOID) * 4);
        KeLoaderBlock->Thread = (ULONG64)Thread;
        KeLoaderBlock->Prcb = (ULONG64)(&PcrBase->Prcb);

        //
        // Attempt to start the next processor. If a processor cannot be
        // started, then deallocate memory and stop starting processors.
        //

        if (HalStartNextProcessor(KeLoaderBlock, &ProcessorState) == 0) {

            //
            // Restore the old node address in the node address array before
            // freeing the allocated data block (the node structure lies
            // within the data block).
            //

            *OldNode = *Node;
            KeNodeBlock[NodeNumber] = OldNode;
            ExDeletePoolTagTable(Number);
            MmFreeIndependentPages(DataBlock, AllocationSize);
            MmDeleteKernelStack(KernelStack, FALSE);
            MmDeleteKernelStack(DpcStack, FALSE);
            break;
        }

        Node->ProcessorMask |= AFFINITY_MASK(Number);

        //
        // Wait for processor to initialize.
        //

        while (*((volatile ULONG64 *)&KeLoaderBlock->Prcb) != 0) {
            KeYieldProcessor();
        }
    }

    //
    // All processors have been started. If this is a multinode system, then
    // allocate any missing node structures.
    //

    if (KeNumberNodes > 1) {
        for (Index = 0; Index < KeNumberNodes; Index += 1) {
            if (KeNodeBlock[Index] == &KiNodeInit[Index]) {
                Node = ExAllocatePoolWithTag(NonPagedPool, sizeof(KNODE), '  eK');
                if (Node != NULL) {
                    *Node = KiNodeInit[Index];
                    KeNodeBlock[Index] = Node;

                } else {
                    goto StartFailure;
                }
            }
        }

    } else if (KiNode0.ProcessorMask != KeActiveProcessors) {
        goto StartFailure;
    }

    //
    // Clear node structure address for nonexistent nodes.
    //

    for (Index = KeNumberNodes; Index < MAXIMUM_CCNUMA_NODES; Index += 1) {
        KeNodeBlock[Index] = NULL;
    }

    //
    // Copy the node color and shifted color to the PRCB of each processor.
    //

    for (Index = 0; Index < (ULONG)KeNumberProcessors; Index += 1) {
        Prcb = KiProcessorBlock[Index];
        ParentNode = Prcb->ParentNode;
        Prcb->NodeColor = ParentNode->Color;
        Prcb->NodeShiftedColor = ParentNode->MmShiftedColor;
        Prcb->SecondaryColorMask = MmSecondaryColorMask;
    }

    //
    // Reset the initialization bit in prefetch retry.
    //

    KiPrefetchRetry &= ~0x80;

    //
    // Reset and synchronize the performance counters of all processors, by
    // applying a null adjustment to the interrupt time.
    //

    KeAdjustInterruptTime(0);

    //
    // Allow all processors that were started to enter the idle loop and
    // begin execution.
    //

    KiBarrierWait = 0;

#endif //

    return;

    //
    // The failure to allocate memory or a unsuccessful status was returned
    // during the attempt to start processors. This is considered fatal since
    // something is very wrong.
    //

#if !defined(NT_UP)

StartFailure:
    KeBugCheckEx(PHASE1_INITIALIZATION_FAILED, 0, 0, 20, 0);

#endif

}

#if !defined(NT_UP)

VOID
KiSetDescriptorBase (
   IN USHORT Selector,
   IN PKGDTENTRY64 GdtBase,
   IN PVOID Base
   )

/*++

Routine Description:

    This function sets the base address of a descriptor to the specified
    base address.

Arguments:

    Selector - Supplies the selector for the descriptor.

    GdtBase - Supplies a pointer to the GDT.

    Base - Supplies a pointer to the base address.

Return Value:

    None.

--*/

{

    GdtBase = &GdtBase[Selector];
    GdtBase->BaseLow = (USHORT)((ULONG64)Base);
    GdtBase->Bytes.BaseMiddle = (UCHAR)((ULONG64)Base >> 16);
    GdtBase->Bytes.BaseHigh = (UCHAR)((ULONG64)Base >> 24);
    GdtBase->BaseUpper = (ULONG)((ULONG64)Base >> 32);
    return;
}

VOID
KiCopyDescriptorMemory (
   IN PKDESCRIPTOR Source,
   IN PKDESCRIPTOR Destination,
   IN PVOID Base
   )

/*++

Routine Description:

    This function copies the specified descriptor memory to the new memory
    and initializes a descriptor for the new memory.

Arguments:

    Source - Supplies a pointer to the source descriptor that describes
        the memory to copy.

    Destination - Supplies a pointer to the destination descriptor to be
        initialized.

    Base - Supplies a pointer to the new memory.

Return Value:

    None.

--*/

{

    Destination->Limit = Source->Limit;
    Destination->Base = Base;
    RtlCopyMemory(Base, Source->Base, Source->Limit + 1);
    return;
}

#endif // !defined(NT_UP)
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\apcint.asm ===
title  "Asynchronous Procedure Call Interrupt"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   apcint.asm
;
; Abstract:
;
;   This module implements the code necessary to process the  Asynchronous
;   Procedure Call interrupt request.
;
;--

include ksamd64.inc

        extern  KiDeliverApc:proc
        extern  KiIdleSummary:qword
        extern  KiRestoreDebugRegisterState:proc
        extern  KiSaveDebugRegisterState:proc

        subttl  "Asynchronous Procedure Call Interrupt"
;++
;
; VOID
; KiApcInterrupt (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered as the result of a software interrupt generated
;   at APC_LEVEL. Its function is to save the machine state and call the APC
;   delivery routine.
;
;   N.B. This is a directly connected interrupt that does not use an interrupt
;        object.
;
;   N.B. APC interrupts are never requested for user mode APCs.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiApcInterrupt, _TEXT$00

        .pushframe                      ; mark machine frame

;
; Check for interrupt from the idle halt state.
;
; N.B. If an APC interrupt occurs when idle halt is set, then the interrupt
;      occurred during the power managment halted state. The interrupt can
;      be immediately dismissed since the idle loop will provide the correct
;      processing.
;

        test    byte ptr MfSegCs[rsp], MODE_MASK ; test if previous mode user
        jnz     short KiAP10            ; if nz, previous mode is user
        cmp     byte ptr gs:[PcIdleHalt], 0 ; check for idle halt interrupt
        je      short KiAP10            ; if e, not interrupt from halt

        EndSystemInterrupt              ; Perform EOI

        iretq                           ; return

;
; Normal APC interrupt.
;

KiAP10: alloc_stack 8                   ; allocate dummy vector
        push_reg rbp                    ; save nonvolatile register

        GENERATE_INTERRUPT_FRAME <>, <DirectNoSlistCheck> ; generate interrupt frame

        mov     ecx, APC_LEVEL          ; set new IRQL level

	ENTER_INTERRUPT	<>, <NoCount>   ; raise IRQL, do EOI, enable interrupts

        mov     ecx, KernelMode         ; set APC processor mode
        xor     edx, edx                ; set exception frame address
        lea     r8, (-128)[rbp]         ; set trap frame address
        call    KiDeliverApc            ; initiate APC execution

        EXIT_INTERRUPT <NoEOI>, <NoCount>, <Direct> ; lower IRQL and restore state

        NESTED_END KiApcInterrupt, _TEXT$00

        subttl  "Initiate User APC Execution"
;++
;
; Routine Description:
;
;   This routine generates an exception frame and attempts to deliver a user
;   APC.
;
; Arguments:
;
;   rbp - Supplies the address of the trap frame.
;
;   rsp - Supplies the address of the trap frame.
;
; Return value:
;
;   None.
;
;--

        NESTED_ENTRY KiInitiateUserApc, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     ecx, UserMode           ; set APC processor mode
        mov     rdx, rsp                ; set exception frame address
        lea     r8, (-128)[rbp]         ; set trap frame address
        call    KiDeliverApc            ; deliver APC

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KiInitiateUserApc, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\yield.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    yield.c

Abstract:

    This module implements the function to yield execution for one quantum
    to any other runnable thread.

--*/

#include "ki.h"

NTSTATUS
NtYieldExecution (
    VOID
    )

/*++

Routine Description:

    This function yields execution to any ready thread for up to one
    quantum.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTHREAD NewThread;
    PRKPRCB Prcb;
    NTSTATUS Status;
    PKTHREAD Thread;

    //
    // If no other threads are ready, then return immediately. Otherwise,
    // attempt to yield execution.
    //
    // N.B. The test for ready threads is made outside any synchonization.
    //      Since this code cannot be perfectly synchronized under any
    //      conditions the lack of synchronization is of no consequence.
    //      

    if (KiGetCurrentReadySummary() == 0) {
        return STATUS_NO_YIELD_PERFORMED;

    } else {
        Status = STATUS_NO_YIELD_PERFORMED;
        Thread = KeGetCurrentThread();
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        if (Prcb->ReadySummary != 0) {
    
            //
            // Acquire the thread lock and the PRCB lock.
            //
            // If a thread has not already been selected for execution, then
            // attempt to select another thread for execution.
            //
    
            KiAcquireThreadLock(Thread);
            KiAcquirePrcbLock(Prcb);
            if (Prcb->NextThread == NULL) {
                Prcb->NextThread = KiSelectReadyThread(1, Prcb);
            }
    
            //
            // If a new thread has been selected for execution, then switch
            // immediately to the selected thread.
            //
    
            if ((NewThread = Prcb->NextThread) != NULL) {
                Thread->Quantum = Thread->QuantumReset;
    
                //
                // Compute the new thread priority.
                //
                // N.B. The new priority will never be greater than the previous
                //      priority.
                //
    
                Thread->Priority = KiComputeNewPriority(Thread, 1);
    
                //
                // Release the thread lock, set swap busy for the old thread,
                // set the next thread to NULL, set the current thread to the
                // new thread, set the new thread state to running, set the
                // wait reason, queue the old running thread, and release the
                // PRCB lock, and swp context to the new thread.
                //
    
                KiReleaseThreadLock(Thread);
                KiSetContextSwapBusy(Thread);
                Prcb->NextThread = NULL;
                Prcb->CurrentThread = NewThread;
                NewThread->State = Running;
                Thread->WaitReason = WrYieldExecution;
                KxQueueReadyThread(Thread, Prcb);
                Thread->WaitIrql = APC_LEVEL;
    
                ASSERT(OldIrql <= DISPATCH_LEVEL);
    
                KiSwapContext(Thread, NewThread);
                Status = STATUS_SUCCESS;
    
            } else {
                KiReleasePrcbLock(Prcb);
                KiReleaseThreadLock(Thread);
            }
        }
    
        //
        // Lower IRQL to its previous level and return.
        //
    
        KeLowerIrql(OldIrql);
        return Status;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\callback.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    callback.c

Abstract:

    This module implements user mode call back services.

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeUserModeCallback)

VOID
KeCheckIfStackExpandCalloutActive (
    VOID
    )

/*++

Routine Description:

    This function check whether a kernel stack expand callout is active for
    the current thread and bugchecks if the result is positive.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKERNEL_STACK_CONTROL Control;
    PKTHREAD Thread;

    Thread = KeGetCurrentThread();
    Control = (PKERNEL_STACK_CONTROL)Thread->InitialStack;
    if (Control->Previous.StackBase != 0) {
        KeBugCheckEx(KERNEL_EXPAND_STACK_ACTIVE, (ULONG64)Thread, 0, 0, 0);
    }

    return;
}

NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    IN PULONG OutputLength
    )

/*++

Routine Description:

    This function call out from kernel mode to a user mode function.

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied
        to the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that receives
        the address of the output buffer.

    Outputlength - Supplies a pointer to a variable that receives
        the length of the output buffer.

Return Value:

    If the callout cannot be executed, then an error status is returned.
    Otherwise, the status returned by the callback function is returned.

--*/

{

    volatile ULONG BatchCount;
    PUCALLOUT_FRAME CalloutFrame;
    ULONG Length;
    ULONG64 OldStack;
    NTSTATUS Status;
    PKTRAP_FRAME TrapFrame;

    ASSERT(KeGetPreviousMode() == UserMode);

    //
    // Check if a kernel stack expand callout is active.
    //

    KeCheckIfStackExpandCalloutActive();

    //
    // Get the user mode stack pointer and attempt to copy input buffer
    // to the user stack.
    //

    TrapFrame = KeGetCurrentThread()->TrapFrame;
    OldStack = TrapFrame->Rsp;
    try {

        //
        // Compute new user mode stack address, probe for writability, and
        // copy the input buffer to the user stack.
        //

        Length = ((InputLength + STACK_ROUND) & ~STACK_ROUND) + UCALLOUT_FRAME_LENGTH;
        CalloutFrame = (PUCALLOUT_FRAME)((OldStack - Length) & ~STACK_ROUND);
        ProbeForWrite(CalloutFrame, Length, STACK_ALIGN);
        RtlCopyMemory(CalloutFrame + 1, InputBuffer, InputLength);

        //
        // Fill in callout arguments.
        //

        CalloutFrame->Buffer = (PVOID)(CalloutFrame + 1);
        CalloutFrame->Length = InputLength;
        CalloutFrame->ApiNumber = ApiNumber;
        CalloutFrame->MachineFrame.Rsp = OldStack;
        CalloutFrame->MachineFrame.Rip = TrapFrame->Rip;

    //
    // If an exception occurs during the probe of the user stack, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Call user mode.
    //

    TrapFrame->Rsp = (ULONG64)CalloutFrame;
    Status = KiCallUserMode(OutputBuffer, OutputLength);

    //
    // When returning from user mode, any drawing done to the GDI TEB
    // batch must be flushed.
    //
    // N.B. It is possible to fault while referencing the user TEB. If
    //      a fault occurs, then always flush the batch count.
    //

    BatchCount = 1;
    try {
        BatchCount = ((PTEB)KeGetCurrentThread()->Teb)->GdiBatchCount;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }   

    if (BatchCount > 0) {
        TrapFrame->Rsp -= 256;
        KeGdiFlushUserBatch();
    }

    TrapFrame->Rsp = OldStack;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\apcuser.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    apcuser.c

Abstract:

    This module implements the machine dependent code necessary to initialize
    a user mode APC.

Environment:

    IRQL APC_LEVEL.

--*/

#include "ki.h"

DECLSPEC_NOINLINE
VOID
KiContinuePreviousModeUser (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to copy the specified context record when the
    previous mode is user. Its only purpose is to save stack space in the
    caller. 

    N.B. This routine assumes that the caller has protected access to the
       specified context record.

Arguments:

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord2;

    //
    // Copy the context record to a stack local context record.
    //
    // N.B. The context record has already been probed for read
    //      access.
    //

    RtlCopyMemory(&ContextRecord2, ContextRecord, sizeof(CONTEXT));

    //
    // Move information from the context record to the exception and trap
    // frames.
    //

    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &ContextRecord2,
                       ContextRecord2.ContextFlags,
                       UserMode);

    return;
}

NTSTATUS
KiContinueEx (
    IN PCONTEXT ContextRecord,
    IN BOOLEAN TestAlert,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to copy the specified context frame to the
    specified exception and trap frames for the continue system service.

    N.B. If the previous mode is user mode, alerts are being tested, a user
         APC is available to execute, and the specified context record was
         previously placed on the stack by the user APC initialization routine,
         then bypass context record copy to the kernel frames and back again.

Arguments:

    ContextRecord - Supplies a pointer to a context record.

    TestAlert - Supplies a boolean value that determines whether a test alert
       is to be performed.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if the context record is not readable
        from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the context record is not
        properly aligned.

    STATUS_SUCCESS + 1 is returned if the context frame is copied successfully
        to the specified exception and trap frames.

    STATUS_SUCCESS is returned if the context record copy was bypassed and
        another user APC is ready to be delivered.

--*/

{

    KIRQL OldIrql;
    NTSTATUS Status;
    PKTHREAD Thread;
    ULONG64 UserStack;

    //
    // Synchronize with other context operations.
    //
    // If the current IRQL is less than APC_LEVEL, then raise IRQL to APC level.
    // 

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < APC_LEVEL) {
        KfRaiseIrql(APC_LEVEL);
    }

    //
    // If the previous mode was not kernel mode, then attempt to bypass
    // the copy of the context record. Otherwise, copy context to kernel
    // frames directly.
    // 
      
    Status = STATUS_SUCCESS + 1;
    Thread = KeGetCurrentThread();
    if (Thread->PreviousMode != KernelMode) {
        try {
            if (TestAlert != FALSE) {
                ProbeForWriteSmallStructure(ContextRecord,
                                            sizeof(CONTEXT),
                                            CONTEXT_ALIGN);

                KeTestAlertThread(UserMode);
                UserStack = (ContextRecord->Rsp  - sizeof(MACHINE_FRAME)) & ~STACK_ROUND;
                if (((UserStack - sizeof(CONTEXT)) == (ULONG64)ContextRecord) &&
                    (Thread->ApcState.UserApcPending != FALSE)) {

                    //
                    // Save the context record and exception frame addresses
                    // in the trap frame and deliver the user APC bypassing
                    // the context copy.
                    //

                    TrapFrame->ContextRecord = (ULONG64)ContextRecord;
                    TrapFrame->ExceptionFrame = (ULONG64)ExceptionFrame;
                    KiDeliverApc(UserMode, NULL, TrapFrame);
                    Status = STATUS_SUCCESS;
                    leave;
                }

            } else {
                ProbeForReadSmallStructure(ContextRecord,
                                           sizeof(CONTEXT),
                                           CONTEXT_ALIGN);
            }

            KiContinuePreviousModeUser(ContextRecord,
                                       ExceptionFrame,
                                       TrapFrame);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
        }

    } else {
        KeContextToKframes(TrapFrame,
                           ExceptionFrame,
                           ContextRecord,
                           ContextRecord->ContextFlags,
                           KernelMode);

        if (TestAlert != FALSE) {
            KeTestAlertThread(KernelMode);
        }
    }

    //
    // If the old IRQL was less than APC level, then lower the IRQL to its
    // previous value.
    //

    if (OldIrql < APC_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    return Status;
}

VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called to initialize the context for a user mode APC.

Arguments:

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    NormalRoutine - Supplies a pointer to the user mode APC routine.

    NormalContext - Supplies a pointer to the user context for the APC
        routine.

    SystemArgument1 - Supplies the first system supplied value.

    SystemArgument2 - Supplies the second system supplied value.

Return Value:

    None.

--*/

{

    PCONTEXT ContextRecord;
    EXCEPTION_RECORD ExceptionRecord;
    PMACHINE_FRAME MachineFrame;

    //
    // Transfer the context information to the user stack, initialize the
    // APC routine parameters, and modify the trap frame so execution will
    // continue in user mode at the user mode APC dispatch routine.
    //

    try {

        //
        // If the exception frame address is NULL, then the context copy
        // has been bypassed and the context is already on the user stack.
        //

        if (ExceptionFrame == NULL) {

            //
            // The address of the already copied context record and the real
            // exception frame address are passed via unused fields in the
            // trap frame.
            //
            // N.B. The context record has been probed for write access.
            //

            ContextRecord = (PCONTEXT)TrapFrame->ContextRecord;
            ExceptionFrame = (PKEXCEPTION_FRAME)TrapFrame->ExceptionFrame;

        } else {

            //
            // Compute address of aligned machine frame, compute address of
            // context record, and probe user stack for writeability.
            //
    
            MachineFrame =
                (PMACHINE_FRAME)((TrapFrame->Rsp - sizeof(MACHINE_FRAME)) & ~STACK_ROUND);
    
            ContextRecord = (PCONTEXT)((ULONG64)MachineFrame - sizeof(CONTEXT));
            ProbeForWriteSmallStructure(ContextRecord,
                                        sizeof(MACHINE_FRAME) + CONTEXT_LENGTH,
                                        STACK_ALIGN);
    
            //
            // Move machine state from trap and exception frames to the context
            // record on the user stack.
            //
    
            ContextRecord->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
            KeContextFromKframes(TrapFrame, ExceptionFrame, ContextRecord);

            //
            // Fill in machine frame information.
            //
    
            MachineFrame->Rsp = ContextRecord->Rsp;
            MachineFrame->Rip = ContextRecord->Rip;
        }

        //
        // Initialize the user APC parameters.
        //

        ContextRecord->P1Home = (ULONG64)NormalContext;
        ContextRecord->P2Home = (ULONG64)SystemArgument1;
        ContextRecord->P3Home = (ULONG64)SystemArgument2;
        ContextRecord->P4Home = (ULONG64)NormalRoutine;

        //
        // Set the address new stack pointer in the current trap frame and
        // the continuation address so control will be transferred to the user
        // APC dispatcher.
        //

        TrapFrame->Rsp = (ULONG64)ContextRecord;
        TrapFrame->Rip = (ULONG64)KeUserApcDispatcher;

    } except (KiCopyInformation(&ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Lower the IRQL to PASSIVE_LEVEL, set the exception address to
        // the current program address, and raise an exception by calling
        // the exception dispatcher.
        //
        // N.B. The IRQL is lowered to PASSIVE_LEVEL to allow APC interrupts
        //      during the dispatching of the exception. The current thread
        //      will be terminated during the dispatching of the exception,
        //      but lowering of the IRQL is required to enable the debugger
        //      to obtain the context of the current thread.
        //

        KeLowerIrql(PASSIVE_LEVEL);
        ExceptionRecord.ExceptionAddress = (PVOID)(TrapFrame->Rip);
        KiDispatchException(&ExceptionRecord,
                            ExceptionFrame,
                            TrapFrame,
                            UserMode,
                            TRUE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\callout.asm ===
title  "Call Out to User Mode"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   callout.asm
;
; Abstract:
;
;   This module implements the code necessary to call out from kernel
;   mode to user mode.
;
;--

include ksamd64.inc

        altentry KiSwitchKernelStackContinue
        altentry KxSwitchKernelStackCallout

        extern  KeBugCheck:proc
        extern  KeBugCheckEx:proc
        extern  KeUserCallbackDispatcher:qword
        extern  KiSystemServiceExit:proc
        extern  KiRestoreDebugRegisterState:proc
        extern  MmGrowKernelStack:proc
        extern  MmGrowKernelStackEx:proc
        extern  PsConvertToGuiThread:proc

        subttl  "Call User Mode Function"
;++
;
; NTSTATUS
; KiCallUserMode (
;     IN PVOID *Outputbuffer,
;     IN PULONG OutputLength
;     )
;
; Routine Description:
;
;   This function calls a user mode function from kernel mode.
;
;   N.B. This function calls out to user mode and the callback return
;        function returns back to the caller of this function. Therefore,
;        the stack layout must be consistent between the two routines.
;
; Arguments:
;
;   OutputBuffer (rcx) - Supplies a pointer to the variable that receives
;       the address of the output buffer.
;
;   OutputLength (rdx) - Supplies a pointer to a variable that receives
;       the length of the output buffer.
;
; Return Value:
;
;   The final status of the call out function is returned as the status
;   of the function.
;
;   N.B. This function does not return to its caller. A return to the
;        caller is executed when a callback return system service is
;        executed.
;
;   N.B. This function does return to its caller if a kernel stack
;        expansion is required and the attempted expansion fails.
;
;--

        NESTED_ENTRY KiCallUserMode, _TEXT$00

        GENERATE_EXCEPTION_FRAME <Rbp>  ; generate exception frame

;
; Save argument registers in frame and allocate a legacy floating point
; save area.
;

        mov     CuOutputBuffer[rbp], rcx ; save output buffer address
        mov     CuOutputLength[rbp], rdx ; save output length address

;
; Check if the current IRQL is above passive level.
;

        mov     rbx, gs:[PcCurrentThread] ; get current thread address

if DBG

        xor     r9, r9                  ; clear parameter value
        mov     r8, cr8                 ; get current IRQL
        or      r8, r8                  ; check if IRQL is passive level
        mov     ecx, IRQL_GT_ZERO_AT_SYSTEM_SERVICE ; set bugcheck code
        jnz     short KiCU05            ; if nz, IRQL not passive level

;
; Check if kernel APCs are disabled or a process is attached.
;

        movzx   r8d, byte ptr ThApcStateIndex[rbx] ; get APC state index
        mov     r9d, ThCombinedApcDisable[rbx] ; get kernel APC disable
        or      r9d, r9d                ; check if kernel APCs disabled
        jnz     short KiCU03            ; if nz, Kernel APCs disabled
        or      r8d, r8d                ; check if process attached
        jz      short KiCU07            ; if z, process not attached
KiCU03: mov     ecx, APC_INDEX_MISMATCH ; set bugcheck code
KiCU05: mov     rdx, ExReturn[rbp]      ; set call out return address
        xor     r10, r10                ; clear trap frame address
        mov     ExP5[rbp], r10          ; set bugcheck parameter
        call    KeBugCheckEx            ; bugcheck system - no return

endif

;
; Check if sufficient room is available on the kernel stack for another
; system call.
;

KiCU07: sub     rsp, KERNEL_STACK_CONTROL_LENGTH ; allocate stack control save area
        lea     r15, (- KERNEL_LARGE_STACK_COMMIT)[rsp] ; compute low address
        cmp     r15, ThStackLimit[rbx]  ; check if limit exceeded
        jae     short KiCU10            ; if ae, limit not exceeded
        mov     rcx, rsp                ; set current stack address
        call    MmGrowKernelStack       ; attempt to grow kernel stack
        or      eax, eax                ; check for successful completion
        jne     KiUC30                  ; if ne, attempt to grow failed

;
; Save the callback stack address and the initial stack address in the current
; frame.
;

KiCU10: mov     rax, ThCallbackStack[rbx] ; save current callback stack address
        mov     CuCallbackStack[rbp], rax ;
        mov     rdx, ThInitialStack[rbx] ; save initial stack address
        mov     CuInitialStack[rbp], rdx ;
        mov     ThCallbackstack[rbx], rbp ; set new callback stack address

;
; Initialize the current and previous kernel stack segment descriptors in the
; kernel stack control area. These descriptors are used to control kernel
; stack expansion from drivers.
;

        mov     qword ptr KcPreviousBase[rsp], 0 ; clear previous base
        mov     rax, KcCurrentBase[rdx] ; set current stack base
        mov     KcCurrentBase[rsp], rax ;
        mov     rax, KcActualLimit[rdx] ; set current stack limit
        mov     KcActualLimit[rsp], rax ;

;
; Save the current trap frame address and establish a new initial kernel stack
; address;
;

        mov     rsi, ThTrapFrame[rbx]   ; save current trap frame address
        mov     CuTrapFrame[rbp], rsi   ;
        cli                             ; disable interrupts
        mov     rdi, gs:[PcTss]         ; get processor TSS address
        mov     ThInitialStack[rbx], rsp ; set new initial stack address
        mov     TssRsp0[rdi], rsp       ; set initial stack address in TSS
        mov     gs:[PcRspBase], rsp     ; set initial stack address in PRCB

;
; Check to determine if a user mode APC is pending.
;
; N.B. Interrupts are not enabled throughout the remainder of the system
;      service exit.
;

        cmp     byte ptr ThApcState + AsUserApcPending[rbx], 0 ; APC pending?
        jne     short KiUC20            ; if ne, user APC pending

;
; A user APC is not pending.
;
; Exit directly back to user mode without building a trap frame.
;

        lea     rbp, 128[rsi]           ; get previous trap frame address
        ldmxcsr TrMxCsr[rbp]            ; restore previous MXCSR
        test    word ptr TrDr7[rbp], DR7_ACTIVE ; test if debug active
        jz      short @f                ; if z, debug not active
        call    KiRestoreDebugRegisterState ; restore user debug register state
@@:     mov     r8, TrRsp[rbp]          ; get previous RSP value
        mov     r9, TrRbp[rbp]          ; get previous RBP value
        xor     r10, r10                ; scrub volatile integer registers
        pxor    xmm0, xmm0              ; scrub volatile floating registers
        pxor    xmm1, xmm1              ;
        pxor    xmm2, xmm2              ;
        pxor    xmm3, xmm3              ;
        pxor    xmm4, xmm4              ;
        pxor    xmm5, xmm5              ;
        mov     rcx, KeUserCallbackDispatcher ; set user return address
        mov     r11, TrEFlags[rbp]      ; get previous EFLAGS
        mov     rbp, r9                 ; restore RBP
        mov     rsp, r8                 ; restore RSP
        swapgs                          ; swap GS base to user mode TEB
        sysretq                         ; return from system call to user mode

;
; A user APC is pending.
;
; Construct a trap frame to facilitate the transfer into user mode via
; the standard system call exit.
;
; N.B. The below code uses an unusual sequence to transfer control. This
;      instruction sequence is required to avoid detection as an epilogue.
;

KiUC20: sub     rsp, KTRAP_FRAME_LENGTH ; allocate a trap frame
        mov     rdi, rsp                ; set destination address
        mov     ecx, (KTRAP_FRAME_LENGTH / 8) ; set length of copy
    rep movsq                           ; copy trap frame
        lea     rbp, 128[rsp]           ; set frame pointer address
        mov     rax, KeUserCallbackDispatcher ; set user return address
        mov     TrRip[rbp], rax         ;
        lea     rcx, KiSystemServiceExit ; get address of service exit
        jmp     rcx                     ; finish in common code

;
; An attempt to grow the kernel stack failed.
;

KiUC30: mov     rsp, rbp                ; deallocate legacy save area

        RESTORE_EXCEPTION_STATE <Rbp>   ; restore exception state/deallocate

        ret                             ;

        NESTED_END KiCallUserMode, _TEXT$00

        subttl  "Convert To Gui Thread"
;++
;
; NTSTATUS
; KiConvertToGuiThread (
;     VOID
;     );
;
; Routine Description:
;
;   This routine is a stub routine which is called by the system service
;   dispatcher to convert the current thread to a GUI thread. The process
;   of converting to a GUI mode thread involves allocating a large stack,
;   switching to the large stack, and then calling the win32k subsystem
;   to record state. In order to switch the kernel stack the frame pointer
;   used in the system service dispatch must be relocated. 
;
;   N.B. The address of the pushed rbp in this routine is located from the
;        trap frame address in switch kernel stack.
;
;   N.B. This routine diverges from the calling standard in that the caller
;        (KiSystemCall64) expects the parameter home addresses to be preserved.
;
; Arguments:
;
;   None.
;
; Implicit arguments:
;
;   rbp - Supplies a pointer to the trap frame.
;
; Return Value:
;
;   The status returned by the real convert to GUI thread is returned as the
;   function status.
;
;--

CgFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        SavedRbp dq ?                   ; saved nonvolatile register
CgFrame ends

        NESTED_ENTRY KiConvertToGuiThread, _TEXT$00

        push_reg rbp                    ; save frame pointer
        alloc_stack (sizeof CgFrame - 8) ; allocate stack frame

        END_PROLOGUE

        call    PsConvertToGuiThread    ; convert to GUI thread
        add     rsp, (sizeof CgFrame - 8) ; deallocate stack frame
        pop     rbp                     ; restore frame pointer
        ret                             ;

        NESTED_END KiConvertToGuiThread, _TEXT$00

        subttl  "Switch Kernel Stack"
;++
;
; PVOID
; KeSwitchKernelStack (
;     IN PVOID StackBase,
;     IN PVOID StackLimit
;     )
;
; Routine Description:
;
;   This function switches to the specified large kernel stack.
;
;   N.B. This function can ONLY be called when there are no variables
;        in the stack that refer to other variables in the stack, i.e.,
;        there are no pointers into the stack.
;
;   N.B. The address of the frame pointer used in the system service
;        dispatcher is located using the trap frame.
;
; Arguments:
;
;   StackBase (rcx) - Supplies a pointer to the base of the new kernel
;       stack.
;
;   StackLimit (rdx) - Supplies a pointer to the limit of the new kernel
;       stack.
;
; Return Value:
;
;   The previous stack base is returned as the function value.
;
;--

SkFrame struct
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRdi dq ?                   ; saved register RDI
        SavedRsi dq ?                   ; saved register RSI
SkFrame ends

        NESTED_ENTRY KeSwitchKernelStack, _TEXT$00

        alloc_stack (sizeof SkFrame)    ; allocate stack frame
        save_reg rdi, SkFrame.SavedRdi  ; save nonvolatile registers
        save_reg rsi, SkFrame.savedRsi  ;

        END_PROLOGUE

;
; Save the address of the new stack and copy the current stack to the new
; stack.
;

        mov     r8, rcx                 ; save new stack base address
        mov     r10, gs:[PcCurrentThread] ; get current thread address
        mov     rcx, ThStackBase[r10]   ; get current stack base address
        mov     r9, ThTrapFrame[r10]    ; get current trap frame address
        sub     r9, rcx                 ; relocate trap frame address
        add     r9, r8                  ;
        mov     ThTrapFrame[r10], r9    ; set new trap frame address
        sub     rcx, rsp                ; compute length of copy in bytes
        mov     rdi, r8                 ; compute destination address of copy
        sub     rdi, rcx                ;
        mov     r9, rdi                 ; save new stack pointer address
        mov     rsi, rsp                ; set source address of copy
        shr     rcx, 3                  ; compute length of copy on quadwords
    rep movsq                           ; copy old stack to new stack
        mov     rcx, ThTrapFrame[r10]   ; get new trap frame address
        lea     rax, 128[rcx]           ; compute new frame address
        mov     (-2 * 8)[rcx], rax      ; set relocated frame pointer 

;
; Switch to the new kernel stack, initialize the current and previous kernel
; stack segment descriptors in the kernel stack control area, and return the
; address of the old kernel stack.
;

        mov     rax, ThStackBase[r10]   ; get current stack base address
        cli                             ; disable interrupts
        mov     byte ptr ThLargeStack[r10], 1 ; set large stack TRUE
        mov     ThStackBase[r10], r8    ; set new stack base address
        sub     r8, KERNEL_STACK_CONTROL_LENGTH ; compute initial stack address
        mov     ThInitialStack[r10], r8 ; set new initial stack address
        mov     ThStackLimit[r10], rdx  ; set new stack limit address
        mov     r10, gs:[PcTss]         ; get processor TSS address
        mov     TssRsp0[r10], r8        ; set initial stack address in TSS
        mov     gs:[PcRspBase], r8      ; set initial stack address in PRCB
        mov     rsp, r9                 ; set new stack pointer address
        mov     qword ptr KcPreviousBase[r8], 0 ; clear previous base
        lea     r9, KERNEL_STACK_CONTROL_LENGTH[r8] ; set current stack base
        mov     KcCurrentBase[r8], r9   ;
        sub     r9, KERNEL_LARGE_STACK_SIZE ; set actual stack limit
        mov     KcActualLimit[r8], r9  ;
        sti                             ; enable interrupts
        mov     rdi, SkFrame.SavedRdi[rsp] ; restore nonvolatile registers
        mov     rsi, SkFrame.SavedRsi[rsp] ;
        add     rsp, (sizeof SkFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END KeSwitchKernelStack, _TEXT$00

        subttl  "Switch Kernel Stack and Callout Handler Exception"
;++
;
; EXCEPTION_DISPOSITION
; KiSwitchKernelStackAndCalloutHandler (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN UINT_PTR EstablisherFrame,
;     IN OUT PCONTEXT ContextRecord,
;     IN OUT PDISPATCHER_CONTEXT DispatcherContext
;     )
;
; Routine Description:
;
;   This function is called when an unhandled exception occurs while the
;   kernel stack has been expanded and a callout is active. This is a fatal
;   condition and causes a bugcheck.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;   None.
;
;--

KhFrame struct
        P1Home  dq ?                    ; argument home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        Fill    dq ?                    ; fill to 0 mod 8
KhFrame ends

        NESTED_ENTRY KiSwitchKernelStackAndCalloutHandler, _TEXT$00

        alloc_stack (sizeof KhFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     ecx, KMODE_EXCEPTION_NOT_HANDLED ; set bugcheck code
        call    KeBugCheck              ; bugcheck the system
        nop                             ; fill - do not remove

        NESTED_END KiSwitchKernelStackAndCalloutHandler, _TEXT$00

        subttl  "Switch Kernel Stack and Callout"
;++
;
; VOID
; KiSwitchKernelStackAndCallout (
;     IN PVOID Parameter,
;     IN PEXPAND_STACK_CALLOUT Callout,
;     IN PVOID LargeStack,
;     IN SIZE_T CommitSize
;     )
;
; Routine Description:
;
;   This function initializes the kernel stack control region of the new
;   stack, sets the new stack parameters for the current thread, calls
;   the specified function with the specified argument, and reverses the
;   process on return from the called function.
;
; Arguments:
;
;   Parameter (rcx) - Supplies a the call out routine parameter.
;
;   Callout (rdx) - Supplies a pointer to the call out function.
;
;   LargeStack (r8) - Supplies the base address of a large kernel stack.
;
;   CommitSize (r9) - Supplies the stack commit size in bytes page aligned.
;   
; Return Value:
;
;   The previous stack base is returned as the function value.
;
;--

KoFrame struct
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRdi dq ?                   ; saved register RDI
        SavedRsi dq ?                   ; saved register RSI
KoFrame ends

KbFrame struct
        P1home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        MfCode  dq ?                    ; dummy machine frame
        MfRip   dq ?                    ;
        MfSegCs dq ?                    ;
        MfEFlags dq ?                   ;
        MfRsp   dq ?                    ;
        MfSeqSs dq ?                    ;
KbFrame ends

        NESTED_ENTRY KiSwitchKernelStackAndCallout, _TEXT$00, KiSwitchKernelStackAndCalloutHandler

        alloc_stack (sizeof KoFrame)    ; allocate stack frame
        save_reg rdi, KoFrame.SavedRdi  ; save nonvolatile registers
        save_reg rsi, KoFrame.savedRsi  ;

        END_PROLOGUE

;
; Save the current thread stack parameters in the previous section of the
; kernel stack control area.
;

        mov     rsi, gs:[PcCurrentThread] ; get current thread address
        mov     rdi, rsp                ; save current stack address
        lea     rax, (-KERNEL_STACK_CONTROL_LENGTH)[r8] ; get initial stack address
        mov     r10, ThStackBase[rsi]   ; save current stack base
        mov     KcPreviousBase[rax], r10 ;
        mov     r10, ThStackLimit[rsi]  ; save current stack limit
        mov     KcPreviousLimit[rax], r10 ;
        mov     KcPreviousKernel[rax], rdi ; save current kernel stack
        mov     r10, ThInitialStack[rsi] ; save initial stack address
        mov     KcPreviousInitial[rax], r10 ;

;
; Initialize the current thread parameters in the current section of the
; kernel stack control area.
;

        mov     KcCurrentBase[rax], r8  ; set current stack base
        lea     r11, (-KERNEL_LARGE_STACK_SIZE)[r8] ; set actual stack limit
        mov     KcActualLimit[rax], r11 ;

;
; Initialize a dummy machine frame and parameter home address area on the
; new stack.
;
; N.B. Only the return address and previous stack pointer are filled into
;      the dummy machine frame.
;

        lea     r11, (-(sizeof KbFrame))[rax] ; get new frame address
        lea     r10, KiSwitchKernelStackContinue ; set RIP in machine frame
        mov     KbFrame.MfRip[r11], r10 ;
        mov     KbFrame.MfRsp[r11], rdi ; set RSP in machine frame

;
; Initialize new thread stack parameters and jump dispatch routine.
;

        cli                             ; disable interupts
        mov     ThStackBase[rsi], r8    ; set new stack base
        sub     r8, KERNEL_LARGE_STACK_COMMIT ; set new stack limit
        mov     ThStackLimit[rsi], r8   ;
        mov     ThInitialStack[rsi], rax ; set new initial stack
        mov     rsp, r11                ; set new stack pointer
        sti                             ; enable interrupt
        jmp     KxSwitchKernelStackCallout ; call specified routine

;
; Continue from callout on original stack with
;

        ALTERNATE_ENTRY KiSwitchKernelStackContinue

        mov     rdi, KoFrame.SavedRdi[rsp] ; restore nonvolatile registers
        mov     rsi, KoFrame.SavedRsi[rsp] ;
        add     rsp, (sizeof KoFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END KiSwitchKernelStackAndCallout, _TEXT$00

;++
;
; This is a dummy function to effect a call out on an expanded stack with
; the proper unwind information.
;
; N.B. The prologue is not executed and the stack frame is set up before
;      transferring control to the alternate entry.
;
;
; At entry to this dummy function:
;
;    rcx - Supplies the call out routine parameter.
;    rdx - Supplies the address of the call out routine.
;    rsi - Supplies the current thread address.
;    rdi - Supplies the old kernel stack address.
;    rsp - Supplies the new stack address.
;    r9 - Supplies the required commit limit.
;       
;--

        NESTED_ENTRY KySwitchKernelStackCallout, _TEXT$00

        push_frame code                 ;
        .allocstack 32                  ; 

        END_PROLOGUE

        ALTERNATE_ENTRY KxSwitchKernelStackCallout

        mov     KbFrame.MfCode[rsp], rcx ; save call out parameter
        mov     KbFrame.MfEFlags[rsp], rdx ; save call out routine address
        mov     rcx, rsp                ; set current kernel stack
        mov     rdx, r9                 ; set require commit size
        call    MmGrowKernelStackEx     ; grow stack to required commitment
        test    eax, eax                ; test if stack committed
        jnz     short KxKO10            ; if nz, stack not committed
        mov     rcx, KbFrame.MfCode[rsp] ; set call out parameter
        call    KbFrame.MfEFlags[rsp]   ; call specified routine
        xor     eax, eax                ; set success completion status

;
; Restore the thread stack parameters and finish in previous code.
;
; N.B. The TSS initial stack and the PRCB initial stack only needs to be
;      reloaded after the call out and just before switching back to the
;      previous stack. This is in contrast to the user mode call code
;      which reloads these two values in both directions. The reason this
;      is possible is because the thread can not return to user mode
;      until after the call out is complete and any exceptions or interrupts
;      will nest on the current kernel stack.
;

KxKO10: mov     rcx, ThInitialStack[rsi] ; get address of initial frame
        cli                             ; disable interrupts
        mov     r10, KcPreviousBase[rcx] ; set stack base
        mov     ThStackBase[rsi], r10   ;
        mov     r10, KcPreviouslimit[rcx] ; set stack limit
        mov     ThStackLimit[rsi], r10  ;
        mov     r10, KcPreviousInitial[rcx] ; set initial stack
        mov     ThInitialStack[rsi], r10 ;
        mov     rdx, gs:[PcTss]         ; get processor TSS address
        mov     TssRsp0[rdx], r10       ; set initial stack address in TSS
        mov     gs:[PcRspBase], r10     ; set initial stack address in PRCB
        mov     rsp, rdi                ; set previous stack address
        sti                             ; enable interrupts
        jmp     KiSwitchKernelStackContinue ; finish in common code

        NESTED_END KySwitchKernelStackCallout, _TEXT$00

        subttl  "Return from User Mode Callback"
;++
;
; NTSTATUS
; NtCallbackReturn (
;     __in __opt PVOID OutputBuffer,
;     __in ULONG OutputLength,
;     __in NTSTATUS Status
;     )
;
; Routine Description:
;
;   This function returns from a user mode callout to the kernel
;   mode caller of the user mode callback function.
;
;   N.B. This function returns to the function that called out to user mode
;        using the call user mode function. Therefore, the stack layout must
;        be consistent between the two routines.
;
; Arguments:
;
;   OutputBuffer (rcx) - Supplies an optional pointer to an output buffer.
;
;   OutputLength (edx) - Supplies the length of the output buffer.
;
;   Status (r8d) - Supplies the status value returned to the caller of the
;       callback function.
;
; Return Value:
;
;   If the callback return cannot be executed, then an error status is
;   returned. Otherwise, the specified callback status is returned to
;   the caller of the callback function.
;
;   N.B. This function returns to the function that called out to user
;        mode is a callout is currently active.
;
;--

CbFrame struct
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRdi dq ?                   ; saved register RDI
        SavedRsi dq ?                   ; saved register RSI
CbFrame ends

        NESTED_ENTRY NtCallbackReturn, _TEXT$00

        alloc_stack (sizeof CbFrame)    ; allocate stack frame
        save_reg rdi, CbFrame.SavedRdi  ; save nonvolatile registers
        save_reg rsi, CbFrame.savedRsi  ;

        END_PROLOGUE

        mov     r11, gs:[PcCurrentThread] ; get current thread address
        mov     r10, ThCallbackStack[r11] ; get callback stack address
        cmp     r10, 0                  ; check if callback active
        je      KiCb10                  ; if zero, callback not active
        mov     eax, r8d                ; save completion status

;
; Store the output buffer address and length.
;

        mov     r9, CuOutputBuffer[r10] ; get address to store output buffer
        mov     [r9], rcx               ; store output buffer address
        mov     r9, CuOutputLength[r10] ; get address to store output length
        mov     [r9], edx               ; store output buffer length

;
; Restore the previous callback stack address and trap frame address.
;

        cli                             ; disable interrupts
        mov     r8, CuTrapFrame[r10]    ; get previous trap frame address
        mov     r9, ThTrapFrame[r11]    ; get current trap frame
        mov     ThTrapFrame[r11], r8    ; restore previous trap frame address

;
; If debug registers are active, then copy the debug registers from the
; current trap frame to the previous trap frame.
;
; N.B. Trap frame offsets are biased offsets.
;

        test    byte ptr ThDebugActive[r11], TRUE ; test if debug enabled
        mov     word ptr TrDr7 + 128[r8], 0 ; assume debug not enabled
        jz      short KiCB05            ; if z, debug not enabled
        mov     rcx, TrDr0 + 128[r9]    ; move current debug registers to
        mov     rdx, TrDr1 + 128[r9]    ;   previous trap frame
        mov     TrDr0 + 128[r8], rcx    ;
        mov     TrDr1 + 128[r8], rdx    ;
        mov     rcx, TrDr2 + 128[r9]    ;
        mov     rdx, TrDr3 + 128[r9]    ;
        mov     TrDr2 + 128[r8], rcx    ;
        mov     TrDr3 + 128[r8], rdx    ;
        mov     rcx, TrDr7 + 128[r9]    ;
        mov     TrDr7 + 128[r8], rcx    ;
KiCB05: mov     r8, CuCallbackStack[r10] ; get previous callback stack address
        mov     ThCallbackStack[r11], r8 ; restore previous callback stack address

;
; Restore initial stack address and restore exception state.
;

        mov     r9, CuInitialStack[r10] ; get previous initial stack address
        mov     ThInitialStack[r11], r9 ; restore initial stack address
        mov     r8, gs:[PcTss]          ; get processor TSS address
        mov     TssRsp0[r8], r9         ; set initial stack address in TSS
        mov     gs:[PcRspBase], r9      ; set initial stack address in PRCB
        mov     rsp, r10                ; trim stack back to callback frame

        RESTORE_EXCEPTION_STATE <Rbp>   ; restore exception state/deallocate

        sti                             ; enable interrupts
        ret                             ; return

;
; No callback is currently active.
;

KiCB10: mov     eax, STATUS_NO_CALLBACK_ACTIVE ; set service status
        mov     rdi, CbFrame.SavedRdi[rsp] ; restore nonvolatile registers
        mov     rsi, CbFrame.savedRsi[rsp] ;
        add     rsp, sizeof CbFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END NtCallbackReturn, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\clockint.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   clockint.asm
;
; Abstract:
;
;   This module implements the architecture dependent code necessary to
;   process the interval clock interrupt.
;
;--

include ksamd64.inc

        extern  ExpInterlockedPopEntrySListEnd:proc
        extern  ExpInterlockedPopEntrySListResume:proc
        extern  KeMaximumIncrement:dword
        extern  KeTimeAdjustment:dword
        extern  KeUpdateRunTime:proc
        extern  KiCheckForSListAddress:proc
        extern  KiDpcInterruptBypass:proc
        extern  KiIdleSummary:qword
        extern  KiInitiateUserApc:proc
        extern  KiRestoreDebugRegisterState:proc
        extern  KiSaveDebugRegisterState:proc
        extern  KiTimeIncrement:qword
        extern  KiTimerTableListHead:qword
        extern  __imp_HalRequestSoftwareInterrupt:qword

        subttl  "Update System Time"
;++
;
; VOID
; KeUpdateSystemTime (
;     IN PKTRAP_FRAME TrapFrame,
;     IN ULONG64 Increment
;     )
;
; Routine Description:
;
;   This routine is called as the result of an interrupt generated by the
;   interval timer. Its function is to update the interrupt time, update the
;   system time, and check to determine if a timer has expired.
;
;   N.B. This routine is executed on a single processor in a multiprocess
;        system. The remainder of the processors only execute the quantum end
;        and runtime update code.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies the address of a trap frame.
;
;   Increment (rdx) - Supplies the time increment value in 100 nanosecond
;       units.
;
; Return Value:
;
;   None.
;
;--

UsFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?
        SavedRbp dq ?                   ; saved register RBP
UsFrame ends

        NESTED_ENTRY KeUpdateSystemTime, _TEXT$00

        alloc_stack (sizeof UsFrame)    ; allocate stack frame
        save_reg rbp, UsFrame.SavedRbp  ; save nonvolatile register

        END_PROLOGUE

        lea     rbp, 128[rcx]           ; set display pointer address
        mov     KiTimeIncrement, rdx    ; save time increment value

;
; Check if the current clock tick should be skipped.
;
; Skip tick is set when the kernel debugger is entered.
;

if DBG

        cmp     byte ptr gs:[PcSkipTick], 0 ; check if tick should be skipped
        jnz     KiUS50                  ; if nz, skip clock tick

endif

;
; Update interrupt time.
;
; N.B. Interrupt time is aligned 0 mod 8.
;

        mov     rcx, USER_SHARED_DATA   ; get user shared data address
        lea     r11, KiTimerTableListHead ; get timer table address
        mov     r8, UsInterruptTime[rcx] ; get interrupt time
        add     r8, rdx                 ; compute updated interrupt time
        ror     r8, 32                  ; swap upper and lower halves
        mov     UsInterruptTime + 8[rcx], r8d ; save 2nd upper half
        ror     r8, 32                  ; swap upper and lower halves
        mov     UsInterruptTime[rcx], r8 ; save updated interrupt time
        mov     r10, UsTickCount[rcx]   ; get tick count value

ifndef NT_UP

   lock sub     gs:[PcMasterOffset], edx ; subtract time increment

else

        sub     gs:[PcMasterOffset], edx ; subtract time increment

endif

        jg      short KiUS20            ; if greater, not complete tick
        mov     eax, KeMaximumIncrement ; get maximum time increment
        add     gs:[PcMasterOffset], eax ; add maximum time to residue

;
; Update system time.
;
; N.B. System time is aligned 4 mod 8, however, this data does not cross
;      a cache line and is, therefore, updated atomically,
;

        mov     eax, KeTimeAdjustment   ; get time adjustment value
        add     rax, UsSystemTime[rcx]  ; compute updated system time
        ror     rax, 32                 ; swap upper and lower halves
        mov     UsSystemTime + 8[rcx], eax ; save upper 2nd half
        ror     rax, 32                 ; swap upper and lower halves
        mov     UsSystemTime[rcx], rax  ; save updated system time

;
; Update tick count.
;
; N.B. Tick count is aligned 0 mod 8.
;
        
        mov     rax, UsTickCount[rcx]   ; get tick count
        inc     rax                     ; increment tick count
        ror     rax, 32                 ; swap upper and lower halves
        mov     UsTickCount + 8[rcx], eax ; save 2nd upper half
        ror     rax, 32                 ; swap upper and lower halves
        mov     UsTickCount[rcx], rax   ; save updated tick count

;
; Check to determine if a timer has expired.
;

        .errnz  (TIMER_ENTRY_SIZE - 24)

        mov     rcx, r10                ; copy tick count value
        and     ecx, TIMER_TABLE_SIZE - 1 ; isolate current hand value
        lea     rcx, [rcx + rcx * 2]    ; multiply by 3
        cmp     r8, TtTime[r11 + rcx * 8] ; compare due time
        jae     short KiUS30            ; if ae, timer has expired
        inc     r10                     ; advance tick count value

;
; Check to determine if a timer has expired.
;

KiUS20: mov     rcx, r10                ; copy tick count value
        and     ecx, TIMER_TABLE_SIZE - 1 ; isolate current hand value
        lea     rcx, [rcx + rcx * 2]    ; multiply by 3
        cmp     r8, TtTime[r11 + rcx * 8] ; compare due time
        jb      short KiUS40            ; if b, timer has not expired

;
; A timer has expired.
;
; Set the timer hand value in the current processor block if it is not already
; set.
;

KiUS30: mov     rdx, gs:[PcCurrentPrcb] ; get current processor block address
        cmp     qword ptr PbTimerRequest[rdx], 0 ; check if expiration active
        jne     short KiUS40            ; if ne, expiration already active
        mov     PbTimerHand[rdx], r10   ; set timer hand value
        mov     byte ptr PbInterruptRequest[rdx], TRUE ; set interrupt request

;
; Update runtime.
;

KiUS40: lea     rcx, (-128)[rbp]        ; set trap frame address
        mov     rdx, KiTimeIncrement    ; set time increment value
        call    KeUpdateRunTime         ; update runtime

if DBG

KiUS50: mov     byte ptr gs:[PcSkipTick], 0 ; clear skip tick indicator

endif

        mov     rbp, UsFrame.SavedRbp[rsp] ; restore nonvolatile register
        add     rsp, (sizeof UsFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END KeUpdateSystemTime, _TEXT$00

        subttl  "Secondary Processor Clock Interrupt Service Routine"
;++
;
; VOID
; KiSecondaryClockInterrupt (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered as the result of an interprocessor interrupt
;   at CLOCK_LEVEL. Its function is to provide clock interrupt service on
;   secondary processors.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiSecondaryClockInterrupt, _TEXT$00

        .pushframe                      ; mark machine frame

        alloc_stack 8                   ; allocate dummy vector
        push_reg rbp                    ; save nonvolatile register

        GENERATE_INTERRUPT_FRAME <>, <Direct> ; generate interrupt frame

        mov     ecx, CLOCK_LEVEL        ; set new IRQL level

	ENTER_INTERRUPT <NoEoi>         ; raise IRQL and enable interrupts

;
; Update runtime.
;

        lea     rcx, (-128)[rbp]        ; set trap frame address
        mov     rdx, KiTimeIncrement    ; set time increment value
        call    KeUpdateRunTime         ; update runtime

        EXIT_INTERRUPT <>, <>, <Direct> ; do EOI, lower IRQL and restore state

        NESTED_END KiSecondaryClockInterrupt, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\cpuid.asm ===
title  "Processor Type and Stepping Detection"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the code necessary to determine cpu information.
;
;--

include ksamd64.inc

        altentry KiCpuIdFault

;++
;
; VOID
; KiCpuId (
;     ULONG Function,
;     ULONG Index,
;     PCPU_INFO CpuInfo
;     );
;
; Routine Description:
;
;   Executes the cpuid instruction and returns the resultant register
;   values.
;
; Arguments:
;
;   ecx - Supplies the cpuid function value.
;
;   edx - Supplies a index of cache descriptor. 
; 
;   r8  - Supplies the address a cpu information structure.
;
; Return Value:
;
;   The return values from the cpuid instruction are stored in the specified
;   cpu information structure.
;
;--

        NESTED_ENTRY KiCpuId, _TEXT$00

        push_reg rbx                    ; save nonvolatile register

        END_PROLOGUE

        mov     eax, ecx                ; set cpuid function
        mov     ecx, edx                ; set index (only used by function 4)
        cpuid                           ; get cpu information

        ALTERNATE_ENTRY KiCpuIdFault

        mov     CpuEax[r8], eax         ; save cpu information in structure
        mov     CpuEbx[r8], ebx         ;
        mov     CpuEcx[r8], ecx         ;
        mov     CpuEdx[r8], edx         ;
        pop     rbx                     ; restore nonvolatile register
        ret                             ; return

        NESTED_END KiCpuId, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\ctxswap.asm ===
title  "Context Swap"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   ctxswap.asm
;
; Abstract:
;
;   This module implements the code necessary to field the dispatch interrupt
;   and perform context switching.
;
;--

include ksamd64.inc

        extern  KeBugCheckEx:proc
        extern  KiCheckForSListAddress:proc
        extern  KiQuantumEnd:proc
        extern  KiQueueReadyThread:proc
        extern  KiRetireDpcList:proc
        extern  WmiTraceContextSwap:proc
        extern  __imp_HalRequestSoftwareInterrupt:qword

        subttl  "Swap Context"
;++
;
; BOOLEAN
; KiSwapContext (
;    IN PKTHREAD OldThread,
;    IN PKTHREAD NewThread
;    )
;
; Routine Description:
;
;   This function is a small wrapper that marshalls arguments and calls the
;   actual swap context routine.
;
;   N.B. The old thread lock has been acquired and the dispatcher lock dropped
;        before this routine is called.
;
;   N.B. The current thread address and the new thread state has been set
;        before this routine is called.
;
; Arguments:
;
;   OldThread (rcx) - Supplies the address of the old thread.
;
;   NewThread (rdx) - Supplies the address of the new thread.
;
; Return Value:
;
;   If a kernel APC is pending, then a value of TRUE is returned. Otherwise,
;   a value of FALSE is returned.
;
;--

        NESTED_ENTRY KiSwapContext, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     rbx, gs:[PcCurrentPrcb] ; get current PRCB address
        mov     rdi, rcx                ; set old thread address
        mov     rsi, rdx                ; set new thread address
        movzx   ecx, byte ptr ThWaitIrql[rdi] ; set APC interrupt bypass disable
        call    SwapContext             ; swap context

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KiSwapContext, _TEXT$00

        subttl  "Dispatch Interrupt"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a software interrupt generated
;   at DISPATCH_LEVEL. Its function is to process the DPC list, and then
;   perform a context switch if a new thread has been selected for execution
;   on the current processor.
;
;   This routine is entered at DISPATCH_LEVEL with the dispatcher database
;   unlocked.
;
; Arguments:
;
;   None
;
; Implicit Arguments:
;
;       rbp - Supplies the address of a trap frame.
;
; Return Value:
;
;   None.
;
;--

DiFrame struct
        P1Home  dq ?                    ; PRCB address parameter
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        SavedRbx dq ?                   ; saved RBX
DiFrame ends

        NESTED_ENTRY KiDispatchInterrupt, _TEXT$00

        alloc_stack (sizeof DiFrame)    ; allocate stack frame
        save_reg rbx, DiFrame.SavedRbx  ; save nonvolatile register

        END_PROLOGUE

;
; Check if an SLIST pop operation is being interrupted and reset RIP as
; necessary.
;

        lea     rcx, (-128)[rbp]        ; set trap frame address
        call    KiCheckForSListAddress  ; check SLIST addresses

;
; Check if the DPC queue has any entries to process.
;

        mov     rbx, gs:[PcCurrentPrcb] ; get current PRCB address
        and     byte ptr PbDpcInterruptRequested[rbx], 0 ; clear request
KiDI10: cli                             ; disable interrupts
        mov     eax, PbDpcQueueDepth[rbx] ; get DPC queue depth
        or      rax, PbTimerRequest[rbx] ; merge timer request value

ifndef NT_UP

        or      rax, PbDeferredReadyListHead[rbx] ; merge deferred ready list

endif

        jz      short KiDI20            ; if z, no DPCs to process
        mov     PbSavedRsp[rbx], rsp    ; save current stack pointer
        mov     rsp, PbDpcStack[rbx]    ; set DPC stack pointer
        mov     rcx, rbx                ; set PRCB address parameter
        call    KiRetireDpcList         ; process the DPC list
        mov     rsp, PbSavedRsp[rbx]    ; restore current stack pointer

;
; Check to determine if quantum end is requested.
;

KiDI20: sti                             ; enable interrupts
        cmp     byte ptr PbQuantumEnd[rbx], 0 ; check if quantum end request
        je      short KiDI40            ; if e, quantum end not requested
        and     byte ptr PbQuantumEnd[rbx], 0 ; clear quantum end indicator
        call    KiQuantumEnd            ; process quantum end

;
; Restore nonvolatile registers, deallocate stack frame, and return.
;

KiDI30: mov     rbx, DiFrame.SavedRbx[rsp] ; restore nonvolatile register
        add     rsp, (sizeof DiFrame)   ; deallocate stack frame
        ret                             ; return

;
; Check to determine if a new thread has been selected for execution on this
; processor.
;

KiDI40: cmp     qword ptr PbNextThread[rbx], 0 ; check if new thread selected
        je      short KiDI30            ; if eq, then no new thread

;
; Swap context to a new thread as the result of new thread being scheduled
; by the dispatch interrupt.
;

        mov     rbx, DiFrame.SavedRbx[rsp] ; restore nonvolatile register
        add     rsp, (sizeof DiFrame)   ; deallocate stack frame
        jmp     short KxDispatchInterrupt ;

        NESTED_END KiDispatchInterrupt, _TEXT$00

;
; There is a new thread scheduled for execution and the dispatcher lock
; has been acquired. Context switch to the new thread immediately.
;
; N.B. The following routine is entered by falling through from the above
;      routine.
;
; N.B. The following routine is carefully written as a nested function that
;      appears to have been called directly by the caller of the above
;      function which processes the dispatch interrupt.
;
; Arguments:
;
;   None.
;

        NESTED_ENTRY KxDispatchInterrupt, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     rbx, gs:[PcCurrentPrcb] ; get current PRCB address
        mov     rdi, PbCurrentThread[rbx] ; get old thread address

;
; Save current MXCSR and set initial value so swap context will be entered
; with a canonical MXCSR value.
;

        stmxcsr ExMxCsr[rsp]            ; save current MXCSR value
        ldmxcsr gs:[PcMxCsr]            ; set default MXCSR value

;
; Raise IRQL to SYNCH level, set context swap busy for the old thread, and
; acquire the current PRCB lock.
;

ifndef NT_UP

        mov     ecx, SYNCH_LEVEL        ; set IRQL to SYNCH level

        SetIrql                         ;

        mov     byte ptr ThSwapbusy[rdi], 1 ; set context swap busy

        AcquireSpinLock PbPrcbLock[rbx] ; acquire current PRCB lock

endif

;
; Get the next thread address, set the thread state to running, queue the old
; running thread, and swap context to the next thread.
;

        mov     rsi, PbNextThread[rbx]  ; get next thread address
        and     qword ptr PbNextThread[rbx], 0 ; clear next thread address
        mov     PbCurrentThread[rbx], rsi ; set current thread address
        mov     byte ptr ThState[rsi], Running ; set new thread state
        mov     byte ptr ThWaitReason[rdi], WrDispatchInt ; set wait reason
        mov     rcx, rdi                ; set address of old thread
        mov     rdx, rbx                ; set address of current PRCB
        call    KiQueueReadyThread      ; queue ready thread for execution
        mov     ecx, APC_LEVEL          ; set APC interrupt bypass disable
        call    SwapContext             ; call context swap routine

        ldmxcsr ExMxCsr[rsp]            ; restore current MXCSR value

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KxDispatchInterrupt, _TEXT$00

        subttl  "Swap Context"
;++
;
; Routine Description:
;
;   This routine is called to swap context from one thread to the next. It
;   swaps context, flushes the translation buffer, swaps the process address
;   space if necessary, and returns to its caller.
;
;   N.B. This routine is only called by code within this module and the idle
;        thread code and uses special register calling conventions.
;
; Arguments:
;
;   al - Supplies a boolean value that determines whether the full legacy
;       floating state needs to be saved.
;
;   cl - Supplies the APC interrupt bypass disable IRQL value.
;
;   rbx - Supplies the address of the current PRCB.
;
;   rdi - Supplies the address of previous thread.
;
;   rsi - Supplies the address of next thread.
;
; Return value:
;
;   al - Supplies the kernel APC pending flag.
;
;   rbx - Supplies the address of the current PRCB.
;
;   rsi - Supplies the address of current thread.
;
;--

        NESTED_ENTRY SwapContext, _TEXT$00

        alloc_stack (KSWITCH_FRAME_LENGTH - (1 * 8)) ; allocate stack frame
        save_reg rbp, SwRbp             ; save nonvolatile register

        END_PROLOGUE

        mov     SwApcBypass[rsp], cl    ; save APC bypass disable

;
; Wait for new thread lock to be dropped.
;
; N.B. It is necessary to wait for the new thread context to be swapped so
;      that any context switch away from the new thread on another processor
;      is completed before attempting to swap context context to the thread.
;

ifndef NT_UP

KiSC00: cmp     byte ptr ThSwapBusy[rsi], 0 ; check if swap busy for new thread

        Yield                           ; yield processor execution

        jne     short KiSC00            ; if ne, context busy for new thread

endif

;
; Increment the number of context switches on this processor.
;
; N.B. This increment is done here is force the cache block containing the
;      context switch count into the cache as write exclusive. There are
;      several other references to this cache block in the following code.
;

        inc     dword ptr PbContextSwitches[rbx] ; processor count

;
; Check for context swap logging.
;

        mov     rax, (PcPerfGlobalGroupMask - PcPrcb)[rbx] ; get global mask address
        test    rax, rax                ; test if logging enabled
        je      short KiSC05            ; if e, logging not enabled
        test    dword ptr PERF_CONTEXTSWAP_OFFSET[rax], PERF_CONTEXTSWAP_FLAG ; check flag
        jz      short KiSC05            ; if z, context swap events not enabled
        mov     rcx, rdi                ; set address of old thread
        mov     rdx, rsi                ; set address of new thread
        call    WmiTraceContextSwap     ; call trace routine

;
; If the current thread NPX state is switch, then save the legacy floating
; point state.
;

KiSC05: cmp     byte ptr ThNpxState[rdi], LEGACY_STATE_SWITCH ; check if switched
        jne     short KiSC10            ; if ne, legacy state not switched
        mov     rbp, ThInitialStack[rdi] ; get previous thread initial stack
        fxsave  [rbp]                   ; save legacy floating point state

;
; Switch kernel stacks.
;

KiSC10: mov     ThKernelStack[rdi], rsp ; save old kernel stack pointer
        mov     rsp, ThKernelStack[rsi] ; get new kernel stack pointer

;
; Swap the process address space if the new process is not the same as the
; previous process.
;

        mov     r14, ThApcState + AsProcess[rsi] ; get new process address
        cmp     r14, ThApcState + AsProcess[rdi] ; check if process match
        je      short KiSC20            ; if e, process addresses match

;
; Clear the processor bit in the old process.
;

ifndef NT_UP

        mov     rdx, ThApcState + AsProcess[rdi] ; get old process address
        mov     rcx, PbSetMember[rbx]   ; get processor set member
   lock xor     PrActiveProcessors[rdx], rcx ; clear bit in previous set

if DBG

        test    PrActiveProcessors[rdx], rcx ; test if bit clear in previous set
        jz      short @f                ; if z, bit clear in previous set
        int     3                       ; debug break - incorrect active mask
@@:                                     ; reference label

endif

endif

;
; Set the processor bit in the new process.
;

ifndef NT_UP

   lock xor     PrActiveProcessors[r14], rcx ; set bit in new set

if DBG

        test    PrActiveProcessors[r14], rcx ; test if bit set in new set
        jnz     short @f                ; if nz, bit set in new set
        int     3                       ; debug break - incorrect active mask
@@:                                     ; reference label

endif

endif

;
; Load new CR3 value which will flush the TB.
;

        mov     rdx, PrDirectoryTableBase[r14] ; get new directory base
        mov     cr3, rdx                ; flush TLB and set new directory base

;
; Set context swap idle for the old thread lock.
;

KiSC20:                                 ;

ifndef NT_UP

        mov     byte ptr ThSwapBusy[rdi], 0  ; set context swap idle

endif

;
; Set the new kernel stack base in the TSS.
;

        mov     r15, (PcTss - PcPrcb)[rbx] ; get processor TSS address
        mov     rbp, ThInitialStack[rsi] ; get new stack base address
        mov     TssRsp0[r15], rbp       ; set stack base address in TSS
        mov     PbRspBase[rbx], rbp     ; set stack base address in PRCB

;
; If the thread requires switching the legacy state, then restore the
; legacy floating state, load the compatilbity mode TEB address, and reload
; the natvie user mode TEB address and segment registers.
;

        cmp     byte ptr ThNpxState[rsi], LEGACY_STATE_UNUSED ; check if kernel thread
        je      short KiSC30            ; if e, legacy state unused
        fxrstor [rbp]                   ; restore legacy floating point state

;
; Set base of compatibility mode TEB.
;
; N.B. The upper 32-bits of the compatibility mode TEB address are always
;      zero.
;

        mov     eax, ThTeb[rsi]         ; compute compatibility mode TEB address
        add     eax, CmThreadEnvironmentBlockOffset ;
        mov     rcx, (PcGdt - PcPrcb)[rbx] ; get GDT base address
        mov     KgdtBaseLow + KGDT64_R3_CMTEB[rcx], ax ; set CMTEB base address
        shr     eax, 16                 ;
        mov     KgdtBaseMiddle + KGDT64_R3_CMTEB[rcx], al ;
        mov     KgdtBaseHigh + KGDT64_R3_CMTEB[rcx], ah   ;

;
; If the user segment selectors have been changed, then reload them with
; their cannonical values.
;
; N.B. The following code depends on the values defined in ntamd64.w that
;      can be loaded in ds, es, fs, and gs. In particular an "and" operation
;      is used for the below comparison.
;

        mov     eax, ds                 ; compute sum of segment selectors
        mov     ecx, es                 ;
        and     eax, ecx                ;
        mov     ecx, gs                 ;
        and     eax, ecx                ;
        cmp     ax, (KGDT64_R3_DATA or RPL_MASK) ; check if sum matches
        je      short KiSC25            ; if e, sum matches expected value
        mov     ecx, KGDT64_R3_DATA or RPL_MASK ; reload user segment selectors
        mov     ds, ecx                 ;
        mov     es, ecx                 ;

;
; N.B. The following reload of the GS selector destroys the system MSR_GS_BASE
;      register. Thus this sequence must be done with interrupt off.
;

        mov     eax, (PcSelf - PcPrcb)[rbx] ; get current PCR address
        mov     edx, (PcSelf - PcPrcb + 4)[rbx] ;
        cli                             ; disable interrupts
        mov     gs, ecx                 ; reload GS segment selector
        mov     ecx, MSR_GS_BASE        ; get GS base MSR number
        wrmsr                           ; write system PCR base address
        sti                             ; enable interrupts
KiSC25: mov     eax, KGDT64_R3_CMTEB or RPL_MASK ; reload FS segment selector
        mov     fs, eax                 ;
        mov     eax, ThTeb[rsi]         ; get low part of user TEB address
        mov     edx, ThTeb + 4[rsi]     ; get high part of user TEB address
        mov     (PcTeb - PcPrcb)[rbx], eax ; set user TEB address in PCR
        mov     (PcTeb - PcPrcb + 4)[rbx], edx ;
        mov     ecx, MSR_GS_SWAP        ; get GS base swap MSR number
        wrmsr                           ; write user TEB base address

;
; Check if an attempt is being made to context switch while in a DPC routine.
;

KiSC30: cmp     byte ptr PbDpcRoutineActive[rbx], 0 ; check if DPC active
        jne     short KiSC50            ; if ne, DPC is active

;
; Update context switch counter.
;

        inc     dword ptr ThContextSwitches[rsi] ; thread count

;
; If the new thread has a kernel mode APC pending, then request an APC
; interrupt if APC bypass is disabled.
;

        cmp     byte ptr ThApcState + AsKernelApcPending[rsi], TRUE ; check if APC pending
        jne     short KiSC40            ; if ne, kernel APC not pending
        movzx   ax, byte ptr SwApcBypass[rsp] ; get disable IRQL level
        or      ax, ThSpecialApcDisable[rsi] ; merge special APC disable
        jz      short KiSC40            ; if z, kernel APC enabled
        mov     ecx, APC_LEVEL          ; request APC interrupt
        call    __imp_HalRequestSoftwareInterrupt ;
        or      rcx, rsp                ; clear ZF flag
KiSC40: setz    al                      ; set return value
        mov     rbp, SwRbp[rsp]         ; restore nonvolatile register
        add     rsp, KSWITCH_FRAME_LENGTH - (1 * 8) ; deallocate stack frame
        ret                             ; return

;
; An attempt is being made to context switch while in a DPC routine. This is
; most likely caused by a DPC routine calling one of the wait functions.
;

KiSC50: xor     r9, r9                  ; clear register
        mov     SwP5Home[rsp], r9       ; set parameter 5
        mov     r8, rsi                 ; set new thread address
        mov     rdx, rdi                ; set old thread address
        mov     ecx, ATTEMPTED_SWITCH_FROM_DPC ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        ret                             ; return

        NESTED_END SwapContext, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\dpcint.asm ===
title  "Deferred Procedure Call Interrupt"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   dpcint.asm
;
; Abstract:
;
;   This module implements the code necessary to process the Deferred
;   Procedure Call interrupt.
;
;--

include ksamd64.inc

        extern  KiDispatchInterrupt:proc
        extern  KiIdleSummary:qword
        extern  KiInitiateUserApc:proc
        extern  KiRestoreDebugRegisterState:proc
        extern  KiSaveDebugRegisterState:proc
        extern  __imp_HalRequestSoftwareInterrupt:qword

        subttl  "Deferred Procedure Call Interrupt"
;++
;
; VOID
; KiDpcInterrupt (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered as the result of a software interrupt generated
;   at DISPATCH_LEVEL. Its function is to save the machine state and call
;   the dispatch interrupt routine.
;
;   N.B. This is a directly connected interrupt that does not use an interrupt
;        object.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiDpcInterrupt, _TEXT$00

        .pushframe                      ; mark machine frame

;
; Check for interrupt from the idle halt state.
;
; N.B. If an DPC interrupt occurs when idle halt is set, then the interrupt
;      occurred during the power managment halted state. The interrupt can
;      be immediately dismissed since the idle loop will provide the correct
;      processing.
;

        test    byte ptr MfSegCs[rsp], MODE_MASK ; test if previous mode user
        jnz     short KiDP10            ; if nz, previous mode is user
        cmp     byte ptr gs:[PcIdleHalt], 0 ; check for idle halt interrupt
        je      short KiDP10            ; if e, not interrupt from idle halt

        EndSystemInterrupt              ; perform EOI

        iretq                           ; return

;
; Normal DPC interrupt.
;

KiDP10: alloc_stack 8                   ; allocate dummy vector
        push_reg rbp                    ; save nonvolatile register

        GENERATE_INTERRUPT_FRAME <>, <DirectNoSListCheck> ; generate interrupt frame

        mov     ecx, DISPATCH_LEVEL     ; set new IRQL level

	ENTER_INTERRUPT	<>, <NoCount>   ; raise IRQL, do EOI, enable interrupts

        call    KiDispatchInterrupt     ; process the dispatch interrupt

        EXIT_INTERRUPT <NoEOI>, <NoCount>, <Direct> ; lower IRQL and restore state

        NESTED_END KiDpcInterrupt, _TEXT$00

        subttl  "Deferred Procedure Call Interrupt Bypass"
;++
;
; VOID
; KiDpcInterruptBypass (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered as the result of a bypassed software interrupt at
;   dispatch level. Its function is to set the current IRQL to DISPATCH_LEVEL
;   and call the dispatch interrupt routine.
;
;   N.B. This function is entered with interrupts disabled and returns with
;        interrupts disabled.
;
; Arguments:
;
;   None.
;
; Implicit Arguments:
;
;   rbp - Supplies the address of the trap frame.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiDpcInterruptBypass, _TEXT$00

        alloc_stack 8                   ; allocate stack frame

        END_PROLOGUE

        mov     ecx, DISPATCH_LEVEL     ; set new IRQL level

        SetIrql                         ;

        sti                             ; enable interrupts

        call    KiDispatchInterrupt     ; process the dispatch interrupt

        cli                             ; disable interrupts
        add     rsp, 8                  ; deallocate stack frame
        ret                             ; return

        NESTED_END KiDpcInterruptBypass, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\flush.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    flush.c

Abstract:

    This module implements AMD64 machine dependent kernel functions to
    flush the data and instruction caches on all processors.

--*/

#include "ki.h"

BOOLEAN
KeInvalidateAllCaches (
    VOID
    )

/*++

Routine Description:

    This function writes back and invalidates the cache on all processors
    in the host configuration.

Arguments:

    None.

Return Value:

    TRUE is returned as the function value.

--*/

{


#if !defined(NT_UP)

    PKAFFINITY Barrier;
    KIRQL OldIrql;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

    //
    // Raise IRQL to SYNCH level.
    //
    // Send request to target processors, if any, invalidate the current cache,
    // and wait for the IPI request barrier.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    Prcb = KeGetCurrentPrcb();
    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        Barrier = KiIpiSendRequest(TargetProcessors, 0, 0, IPI_INVALIDATE_ALL);
        WritebackInvalidate();
        KiIpiWaitForRequestBarrier(Barrier);

    } else {
        WritebackInvalidate();
    }

    //
    // Lower IRQL to its previous value.
    //

    KeLowerIrql(OldIrql);

#else

    WritebackInvalidate();

#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\decode.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    decode.c

Abstract:

    This module implement the code necessary to dispatch exceptions to the
    proper mode and invoke the exception dispatcher.

--*/

#include "ki.h"

//
// Global data used for synchronization of the patch process.
// 

LONG volatile KiCodePatchCycle;

//
// Gather statistics on number of prefetch instructions patched and the
// number of unsuccessful attempts.
//

ULONG KiOpPrefetchPatchCount;
ULONG KiOpPrefetchPatchRetry;

//
// A flag for each instruction prefix
// 

#define OP_PREFIX_ES        (1 << 0)
#define OP_PREFIX_CS        (1 << 1)
#define OP_PREFIX_SS        (1 << 2)
#define OP_PREFIX_DS        (1 << 3)
#define OP_PREFIX_FS        (1 << 4)
#define OP_PREFIX_GS        (1 << 5)
#define OP_PREFIX_OPERAND   (1 << 6)
#define OP_PREFIX_ADDR      (1 << 7)
#define OP_PREFIX_LOCK      (1 << 8)
#define OP_PREFIX_REPNE     (1 << 9)
#define OP_PREFIX_REPE      (1 << 10)
#define OP_PREFIX_REX       (1 << 11)

//
// An identifier for each prefix group with more than a single
// prefix
// 

#define OP_PREFIXGRP_SEGMENT    (1 << 0)
#define OP_PREFIXGRP_REP        (1 << 1)

#define OP_TWOBYTE          0x0F
#define OP_NOREGEXT         0xFF

#define OP_MAXIMUM_LENGTH   15

//
// Flag definitions for DECODE_ENTRY.Flags
//

#define OPF_NONE            (0)
#define OPF_IMM8            (1 << 0)
#define OPF_IMM32           (1 << 1)
#define OPF_MODRM           (1 << 2)

#define OPF_GP              ((ULONG)1 << 31)
#define OPF_INVAL           ((ULONG)1 << 30)
#define OPF_DIV             ((ULONG)1 << 29)
#define OPF_AV              ((ULONG)1 << 28)

//
// A structure used to coordinate pausing of processors
//

typedef struct _KIOP_COPY_CONTEXT {

    PUCHAR Destination;
    LOGICAL CopyDirect;
    LOGICAL CopyPerformed;
    NTSTATUS Status;

#if !defined(NT_UP)

    ULONG ProcessorNumber;
    LONG volatile ProcessorsRunning;
    LONG volatile ProcessorsToResume;
    LOGICAL volatile Done;

#endif

    UCHAR Replacement;

} KIOP_COPY_CONTEXT, *PKIOP_COPY_CONTEXT;

//
// A table containing each of the possible legacy prefix bytes.
// The REX prefix is not included here, rather it is checked for
// separately.
// 

struct {

    //
    // The numeric value of the prefix byte
    //

    UCHAR Prefix;

    //
    // The flag associated with this prefix
    //

    ULONG Flag;

    //
    // If the prefix shares its group with other prefixes, the
    // group identifier is stored here to detect illegal use of
    // multiple prefix bytes from within the same group.
    //

    ULONG Group;

} const KiOpPrefixTable[] = {
    { 0x26, OP_PREFIX_ES,      OP_PREFIXGRP_SEGMENT },
    { 0x2e, OP_PREFIX_CS,      OP_PREFIXGRP_SEGMENT },
    { 0x36, OP_PREFIX_SS,      OP_PREFIXGRP_SEGMENT },
    { 0x3e, OP_PREFIX_DS,      OP_PREFIXGRP_SEGMENT },
    { 0x64, OP_PREFIX_FS,      OP_PREFIXGRP_SEGMENT },
    { 0x65, OP_PREFIX_GS,      OP_PREFIXGRP_SEGMENT },
    { 0x66, OP_PREFIX_OPERAND, 0 },
    { 0x67, OP_PREFIX_ADDR,    0 },
    { 0xf0, OP_PREFIX_LOCK,    0 },
    { 0xf2, OP_PREFIX_REPNE,   OP_PREFIXGRP_REP },
    { 0xf3, OP_PREFIX_REPE,    OP_PREFIXGRP_REP }
};

typedef struct _DECODE_ENTRY const *PDECODE_ENTRY;

//
// This is the context that is built and passed around most of the
// routines in this module to track the state of the decode process.
// 

typedef struct _DECODE_CONTEXT {
    PUCHAR Start;
    PUCHAR Next;
    PCONTEXT ContextRecord;
    PEXCEPTION_RECORD ExceptionRecord;
    PUCHAR OpCodeLocation;
    ULONG PrefixMask;
    ULONG GroupMask;
    UCHAR OpCode;
    BOOLEAN TwoByte;
    BOOLEAN CompatibilityMode;

    union {
        struct {
            UCHAR B:1;
            UCHAR X:1;
            UCHAR R:1;
            UCHAR W:1;
        };
        UCHAR Byte;
    } Rex;

    union {
        struct {
            UCHAR rm:3;
            UCHAR reg:3;
            UCHAR mod:2;
        };
        UCHAR Byte;
    } ModRM;

    union {
        struct {
            UCHAR base : 3;
            UCHAR index : 3;
            UCHAR scale : 2;
        };
        UCHAR Byte;
    } SIB;

    LONG Displacement;
    LONG64 Immediate;

    BOOLEAN ModRMRead;

    KPROCESSOR_MODE PreviousMode;
    PDECODE_ENTRY DecodeEntry;

    //
    // Set to TRUE if the offending instruction or context has been
    // fixed up in some way and should be retried.
    //

    BOOLEAN Retry;

} DECODE_CONTEXT, *PDECODE_CONTEXT;

typedef
NTSTATUS
(*PKOP_OPCODE_HANDLER) (
    IN PDECODE_CONTEXT DecodeContext
    );

//
// Entry used to build the decode tables.
// 

typedef struct _DECODE_ENTRY {

    //
    // OpCode is the first byte of a single byte opcode, or the
    // second byte of a two byte opcode.
    //

    UCHAR OpCode;

    //
    // Range is the number of sequential opcodes covered by this
    // entry.
    //

    UCHAR Range;

    //
    // Some opcodes are additionally identified by a specific prefix.
    // That prefix is supplied here, otherwise 0.
    //

    ULONG Prefix;

    //
    // Some opcodes are additionally identified by a value in the
    // ModRM's reg field.  If so that value is supplied here, otherwise
    // OP_NOREGEXT is specified.
    //

    UCHAR ModRMExtension;

    //
    // Additional OPF_ flags
    //

    ULONG Flags;

    //
    // Pointer to the handler for this opcode.
    //

    PKOP_OPCODE_HANDLER Handler;

} DECODE_ENTRY;

//
// Routines external to this module
//

VOID
KiCpuIdFault (
    VOID
    );

BOOLEAN
KiFilterFiberContext (
    PCONTEXT Context
    );

//
// Forwarded declarations for routines local to this module
// 

NTSTATUS
KiCheckForAtlThunk (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_Div (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_LSAHF (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS   
KiOp_MOVAPS (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_MOVDQA (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_PREF_NOP (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_PREFETCH3 (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_PREFETCHx (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_Priv (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOp_Illegal (
    IN PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOpDecode (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOpDecodeModRM (
    IN OUT PDECODE_CONTEXT DecodeContext
    );

NTSTATUS
KiOpFetchBytes (
    IN PDECODE_CONTEXT DecodeContext,
    IN ULONG Count,
    OUT PVOID Buffer
    );

NTSTATUS
KiOpFetchNextByte (
    IN PDECODE_CONTEXT DecodeContext,
    OUT PUCHAR NextByte
    );

NTSTATUS
KiOpIsPrefix (
    IN PDECODE_CONTEXT DecodeContext,
    IN UCHAR OpByte,
    OUT PBOOLEAN IsPrefix
    );

NTSTATUS
KiOpLocateDecodeEntry (
    IN OUT PDECODE_CONTEXT DecodeContext
    );

ULONG_PTR
KiOpSingleProcCopy (
    IN ULONG_PTR Context
    );

NTSTATUS
KiOpPatchCode (
    IN PDECODE_CONTEXT DecodeContext,
    OUT PUCHAR Destination,
    IN UCHAR Replacement
    );

BOOLEAN
KiOpPreprocessAccessViolation (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

//
// Two separate opcode tables, one for single byte opcodes and another
// for double byte opcodes.
//
// Entries may appear in any order.
//

DECODE_ENTRY const
KiOpOneByteTable[] = {
    { 0xfa, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // CLI
    { 0xfb, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // STI
    { 0xe4, 4,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // IN, OUT imm8
    { 0xec, 4,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // IN, OUT [dx]
    { 0x6c, 4,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // INS, OUTS
    { 0x9E, 2,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_LSAHF     },  // LAHF / SAHF  
    { 0xf4, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // HLT
    { 0xf6, 1,                 0,           6, OPF_MODRM, KiOp_Div       },  // DIV ax/(reg/mem8)
    { 0xf6, 1,                 0,           7, OPF_MODRM, KiOp_Div       },  // IDIV ax/(reg/mem8)
    { 0xf7, 1,                 0,           6, OPF_MODRM, KiOp_Div       },  // DIV [r|e]dx:[r|e]ax/(reg/mem[16|32|64])
    { 0xf7, 1,                 0,           7, OPF_MODRM, KiOp_Div       }   // IDIV [r|e]dx:[r|e]ax/(reg/mem[16|32|64])
};


DECODE_ENTRY const
KiOpTwoByteTable[] = {
    { 0x6F, 1, OP_PREFIX_OPERAND, OP_NOREGEXT, OPF_MODRM, KiOp_MOVDQA    },  // MOVDQA xmm1,xmm2/mem128
    { 0x7F, 1, OP_PREFIX_OPERAND, OP_NOREGEXT, OPF_MODRM, KiOp_MOVDQA    },  // MOVDQA xmm1/mem128,xmm2
    { 0x28, 1,                 0, OP_NOREGEXT, OPF_MODRM, KiOp_MOVAPS    },  // MOVAPS xmm1,xmm2/mem128
    { 0x29, 1,                 0, OP_NOREGEXT, OPF_MODRM, KiOp_MOVAPS    },  // MOVAPS xmm1,xmm2/mem128
    { 0x00, 1,                 0,           2, OPF_NONE,  KiOp_Priv      },  // LLDT
    { 0x00, 1,                 0,           3, OPF_NONE,  KiOp_Priv      },  // LTR
    { 0x01, 1,                 0,           2, OPF_NONE,  KiOp_Priv      },  // LGDT
    { 0x01, 1,                 0,           3, OPF_NONE,  KiOp_Priv      },  // LIGT
    { 0x01, 1,                 0,           6, OPF_NONE,  KiOp_Priv      },  // LMSW
    { 0x01, 1,                 0,           7, OPF_NONE,  KiOp_Priv      },  // INVLPG, SWAPGS
    { 0x08, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // INVD
    { 0x09, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // WBINVD
    { 0x0D, 1,                 0,           0, OPF_MODRM, KiOp_PREFETCH3 },  // PREFETCH
    { 0x0D, 1,                 0,           1, OPF_MODRM, KiOp_PREFETCH3 },  // PREFETCHW
    { 0x18, 1,                 0,           0, OPF_MODRM, KiOp_PREFETCHx },  // PREFETCH0
    { 0x18, 1,                 0,           1, OPF_MODRM, KiOp_PREFETCHx },  // PREFETCH1
    { 0x18, 1,                 0,           2, OPF_MODRM, KiOp_PREFETCHx },  // PREFETCH2
    { 0x18, 1,                 0,           3, OPF_MODRM, KiOp_PREFETCHx },  // PREFETCH3
    { 0x1f, 1,                 0,           1, OPF_MODRM, KiOp_PREF_NOP  },  // PREFETCH_NOP
    { 0x35, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // SYSEXIT
    { 0x20, 4,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // MOV to/from control or dbg reg
    { 0x30, 4,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // WRMSR, RDTSC, RDMSR, RDPMC
    { 0x06, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      },  // CLTS
    { 0xAA, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Illegal   },  // RSM
    { 0x07, 1,                 0, OP_NOREGEXT, OPF_NONE,  KiOp_Priv      }   // SYSRET
};

DECLSPEC_NOINLINE
BOOLEAN
KiPreprocessFault (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    A wide variety of exception conditions can result in a general
    protection fault.

    This routine attempts to further determine the cause of the fault
    and take appropriate action, which can include

        - Updating the context record with a more appropriate status

        - Emulating the instruction or otherwise modifying the caller's
          context and/or istream and returning

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    TrapFrame - Supplies a pointer to the trap frame.

    PreviousMode - Supplies the execution mode at the time of the exception.

Return Value:

    TRUE - the caller's context should be updated and control returned
           to the caller.

    FALSE - the exception should be raised with (perhaps) an updated
            context record.

--*/

{
    DECODE_CONTEXT decodeContext;
    PDECODE_ENTRY decodeEntry;
    ULONG faultType;
    BOOLEAN retry;
    NTSTATUS status;

    //
    // Determine whether this is an internal exception and if so replace
    // it with the canonical one and continue processing.
    //

    switch (ExceptionRecord->ExceptionCode) {
        
        case KI_EXCEPTION_GP_FAULT:

            faultType = OPF_GP;
            ExceptionRecord->ExceptionCode = STATUS_ACCESS_VIOLATION;
            break;

        case KI_EXCEPTION_INVALID_OP:
            faultType = OPF_INVAL;
            ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
            break;

        case KI_EXCEPTION_INTEGER_DIVIDE_BY_ZERO:
            faultType = OPF_DIV;
            ExceptionRecord->ExceptionCode = STATUS_INTEGER_DIVIDE_BY_ZERO;
            break;

        case KI_EXCEPTION_ACCESS_VIOLATION:
            retry = KiOpPreprocessAccessViolation(ExceptionRecord,
                                                  ContextRecord);
            if (retry != FALSE) {
                return TRUE;
            }
            faultType = OPF_AV;
            ExceptionRecord->ExceptionCode = STATUS_ACCESS_VIOLATION;
            break;

        default:
            return FALSE;
    }

    //
    // Decode the offending instruction.  This tells us the length of the
    // instruction.
    //

    status = KiOpDecode(ExceptionRecord,
                        ContextRecord,
                        PreviousMode,
                        &decodeContext);

    //
    // Now that the instruction has been decoded, determine whether
    // any code patches have taken place between the time of the exception
    // and now.
    //
    // If so, re-execute the code that generated the exception.  If it was
    // not this code that was patched, then another exception will fire and
    // we'll try again.
    //

    if (TrapFrame->CodePatchCycle != KiCodePatchCycle) {
        return TRUE;
    }

    if (NT_SUCCESS(status)) {
    
        //
        // If this is an interesting instruction (i.e. it appears in the
        // decode tables) then call its handler.
        // 
    
        decodeEntry = decodeContext.DecodeEntry;
        if (decodeEntry != NULL) {
            status = decodeEntry->Handler(&decodeContext);
        }
    } else {
        decodeEntry = NULL;
    }
    
    //
    // Indicate whether the operation should be retried, and return.
    //

    if (NT_SUCCESS(status) && (decodeEntry != NULL)) {

        retry = decodeContext.Retry;
                       
    } else {

        if (faultType == OPF_GP) {
    
            //
            // If a specific action was not carried out for a general
            // protection fault then the default action is to raise an
            // access violation.
            //
    
            //
            // Set two parameters to "read", "unknown faulting VA"
            //
    
            ExceptionRecord->NumberParameters = 2;
            ExceptionRecord->ExceptionInformation[0] = 0;
            ExceptionRecord->ExceptionInformation[1] = (ULONG_PTR)-1;
        }

        retry = FALSE;
    }

    if ((retry == FALSE) && (faultType == OPF_AV)) {

        //
        // Check for an ATL thunk
        //

        if (NT_SUCCESS(KiCheckForAtlThunk(&decodeContext))) {
            retry = decodeContext.Retry;
        }
    }

    return retry;
}

NTSTATUS
KiOpDecode (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode,
    OUT PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This routine decodes the instruction stream sufficiently to positively
    determine whether this is an opcode we are interested in and, if so,
    to positively identify it.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    PreviousMode - Supplies the execution mode at the time of the exception.

    DecodeContext - Supplies a pointer to an uninitialized DECODE_CONTEXT.


Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    CHAR byteVal;
    PDECODE_ENTRY decodeEntry;
    BOOLEAN isPrefix;
    LONG longVal;
    UCHAR opByte;
    ULONG prefixLength;
    PUCHAR rip;
    NTSTATUS status;
    SHORT shortVal;

    //
    // Initialize the decode context according to the parameters supplied.
    //
    // Also, make sure the instruction pointer refers to the user mode
    // data area.
    //

    RtlZeroMemory(DecodeContext,sizeof(*DecodeContext));

    rip = (PUCHAR)ContextRecord->Rip;

    //
    // Make sure the faulting address is valid.  Length of the region
    // is 1, as we don't yet know how the true length of the opcode.
    //

    if (PreviousMode == UserMode) {
        try {
            ProbeAndReadUchar(rip);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
    }

    DecodeContext->Start = rip;
    DecodeContext->Next = rip;
    DecodeContext->ExceptionRecord = ExceptionRecord;
    DecodeContext->ContextRecord = ContextRecord;
    DecodeContext->PreviousMode = PreviousMode;

    //
    // Record whether the fault occured in a compatibility mode segment.
    //

    if (ContextRecord->SegCs == (KGDT64_R3_CMCODE | RPL_MASK)) {

        ASSERT( PreviousMode == UserMode );
        DecodeContext->CompatibilityMode = TRUE;
    }

    //
    // Accumulate all of the prefix bytes
    //

    prefixLength = 0;
    do {

        status = KiOpFetchNextByte(DecodeContext,&opByte);
        if (!NT_SUCCESS(status)) {
            return status;
        }

        status = KiOpIsPrefix(DecodeContext,opByte,&isPrefix);
        if (!NT_SUCCESS(status)) {
            return status;
        }

    } while (isPrefix != FALSE);

    //
    // opByte contains the first base byte of the opcode.  If this is
    // a two byte opcode, retrieve the second byte.
    //

    if (opByte == OP_TWOBYTE) {

        DecodeContext->TwoByte = TRUE;

        status = KiOpFetchNextByte(DecodeContext,&opByte);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    DecodeContext->OpCodeLocation = DecodeContext->Next - 1;
    DecodeContext->OpCode = opByte;
    status = KiOpLocateDecodeEntry(DecodeContext);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If there was no decode entry then we are not interested in handling
    // this instruction.  This is not an error condition, so return
    // success.
    //

    decodeEntry = DecodeContext->DecodeEntry;
    if (decodeEntry == NULL) {
        return STATUS_SUCCESS;
    }

    //
    // Decode any address portion of the instruction
    // 

    if ((decodeEntry->Flags & OPF_MODRM) != 0) {
        status = KiOpDecodeModRM(DecodeContext);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Followed by a possible 8-, 16- or 32-bit immediate
    //

    if ((decodeEntry->Flags & OPF_IMM8) != 0) {

        //
        // 8-bit displacement
        //

        status = KiOpFetchBytes(DecodeContext,
                                sizeof(byteVal),
                                &byteVal);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        DecodeContext->Immediate = byteVal;

    } else if ((DecodeContext->DecodeEntry->Flags & OPF_IMM32) != 0) {

        if ((DecodeContext->PrefixMask & OP_PREFIX_OPERAND) != 0) {

            //
            // 16-bit immediate
            //

            status = KiOpFetchBytes(DecodeContext,
                                    sizeof(shortVal),
                                    &shortVal);
            if (!NT_SUCCESS(status)) {
                return status;
            }
            DecodeContext->Immediate = shortVal;

        } else {

            //
            // 32-bit immediate
            //
    
            status = KiOpFetchBytes(DecodeContext,
                                    sizeof(longVal),
                                    &longVal);
            if (!NT_SUCCESS(status)) {
                return status;
            }
            DecodeContext->Immediate = longVal;
        }
    }

    return status;
}


NTSTATUS
KiOpFetchBytes (
    IN PDECODE_CONTEXT DecodeContext,
    IN ULONG Count,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    This routine safely retrieves bytes from the istream specified
    in DecodeContext.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT.

    Count - Supplies the number of bytes to capture from the instruction stream.

    Buffer - Supplies a pointer to the memory that is to contain the captured
             bytes.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    NTSTATUS status;

    status = STATUS_SUCCESS;
    try {
        RtlCopyMemory(Buffer, DecodeContext->Next, Count);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }
    if (!NT_SUCCESS(status)) {
        return status;
    }
    DecodeContext->Next += Count;

    return STATUS_SUCCESS;
}

NTSTATUS
KiOpFetchNextByte (
    IN PDECODE_CONTEXT DecodeContext,
    OUT PUCHAR NextByte
    )

/*++

Routine Description:

    This routine safely retrieves a single byte from the istream specified
    in DecodeContext.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT.

    NextByte - Supplies a pointer to the memory that is to contain the captured
               byte.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    return KiOpFetchBytes(DecodeContext, 1, NextByte);
}


NTSTATUS
KiOpIsPrefix (
    IN PDECODE_CONTEXT DecodeContext,
    IN UCHAR OpByte,
    OUT PBOOLEAN IsPrefix
    )

/*++

Routine Description:

    This routine determines whether the supplied byte is a prefix byte and
    updates DecodeContext accordingly.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

    OpByte - The possible prefix byte.

    IsPrefix - Supplies a pointer to the BOOLEAN that will be set according
               to whether OpByte is a prefix byte or not.

Return Value:

    NTSTATUS - Status of the operation.

    This routine will fail if an illegal instruction is detected.

--*/

{
    ULONG groupMask;
    ULONG index;
    BOOLEAN isPrefix;
    ULONG prefixMask;
    NTSTATUS status;

    status = STATUS_SUCCESS;
    isPrefix = FALSE;
    prefixMask = 0;
    groupMask = 0;

    //
    // Check for REX prefix
    //

    if ((DecodeContext->CompatibilityMode == FALSE) &&
        (OpByte & 0xf0) == 0x40) {

        prefixMask = OP_PREFIX_REX;
        DecodeContext->Rex.Byte = OpByte;

    } else {

        //
        // Check for other prefix bytes
        //

        for (index = 0; index < RTL_NUMBER_OF(KiOpPrefixTable); index += 1) {

            if (KiOpPrefixTable[index].Prefix == OpByte) {

                prefixMask = KiOpPrefixTable[index].Flag;
                groupMask = KiOpPrefixTable[index].Group;
                break;
            }
        }
    }

    if (prefixMask != 0) {

        //
        // A prefix byte has been found.  If this prefix byte has already
        // appeared in this instruction, or belongs to a group that has
        // already been represented by a previous prefix, then this is
        // an illegal instruction.
        // 

        if (((DecodeContext->PrefixMask & prefixMask) != 0) ||
            ((DecodeContext->GroupMask & groupMask) != 0)) {

            status = STATUS_ILLEGAL_INSTRUCTION;

        } else {

            DecodeContext->PrefixMask |= prefixMask;
            DecodeContext->GroupMask |= groupMask;
            isPrefix = TRUE;
        }
    }

    if (NT_SUCCESS(status)) {
        *IsPrefix = isPrefix;
    }

    return status;
}


NTSTATUS
KiOpLocateDecodeEntry (
    IN OUT PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    Given a decoded instruction, this routine attempts to locate the
    DECODE_ENTRY structure and update DecodeContext accordingly.

    Some opcodes require the rem field in the ModRM byte to be consulted
    before they can be identified.  In that case, this routine will
    fetch the ModRM byte from the instruction stream.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    NTSTATUS - Status of the operation.  Success unless a necessary
               ModRM byte could not be fetched from the istream.

--*/

{
    PDECODE_ENTRY decodeEntry;
    UCHAR opBase;
    UCHAR opLimit;
    NTSTATUS status;
    PDECODE_ENTRY tableEnd;

    if (DecodeContext->TwoByte == FALSE) {

        decodeEntry = KiOpOneByteTable;
        tableEnd = &decodeEntry[RTL_NUMBER_OF(KiOpOneByteTable)];

    } else {

        decodeEntry = KiOpTwoByteTable;
        tableEnd = &decodeEntry[RTL_NUMBER_OF(KiOpTwoByteTable)];
    }

    //
    // For each DECODE_ENTRY in the array, determine whether it matches
    // the current instruction.
    //

    decodeEntry -= 1;
    while (TRUE) {

        decodeEntry += 1;
        if (decodeEntry == tableEnd) {
            return STATUS_SUCCESS;
        }

        //
        // Check whether the opcode in question falls within the opcode
        // range represented by this DECODE_ENTRY
        //

        opBase = decodeEntry->OpCode;
        opLimit = opBase + decodeEntry->Range - 1;

        if ((DecodeContext->OpCode < opBase) ||
            (DecodeContext->OpCode > opLimit)) {
            continue;
        }

        //
        // Check whether this opcode relies on a specific prefix for
        // further identification and if so, whether the current
        // instruction stream includes that prefix.
        //

        if ((decodeEntry->Prefix != 0) &&
            (decodeEntry->Prefix & DecodeContext->PrefixMask) == 0) {
            continue;
        }

        //
        // Check whether this opcode relies on a specific value within
        // ModRM.reg and if so, whether the current instruction stream
        // includes that value.
        //

        if (decodeEntry->ModRMExtension != OP_NOREGEXT) {

            //
            // The opcode is defined to include a ModRM byte.  Read
            // it here if it hasn't yet been read.
            //

            if (DecodeContext->ModRMRead == FALSE) {
                status = KiOpFetchNextByte(DecodeContext,
                                           &DecodeContext->ModRM.Byte);
                if (!NT_SUCCESS(status)) {
                    return status;
                }
                DecodeContext->ModRMRead = TRUE;
            }

            if (decodeEntry->ModRMExtension != DecodeContext->ModRM.reg) {
                continue;
            }
        }

        //
        // All tests have passed, we have a match.
        // 

        DecodeContext->DecodeEntry = decodeEntry;
        return STATUS_SUCCESS;
    }
}

NTSTATUS
KiOpDecodeModRM (
    IN OUT PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This routine retrieves and parses the ModRM portion of the opcode and,
    optionally, an SIB byte and 8-, 16- or 32-bit offset.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    CHAR byteVal;
    NTSTATUS status;

    //
    // It is assumed that the opcode itself has been decoded.  It is also
    // possible that the ModRM byte itself has already been retrieved as
    // a result of further refining the opcode search.
    //

    if (DecodeContext->ModRMRead == FALSE) {

        status = KiOpFetchNextByte(DecodeContext,
                                   &DecodeContext->ModRM.Byte);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        DecodeContext->ModRMRead = TRUE;
    }

    //
    // Next comes the SIB byte, if one exists
    //

    if (DecodeContext->ModRM.mod != 0x03 &&
        DecodeContext->ModRM.rm == 0x4) {

        //
        // The opcode contains an SIB byte as well
        //

        status = KiOpFetchNextByte(DecodeContext,
                                   &DecodeContext->SIB.Byte);
        if (!NT_SUCCESS(status)) {
            return status;
        }
    }

    //
    // Possibly followed by an 8- or 32-bit displacement.
    //
    // Mod == 2          -> 32-bit displacement
    // Mod == 0, rm == 5 -> 32-bit displacement
    // Mod == 1          ->  8-bit displacement
    //

    if (((DecodeContext->ModRM.mod == 0) && (DecodeContext->ModRM.rm == 5)) ||
        (DecodeContext->ModRM.mod == 2)) {

        //
        // 32-bit displacent
        //

        status = KiOpFetchBytes(DecodeContext,
                                sizeof(LONG), 
                                &DecodeContext->Displacement);
        if (!NT_SUCCESS(status)) {
            return status;
        }

    } else if (DecodeContext->ModRM.mod == 1) {

        //
        // 8-bit displacement
        //

        status = KiOpFetchBytes(DecodeContext,
                                sizeof(byteVal),
                                &byteVal);
        if (!NT_SUCCESS(status)) {
            return status;
        }
        DecodeContext->Displacement = byteVal;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
KiOpRetrieveRegMemAddress (
    IN OUT PDECODE_CONTEXT DecodeContext,
    OUT PVOID *OperandAddress,
    OUT KPROCESSOR_MODE *ProcessorMode
    )

/*++

Routine Description:

    After an instruction has been decoded, this routine calculates the
    address of an instruction's rm target.

    If rm specifies a register, OperandAddress will point to the location
    of that register within the context record.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT.

    OperandAddress - Supplies a pointer to the memory to receive the
                     calculated rm operand address.

    ProcessorMode - Supplies a pointer to the memory to receive the probe
                    mode for the OperandAddress pointer.  This may be
                    different than PreviousMode() if the operand is a
                    register.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    PVOID address;
    LONG64 base;
    ULONG baseReg;
    LONG64 index;
    ULONG indexReg;
    KPROCESSOR_MODE processorMode;

    ASSERT( (DecodeContext->DecodeEntry->Flags & OPF_MODRM) != 0 );
    ASSERT( DecodeContext->ModRMRead != FALSE );

    processorMode = DecodeContext->PreviousMode;
    base = 0;
    index = 0;

    if (DecodeContext->ModRM.mod == 3) {

        //
        // Not a memory operand, value is found in a register (i.e. in the
        // context record)
        //

        baseReg = DecodeContext->ModRM.rm;
        if (DecodeContext->Rex.B) {
            baseReg += 8;
        }

        base = (LONG64)(&DecodeContext->ContextRecord->Rax + baseReg);
        processorMode = KernelMode;

    } else if (DecodeContext->ModRM.rm == 4) {

        //
        // Opcode includes an SIB byte.
        //

        if ((DecodeContext->SIB.base == 5) &&
            (DecodeContext->ModRM.mod == 0)) {

            NOTHING;

        } else {

            baseReg = DecodeContext->SIB.base;
            if (DecodeContext->Rex.B) {
                baseReg += 8;
            }

            base = *(&DecodeContext->ContextRecord->Rax + baseReg);
        }

        if (DecodeContext->SIB.index == 4) {

            NOTHING;

        } else {

            indexReg = DecodeContext->SIB.index;
            if (DecodeContext->Rex.X) {
                indexReg += 8;
            }

            index = *(&DecodeContext->ContextRecord->Rax + indexReg);
            index <<= DecodeContext->SIB.scale;
        }

    } else {

        baseReg = DecodeContext->ModRM.rm;
        if (DecodeContext->Rex.B) {
            baseReg += 8;
        }
        base = *(&DecodeContext->ContextRecord->Rax + baseReg);
    }

    address = (PVOID)(base + index + DecodeContext->Displacement);

    if ((DecodeContext->ModRM.mod == 0) &&
        (DecodeContext->ModRM.rm == 5)) {

        //
        // Displacement is RIP-relative, add in RIP of next instruction
        // 

        address = (PVOID)((LONG64)address + (LONG64)(DecodeContext->Next));
    }

    *OperandAddress = address;
    *ProcessorMode = processorMode;

    return STATUS_SUCCESS;
}


NTSTATUS
KiOp_Priv (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for instructions for which a PRIVELEGED_INSTRUCTION
    exception should be raised.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    PEXCEPTION_RECORD exceptionRecord;

    exceptionRecord = DecodeContext->ExceptionRecord;
    exceptionRecord->ExceptionCode = STATUS_PRIVILEGED_INSTRUCTION;
    exceptionRecord->NumberParameters = 0;

    return STATUS_SUCCESS;
}

NTSTATUS
KiOp_Illegal (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for instructions for which an ILLEGAL_INSTRUCTION
    exception should be raised.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    PEXCEPTION_RECORD exceptionRecord;

    exceptionRecord = DecodeContext->ExceptionRecord;
    exceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
    exceptionRecord->NumberParameters = 0;

    return STATUS_SUCCESS;
}


NTSTATUS
KiCheckForAtlThunk (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for the C7 /0 opcode: mov reg/mem32, imm32.

    This marks the beginning of an x86 ATL thunk.  Control will branch
    here if the ATL thunk was built in memory marked no execute.  If that
    is the case, then the thunk code will be emulated and control returned
    to the thread.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    PEXCEPTION_RECORD exceptionRecord;
    ULONG64 faultIndicator;

    //
    // Interested only in compatibility mode code.
    //

    if (DecodeContext->CompatibilityMode == FALSE) {
        return STATUS_SUCCESS;
    }

    //
    // Interested only in an instruction fetch fault.
    // 

    exceptionRecord = DecodeContext->ExceptionRecord;
    faultIndicator = exceptionRecord->ExceptionInformation[0];
    if ((faultIndicator & 0x8) == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Where the fault address is the instruction
    // 

    if (exceptionRecord->ExceptionInformation[1] !=
        (ULONG64)(DecodeContext->Start)) {
        return STATUS_SUCCESS;
    }

    if (KiEmulateAtlThunk((ULONG *)&DecodeContext->ContextRecord->Rip,
                          (ULONG *)&DecodeContext->ContextRecord->Rsp,
                          (ULONG *)&DecodeContext->ContextRecord->Rax,
                          (ULONG *)&DecodeContext->ContextRecord->Rcx,
                          (ULONG *)&DecodeContext->ContextRecord->Rdx)) {

        //
        // An ATL thunk was recognized and emulated.
        // Indicate "resume execution".
        //

        DecodeContext->Retry = TRUE;
    }

    return STATUS_SUCCESS;
}

VOID
KiCheckForSListAddress (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called from the APC and DPC interrupt code to check if
    the specified RIP lies within the SLIST pop code. If the specified RIP
    lies within the SLIST code, then RIP is reset to the SLIST resume address.

Arguments:

    TrapFrame - Supplies the address of a trap frame.

Return Value:

    None.

--*/

{

    ULONG64 Rip;

    //
    // Check for user mode 64-bit execution, user mode WOW64 32-bit execution,
    // and kernel mode 64-bit execution.
    //

    Rip = TrapFrame->Rip;
    if (TrapFrame->SegCs == (KGDT64_R3_CODE | RPL_MASK)) {
        if ((Rip > (ULONG64)KeUserPopEntrySListResume) &&
            (Rip <= (ULONG64)KeUserPopEntrySListEnd)) {

            TrapFrame->Rip = (ULONG64)KeUserPopEntrySListResume;
        }

    } else if (TrapFrame->SegCs == (KGDT64_R3_CMCODE | RPL_MASK)) {
        if ((Rip > (ULONG64)KeUserPopEntrySListResumeWow64) &&
            (Rip <= (ULONG64)KeUserPopEntrySListEndWow64)) {

            TrapFrame->Rip = (ULONG64)KeUserPopEntrySListResumeWow64;
        }

    } else if (TrapFrame->SegCs == KGDT64_R0_CODE) {
        if ((Rip > (ULONG64)&ExpInterlockedPopEntrySListResume) &&
            (Rip <= (ULONG64)&ExpInterlockedPopEntrySListEnd)) {

            TrapFrame->Rip = (ULONG64)&ExpInterlockedPopEntrySListResume;
        }
    }

    return;
}


NTSTATUS
KiOp_MOVDQA (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for MOVDQA instructions that resulted in a
    GP fault.  This can occur when supplied with a misaliged memory
    reference.

    This routine essentially performs an "alignment fixup" by replacing
    the instruction with the slower MOVDQU in the user's istream.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    PKPROCESS currentProcess;
    PKTHREAD currentThread;
    NTSTATUS status;

    //
    // If the current process is wow64 or has autoalignment disabled, then
    // do not perform the transformation.
    //

    if (DecodeContext->CompatibilityMode != FALSE) {
        return STATUS_SUCCESS;
    }

    currentThread = KeGetCurrentThread();
    currentProcess = currentThread->ApcState.Process;
    if ((currentThread->AutoAlignment == FALSE) &&
        (currentProcess->AutoAlignment == FALSE)) {

        return STATUS_SUCCESS;
    }

    //
    // Replace:
    //
    // 66 0F 6F /r - MOVDQA xmm1,xmm2/mem128
    // 66 0F 7F /r - MOVDQA xmm1/mem128,xmm2
    //
    // With:
    //
    // F3 0F 6F /r - MOVDQU xmm1,xmm2/mem128
    // F3 0F 7F /r - MOVDQU xmm1/mem128,xmm2
    //

    status = KiOpPatchCode(DecodeContext,
                           DecodeContext->Start,
                           0xF3);

    if (NT_SUCCESS(status) || (status == STATUS_RETRY)) {
        DecodeContext->Retry = TRUE;
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
KiOp_MOVAPS (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for MOVAPS instructions that resulted in a
    GP fault.  This can occur when supplied with a misaliged memory
    reference.

    This routine essentially performs an "alignment fixup" by replacing
    the instruction with the slower MOVUPS in the user's istream.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    PKPROCESS currentProcess;
    PKTHREAD currentThread;
    UCHAR newByte;
    NTSTATUS status;

    //
    // If the current process is wow64 or has autoalignment disabled, or
    // if the fault occured in kernel mode, then do not perform the
    // transformation.
    //

    if ((DecodeContext->CompatibilityMode != FALSE) ||
        (DecodeContext->PreviousMode != UserMode)) {

        return STATUS_SUCCESS;
    }

    currentThread = KeGetCurrentThread();
    currentProcess = currentThread->ApcState.Process;
    if ((currentThread->AutoAlignment == FALSE) &&
        (currentProcess->AutoAlignment == FALSE)) {

        return STATUS_SUCCESS;
    }

    //
    // Replace:
    //
    // 0F 28 /r - MOVAPS xmm1,xmm2/mem128
    // 0F 29 /r - MOVAPS xmm1/mem128,xmm2
    //
    // With:
    //
    // 0F 10 /r - MOVUPS xmm1,xmm2/mem128
    // 0F 11 /r - MOVUPS xmm1/mem128,xmm2
    //

    if (DecodeContext->OpCode == 0x28) {
        newByte = 0x10;
    } else {
        newByte = 0x11;
    }

    status = KiOpPatchCode(DecodeContext,
                           DecodeContext->OpCodeLocation,
                           newByte);

    if (NT_SUCCESS(status) || (status == STATUS_RETRY)) {
        DecodeContext->Retry = TRUE;
        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
KiOp_PREF_NOP (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for PREF_NOP instructions.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS exceptionCode;

    //
    // This is the two-byte modrm NOP that was once a PREFETCHW.  If this
    // instruction appears to have generated an illegal instruction fault,
    // it is because another processor had already patched it but the previous
    // encoding was in this processor's ICACHE.
    // 

    exceptionCode = DecodeContext->ExceptionRecord->ExceptionCode;

    if ((exceptionCode == STATUS_ILLEGAL_INSTRUCTION) &&
        (KiCodePatchCycle != 0)) {

        DecodeContext->Retry = TRUE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
KiOp_PREFETCH3 (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for PREFETCHW instructions that are executed
    on processors that do not support this instruction, resulting in
    an invalid opcode exception.

    The strategy for dealing with such an exception is to replace the
    instruction with a mod r/m nop instruction, which has an encoding
    identical to prefetchw except for the opcode itself.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS exceptionCode;
    ULONG instructionLength;
    NTSTATUS status;

    //
    // The opcode has been decoded.  Transform PREFETCHW into
    // a mod r/m nop by replacing the 0x0D opcode with 0x1f.
    // 

    exceptionCode = DecodeContext->ExceptionRecord->ExceptionCode;
    instructionLength = (ULONG)(DecodeContext->Next -
                                DecodeContext->Start);

    if (exceptionCode == STATUS_ILLEGAL_INSTRUCTION) {

        status = KiOpPatchCode(DecodeContext,
                               DecodeContext->OpCodeLocation,
                               0x1f);
    
        if (!NT_SUCCESS(status)) {
    
            //
            // If the opcode could not be patched then simply
            // skip the instruction.
            //

            DecodeContext->ContextRecord->Rip += instructionLength;
            KiOpPrefetchPatchRetry += 1;
        } else {
            KiOpPrefetchPatchCount += 1;
        }
        DecodeContext->Retry = TRUE;

    } else if (exceptionCode == STATUS_ACCESS_VIOLATION) {

        //
        // Prefetch instructions should never generate an AV.  Advance
        // past the instruction.
        //

        DecodeContext->ContextRecord->Rip += instructionLength;
        DecodeContext->Retry = TRUE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
KiOp_PREFETCHx (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for the PREFETCHx instructions.

    The strategy for dealing with such an exception is to advance the
    instruction pointer past the instruction.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS exceptionCode;
    ULONG instructionLength;

    exceptionCode = DecodeContext->ExceptionRecord->ExceptionCode;
    if (exceptionCode == STATUS_ACCESS_VIOLATION) {

        //
        // Prefetch instructions should never generate an AV.  Advance
        // past the instruction.
        //

        instructionLength = (ULONG)(DecodeContext->Next -
                                    DecodeContext->Start);

        DecodeContext->ContextRecord->Rip += instructionLength;
        DecodeContext->Retry = TRUE;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
KiOp_Div (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for the integer DIV and IDIV instructions.

    The AMD64 processor generates a divide-by-zero fault when either the
    divisor operand is zero, or when the quotient is too large for the
    destination register.

    In the former case a STATUS_INTEGER_DIVIDE_BY_ZERO exception is raised,
    while in the latter case a STATUS_INTEGER_OVERFLOW should be raised.

    It is the job of this routine to determine which exception to raise.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS status;
    KPROCESSOR_MODE captureMode;
    PVOID divisorAddress;
    LONG64 divisor;
    ULONG divisorSize;
    NTSTATUS *exceptionCode;

    if (KiFilterFiberContext( DecodeContext->ContextRecord ) != FALSE) {

        DecodeContext->Retry = TRUE;
        return STATUS_SUCCESS;
    }

    exceptionCode = &DecodeContext->ExceptionRecord->ExceptionCode;
    if (*exceptionCode != STATUS_INTEGER_DIVIDE_BY_ZERO) {

        //
        // No further processing for any other exception.
        //

        return STATUS_SUCCESS;
    }

    //
    // Raise STATUS_INTEGER_DIVIDE_BY_ZERO unless we are able to determine
    // that the divisor was non-zero.
    //

    status = KiOpRetrieveRegMemAddress( DecodeContext,
                                        &divisorAddress,
                                        &captureMode );
    if (NT_SUCCESS(status)) {

        if (DecodeContext->ModRM.reg == 6) {

            //
            // 8 bit divisor
            //

            divisorSize = 1;

        } else if ((DecodeContext->PrefixMask & OP_PREFIX_OPERAND) != 0) {

            //
            // 16 bit divisor
            //

            divisorSize = 2;

        } else if ((DecodeContext->Rex.W == 0)) {

            //
            // 32 bit divisor
            //

            divisorSize = 4;

        } else {

            //
            // 64 bit divisor
            //

            divisorSize = 8;
        }

        divisor = 0;
        try {

            if (captureMode == UserMode) {
                ProbeForRead(divisorAddress,divisorSize,1);
            } 

            switch (divisorSize) {
                case 8:
                    divisor = *(PULONG64)divisorAddress;
                    break;

                case 4:
                    divisor = *(PULONG)divisorAddress;
                    break;

                case 2:
                    divisor = *(PUSHORT)divisorAddress;
                    break;

                case 1:
                    divisor = *(PUCHAR)divisorAddress;
                    break;

                default:
                    __assume(FALSE);
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }

        if (NT_SUCCESS(status) && (divisor != 0)) {

            //
            // The content of the divisor was successfully read and
            // determined to be non-zero.
            //

            *exceptionCode = STATUS_INTEGER_OVERFLOW;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
KiOp_LSAHF (
    IN PDECODE_CONTEXT DecodeContext
    )

/*++

Routine Description:

    This is the handler for the LAHF and SAHF instructions.

    Early versions of the AMD64 processor (and, currently, all versions
    of the EMT64 processor) generate an invalid instruction trap in response
    to executing one of these instructions.

    If previousmode was user, this routine emulates the instruction and
    returns to the caller.

    Otherwise, the exception is forwarded.

    N.B. These instructions will almost always be handled in a more direct
         fashion by KiProcessInvalidOpcodeFault().  Only in the case of a
         more complex opcode (prefixes, etc.) will control make it to
         this point.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT

Return Value:

    STATUS_SUCCESS

--*/

{
    PUCHAR AH;
    PUCHAR FL;
    ULONG instructionLength;

    //
    // Emulates a LAHF/SAHF instruction.
    //

    if (DecodeContext->ExceptionRecord->ExceptionCode !=
        STATUS_ILLEGAL_INSTRUCTION) {

        //
        // No further processing for any other exception.
        //

        return STATUS_SUCCESS;
    }

    AH = ((PUCHAR)&(DecodeContext->ContextRecord->Rax)) + 1;
    FL = (PUCHAR)&(DecodeContext->ContextRecord->EFlags);

    if (DecodeContext->OpCode == 0x9E) {

        //
        // Emulate SAHF
        //

        *FL = *AH;

    } else {

        //
        // Emulate LAHF
        //

        *AH = *FL;
    }

    instructionLength = (ULONG)(DecodeContext->Next -
                                DecodeContext->Start);

    DecodeContext->ContextRecord->Rip += instructionLength;
    DecodeContext->Retry = TRUE;

    return STATUS_SUCCESS;
}


NTSTATUS
KiOpPatchCode (
    IN PDECODE_CONTEXT DecodeContext,
    IN PUCHAR Destination,
    IN UCHAR Replacement
    )

/*++

Routine Description:

    This routine copies the specified data into the opcode that generated the
    exception.  This routine can be used to patch any ISTREAM that was executing
    below SYNCH_LEVEL.

    Patching the ISTREAM must be done with great care, there are several things
    to consider:

    1. No other CPU must be permitted to execute code while it is being patched.

    2. It is possible that P1 will patch the code while P0 is processing the
       exception generated as a result of executing the unpatched copy.  This
       situation must be dealt with correctly.

    3. Any pageable code must not be marked "dirty" as a result of the patch, as
       doing so will result in additional paging activity (i.e. it is cheaper to
       re-patch code that has been discarded than it is to page it out.)

    4. The code may lie within a read-only page.

    Solution 1: The code modification is made within a callback called from
    KeIpiGenericCall().  This ensures that any other processors are spinning
    within an IPI while the code modification is occurring.

    Solution 2: The global KiCodePatchCycle is used to deal with (2).  Each
    trap frame generated as a result of a general protection fault or an illegal
    instruction trap will include the value of KiCodePatchCycle as part of the
    trap frame.

    After the instruction is decoded, the global KiCodePatchCycle is
    compared with that captured in the trap frame.  If they differ, then the
    possibility exists that another processor has already patched the
    instruction after it generated a trap on this processor but before it was
    decoded.  Therefore, execution is retried.

    Solution 3,4: An MDL is made for the target address and the patch is
    performed through the aliased system address.

Arguments:

    DecodeContext - Supplies a pointer to the current DECODE_CONTEXT.

    Destination - Supplies a pointer to the copy destination.

    Replacement - Supplies the replacement byte value

Return Value:

    NTSTATUS - Status of operation

--*/

{
    PVOID baseAddress;
    KIOP_COPY_CONTEXT copyContext;
    PUCHAR dst;
    LARGE_INTEGER interval;
    struct {
        MDL mdl;
        PFN_NUMBER pfnArray[2];
    } mdl;
    KIRQL oldIrql;
    ULONG oldProtection;
    UCHAR reentryCount;
    SIZE_T regionSize;
    NTSTATUS status;
    PKTHREAD thread;
    static LONG64 spinLock = 0;

    thread = KeGetCurrentThread();

    reentryCount = ++(thread->CodePatchInProgress);
    if (reentryCount == 1) {

        //
        // Take the patch lock.  If not available, return indicating retry.
        //

        if (InterlockedCompareExchange64(&spinLock, (LONG64)thread, 0) != 0) {

            if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
    
                interval.QuadPart = -5 * 1000 * 10;     // 5ms, relative
                KeDelayExecutionThread( KernelMode,
                                        FALSE,
                                        &interval );
            }

            status = STATUS_RETRY;
            goto errorExit;
        }
    }

    if (DecodeContext->PreviousMode == UserMode) {

        //
        // Ensure that the target pages are writable
        // 

        baseAddress = Destination;
        regionSize = sizeof(UCHAR);

        status = ZwProtectVirtualMemory(NtCurrentProcess(),
                                        &baseAddress,
                                        &regionSize,
                                        PAGE_EXECUTE_READWRITE,
                                        &oldProtection);
        if (!NT_SUCCESS(status)) {
            goto errorExit;
        }

    }

    //
    // If the fault occured at IRQL < DISPATCH_LEVEL (whether in user-
    // or kernel-mode) then build a locked, system address for the target
    // so that the memory can be manipulated from within an IPI.
    //

    if (InitializationPhase == 0) {

        //
        // If init phase 0 hasn't been completed then it is not yet safe
        // to call MmProbeAndLockPages() or acquire a spinlock.
        //
        // However at this stage, these things can be presumed:
        //
        // - Only a single processor is running
        // - All code pages are writeable
        // - The fault occured in kernel mode
        //

        dst = Destination;
        copyContext.CopyDirect = TRUE;

    } else if (MmCanThreadFault() &&
               (reentryCount == 1) &&
               ((GetCallersEflags() & EFLAGS_IF_MASK) != 0)) {

        //
        // Build a system address for the target, the data will be
        // copied directly to that.
        //

        memset(&mdl,0,sizeof(mdl));
        MmInitializeMdl(&mdl.mdl, Destination, sizeof(UCHAR));
        status = STATUS_SUCCESS;
        try {
            MmProbeAndLockPages(&mdl.mdl,
                                DecodeContext->PreviousMode,
                                IoReadAccess);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();
        }

        if (!NT_SUCCESS(status)) {
            goto revertProtection;
        }

        dst = MmGetSystemAddressForMdlSafe(&mdl.mdl,
                                           NormalPagePriority);
        if (dst == NULL) {
            MmUnlockPages(&mdl.mdl);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto revertProtection;
        }
        copyContext.CopyDirect = TRUE;

    } else {

        //
        // The fault occured at IRQL >= DISPATCH_LEVEL or with interrupts
        // disabled, in which case we know that the target is a locked,
        // kernel-mode address so MmDbgCopyMemory() will be used directly
        // on the destination.
        //

        dst = Destination;
        copyContext.CopyDirect = FALSE;
    }

    //
    // Further initialize copyContext and invoke KiOpSingleProcCopy()
    // simultaneously on all processors.
    // 

    copyContext.Replacement = Replacement;
    copyContext.Destination = dst;
    copyContext.CopyPerformed = FALSE;
    copyContext.Status = STATUS_SUCCESS;

#if defined(NT_UP)

    KeRaiseIrql(IPI_LEVEL-2,&oldIrql);
    KiOpSingleProcCopy((ULONG_PTR)&copyContext);
    KeLowerIrql(oldIrql);

#else

    copyContext.Done = FALSE;
    copyContext.ProcessorNumber = KeGetCurrentProcessorNumber();

    if ((KeNumberProcessors > 1) && (reentryCount <= 2)) {

        thread->CodePatchInProgress += 2;
        copyContext.ProcessorsRunning = KeNumberProcessors-1;
        copyContext.ProcessorsToResume = KeNumberProcessors-1;
        KeIpiGenericCall(KiOpSingleProcCopy,(ULONG_PTR)&copyContext);
        thread->CodePatchInProgress -= 2;

    } else {

        oldIrql = KeGetCurrentIrql();
        if (oldIrql < (IPI_LEVEL-1)) {
            KfRaiseIrql(IPI_LEVEL-1);
        }
        copyContext.ProcessorsRunning = 0;
        copyContext.ProcessorsToResume = 0;
        KiOpSingleProcCopy((ULONG_PTR)&copyContext);
        KeLowerIrql(oldIrql);
    }

#endif

    ASSERT(NT_SUCCESS(copyContext.Status));

    if (dst != Destination) {
        MmUnlockPages(&mdl.mdl);
    }

    if (copyContext.CopyPerformed) {
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_RETRY;
    }

revertProtection:

    if (DecodeContext->PreviousMode == UserMode) {

        //
        // Restore the page protection
        // 

        ZwProtectVirtualMemory(NtCurrentProcess(),
                               &baseAddress,
                               &regionSize,
                               oldProtection,
                               &oldProtection);
    }

    if (reentryCount == 1) {
        InterlockedAnd64( &spinLock, 0 );
    }

errorExit:
    thread->CodePatchInProgress -= 1;

    return status;
}


ULONG_PTR
KiOpSingleProcCopy (
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    This routine is invoked via KeIpiGenericCall() on each processor in the
    system.  It's purpose is to ensure that one processor is modifying code
    at a time when all of the other processors are known to be not executing
    that code.

Arguments:

    Context - Supplies a pointer to the KIOP_COPY_CONTEXT structure.

Return Value:

    0

--*/
{
    PKIOP_COPY_CONTEXT copyContext;
    ULONG64 dst;
    PUCHAR src;
    NTSTATUS status;

    copyContext = (PKIOP_COPY_CONTEXT)Context;

#if !defined(NT_UP)

    if (copyContext->ProcessorNumber != KeGetCurrentProcessorNumber()) {

        //
        // All processors but one wait here until the routine is complete
        //

        InterlockedDecrement(&copyContext->ProcessorsRunning);
        while (copyContext->Done == FALSE) {
            KeYieldProcessor();
        }

        //
        // The working processor has indicated that the operation
        // is complete, acknowledge and return.
        //

        InterlockedDecrement(&copyContext->ProcessorsToResume);
        return 0;
    }

    //
    // This processor will do the work.  First wait until the other
    // processors are spinning.
    // 

    while (copyContext->ProcessorsRunning != 0) {
        KeYieldProcessor();
    }

#endif

    if (copyContext->CopyDirect != FALSE) {

        //
        // The target has been mapped to a system va, copy into that
        // directly.
        // 

        *(copyContext->Destination) = copyContext->Replacement;

        status = STATUS_SUCCESS;

    } else {

        //
        // The target could not be mapped to a system va.  Fortunately
        // means that the target is already locked, system VA.  However,
        // it may be on a read only page, so MmDbgCopyMemory() must be
        // used.
        //

        dst = (ULONG64)copyContext->Destination;
        src = &copyContext->Replacement;

        status = MmDbgCopyMemory(dst,
                                 src,
                                 sizeof(UCHAR),
                                 MMDBG_COPY_WRITE | MMDBG_COPY_UNSAFE);
    }

    //
    // If the copy was performed successfully, so indicate
    // and increment the KiCodePatchCycle global.
    // 

    if (NT_SUCCESS(status)) {
        copyContext->CopyPerformed = TRUE;
        KiCodePatchCycle += 1;
    } else {
        copyContext->Status = status;
    }

    //
    // Finished with the code page modifications, so release the other
    // processors and spin until they acknowledge.
    //

#if !defined(NT_UP)

    copyContext->Done = TRUE;
    while (copyContext->ProcessorsToResume != 0) {
        KeYieldProcessor();
    }

#endif

    return 0;
}


NTSTATUS
KiPreprocessKernelAccessFault (
    IN ULONG FaultStatus,
    IN PVOID VirtualAddress,
    IN KPROCESSOR_MODE PreviousMode,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is invoked from KiPageFault when these conditions are true:

    - The fault was not an execution fault
    - The execution mode at the time of the fault was kernel mode

    This routine will examine the faulting opcode.  If it is a prefetch
    instruction, then execution is resumed.

Arguments:

    FaultStatus - Supplies fault status information bits.

    VirtualAddress - Supplies the virtual address which caused the fault.

    PreviousMode - Supplies the mode (kernel or user) in which the fault
                   occurred.

    TrapFrame - Supplies a pointer to the KTRAP_FRAME generated by
                the fault handler.

Return Value:

    Returns

        - STATUS_SUCCESS if execution should be resumed
        - An error if normal fault handling should proceed

--*/

{
    LOGICAL prefix;
    PUCHAR rip;

    UNREFERENCED_PARAMETER(FaultStatus);
    UNREFERENCED_PARAMETER(VirtualAddress);
    UNREFERENCED_PARAMETER(PreviousMode);

    //
    // This code is executed on every kernel-mode DSTREAM page fault.
    // Performance is paramount.
    //
    // We wish to determine whether this page fault was generated by
    // a prefetch instruction.  Rather than using the rather heavyweight
    // KiOpDecode(), we use a brute-force decode approach.
    //
    // Note that we know this is a valid instruction, otherwise an invalid
    // opcode trap would have been generated.
    //

    //
    // First, skip any prefix bytes.  This routine is invoked for kernel
    // mode faults only, so compatibility mode code is not an option.
    // 

    rip = (PUCHAR)TrapFrame->Rip;
    do {
        switch (*rip) {        

            //
            // 0x0F is the first byte of a two-byte opcode.  Break out
            // of the loop and further qualify the opcode.
            //

            case 0x0F:
                rip += 1;
                prefix = FALSE;
                break;

            case 0x26:          // ES:
            case 0x2E:          // CS:
            case 0x36:          // SS:
            case 0x3E:          // DS:
            case 0x40:          // REX
            case 0x41:          // REX
            case 0x42:          // REX
            case 0x43:          // REX
            case 0x44:          // REX
            case 0x45:          // REX
            case 0x46:          // REX
            case 0x47:          // REX
            case 0x48:          // REX
            case 0x49:          // REX
            case 0x4A:          // REX
            case 0x4B:          // REX
            case 0x4C:          // REX
            case 0x4D:          // REX
            case 0x4E:          // REX
            case 0x4F:          // REX
            case 0x64:          // FS:
            case 0x65:          // GS:
            case 0x66:          // operand size
            case 0x67:          // address size
            case 0xF0:          // lock
            case 0xF2:          // repne
            case 0xF3:          // repe
                rip += 1;
                prefix = TRUE;
                break;

            default:
                return STATUS_ACCESS_VIOLATION;
        }

    } while (prefix != FALSE);

    //
    // Look for 0x0D (PREFETCH or PREFETCHW) or 0x18 (PREFEETCHlevel)
    //

    if (rip[0] == 0x0D) {

        //
        // PREFETCH and PREFETCHW are differentiated by a
        // ModRM.reg of 0 and 1, respectively.
        //

        if ((rip[1] & 0x1C) == 4) {

            //
            // PREFETCHW.  Ensure that this was a write fault.
            //

            if ((FaultStatus & EXCEPTION_WRITE_FAULT) == 0) {
                return STATUS_ACCESS_VIOLATION;
            }

        } else {

            //
            // PREFETCH.  Ensure that this was a read fault.
            //

            if ((FaultStatus & EXCEPTION_WRITE_FAULT) != 0) {
                return STATUS_ACCESS_VIOLATION;
            }
        }

    } else if (rip[0] == 0x18) {

        //
        // PREFETCHx.  Ensure that this was a read fault.
        //

        if ((FaultStatus & EXCEPTION_WRITE_FAULT) != 0) {
            return STATUS_ACCESS_VIOLATION;
        }

    } else {

        //
        // Some other instruction.
        // 

        return STATUS_ACCESS_VIOLATION;
    }

    return STATUS_SUCCESS;
}


LOGICAL
KiPreprocessInvalidOpcodeFault (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is invoked from KiInvalidOpcodeFault.  It will examine the
    faulting opcode.  If it is LAHF or SAHF, the instruction will be
    emulated and execution resumed.

Arguments:

    TrapFrame - Supplies a pointer to the KTRAP_FRAME generated by
                the fault handler.

Return Value:

    Returns non-zero if the instruction was emulated and should be resumed,
    zero otherwise.

--*/

{
    PUCHAR AH;
    PUCHAR FL;
    LOGICAL fixedUp;
    KIRQL oldIrql;
    UCHAR opcode;
    KPROCESSOR_MODE previousMode;
    PUCHAR rip;

    fixedUp = FALSE;

    //
    // Ensure that the trap frame isn't modified while we're here
    // 

    oldIrql = KeGetCurrentIrql();
    if (oldIrql < APC_LEVEL) {
        KfRaiseIrql(APC_LEVEL);
    }

    //
    // Determine previous mode and capture the faulting opcode, probing
    // as appropriate.
    //

    if ((TrapFrame->SegCs & MODE_MASK) != 0) {
        previousMode = UserMode;
    } else {
        previousMode = KernelMode;
    }

    rip = (PUCHAR)(TrapFrame->Rip);
    if (previousMode == UserMode) {

        opcode = 0;
        try {
            opcode = ProbeAndReadUchar(rip);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }

    } else {
        opcode = *rip;
    }

    //
    // If the opcode is neither SAHF nor LAHF then return FALSE.  If the
    // opcode capture failed, then opcode == 0 at this point.
    //
    // If this is in fact a more complex encoding of LAHF/SAHF (prefix,
    // etc.) then KiOp_LSAHF() will pick it up.
    // 
    // Otherwise, emulate the effect of the instruction, skip past, and
    // resume execution.
    // 
    
    AH = ((PUCHAR)&(TrapFrame->Rax)) + 1;
    FL = (PUCHAR)&(TrapFrame->EFlags);

    if (opcode == 0x9E) {

        //
        // Emulate SAHF
        //

        *FL = *AH;
        fixedUp = TRUE;

    } else if (opcode == 0x9F) {

        //
        // Emulate LAHF
        //

        *AH = *FL;
        fixedUp = TRUE;
    }

    if (fixedUp != FALSE) {
    
        TrapFrame->Rip = SANITIZE_VA(TrapFrame->Rip + 1,
                                     TrapFrame->SegCs,
                                     previousMode);
    }

    if (oldIrql < APC_LEVEL) {
        KeLowerIrql(oldIrql);
    }

    return fixedUp;
}


BOOLEAN
KiOpPreprocessAccessViolation (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    TRUE - the caller's context should be updated and control returned
           to the caller.

    FALSE - do not return control to the caller at this time, continue
            exception handling.

--*/

{
    USHORT codeSegment;
    PKTHREAD currentThread;
    PVOID faultVa;
    ULONG faultCount;
    ULONG64 slistFault;
    ULONG64 slistResume;

    codeSegment = ContextRecord->SegCs;
    switch (codeSegment) {
    
        case KGDT64_R3_CODE | RPL_MASK:
            slistFault = (ULONG64)KeUserPopEntrySListFault;
            slistResume = (ULONG64)KeUserPopEntrySListResume;
            break;

        case KGDT64_R3_CMCODE | RPL_MASK:
            slistFault = (ULONG64)KeUserPopEntrySListFaultWow64;
            slistResume = (ULONG64)KeUserPopEntrySListResumeWow64;
            break;

        case KGDT64_R0_CODE:
            slistFault = (ULONG64)&ExpInterlockedPopEntrySListFault;
            slistResume = (ULONG64)&ExpInterlockedPopEntrySListResume;
            break;

        default:
            return FALSE;
    }

    if (ContextRecord->Rip != slistFault) {
        return FALSE;
    }

    if (codeSegment == KGDT64_R0_CODE) {
        ContextRecord->Rip = slistResume;
        return TRUE;
    }

    currentThread = KeGetCurrentThread();
    faultVa = (PVOID)ExceptionRecord->ExceptionInformation[1];

    if (faultVa == currentThread->SListFaultAddress) {

        faultCount = currentThread->SListFaultCount;
        if (faultCount > KI_SLIST_FAULT_COUNT_MAXIMUM) {
            currentThread->SListFaultCount = 0;
            return FALSE;
        }

        currentThread->SListFaultCount = faultCount + 1;

    } else {

        currentThread->SListFaultCount = 0;
        currentThread->SListFaultAddress = faultVa;
    }

    ContextRecord->Rip = slistResume;
    return TRUE;

}


BOOLEAN
KeInvalidAccessAllowed (
    __in_opt PVOID TrapInformation
    )

/*++

Routine Description:

    Mm will pass a pointer to a trap frame prior to issuing a bugcheck on
    a pagefault.  This routine lets Mm know if it is ok to bugcheck.  The
    specific case we must protect are the interlocked pop sequences which can
    blindly access memory that may have been freed and/or reused prior to the
    access.  We don't want to bugcheck the system in these cases, so we check
    the instruction pointer here.

    For a usermode fault, Mm uses this routine for similar reasons, to determine
    whether a guard page fault should be ignored.

Arguments:

    TrapInformation - Supplies a trap frame pointer.  NULL means return False.

Return Value:

    True if the invalid access should be ignored, False otherwise.

--*/

{
    BOOLEAN result;
    ULONG64 slistFaultIP;
    PKTRAP_FRAME trapFrame;

    if (ARGUMENT_PRESENT(TrapInformation) == FALSE) {
        return FALSE;
    }

    trapFrame = TrapInformation;
    result = FALSE;

    switch (trapFrame->SegCs) {

        case KGDT64_R0_CODE:

            //
            // Fault occured in kernel mode
            //

            slistFaultIP = (ULONG64)&ExpInterlockedPopEntrySListFault;
            break;

        case KGDT64_R3_CMCODE | RPL_MASK:

            //
            // Fault occured in usermode, wow64
            //

            slistFaultIP = (ULONG64)KeUserPopEntrySListFaultWow64;
            break;

        case KGDT64_R3_CODE | RPL_MASK:

            //
            // Fault occured in native usermode
            //

            slistFaultIP = (ULONG64)KeUserPopEntrySListFault;
            break;

        default:
            return FALSE;
    }

    if (trapFrame->Rip == slistFaultIP) {
        result = TRUE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\exceptn.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exceptn.c

Abstract:

    This module implement the code necessary to dispatch exceptions to the
    proper mode and invoke the exception dispatcher.

--*/

#include "ki.h"

BOOLEAN
KiPreprocessFault (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextRecord,
    IN KPROCESSOR_MODE PreviousMode
    );

VOID
KeContextFromKframes (
    __in PKTRAP_FRAME TrapFrame,
    __in PKEXCEPTION_FRAME ExceptionFrame,
    __inout PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and
    exception frames into the specified context frame according to the
    specified context flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile
        context should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which
        context should be copied into the context record.

    ContextRecord - Supplies a pointer to the context frame that receives
        the context copied from the trap and exception frames.

Return Value:

    None.

--*/

{

    ULONG ContextFlags;
    KIRQL OldIrql;

    //
    // Raise IRQL to APC_LEVEL to guarantee that a consistent set of context
    // is transferred from the trap and exception frames.
    //

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < APC_LEVEL) {
        KfRaiseIrql(APC_LEVEL);
    }

    //
    // Set control information if specified.
    //

    ContextFlags = ContextRecord->ContextFlags;
    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers RIP, CS, RSP, SS, and EFlags.
        //

        ContextRecord->Rip = TrapFrame->Rip;
        ContextRecord->SegCs = TrapFrame->SegCs;
        ContextRecord->SegSs = TrapFrame->SegSs;
        ContextRecord->Rsp = TrapFrame->Rsp;
        ContextRecord->EFlags = TrapFrame->EFlags;
    }

    //
    // Set segment register contents if specified.
    //

    if ((ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers GS, FS, ES, DS.
        //

        ContextRecord->SegDs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegEs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegFs = KGDT64_R3_CMTEB | RPL_MASK;
        ContextRecord->SegGs = KGDT64_R3_DATA | RPL_MASK;
    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        ContextRecord->Rax = TrapFrame->Rax;
        ContextRecord->Rcx = TrapFrame->Rcx;
        ContextRecord->Rdx = TrapFrame->Rdx;
        ContextRecord->R8 = TrapFrame->R8;
        ContextRecord->R9 = TrapFrame->R9;
        ContextRecord->R10 = TrapFrame->R10;
        ContextRecord->R11 = TrapFrame->R11;
        ContextRecord->Rbp = TrapFrame->Rbp;

        ContextRecord->Rbx = ExceptionFrame->Rbx;
        ContextRecord->Rdi = ExceptionFrame->Rdi;
        ContextRecord->Rsi = ExceptionFrame->Rsi;
        ContextRecord->R12 = ExceptionFrame->R12;
        ContextRecord->R13 = ExceptionFrame->R13;
        ContextRecord->R14 = ExceptionFrame->R14;
        ContextRecord->R15 = ExceptionFrame->R15;
    }

    //
    // Set floating point context if specified.
    //
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // If the specified mode is user, then save the legacy floating
        // point state.
        //

        if ((TrapFrame->SegCs & MODE_MASK) == UserMode) {
            KeSaveLegacyFloatingPointState(&ContextRecord->FltSave);
        }

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //

        ContextRecord->Xmm0 = TrapFrame->Xmm0;
        ContextRecord->Xmm1 = TrapFrame->Xmm1;
        ContextRecord->Xmm2 = TrapFrame->Xmm2;
        ContextRecord->Xmm3 = TrapFrame->Xmm3;
        ContextRecord->Xmm4 = TrapFrame->Xmm4;
        ContextRecord->Xmm5 = TrapFrame->Xmm5;

        ContextRecord->Xmm6 = ExceptionFrame->Xmm6;
        ContextRecord->Xmm7 = ExceptionFrame->Xmm7;
        ContextRecord->Xmm8 = ExceptionFrame->Xmm8;
        ContextRecord->Xmm9 = ExceptionFrame->Xmm9;
        ContextRecord->Xmm10 = ExceptionFrame->Xmm10;
        ContextRecord->Xmm11 = ExceptionFrame->Xmm11;
        ContextRecord->Xmm12 = ExceptionFrame->Xmm12;
        ContextRecord->Xmm13 = ExceptionFrame->Xmm13;
        ContextRecord->Xmm14 = ExceptionFrame->Xmm14;
        ContextRecord->Xmm15 = ExceptionFrame->Xmm15;

        ContextRecord->MxCsr = TrapFrame->MxCsr;
    }

    //
    //
    // Set debug register contents if requested.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        if ((TrapFrame->Dr7 & DR7_ACTIVE) != 0) {
            ContextRecord->Dr0 = TrapFrame->Dr0;
            ContextRecord->Dr1 = TrapFrame->Dr1;
            ContextRecord->Dr2 = TrapFrame->Dr2;
            ContextRecord->Dr3 = TrapFrame->Dr3;
            ContextRecord->Dr6 = TrapFrame->Dr6;
            ContextRecord->Dr7 = TrapFrame->Dr7;
            if ((TrapFrame->Dr7 & DR7_LAST_BRANCH) != 0) {
                ContextRecord->LastBranchToRip = TrapFrame->LastBranchToRip;
                ContextRecord->LastBranchFromRip = TrapFrame->LastBranchFromRip;
                ContextRecord->LastExceptionToRip = TrapFrame->LastExceptionToRip;
                ContextRecord->LastExceptionFromRip = TrapFrame->LastExceptionFromRip;

            } else {
                ContextRecord->LastBranchToRip = 0;
                ContextRecord->LastBranchFromRip = 0;
                ContextRecord->LastExceptionToRip = 0;
                ContextRecord->LastExceptionFromRip = 0;
            }

        } else {
            ContextRecord->Dr0 = 0;
            ContextRecord->Dr1 = 0;
            ContextRecord->Dr2 = 0;
            ContextRecord->Dr3 = 0;
            ContextRecord->Dr6 = 0;
            ContextRecord->Dr7 = 0;
            ContextRecord->LastBranchToRip = 0;
            ContextRecord->LastBranchFromRip = 0;
            ContextRecord->LastExceptionToRip = 0;
            ContextRecord->LastExceptionFromRip = 0;
        }
    }

    //
    // Lower IRQL to its previous value.
    //

    if (OldIrql < APC_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    return;
}

PXMM_SAVE_AREA32
KxContextToKframes (
    __inout PKTRAP_FRAME TrapFrame,
    __inout PKEXCEPTION_FRAME ExceptionFrame,
    __in PCONTEXT ContextRecord,
    __in ULONG ContextFlags,
    __in KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame
    into the specified trap and exception frames according to the specified
    context flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record.

    ContextRecord - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

    PreviousMode - Supplies the processor mode for which the exception and
        trap frames are being built.

Return Value:

    If the context operation is a set context and the legacy floating state is
    switched for the current thread, then the address of the legacy floating
    save area is returned as the function value. Otherwise, NULL is returned.

--*/

{

    PXMM_SAVE_AREA32 XmmSaveArea;

    //
    // Set control information if specified.
    //

    XmmSaveArea = NULL;
    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {
        TrapFrame->EFlags = SANITIZE_EFLAGS(ContextRecord->EFlags, PreviousMode);
        TrapFrame->Rip = ContextRecord->Rip;
        TrapFrame->Rsp = ContextRecord->Rsp;
    }

    //
    // The segment registers DS, ES, FS, and GS are never restored from saved
    // data. However, SS and CS are restored from the trap frame. Make sure
    // that these segment registers have the proper values.
    //

    if (PreviousMode == UserMode) {
        TrapFrame->SegSs = KGDT64_R3_DATA | RPL_MASK;
        if (ContextRecord->SegCs != (KGDT64_R3_CODE | RPL_MASK)) {
            TrapFrame->SegCs = KGDT64_R3_CMCODE | RPL_MASK;

        } else {
            TrapFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;
        }

    } else {
        TrapFrame->SegCs = KGDT64_R0_CODE;
        TrapFrame->SegSs = KGDT64_R0_DATA;
    }

    TrapFrame->Rip = SANITIZE_VA(TrapFrame->Rip, TrapFrame->SegCs, PreviousMode);

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        TrapFrame->Rax = ContextRecord->Rax;
        TrapFrame->Rcx = ContextRecord->Rcx;
        TrapFrame->Rdx = ContextRecord->Rdx;
        TrapFrame->R8 = ContextRecord->R8;
        TrapFrame->R9 = ContextRecord->R9;
        TrapFrame->R10 = ContextRecord->R10;
        TrapFrame->R11 = ContextRecord->R11;
        TrapFrame->Rbp = ContextRecord->Rbp;

        ExceptionFrame->Rbx = ContextRecord->Rbx;
        ExceptionFrame->Rsi = ContextRecord->Rsi;
        ExceptionFrame->Rdi = ContextRecord->Rdi;
        ExceptionFrame->R12 = ContextRecord->R12;
        ExceptionFrame->R13 = ContextRecord->R13;
        ExceptionFrame->R14 = ContextRecord->R14;
        ExceptionFrame->R15 = ContextRecord->R15;
    }

    //
    // Set floating register contents if requested.
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //

        TrapFrame->Xmm0 = ContextRecord->Xmm0;
        TrapFrame->Xmm1 = ContextRecord->Xmm1;
        TrapFrame->Xmm2 = ContextRecord->Xmm2;
        TrapFrame->Xmm3 = ContextRecord->Xmm3;
        TrapFrame->Xmm4 = ContextRecord->Xmm4;
        TrapFrame->Xmm5 = ContextRecord->Xmm5;

        ExceptionFrame->Xmm6 = ContextRecord->Xmm6;
        ExceptionFrame->Xmm7 = ContextRecord->Xmm7;
        ExceptionFrame->Xmm8 = ContextRecord->Xmm8;
        ExceptionFrame->Xmm9 = ContextRecord->Xmm9;
        ExceptionFrame->Xmm10 = ContextRecord->Xmm10;
        ExceptionFrame->Xmm11 = ContextRecord->Xmm11;
        ExceptionFrame->Xmm12 = ContextRecord->Xmm12;
        ExceptionFrame->Xmm13 = ContextRecord->Xmm13;
        ExceptionFrame->Xmm14 = ContextRecord->Xmm14;
        ExceptionFrame->Xmm15 = ContextRecord->Xmm15;

        //
        // Clear all reserved bits in MXCSR.
        //

        TrapFrame->MxCsr = SANITIZE_MXCSR(ContextRecord->MxCsr);

        //
        // If the specified mode is user, then set the legacy floating point
        // state.
        //
        // Clear all reserved bits in legacy floating state.
        //
        // N.B. The legacy floating state is restored if and only if the
        //      request mode is user.
        //
        // N.B. The current MXCSR value is placed in the legacy floating
        //      state so it will get restored if the legacy state is
        //      restored.
        // 

        if (PreviousMode == UserMode) {
            XmmSaveArea = &ContextRecord->FltSave;
            ContextRecord->FltSave.MxCsr = ReadMxCsr();
            ContextRecord->FltSave.ControlWord =
                                SANITIZE_FCW(ContextRecord->FltSave.ControlWord);
        }
    }

    //
    // Set debug register state if specified.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        TrapFrame->Dr0 = SANITIZE_DRADDR(ContextRecord->Dr0, PreviousMode);
        TrapFrame->Dr1 = SANITIZE_DRADDR(ContextRecord->Dr1, PreviousMode);
        TrapFrame->Dr2 = SANITIZE_DRADDR(ContextRecord->Dr2, PreviousMode);
        TrapFrame->Dr3 = SANITIZE_DRADDR(ContextRecord->Dr3, PreviousMode);
        TrapFrame->Dr6 = 0;
        TrapFrame->Dr7 = SANITIZE_DR7(ContextRecord->Dr7, PreviousMode);
        TrapFrame->LastBranchToRip = ContextRecord->LastBranchToRip;
        TrapFrame->LastBranchFromRip = ContextRecord->LastBranchFromRip;
        TrapFrame->LastExceptionToRip = ContextRecord->LastExceptionToRip;
        TrapFrame->LastExceptionFromRip = ContextRecord->LastExceptionFromRip;
        if (PreviousMode != KernelMode) {
            KeGetCurrentThread()->Header.DebugActive =
                                (BOOLEAN)((TrapFrame->Dr7 & DR7_ACTIVE) != 0);
        }
    }

    return XmmSaveArea;
}

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called. If the previous mode is
    kernel, then the exception dispatcher is called directly to process the
    exception. Otherwise the exception record, exception frame, and trap
    frame contents are copied to the user mode stack. The contents of the
    exception frame and trap are then modified such that when control is
    returned, execution will commense in user mode in a routine which will
    call the exception dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,
        this should be NULL.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Supplies the previous processor mode.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    BOOLEAN DebugService;
    EXCEPTION_RECORD ExceptionRecord1;
    BOOLEAN ExceptionWasForwarded = FALSE;
    ULONG64 FaultingRsp;
    PMACHINE_FRAME MachineFrame;
    ULONG64 UserStack1;
    ULONG64 UserStack2;

    //
    // Move machine state from trap and exception frames to a context frame
    // and increment the number of exceptions dispatched.
    //

    KeGetCurrentPrcb()->KeExceptionDispatchCount += 1;
    ContextRecord.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS | CONTEXT_SEGMENTS;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextRecord);

    //
    // If the exception is a break point, then convert the break point to a
    // fault.
    //

    if (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) {
        ContextRecord.Rip -= 1;
    }

    //
    // If the exception is an internal general protect fault, invalid opcode,
    // or integer divide by zero, then attempt to resolve the problem without
    // actually raising an exception.
    // 

    if (KiPreprocessFault(ExceptionRecord,
                          TrapFrame,
                          &ContextRecord,
                          PreviousMode) != FALSE) {

        goto Handled1;
    }

    //
    // Select the method of handling the exception based on the previous mode.
    //

    if (PreviousMode == KernelMode) {

        //
        // Previous mode was kernel.
        //
        // If the kernel debugger is active, then give the kernel debugger
        // the first chance to handle the exception. If the kernel debugger
        // handles the exception, then continue execution. Otherwise, attempt
        // to dispatch the exception to a frame based handler. If a frame
        // based handler handles the exception, then continue execution.
        //
        // If a frame based handler does not handle the exception, give the
        // kernel debugger a second chance, if it's present.
        //
        // If the exception is still unhandled call bugcheck.
        //

        if (FirstChance != FALSE) {
            if ((KiDebugRoutine)(TrapFrame,
                                 ExceptionFrame,
                                 ExceptionRecord,
                                 &ContextRecord,
                                 PreviousMode,
                                 FALSE) != FALSE) {

                goto Handled1;
            }

            //
            // Kernel debugger didn't handle exception.
            //
            // If interrupts are disabled, then bugcheck.
            //

            if (RtlDispatchException(ExceptionRecord, &ContextRecord) != FALSE) {
                goto Handled1;
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if ((KiDebugRoutine)(TrapFrame,
                             ExceptionFrame,
                             ExceptionRecord,
                             &ContextRecord,
                             PreviousMode,
                             TRUE) != FALSE) {

            goto Handled1;
        }

        KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                     ExceptionRecord->ExceptionCode,
                     (ULONG64)ExceptionRecord->ExceptionAddress,
                     ExceptionRecord->ExceptionInformation[0],
                     ExceptionRecord->ExceptionInformation[1]);

    } else {

        //
        // Previous mode was user.
        //
        // If this is the first chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // transfer the exception information to the user stack, transition to
        // user mode, and attempt to dispatch the exception to a frame based
        // handler. If a frame based handler handles the exception, then continue
        // execution with the continue system service. Else execute the
        // NtRaiseException system service with FirstChance == FALSE, which
        // will call this routine a second time to process the exception.
        //
        // If this is the second chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // if the current process has a subsystem port, then send a message to
        // the subsystem port and wait for a reply. If the subsystem handles the
        // exception, then continue execution. Else terminate the process.
        //
        // If the current process is a wow64 process, an alignment fault has
        // occurred, and the AC bit is set in EFLAGS, then clear AC in EFLAGS
        // and continue execution. Otherwise, attempt to resolve the exception.
        //

        if ((PsGetCurrentProcess()->Wow64Process != NULL) &&
            (ExceptionRecord->ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) &&
            ((TrapFrame->EFlags & EFLAGS_AC_MASK) != 0)) {

            TrapFrame->EFlags &= ~EFLAGS_AC_MASK;
            goto Handled2;
        }

        //
        // If the exception happened while executing 32-bit code, then convert
        // the exception to a wow64 exception. These codes are translated later
        // by wow64.
        //

        if ((ContextRecord.SegCs & 0xfff8) == KGDT64_R3_CMCODE) {
            
            switch (ExceptionRecord->ExceptionCode) {
            case STATUS_BREAKPOINT:
                ExceptionRecord->ExceptionCode = STATUS_WX86_BREAKPOINT;
                break;

            case STATUS_SINGLE_STEP:
                ExceptionRecord->ExceptionCode = STATUS_WX86_SINGLE_STEP;
                break;
            }

            //
            // Clear the upper 32-bits of the stack address and 16-byte
            // align the stack address.
            //

            FaultingRsp = (ContextRecord.Rsp & 0xfffffff0UI64);

        } else {
            FaultingRsp = ContextRecord.Rsp;
        }

        if (FirstChance == TRUE) {

            //
            // This is the first chance to handle the exception.
            //
            // If the current processor is not being debugged and user mode
            // exceptions are not being ignored, or this is a debug service,
            // then attempt to handle the exception via the kernel debugger.
            //


            DebugService = KdIsThisAKdTrap(ExceptionRecord,
                                           &ContextRecord,
                                           UserMode);

            if (((PsGetCurrentProcess()->DebugPort == NULL) &&
                 (KdIgnoreUmExceptions == FALSE)) ||
                (DebugService == TRUE)) {

                //
                // Attempt to handle the exception with the kernel debugger.
                //

                if ((KiDebugRoutine)(TrapFrame,
                                     ExceptionFrame,
                                     ExceptionRecord,
                                     &ContextRecord,
                                     PreviousMode,
                                     FALSE) != FALSE) {

                    goto Handled1;
                }
            }

            if ((ExceptionWasForwarded == FALSE) &&
                (DbgkForwardException(ExceptionRecord, TRUE, FALSE))) {

                goto Handled2;
            }

            //
            // Clear the trace flag in the trap frame so a spurious trace
            // trap is guaranteed not to occur in the trampoline code.
            //
    
            TrapFrame->EFlags &= ~EFLAGS_TF_MASK;

            //
            // Transfer exception information to the user stack, transition
            // to user mode, and attempt to dispatch the exception to a frame
            // based handler.
            //

            ExceptionRecord1.ExceptionCode = STATUS_ACCESS_VIOLATION;

        repeat:
            try {

                //
                // Compute address of aligned machine frame, compute address
                // of exception record, compute address of context record,
                // and probe user stack for writeability.
                //

                MachineFrame =
                    (PMACHINE_FRAME)((FaultingRsp - sizeof(MACHINE_FRAME)) & ~STACK_ROUND);

                UserStack1 = (ULONG64)MachineFrame - EXCEPTION_RECORD_LENGTH;
                UserStack2 = UserStack1 - CONTEXT_LENGTH;
                ProbeForWriteSmallStructure((PVOID)UserStack2,
                                            sizeof(MACHINE_FRAME) + EXCEPTION_RECORD_LENGTH + CONTEXT_LENGTH,
                                            STACK_ALIGN);

                //
                // Fill in machine frame information.
                //

                MachineFrame->Rsp = FaultingRsp;
                MachineFrame->Rip = ContextRecord.Rip;

                //
                // Copy exception record to the user stack.
                //

                *(PEXCEPTION_RECORD)UserStack1 = *ExceptionRecord;

                //
                // Copy context record to the user stack.
                //

                *(PCONTEXT)UserStack2 = ContextRecord;

                //
                // Set the address of the new stack pointer in the current
                // trap frame.
                //

                TrapFrame->Rsp = UserStack2;

                //
                // Set the user mode 64-bit code selector.
                //

                TrapFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;

                //
                // Set the address of the exception routine that will call the
                // exception dispatcher and then return to the trap handler.
                // The trap handler will restore the exception and trap frame
                // context and continue execution in the routine that will
                // call the exception dispatcher.
                //

                TrapFrame->Rip = (ULONG64)KeUserExceptionDispatcher;
                return;

            } except (KiCopyInformation(&ExceptionRecord1,
                        (GetExceptionInformation())->ExceptionRecord)) {

                //
                // If the exception is a stack overflow, then attempt to
                // raise the stack overflow exception. Otherwise, the user's
                // stack is not accessible, or is misaligned, and second
                // chance processing is performed.
                //

                if (ExceptionRecord1.ExceptionCode == STATUS_STACK_OVERFLOW) {
                    ExceptionRecord1.ExceptionAddress = ExceptionRecord->ExceptionAddress;
                    *ExceptionRecord = ExceptionRecord1;

                    goto repeat;
                }
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if (DbgkForwardException(ExceptionRecord, TRUE, TRUE)) {
            goto Handled2;

        } else if (DbgkForwardException(ExceptionRecord, FALSE, TRUE)) {
            goto Handled2;

        } else {
            ZwTerminateProcess(NtCurrentProcess(), ExceptionRecord->ExceptionCode);
            KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                         ExceptionRecord->ExceptionCode,
                         (ULONG64)ExceptionRecord->ExceptionAddress,
                         ExceptionRecord->ExceptionInformation[0],
                         ExceptionRecord->ExceptionInformation[1]);
        }
    }

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:
    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &ContextRecord,
                       ContextRecord.ContextFlags,
                       PreviousMode);

    //
    // Exception was handled by the debugger or the associated subsystem
    // and state was modified, if necessary, using the get state and set
    // state capabilities. Therefore the context frame does not need to
    // be transferred to the trap and exception frames.
    //

Handled2:
    return;
}

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    )

/*++

Routine Description:

    This function is called from an exception filter to copy the exception
    information from one exception record to another when an exception occurs.

Arguments:

    ExceptionRecord1 - Supplies a pointer to the destination exception record.

    ExceptionRecord2 - Supplies a pointer to the source exception record.

Return Value:

    A value of EXCEPTION_EXECUTE_HANDLER is returned as the function value.

--*/

{

    //
    // Copy one exception record to another and return value that causes
    // an exception handler to be executed.
    //

    *ExceptionRecord1 = *ExceptionRecord2;

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOLEAN
KeQueryCurrentStackInformation (
    __out PKERNEL_STACK_LIMITS Type,
    __out PULONG64 LowLimit,
    __out PULONG64 HighLimit
    )

/*++

Routine Description:

    This function determines the current kernel stack type and limits.

Arguments:

    Type - Supplies a pointer to a variable that receives the kernel stack
        type.

    LowLimit - Supplies a pointer to a variable that receives the low
        stack limit.

    HighLimit - Supplies a pointer to a variable that receives the high
        stack limit.

Return Value;

    A value of TRUE is returned if the current stack pointer is within the
    defined limits. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG64 CurrentStack;
    PKERNEL_STACK_CONTROL StackControl;
    PKTHREAD Thread;

    //
    // If a bugcheck is in progress, then return system space as the stack
    // limits. Otherwise, if a DPC is active then return the DPC stack limits.
    // Otherwise, return the thread stack limits.
    //

    if (KeBugCheckActive != FALSE) {
        *Type = BugcheckStackLimits;
        *HighLimit = (ULONG64)MM_SYSTEM_SPACE_END;
        *LowLimit = (ULONG64)MM_KSEG0_BASE;
        return TRUE;

    } else {
        Thread = KeGetCurrentThread();
        if ((KeIsExecutingLegacyDpc() == TRUE) &&
            (Thread != KeGetCurrentPrcb()->IdleThread)) {

            *Type = DPCStackLimits;
            *HighLimit = KeGetDpcStackBase();
            *LowLimit = *HighLimit - KERNEL_STACK_SIZE;

        } else {
            if (Thread->CalloutActive == TRUE) {
                *Type = ExpandedStackLimits;
    
            } else if (Thread->LargeStack == TRUE) {
                *Type = Win32kStackLimits;
    
            } else {
                *Type = NormalStackLimits;
            }

            StackControl = (PKERNEL_STACK_CONTROL)(Thread->InitialStack);
            if (((ULONG64)Thread->StackBase == StackControl->Current.StackBase) &&
                (StackControl->Current.ActualLimit <= (ULONG64)Thread->StackLimit) &&
                ((ULONG64)Thread->StackLimit < StackControl->Current.StackBase)) {

                *HighLimit = (ULONG64)Thread->StackBase;
                *LowLimit = (ULONG64)Thread->StackLimit;

            } else {
                *HighLimit = StackControl->Current.StackBase;
                *LowLimit = StackControl->Current.ActualLimit;
            }
        }

        //
        // Check to determine if the current stack is within the computed
        // limits.
        //
    
        CurrentStack = KeGetCurrentStackPointer();
        if ((*LowLimit <= CurrentStack) && (CurrentStack < *HighLimit)) {
            return TRUE;

        } else {
            return FALSE;
        }
    }
}

NTSTATUS
KeRaiseUserException (
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function causes an exception to be raised in the calling thread's
    user context.

Arguments:

    ExceptionCode - Supplies the status value to be raised.

Return Value:

    The status value that should be returned by the caller.

--*/

{

    PTEB Teb;
    PKTHREAD Thread;
    PKTRAP_FRAME TrapFrame;

    //
    // Save the exception code in the TEB and set the return address in the
    // trap frame to return to the raise user exception code in user mode.
    // This replaces the normal return which would go to the system service
    // dispatch stub. The system service dispatch stub is called thus the
    // return to the system service call site is on the top of the user stack.
    //

    Thread = KeGetCurrentThread();
    TrapFrame = Thread->TrapFrame;
    if ((TrapFrame != NULL) &&
        ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {
        Teb = (PTEB)Thread->Teb;
        try {
            Teb->ExceptionCode = ExceptionCode;
    
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return ExceptionCode;
        }

        TrapFrame->Rip = (ULONG64)KeRaiseUserExceptionDispatcher;
    }

    return ExceptionCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\idle.asm ===
title  "Idle Loop"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   idle.asm
;
; Abstract:
;
;   This module implements the platform specified idle loop.
;
;--

include ksamd64.inc

        extern  KeAcquireQueuedSpinLockAtDpcLevel:proc
        extern  KeAcquireQueuedSpinLockRaiseToSynch:proc
        extern  KeReleaseQueuedSpinLock:proc
        extern  KeReleaseQueuedSpinLockFromDpcLevel:proc

ifndef NT_UP

        extern  KiIdleSchedule:proc

endif

        extern  KiRetireDpcList:proc
        extern  SwapContext:proc

        subttl  "Idle Loop"
;++
; VOID
; KiIdleLoop (
;     VOID
;     )
;
; Routine Description:
;
;    This routine continuously executes the idle loop and never returns.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    This routine never returns.
;
;--

IlFrame struct
        P1Home  dq ?                    ;
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        Fill    dq ?                    ; fill to 8 mod 16
IlFrame ends

        NESTED_ENTRY KiIdleLoop, _TEXT$00

        alloc_stack (sizeof IlFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     rbx, gs:[PcCurrentPrcb] ; get current processor block address
        jmp     short KiIL20            ; skip idle processor on first iteration

;
; There are no entries in the DPC list and a thread has not been selected
; for execution on this processor. Call the HAL so power managment can be
; performed.
;
; N.B. The HAL is called with interrupts disabled. The HAL will return
;      with interrupts enabled.
;

KiIL10: xor     ecx, ecx                ; lower IRQL to passive level

        SetIrql                         ;

        lea     rcx, PbPowerState[rbx]  ; set address of power state
        call    qword ptr PpIdleFunction[rcx] ; call idle function
        sti                             ; enable interrupts/avoid spurious interrupt
        mov     ecx, DISPATCH_LEVEL     ; set IRQL to dispatch level

        SetIrql                         ;

        and     byte ptr PbIdleHalt[rbx], 0 ; clear idle halt

KiIL20:                                 ; reference label

;
; Disable interrupts and check if there is any work in the DPC list of the
; current processor or a target processor.
;
; N.B. The following code enables interrupts for a few cycles, then disables
;      them again for the subsequent DPC and next thread checks.
;

CheckDpcList:                           ; reference label

        Yield                           ; yield processor execution

        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        mov     eax, PbDpcQueueDepth[rbx] ; get DPC queue depth
        or      rax, PbTimerRequest[rbx] ; merge timer request value

ifndef NT_UP

        or      rax, PbDeferredReadyListHead[rbx] ; merge ready list head

endif

        jz      short CheckNextThread   ; if z, no DPCs to process
        mov     rcx, rbx                ; set current PRCB address
        call    KiRetireDpcList         ; process the current DPC list

;
; Check if a thread has been selected to run on the current processor.
;
; N.B. The variable idle halt is only written on the owning processor.
;      It is only read on other processors. This variable is set when
;      the respective processor may enter a sleep state. The following
;      code sets the variable under interlocked which provides a memory
;      barrier, then checks to determine if a thread has been schedule.
;      Code elsewhere in the system that reads this variable, set next
;      thread, executes a memory barrier, then reads the variable.
;

CheckNextThread:                        ;

   lock or      byte ptr PbIdleHalt[rbx], 1 ; set idle halt
        cmp     qword ptr PbNextThread[rbx], 0 ; check if thread selected

ifdef NT_UP

        je      KiIL10                  ; if e, no thread selected

else

        je      KiIL50                  ; if e, no thread selected

endif

        and     byte ptr PbIdleHalt[rbx], 0 ; clear idle halt
        sti                             ; enable interrupts

        mov     ecx, SYNCH_LEVEL        ; set IRQL to synchronization level

        RaiseIrql                       ;

;
; set context swap busy for the idle thread and acquire the PRCB Lock.
;

        mov     rdi, PbIdleThread[rbx]  ; get idle thread address

ifndef NT_UP

        mov     byte ptr ThSwapBusy[rdi], 1 ; set context swap busy

        AcquireSpinLock PbPrcbLock[rbx] ; acquire current PRCB Lock

endif

        mov     rsi, PbNextThread[rbx]  ; set next thread address

;
; If a thread had been scheduled for this processor, but was removed from
; eligibility (e.g., an affinity change), then the new thread could be the
; idle thread.
;

ifndef NT_UP

        cmp     rsi, rdi                ; check if swap from idle to idle
        je      short KiIL40            ; if eq, idle to idle

endif

        and     qword ptr PbNextThread[rbx], 0 ; clear next thread address
        mov     PbCurrentThread[rbx], rsi ; set current thread address
        mov     byte ptr ThState[rsi], Running ; set new thread state

;
; Clear idle schedule since a new thread has been selected for execution on
; this processor and release the PRCB lock.
;

ifndef NT_UP

        and     byte ptr PbIdleSchedule[rbx], 0 ; clear idle schedule
        and     qword ptr PbPrcbLock[rbx], 0 ; release current PRCB lock

endif

;
; Switch context to new thread.
;

KiIL30: mov     ecx, APC_LEVEL          ; set APC bypass disable
        call    SwapContext             ; swap context to next thread

ifndef NT_UP

        mov     ecx, DISPATCH_LEVEL     ; set IRQL to dispatch level

        SetIrql                         ;

endif

        jmp     KiIL20                  ; loop

;
; The new thread is the Idle thread (same as old thread).  This can happen
; rarely when a thread scheduled for this processor is made unable to run
; on this processor. As this processor has again been marked idle, other
; processors may unconditionally assign new threads to this processor.
;

ifndef NT_UP

KiIL40: and     qword ptr PbNextThread[rbx], 0 ; clear next thread
        and     qword ptr PbPrcbLock[rbx], 0 ; release current PRCB lock
        and     byte ptr ThSwapBusy[rdi], 0 ; set context swap idle 
        jmp     KiIL20                  ;

;
; Call idle schedule if requested.
;

KiIL50: cmp     byte ptr PbIdleSchedule[rbx], 0 ; check if idle schedule
        je      KiIL10                  ; if e, idle schedule not requested
        and     byte ptr PbIdleHalt[rbx], 0 ; clear idle halt
        sti                             ; enable interrupts
        mov     rcx, rbx                ; pass current PRCB address
        call    KiIdleSchedule          ; attempt to schedule thread
        test    rax, rax                ; test if new thread schedule
        mov     rsi, rax                ; set new thread address
        mov     rdi, PbIdleThread[rbx]  ; get idle thread address
        jnz     KiIL30                  ; if nz, new thread scheduled
        jmp     KiIL20                  ;

endif

        NESTED_END KiIdleLoop, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\flushtb.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    flushtb.c

Abstract:

    This module implements machine dependent functions to flush the TB
    for an AMD64 system.

--*/

#include "ki.h"

VOID
KxFlushEntireTb (
    VOID
    )

/*++

Routine Description:

    This function flushes the entire translation buffer (TB) on all
    processors in the host configuration.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

#if !defined(NT_UP)

    PKAFFINITY Barrier;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

#endif

    //
    // Raise IRQL to SYNCH level and set TB flush time stamp busy.
    //
    // Send request to target processors, if any, flush the current TB, and
    // wait for the IPI request barrier.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
    KiSetTbFlushTimeStampBusy();
    if (TargetProcessors != 0) {
        Barrier = KiIpiSendRequest(TargetProcessors, 0, 0, IPI_FLUSH_ALL);
        KeFlushCurrentTb();
        KiIpiWaitForRequestBarrier(Barrier);

    } else {
        KeFlushCurrentTb();
    }

#else

    KeFlushCurrentTb();

#endif

    //
    // Clear the TB flush time stamp busy and lower IRQL to its previous value.
    //

    KiClearTbFlushTimeStampBusy();
    KeLowerIrql(OldIrql);
    return;
}

#if !defined(NT_UP)

VOID
KeFlushProcessTb (
    VOID
    )

/*++

Routine Description:

    This function flushes the non-global translation buffer on all processors
    that are currently running threads which are child of the current process.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKAFFINITY Barrier;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors, disable context switching,
    // and send the flush entire parameters to the target processors,
    // if any, for execution.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    Prcb = KeGetCurrentPrcb();
    Process = Prcb->CurrentThread->ApcState.Process;
    TargetProcessors = Process->ActiveProcessors;
    TargetProcessors &= ~Prcb->SetMember;

    //
    // Send request to target processors, if any, flush the current process
    // TB, and wait for the IPI request barrier.
    //

    if (TargetProcessors != 0) {
        Barrier = KiIpiSendRequest(TargetProcessors, 0, 0, IPI_FLUSH_PROCESS);
        KiFlushProcessTb();
        KiIpiWaitForRequestBarrier(Barrier);

    } else {
        KiFlushProcessTb();
    }

    //
    // Lower IRQL to its previous value.
    //

    KeLowerIrql(OldIrql);
    return;
}

VOID
KeFlushMultipleTb (
    IN ULONG Number,
    IN PVOID *Virtual,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes multiple entries from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a multiple entries from
    the translation buffer on all processors in the host configuration.

Arguments:

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    PKAFFINITY Barrier;
    PVOID *End;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    ASSERT((Number != 0) && (Number <= FLUSH_MULTIPLE_MAXIMUM));

    //
    // Compute target set of processors.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    Prcb = KeGetCurrentPrcb();
    if (AllProcessors != FALSE) {
        TargetProcessors = KeActiveProcessors;

    } else {
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    //
    // Send request to target processors, if any, flush multiple entries in
    // current TB, and wait for the IPI request barrier.
    //

    End = Virtual + Number;
    TargetProcessors &= ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        Barrier = KiIpiSendRequest(TargetProcessors,
                                   (LONG64)Virtual,
                                   Number,
                                   IPI_FLUSH_MULTIPLE);

        do {
            KiFlushSingleTb(*Virtual);
            Virtual += 1;
        } while (Virtual < End);

        KiIpiWaitForRequestBarrier(Barrier);

    } else {
        do {
            KiFlushSingleTb(*Virtual);
            Virtual += 1;
        } while (Virtual < End);
    }

    //
    // Lower IRQL to its previous value.
    //

    KeLowerIrql(OldIrql);
    return;
}

VOID
FASTCALL
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes a single entry from translation buffer (TB)
    on all processors that are currently running threads which are
    children of the current process.

Arguments:

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    PKAFFINITY Barrier;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors and send the flush single
    // parameters to the target processors, if any, for execution.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    Prcb = KeGetCurrentPrcb();
    if (AllProcessors != FALSE) {
        TargetProcessors = KeActiveProcessors;

    } else {
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    //
    // Send request to target processors, if any, flush the single entry from
    // the current TB, and wait for the IPI request barrier.
    //

    TargetProcessors &= ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        Barrier = KiIpiSendRequest(TargetProcessors, (LONG64)Virtual, 0, IPI_FLUSH_SINGLE);
        KiFlushSingleTb(Virtual);
        KiIpiWaitForRequestBarrier(Barrier);

    } else {
        KiFlushSingleTb(Virtual);
    }

    //
    // Lower IRQL to its previous value.
    //

    KeLowerIrql(OldIrql);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\intipi.asm ===
title  "Interprocessor Interrupts"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   intipi.asm
;
; Abstract:
;
;   This module implements the code necessary to process interprocessor
;   interrupt requests.
;
;--

include ksamd64.inc

        extern  ExpInterlockedPopEntrySListEnd:proc
        extern  ExpInterlockedPopEntrySListResume:proc
        extern  KiCheckForSListAddress:proc
        extern  KiDpcInterruptBypass:proc
        extern  KiInitiateUserApc:proc
        extern  KiIdleSummary:qword
        extern  KiIpiProcessRequests:proc
        extern  KiRestoreDebugRegisterState:proc
        extern  KiSaveDebugRegisterState:proc
        extern  __imp_HalRequestSoftwareInterrupt:qword

        subttl  "Interprocess Interrupt Service Routine"
;++
;
; VOID
; KiIpiInterrupt (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered as the result of an interprocessor interrupt at
;   IPI level. Its function is to process all interprocessor requests.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiIpiInterrupt, _TEXT$00

        .pushframe                      ; mark machine frame

        alloc_stack 8                   ; allocate dummy vector
        push_reg rbp                    ; save nonvolatile register

        GENERATE_INTERRUPT_FRAME <>, <Direct> ; generate interrupt frame

        mov     ecx, IPI_LEVEL          ; set new IRQL level

	ENTER_INTERRUPT <NoEoi>         ; raise IRQL and enable interrupts

;
; Process all interprocessor requests.
;

        call    KiIpiProcessRequests    ; process interprocessor requests

        EXIT_INTERRUPT <>, <>, <Direct> ; do EOI, lower IRQL and restore state

        NESTED_END KiIpiInterrupt, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\ipi.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ipi.c

Abstract:

    This module implements AMD64 specific interprocessor interrupt
    routines.

--*/

#include "ki.h"

VOID
KiRestoreProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function restores the processor state to the specified exception
    and trap frames, and restores the processor control state.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    PKPRCB Prcb;
    KPROCESSOR_MODE PreviousMode;

    //
    // Get the address of the current processor block, move the specified
    // register state from the processor context structure to the specified
    // trap and exception frames, and restore the processor control state.
    //

    if ((TrapFrame->SegCs & MODE_MASK) != 0) {
        PreviousMode = UserMode;
    } else {
        PreviousMode = KernelMode;
    }

    Prcb = KeGetCurrentPrcb();
    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &Prcb->ProcessorState.ContextFrame,
                       CONTEXT_FULL,
                       PreviousMode);

    KiRestoreProcessorControlState(&Prcb->ProcessorState);

#else

    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);

#endif

    return;
}

VOID
KiSaveProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function saves the processor state from the specified exception
    and trap frames, and saves the processor control state.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    PKPRCB Prcb;

    //
    // Get the address of the current processor block, move the specified
    // register state from specified trap and exception frames to the current
    // processor context structure, and save the processor control state.
    //

    Prcb = KeGetCurrentPrcb();
    Prcb->ProcessorState.ContextFrame.ContextFlags = CONTEXT_FULL;
    KeContextFromKframes(TrapFrame,
                         ExceptionFrame,
                         &Prcb->ProcessorState.ContextFrame);

    KiSaveProcessorControlState(&Prcb->ProcessorState);

#else

    UNREFERENCED_PARAMETER(TrapFrame);
    UNREFERENCED_PARAMETER(ExceptionFrame);

#endif

    return;
}

DECLSPEC_NOINLINE
VOID
KiIpiProcessRequests (
    VOID
    )

/*++

Routine Description:

    This routine processes interprocessor requests and returns a summary
    of the requests that were processed.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    PVOID *End;
    ULONG64 Number;
    PKPRCB Packet;
    PKPRCB Prcb;
    ULONG Processor;
    REQUEST_SUMMARY Request;
    PREQUEST_MAILBOX RequestMailbox;
    PKREQUEST_PACKET RequestPacket;
    LONG64 SetMember;
    PKPRCB Source;
    KAFFINITY SummarySet;
    KAFFINITY TargetSet;
    PVOID *Virtual;

    //
    // Loop until the sender summary is zero.
    //

    Prcb = KeGetCurrentPrcb();
    TargetSet = ReadForWriteAccess(&Prcb->SenderSummary);
    SetMember = Prcb->SetMember;
    while (TargetSet != 0) {
        SummarySet = TargetSet;
        BitScanForward64(&Processor, SummarySet);
        do {
            Source = KiProcessorBlock[Processor];
            RequestMailbox = &Prcb->RequestMailbox[Processor];
            Request.Summary = RequestMailbox->RequestSummary;

            //
            // If the request type is flush multiple immediate, flush process,
            // flush single, or flush all, then packet done can be signaled
            // before processing the request. Otherwise, the request type must
            // be a packet request, a cache invalidate, or a flush multiple
            //

            if (Request.IpiRequest <= IPI_FLUSH_ALL) {

                //
                // If the synchronization type is target set, then the IPI was
                // only between two processors and target set should be used
                // for synchronization. Otherwise, packet barrier is used for
                // synchronization.
                //
    
                if (Request.IpiSynchType == 0) {
                    if (SetMember == InterlockedXor64((PLONG64)&Source->TargetSet,
                                                      SetMember)) {
    
                        Source->PacketBarrier = 0;
                    }
    
                } else {
                    Source->TargetSet = 0;
                }

                if (Request.IpiRequest == IPI_FLUSH_MULTIPLE_IMMEDIATE) {
                    Number = Request.Count;
                    Virtual = &RequestMailbox->Virtual[0];
                    End = Virtual + Number;
                    do {
                        KiFlushSingleTb(*Virtual);
                        Virtual += 1;
                    } while (Virtual < End);

                } else if (Request.IpiRequest == IPI_FLUSH_PROCESS) {
                    KiFlushProcessTb();
        
                } else if (Request.IpiRequest == IPI_FLUSH_SINGLE) {
                    KiFlushSingleTb((PVOID)Request.Parameter);
        
                } else {

                    ASSERT(Request.IpiRequest == IPI_FLUSH_ALL);

                    KeFlushCurrentTb();
                }

            } else {

                //
                // If the request type is packet ready, then call the worker
                // function. Otherwise, the request must be either a flush
                // multiple or a cache invalidate.
                //
        
                if (Request.IpiRequest == IPI_PACKET_READY) {
                    Packet = Source;
                    if (Request.IpiSynchType != 0) {
                        Packet = (PKPRCB)((ULONG64)Source + 1);
                    }
    
                    RequestPacket = (PKREQUEST_PACKET)&RequestMailbox->RequestPacket;
                    (RequestPacket->WorkerRoutine)((PKIPI_CONTEXT)Packet,
                                                   RequestPacket->CurrentPacket[0],
                                                   RequestPacket->CurrentPacket[1],
                                                   RequestPacket->CurrentPacket[2]);
        
                } else {
                    if (Request.IpiRequest == IPI_FLUSH_MULTIPLE) {
                        Number = Request.Count;
                        Virtual = (PVOID *)Request.Parameter;
                        End = Virtual + Number;
                        do {
                            KiFlushSingleTb(*Virtual);
                            Virtual += 1;
                        } while (Virtual < End);

                    } else if (Request.IpiRequest == IPI_INVALIDATE_ALL) {
                        WritebackInvalidate();

                    } else {

                        ASSERT(FALSE);

                    }
        
                    //
                    // If the synchronization type is target set, then the IPI was
                    // only between two processors and target set should be used
                    // for synchronization. Otherwise, packet barrier is used for
                    // synchronization.
                    //
        
                    if (Request.IpiSynchType == 0) {
                        if (SetMember == InterlockedXor64((PLONG64)&Source->TargetSet,
                                                          SetMember)) {
        
                            Source->PacketBarrier = 0;
                        }
        
                    } else {
                        Source->TargetSet = 0;
                    }
                }
            }
            
            SummarySet ^= AFFINITY_MASK(Processor);
        } while (BitScanForward64(&Processor, SummarySet) != FALSE);

        //
        // Clear target set in sender summary.
        //

        TargetSet = 
            InterlockedExchangeAdd64((LONG64 volatile *)&Prcb->SenderSummary,
                                     -(LONG64)TargetSet) - TargetSet;
    }

#endif

    return;
}

DECLSPEC_NOINLINE
PKAFFINITY
KiIpiSendRequest (
    IN KAFFINITY TargetSet,
    IN ULONG64 Parameter,
    IN ULONG64 Count,
    IN ULONG64 RequestType
    )

/*++

Routine Description:

    This routine executes the specified immediate request on the specified
    set of processors.

    N.B. This function MUST be called from a non-context switchable state.

Arguments:

   TargetProcessors - Supplies the set of processors on which the specfied
       operation is to be executed.

   Parameter - Supplies the parameter data that will be packed into the
       request summary.

   Count - Supplies the count data that will be packed into the request summary.

   RequestType - Supplies the type of immediate request.

Return Value:

    The address of the appropriate request barrier is returned as the function
    value.

--*/

{

#if !defined(NT_UP)

    PKAFFINITY Barrier;
    PKPRCB Destination;
    ULONG Number;
    KAFFINITY PacketTargetSet;
    PKPRCB Prcb;
    ULONG Processor;
    PREQUEST_MAILBOX RequestMailbox;
    KAFFINITY SetMember;
    PVOID *Start;
    KAFFINITY SummarySet;
    KAFFINITY TargetMember;
    REQUEST_SUMMARY Template;
    PVOID *Virtual;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    //
    // Initialize request template.
    //

    Prcb = KeGetCurrentPrcb();
    Template.Summary = 0;
    Template.IpiRequest = RequestType;
    Template.Count = Count;
    Template.Parameter = Parameter;

    //
    // If the target set contains one and only one processor, then use the
    // target set for signal done synchronization. Otherwise, use packet
    // barrier for signal done synchronization.
    //

    Prcb->TargetSet = TargetSet;
    if ((TargetSet & (TargetSet - 1)) == 0) {
        Template.IpiSynchType = TRUE;
        Barrier = (PKAFFINITY)&Prcb->TargetSet;

    } else {
        Prcb->PacketBarrier = 1;
        Barrier = (PKAFFINITY)&Prcb->PacketBarrier;
    }

    //
    // Loop through the target set of processors and set the request summary.
    // If a target processor is already processing a request, then remove
    // that processor from the target set of processor that will be sent an
    // interprocessor interrupt.
    //
    // N.B. It is guaranteed that there is at least one bit set in the target
    //      set.
    //

    Number = Prcb->Number;
    SetMember = Prcb->SetMember;
    SummarySet = TargetSet;
    PacketTargetSet = TargetSet;
    BitScanForward64(&Processor, SummarySet);
    do {
        Destination = KiProcessorBlock[Processor];
        PrefetchForWrite(&Destination->SenderSummary);
        RequestMailbox = &Destination->RequestMailbox[Number];
        PrefetchForWrite(RequestMailbox);
        TargetMember = AFFINITY_MASK(Processor);

        //
        // Make sure that processing of the last IPI is complete before sending
        // another IPI to the same processor.
        // 

        while ((Destination->SenderSummary & SetMember) != 0) {
            KeYieldProcessor();
        }

        //
        // If the request type is flush multiple and the flush entries will
        // fit in the mailbox, then copy the virtual address array to the
        // destination mailbox and change the request type to flush immediate.
        //
        // If the request type is packet ready, then copy the packet to the
        // destination mailbox.
        //

        if (RequestType == IPI_FLUSH_MULTIPLE) {
            Virtual = &RequestMailbox->Virtual[0];
            Start = (PVOID *)Parameter;
            switch (Count) {

                //
                // Copy of up to seven virtual addresses and a conversion of
                // the request type to flush multiple immediate.
                //

            case 7:
                Virtual[6] = Start[6];
            case 6:
                Virtual[5] = Start[5];
            case 5:
                Virtual[4] = Start[4];
            case 4:
                Virtual[3] = Start[3];
            case 3:
                Virtual[2] = Start[2];
            case 2:
                Virtual[1] = Start[1];
            case 1:
                Virtual[0] = Start[0];
                Template.IpiRequest = IPI_FLUSH_MULTIPLE_IMMEDIATE;
                break;
            }

        } else if (RequestType == IPI_PACKET_READY) {
            RequestMailbox->RequestPacket = *(PKREQUEST_PACKET)Parameter;
        }

        RequestMailbox->RequestSummary = Template.Summary;
        if (InterlockedExchangeAdd64((LONG64 volatile *)&Destination->SenderSummary,
                                     SetMember) != 0) {

            TargetSet ^= TargetMember;
        }

        SummarySet ^= TargetMember;
    } while (BitScanForward64(&Processor, SummarySet) != FALSE);

    //
    // Request interprocessor interrupts on the remaining target set of
    // processors.
    //
    //
    // N.B. For packet sends, there exists a potential deadlock situation
    //      unless an IPI is sent to the original set of target processors.
    //      The deadlock arises from the fact that the targets will spin in
    //      their IPI routines.
    //

    if (RequestType == IPI_PACKET_READY) {
        TargetSet = PacketTargetSet;
    }

    if (TargetSet != 0) {
        HalRequestIpi(TargetSet);
    }

    return Barrier;

#else

    UNREFERENCED_PARAMETER(TargetSet);
    UNREFERENCED_PARAMETER(Parameter);
    UNREFERENCED_PARAMETER(Count);
    UNREFERENCED_PARAMETER(RequestType);

    return NULL;

#endif

}

VOID
KiIpiSendPacket (
    IN KAFFINITY TargetSet,
    IN PKIPI_WORKER WorkerFunction,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This routine executes the specified worker function on the specified
    set of processors.

    N.B. This function MUST be called from a non-context switchable state.

Arguments:

   TargetProcessors - Supplies the set of processors on which the specfied
       operation is to be executed.

   WorkerFunction  - Supplies the address of the worker function.

   Parameter1 - Parameter3 - Supplies worker function specific parameters.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    KREQUEST_PACKET RequestPacket;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    //
    // Initialize the worker packet information.
    //

    RequestPacket.CurrentPacket[0] = Parameter1;
    RequestPacket.CurrentPacket[1] = Parameter2;
    RequestPacket.CurrentPacket[2] = Parameter3;
    RequestPacket.WorkerRoutine = WorkerFunction;

    //
    // Send request.
    //

    KiIpiSendRequest(TargetSet, (ULONG64)&RequestPacket, 0, IPI_PACKET_READY);

#else

    UNREFERENCED_PARAMETER(TargetSet);
    UNREFERENCED_PARAMETER(WorkerFunction);
    UNREFERENCED_PARAMETER(Parameter1);
    UNREFERENCED_PARAMETER(Parameter2);
    UNREFERENCED_PARAMETER(Parameter3);

#endif

    return;
}

VOID
KiIpiSignalPacketDone (
    IN PKIPI_CONTEXT SignalDone
    )

/*++

Routine Description:

    This routine signals that a processor has completed a packet by clearing
    the calling processor's set member of the requesting processor's packet.

Arguments:

    SignalDone - Supplies a pointer to the processor block of the sending
        processor.

Return Value:

     None.

--*/

{

#if !defined(NT_UP)

    LONG64 SetMember;
    PKPRCB TargetPrcb;


    //
    // If the low bit of signal is set, then use target set to notify the
    // sender that the operation is complete on the current processor.
    // Otherwise, use packet barrier to notify the sender that the operation
    // is complete on the current processor.
    //

    if (((ULONG64)SignalDone & 1) == 0) {

        SetMember = KeGetCurrentPrcb()->SetMember;
        TargetPrcb = (PKPRCB)SignalDone;
        if (SetMember == InterlockedXor64((PLONG64)&TargetPrcb->TargetSet,
                                          SetMember)) {

            TargetPrcb->PacketBarrier = 0;
        }

    } else {
        TargetPrcb = (PKPRCB)((ULONG64)SignalDone - 1);
        TargetPrcb->TargetSet = 0;
    }

#else

    UNREFERENCED_PARAMETER(SignalDone);

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\kiamd64.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    kiamd64.h

Abstract:

    This module contains the private (internal) platform specific header file
    for the kernel.

--*/

#if !defined(_KIAMD64_)
#define _KIAMD64_

#pragma warning(disable:4213)   // nonstandard extension : cast on l-value

//
// Define IPI request summary structure.
//
// N.B. The numeric order of the request definitions is important.
//

#define IPI_FLUSH_MULTIPLE_IMMEDIATE 1
#define IPI_FLUSH_PROCESS 2
#define IPI_FLUSH_SINGLE 3
#define IPI_FLUSH_ALL 4
#define IPI_FLUSH_MULTIPLE 5
#define IPI_PACKET_READY 6
#define IPI_INVALIDATE_ALL 7

#define IPI_REQUEST_SUMMARY 0xf

typedef struct _REQUEST_SUMMARY {
    union {
        struct {
            ULONG64 IpiRequest : 4;
            ULONG64 Reserved1 : 3;
            ULONG64 IpiSynchType : 1;
            ULONG64 Count : 8;
            LONG64 Parameter : 48;
        };

        LONG64 Summary;
    };

} REQUEST_SUMMARY, *PREQUEST_SUMMARY;

//
// Define get current ready summary macro.
//

#define KiGetCurrentReadySummary()                                           \
    __readgsdword(FIELD_OFFSET(KPCR, Prcb.ReadySummary))

//
// Define function prototypes.
//

VOID
KiAcquireSpinLockCheckForFreeze (
    IN PKSPIN_LOCK SpinLock,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KiInitializeBootStructures (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    );

extern KIRQL KiProfileIrql;

#if !defined(NT_UP)

extern BOOLEAN KiResumeForReboot;

#endif

FORCEINLINE
ULONG64
KiGetActualStackLimit (
    IN PKTHREAD Thread
    )

{

    PKERNEL_STACK_CONTROL StackControl;

    StackControl = (PKERNEL_STACK_CONTROL)Thread->InitialStack;
    return StackControl->Current.ActualLimit;
}

//
// Define function prototypes for trap processing functions.
//

VOID
KiDivideErrorFault (
    VOID
    );

VOID
KiDebugTrapOrFault (
    VOID
    );

VOID
KiNmiInterrupt (
    VOID
    );

VOID
KiBreakpointTrap (
    VOID
    );

VOID
KiOverflowTrap (
    VOID
    );

VOID
KiBoundFault (
    VOID
    );

VOID
KiInvalidOpcodeFault (
    VOID
    );

VOID
KiNpxNotAvailableFault (
    VOID
    );

VOID
KiDoubleFaultAbort (
    VOID
    );

VOID
KiNpxSegmentOverrunAbort (
    VOID
    );

VOID
KiInvalidTssFault (
    VOID
    );

VOID
KiRaiseAssertion (
    VOID
    );

VOID
KiSaveInitialProcessorControlState (
    IN PKPROCESSOR_STATE ProcessorState
    );

VOID
KiSegmentNotPresentFault (
    VOID
    );

VOID
KiSetPageAttributesTable (
    VOID
    );

VOID
KiStackFault (
    VOID
    );

VOID
KiGeneralProtectionFault (
    VOID
    );

VOID
KiPageFault (
    VOID
    );

VOID
KiFloatingErrorFault (
    VOID
    );

VOID
KiAlignmentFault (
    VOID
    );

VOID
KiMcheckAbort (
    VOID
    );

VOID
KiXmmException (
    VOID
    );

VOID
KiApcInterrupt (
    VOID
    );

VOID
KiDebugServiceTrap (
    VOID
    );

ULONG
KiDivide6432 (
    ULONG64 Dividend,
    ULONG Divisor
    );

VOID
KiDpcInterrupt (
    VOID
    );

VOID
KiFreezeInterrupt (
    VOID
    );

VOID
KiIpiInterrupt (
    VOID
    );

VOID
KiIpiProcessRequests (
    VOID
    );

PKAFFINITY
KiIpiSendRequest (
    IN KAFFINITY TargetSet,
    IN ULONG64 Parameter,
    IN ULONG64 Count,
    IN ULONG64 RequestType
    );

__forceinline
VOID
KiIpiWaitForRequestBarrier (
    KAFFINITY volatile *Barrier
    )

/*++

Routine Description:

    This function waits until the specified barrier is set to zero.

Arguments:

    Barrier - Supplies a pointer to a request barrier.

Return Value:

    None.

--*/

{

    //
    // Wait until the request barrier is zero before proceeding.
    //

    while (*Barrier != 0) {
        KeYieldProcessor();
    }

    return;
}

VOID
KiSecondaryClockInterrupt (
    VOID
    );

VOID
KiSystemCall32 (
    VOID
    );

VOID
KiSystemCall64 (
    VOID
    );

VOID
KiInterruptDispatchLBControl (
    VOID
    );

VOID
KiInterruptDispatchNoLock (
    VOID
    );

VOID
KiInterruptDispatchNoEOI (
    VOID
    );

VOID
KiWaitForReboot (
    VOID
    );

__forceinline
BOOLEAN
KiSwapProcess (
    IN PKPROCESS NewProcess,
    IN PKPROCESS OldProcess
    )

/*++

Routine Description:

    This function swaps the address space to another process by flushing the
    the translation buffer and establishings a new directory table base. It
    also swaps the I/O permission map to the new process.

    N.B. There is code similar to this code in swap context.

    N.B. This code is executed at DPC level.

Arguments:

    NewProcess - Supplies a pointer to the new process object.

    Oldprocess - Supplies a pointer to the old process object.

Return Value:

    None.

--*/

{

    //
    // Clear the processor bit in the old process.
    //

#if !defined(NT_UP)

    PKPRCB Prcb;
    KAFFINITY SetMember;

    Prcb = KeGetCurrentPrcb();
    SetMember = Prcb->SetMember;
    InterlockedXor64((LONG64 volatile *)&OldProcess->ActiveProcessors, SetMember);

    ASSERT((OldProcess->ActiveProcessors & SetMember) == 0);

    //
    // Set the processor bit in the new process.
    //

    InterlockedXor64((LONG64 volatile *)&NewProcess->ActiveProcessors, SetMember);

    ASSERT((NewProcess->ActiveProcessors & SetMember) != 0);

#endif

    //
    // Load the new directory table base.
    //

    WriteCR3(NewProcess->DirectoryTableBase[0]);

#if defined(NT_UP)

    UNREFERENCED_PARAMETER(OldProcess);

#endif // !defined(NT_UP)

    return TRUE;
}

#if !defined(NT_UP)

FORCEINLINE
BOOLEAN
KiCheckForFreezeExecution (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function checks for a pending freeze execution request from
    another processor.  If such a request is pending then execution is
    frozen.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;

    Prcb = KeGetCurrentPrcb();
    if (Prcb->IpiFrozen == TARGET_FREEZE) {
        KiFreezeTargetExecution(TrapFrame, ExceptionFrame);
        if (KiResumeForReboot != FALSE) {

            //
            // If previous mode was user, then set the code and stack
            // selectors and the stack pointer to valid kernel values.
            // 

            if (TrapFrame->SegCs != KGDT64_R0_CODE) {
                TrapFrame->SegCs = KGDT64_R0_CODE;
                TrapFrame->SegSs = KGDT64_R0_DATA;
                TrapFrame->Rsp = Prcb->RspBase;
            }

            TrapFrame->Rip = (ULONG64)KiWaitForReboot;

        }
        return TRUE;

    } else {
        return FALSE;
    }
}

#endif

//
// Define thread startup routine prototypes.
//

VOID
KiStartSystemThread (
    VOID
    );

VOID
KiStartUserThread (
    VOID
    );

VOID
KiStartUserThreadReturn (
    VOID
    );

PXMM_SAVE_AREA32
KxContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextRecord,
    IN ULONG ContextFlags,
    IN KPROCESSOR_MODE PreviousMode
    );

//
// Define unexpected interrupt structure and table.
//

#pragma pack(1)
typedef DECLSPEC_ALIGN(16)  struct _UNEXPECTED_INTERRUPT {
    UCHAR PushImmOp;
    ULONG PushImm;
    UCHAR PushRbp;
    UCHAR JmpOp;
    LONG JmpOffset;
} UNEXPECTED_INTERRUPT, *PUNEXPECTED_INTERRUPT;
#pragma pack()

extern UNEXPECTED_INTERRUPT KxUnexpectedInterrupt0[256];

#define PPI_BITS    2
#define PDI_BITS    9
#define PTI_BITS    9

#define PDI_MASK    ((1 << PDI_BITS) - 1)
#define PTI_MASK    ((1 << PTI_BITS) - 1)

#define KiGetPpeIndex(va) ((((ULONG)(va)) >> PPI_SHIFT) & PPI_MASK)
#define KiGetPdeIndex(va) ((((ULONG)(va)) >> PDI_SHIFT) & PDI_MASK)
#define KiGetPteIndex(va) ((((ULONG)(va)) >> PTI_SHIFT) & PTI_MASK)

extern KSPIN_LOCK KiNMILock;
extern ULONG KeAmd64MachineType;
extern ULONG KiLogicalProcessors;
extern ULONG KiMxCsrMask;
extern ULONG KiPhysicalProcessors;
extern UCHAR KiPrefetchRetry;
extern ULONG64 KiTestDividend;

#endif // !defined(_KIAMD64_)
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\initkr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    initkr.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, the processor control
    block, and the processor control region.

--*/

#include "ki.h"
#include <kddll.h>

//
// Define default profile IRQL level.
//

KIRQL KiProfileIrql = PROFILE_LEVEL;

//
// Define the system cache flush size.
//

UCHAR KiCFlushSize = 0;

//
// Define the APIC mask, the number of logical processors per physical
// pyhsical processor, and the number of physical processors.
//

ULONG KiApicMask;
ULONG KiLogicalProcessors;
ULONG KiPhysicalProcessors;

//
// Define last branch control register MSR.
//

ULONG KeLastBranchMSR = 0;

//
// Define the MxCsr mask.
//

ULONG KiMxCsrMask = 0xFFBF;

//
// Define the prefetch retry flag. Each processor that requires prefetch
// retry will set bit 0 of prefetch retry. After all processors have been
// started, bit 7 of prefetch retry is cleared.
//
// If the end result is zero, then no processors require prefetch retry.
//

UCHAR KiPrefetchRetry = 0x80;

//
// Define the interrupt initialization data.
//
// Entries in the interrupt table must be in ascending vector # order.
//

typedef
VOID
(*KI_INTERRUPT_HANDLER) (
    VOID
    );

typedef struct _KI_INTINIT_REC {
    UCHAR Vector;
    UCHAR Dpl;
    UCHAR IstIndex;
    KI_INTERRUPT_HANDLER Handler;
} KI_INTINIT_REC, *PKI_INTINIT_REC;

#pragma data_seg("INITDATA")

KI_INTINIT_REC KiInterruptInitTable[] = {
    {0,  0, 0,             KiDivideErrorFault},
    {1,  0, 0,             KiDebugTrapOrFault},
    {2,  0, TSS_IST_NMI,   KiNmiInterrupt},
    {3,  3, 0,             KiBreakpointTrap},
    {4,  3, 0,             KiOverflowTrap},
    {5,  0, 0,             KiBoundFault},
    {6,  0, 0,             KiInvalidOpcodeFault},
    {7,  0, 0,             KiNpxNotAvailableFault},
    {8,  0, TSS_IST_PANIC, KiDoubleFaultAbort},
    {9,  0, 0,             KiNpxSegmentOverrunAbort},
    {10, 0, 0,             KiInvalidTssFault},
    {11, 0, 0,             KiSegmentNotPresentFault},
    {12, 0, 0,             KiStackFault},
    {13, 0, 0,             KiGeneralProtectionFault},
    {14, 0, 0,             KiPageFault},
    {16, 0, 0,             KiFloatingErrorFault},
    {17, 0, 0,             KiAlignmentFault},
    {18, 0, TSS_IST_MCA,   KiMcheckAbort},
    {19, 0, 0,             KiXmmException},
    {31, 0, 0,             KiApcInterrupt},
    {44, 3, 0,             KiRaiseAssertion},
    {45, 3, 0,             KiDebugServiceTrap},
    {47, 0, 0,             KiDpcInterrupt},
    {225, 0, 0,            KiIpiInterrupt},
    {0,  0, 0,             NULL}
};

#pragma data_seg()

//
// Define the unexpected interrupt array.
//

#pragma data_seg("RWEXEC")

UNEXPECTED_INTERRUPT KxUnexpectedInterrupt0[256];

#pragma data_seg()

//
// Define macro to initialize an IDT entry.
//
// KiInitializeIdtEntry (
//     IN PKIDTENTRY64 Entry,
//     IN PVOID Address,
//     IN USHORT Level
//     )
//
// Arguments:
//
//     Entry - Supplies a pointer to an IDT entry.
//
//     Address - Supplies the address of the vector routine.
//
//     Dpl - Descriptor privilege level.
//
//     Ist - Interrupt stack index.
//

#define KiInitializeIdtEntry(Entry, Address, Level, Index)                  \
    (Entry)->OffsetLow = (USHORT)((ULONG64)(Address));                      \
    (Entry)->Selector = KGDT64_R0_CODE;                                     \
    (Entry)->IstIndex = Index;                                              \
    (Entry)->Type = 0xe;                                                    \
    (Entry)->Dpl = (Level);                                                 \
    (Entry)->Present = 1;                                                   \
    (Entry)->OffsetMiddle = (USHORT)((ULONG64)(Address) >> 16);             \
    (Entry)->OffsetHigh = (ULONG)((ULONG64)(Address) >> 32)                 \

//
// Define forward referenced prototypes.
//

ULONG
KiFatalFilter (
    IN ULONG Code,
    IN PEXCEPTION_POINTERS Pointers
    );

VOID
KiSetCacheInformation (
    VOID
    );

VOID
KiSetCacheInformationAmd (
    VOID
    );
VOID
KiSetCacheInformationIntel (
    VOID
    );

VOID
KiSetCpuVendor (
    VOID
    );

VOID
KiSetFeatureBits (
    IN PKPRCB Prcb
    );

VOID
KiSetProcessorType (
    VOID
    );

#pragma alloc_text(INIT, KiFatalFilter)
#pragma alloc_text(INIT, KiInitializeBootStructures)
#pragma alloc_text(INIT, KiInitializeKernel)
#pragma alloc_text(INIT, KiInitMachineDependent)
#pragma alloc_text(INIT, KiSetCacheInformation)
#pragma alloc_text(INIT, KiSetCacheInformationAmd)
#pragma alloc_text(INIT, KiSetCacheInformationIntel)
#pragma alloc_text(INIT, KiSetCpuVendor)
#pragma alloc_text(INIT, KiSetFeatureBits)
#pragma alloc_text(INIT, KiSetProcessorType)

VOID
KeCompactServiceTable (
    IN PVOID Table,
    IN ULONG Limit,
    IN BOOLEAN Win32
    )

/*++

Routine Description:

    This function compacts the specified system service table into an array
    of 32-bit displacements with the number of arguments encoded in the low
    bits of the relative address.

Arguments:

    Table - Supplies the address of a system service table.

    Limit - Supplies the number of entries in the system service table.

    Win32 - Supplies a boolean variable that signifies whether the system
        service table is the win32k table or the kernel table.

Return Value:

    None.

--*/

{

    ULONG64 Base;
    ULONG Index;
    PULONG64 Input;
    PULONG Output;

    //
    // Copy and compact the specified system servicde table into an array
    // of relative addresses.
    //

    Base = (ULONG64)Table;
    Input = (PULONG64)Table;
    Output = (PULONG)Table;
    for (Index = 0; Index < Limit; Index += 1) {
        *Output = (ULONG)(*Input - Base);
        Input += 1;
        Output += 1;
    }

    //
    // If the specified system service table in the Win32 table, then copy
    // the status translation vector.
    //

    if (Win32 == TRUE) {
        memcpy((PUCHAR)Output, (PUCHAR)Input, Limit);
    }

    return;
}

VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function gains control after the system has been booted, but before
    the system has been completely initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    complete the initialization of the processor control block (PRCB) and
    processor control region (PCR), call the executive initialization routine,
    then return to the system startup routine. This routine is also called to
    initialize the processor specific structures when a new processor is
    brought on line.

    N.B. Kernel initialization is called with interrupts disabled at IRQL
         HIGH_LEVEL and returns with with interrupts enabled at DISPATCH_LEVEL.

Arguments:

    Process - Supplies a pointer to a control object of type process for
        the specified processor.

    Thread - Supplies a pointer to a dispatcher object of type thread for
        the specified processor.

    IdleStack - Supplies a pointer the base of the real kernel stack for
        idle thread on the specified processor.

    Prcb - Supplies a pointer to a processor control block for the specified
        processor.

    Number - Supplies the number of the processor that is being
        initialized.

    LoaderBlock - Supplies a pointer to the loader parameter block.

Return Value:

    None.


--*/

{

    ULONG ApicId;
    ULONG64 DirectoryTableBase[2];
    ULONG FeatureBits;
    LONG64 Index;
    ULONG MxCsrMask;
    PKPRCB NextPrcb;
    KIRQL OldIrql;
    PCHAR Options;
    XMM_SAVE_AREA32 XmmSaveArea;

    //
    // Set CPU vendor.
    //

    KiSetCpuVendor();

    //
    // Set processor type.
    //

    KiSetProcessorType();

    //
    // get the processor feature bits.
    //

    FeatureBits = Prcb->FeatureBits;

    //
    // Retrieve MxCsr mask, if any.
    //

    RtlZeroMemory(&XmmSaveArea, sizeof(XmmSaveArea));
    KeSaveLegacyFloatingPointState(&XmmSaveArea);

    //
    // If this is the boot processor, then enable global pages, set the page
    // attributes table, set machine check enable, set large page enable, 
    // enable debug extensions, and set multithread information. Otherwise,
    // propagate multithread information.
    //
    // N.B. This only happens on the boot processor and at a time when there
    //      can be no coherency problem. On subsequent, processors this happens
    //      during the transistion into 64-bit mode which is also at a time
    //      that there can be no coherency problems.
    //

    if (Number == 0) {

        //
        // Retrieve the loader options.
        //
        // N.B. LoadOptions was upcased by the loader.
        //

        Options = LoaderBlock->LoadOptions;

        //
        // Flush the entire TB and enable global pages.
        //
    
        KeFlushCurrentTb();
    
        //
        // Set page attributes table and flush cache.
        //
    
        KiSetPageAttributesTable();
        WritebackInvalidate();

        //
        // Parse boot options to determine desired level of no execute
        // protection.
        //
        
        SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_OPTIN;
        if (strstr(Options, "NOEXECUTE=ALWAYSON") != NULL) {
            SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_ALWAYSON;
            FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

        } else if (strstr(Options, "NOEXECUTE=OPTOUT") != NULL) {
            SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_OPTOUT;
            FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

        } else if (strstr(Options, "NOEXECUTE=OPTIN") != NULL) {
            FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

        } else if (strstr(Options, "NOEXECUTE=ALWAYSOFF") != NULL) {
            SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_ALWAYSOFF;
            FeatureBits |= KF_GLOBAL_32BIT_EXECUTE;

        } else if (strstr(Options, "NOEXECUTE") != NULL) {
            FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

        } else if (strstr(Options, "EXECUTE") != NULL) {
            SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_ALWAYSOFF;
            FeatureBits |= KF_GLOBAL_32BIT_EXECUTE;
        }

        //
        // If no execute protection is supported, then turn on no execute
        // protection for memory management. Otherwise, make sure the feature
        // bits reflect that no execute is not supported no matter what boot
        // options were specified.
        //
        // N.B. No execute protection is always enabled during processor
        //      initialization if it is present on the respective processor.
        //

        if ((FeatureBits & KF_NOEXECUTE) != 0) {
            MmPaeMask = 0x8000000000000000UI64;
            MmPaeErrMask = 0x8;
            SharedUserData->ProcessorFeatures[PF_NX_ENABLED] = TRUE;

        } else {
            FeatureBits &= ~KF_GLOBAL_32BIT_NOEXECUTE;
            FeatureBits |= KF_GLOBAL_32BIT_EXECUTE;
        }

        //
        // Set debugger extension and large page enable.
        //

        WriteCR4(ReadCR4() | CR4_DE | CR4_PSE);

        //
        // Flush the entire TB.
        //

        KeFlushCurrentTb();

        //
        // Set the multithread processor set and the multithread set master
        // for the boot processor, and set the number of logical processors
        // per physical processor.
        //

        Prcb->MultiThreadProcessorSet = Prcb->SetMember;
        Prcb->MultiThreadSetMaster = Prcb;

        //
        // Derive the appropriate MxCsr mask for processor zero.
        //

        if (XmmSaveArea.MxCsr_Mask != 0) {
            KiMxCsrMask = XmmSaveArea.MxCsr_Mask;

        } else {
            KiMxCsrMask = 0x0000FFBF;
        }

        //
        // Compact the system service table.
        //

        KeCompactServiceTable(&KiServiceTable[0], KiServiceLimit, FALSE);

    } else {

        //
        // If the system is not a multithread system, then initialize the
        // multithread processor set and multithread set master. Otherwise,
        // propagate multithread set information.
        //

        if (KiLogicalProcessors == 1) {
            Prcb->MultiThreadProcessorSet = Prcb->SetMember;
            Prcb->MultiThreadSetMaster = Prcb;
            KiPhysicalProcessors += 1;

        } else {
            ApicId = Prcb->InitialApicId & KiApicMask;
            for (Index = 0; Index < (LONG)KeNumberProcessors; Index += 1) {
                NextPrcb = KiProcessorBlock[Index];
                if ((NextPrcb->InitialApicId & KiApicMask) == ApicId) {
                    NextPrcb->MultiThreadProcessorSet |= Prcb->SetMember;
                    Prcb->MultiThreadSetMaster = NextPrcb->MultiThreadSetMaster;
                }
            }

            if (Prcb->MultiThreadSetMaster == NULL) {
                Prcb->MultiThreadProcessorSet = Prcb->SetMember;
                Prcb->MultiThreadSetMaster = Prcb;
                KiPhysicalProcessors += 1;

            } else {
                NextPrcb = Prcb->MultiThreadSetMaster;
                Prcb->MultiThreadProcessorSet = NextPrcb->MultiThreadProcessorSet;
            }
        }
    }

    //
    // set processor cache size information.
    //

    KiSetCacheInformation();

    //
    // Initialize power state information.
    //

    PoInitializePrcb(Prcb);

    //
    // If the initial processor is being initialized, then initialize the
    // per system data structures. Otherwise, check for a valid system.
    //

    if (Number == 0) {

        //
        // Set the default node for the boot processor.
        //

        KeNodeBlock[0] = &KiNode0;
        Prcb->ParentNode = KeNodeBlock[0];
        KiNode0.ProcessorMask = 1;
        KiNode0.NodeNumber = 0;

        //
        // Initialize the node block array with pointers to temporary node
        // blocks to be used during initialization.
        //

#if !defined(NT_UP)

        for (Index = 1; Index < MAXIMUM_CCNUMA_NODES; Index += 1) {
            KeNodeBlock[Index] = &KiNodeInit[Index];
            KeNodeBlock[Index]->NodeNumber = (UCHAR)Index;
        }

#endif

        //
        // Set global architecture and feature information.
        //

        KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_AMD64;
        KeProcessorLevel = (USHORT)Prcb->CpuType;
        KeProcessorRevision = Prcb->CpuStep;
        KeFeatureBits = FeatureBits;
        KiCFlushSize = Prcb->CFlushSize;

        //
        // Lower IRQL to APC level.
        //

        KeLowerIrql(APC_LEVEL);

        //
        // Initialize kernel internal spinlocks
        //

        KeInitializeSpinLock(&KiFreezeExecutionLock);

        //
        // Performance architecture independent initialization.
        //

        KiInitSystem();

        //
        // Initialize idle thread process object and then set:
        //
        //  1. the process quantum.
        //

        DirectoryTableBase[0] = 0;
        DirectoryTableBase[1] = 0;
        InitializeListHead(&KiProcessListHead);
        KeInitializeProcess(Process,
                            (KPRIORITY)0,
                            (KAFFINITY)(-1),
                            &DirectoryTableBase[0],
                            TRUE);

        Process->QuantumReset = MAXCHAR;

    } else {

        //
        // Derive the appropriate MxCsr mask for this processor.
        //

        if (XmmSaveArea.MxCsr_Mask != 0) {
            MxCsrMask = XmmSaveArea.MxCsr_Mask;

        } else {
            MxCsrMask = 0x0000FFBF;
        }

        //
        // If the CPU feature bits are not identical or the number of logical
        // processors per physical processors are not identical, then bugcheck.
        //

        if ((FeatureBits != (KeFeatureBits & ~(KF_GLOBAL_32BIT_NOEXECUTE | KF_GLOBAL_32BIT_EXECUTE))) ||
            (MxCsrMask != KiMxCsrMask) ||
            (KiCFlushSize != Prcb->CFlushSize) || 
            (KiLogicalProcessors != Prcb->LogicalProcessorsPerPhysicalProcessor)) {

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED,
                         (ULONG64)FeatureBits,
                         (ULONG64)KeFeatureBits,
                         0,
                         0);
        }

        //
        // Lower IRQL to DISPATCH level.
        //

        KeLowerIrql(DISPATCH_LEVEL);
    }

    //
    // Set global processor features.
    //

    SharedUserData->TestRetInstruction = 0xc3;
    SharedUserData->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_MMX_INSTRUCTIONS_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_RDTSC_INSTRUCTION_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] = TRUE;
    SharedUserData->ProcessorFeatures[PF_XMMI64_INSTRUCTIONS_AVAILABLE] = TRUE;
    if ((FeatureBits & KF_3DNOW) != 0) {
        SharedUserData->ProcessorFeatures[PF_3DNOW_INSTRUCTIONS_AVAILABLE] = TRUE;
    }

    //
    // Initialize idle thread object and then set:
    //
    //      1. the next processor number to the specified processor.
    //      2. the thread priority to the highest possible value.
    //      3. the state of the thread to running.
    //      4. the thread affinity to the specified processor.
    //      5. the specified member in the process active processors set.
    //

    KeInitializeThread(Thread,
                       (PVOID)((ULONG64)IdleStack),
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       Process);

    Thread->NextProcessor = Number;
    Thread->Priority = HIGH_PRIORITY;
    Thread->State = Running;
    Thread->Affinity = AFFINITY_MASK(Number);
    Thread->WaitIrql = DISPATCH_LEVEL;
    Process->ActiveProcessors |= AFFINITY_MASK(Number);

    //
    // Call the executive initialization routine.
    //

    try {
        ExpInitializeExecutive(Number, LoaderBlock);

    } except(KiFatalFilter(GetExceptionCode(), GetExceptionInformation())) {
        NOTHING;
    }

    //
    // If the initial processor is being initialized, then compute the timer
    // table reciprocal value, reset the PRCB values for the controllable DPC
    // behavior in order to reflect any registry overrides, and initialize the
    // global unwind history table.
    //

    if (Number == 0) {
        KiTimeIncrementReciprocal = KeComputeReciprocal((LONG)KeMaximumIncrement,
                                                        &KiTimeIncrementShiftCount);

        Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
        Prcb->MinimumDpcRate = KiMinimumDpcRate;
        Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;
        RtlInitializeHistoryTable();
    }

    //
    // Raise IRQL to dispatch level, enable interrupts, and set the priority
    // of the idle thread to zero. This will have the effect of immediately
    // causing the phase one initialization thread to get scheduled. The idle
    // thread priority is then set of the lowest realtime priority.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    _enable();
    KeSetPriorityThread(Thread, 0);
    Thread->Priority = LOW_REALTIME_PRIORITY;

    //
    // If the current processor is a secondary processor and a thread has
    // not been selected for execution, then set the appropriate bit in the
    // idle summary.
    //

#if !defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();
    KiAcquirePrcbLock(Prcb);
    if ((Number != 0) && (Prcb->NextThread == NULL)) {
        KiIdleSummary |= AFFINITY_MASK(Number);
    }

    KiReleasePrcbLock(Prcb);
    KeLowerIrql(OldIrql);

#endif

    //
    // Signal that this processor has completed its initialization.
    //

    LoaderBlock->Prcb = (ULONG64)NULL;
    return;
}

VOID
KiInitializeBootStructures (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the boot structures for a processor. It is only
    called by the system start up code. Certain fields in the boot structures
    have already been initialized. In particular:

    The address and limit of the GDT and IDT in the PCR.

    The address of the system TSS in the PCR.

    The processor number in the PCR.

    The special registers in the PRCB.

    N.B. All uninitialized fields are zero.

Arguments:

    LoaderBlock - Supplies a pointer to the loader block that has been
        initialized for this processor.

Return Value:

    None.

--*/

{

    ULONG ApicMask;
    ULONG Bit;
    PKIDTENTRY64 IdtBase;
    ULONG64 Index;
    PKI_INTINIT_REC IntInitRec;
    LONG64 JumpOffset;
    PKPCR Pcr = KeGetPcr();
    PKPRCB Prcb = KeGetCurrentPrcb();
    UCHAR Number;
    PKTHREAD Thread;
    PKTSS64 TssBase;
    PUNEXPECTED_INTERRUPT UnexpectedInterrupt;

    //
    // Initialize the PCR major and minor version numbers.
    //

    Pcr->MajorVersion = PCR_MAJOR_VERSION;
    Pcr->MinorVersion = PCR_MINOR_VERSION;

    //
    // initialize the PRCB major and minor version numbers and build type.
    //

    Prcb->MajorVersion = PRCB_MAJOR_VERSION;
    Prcb->MinorVersion =  PRCB_MINOR_VERSION;
    Prcb->BuildType = 0;

#if DBG

    Prcb->BuildType |= PRCB_BUILD_DEBUG;

#endif

#if defined(NT_UP)

    Prcb->BuildType |= PRCB_BUILD_UNIPROCESSOR;

#endif

    //
    // Initialize the PRCB set member.
    //

    Number = Pcr->Prcb.Number;
    Prcb->SetMember = AFFINITY_MASK(Number);

    //
    // If this is processor zero, then initialize the address of the system
    // process and initial thread.
    //

    if (Number == 0) {
        LoaderBlock->Process = (ULONG64)&KiInitialProcess;
        LoaderBlock->Thread = (ULONG64)&KiInitialThread;
    }

    //
    // Initialize the PRCB scheduling thread address and the thread process
    // address.
    //

    Thread = (PVOID)LoaderBlock->Thread;
    Prcb->CurrentThread = Thread;
    Prcb->NextThread = NULL;
    Prcb->IdleThread = Thread;
    Thread->ApcState.Process = (PKPROCESS)LoaderBlock->Process;
    InitializeListHead(&Thread->ApcState.ApcListHead[KernelMode]);

    //
    // Initialize the processor block address.
    //

    KiProcessorBlock[Number] = Prcb;

    //
    // Initialize the PRCB address of the DPC stack.
    //

    Prcb->DpcStack = (PVOID)LoaderBlock->KernelStack;

    //
    // If this is processor zero, then initialize the IDT according to the
    // contents of interrupt initialization table. Otherwise, initialize the
    // secondary processor clock interrupt.
    //

    IdtBase = Pcr->IdtBase;
    if (Number == 0) {

        IntInitRec = KiInterruptInitTable;
        for (Index = 0; Index < MAXIMUM_IDTVECTOR; Index += 1) {

            //
            // If the vector is found in the initialization table then
            // set up the IDT entry accordingly and advance to the next
            // entry in the initialization table.
            //
            // Otherwise set the IDT to reference the unexpected interrupt
            // handler.
            // 

            if (Index == IntInitRec->Vector) {
                KiInitializeIdtEntry(&IdtBase[Index],
                                     IntInitRec->Handler,
                                     IntInitRec->Dpl,
                                     IntInitRec->IstIndex);

                IntInitRec += 1;

            } else {

                UnexpectedInterrupt = &KxUnexpectedInterrupt0[Index];

                UnexpectedInterrupt->PushImmOp = 0x68;
                UnexpectedInterrupt->PushImm = (UCHAR)Index;
                UnexpectedInterrupt->PushRbp = 0x55;
                UnexpectedInterrupt->JmpOp = 0xe9;

                JumpOffset =
                    (LONG64)KiUnexpectedInterrupt - 
                    ((LONG64)UnexpectedInterrupt +
                     RTL_SIZEOF_THROUGH_FIELD(UNEXPECTED_INTERRUPT,JmpOffset));

                UnexpectedInterrupt->JmpOffset = (LONG)JumpOffset;

                KiInitializeIdtEntry(&IdtBase[Index],
                                     UnexpectedInterrupt,
                                     0,
                                     0);
            }
        }

    } else {
        KiInitializeIdtEntry(&IdtBase[209], &KiSecondaryClockInterrupt, 0, 0);
    }

    //
    // Initialize the system TSS I/O Map.
    //

    TssBase = Pcr->TssBase;
    TssBase->IoMapBase = KiComputeIopmOffset(FALSE);

    //
    // Initialize the system call MSRs.
    //

    WriteMSR(MSR_STAR,
             ((ULONG64)KGDT64_R0_CODE << 32) | (((ULONG64)KGDT64_R3_CMCODE | RPL_MASK) << 48));

    WriteMSR(MSR_CSTAR, (ULONG64)&KiSystemCall32);
    WriteMSR(MSR_LSTAR, (ULONG64)&KiSystemCall64);
    WriteMSR(MSR_SYSCALL_MASK, EFLAGS_SYSCALL_CLEAR);

    //
    // Set processor feature bits.
    //

    KiSetFeatureBits(Prcb);

    //
    // If this is processor zero, then set the number of logical processors
    // per physical processor, the APIC mask, and the initial number of
    // physical processors.
    //

    if (Number == 0) {
        KiLogicalProcessors = Prcb->LogicalProcessorsPerPhysicalProcessor;
        if (KiLogicalProcessors == 1) {
            ApicMask = 0xffffffff;

        } else {
            ApicMask = (KiLogicalProcessors * 2) - 1;
            KeFindFirstSetLeftMember(ApicMask, &Bit);
            ApicMask = ~((1 << Bit) - 1);
        }

        KiApicMask = ApicMask;
        KiPhysicalProcessors = 1;
    }

    Prcb->ApicMask = KiApicMask;

    //
    // initialize the per processor lock data.
    //

    KiInitSpinLocks(Prcb, Number);

    //
    // Initialize the PRCB temporary pool look aside pointers.
    //

    ExInitPoolLookasidePointers();

    //
    // Initialize the HAL for this processor.
    //

    HalInitializeProcessor(Number, LoaderBlock);

    //
    // Set the appropriate member in the active processors set.
    //

    KeActiveProcessors |= AFFINITY_MASK(Number);

    //
    // Set the number of processors based on the maximum of the current
    // number of processors and the current processor number.
    //

    if ((Number + 1) > KeNumberProcessors) {
        KeNumberProcessors = Number + 1;
    }

    //
    // Initialize the processor control state in the PRCB.
    //

    KiSaveInitialProcessorControlState(&Prcb->ProcessorState);

    return;
}

ULONG
KiFatalFilter (
    IN ULONG Code,
    IN PEXCEPTION_POINTERS Pointers
    )

/*++

Routine Description:

    This function is executed if an unhandled exception occurs during
    phase 0 initialization. Its function is to bugcheck the system
    with all the context information still on the stack.

Arguments:

    Code - Supplies the exception code.

    Pointers - Supplies a pointer to the exception information.

Return Value:

    None - There is no return from this routine even though it appears there
    is.

--*/

{

    KeBugCheckEx(PHASE0_EXCEPTION, Code, (ULONG64)Pointers, 0, 0);
}


BOOLEAN
KiInitMachineDependent (
    VOID
    )

/*++

Routine Description:

    This function initializes machine dependent data structures and hardware.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Size;
    NTSTATUS Status;
    BOOLEAN UseFrameBufferCaching;

    //
    // Query the HAL to determine if the write combining can be used for the
    // frame buffer.
    //

    Status = HalQuerySystemInformation(HalFrameBufferCachingInformation,
                                       sizeof(BOOLEAN),
                                       &UseFrameBufferCaching,
                                       &Size);

    //
    // If the status is successful and frame buffer caching is disabled,
    // then don't enable write combining.
    //

    if (!NT_SUCCESS(Status) || (UseFrameBufferCaching != FALSE)) {
        MmEnablePAT();
    }

    //
    // Verify division errata is not present.
    //

    if (KiDivide6432(KiTestDividend, 0xCB5FA3) != 0x5EE0B7E5) {
        KeBugCheck(UNSUPPORTED_PROCESSOR);
    }

    return TRUE;
}

VOID
KiSetCacheInformation (
    VOID
    )

/*++

Routine Description:

    This function sets the current processor cache information in the PCR and
    PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG AdjustedSize;
    UCHAR Associativity;
    PCACHE_DESCRIPTOR Cache;
    ULONG i;
    PKPCR Pcr;
    PKPRCB Prcb;
    ULONG Size;

    Pcr = KeGetPcr();
    Prcb = KeGetCurrentPrcb();

    //
    // Switch on processor vendor.
    //

    switch (Prcb->CpuVendor) {
    case CPU_AMD: 
        KiSetCacheInformationAmd();
        break;

    case CPU_INTEL:
        KiSetCacheInformationIntel();
        break;

    default:
        KeBugCheck(UNSUPPORTED_PROCESSOR);
        break;
    }

    //
    // Scan through the cache descriptors initialized by the processor 
    // specific code and compute cache parameters for page coloring 
    // and largest cache line size.
    //

    AdjustedSize = 0;
    Cache = Prcb->Cache;
    Pcr->SecondLevelCacheSize = 0;

    for (i = 0; i < Prcb->CacheCount; i++) {
        if ((Cache->Level >= 2) && 
            ((Cache->Type == CacheData) || (Cache->Type == CacheUnified))) {

            Associativity = Cache->Associativity;
            if (Associativity == CACHE_FULLY_ASSOCIATIVE) {

                //
                // Temporarily preserve existing behavior of treating
                // fully associative cache as a 16 way associative
                // cache until MM interprets the cache descriptors
                // directly.
                //

                Associativity = 16;
            }

            if (Associativity != 0) {
                Size = Cache->Size/Associativity;
                if (Size > AdjustedSize) {
                    AdjustedSize = Size;
                    Pcr->SecondLevelCacheSize = Cache->Size;
                    Pcr->SecondLevelCacheAssociativity = Associativity;
                }
            }

            //
            // If the line size is greater then the current largest line
            // size, then set the new largest line size.
            //

            if (Cache->LineSize > KeLargestCacheLine) {
                KeLargestCacheLine = Cache->LineSize;
            }
        }
        Cache++;
    }
    return;
}

VOID
KiSetCacheInformationAmd (
    VOID
    )

/*++

Routine Description:

    This function extracts the cache hierarchy information of an AMD
    processor and initializes cache descriptors in the PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    UCHAR Associativity;
    PCACHE_DESCRIPTOR Cache;
    CPU_INFO CpuInfo;
    ULONG Index;
    UCHAR Level;
    USHORT LineSize;
    AMD_L1_CACHE_INFO L1Info;
    AMD_L2_CACHE_INFO L2Info;
    PKPRCB Prcb;
    ULONG Size;
    PROCESSOR_CACHE_TYPE Type;

    //
    // Iterate through the cache levels and generate the cache information
    // for each level.
    //

    Prcb = KeGetCurrentPrcb();
    Prcb->CacheCount = 0;
    Cache = &Prcb->Cache[0];
    Index = 0;
    do {

        //
        // Switch on the cache level.
        //

        switch (Index) {
        
            //
            // Get L1 instruction and data cache information.
            //

        case 0:
        case 1:
            KiCpuId(0x80000005, 0, &CpuInfo);
            Level = 1;
            if (Index == 0) {
                L1Info.Ulong = CpuInfo.Ecx;
                Type = CacheData;

            } else {
                L1Info.Ulong = CpuInfo.Edx;
                Type = CacheInstruction;
            }

            LineSize = L1Info.LineSize;
            Size = L1Info.Size << 10;
            Associativity = L1Info.Associativity;
            break;

            //
            // Get L2 unified cache information.
            //

        case 2:
            KiCpuId(0x80000006, 0, &CpuInfo);
            Level = 2;
            Type = CacheUnified;
            L2Info.Ulong = CpuInfo.Ecx;
            LineSize = L2Info.LineSize;
            Size = L2Info.Size << 10;

            //
            // Switch on associativity.
            //

            switch (L2Info.Associativity) {

                //
                // L2 cache is not present
                //

            case 0x0:
                continue;

                //
                // L2 cache is two way associative.
                //

            case 0x2:
                Associativity = 2;
                break;

                //
                // L2 cache is four way associative.
                //

            case 0x4:
                Associativity = 4;
                break;

                //
                // L2 cache is eight way associative.
                //

            case 0x6:
                Associativity = 8;
                break;

                //
                // L2 cache is sixteen way associative.
                //

            case 0x8:
                Associativity = 16;
                break;

                //
                // L2 cache is fully associative.
                //

            case 0xf:
                Associativity = CACHE_FULLY_ASSOCIATIVE;
                break;

                //
                // Direct mapped.
                //

            default:
                Associativity = 1;
            }

            break;

            //
            // L3 cache is undefined.
            //

        default:
            continue;
        }
            
        //
        // Generate a cache descriptor for the current level in the PRCB.
        //

        Cache->Type = Type;
        Cache->Level = Level;
        Cache->Associativity = Associativity;
        Cache->LineSize = LineSize;
        Cache->Size = Size;
        Cache += 1;
        Prcb->CacheCount += 1;
        Index += 1;
    } while (Index < 3);
    return;
}

VOID
KiSetCacheInformationIntel (
    VOID
    )
/*++

Routine Description:

    This function extracts the cache hierarchy information of an Intel 
    processor and initializes cache descriptors in the PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PCACHE_DESCRIPTOR Cache;
    CPU_INFO CpuInfo;
    INTEL_CACHE_INFO_EAX CacheInfoEax;
    INTEL_CACHE_INFO_EBX CacheInfoEbx;
    ULONG Index;
    PKPRCB Prcb;
    ULONGLONG CacheSize;

    Prcb = KeGetCurrentPrcb();
    Prcb->CacheCount = 0;

    //
    // Check for the availability of deterministic cache parameter mechanism.
    // This cpuid function should be supported on all versions EM64T family
    // processors. 
    //

    KiCpuId(0, 0, &CpuInfo);
    if (CpuInfo.Eax < 3 || CpuInfo.Eax >= 0x80000000) {
        ASSERT(FALSE);
        return;
    }

    Cache = &Prcb->Cache[0];
    Index = 0;

    //
    // Enumerate the details of cache hierarchy by executing CPUID 
    // instruction repeatedly until no more cache information to be
    // returned.
    //
    
    do {
        KiCpuId(4, Index, &CpuInfo);
        Index += 1;
        CacheInfoEax.Ulong = CpuInfo.Eax;
        CacheInfoEbx.Ulong = CpuInfo.Ebx;

        if (CacheInfoEax.Type == IntelCacheNull) {
            break;
        }

        switch (CacheInfoEax.Type) {
        case IntelCacheData:
            Cache->Type = CacheData;
            break;
        case IntelCacheInstruction:
            Cache->Type = CacheInstruction;
            break;
        case IntelCacheUnified:
            Cache->Type = CacheUnified;
            break;
        case IntelCacheTrace:
            Cache->Type = CacheTrace;
            break;
        default:
            continue;
        }

        if (CacheInfoEax.FullyAssociative) {
            Cache->Associativity = CACHE_FULLY_ASSOCIATIVE;

        } else {
            Cache->Associativity = (UCHAR) CacheInfoEbx.Associativity + 1;
        }

        Cache->Level = (UCHAR) CacheInfoEax.Level;
        Cache->LineSize = (USHORT) (CacheInfoEbx.LineSize + 1);

        //
        // Cache size = Ways x Partitions x LineSize x Sets. 
        //
        // N.B. For fully-associative cache, the "Sets" returned 
        // from cpuid is actually the number of entries, not the
        // "Ways". Therefore the formula of evaluating the cache 
        // size below will still hold.
        //

        CacheSize = (CacheInfoEbx.Associativity + 1) *
                    (CacheInfoEbx.Partitions + 1) *
                    (CacheInfoEbx.LineSize + 1) * 
                    (CpuInfo.Ecx + 1);

        Cache->Size = (ULONG) CacheSize;
        ASSERT(CacheSize == Cache->Size);
        Cache++;
        Prcb->CacheCount++;
    } while (Prcb->CacheCount < RTL_NUMBER_OF(Prcb->Cache));
    return;
}

VOID
KiSetCpuVendor (
    VOID
    )

/*++

Routine Description:

    Set the current processor cpu vendor information in the PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    CPU_INFO CpuInformation;
    PKPRCB Prcb = KeGetCurrentPrcb();
    ULONG Temp;

    //
    // Get the CPU vendor string.
    //

    KiCpuId(0, 0, &CpuInformation);

    //
    // Copy vendor string to PRCB.
    //

    Temp = CpuInformation.Ecx;
    CpuInformation.Ecx = CpuInformation.Edx;
    CpuInformation.Edx = Temp;
    RtlCopyMemory(Prcb->VendorString,
                  &CpuInformation.Ebx,
                  sizeof(Prcb->VendorString) - 1);

    Prcb->VendorString[sizeof(Prcb->VendorString) - 1] = '\0';

    //
    // Check to determine the processor vendor.
    //

    if (strncmp((PCHAR)&CpuInformation.Ebx, "AuthenticAMD", 12) == 0) {
        Prcb->CpuVendor = CPU_AMD;

    } else if (strncmp((PCHAR)&CpuInformation.Ebx, "GenuineIntel", 12) == 0) {
        Prcb->CpuVendor = CPU_INTEL;

    } else {
        KeBugCheck(UNSUPPORTED_PROCESSOR);
    }

    return;
}

VOID
KiSetFeatureBits (
    IN PKPRCB Prcb
    )

/*++

Routine Description:

    Set the current processor feature bits in the PRCB.

Arguments:

    Prcb - Supplies a pointer to the current processor block.

Return Value:

    None.

--*/

{

    CPU_INFO InformationExtended;
    CPU_INFO InformationStandard;
    ULONG FeatureBits;

    //
    // Get CPU feature information.
    //

    KiCpuId(1, 0, &InformationStandard);
    KiCpuId(0x80000001, 0, &InformationExtended);

    //
    // Set the initial APIC ID and cache flush size.
    //

    Prcb->InitialApicId = (UCHAR)(InformationStandard.Ebx >> 24);
    Prcb->CFlushSize = ((UCHAR)(InformationStandard.Ebx >> 8)) << 3;

    //
    // If the required features are not present, then bugcheck.
    //

    if (((InformationStandard.Edx & HF_REQUIRED) != HF_REQUIRED) ||
        ((InformationExtended.Edx & XHF_SYSCALL) == 0)) {

        KeBugCheckEx(UNSUPPORTED_PROCESSOR, InformationStandard.Edx, 0, 0, 0);
    }

    FeatureBits = KF_REQUIRED;
    if ((InformationStandard.Edx & HF_DS) != 0) {
        FeatureBits |= KF_DTS;
    }

    //
    // Check the extended feature bits.
    //

    if ((InformationExtended.Edx & XHF_3DNOW) != 0) {
        FeatureBits |= KF_3DNOW;
    }

    //
    // Check for no execute protection.
    //
    // If the processor being initialized is the boot processor or the boot
    // processor is NX capable, then set the no execute feature bit for this
    // processor as appropriate.
    //

    if ((Prcb->Number == 0) ||
        ((KeFeatureBits & KF_NOEXECUTE) != 0)) {

        if ((InformationExtended.Edx & XHF_NOEXECUTE) != 0) {
            FeatureBits |= KF_NOEXECUTE;
        }
    }

    //
    // Check for fast floating/save restore and, if present, enable for the
    // current processor.
    //

    if ((InformationExtended.Edx & XHF_FFXSR) != 0) {
        WriteMSR(MSR_EFER, ReadMSR(MSR_EFER) | MSR_FFXSR);
    }

    //
    // Set number of logical processors per physical processor.
    //

    Prcb->LogicalProcessorsPerPhysicalProcessor = 1;
    if ((InformationStandard.Edx & HF_SMT) != 0) {
        Prcb->LogicalProcessorsPerPhysicalProcessor =
                                        (UCHAR)(InformationStandard.Ebx >> 16);
    }

    Prcb->FeatureBits = FeatureBits;
    return;
}              

VOID
KiSetProcessorType (
    VOID
    )

/*++

Routine Description:

    This function sets the current processor family and stepping in the PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    CPU_INFO CpuInformation;
    ULONG Family;
    ULONG Model;
    PKPRCB Prcb = KeGetCurrentPrcb();
    ULONG Stepping;
    union {
        struct {
            ULONG Stepping : 4;
            ULONG Model : 4;
            ULONG Family : 4;
            ULONG Reserved0 : 4;
            ULONG ExtendedModel : 4;
            ULONG ExtendedFamily : 8;
            ULONG Reserved1 : 4;
        };

        ULONG AsUlong;
    } Signature;

    //
    // Get cpu feature information.
    //

    KiCpuId(1, 0, &CpuInformation);
    Signature.AsUlong = CpuInformation.Eax;

    //
    // Set processor family and stepping information.
    //

    if (Signature.Family == 0xf) {
        Family = Signature.Family + Signature.ExtendedFamily;
        Model = (Signature.ExtendedModel << 4) | Signature.Model;

    } else {
        Family = Signature.Family;
        Model = Signature.Model;
    }

    //
    // Derive the extended model info for Intel family 6 processors.
    //

    if ((Prcb->CpuVendor == CPU_INTEL) && (Family == 6)) {
        Model |= (Signature.ExtendedModel << 4);
    }

    Stepping = Signature.Stepping;
    Prcb->CpuID = TRUE;
    Prcb->CpuType = (UCHAR)Family;
    Prcb->CpuStep = (USHORT)((Model << 8) | Stepping);

    //
    // Retrieve the microcode update signature
    //

    if (Prcb->CpuVendor == CPU_INTEL) {
        WriteMSR(MSR_BIOS_SIGN, 0);
        KiCpuId(1, 0, &CpuInformation);
        Prcb->UpdateSignature.QuadPart = ReadMSR(MSR_BIOS_SIGN);
    }

    //
    // Enable prefetch retry as appropriate.
    // 

    if ((Prcb->CpuVendor == CPU_AMD) &&
        (Family <= 0x0F) &&
        (Model <= 5) &&
        (Stepping <= 8)) {

        KiPrefetchRetry |= 0x01;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\intobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

--*/

#include "ki.h"

VOID
KeInitializeInterrupt (
    __out PKINTERRUPT Interrupt,
    __in PKSERVICE_ROUTINE ServiceRoutine,
    __in_opt PVOID ServiceContext,
    __out_opt PKSPIN_LOCK SpinLock,
    __in ULONG Vector,
    __in KIRQL Irql,
    __in KIRQL SynchronizeIrql,
    __in KINTERRUPT_MODE InterruptMode,
    __in BOOLEAN ShareVector,
    __in CCHAR ProcessorNumber,
    __in BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, SynchronizeIrql, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    SpinLock - Supplies a pointer to an executive spin lock.  There are two
        distinguished values recognized for SpinLock:

        NO_INTERRUPT_SPINLOCK - The kernel does not manage a spinlock
            associated with this interrupt.

        NO_END_OF_INTERRUPT - The interrupt represents a spurious interrupt
            vector, which is handled with a special, non-EOI interrupt
            routine.

    Vector - Supplies the HAL-generated interrupt vector.  Note that this
        is not be directly used as an index into the Interrupt Dispatch Table.

    Irql - Supplies the request priority of the interrupting source.

    SynchronizeIrql - Supplies the request priority that the interrupt should be
        synchronized with.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorNumber - Supplies the number of the processor to which the
        interrupt will be connected.

    FloatingSave - Supplies a boolean value that determines whether the
        floating point registers are to be saved before calling the service
        routine function. N.B. This argument is ignored.

Return Value:

    None.

--*/

{
    LONG64 Index;
    PULONG InterruptTemplate;

    UNREFERENCED_PARAMETER(FloatingSave);

    //
    // Initialize standard control object header.
    //

    Interrupt->Type = InterruptObject;
    Interrupt->Size = sizeof(KINTERRUPT);

    //
    // Initialize the address of the service routine, the service context,
    // the address of the spin lock, the address of the actual spinlock
    // that will be used, the vector number, the IRQL of the interrupting
    // source, the IRQL used for synchronize execution, the interrupt mode,
    // the processor number, and the floating context save flag.
    //

    Interrupt->ServiceRoutine = ServiceRoutine;
    Interrupt->ServiceContext = ServiceContext;
    if (ARGUMENT_PRESENT(SpinLock)) {
        Interrupt->ActualLock = SpinLock;

    } else {
        KeInitializeSpinLock (&Interrupt->SpinLock);
        Interrupt->ActualLock = &Interrupt->SpinLock;
    }

    Interrupt->Vector = Vector;
    Interrupt->Irql = Irql;
    Interrupt->SynchronizeIrql = SynchronizeIrql;
    Interrupt->Mode = InterruptMode;
    Interrupt->ShareVector = ShareVector;
    Interrupt->Number = ProcessorNumber;

    //
    // Copy the interrupt dispatch code template into the interrupt object.
    //

    if (SpinLock == NO_END_OF_INTERRUPT) {
        InterruptTemplate = KiSpuriousInterruptTemplate;

    } else {
        InterruptTemplate = KiInterruptTemplate;
    }

    for (Index = 0; Index < NORMAL_DISPATCH_LENGTH; Index += 1) {
        Interrupt->DispatchCode[Index] = InterruptTemplate[Index];
    }

    //
    // If this is the performance interrupt, and we're on a processor that
    // supports the LB MSR, then route the interrupt to the special interrupt
    // handler. Otherwise, route to the standard no lock interrupt handler.
    //

    if ((SpinLock == INTERRUPT_PERFORMANCE) &&
        (KeGetCurrentPrcb()->CpuVendor != CPU_INTEL)) {

        SpinLock = NO_INTERRUPT_SPINLOCK;
    }

    //
    // Set DispatchAddress to KiInterruptDispatch as a default value.
    // The AMD64 HAL expects this to be set here.  Other clients will
    // overwrite this value as appropriate via KeConnectInterrupt().
    //

    if (SpinLock == NO_INTERRUPT_SPINLOCK) {
        Interrupt->DispatchAddress = &KiInterruptDispatchNoLock;

    } else if (SpinLock == INTERRUPT_PERFORMANCE) {
        Interrupt->DispatchAddress = &KiInterruptDispatchLBControl;

    } else {
        Interrupt->DispatchAddress = &KiInterruptDispatch;
    }

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
    return;
}

BOOLEAN
KeConnectInterrupt (
    __inout PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Otherwise, a value of TRUE is returned.

--*/

{

    BOOLEAN Connected;
    PVOID Dispatch;
    ULONG IdtIndex;
    PKINTERRUPT Interruptx;
    KIRQL Irql;
    CCHAR Number;
    KIRQL OldIrql;
    PVOID Unexpected;
    ULONG Vector;

    //
    // If the interrupt object is already connected, the interrupt vector
    // number is invalid, an attempt is being made to connect to a vector
    // that cannot be connected, the interrupt request level is invalid, or
    // the processor number is invalid, then do not connect the interrupt
    // object. Otherwise, connect the interrupt object to the specified
    // vector and establish the proper interrupt dispatcher.
    //

    Connected = FALSE;
    Irql = Interrupt->Irql;
    Number = Interrupt->Number;
    Vector = Interrupt->Vector;
    IdtIndex = HalVectorToIDTEntry(Vector);
    if (((IdtIndex > MAXIMUM_PRIMARY_VECTOR) ||
        (Irql > HIGH_LEVEL) ||
        (Irql != (IdtIndex >> 4)) ||
        (Number >= KeNumberProcessors) ||
        (Interrupt->SynchronizeIrql < Irql)) == FALSE) {

        //
        // Set the system affinity to the specified processor, raise IRQL to
        // dispatcher level, and lock the dispatcher database.
        //

        KeSetSystemAffinityThread(AFFINITY_MASK(Number));
        KiLockDispatcherDatabase(&OldIrql);

        //
        // If the specified interrupt vector is not connected, then
        // connect the interrupt vector to the interrupt object dispatch
        // code, establish the dispatcher address, and set the new
        // interrupt mode and enable masks. Otherwise, if the interrupt is
        // already chained, then add the new interrupt object at the end
        // of the chain. If the interrupt vector is not chained, then
        // start a chain with the previous interrupt object at the front
        // of the chain. The interrupt mode of all interrupt objects in
        // a chain must be the same.
        //

        if (Interrupt->Connected == FALSE) {
            KeGetIdtHandlerAddress(Vector, &Dispatch);
            Unexpected = &KxUnexpectedInterrupt0[IdtIndex];
            if (Unexpected == Dispatch) {

                KIRQL OldIrql;

                //
                // The interrupt vector is not connected.
                //
                // Raise IRQL to high level in order to prevent a pending
                // interrupt from firing before the IDT is set up.
                //

                KeRaiseIrql(HIGH_LEVEL,&OldIrql);
                Connected = HalEnableSystemInterrupt(Vector,
                                                     Irql,
                                                     Interrupt->Mode);

                if (Connected != FALSE) {
                    Interrupt->DispatchAddress = &KiInterruptDispatch;
                    KeSetIdtHandlerAddress(Vector, &Interrupt->DispatchCode[0]);
                }

                KeLowerIrql(OldIrql);

            } else if (IdtIndex >= PRIMARY_VECTOR_BASE) {

                //
                // The interrupt vector is connected. Make sure the interrupt
                // mode matchs and that both interrupt objects allow sharing
                // of the interrupt vector.
                //

                Interruptx = CONTAINING_RECORD(Dispatch,
                                               KINTERRUPT,
                                               DispatchCode[0]);

                if ((Interrupt->Mode == Interruptx->Mode) &&
                    (Interrupt->ShareVector != FALSE) &&
                    (Interruptx->ShareVector != FALSE) &&
                    ((Interruptx->DispatchAddress == KiInterruptDispatch) ||
                     (Interruptx->DispatchAddress == KiChainedDispatch))) {

                    Connected = TRUE;

                    //
                    // If the chained dispatch routine is not being used,
                    // then switch to chained dispatch.
                    //

                    if (Interruptx->DispatchAddress != &KiChainedDispatch) {
                        InitializeListHead(&Interruptx->InterruptListEntry);
                        Interruptx->DispatchAddress = &KiChainedDispatch;
                    }

                    InsertTailList(&Interruptx->InterruptListEntry,
                                   &Interrupt->InterruptListEntry);
                }
            }
        }

        //
        // Unlock dispatcher database, lower IRQL to its previous value, and
        // set the system affinity back to the original value.
        //

        KiUnlockDispatcherDatabase(OldIrql);
        KeRevertToUserAffinityThread();
    }

    //
    // Return whether interrupt was connected to the specified vector.
    //

    Interrupt->Connected = Connected;
    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    __inout PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Otherwise, a value of TRUE is returned.

--*/

{

    BOOLEAN Disconnected;
    PVOID Dispatch;
    ULONG IdtIndex;
    PKINTERRUPT Interruptx;
    PKINTERRUPT Interrupty;
    KIRQL Irql;
    KIRQL OldIrql;
    PVOID Unexpected;
    ULONG Vector;

    //
    // Set the system affinity to the specified processor, raise IRQL to
    // dispatcher level, and lock dispatcher database.
    //

    KeSetSystemAffinityThread(AFFINITY_MASK(Interrupt->Number));
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Disconnected = Interrupt->Connected;
    if (Disconnected != FALSE) {
        Irql = Interrupt->Irql;
        Vector = Interrupt->Vector;
        IdtIndex = HalVectorToIDTEntry(Vector);

        //
        // If the specified interrupt vector is not connected to the chained
        // interrupt dispatcher, then disconnect it by setting its dispatch
        // address to the unexpected interrupt routine. Otherwise, remove the
        // interrupt object from the interrupt chain. If there is only
        // one entry remaining in the list, then reestablish the dispatch
        // address.
        //

        KeGetIdtHandlerAddress(Vector, &Dispatch);
        Interruptx = CONTAINING_RECORD(Dispatch, KINTERRUPT, DispatchCode[0]);
        if (Interruptx->DispatchAddress == &KiChainedDispatch) {

            //
            // The interrupt object is connected to the chained dispatcher.
            //

            if (Interrupt == Interruptx) {
                Interruptx = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                               KINTERRUPT,
                                               InterruptListEntry);

                Interruptx->DispatchAddress = &KiChainedDispatch;
                KeSetIdtHandlerAddress(Vector, &Interruptx->DispatchCode[0]);
            }

            RemoveEntryList(&Interrupt->InterruptListEntry);
            Interrupty = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                           KINTERRUPT,
                                           InterruptListEntry);

            if (Interruptx == Interrupty) {
                Interrupty->DispatchAddress = KiInterruptDispatch;
                KeSetIdtHandlerAddress(Vector, &Interrupty->DispatchCode[0]);
            }

        } else {

            //
            // The interrupt object is not connected to the chained interrupt
            // dispatcher.
            //

            HalDisableSystemInterrupt(Vector, Irql);
            Unexpected = &KxUnexpectedInterrupt0[IdtIndex];
            KeSetIdtHandlerAddress(Vector, Unexpected);
        }

        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // set the system affinity back to the original value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    KeRevertToUserAffinityThread();

    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Disconnected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\intsup.asm ===
TITLE  "Interrupt Object Support Routines"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    intsup.asm
;
; Abstract:
;
;    This module implements the platform specific code to support interrupt
;    objects. It contains the interrupt dispatch code and the code template
;    that gets copied into an interrupt object.
;
;--

include ksamd64.inc

        extern  ExpInterlockedPopEntrySListEnd:proc
        extern  ExpInterlockedPopEntrySListResume:proc
        extern  KeBugCheck:proc
        extern  KeLastBranchMSR:dword
        extern  KiBugCheckDispatch:proc
        extern  KiCheckForSListAddress:proc
        extern  KiDpcInterruptBypass:proc
        extern  KiIdleSummary:qword
        extern  KiInitiateUserApc:proc
        extern  KiRestoreDebugRegisterState:proc
        extern  KiSaveDebugRegisterState:proc
        extern  PerfInfoLogInterrupt:proc
        extern  __imp_HalRequestSoftwareInterrupt:qword

        subttl  "Synchronize Execution"
;++
;
; BOOLEAN
; KeSynchronizeExecution (
;     IN PKINTERRUPT Interrupt,
;     IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
;     IN PVOID SynchronizeContext
;     )
;
; Routine Description:
;
;   This function synchronizes the execution of the specified routine with
;   the execution of the service routine associated with the specified
;   interrupt object.
;
; Arguments:
;
;   Interrupt (rcx) - Supplies a pointer to an interrupt object.
;
;   SynchronizeRoutine (rdx) - Supplies a pointer to the function whose
;       execution is to be synchronized with the execution of the service
;       routine associated with the specified interrupt object.
;
;   SynchronizeContext (r8) - Supplies a context pointer which is to be
;       passed to the synchronization function as a parameter.
;
; Return Value:
;
;   The value returned by the synchronization routine is returned as the
;   function value.
;
;--

SyFrame struct
        P1Home  dq ?                    ; parameter home address
        P2Home  dq ?
        P3Home  dq ?
        P4Home  dq ?
        OldIrql dd ?                    ; saved IRQL
        Fill0   dd ?
        Fill1   dq ?                    ; stack alignment
        SavedRsi dq ?                   ; saved nonvolatile register
SyFrame ends

        NESTED_ENTRY KeSynchronizeExecution, _TEXT$00

        alloc_stack (sizeof SyFrame)    ; allocate stack frame
        save_reg rsi, SyFrame.SavedRsi  ; save nonvolatile register

        END_PROLOGUE

        mov     rsi, InActualLock[rcx]  ; save interrupt object lock
        movzx   ecx, byte ptr InSynchronizeIrql[rcx] ; get synchronization IRQL

        RaiseIrql                       ; raise IRQL to synchronization level

        mov     rcx, r8                 ; set synchronization context
        mov     SyFrame.OldIrql[rsp], eax ; save previous IRQL

        AcquireSpinLock [rsi]           ; acquire interrupt spin lock

        call    rdx                     ; call synchronization routine

        ReleaseSpinlock [rsi]           ; release interrupt spin lock

        mov     ecx, SyFrame.OldIrql[rsp] ; get previous IRQL

        LowerIrql                       ; lower IRQL to previous level

        mov     rsi, SyFrame.SavedRsi[rsp] ; restore nonvolatile register
        add     rsp, sizeof SyFrame     ; deallocate stack frame
        ret                             ;

        NESTED_END KeSynchronizeExecution, _TEXT$00

        subttl  "Interrupt Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; KiInterruptHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PDISPATCHER_CONTEXT DispatcherContext
;    )
;
; Routine Description:
;
;   This routine is the exception handler for the interrupt dispatcher. The
;   dispatching or unwinding of an exception across an interrupt causes a
;   bugcheck.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to  the dispatcher context
;       record.
;
; Return Value:
;
;   There is no return from this routine.
;
;--

IhFrame struct
        P1Home  dq ?                    ; parameter home address
        P2Home  dq ?
        P3Home  dq ?
        P4Home  dq ?
        Fill    dq ?
IhFrame ends

        NESTED_ENTRY KiInterruptHandler, _TEXT$00

        alloc_stack (sizeof IhFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     r10, ErExceptionAddress[rcx] ; set exception address
        xor     r9, r9                  ; zero remaining arguments
        xor     r8, r8                  ;
        xor     edx, edx                ;
        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; test for unwind
        mov     ecx, INTERRUPT_UNWIND_ATTEMPTED ; set bugcheck code
        jnz     short KiIH10            ; if nz, unwind in progress
        mov     ecx, INTERRUPT_EXCEPTION_NOT_HANDLED ; set bugcheck code
KiIH10: call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiInterruptHandler, _TEXT$00

        subttl  "Chained Dispatch"
;++
;
; VOID
; KiChainedDispatch (
;     VOID
;     );
;
; Routine Description:
;
;   This routine is entered as the result of an interrupt being generated
;   via a vector that is connected to more than one interrupt object.
;
; Arguments:
;
;   rbp - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiChainedDispatch, _TEXT$00, KiInterruptHandler

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

        movzx   ecx, byte ptr InIrql[rsi] ; set interrupt IRQL

	ENTER_INTERRUPT	<NoEOI>         ; raise IRQL and enable interrupts

        call    KiScanInterruptObjectList ; scan interrupt object list

        EXIT_INTERRUPT                  ; do EOI, lower IRQL, and restore state

        NESTED_END KiChainedDispatch, _TEXT$00

        subttl  "Scan Interrupt Object List"
;++
;
; Routine Description:
;
;   This routine scans the list of interrupt objects for chained interrupt
;   dispatch. If the mode of the interrupt is latched, then a complete scan
;   of the list must be performed. Otherwise, the scan can be cut short as
;   soon as an interrupt routine returns
;
; Arguments:
;
;   rsi - Supplies a pointer to the interrupt object.
;
; Implicit Arguments:
;
;   rbp - Supplies the address of the interrupt trap frame.
;
; Return Value:
;
;   None.
;
;--

SiFrame struct
        P1Home  dq ?                    ; interrupt object parameter
        P2Home  dq ?                    ; service context parameter
        P3Home  dq ?                    ; Per calling standard
        P4Home  dq ?                    ;  "
        Return  db ?                    ; service routine return value
        Fill    db 15 dup (?)           ; fill
        SavedRbx dq ?                   ; saved register RBX
        SavedRdi dq ?                   ; saved register RDI
        SavedR12 dq ?                   ; saved register RSI
SiFrame ends

        NESTED_ENTRY KiScanInterruptObjectList, _TEXT$00

        alloc_stack (sizeof SiFrame)    ; allocate stack frame
        save_reg rbx, SiFrame.SavedRbx  ; save nonvolatile registers
        save_reg rdi, SiFrame.SavedRdi  ;
        save_reg r12, SiFrame.SavedR12  ;

        END_PROLOGUE

        lea     rbx, InInterruptListEntry[rsi] ; get list head address
        mov     r12, rbx                ; set address of first list entry

;
; If interrupt logging is enabled, then store the initial time stamp value.
;

        mov     rax, gs:[PcPerfGlobalGroupMask]; get global mask address
        test    rax, rax                ; test if logging enabled
        mov     qword ptr TrTimeStamp[rbp], 0 ; clear time stamp value
        je      short KiSI05            ; if e, logging not enabled
        test    qword ptr PERF_INTERRUPT_OFFSET[rax], PERF_INTERRUPT_FLAG ; check flag
        jz      short KiSI05            ; if z, interrupt logging not enabled
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        mov     TrTimeStamp[rbp], rax   ; save starting time stamp value

;
; Scan the list of connected interrupt objects and call the service routine.
;

KiSI05: xor     edi, edi                ; clear interrupt handled flag
KiSI10: sub     r12, InInterruptListEntry ; compute interrupt object address
        movzx   ecx, byte ptr InSynchronizeIrql[r12] ; get synchronization IRQL
        mov     r11, InActualLock[r12]  ; get actual spin lock address
        cmp     cl, InIrql[rsi]         ; check if equal interrupt IRQL
        je      short KiSI20            ; if e, IRQL levels equal

        SetIrql                         ; set IRQL to synchronization level

KiSI20: AcquireSpinLock [r11]           ; acquire interrupt spin lock

        mov     rcx, r12                ; set interrupt object parameter
        mov     rdx, InServiceContext[r12] ; set context parameter
        call    qword ptr InServiceRoutine[r12] ; call interrupt service routine
        mov     r11, InActualLock[r12]  ; get actual spin lock address
        mov     SiFrame.Return[rsp], al ; save return value
        movzx   ecx, byte ptr InIrql[rsi] ; get interrupt IRQL

        ReleaseSpinLock [r11]           ; release interrupt spin lock

        cmp     cl, InSynchronizeIrql[r12] ; check if equal synchronization IRQL
        je      short KiSI25            ; if e, IRQL levels equal

        SetIrql                         ; set IRQL to interrupt level

;
; If interrupt logging is enabled, then log the interrupt.
;

KiSI25: cmp     qword ptr TrTimeStamp[rbp], 0 ; check if interrupt logging enabled
        je      short KiSI30            ; if e, interrupt logging not enabled
        mov     r8, TrTimeStamp[rbp]    ; set initial time stamp value
        movzx   edx, SiFrame.Return[rsp] ; set interrupt return value
        mov     rcx, InServiceRoutine[r12] ; set interrupt service routine address
        call    PerfInfoLogInterrupt    ; log interrupt
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        mov     TrTimeStamp[rbp], rax   ; save starting time stamp value
KiSI30: test    byte ptr SiFrame.Return[rsp], 0ffh ; test if interrupt handled
        jz      short KiSI40            ; if z, interrupt not handled
        cmp     word ptr InMode[r12], InLatched ; check if latched interrupt
        jne     short KiSI50            ; if ne, not latched interrupt
        inc     edi                     ; indicate latched interrupt handled
KiSI40: mov     r12, InInterruptListEntry[r12] ; get next interrupt list entry
        cmp     r12, rbx                ; check if end of list
        jne     KiSI10                  ; if ne, not end of list

;
; The complete interrupt object list has been scanned. This can only happen
; if the interrupt is a level sensitive interrupt and no interrupt was handled
; or the interrupt is a latched interrupt. Therefore, if any interrupt was
; handled it was a latched interrupt and the list needs to be scanned again
; to ensure that no interrupts are lost.
;

        test    edi, edi                ; test if any interrupts handled
        jnz     KiSI05                  ; if nz, latched interrupt handled
KiSI50: mov     rbx, SiFrame.SavedRbx[rsp] ; restore nonvolatile register
        mov     rdi, SiFrame.SavedRdi[rsp] ;
        mov     r12, SiFrame.SavedR12[rsp] ;
        add     rsp, (sizeof SiFrame)   ; deallocate stack frame
        ret                             ;

        NESTED_END KiscanInterruptObjectList, _TEXT$00

        subttl  "Interrupt Dispatch"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an interrupt being generated
;   via a vector that is connected to an interrupt object. Its function is
;   to directly call the specified interrupt service routine.
;
;   This routine is identical to interrupt dispatch no lock except that
;   the interrupt spinlock is taken.
;
;   N.B. On entry rbp and rsi have been saved on the stack.
;
; Arguments:
;
;   rbp - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiInterruptDispatch, _TEXT$00, KiInterruptHandler

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

;
; N.B. It is possible for a interrupt to occur at an IRQL that is lower
;      than the current IRQL. This happens when the IRQL raised and at
;      the same time an interrupt request is granted.
;

        movzx   ecx, byte ptr InIrql[rsi] ; set interrupt IRQL

	ENTER_INTERRUPT <NoEOI>         ; raise IRQL and enable interrupts

        lea     rax, (-128)[rbp]        ; set trap frame address
        mov     InTrapFrame[rsi], rax   ;

;
; If interrupt logging is enabled, then store the initial time stamp value.
;

        mov     rax, gs:[PcPerfGlobalGroupMask]; get global mask address
        test    rax, rax                ; test if logging enabled
        mov     qword ptr TrTimeStamp[rbp], 0 ; clear time stamp value
        je      short KiID10            ; if e, logging not enabled
        test    qword ptr PERF_INTERRUPT_OFFSET[rax], PERF_INTERRUPT_FLAG ; check flag
        jz      short KiID10            ; if z, interrupt logging not enabled
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        mov     TrTimeStamp[rbp], rax   ; save starting time stamp value
        mov     rax, InServiceRoutine[rsi] ; save interrupt service routine address
        mov     TrP5[rbp], rax          ;

;
; Dispatch interrupt.
;

KiID10: mov     rcx, rsi                ; set address of interrupt object
        mov     rsi, InActualLock[rsi]  ; get address of interrupt lock
        mov     rdx, InServiceContext[rcx] ; set service context

        AcquireSpinLock [rsi]           ; acquire interrupt spin lock

        call    qword ptr InServiceRoutine[rcx] ; call interrupt service routine

        ReleaseSpinLock [rsi]    