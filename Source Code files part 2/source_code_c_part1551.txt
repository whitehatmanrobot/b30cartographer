dgeGoesRight( up->Lprev )
	     || EdgeSign( up->Dst, up->Org, up->Lprev->Org ) >= 0 )) {
	up = __gl_meshConnect( up, up->Lprev )->Sym;
      }
      up = up->Lnext;
    }
  }

  /* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
   * can be tesselated in a fan from this leftmost vertex.
   */
  assert( lo->Lnext != up );
  while( lo->Lnext->Lnext != up ) {
    lo = __gl_meshConnect( lo->Lnext, lo )->Sym;
  }
}


/* __gl_meshTesselateInterior( mesh ) tesselates each region of
 * the mesh which is marked "inside" the polygon.  Each such region
 * must be monotone.
 */
void __gl_meshTesselateInterior( GLUmesh *mesh )
{
  GLUface *f, *next;

  /*LINTED*/
  for( f = mesh->fHead.next; f != &mesh->fHead; f = next ) {
    /* Make sure we don''t try to tesselate the new triangles. */
    next = f->next;
    if( f->inside ) {
      __gl_meshTesselateMonoRegion( f );
    }
  }
}


/* __gl_meshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
 * which are not marked "inside" the polygon.  Since further mesh operations
 * on NULL faces are not allowed, the main purpose is to clean up the
 * mesh so that exterior loops are not represented in the data structure.
 */
void __gl_meshDiscardExterior( GLUmesh *mesh )
{
  GLUface *f, *next;

  /*LINTED*/
  for( f = mesh->fHead.next; f != &mesh->fHead; f = next ) {
    /* Since f will be destroyed, save its next pointer. */
    next = f->next;
    if( ! f->inside ) {
      __gl_meshZapFace( f );
    }
  }
}

#define MARKED_FOR_DELETION	0x7fffffff

/* __gl_meshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
 * winding numbers on all edges so that regions marked "inside" the
 * polygon have a winding number of "value", and regions outside
 * have a winding number of 0.
 *
 * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
 * separate an interior region from an exterior one.
 */
void __gl_meshSetWindingNumber( GLUmesh *mesh, int value,
			        GLboolean keepOnlyBoundary )
{
  GLUhalfEdge *e, *eNext;

  for( e = mesh->eHead.next; e != &mesh->eHead; e = eNext ) {
    eNext = e->next;
    if( e->Rface->inside != e->Lface->inside ) {

      /* This is a boundary edge (one side is interior, one is exterior). */
      e->winding = (e->Lface->inside) ? value : -value;
    } else {

      /* Both regions are interior, or both are exterior. */
      if( ! keepOnlyBoundary ) {
	e->winding = 0;
      } else {
	__gl_meshDelete( e );
      }
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\bufpool.h ===
/* bufpool.h */

#ifndef BUFPOOL

#define BUFPOOL
#define	NBLOCKS	32

typedef enum { is_allocated = 0xf3a1, is_free = 0xf1a2 } Magic;

typedef struct _buffer {
	struct	_buffer	*next;		/* next buffer on free list	*/
} Buffer ;

typedef struct Pool {
	Buffer	*freelist;	/* linked list of free buffers		*/
	char	*blocklist[NBLOCKS];	/* blocks of malloced memory	*/
	int	nextblock;	/* next free block index		*/
	char	*curblock;	/* last malloced block			*/
	int	buffersize;	/* bytes per buffer			*/
	int	nextsize;	/* size of next block of memory		*/
	int	nextfree;	/* byte offset past next free buffer	*/
#ifndef NDEBUG
	char	*name;		/* name of the pool			*/
	Magic	magic;		/* marker for valid pool		*/
#endif
} Pool;

	
extern	Pool	*__gl_new_pool( int, int, char * );
extern	char	*__gl_new_buffer( Pool * );
extern	void	__gl_free_buffer( Pool *, void * );
extern	void	__gl_clear_pool( Pool * );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtess\tess.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <assert.h>
#include "memalloc.h"
#include "tess.h"
#include "mesh.h"
#include "normal.h"
#include "sweep.h"
#include "tessmono.h"
#include "render.h"

#define GLU_TESS_DEFAULT_TOLERANCE 0.0
#ifndef NT
#define GLU_TESS_MESH		100112	/* void (*)(GLUmesh *mesh)	    */
#endif

#define TRUE 1
#define FALSE 0

/*ARGSUSED*/ static void noBegin( GLenum type ) {}
/*ARGSUSED*/ static void noEdgeFlag( GLboolean boundaryEdge ) {}
/*ARGSUSED*/ static void noVertex( void *data ) {}
/*ARGSUSED*/ static void noEnd( void ) {}
/*ARGSUSED*/ static void noError( GLenum errno ) {}
/*ARGSUSED*/ static void noCombine( GLdouble coords[3], void *data[4],
                                    GLfloat weight[4], void **dataOut ) {}
/*ARGSUSED*/ static void noMesh( GLUmesh *mesh ) {}


/*ARGSUSED*/ void __gl_noBeginData( GLenum type, void *polygonData ) {}
/*ARGSUSED*/ void __gl_noEdgeFlagData( GLboolean boundaryEdge, 
				       void *polygonData ) {}
/*ARGSUSED*/ void __gl_noVertexData( void *data, void *polygonData ) {}
/*ARGSUSED*/ void __gl_noEndData( void *polygonData ) {}
/*ARGSUSED*/ void __gl_noErrorData( GLenum errno, void *polygonData ) {}
/*ARGSUSED*/ void __gl_noCombineData( GLdouble coords[3], void *data[4],
			 GLfloat weight[4], void **outData,
			 void *polygonData ) {}

/* Half-edges are allocated in pairs (see mesh.c) */
typedef struct { GLUhalfEdge e, eSym; } EdgePair;

#define MAX(a,b)	((a) > (b) ? (a) : (b))
#define MAX_FAST_ALLOC	(MAX(sizeof(EdgePair), \
			 MAX(sizeof(GLUvertex),sizeof(GLUface))))


#ifdef NT
GLUtesselator* APIENTRY gluNewTess( void )
#else
GLUtesselator *gluNewTess( void )
#endif
{
  GLUtesselator *tess;

  /* Only initialize fields which can be changed by the api.  Other fields
   * are initialized where they are used.
   */

  if (memInit( MAX_FAST_ALLOC ) == 0) {
     return 0;			/* out of memory */
  }
  tess = (GLUtesselator *)memAlloc( sizeof( GLUtesselator ));
  if (tess == NULL) {
     return 0;			/* out of memory */
  }

  tess->state = T_DORMANT;

  tess->normal[0] = 0;
  tess->normal[1] = 0;
  tess->normal[2] = 0;

  tess->relTolerance = GLU_TESS_DEFAULT_TOLERANCE;
  tess->windingRule = GLU_TESS_WINDING_ODD;
  tess->flagBoundary = FALSE;
  tess->boundaryOnly = FALSE;

  tess->callBegin = &noBegin;
  tess->callEdgeFlag = &noEdgeFlag;
  tess->callVertex = &noVertex;
  tess->callEnd = &noEnd;

  tess->callError = &noError;
  tess->callCombine = &noCombine;
  tess->callMesh = &noMesh;

  tess->callBeginData= &__gl_noBeginData;
  tess->callEdgeFlagData= &__gl_noEdgeFlagData;
  tess->callVertexData= &__gl_noVertexData;
  tess->callEndData= &__gl_noEndData;
  tess->callErrorData= &__gl_noErrorData;
  tess->callCombineData= &__gl_noCombineData;

  tess->polygonData= NULL;

  return tess;
}

static void MakeDormant( GLUtesselator *tess )
{
  /* Return the tesselator to its original dormant state. */

  if( tess->mesh != NULL ) {
    __gl_meshDeleteMesh( tess->mesh );
  }
  tess->state = T_DORMANT;
  tess->lastEdge = NULL;
  tess->mesh = NULL;
}

#define RequireState( tess, s )   if( tess->state != s ) GotoState(tess,s)

static void GotoState( GLUtesselator *tess, enum TessState newState )
{
#ifdef NT
  while( tess->state != (GLenum) newState ) {
#else
  while( tess->state != newState ) {
#endif
    /* We change the current state one level at a time, to get to
     * the desired state.
     */
#ifdef NT
    if( tess->state < (GLenum) newState ) {
#else
    if( tess->state < newState ) {
#endif
      switch( tess->state ) {
      case T_DORMANT:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_BEGIN_POLYGON );
	gluTessBeginPolygon( tess, NULL );
	break;
      case T_IN_POLYGON:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_BEGIN_CONTOUR );
	gluTessBeginContour( tess );
	break;
      }
    } else {
      switch( tess->state ) {
      case T_IN_CONTOUR:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_END_CONTOUR );
	gluTessEndContour( tess );
	break;
      case T_IN_POLYGON:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_END_POLYGON );
	/* gluTessEndPolygon( tess ) is too much work! */
	MakeDormant( tess );
	break;
      }
    }
  }
}


#ifdef NT
void APIENTRY gluDeleteTess( GLUtesselator *tess )
#else
void gluDeleteTess( GLUtesselator *tess )
#endif
{
  RequireState( tess, T_DORMANT );
  memFree( tess );
}


#ifdef NT
void APIENTRY gluTessProperty( GLUtesselator *tess, GLenum which, GLdouble value )
#else
void gluTessProperty( GLUtesselator *tess, GLenum which, GLdouble value )
#endif
{
  GLenum windingRule;

  switch( which ) {
  case GLU_TESS_TOLERANCE:
    if( value < 0.0 || value > 1.0 ) break;
    tess->relTolerance = value;
    return;

  case GLU_TESS_WINDING_RULE:
    windingRule = (GLenum) value;
    if( windingRule != value ) break;	/* not an integer */

    switch( windingRule ) {
    case GLU_TESS_WINDING_ODD:
    case GLU_TESS_WINDING_NONZERO:
    case GLU_TESS_WINDING_POSITIVE:
    case GLU_TESS_WINDING_NEGATIVE:
    case GLU_TESS_WINDING_ABS_GEQ_TWO:
      tess->windingRule = windingRule;
      return;
    default:
      break;
    }

  case GLU_TESS_BOUNDARY_ONLY:
    tess->boundaryOnly = (value != 0);
    return;

  default:
    CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_ENUM );
    return;
  }
  CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_VALUE );
}

/* Returns tesselator property */
#ifdef NT
void APIENTRY gluGetTessProperty( GLUtesselator *tess, GLenum which, GLdouble *value )
#else
void gluGetTessProperty( GLUtesselator *tess, GLenum which, GLdouble *value )
#endif
{
   switch (which) {
   case GLU_TESS_TOLERANCE:
      /* tolerance should be in range [0..1] */
      assert(0.0 <= tess->relTolerance && tess->relTolerance <= 1.0);
      *value= tess->relTolerance;
      break;    
   case GLU_TESS_WINDING_RULE:
      assert(tess->windingRule == GLU_TESS_WINDING_ODD ||
	     tess->windingRule == GLU_TESS_WINDING_NONZERO ||
	     tess->windingRule == GLU_TESS_WINDING_POSITIVE ||
	     tess->windingRule == GLU_TESS_WINDING_NEGATIVE ||
	     tess->windingRule == GLU_TESS_WINDING_ABS_GEQ_TWO);
      *value= tess->windingRule;
      break;
   case GLU_TESS_BOUNDARY_ONLY:
      assert(tess->boundaryOnly == TRUE || tess->boundaryOnly == FALSE);
      *value= tess->boundaryOnly;
      break;
   default:
      *value= 0.0;
      CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_ENUM );
      break;
   }
} /* gluGetTessProperty() */

#ifdef NT
void APIENTRY gluTessNormal( GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z )
#else
void gluTessNormal( GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z )
#endif
{
  tess->normal[0] = x;
  tess->normal[1] = y;
  tess->normal[2] = z;
}

#ifdef NT
void APIENTRY gluTessCallback( GLUtesselator *tess, GLenum which, void (*fn)())
#else
void gluTessCallback( GLUtesselator *tess, GLenum which, void (*fn)())
#endif
{
  switch( which ) {
  case GLU_TESS_BEGIN:
    tess->callBegin = (fn == NULL) ? &noBegin : (void (*)(GLenum)) fn;
    return;
  case GLU_TESS_BEGIN_DATA:
    tess->callBeginData = (fn == NULL) ? &__gl_noBeginData : 
                                         (void (*)(GLenum, void *)) fn;
    return;
  case GLU_TESS_EDGE_FLAG:
    tess->callEdgeFlag = (fn == NULL) ? &noEdgeFlag : (void (*)(GLboolean)) fn;
    /* If the client wants boundary edges to be flagged,
     * we render everything as separate triangles (no strips or fans).
     */
    tess->flagBoundary = (fn != NULL);
    return;
  case GLU_TESS_EDGE_FLAG_DATA:
    tess->callEdgeFlagData= (fn == NULL) ? &__gl_noEdgeFlagData :
                                           (void (*)(GLboolean, void *)) fn; 
    /* If the client wants boundary edges to be flagged,
     * we render everything as separate triangles (no strips or fans).
     */
    tess->flagBoundary = (fn != NULL);
    return;
  case GLU_TESS_VERTEX:
    tess->callVertex = (fn == NULL) ? &noVertex : (void (*)(void *)) fn;
    return;
  case GLU_TESS_VERTEX_DATA:
    tess->callVertexData = (fn == NULL) ? &__gl_noVertexData : 
                                          (void (*)(void *, void *)) fn;
    return;
  case GLU_TESS_END:
    tess->callEnd = (fn == NULL) ? &noEnd : (void (*)(void)) fn;
    return;
  case GLU_TESS_END_DATA:
    tess->callEndData = (fn == NULL) ? &__gl_noEndData : 
                                       (void (*)(void *)) fn;
    return;
  case GLU_TESS_ERROR:
    tess->callError = (fn == NULL) ? &noError : (void (*)(GLenum)) fn;
    return;
  case GLU_TESS_ERROR_DATA:
    tess->callErrorData = (fn == NULL) ? &__gl_noErrorData : 
                                         (void (*)(GLenum, void *)) fn;
    return;
  case GLU_TESS_COMBINE:
    tess->callCombine = (fn == NULL) ? &noCombine :
	(void (*)(GLdouble [3],void *[4], GLfloat [4], void ** )) fn;
    return;
  case GLU_TESS_COMBINE_DATA:
    tess->callCombineData = (fn == NULL) ? &__gl_noCombineData :
                                           (void (*)(GLdouble [3],
						     void *[4], 
						     GLfloat [4], 
						     void **,
						     void *)) fn;
    return;
#ifndef NT
  case GLU_TESS_MESH:
    tess->callMesh = (fn == NULL) ? &noMesh : (void (*)(GLUmesh *)) fn;
    return;
#endif
  default:
    CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_ENUM );
    return;
  }
}

static void AddVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
{
  GLUhalfEdge *e;

  e = tess->lastEdge;
  if( e == NULL ) {
    /* Make a self-loop (one vertex, one edge). */

    e = __gl_meshMakeEdge( tess->mesh );
    __gl_meshSplice( e, e->Sym );
  } else {
    /* Create a new vertex and edge which immediately follow e
     * in the ordering around the left face.
     */
    (void) __gl_meshSplitEdge( e );
    e = e->Lnext;
  }

  /* The new vertex is now e->Org. */
  e->Org->data = data;
  e->Org->coords[0] = coords[0];
  e->Org->coords[1] = coords[1];
  e->Org->coords[2] = coords[2];
  
  /* The winding of an edge says how the winding number changes as we
   * cross from the edge''s right face to its left face.  We add the
   * vertices in such an order that a CCW contour will add +1 to
   * the winding number of the region inside the contour.
   */
  e->winding = 1;
  e->Sym->winding = -1;

  tess->lastEdge = e;
}


static void CacheVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
{
  CachedVertex *v = &tess->cache[tess->cacheCount];

  v->data = data;
  v->coords[0] = coords[0];
  v->coords[1] = coords[1];
  v->coords[2] = coords[2];
  ++tess->cacheCount;
}


static void EmptyCache( GLUtesselator *tess )
{
  CachedVertex *v = tess->cache;
  CachedVertex *vLast;

  tess->mesh = __gl_meshNewMesh();

  for( vLast = v + tess->cacheCount; v < vLast; ++v ) {
    AddVertex( tess, v->coords, v->data );
  }
  tess->cacheCount = 0;
  tess->emptyCache = FALSE;
}


#ifdef NT
void APIENTRY gluTessVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
#else
void gluTessVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
#endif
{
  int i, tooLarge = FALSE;
  GLdouble x, clamped[3];

  RequireState( tess, T_IN_CONTOUR );

  if( tess->emptyCache ) {
    EmptyCache( tess );
    tess->lastEdge = NULL;
  }
  for( i = 0; i < 3; ++i ) {
    x = coords[i];
    if( x < - GLU_TESS_MAX_COORD ) {
      x = - GLU_TESS_MAX_COORD;
      tooLarge = TRUE;
    }
    if( x > GLU_TESS_MAX_COORD ) {
      x = GLU_TESS_MAX_COORD;
      tooLarge = TRUE;
    }
    clamped[i] = x;
  }
  if( tooLarge ) {
    CALL_ERROR_OR_ERROR_DATA( GLU_TESS_COORD_TOO_LARGE );
  }

  if( tess->mesh == NULL ) {
    if( tess->cacheCount < TESS_MAX_CACHE ) {
      CacheVertex( tess, clamped, data );
      return;
    }
    EmptyCache( tess );
  }
  AddVertex( tess, clamped, data );
}


#ifdef NT
void APIENTRY gluTessBeginPolygon( GLUtesselator *tess, void *data )
#else
void gluTessBeginPolygon( GLUtesselator *tess, void *data )
#endif
{
  RequireState( tess, T_DORMANT );

  tess->state = T_IN_POLYGON;
  tess->cacheCount = 0;
  tess->emptyCache = FALSE;
  tess->mesh = NULL;

  tess->polygonData= data;
}


#ifdef NT
void APIENTRY gluTessBeginContour( GLUtesselator *tess )
#else
void gluTessBeginContour( GLUtesselator *tess )
#endif
{
  RequireState( tess, T_IN_POLYGON );

  tess->state = T_IN_CONTOUR;
  tess->lastEdge = NULL;
  if( tess->cacheCount > 0 ) {
    /* Just set a flag so we don't get confused by empty contours
     * -- these can be generated accidentally with the obsolete
     * NextContour() interface.
     */
    tess->emptyCache = TRUE;
  }
}


#ifdef NT
void APIENTRY gluTessEndContour( GLUtesselator *tess )
#else
void gluTessEndContour( GLUtesselator *tess )
#endif
{
  RequireState( tess, T_IN_CONTOUR );
  tess->state = T_IN_POLYGON;
}


#ifdef NT
void APIENTRY gluTessEndPolygon( GLUtesselator *tess )
#else
void gluTessEndPolygon( GLUtesselator *tess )
#endif
{
  GLUmesh *mesh;

  RequireState( tess, T_IN_POLYGON );
  tess->state = T_DORMANT;

  if( tess->mesh == NULL ) {
    if( ! tess->flagBoundary && tess->callMesh == &noMesh ) {

      /* Try some special code to make the easy cases go quickly
       * (eg. convex polygons).  This code does NOT handle multiple contours,
       * intersections, edge flags, and of course it does not generate
       * an explicit mesh either.
       */
      if( __gl_renderCache( tess )) {
	tess->polygonData= NULL; 
	return;
      }
    }
    EmptyCache( tess );
  }

  /* Determine the polygon normal and project vertices onto the plane
   * of the polygon.
   */
  __gl_projectPolygon( tess );

  /* __gl_computeInterior( tess ) computes the planar arrangement specified
   * by the given contours, and further subdivides this arrangement
   * into regions.  Each region is marked "inside" if it belongs
   * to the polygon, according to the rule given by tess->windingRule.
   * Each interior region is guaranteed be monotone.
   */
  __gl_computeInterior( tess );

  mesh = tess->mesh;
  if( ! tess->fatalError ) {
    /* If the user wants only the boundary contours, we throw away all edges
     * except those which separate the interior from the exterior.
     * Otherwise we tesselate all the regions marked "inside".
     */
    if( tess->boundaryOnly ) {
      __gl_meshSetWindingNumber( mesh, 1, TRUE );
    } else {
      __gl_meshTesselateInterior( mesh );
    }
    __gl_meshCheckMesh( mesh );

    if( tess->callBegin != &noBegin || tess->callEnd != &noEnd
       || tess->callVertex != &noVertex || tess->callEdgeFlag != &noEdgeFlag 
       || tess->callBeginData != &__gl_noBeginData 
       || tess->callEndData != &__gl_noEndData
       || tess->callVertexData != &__gl_noVertexData
       || tess->callEdgeFlagData != &__gl_noEdgeFlagData )
    {
      if( tess->boundaryOnly ) {
	__gl_renderBoundary( tess, mesh );  /* output boundary contours */
      } else {
	__gl_renderMesh( tess, mesh );	   /* output strips and fans */
      }
    }
    if( tess->callMesh != &noMesh ) {

      /* Throw away the exterior faces, so that all faces are interior.
       * This way the user doesn't have to check the "inside" flag,
       * and we don't need to even reveal its existence.  It also leaves
       * the freedom for an implementation to not generate the exterior
       * faces in the first place.
       */
      __gl_meshDiscardExterior( mesh );
      (*tess->callMesh)( mesh );		/* user wants the mesh itself */
      tess->mesh = NULL;
      tess->polygonData= NULL;
      return;
    }
  }
  __gl_meshDeleteMesh( mesh );
  tess->polygonData= NULL;
  tess->mesh = NULL;
}


#ifndef NT
void gluDeleteMesh( GLUmesh *mesh )
{
  __gl_meshDeleteMesh( mesh );
}
#endif


/*******************************************************/

/* Obsolete calls -- for backward compatibility */

#ifdef NT
void APIENTRY gluBeginPolygon( GLUtesselator *tess )
#else
void gluBeginPolygon( GLUtesselator *tess )
#endif
{
  gluTessBeginPolygon( tess, NULL );
  gluTessBeginContour( tess );
}


/*ARGSUSED*/
#ifdef NT
void APIENTRY gluNextContour( GLUtesselator *tess, GLenum type )
#else
void gluNextContour( GLUtesselator *tess, GLenum type )
#endif
{
  gluTessEndContour( tess );
  gluTessBeginContour( tess );
}


#ifdef NT
void APIENTRY gluEndPolygon( GLUtesselator *tess )
#else
void gluEndPolygon( GLUtesselator *tess )
#endif
{
  gluTessEndContour( tess );
  gluTessEndPolygon( tess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\class.c ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1989, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* class.c */

/* Derrick Burns - 1989 */

#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "monotone.h"

/*----------------------------------------------------------------------------
 * classify - classify a vertex 
 *----------------------------------------------------------------------------
 */

static Vertclass
classify( Vert *vert )
{
    float   det;
    float   ps, pt, ns, nt, ms, mt;

    ps = vert->prev->s;
    pt = vert->prev->t;
    ms = vert->s;
    mt = vert->t;
    ns = vert->next->s;
    nt = vert->next->t;

    if ((ps < ms) && (ms < ns)) return VC_OK_TOP;
    if ((ps > ms) && (ms > ns)) return VC_OK_BOTTOM;

    if (ps == ms) {
	if (ms == ns) {
	    if (pt < mt) 
		 return VC_OK_TOP;
	    else if( pt == mt )
		 return VC_BAD_LONE;
	    else
		return VC_OK_BOTTOM;
	}
	if (pt < mt) {
	    if (ns < ms) return VC_OK_LEFT;
	    return VC_OK_TOP;
	}
	if (pt > mt) {
	    if (ns <= ms) return VC_OK_BOTTOM;
	    return VC_OK_RIGHT;
	}
	return VC_BAD_ERROR;
    }
    if (ms == ns) {
	if (nt < mt) {
	    if (ps >= ms) return VC_OK_BOTTOM;
	    return VC_BAD_RIGHT;
	}
	if (nt > mt) {
	    if (ms >= ps) return VC_OK_TOP;
	    return VC_BAD_LEFT;
	}
	return VC_BAD_ERROR;
    }

    /* Calculate determinant of:
     *
     *     | ps pt 1 |
     *     | ms mt 1 |
     *     | ns nt 1 |
     */

    det = ms*(nt-pt)+ns*(pt-mt)+ps*(mt-nt);

    if ((ps < ms) && (ns < ms)) {
	if (det < (float)0) return VC_BAD_RIGHT;
	if (det > (float)0) return VC_OK_LEFT;
	if (det == (float)0) return VC_BAD_ERROR;
    }
    if ((ps > ms) && (ns > ms)) {
	if (det < (float)0) return VC_BAD_LEFT;
	if (det > (float)0) return VC_OK_RIGHT;
	if (det == (float)0) return VC_BAD_ERROR;
    }
    return VC_BAD_ERROR;
}

/*----------------------------------------------------------------------------
 * unclassify_all - unclassify all vertices in a loop 
 *----------------------------------------------------------------------------
 */

void
__gl_unclassify_all( Vert *vert )
{
    Vert *last = vert;
    do {
	vert->vclass = VC_NO_CLASS;
	vert = vert->next;
    } while( vert != last );
}

/*----------------------------------------------------------------------------
 * classify_all - classify all vertices in a loop 
 *----------------------------------------------------------------------------
 */

int
__gl_classify_all( Vert *vert )
{
    int f = 0;
    Vert *last = vert;

    do {
	vert->nextid = vert->next->myid;
	vert->vclass = classify( vert );
	f |= vert->vclass;
	vert = vert->next;
    } while( vert != last );
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\interfac.c ===
/**************************************************************************
 *                                                                        *
 *               Copyright (C) 1989, Silicon Graphics, Inc.               *
 *                                                                        *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *                                                                        *
 **************************************************************************/

/* interface.c */

/* Derrick Burns - 1989 */

#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>

#ifndef NT
#include <stdlib.h>
#else
#include "winmem.h"
#include "bufpool.h"
#endif

#include "monotone.h"

static void     do_out_finish(GLUtriangulatorObj *);
static void     __gluTessEndContour(GLUtriangulatorObj *tobj);

GLUtriangulatorObj * APIENTRY gluNewTess(void)
{
    GLUtriangulatorObj *tobj;
    tobj = (GLUtriangulatorObj *) malloc(sizeof(GLUtriangulatorObj));
    tobj->init = 0;
    tobj->minit = 0;
    tobj->in_poly = 0;
    tobj->doingTriangles = 0;
    tobj->tritype = GL_TRIANGLES;
    tobj->vpool = 0;
    tobj->raypool = 0;
    tobj->begin = NULL;
    tobj->end = NULL;
    tobj->vertex = NULL;
    tobj->error = NULL;
    tobj->edgeflag = NULL;
    tobj->parray = (Vert **)NULL;
    tobj->inBegin = GL_FALSE;
    tobj->s = 0;
    tobj->t = 0;
    return tobj;
}

void APIENTRY
gluTessCallback(GLUtriangulatorObj *tobj, GLenum which, void (CALLBACK *fn)())
{
    switch(which) {
      case GLU_BEGIN:
        #ifndef NT
        tobj->begin = (void (*)(GLenum)) fn;
        #else
        tobj->begin = (GLUtessBeginProc) fn;
        #endif
        break;
      case GLU_VERTEX:
        #ifndef NT
        tobj->vertex = (void (*)(void *)) fn;
        #else
        tobj->vertex = (GLUtessVertexProc) fn;
        #endif
        break;
      case GLU_END:
        #ifndef NT
        tobj->end = (void (*)(void)) fn;
        #else
        tobj->end = (GLUtessEndProc) fn;
        #endif
        break;
      case GLU_ERROR:
        #ifndef NT
        tobj->error = (void (*)(GLenum)) fn;
        #else
        tobj->error = (GLUtessErrorProc) fn;
        #endif
        break;
      case GLU_EDGE_FLAG:
        #ifndef NT
        tobj->edgeflag = (void (*)(GLboolean)) fn;
        #else
        tobj->edgeflag = (GLUtessEdgeFlagProc) fn;
        #endif
        break;
      default:
        /* XXX */
        break;
    }
}

void APIENTRY
gluDeleteTess(GLUtriangulatorObj *t)
{
#ifdef NT
    extern void __gl_free_pool( Pool * );
#endif

    __gl_free_priorityq(t);
    if (t->raypool) __gl_free_pool(t->raypool);
    if (t->vpool) __gl_free_pool(t->vpool);
    __gl_clear_triangulate(t);
    __gl_clear_sort(t);
    free(t);
}

/*---------------------------------------------------------------------------
 * gluBeginPolygon - called before each input polygon
 *---------------------------------------------------------------------------
 */

void APIENTRY
gluBeginPolygon(GLUtriangulatorObj *tobj)
{
    if(setjmp(tobj->in_env) != 0)
        return;

    if (tobj->in_poly++) {
        __gl_in_error(tobj, 1);
    }

    /* 17 arbitrarily */
    __gl_init_priorityq(tobj, 17);
    __gl_init_verts(tobj);
    __gl_init_raylist(tobj);

    tobj->nloops =  0;
    tobj->maxarea = (float)0.0;
    tobj->head = 0;
    tobj->looptype = GLU_EXTERIOR;
}

/*---------------------------------------------------------------------------
 * gluEndPolygon - called after each input polygon
 *---------------------------------------------------------------------------
 */

void APIENTRY
gluEndPolygon(GLUtriangulatorObj *tobj)
{
#ifdef NT
    extern void __gl_setpriority_priorityq( GLUtriangulatorObj *, int, int);
#endif

    if(setjmp(tobj->in_env) != 0)
        return;

    if (--tobj->in_poly) {
        __gl_in_error(tobj, 2);
    }

    if (tobj->head) {
        __gluTessEndContour(tobj);
    }

    /* Set edge flag to -1 so that if the user wants edge flag info, we
    ** specify an edge flag for the first edge regardless (then we only
    ** report changes).
    */
    tobj->currentEdgeFlag = (GLboolean) -1;

    __gl_setpriority_priorityq(tobj, tobj->s, tobj->t);

    __gl_monotonize(tobj);
    do_out_finish(tobj);
    __gl_free_verts(tobj);
    __gl_free_priorityq(tobj);
    __gl_free_raylist(tobj);
}

static void
do_out_finish(GLUtriangulatorObj *tobj)
{
    if (tobj->doingTriangles) {
        if (tobj->end) {
            (*tobj->end)();
            tobj->inBegin = GL_FALSE;
        }
        tobj->doingTriangles = 0;
    }
}

/*---------------------------------------------------------------------------
 * gluNextContour - called before each input boundary loop
 *---------------------------------------------------------------------------
 */

void APIENTRY
gluNextContour(GLUtriangulatorObj *tobj, GLenum type)
{
    if(setjmp(tobj->in_env) != 0)
        return;

    if(!tobj->in_poly) {
        __gl_in_error(tobj, 2);
    }

    if (tobj->head) {
        __gluTessEndContour(tobj);
    }

    tobj->head = 0;
    tobj->looptype = type;
}

/*---------------------------------------------------------------------------
 * gluTessEndContour - called after each input boundary loop
 *---------------------------------------------------------------------------
 */

static void
__gluTessEndContour(GLUtriangulatorObj *tobj)
{
    double xyarea, xzarea, yzarea;
    Vert *v;

    tobj->nloops++;
    xyarea = xzarea = yzarea = 0.0;

    v = tobj->head;

    do {
        xyarea += v->v[0] * v->next->v[1] - v->v[1] * v->next->v[0];
        xzarea += v->v[0] * v->next->v[2] - v->v[2] * v->next->v[0];
        yzarea += v->v[1] * v->next->v[2] - v->v[2] * v->next->v[1];
        v = v->next;
    } while(v != tobj->head);

    if(xyarea < 0.0) {
        if(-xyarea > tobj->maxarea) {
            tobj->maxarea = -xyarea; tobj->s =  1; tobj->t = 0;
        }
    } else {
        if(xyarea > tobj->maxarea) {
            tobj->maxarea = xyarea; tobj->s =  0; tobj->t = 1;
        }
    }

    if(xzarea < 0.0) {
        if(-xzarea > tobj->maxarea) {
            tobj->maxarea = -xzarea; tobj->s =  2; tobj->t = 0;
        }
    } else {
         if(xzarea > tobj->maxarea) {
            tobj->maxarea = xzarea; tobj->s =  0; tobj->t = 2;
        }
    }

    if(yzarea < 0.0) {
        if(-yzarea > tobj->maxarea) {
            tobj->maxarea = -yzarea; tobj->s =  2; tobj->t = 1;
        }
    } else {
        if(yzarea > tobj->maxarea) {
            tobj->maxarea = yzarea; tobj->s =  1; tobj->t = 2;
        }
    }

    __gl_unclassify_all(tobj->head);
}

/*---------------------------------------------------------------------------
 * gluTessVertex - called for each input vertex
 *---------------------------------------------------------------------------
 */

void APIENTRY
gluTessVertex(GLUtriangulatorObj *tobj, GLdouble v[3], void *data)
{
    Vert *vert;

    if(setjmp(tobj->in_env) != 0)
        return;

    if(!tobj->in_poly) {
        __gl_in_error(tobj, 2);
    }

    vert = __gl_new_vert(tobj);
    vert->myid = vert;

    vert->v[0] = v[0];
    vert->v[1] = v[1];
    vert->v[2] = v[2];
    vert->ray = 0;
    vert->data = data;
#ifdef ADDED
    vert->added = 0;
#endif
    if(tobj->head == 0) {
        tobj->head = vert->prev = vert->next = vert;
    } else {
        vert->prev = tobj->head->prev;
        vert->next = tobj->head;
        vert->prev->next = vert;
        vert->next->prev = vert;
    }
    __gl_add_priorityq(tobj, vert);
}

/*----------------------------------------------------------------------------
 * in_error - data input error, free all storage
 *----------------------------------------------------------------------------
 */

void
__gl_in_error(GLUtriangulatorObj *tobj, GLenum which)
{
    __gl_clear_sort(tobj);
    __gl_clear_triangulate(tobj);
    __gl_free_raylist(tobj);
    __gl_free_verts(tobj);
    __gl_free_priorityq(tobj);
    __gl_cleanup(tobj);
    tobj->in_poly = 0;
    if (tobj->error) {
        (*tobj->error)(which + (GLU_TESS_ERROR1 - 1));
    }
    longjmp(tobj->in_env, (int) which);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\monotone.h ===
/**************************************************************************
 *                                                                        *
 *               Copyright (C) 1989, Silicon Graphics, Inc.               *
 *                                                                        *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *                                                                        *
 **************************************************************************/

#ifndef MONOTONE_H
#define MONOTONE_H
/* monotone.h */

/* Derrick Burns - 1989 */

#include <assert.h>
#include <setjmp.h>
#include <stdio.h>
#include "triangul.h"

#define INITVERTS       256
#define INITVPSIZE      256

#define VC_BAD             0x01
#define VC_OK              0x02
#define VC_LEFT            0x04
#define VC_RIGHT           0x08
#define VC_TOP             0x10
#define VC_BOTTOM          0x20
#define VC_LONE            0x40
#define VC_ERROR           0x80

enum _Vertclass {
    VC_NO_CLASS    = 0,
    VC_OK_RIGHT    = VC_OK  | VC_RIGHT,
    VC_OK_LEFT     = VC_OK  | VC_LEFT,
    VC_OK_TOP      = VC_OK  | VC_TOP,
    VC_OK_BOTTOM   = VC_OK  | VC_BOTTOM,
    VC_BAD_RIGHT   = VC_BAD | VC_RIGHT,
    VC_BAD_LEFT    = VC_BAD | VC_LEFT,
    VC_BAD_LONE    = VC_BAD | VC_LONE,
    VC_BAD_ERROR   = VC_BAD | VC_ERROR
};

typedef enum _Vertclass Vertclass;

typedef struct Vert {
    struct Vert *next;
    struct Vert *prev;
    struct Ray  *ray;
    Vertclass   vclass;
#ifdef ADDED
    char        added;
#endif
    void        *myid;
    void        *nextid;
    float       s;
    float       t;
    double      v[3];
    void        *data;
} Vert;

typedef struct Ray {
    struct Ray  *next;
    struct Ray  *prev;
    struct Vert *vertex;
#ifdef LAZYRECALC
    struct Vert *end1;          /* ray's zNear endpoint */
    struct Vert *end2;          /* ray's zFar endpoint */
#endif
    int         orientation;
    int         mustconnect;    /* 1 if mustconnect, 0 otherwise */
    float       coords[3];      /* ax + by + c.  Assume b >= 0. */
} Ray;

extern  void    __gl_init_verts( GLUtriangulatorObj * );
extern  void    __gl_free_verts( GLUtriangulatorObj * );

extern  Vert    *__gl_new_vert( GLUtriangulatorObj * );
extern  Vert    *__gl_first_vert( Vert * );
extern  Vert    *__gl_last_vert( Vert * );
extern  short   __gl_ccw_vert( Vert * );
extern  void    __gl_reverse_vert( Vert * );
extern  void    __gl_checkray_vert( GLUtriangulatorObj *, Vert *, Ray *, Ray * );
extern  long    __gl_orient_vert( Vert *, GLenum );

extern  Ray *   __gl_new_ray( GLUtriangulatorObj *, int );
extern  int     __gl_above_ray( Ray *, Vert * );
extern  void    __gl_recalc_ray( Ray *, Vert *, Vert * );

extern  void    __gl_init_raylist( GLUtriangulatorObj * );
extern  void    __gl_add2_raylist( Ray *, Ray *, Ray * );
extern  void    __gl_remove2_raylist( GLUtriangulatorObj *, Ray * );
extern  void    __gl_delete_ray( GLUtriangulatorObj *, Ray * );

extern  Ray     *__gl_findray_raylist( GLUtriangulatorObj *, Vert *v);
extern  void    __gl_free_raylist( GLUtriangulatorObj * );

extern  void    __gl_clear_triangulate( GLUtriangulatorObj * );
extern  void    __gl_triangulate( GLUtriangulatorObj *, Vert *, long );
extern  void    __gl_checktriangulate( GLUtriangulatorObj *, Vert * );

extern  void    __gl_init_priorityq( GLUtriangulatorObj *, long );
extern  void    __gl_add_priorityq( GLUtriangulatorObj *,Vert *v );
extern  int     __gl_more_priorityq( GLUtriangulatorObj * );
extern  void    __gl_sort_priorityq( GLUtriangulatorObj * );
extern  Vert *  __gl_remove_priorityq( GLUtriangulatorObj * );
extern  void    __gl_free_priorityq( GLUtriangulatorObj * );

extern  void    __gl_unclassify_all( Vert * );
extern  int     __gl_classify_all( Vert * );

extern void     __gl_monotonize( GLUtriangulatorObj * );
extern void     __gl_clear_sort( GLUtriangulatorObj * );
extern void     __gl_triangulateloop( GLUtriangulatorObj *, Vert *);

#ifndef NT
#define mymalloc malloc
#define myfree free
#define myrealloc realloc
#else
#include <windows.h>

#define mymalloc(size)      LocalAlloc(LMEM_FIXED, (size))
#define myfree(p)           LocalFree((p))
#define myrealloc(p, size)  LocalReAlloc((p), (size), LMEM_MOVEABLE)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\msort.h ===
#ifndef MSORT_H
#define MSORT_H

typedef	int		(*SortFunc)( void **, void ** );
extern	void 		__gl_msort(GLUtriangulatorObj *, void **, long,long, SortFunc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\errorstr.c ===
#include <glos.h>

#ifdef NT
#include "glstring.h"
#endif

#ifndef NT

static const char *errors[] = {
    "",
    "missing gluEndPolygon",
    "missing gluBeginPolygon",
    "bad orientation or intersecting edges",
    "vertex/edge intersection",
    "misoriented or self-intersecting loops",
    "coincident vertices",
    "illegal data",
    "intersecting edges"
};

#else

static UINT auiTessErrors[] = {
    STR_TESS_EMPTY         ,    // ""
    STR_TESS_END_POLY      ,    // "missing gluEndPolygon"
    STR_TESS_BEGIN_POLY    ,    // "missing gluBeginPolygon"
    STR_TESS_BAD_EDGE      ,    // "bad orientation or intersecting edges"
    STR_TESS_INTERSECT     ,    // "vertex/edge intersection"
    STR_TESS_BAD_LOOP      ,    // "misoriented or self-intersecting loops"
    STR_TESS_VERTICES      ,    // "coincident vertices"
    STR_TESS_BAD_DATA      ,    // "illegal data"
    STR_TESS_INTERSECT_EDGE     // "intersecting edges"
};

#define NERRORS ( sizeof(auiTessErrors)/sizeof(auiTessErrors[0]) )

static char *errors[NERRORS];
static WCHAR *errorsW[NERRORS];

#endif

const char *__glTessErrorString(int errno)
{
    return (const char *) errors[errno];
}


#ifdef NT

const WCHAR *__glTessErrorStringW(int errno)
{
    return (const WCHAR *) errorsW[errno];
}

VOID vInitTessStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        for (i = 0; i < NERRORS; i++)
            errors[i] = pszGetResourceStringA(hMod, auiTessErrors[i]);
    }
    else
    {
        for (i = 0; i < NERRORS; i++)
            errorsW[i] = pwszGetResourceStringW(hMod, auiTessErrors[i]);
    }
}

#endif /* NT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\monotoni.c ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1989, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* monotonize.c */

/* Derrick Burns - 1989 */

#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "monotone.h"

static Vert *	__gl_connectedge( GLUtriangulatorObj *, Vert *, Vert * );

/*----------------------------------------------------------------------------
 * monotonize - add edges to a polygon to create monotone pieces
 *----------------------------------------------------------------------------
 */

void
__gl_monotonize(  GLUtriangulatorObj *tobj )
{
    Ray		*ray, *new_ray1, *new_ray2;

    __gl_sort_priorityq( tobj );
    while( __gl_more_priorityq( tobj ) ) {
	Vert *vert = __gl_remove_priorityq( tobj );

 	if( vert->vclass == VC_NO_CLASS ) {
	    ray = __gl_findray_raylist( tobj, vert );
	    if( ray->orientation == __gl_ccw_vert( vert ) )
		__gl_reverse_vert( vert );
	    (void) __gl_classify_all( vert );
	}

	switch (vert->vclass) {

	    case VC_OK_RIGHT: /* two new rays */

		assert( vert->ray == 0 );

	        ray = __gl_findray_raylist( tobj, vert );

		if( ray->orientation != 0 )
		    __gl_in_error( tobj, 3 );

		/* compute top ray */
		new_ray1 = __gl_new_ray( tobj, 0 );
		__gl_recalc_ray(new_ray1, vert, vert->prev);
		if( vert->prev->vclass != VC_BAD_RIGHT )
			vert->prev->ray = new_ray1;

		/* compute middle ray */
		new_ray2 = __gl_new_ray( tobj, 1 );
		__gl_recalc_ray(new_ray2, vert, vert->next);
		if( vert->next->vclass != VC_OK_LEFT )
			vert->next->ray = new_ray2;

		new_ray2->vertex = vert;

		assert( ! ray->mustconnect );

		__gl_add2_raylist( ray->prev, new_ray1, new_ray2 );

		break;

	    case VC_BAD_LEFT: /* two new rays */

		assert( vert->ray == 0 );

	 	ray = __gl_findray_raylist( tobj, vert );

		if( ray->orientation != 1 )
		    __gl_in_error( tobj, 3 );

		/* compute top ray */
		new_ray1 = __gl_new_ray( tobj, 1 );
		__gl_recalc_ray(new_ray1, vert, vert->next);
		if( vert->next->vclass != VC_OK_LEFT )
			vert->next->ray = new_ray1;

		/* compute middle ray */
		new_ray2 = __gl_new_ray( tobj, 0 );
		__gl_recalc_ray(new_ray2, vert, vert->prev);
		if( vert->prev->vclass != VC_BAD_RIGHT )
			vert->prev->ray = new_ray2;

		new_ray1->vertex = __gl_connectedge( tobj,vert, ray->vertex);

		/* update bottom ray */
		ray->mustconnect = 0;
		ray->vertex = vert;

		__gl_add2_raylist( ray->prev, new_ray1, new_ray2 );

		break;

	    case VC_OK_LEFT:   /* two rays disappear */
		ray = vert->ray;
		if ( ray == NULL )
		    __gl_in_error( tobj, 4 );
		__gl_checkray_vert( tobj, vert, ray->prev, ray->next->next );
		/* region above_ray top ray is outside */
		assert( ! ray->mustconnect ); 
		assert( ray->next ); 

		/* region above_ray middle ray is inside */
		if( ray->next->mustconnect ) {
		    __gl_triangulateloop( tobj,__gl_connectedge( tobj,vert,ray->next->vertex));
		    __gl_triangulateloop( tobj, vert );
		} else { 
		    __gl_triangulateloop( tobj, vert );
		}

		/* region above_ray bottom ray is outside */
		assert( ray->next->next );
		assert( ! ray->next->next->mustconnect );

		__gl_remove2_raylist( tobj, ray );
		__gl_delete_ray( tobj, ray->next );
		__gl_delete_ray( tobj, ray );
		break;

	    case VC_BAD_RIGHT: /* two rays disappear */
		ray = vert->ray;
		if ( ray == NULL || ray->next == NULL )
		    __gl_in_error( tobj, 4 );
		__gl_checkray_vert( tobj, vert, ray->prev, ray->next->next );
		if (ray->mustconnect) {
		    vert = __gl_connectedge( tobj, vert, ray->vertex );
		    __gl_triangulateloop( tobj, ray->vertex->next );
		} 

		if ( ray->next->mustconnect ) {
		    __gl_in_error( tobj, 8 );
		}

		assert( ray->next ); 
		assert( ray->next->next );

		if (ray->next->next->mustconnect)
		    __gl_triangulateloop( tobj, __gl_connectedge( tobj, vert,
					ray->next->next->vertex) );
		ray->next->next->vertex = vert;
		ray->next->next->mustconnect = 1;
		__gl_remove2_raylist( tobj, ray );
		__gl_delete_ray( tobj, ray->next );
		__gl_delete_ray( tobj, ray );
		break;

	    case VC_OK_TOP: /* one ray changes ends and coords */
		ray = vert->ray;
		if( ray == NULL || ray->next == NULL ) 
		    __gl_in_error( tobj, 4 );
		__gl_checkray_vert( tobj, vert, ray->prev, ray->next ); 
		__gl_recalc_ray( ray, vert, vert->next );
		if( vert->next->vclass != VC_OK_LEFT )
			vert->next->ray = ray;

		if (ray->mustconnect) {
		    ray->vertex = __gl_connectedge( tobj,vert,ray->vertex);
		    ray->mustconnect = 0;
		    __gl_triangulateloop( tobj, vert );
		} else {
		    ray->vertex = vert;
		}

		assert( ray->next );
		assert( ! ray->next->mustconnect );
		
		break;

	    case VC_OK_BOTTOM: /* one ray changes ends and coords */
		ray = vert->ray;
		if ( ray == NULL || ray->next == NULL )
		    __gl_in_error( tobj, 4 );
		__gl_checkray_vert( tobj, vert, ray->prev, ray->next ); 
		__gl_recalc_ray( ray, vert, vert->prev );
		if( vert->prev->vclass != VC_BAD_RIGHT )
			vert->prev->ray = ray;

		assert( ! ray->mustconnect );
		assert( ray->next );

		if (ray->next->mustconnect) {
		    __gl_triangulateloop( tobj,__gl_connectedge( tobj,vert, ray->next->vertex));
		    ray->next->mustconnect = 0;
		    ray->next->vertex = vert;
		} else {
		    ray->next->vertex = vert;
		}

		break;

	    case VC_BAD_LONE:
		break;

	    case VC_BAD_ERROR:
		__gl_in_error( tobj, 4 );
		return;

	    case VC_NO_CLASS:
		assert( 0 );
		break;
	}
    }
    return;
}
 
/*----------------------------------------------------------------------------
 * connectedge - create two anti-parallel edges splitting a polygon
 *----------------------------------------------------------------------------
 */

static Vert *
__gl_connectedge( GLUtriangulatorObj *tobj, Vert *x, Vert *y )
{
    Vert	*newx, *newy;

    if( x == 0 || y == 0 || y->prev == 0 || x->next == 0 ) {
	__gl_in_error( tobj, 5 );
 	return 0;
    } else {
	assert( x->prev->next == x );
	assert( x->next->prev == x );
	assert( y->prev->next == y );
	assert( y->next->prev == y );
	assert( x->next != y );
	assert( x != y );

        newx = (Vert *) __gl_new_vert( tobj );
	newx->myid = x->myid;
	newx->nextid = x->nextid;
 	newx->ray = x->ray;
 	newx->vclass = x->vclass;
#ifdef ADDED
 	newx->added = x->added;
#endif
 	newx->s = x->s;
 	newx->t = x->t;
 	newx->data = x->data;

        newy = (Vert *) __gl_new_vert( tobj );
	newy->myid = y->myid;
	newy->nextid = y->nextid;
 	newy->ray = y->ray;
 	newy->vclass = y->vclass;
#ifdef ADDED
        newy->added = 1;
#endif
 	newy->s = y->s;
 	newy->t = y->t;
 	newy->data = y->data;

        newx->prev = newy;
	newx->next = x->next;
        newy->next = newx;
	newy->prev = y->prev;
	newx->next->prev = newx;
	newy->prev->next = newy;
        x->next = y;
        y->prev = x;
#ifdef ADDED
        x->added = 1;
#endif
	assert( x->prev->next == x );
	assert( x->next->prev == x );
	assert( y->prev->next == y );
	assert( y->next->prev == y );
	assert( newx->prev->next == newx );
	assert( newx->next->prev == newx );
	assert( newy->prev->next == newy );
	assert( newy->next->prev == newy );
        return newx;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\msort.c ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1989, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* msort.c */

/*
	Tom Davis - 1988
	Derrick Burns - 1989
 */

#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>

#ifndef NT
#include <assert.h>
#include <stdlib.h>
#else
#include "winmem.h"
#endif

#include "monotone.h"
#include "msort.h"

/* code to do a merge sort where we assume that the initial data tends
 * to make long runs, either up or down.
 */

#define INITSORT 50


/*---------------------------------------------------------------------------
 * init_sort - initialize merge sort data structures
 *---------------------------------------------------------------------------
 */

void
__gl_init_sort( GLUtriangulatorObj *tobj, long n )
{
    if( n == 0 ) return;
    if( tobj->minit ) {
	if( n > tobj->size ) {
	    free( tobj->ptrlist );
	    free( tobj->limits );	
	    free( tobj->dirs );
            tobj->size = n * 2;
            tobj->ptrlist = (void **)
		malloc((unsigned int)tobj->size*sizeof(void *) );
            tobj->limits = (long *)
		malloc((unsigned int)(tobj->size+1)*sizeof(long) );
            tobj->dirs = (enum updown *)
                malloc((unsigned int)tobj->size*sizeof(enum updown) );
	} 
    } else {
        tobj->size = n;
        tobj->ptrlist = (void **)
		malloc((unsigned int)tobj->size*sizeof(void *) );
        tobj->limits = (long *)
		malloc((unsigned int)(tobj->size+1)*sizeof(long) );
        tobj->dirs = (enum updown *)
                malloc((unsigned int)tobj->size*sizeof(enum updown) );
        tobj->minit = 1;
    }
}

/*---------------------------------------------------------------------------
 * clear_sort - free merge sort data structures
 *---------------------------------------------------------------------------
 */

void 
__gl_clear_sort( GLUtriangulatorObj *tobj )
{
    if( tobj->minit ) {
        free( tobj->ptrlist );
	free( tobj->limits );	
	free( tobj->dirs );
        tobj->minit = 0;
    }
 }


/*---------------------------------------------------------------------------
 * msort - perform a merge sort on the data
 *---------------------------------------------------------------------------
 */

void
__gl_msort( GLUtriangulatorObj *tobj, 
            void **curptrlist, long count, long width, SortFunc comp )
{
    long i;
    long p1s, p1e, p2s, p2e, d1, d2;
    long q;
    int result;
    void *tmp;
    void **temp;
    void **newptrlist, **saveptrlist;
    void **c1s, **c1e, **c2s, **c2e, **np;

    /* XXX
    ** if comp() returns 0, then vertices are coincident.  That is illegal,
    ** call error.
    */
    if( count <= 1) return;
    if( count == 2) {
	result = comp( &curptrlist[0], &curptrlist[1] );
	if( result < 0 ) {
	    tmp = curptrlist[0];
	    curptrlist[0] = curptrlist[1];
	    curptrlist[1] = tmp;
	} else if (result == 0) {
	    __gl_in_error( tobj, 6 );
	}
	return;
    }

    __gl_init_sort( tobj, count );

    saveptrlist = curptrlist;
    newptrlist = tobj->ptrlist;
    tobj->limitcount = 0;
    tobj->limits[0] = 0;

    i=0;
    while( 1 ) {
	do {
	    i++;
	    if( i == count ) break;
	    result = comp(&curptrlist[i-1], &curptrlist[i]);
	    if (result == 0) {
		__gl_in_error( tobj, 6 );
	    }
	} while( result > 0 );
        tobj->dirs[tobj->limitcount] = down;
        tobj->limits[++tobj->limitcount] = i;
	if( i == count ) break;

	do {
	    i++;
	    if( i == count ) break;
	    result = comp(&curptrlist[i-1], &curptrlist[i]);
	    if (result == 0) {
		__gl_in_error( tobj, 6 );
	    }
	} while( result <= 0 );
        tobj->dirs[tobj->limitcount] = up;
        tobj->limits[++tobj->limitcount] = i;
	if( i == count ) break;
    }

    q = tobj->newlimitcount = 0;
    for (i = 0; i < tobj->limitcount-1; i += 2) {
	if (tobj->dirs[i] == up) {
	    p1s = tobj->limits[i];
	    p1e = tobj->limits[i+1];
	    d1 = 1;
	} else {
	    p1s = tobj->limits[i+1]-1;
	    p1e = tobj->limits[i]-1;
	    d1 = -1;
	}
	if (tobj->dirs[i+1] == up) {
	    p2s = tobj->limits[i+1];
	    p2e = tobj->limits[i+2];
	    d2 = 1;
	} else {
	    p2s = tobj->limits[i+2]-1;
	    p2e = tobj->limits[i+1]-1;
	    d2 = -1;
	}
	while ((p1s != p1e) && (p2s != p2e)) {
	    result = comp(&curptrlist[p1s], &curptrlist[p2s]);
	    if (result == 0) {
		__gl_in_error( tobj, 6 );
	    }
	    if (result > 0) {
		newptrlist[q++] = curptrlist[p2s];
		p2s += d2;
		if (p2s == p2e) do {
		    newptrlist[q++] = curptrlist[p1s];
		    p1s += d1;
		} while (p1s != p1e);
	    } else {
		newptrlist[q++] = curptrlist[p1s];
		p1s += d1;
		if (p1s == p1e) do {
		    newptrlist[q++] = curptrlist[p2s];
		    p2s += d2;
		} while (p2s != p2e);
	    }
	}
	tobj->limits[++tobj->newlimitcount] = q;
    }

    if (tobj->limitcount & 1) {
	if (tobj->dirs[tobj->limitcount-1] == up) {
	    p1s = tobj->limits[tobj->limitcount-1];
	    p1e = tobj->limits[tobj->limitcount];
	    d1 = 1;
	} else {
	    p1s = tobj->limits[tobj->limitcount] - 1;
	    p1e = tobj->limits[tobj->limitcount-1] - 1;
	    d1 = -1;
	}
	do {
	    newptrlist[q++] = curptrlist[p1s];
	    p1s += d1;
	} while (p1s != p1e);
	tobj->limits[++tobj->newlimitcount] = q;
    }

    tobj->limitcount = tobj->newlimitcount;

// The x86 compiler does not deal with this swap properly (though it does
// it fine in the while loop below).  Luckily, at this point saveptrlist
// has the data we want, so do the assignment to newptrlist using it instead.
//
// Meanwhile, lets keep the old code around so we can verify the compiler
// fix when it rolls out.

//!!!XXX -- compiler bug
#ifdef COMPILER_FIXED
    temp = curptrlist;
    curptrlist = newptrlist;
    newptrlist = temp;
#else
    curptrlist = newptrlist;
    newptrlist = saveptrlist;
#endif

    while (tobj->limitcount > 1) {
	np = newptrlist;
	q = tobj->newlimitcount = 0;
	for (i = 0; i < tobj->limitcount-1; i += 2) {
	    c1s = curptrlist + tobj->limits[i];
	    c1e = curptrlist + tobj->limits[i+1];
	    c2s = curptrlist + tobj->limits[i+1];
	    c2e = curptrlist + tobj->limits[i+2];
	    while ((c1s != c1e) && (c2s != c2e)) {
		result = comp(c1s, c2s);
		if (result == 0) {
		    __gl_in_error( tobj, 6 );
		}
		if (result > 0) {
		    *np++ = *c2s++;
		    if (c2s == c2e) do {
			*np++ = *c1s++;
		    } while (c1s != c1e);
		} else {
		    *np++ = *c1s++;
		    if (c1s == c1e) do {
			*np++ = *c2s++;
		    } while (c2s != c2e);
		}
	    }
	    tobj->limits[++tobj->newlimitcount] = np - newptrlist;
	}
	if( tobj->limitcount & 1 ) {
	    p1s = tobj->limits[tobj->limitcount-1];
	    p1e = tobj->limits[tobj->limitcount];
	    do {
	        *np++ = curptrlist[p1s++];
	    } while (p1s != p1e);
	    tobj->limits[++tobj->newlimitcount] = np - newptrlist;
	}
	tobj->limitcount = tobj->newlimitcount;
	temp = curptrlist;
	curptrlist = newptrlist;
	newptrlist = temp;
    }

    if (curptrlist != saveptrlist)
	for (i = 0; i < count; i++)
            saveptrlist[i] = curptrlist[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\priority.c ===
#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>

#ifndef NT
#include <stdlib.h>
#include <assert.h>
#else
#include "winmem.h"
#endif

#include "monotone.h"
#include "msort.h"

static int 	comp_priorityq( Vert **x, Vert **y );
static void 	grow_priorityq( GLUtriangulatorObj *tobj );


void
__gl_init_priorityq( GLUtriangulatorObj *tobj, long s )
{
    assert( ! tobj->parray ) ;
    tobj->phead = 0;
    tobj->ptail = 0;
    tobj->psize = s > 0 ? s : 1;
    tobj->parray = (Vert **)
        malloc( (unsigned int) (sizeof( Vert *) * tobj->psize) );
}

void
__gl_add_priorityq( GLUtriangulatorObj *tobj, Vert *v )
{
    assert( tobj->parray );
    if( tobj->ptail == tobj->psize ) grow_priorityq( tobj );
    tobj->parray[tobj->ptail++] = v;
}

int
__gl_more_priorityq( GLUtriangulatorObj *tobj )
{
    return tobj->phead != tobj->ptail;
}

void
__gl_sort_priorityq( GLUtriangulatorObj *tobj )
{
    assert( tobj->phead <= tobj->ptail );
    __gl_msort( tobj, (void **)tobj->parray+tobj->phead,
	   tobj->ptail-tobj->phead, sizeof(Vert *), (SortFunc) comp_priorityq );
}

Vert *
__gl_remove_priorityq( GLUtriangulatorObj *tobj )
{
    return tobj->parray[tobj->phead++];
}

void
__gl_free_priorityq( GLUtriangulatorObj *tobj )
{
    if (tobj->parray) { free( tobj->parray ); tobj->parray = 0; }
}

static void
grow_priorityq( GLUtriangulatorObj *tobj )
{
    tobj->psize *= 2;
    tobj->parray = (Vert **)
        realloc( tobj->parray, (unsigned int)(sizeof(Vert*)*tobj->psize) );
}

static int
comp_priorityq( Vert **vp1, Vert **vp2 )
{
    float diff = (*vp1)->s - (*vp2)->s;
    if (diff < (float)0.0) return -1;
    if (diff > (float)0.0) return 1;
    if (diff == (float)0.0)
        diff = (*vp1)->t - (*vp2)->t;
    if (diff < (float)0.0) return -1;
    if (diff > (float)0.0) return 1;

    return 0;
}

void
__gl_setpriority_priorityq( GLUtriangulatorObj *tobj, int s, int t )
{
   int i;
   
   for( i=tobj->phead; i<tobj->ptail; i++ ) {
	tobj->parray[i]->s = tobj->parray[i]->v[s];
	tobj->parray[i]->t = tobj->parray[i]->v[t];
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\ray.c ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1989, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* ray.c */

/* Derrick Burns - 1989 */

#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "monotone.h"
#include "bufpool.h"

#define ZERO 0.000001

/*----------------------------------------------------------------------------
 * init_raylist - create dummy rays at y = +/- infinity
 *----------------------------------------------------------------------------
 */

void
__gl_init_raylist( GLUtriangulatorObj *tobj )
{
    Ray *ray1, *ray2;

    if( ! tobj->raypool )
	tobj->raypool = __gl_new_pool( sizeof( Ray ), 32, "tobj->raypool" );

    ray1 = __gl_new_ray( tobj, 1 );
    ray2 = __gl_new_ray( tobj, 0 );
    ray1->next = ray1->prev = ray2;
    ray2->next = ray2->prev = ray1;
    ray1->coords[0] = ray1->coords[1] = (float)0.0; ray1->coords[2] = (float)-1.0;
    ray2->coords[0] = ray2->coords[1] = (float)0.0; ray2->coords[2] = (float)1.0;
    ray1->vertex =  0;
    ray2->vertex = 0;

#ifdef LAZYRECALC
    ray1->end1 = ray1->end2 = ray2->end1 = ray2->end2 = 0;
#endif

    tobj->raylist = ray1;
}

/*----------------------------------------------------------------------------
 * add2_raylist - add two rays to the ray list
 *----------------------------------------------------------------------------
 */

void
__gl_add2_raylist( Ray *prev, Ray *ray1, Ray *ray2 )
{
    ray1->prev = prev;
    ray1->next = ray2;
    ray2->prev = ray1;
    ray2->next = prev->next;
    ray1->prev->next = ray1;
    ray2->next->prev = ray2;
}

/*----------------------------------------------------------------------------
 * remove2_raylist - remove two rays from the ray list
 *----------------------------------------------------------------------------
 */

void 
__gl_remove2_raylist( GLUtriangulatorObj *tobj, Ray *ray )
{

    if( ray == tobj->raylist ||
	ray == tobj->raylist->prev ||
	ray->next == tobj->raylist ) {
	__gl_in_error( tobj, 7 );
    } else {
        ray->prev->next = ray->next->next;
        ray->next->next->prev = ray->prev;
   }
}

/*----------------------------------------------------------------------------
 * findray_raylist - find first ray below given vertex
 *----------------------------------------------------------------------------
 */

Ray *
__gl_findray_raylist( GLUtriangulatorObj *tobj, Vert *v )
{
    Ray *ray;
    for( ray=tobj->raylist; __gl_above_ray(ray, v) < -ZERO; ray=ray->next );
    return ray;
}

/*----------------------------------------------------------------------------
 * free_raylist - reclaim all rays
 *----------------------------------------------------------------------------
 */

void
__gl_free_raylist( GLUtriangulatorObj *tobj )
{
    if (tobj->raypool) {
	__gl_clear_pool(tobj->raypool);
    }
}

/*----------------------------------------------------------------------------
 * new_ray - create a new ray
 *----------------------------------------------------------------------------
 */

Ray *
__gl_new_ray( GLUtriangulatorObj *tobj, int orientation )
{
    Ray	*ray = (Ray *) __gl_new_buffer( tobj->raypool );
    ray->orientation = orientation;
    ray->mustconnect = 0;
    ray->vertex = 0;
    return ray;
}

/*----------------------------------------------------------------------------
 * delete_ray - free ray
 *----------------------------------------------------------------------------
 */

void
__gl_delete_ray( GLUtriangulatorObj *tobj, Ray *ray )
{
    __gl_free_buffer( tobj->raypool, ray );
}

/*----------------------------------------------------------------------------
 * above_ray - determine if a vertex is above_ray a ray
 *----------------------------------------------------------------------------
 */

int 
__gl_above_ray( Ray *ray, Vert *vert )
{
    /* returns 1 if the vertex is above_ray the ray (is in the region
     * associated with the ray) 0 if it's on the ray, and -1 if it is
     * below. */

    float dot;

#ifdef LAZYRECALC
    if( ray->end1 != 0 ) {
        ray->coords[0] = ray->end1->t - ray->end2->t;
        ray->coords[1] = ray->end2->s - ray->end1->s;
	ray->coords[2] = - ray->coords[1] * ray->end2->t 
			 - ray->coords[0] * ray->end2->s;
        ray->end1 = ray->end2 = 0;
    }
#endif 

    dot = ray->coords[0]*vert->s + ray->coords[1]*vert->t + ray->coords[2];
    if (dot > (float)0.0) return 1;
    if (dot < (float)0.0) return -1;
    /* XXX
	If we reach this point, it means that an input vertex lies on
	an edge connecting two other veritces.  This is officially
	disallowed. In some cases this will be detected in monotonize
	and in others it won't.  When it is not detected, it will NOT
	cause the program to die, and it WILL give reasonable results.
    */
    return 0;
}

/*----------------------------------------------------------------------------
 * recalc_ray - calculate the vector perpindicular to the line through v0/v1
 *----------------------------------------------------------------------------
 */

void
__gl_recalc_ray( Ray *ray, Vert *v0, Vert *v1 )
{
#ifdef LAZYRECALC
    ray->end1 = v0;
    ray->end2 = v1;
#else
    ray->coords[0] = v0->t - v1->t;
    ray->coords[1] = v1->s - v0->s;
    ray->coords[2] = - ray->coords[1]*v1->t - ray->coords[0]*v1->s;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\triangul.h ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1989, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

#ifndef TRIANGULATE_H
#define TRIANGULATE_H

#include <setjmp.h>

/* triangulate.h */

enum updown {none, up, down};

struct GLUtriangulatorObj {
    short	minit;
    short	in_poly;
    int		doingTriangles;
    struct Pool	*vpool;

    long	s;
    long	t;
    float	maxarea;
    enum updown	*dirs;
    void	**ptrlist;
    jmp_buf	in_env;
    GLenum	looptype;
    short	init;
    long	nloops;
    long	size;
    long 	*limits;
    long 	limitcount;
    long	newlimitcount;
    long 	phead;
    long	ptail;
    long	psize;
    long	vcount;
    long	lastedge;
    long	vdatalast;
    long	vdatatop;
    struct Vert	*head;
    struct Vert	**parray;
    struct Ray	*raylist;
    struct Pool	*raypool;
    struct Vert	**vdata;
    struct Vert	*vtop;
    struct Vert	*vbottom;
    struct Vert	*vlast;
    struct Vert *saved[2];
    short	saveCount;
    short	reverse;
    int		tritype;
    GLboolean	currentEdgeFlag;
    GLUtessBeginProc  begin;
    GLUtessVertexProc vertex;
    GLUtessEndProc    end;
    GLUtessErrorProc  error;
    GLUtessEdgeFlagProc   edgeflag;
    GLboolean	inBegin;
};

extern void __gl_in_error(GLUtriangulatorObj *, GLenum);
extern void __gl_cleanup(GLUtriangulatorObj *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\triangul.c ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1989, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* triangulate.c */

/* Derrick Burns - 1989 */

#include <glos.h>
#include <stdlib.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "monotone.h"

#define do_out_vert(x,y) do_out_vertex(x, y)
#define EPSILON 0.0

static void		do_out_begin( GLUtriangulatorObj *, GLenum );
static void		do_out_edgeflag( GLUtriangulatorObj *, GLboolean );
static void		do_out_vertex( GLUtriangulatorObj *, Vert * );
static void		do_out_end( GLUtriangulatorObj * );
static void		do_out_triangle( GLUtriangulatorObj *, Vert *, Vert *, 
					 Vert * );
static void		checkabove( GLUtriangulatorObj *, Vert *, Vert *, Vert *);

/*----------------------------------------------------------------------------
 * init_triangulate - reinitialize triangulation data structures
 *----------------------------------------------------------------------------
 */

void
__gl_init_triangulate( GLUtriangulatorObj *tobj, long nverts )
{
   if( tobj->init ) {
	if( nverts > tobj->vcount ) {
	    myfree( (char *)tobj->vdata );
            tobj->vcount = nverts * 2;
            tobj->vdata = (Vert **)
		mymalloc( (unsigned int) tobj->vcount * sizeof(Vert *) );
	} 
   } else {
     tobj->init = 1;
     tobj->vcount = nverts;
     tobj->vdata = (Vert **)
	mymalloc( (unsigned int) tobj->vcount * sizeof(Vert *) );
  }
}

/*----------------------------------------------------------------------------
 * clear_triangulate - free triangulation data structures
 *----------------------------------------------------------------------------
 */

void
__gl_clear_triangulate( GLUtriangulatorObj *tobj )
{
    if( tobj->init == 1 ) {
        myfree( (char *) tobj->vdata );
        tobj->init = 0;
    }
}

/*----------------------------------------------------------------------------
 * nextuppervert - find next vertex on upper chain
 *----------------------------------------------------------------------------
 */

static Vert *
__gl_nextuppervert( GLUtriangulatorObj *tobj )
{
    return (tobj->vtop == tobj->vlast || tobj->vbottom == tobj->vtop->prev)
	   ? 0 : tobj->vtop->prev;
}

/*----------------------------------------------------------------------------
 * nextlowervert - find next vertex on lower chain 
 *----------------------------------------------------------------------------
 */

static Vert *
__gl_nextlowervert( GLUtriangulatorObj *tobj )
{
    return (tobj->vbottom == tobj->vlast || tobj->vtop == tobj->vbottom->next)
	   ? 0 : tobj->vbottom->next;
}

/*----------------------------------------------------------------------------
 * testccw - test if top three verts on stack make ccw_vert turn
 *----------------------------------------------------------------------------
 */

static int
testccw( GLUtriangulatorObj *tobj ) /* tobj->lastedge == 1 */
{
    float s0, t0, s1, t1, s2, t2;
    float area;

    s0 = tobj->vdata[tobj->vdatalast]->s;
    t0 = tobj->vdata[tobj->vdatalast]->t;
    s1 = tobj->vdata[tobj->vdatatop-1]->s;
    t1 = tobj->vdata[tobj->vdatatop-1]->t;
    s2 = tobj->vdata[tobj->vdatatop-2]->s;
    t2 = tobj->vdata[tobj->vdatatop-2]->t;

    area = s0*(t1-t2) - s1*(t0-t2) + s2*(t0-t1);
    return (area < (float)-EPSILON) ? 0 : 1;
}

/*----------------------------------------------------------------------------
 * testcw - test if top three verts on stack make cw turn
 *----------------------------------------------------------------------------
 */

static int
testcw( GLUtriangulatorObj *tobj ) /* tobj->lastedge == 0 */
{
    float s0, t0, s1, t1, s2, t2;
    float area;

    s0 = tobj->vdata[tobj->vdatalast]->s;
    t0 = tobj->vdata[tobj->vdatalast]->t;
    s1 = tobj->vdata[tobj->vdatatop-1]->s;
    t1 = tobj->vdata[tobj->vdatatop-1]->t;
    s2 = tobj->vdata[tobj->vdatatop-2]->s;
    t2 = tobj->vdata[tobj->vdatatop-2]->t;
    area = s0*(t1-t2) - s1*(t0-t2) + s2*(t0-t1);
    return (area > (float)EPSILON) ? 0 : 1;
}


/*----------------------------------------------------------------------------
 * pushvert - place vertex on stack
 *----------------------------------------------------------------------------
 */

static void 
pushvert( GLUtriangulatorObj *tobj, Vert *v )
{
    ++tobj->vdatatop;
    assert( tobj->vdatatop < tobj->vcount );
    tobj->vdata[tobj->vdatatop] = v;
}


/*----------------------------------------------------------------------------
 * addedge - process new vertex 
 *----------------------------------------------------------------------------
 */

static void
addedge( GLUtriangulatorObj *tobj, Vert *v, long edge )
{
    long i;

    pushvert( tobj, v );
    if( tobj->vdatatop < 2 ) {
	tobj->lastedge = edge;
	return;
    }

    tobj->vdatalast = tobj->vdatatop;

    if( tobj->lastedge != edge ) {
	if( tobj->lastedge == 1 ) {
	    if ( tobj->vdatalast-1 == 1 ) {
		do_out_begin( tobj, GL_TRIANGLES );
	    } else {
		do_out_begin( tobj, GL_TRIANGLE_FAN );
	    }
	    do_out_vert( tobj, tobj->vdata[tobj->vdatalast] );
	    for( i = tobj->vdatalast-1; i >= 1; i-- ) {
		do_out_vert( tobj, tobj->vdata[i] );
	    }
	    tobj->vdatatop = tobj->vdatalast;
	    do_out_vert( tobj, tobj->vdata[0] );
	    do_out_end( tobj );
	    tobj->lastedge = 0;
	} else {
	    if ( tobj->vdatalast-1 == 1 ) {
		do_out_begin( tobj, GL_TRIANGLES );
	    } else {
		do_out_begin( tobj, GL_TRIANGLE_FAN );
	    }
	    do_out_vert( tobj, tobj->vdata[tobj->vdatalast] );
	    do_out_vert( tobj, tobj->vdata[0]);
	    for( i = 1; i < tobj->vdatalast; i++ ) {
		do_out_vert( tobj, tobj->vdata[i] );
	    }
	    tobj->vdatatop = tobj->vdatalast;
	    do_out_end( tobj );
	    tobj->lastedge = 1;
	}


	tobj->vdata[0] = tobj->vdata[tobj->vdatalast-1];
	tobj->vdata[1] = tobj->vdata[tobj->vdatalast];
	tobj->vdatatop = 1;
    } else {
	if( tobj->lastedge == 1 ) {
	    if( ! testccw( tobj ) ) return;
	    do {
		tobj->vdatatop--;
	    } while( (tobj->vdatatop > 1) && testccw( tobj ) );

	    if ( tobj->vdatalast - tobj->vdatatop == 1 ) {
		do_out_begin( tobj, GL_TRIANGLES );
	    } else {
		do_out_begin( tobj, GL_TRIANGLE_FAN );
	    }
	    do_out_vert( tobj, tobj->vdata[tobj->vdatalast] );
	    do_out_vert( tobj, tobj->vdata[tobj->vdatalast-1] );
	    for( i = tobj->vdatalast-2; i >= tobj->vdatatop-1; i-- ) {
		do_out_vert( tobj, tobj->vdata[i] );
	    }
	    do_out_end( tobj );
	} else {
	    if( ! testcw( tobj ) ) return;
	    do {
		tobj->vdatatop--;
	    } while( (tobj->vdatatop > 1) && testcw( tobj ) );

	    if ( tobj->vdatalast - tobj->vdatatop == 1 ) {
		do_out_begin( tobj, GL_TRIANGLES );
	    } else {
		do_out_begin( tobj, GL_TRIANGLE_FAN );
	    }
	    do_out_vert( tobj, tobj->vdata[tobj->vdatalast] );
	    for( i = tobj->vdatatop-1; i <= tobj->vdatalast-2; i++ ) {
		do_out_vert( tobj, tobj->vdata[i] );
	    }
	    do_out_vert( tobj, tobj->vdata[tobj->vdatalast-1] );
	    do_out_end( tobj );
	}
	tobj->vdata[tobj->vdatatop] = tobj->vdata[tobj->vdatalast];
    }
}

/*----------------------------------------------------------------------------
 * triangulate - triangulate a monotone loop of vertices 
 *----------------------------------------------------------------------------
 */

void
__gl_triangulate( GLUtriangulatorObj *tobj, Vert *v, long count )
{
    Vert	*vnext;

    __gl_init_triangulate( tobj, count );
    tobj->vlast = __gl_last_vert( v );
    tobj->vdatatop = -1;
    pushvert( tobj, tobj->vbottom = tobj->vtop = __gl_first_vert( v ) );
    tobj->vtop 	= __gl_nextuppervert( tobj );
    tobj->vbottom = __gl_nextlowervert( tobj );

    assert( tobj->vtop && tobj->vbottom );

    while ( 1 ) {
	if (tobj->vtop->s < tobj->vbottom->s) {
	    addedge( tobj, tobj->vtop, 1);
	    tobj->vtop = __gl_nextuppervert( tobj );
	    if (tobj->vtop == 0) {
		while (tobj->vbottom) {
		    vnext = __gl_nextlowervert( tobj );
		    addedge( tobj,  tobj->vbottom, (vnext ? 0 : 2 ) );
		    tobj->vbottom = vnext;
		}
		break;
	    }
	} else {
	    addedge( tobj, tobj->vbottom, 0);
	    tobj->vbottom = __gl_nextlowervert( tobj );
	    if (tobj->vbottom == 0) {
		while (tobj->vtop) {
		    vnext = __gl_nextuppervert( tobj );
		    addedge( tobj,  tobj->vtop, (vnext ? 1 : 2 ) );
		    tobj->vtop = vnext;
		}
		break;
	    }
	}
    }
    assert( tobj->vdatatop < 2 );
}


/*----------------------------------------------------------------------------
 * triangulateloop  - count vertices in loop and split into triangle meshes
 *----------------------------------------------------------------------------
 */

void
__gl_triangulateloop( GLUtriangulatorObj *tobj, Vert *v )
{
    short count = 0;
    Vert  *vl = v;
    do {
	count++;
	v = v->next;
    } while( v != vl );
    __gl_triangulate( tobj, v, count );
}

static void
do_out_begin( GLUtriangulatorObj *tobj, GLenum what )
{
    switch( what ) {
      case GL_TRIANGLES:
	tobj->tritype = GL_TRIANGLES;
	tobj->saveCount = 0;
	if (tobj->doingTriangles) return;
	tobj->doingTriangles = 1;
        break;
      case GL_TRIANGLE_FAN:
      case GL_TRIANGLE_STRIP:
	if (tobj->edgeflag) {
	    /* We convert fans and strips into independent triangles because
	    ** we can't set edge flags for fans and strips.
	    */
	    tobj->tritype = what;
	    tobj->saveCount = 0;
	    tobj->reverse = GL_FALSE;
	    if (tobj->doingTriangles) return;

	    tobj->doingTriangles = 1;
	    /* Change "what" so we tell user we are doing GL_TRIANGLES */
	    what = GL_TRIANGLES;
	} else {
	    /* So do_out_vertex() doesn't try to interpret anything */
	    tobj->tritype = -1;
	    if (tobj->doingTriangles) {
		tobj->doingTriangles = 0;
		do_out_end( tobj );
	    }
	}
	break;
    }
    if (*tobj->begin) {
	(*tobj->begin)( what );
	tobj->inBegin = GL_TRUE;
    }
}

static void
do_out_vertex( GLUtriangulatorObj *tobj, Vert *vertex )
{
    /* 
    ** tobj->tritype is set to GL_TRIANGLE_FAN or GL_TRIANGLE_STRIP if this
    ** routine needs to interpret incoming vertices from these 
    ** primitives and convert them into independent triangles.
    ** Otherwise, tobj->tritype is GL_TRIANGLES, and we just ship the 
    ** vertex to the dispatcher.
    */
    switch(tobj->tritype) {
      case GL_TRIANGLE_FAN:
	if (tobj->saveCount < 2) {
	    tobj->saved[tobj->saveCount] = vertex;
	    tobj->saveCount++;
	    return;
	} else {
	    if (tobj->vertex) {
		do_out_triangle( tobj, tobj->saved[0], tobj->saved[1], vertex);
		tobj->saved[1] = vertex;
	    }
	}
	break;
      case GL_TRIANGLE_STRIP:
	if (tobj->saveCount < 2) {
	    tobj->saved[tobj->saveCount] = vertex;
	    tobj->saveCount++;
	    return;
	} else {
	    if (!tobj->reverse) {
		if (tobj->vertex) {
		    do_out_triangle( tobj, tobj->saved[0], tobj->saved[1], 
			    vertex);
		}
		tobj->reverse = GL_TRUE;
	    } else {
		if (tobj->vertex) {
		    do_out_triangle( tobj, tobj->saved[1], tobj->saved[0], 
			    vertex);
		}
		tobj->reverse = GL_FALSE;
	    }
	    tobj->saved[0] = tobj->saved[1];
	    tobj->saved[1] = vertex;
	}
	break;
      case GL_TRIANGLES:
	if (tobj->saveCount < 2) {
	    tobj->saved[tobj->saveCount] = vertex;
	    tobj->saveCount++;
	    return;
	} else {
	    do_out_triangle( tobj, tobj->saved[0], tobj->saved[1], vertex);
	    tobj->saveCount=0;
	}
	break;
      default:
	/* Pass it along, no interpretation */
	if (tobj->vertex) {
	    (*tobj->vertex)( vertex->data );
	}
	break;
    }
}

static void
do_out_triangle( GLUtriangulatorObj *tobj, Vert *v1, Vert *v2, Vert *v3 )
{
    if (v1->nextid == v2->myid) {
	do_out_edgeflag( tobj, GL_TRUE );
    } else {
	do_out_edgeflag( tobj, GL_FALSE );
    }
    if (tobj->vertex) {
	(*tobj->vertex)( v1->data );
    }

    if (v2->nextid == v3->myid) {
	do_out_edgeflag( tobj, GL_TRUE );
    } else {
	do_out_edgeflag( tobj, GL_FALSE );
    }
    if (tobj->vertex) {
	(*tobj->vertex)( v2->data );
    }

    if (v3->nextid == v1->myid) {
	do_out_edgeflag( tobj, GL_TRUE );
    } else {
	do_out_edgeflag( tobj, GL_FALSE );
    }
    if (tobj->vertex) {
	(*tobj->vertex)( v3->data );
    }
}

static void
do_out_edgeflag( GLUtriangulatorObj *tobj, GLboolean value )
{
    if (value == tobj->currentEdgeFlag) return;
    tobj->currentEdgeFlag = value;
    if (tobj->edgeflag) {
	(*tobj->edgeflag)(tobj->currentEdgeFlag);
    }
}

static void
do_out_end( GLUtriangulatorObj *tobj )
{
    if (tobj->doingTriangles) return;
    if (tobj->end) {
	(*tobj->end)();
	tobj->inBegin = GL_FALSE;
    }
}

void
__gl_cleanup( GLUtriangulatorObj *tobj )
{
    if (tobj->inBegin) {
	(*tobj->end)();
	tobj->inBegin = GL_FALSE;
	tobj->doingTriangles = 0;
    }
}

void
__gl_checktriangulate( GLUtriangulatorObj *tobj, Vert *v )
{
    Vert	*vb, *vt, *vl;

    vl = __gl_last_vert( v );
    vb = vt = __gl_first_vert( v );
    vb = vb->next;
    vt = vt->prev;

    if( vb == vt ) return;

    while( 1 ) {
	if( vt->s < vb->s ) {
	    checkabove( tobj, vt, vb->prev, vb );
	    vt = vt->prev;
	    if( vt == vl ) {
		for( ; vb != vl; vb=vb->next ) 
		    checkabove( tobj, vb, vl, vl->next );
		break;
	    }
	} else {
	    checkabove( tobj, vb, vt, vt->next );
	    vb = vb->next;
	    if( vb == vl ) {
		for( ; vt != vl; vt=vt->prev )
		    checkabove( tobj, vt, vl->prev, vl );
		break;
	    }
	}
    }
}

static void
checkabove( GLUtriangulatorObj *tobj, Vert *v0, Vert *v1, Vert *v2 )
{
    float area;
    area = v0->s*(v1->t-v2->t) - v1->s*(v0->t-v2->t) + v2->s*(v0->t-v1->t);
    if( area < (float)0 )
	__gl_in_error( tobj, 8 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libutil\memory.c ===
#ifdef NT
#include <glos.h>
#endif
#include "gluint.h"
#include <GL/glu.h>

#ifndef NT
#include <stdio.h>
#include <stdlib.h>
#else
#include "glstring.h"
#endif

DWORD gluMemoryAllocationFailed = 0;

HLOCAL gluAlloc (UINT size)
{
    HLOCAL tmp;
    
    tmp = LocalAlloc(LMEM_FIXED, size);
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
}


HLOCAL gluCalloc (UINT nobj, UINT size)
{
    HLOCAL tmp;
    
    tmp = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, nobj*size);
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
}


HLOCAL gluReAlloc (HLOCAL p, UINT size)
{
    HLOCAL tmp;
    
    tmp = LocalReAlloc(p, size, LMEM_MOVEABLE);
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libutil\gluint.h ===
#ifndef __gluint_h__
#define __gluint_h__

/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.1 $
** $Date: 1995/06/08 22:28:21 $
*/

#include <glos.h>

extern const char *__glNURBSErrorString( int errno );
extern const char *__glTessErrorString( int errno );

#ifdef NT
extern LPCWSTR __glNURBSErrorStringW( int errno );
extern LPCWSTR __glTessErrorStringW( int errno );
#endif

#ifdef _EXTENSIONS_
#define COS cosf
#define SIN sinf
#define SQRT sqrtf
#else
#define COS cos
#define SIN sin
#define SQRT sqrt
#endif

#endif /* __gluint_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\vlist2.c ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1989, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* vlist2.c */

/* Derrick Burns - 1989 */

#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "monotone.h"
#include "bufpool.h"

 /*---------------------------------------------------------------------------
 * free_verts - free all vertices and vertex lists 
 *---------------------------------------------------------------------------
 */

void
__gl_free_verts( GLUtriangulatorObj *tobj )
{
    if (tobj->vpool) {
	__gl_clear_pool(tobj->vpool);
    }
}

/*---------------------------------------------------------------------------
 * init_verts - set initial size of vertex pointer list and vertex lists
 *---------------------------------------------------------------------------
 */

void
__gl_init_verts( GLUtriangulatorObj *tobj )
{
    if( ! tobj->vpool )
	tobj->vpool = __gl_new_pool( sizeof( Vert ), INITVPSIZE, "vert_pool" );
}

/*---------------------------------------------------------------------------
 * new_vert - allocate a vertex
 *---------------------------------------------------------------------------
 */

Vert *
__gl_new_vert( GLUtriangulatorObj *tobj )
{
    return (Vert *) __gl_new_buffer( tobj->vpool );
}

/*----------------------------------------------------------------------------
 * checkray_vert - cheap check for ray/ray intersection
 *----------------------------------------------------------------------------
 */

void
__gl_checkray_vert( GLUtriangulatorObj *tobj, Vert *v, Ray *ray1, Ray *ray2 )
{
    if( __gl_above_ray( ray2, v ) < 0 || __gl_above_ray( ray1, v ) > 0 )
	__gl_in_error( tobj, 8 );
}

/*---------------------------------------------------------------------------
 * first_vert - find leftmost vertex in loop
 *---------------------------------------------------------------------------
 */

Vert *
__gl_first_vert( Vert *h )
{
    Vert *vlo, *v;
    for( vlo = h, v = h->next; v != h; v=v->next )
	if( (v->s < vlo->s) || ( v->s == vlo->s && v->t < vlo->t ) )
	    vlo = v;
    return vlo;
}

/*----------------------------------------------------------------------------
 * last_vert - find rightmost vertex on loop
 *----------------------------------------------------------------------------
 */

Vert *
__gl_last_vert( Vert *h )
{
    Vert *vhi, *v;
    for( vhi = h, v = h->next; v != h; v=v->next )
	if( (v->s > vhi->s) || ( v->s == vhi->s && v->t > vhi->t ) )
	    vhi = v;
    return vhi;
}

/*---------------------------------------------------------------------------
 * reverse_vert - reverse_vert a doubly linked list
 *---------------------------------------------------------------------------
 */

void
__gl_reverse_vert( Vert *h )
{
    Vert *v, *next;
    v = h;
    do {
	next = v->next;	
	v->next = v->prev;
	v->prev = next;
 	v = next;
    } while( v != h );
}

/*---------------------------------------------------------------------------
 * ccw_vert - check if three vertices are oriented ccw_vert
 *---------------------------------------------------------------------------
 */

short
__gl_ccw_vert( Vert *v )
{
    double det;
    det = (v->s * (v->next->t - v->prev->t)+
	   v->next->s * (v->prev->t - v->t)+
	   v->prev->s * (v->t - v->next->t));
    if( det == 0.0 ) 
	return v->prev->t > v->next->t ? 1 : 0;
    else if( det > 0.0 )
	return 1;
    else 
	return 0;
}


/*----------------------------------------------------------------------------
 * orient_vert - correct the orientation of a loop 
 *----------------------------------------------------------------------------
 */

long
__gl_orient_vert( Vert *v, GLenum type )
{
    long f;
    switch( type ) {
      case GLU_EXTERIOR:
	if (! __gl_ccw_vert( __gl_first_vert( v ) ) ) __gl_reverse_vert( v );
	f = __gl_classify_all( v );
	break;
      case GLU_INTERIOR:
	if (__gl_ccw_vert( __gl_first_vert( v ) ) ) __gl_reverse_vert( v );
	f = __gl_classify_all( v );
	break;
      case GLU_CW:
	f = __gl_classify_all( v );
	break;
      case GLU_CCW:
	__gl_reverse_vert( v );
	f = __gl_classify_all( v );
	break;
      case GLU_UNKNOWN:
	__gl_unclassify_all( v );
	f = 0;
	break;
    }
    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libtri\tribufpo.c ===
/**************************************************************************
 *    									  *
 *     	 Copyright (C) 1988, Silicon Graphics, Inc.			  *
 *    									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *    									  *
 **************************************************************************/

/*
 *  bufpool.c 
 *
 *  $Revision: 1.1 $
 */

#ifndef NT
#include <assert.h>
#include <stdlib.h>
#else
#include "winmem.h"
#endif

#include "bufpool.h"

/* local functions */
static void	grow_pool( register Pool * );

/*-----------------------------------------------------------------------------
 * new_pool - allocate a new pool of buffers
 *-----------------------------------------------------------------------------
 */
Pool *
__gl_new_pool( int buffersize, int initpoolsize, char *name )
{
    register Pool *p;

    p = (Pool *) malloc( sizeof (Pool) );
    p->buffersize= (buffersize < sizeof(Buffer)) ? sizeof(Buffer)	
    						 : buffersize;
    p->nextsize	= initpoolsize * p->buffersize;
#ifndef NDEBUG
    p->name	= name;
    p->magic	= is_allocated;
#endif
    p->nextblock= 0;
    p->curblock	= 0;
    p->freelist	= 0;
    p->nextfree	= 0;
    return p;
}

/*-----------------------------------------------------------------------------
 * new_buffer - allocate a buffer from a pool
 *-----------------------------------------------------------------------------
 */

char *
__gl_new_buffer( register Pool *p )
{
    char *buffer;

#ifndef NT
#ifndef NDEBUG
    assert( p && (p->magic == is_allocated) );
#endif
#endif

    /* find free buffer */

    if( p->freelist ) {
    	buffer = (char *) p->freelist; 
    	p->freelist = p->freelist->next;
    } else {
    	if( ! p->nextfree )
    	    grow_pool( p );
    	p->nextfree -= p->buffersize;;
    	buffer = p->curblock + p->nextfree;
    }
    return buffer;
}

static void
grow_pool( register Pool *p )
{
#ifndef NT
#ifndef NDEBUG
    assert( p && (p->magic == is_allocated) );
#endif
#endif

    p->curblock = (char *) malloc( p->nextsize );
    p->blocklist[p->nextblock++] = p->curblock;
    p->nextfree = p->nextsize;
    p->nextsize *= 2;
}

/*-----------------------------------------------------------------------------
 * free_buffer - return a buffer to a pool
 *-----------------------------------------------------------------------------
 */

void
__gl_free_buffer( Pool *p, void *b )
{
#ifndef NT
#ifndef NDEBUG
    assert( p && (p->magic == is_allocated) );
#endif
#endif

    /* add buffer to singly connected free list */

    ((Buffer *) b)->next = p->freelist;
    p->freelist = (Buffer *) b;
}

/*-----------------------------------------------------------------------------
 * free_pool - free a pool of buffers and the pool itself
 *-----------------------------------------------------------------------------
 */

void 
__gl_free_pool( Pool *p )
{
#ifndef NT
#ifndef NDEBUG
    assert( p && (p->magic == is_allocated) );
#endif
#endif

    while( p->nextblock )
    	free( p->blocklist[--(p->nextblock)] );
#ifndef NDEBUG
    p->magic = is_free;
#endif
    free( p );
}

/*-----------------------------------------------------------------------------
 * clear_pool - free buffers associated with pool but keep pool 
 *-----------------------------------------------------------------------------
 */

void 
__gl_clear_pool( Pool *p )
{
#ifndef NT
#ifndef NDEBUG
    assert( p && (p->magic == is_allocated) );
#endif
#endif

    while( p->nextblock )
    	free( p->blocklist[--(p->nextblock)] );
    p->curblock	= 0;
    p->freelist	= 0;
    p->nextfree	= 0;
    if( p->nextsize >= 2 * p->buffersize )
        p->nextsize /= 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libutil\mipmap.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1996/03/29 01:55:31 $
*/
#ifdef NT
#include <glos.h>
#endif
#include <assert.h>
#include "gluint.h"
#include <GL/glu.h>
#include <stdio.h>
#ifdef NT
#include "winmem.h"
#else
#include <stdlib.h>
#endif
#include <string.h>
#include <math.h>

typedef union {
    unsigned char ub[4];
    unsigned short us[2];
    unsigned long ui;
    char b[4];
    short s[2];
    long i;
    float f;
} Type_Widget;

/* Pixel storage modes */ 
typedef struct {
   GLint pack_alignment;
   GLint pack_row_length; 
   GLint pack_skip_rows;  
   GLint pack_skip_pixels;
   GLint pack_lsb_first;
   GLint pack_swap_bytes;

   GLint unpack_alignment;
   GLint unpack_row_length;
   GLint unpack_skip_rows;
   GLint unpack_skip_pixels;
   GLint unpack_lsb_first;
   GLint unpack_swap_bytes;
} PixelStorageModes;

/*
 * internal function declarations
 */
static GLfloat bytes_per_element(GLenum type);
static GLint elements_per_group(GLenum format);
#ifdef NT
static GLboolean is_index(GLenum format);
#else
static GLint is_index(GLenum format);
#endif
static GLint image_size(GLint width, GLint height, GLenum format, GLenum type);
static void fill_image(const PixelStorageModes *,
		       GLint width, GLint height, GLenum format, 
		       GLenum type, GLboolean index_format, 
		       const void *userdata, GLushort *newimage);
static void empty_image(const PixelStorageModes *,
			GLint width, GLint height, GLenum format, 
		        GLenum type, GLboolean index_format, 
			const GLushort *oldimage, void *userdata);
static void scale_internal(GLint components, GLint widthin, GLint heightin, 
			   const GLushort *datain, 
			   GLint widthout, GLint heightout, 
			   GLushort *dataout);

static GLint retrieveStoreModes(PixelStorageModes *psm)
{
    glGetError();
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &psm->unpack_alignment);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &psm->unpack_row_length);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_SKIP_ROWS, &psm->unpack_skip_rows);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &psm->unpack_skip_pixels);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_LSB_FIRST, &psm->unpack_lsb_first);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_SWAP_BYTES, &psm->unpack_swap_bytes);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_ALIGNMENT, &psm->pack_alignment);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_ROW_LENGTH, &psm->pack_row_length);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_SKIP_ROWS, &psm->pack_skip_rows);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_SKIP_PIXELS, &psm->pack_skip_pixels);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_LSB_FIRST, &psm->pack_lsb_first);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_SWAP_BYTES, &psm->pack_swap_bytes);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    return 0;
}

static int computeLog(GLuint value)
{
    int i;

    i = 0;

    /* Error! */
    if (value == 0) return -1;

    for (;;) {
	if (value & 1) {
	    /* Error ! */
	    if (value != 1) return -1;
	    return i;
	}
	value = value >> 1;
	i++;
    }
}

/* 
** Compute the nearest power of 2 number.  This algorithm is a little 
** strange, but it works quite well.
*/
static int nearestPower(GLuint value)
{
    int i;

    i = 1;

    /* Error! */
    if (value == 0) return -1;

    for (;;) {
	if (value == 1) {
	    return i;
	} else if (value == 3) {
	    return i*4;
	}
	value = value >> 1;
	i *= 2;
    }
}

static void halveImage(GLint components, GLuint width, GLuint height, 
		       const GLushort *datain, GLushort *dataout)
{
    int i, j, k;
    int newwidth, newheight;
    int delta;
    GLushort *s;
    const GLushort *t;

    newwidth = width / 2;
    newheight = height / 2;
    delta = width * components;
    s = dataout;
    t = datain;

    /* Piece o' cake! */
    for (i = 0; i < newheight; i++) {
	for (j = 0; j < newwidth; j++) {
	    for (k = 0; k < components; k++) {
		s[0] = (t[0] + t[components] + t[delta] + 
			t[delta+components] + 2) / 4;
		s++; t++;
	    }
	    t += components;
	}
	t += delta;
    }
}

static void scale_internal(GLint components, GLint widthin, GLint heightin, 
			   const GLushort *datain, 
			   GLint widthout, GLint heightout, 
			   GLushort *dataout)
{
    float x, lowx, highx, convx, halfconvx;
    float y, lowy, highy, convy, halfconvy;
    float xpercent,ypercent;
    float percent;
    /* Max components in a format is 4, so... */
    float totals[4];
    float area;
    int i,j,k,yint,xint,xindex,yindex;
    int temp;

    if (widthin == widthout*2 && heightin == heightout*2) {
	halveImage(components, widthin, heightin, datain, dataout);
	return;
    }
    convy = (float) heightin/heightout;
    convx = (float) widthin/widthout;
    halfconvx = convx/2;
    halfconvy = convy/2;
    for (i = 0; i < heightout; i++) {
	y = convy * (i+0.5);
	if (heightin > heightout) {
	    highy = y + halfconvy;
	    lowy = y - halfconvy;
	} else {
	    highy = y + 0.5;
	    lowy = y - 0.5;
	}
	for (j = 0; j < widthout; j++) {
	    x = convx * (j+0.5);
	    if (widthin > widthout) {
		highx = x + halfconvx;
		lowx = x - halfconvx;
	    } else {
		highx = x + 0.5;
		lowx = x - 0.5;
	    }

	    /*
	    ** Ok, now apply box filter to box that goes from (lowx, lowy)
	    ** to (highx, highy) on input data into this pixel on output
	    ** data.
	    */
	    totals[0] = totals[1] = totals[2] = totals[3] = 0.0;
	    area = 0.0;

	    y = lowy;
	    yint = floor(y);
	    while (y < highy) {
		yindex = (yint + heightin) % heightin;
		if (highy < yint+1) {
		    ypercent = highy - y;
		} else {
		    ypercent = yint+1 - y;
		}

		x = lowx;
		xint = floor(x);

		while (x < highx) {
		    xindex = (xint + widthin) % widthin;
		    if (highx < xint+1) {
			xpercent = highx - x;
		    } else {
			xpercent = xint+1 - x;
		    }

		    percent = xpercent * ypercent;
		    area += percent;
		    temp = (xindex + (yindex * widthin)) * components;
		    for (k = 0; k < components; k++) {
			totals[k] += datain[temp + k] * percent;
		    }

		    xint++;
		    x = xint;
		}
		yint++;
		y = yint;
	    }

	    temp = (j + (i * widthout)) * components;
	    for (k = 0; k < components; k++) {
		dataout[temp + k] = totals[k]/area;
	    }
	}
    }
}

static GLboolean legalFormat(GLenum format)
{
    switch(format) {
      case GL_COLOR_INDEX:
      case GL_STENCIL_INDEX:
      case GL_DEPTH_COMPONENT:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	return GL_TRUE;
      default:
	return GL_FALSE;
    }
}

static GLboolean legalType(GLenum type)
{
    switch(type) {
      case GL_BITMAP:
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	return GL_TRUE;
      default:
	return GL_FALSE;
    }
}

GLint gluScaleImage(GLenum format, GLint widthin, GLint heightin, 
		 GLenum typein, const void *datain, 
		 GLint widthout, GLint heightout, GLenum typeout,
		 void *dataout)
{
    int components;
    GLushort *beforeImage;
    GLushort *afterImage;
    PixelStorageModes psm;

    if (widthin == 0 || heightin == 0 || widthout == 0 || heightout == 0) {
	    return 0;
    }
    if (widthin < 0 || heightin < 0 || widthout < 0 || heightout < 0) {
	    return GLU_INVALID_VALUE;
    }
    if (!legalFormat(format) || !legalType(typein) || !legalType(typeout)) {
        return GLU_INVALID_ENUM;
    }

    if (retrieveStoreModes(&psm)) {
        return GL_OUT_OF_MEMORY;
    }
    
    beforeImage =
	malloc(image_size(widthin, heightin, format, GL_UNSIGNED_SHORT)); 
    afterImage =
	malloc(image_size(widthout, heightout, format, GL_UNSIGNED_SHORT));
    if (beforeImage == NULL || afterImage == NULL) {
	return GLU_OUT_OF_MEMORY;
    }

    fill_image(&psm,widthin, heightin, format, typein, is_index(format),
	    datain, beforeImage);

    components = elements_per_group(format);
    scale_internal(components, widthin, heightin, beforeImage, 
	    widthout, heightout, afterImage);

    empty_image(&psm,widthout, heightout, format, typeout, 
	    is_index(format), afterImage, dataout);
    free((GLbyte *) beforeImage);
    free((GLbyte *) afterImage);

    return 0;
}

GLint gluBuild1DMipmaps(GLenum target, GLint components, GLint width,
		     GLenum format, GLenum type, const void *data)
{
    GLint newwidth;
    GLint level, levels;
    GLushort *newImage;
    GLint newImage_width;
    GLushort *otherImage;
    GLushort *imageTemp;
    GLint memreq;
    GLint maxsize;
    GLint cmpts;
    PixelStorageModes psm;
    GLboolean error = GL_FALSE;
    
    if (width < 1) {
        return GLU_INVALID_VALUE;
    }
    if (!legalFormat(format) || !legalType(type)) {
        return GLU_INVALID_ENUM;
    }
    if (format == GL_STENCIL_INDEX) {
       return GLU_INVALID_ENUM;
    }
    if (format == GL_DEPTH_COMPONENT) {
       return GLU_INVALID_ENUM;
    }

    if (retrieveStoreModes(&psm)) {
       return GL_OUT_OF_MEMORY;
    }

    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxsize);
    if (glGetError() != GL_NO_ERROR)
    {
       return GL_OUT_OF_MEMORY;
    }

    newwidth = nearestPower(width);
    if (newwidth > maxsize) newwidth = maxsize;
    levels = computeLog(newwidth);

    otherImage = NULL;
    newImage = (GLushort *)
	malloc(image_size(width, 1, format, GL_UNSIGNED_SHORT)); 
    newImage_width = width;
    if (newImage == NULL) {
	return GLU_OUT_OF_MEMORY;
    }
    fill_image(&psm,width, 1, format, type, is_index(format),
	    data, newImage);
    cmpts = elements_per_group(format);

    glGetError();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    /*
    ** If swap_bytes was set, swapping occurred in fill_image.
    */
    glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
    if (glGetError() != GL_NO_ERROR)   {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }

    for (level = 0; level <= levels; level++) {
	if (newImage_width == newwidth) {
	    /* Use newImage for this level */
	    glTexImage1D(target, level, components, newImage_width, 
		    0, format, GL_UNSIGNED_SHORT, (void *) newImage);
	} else {
	    if (otherImage == NULL) {
		memreq = image_size(newwidth, 1, format, GL_UNSIGNED_SHORT);
		otherImage = (GLushort *) malloc(memreq);
		if (otherImage == NULL) {
		    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
		    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
		    glPixelStorei(GL_UNPACK_SKIP_PIXELS,psm.unpack_skip_pixels);
		    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
		    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
		    return GLU_OUT_OF_MEMORY;
		}
	    }
	    scale_internal(cmpts, newImage_width, 1, newImage, 
		    newwidth, 1, otherImage);
	    /* Swap newImage and otherImage */
	    imageTemp = otherImage; 
	    otherImage = newImage;
	    newImage = imageTemp;

	    newImage_width = newwidth;
	    glTexImage1D(target, level, components, newImage_width,
		    0, format, GL_UNSIGNED_SHORT, (void *) newImage);
	}
	if (newwidth > 1) newwidth /= 2;
    }

gluBuild1DMipmaps_cleanup:
    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);

    free((GLbyte *) newImage);
    if (otherImage) {
	free((GLbyte *) otherImage);
    }
    if (error == GL_TRUE)
        return GL_OUT_OF_MEMORY;
    else
        return 0;
}

GLint gluBuild2DMipmaps(GLenum target, GLint components, GLint width, 
		     GLint height, GLenum format, 
		     GLenum type, const void *data)
{
    GLint newwidth, newheight;
    GLint level, levels;
    GLushort *newImage;
    GLint newImage_width;
    GLint newImage_height;
    GLushort *otherImage;
    GLushort *imageTemp;
    GLint memreq;
    GLint maxsize;
    GLint cmpts;
    GLboolean error = GL_FALSE;

    PixelStorageModes psm;

    if (width < 1 || height < 1) {
	return GLU_INVALID_VALUE;
    }
    if (!legalFormat(format) || !legalType(type)) {
	return GLU_INVALID_ENUM;
    }
    if (format == GL_STENCIL_INDEX) {
       return GLU_INVALID_ENUM;
    }
    if (format == GL_DEPTH_COMPONENT) {
       return GLU_INVALID_ENUM;
    }

    if (retrieveStoreModes(&psm)) {
       return GL_OUT_OF_MEMORY;
    }

    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxsize);
    if (glGetError() != GL_NO_ERROR)
    {
       return GL_OUT_OF_MEMORY;
    }

    newwidth = nearestPower(width);
    if (newwidth > maxsize) newwidth = maxsize;
    newheight = nearestPower(height);
    if (newheight > maxsize) newheight = maxsize;
    levels = computeLog(newwidth);
    level = computeLog(newheight);
    if (level > levels) levels=level;

    otherImage = NULL;
    newImage = (GLushort *) 
	malloc(image_size(width, height, format, GL_UNSIGNED_SHORT)); 
    newImage_width = width;
    newImage_height = height;
    if (newImage == NULL) {
	return GLU_OUT_OF_MEMORY;
    }
    fill_image(&psm,width, height, format, type, is_index(format),
	    data, newImage);
    cmpts = elements_per_group(format);

    glGetError();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    /*
    ** If swap_bytes was set, swapping occurred in fill_image.
    */
    glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }

    for (level = 0; level <= levels; level++) {
	if (newImage_width == newwidth && newImage_height == newheight) {
	    /* Use newImage for this level */
	    glTexImage2D(target, level, components, newImage_width, 
		    newImage_height, 0, format, GL_UNSIGNED_SHORT, 
		    (void *) newImage);
	} else {
	    if (otherImage == NULL) {
		memreq = 
		    image_size(newwidth, newheight, format, GL_UNSIGNED_SHORT);
		otherImage = (GLushort *) malloc(memreq);
		if (otherImage == NULL) {
		    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
		    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
		    glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
		    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
		    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
		    return GLU_OUT_OF_MEMORY;
		}
	    }
	    scale_internal(cmpts, newImage_width, newImage_height, newImage, 
		    newwidth, newheight, otherImage);
	    /* Swap newImage and otherImage */
	    imageTemp = otherImage; 
	    otherImage = newImage;
	    newImage = imageTemp;

	    newImage_width = newwidth;
	    newImage_height = newheight;
	    glTexImage2D(target, level, components, newImage_width, 
		    newImage_height, 0, format, GL_UNSIGNED_SHORT, 
		    (void *) newImage);
	}
	if (newwidth > 1) newwidth /= 2;
	if (newheight > 1) newheight /= 2;
    }
gluBuild2DMipmaps_cleanup:
    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);

    free((GLbyte *) newImage);
    if (otherImage) {
	free((GLbyte *) otherImage);
    }
    if (error == GL_TRUE)
        return GL_OUT_OF_MEMORY;
    else
        return 0;
}

/*
 * Utility Routines
 */
static GLint elements_per_group(GLenum format) 
{
    /*
     * Return the number of elements per group of a specified format
     */
    switch(format) {
      case GL_RGB:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
#endif
	return 3;
      case GL_LUMINANCE_ALPHA:
	return 2;
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
#endif
	return 4;
      default:
	return 1;
    }
}

static GLfloat bytes_per_element(GLenum type) 
{
    /*
     * Return the number of bytes per element, based on the element type
     */
    switch(type) {
      case GL_BITMAP:
	return 1.0 / 8.0;
      case GL_UNSIGNED_SHORT:
      case GL_SHORT:
	return 2;
      case GL_UNSIGNED_BYTE:
      case GL_BYTE:
	return 1;
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
      default:
	return 4;
    }
}

#ifdef NT
static GLboolean is_index(GLenum format) 
#else
static GLint is_index(GLenum format) 
#endif
{
    return format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX;
}

/*
** Compute memory required for internal packed array of data of given type
** and format.
*/
static GLint image_size(GLint width, GLint height, GLenum format, GLenum type) 
{
    int bytes_per_row;
    int components;

    assert(width > 0);
    assert(height > 0);
    components = elements_per_group(format);
    if (type == GL_BITMAP) {
	bytes_per_row = (width + 7) / 8;
    } else {
	bytes_per_row = bytes_per_element(type) * width;
    }
    return bytes_per_row * height * components;
}

/*
** Extract array from user's data applying all pixel store modes.
** The internal format used is an array of unsigned shorts.
*/
static void fill_image(const PixelStorageModes *psm,
		       GLint width, GLint height, GLenum format, 
		       GLenum type, GLboolean index_format, 
		       const void *userdata, GLushort *newimage)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint groups_per_line;
    GLint group_size;
    GLint elements_per_line;
    const GLubyte *start;
    const GLubyte *iter;
    GLushort *iter2;
    GLint i, j, k;
    GLint myswap_bytes;

    myswap_bytes = psm->unpack_swap_bytes;
    components = elements_per_group(format);
    if (psm->unpack_row_length > 0) {
	groups_per_line = psm->unpack_row_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint bit_offset;
	GLint current_bit;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % psm->unpack_alignment);
	if (padding) {
	    rowsize += psm->unpack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->unpack_skip_rows * rowsize + 
		(psm->unpack_skip_pixels * components / 8);
	elements_per_line = width * components;
	iter2 = newimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    bit_offset = (psm->unpack_skip_pixels * components) % 8;
	    for (j = 0; j < elements_per_line; j++) {
		/* Retrieve bit */
		if (psm->unpack_lsb_first) {
		    current_bit = iter[0] & (1 << bit_offset);
		} else {
		    current_bit = iter[0] & (1 << (7 - bit_offset));
		}
		if (current_bit) {
		    if (index_format) {
			*iter2 = 1;
		    } else {
			*iter2 = 65535;
		    }
		} else {
		    *iter2 = 0;
		}
		bit_offset++;
		if (bit_offset == 8) {
		    bit_offset = 0;
		    iter++;
		}
		iter2++;
	    }
	    start += rowsize;
	}
    } else {
	element_size = bytes_per_element(type);
	group_size = element_size * components;
	if (element_size == 1) myswap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % psm->unpack_alignment);
	if (padding) {
	    rowsize += psm->unpack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->unpack_skip_rows * rowsize + 
		psm->unpack_skip_pixels * group_size;
	elements_per_line = width * components;

	iter2 = newimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    for (j = 0; j < elements_per_line; j++) {
		Type_Widget widget;

		switch(type) {
		  case GL_UNSIGNED_BYTE:
		    if (index_format) {
			*iter2 = *iter;
		    } else {
			*iter2 = (*iter) * 257;
		    }
		    break;
		  case GL_BYTE:
		    if (index_format) {
			*iter2 = *((GLbyte *) iter);
		    } else {
			/* rough approx */
			*iter2 = (*((GLbyte *) iter)) * 516;
		    }
		    break;
		  case GL_UNSIGNED_SHORT:
		  case GL_SHORT:
		    if (myswap_bytes) {
			widget.ub[0] = iter[1];
			widget.ub[1] = iter[0];
		    } else {
			widget.ub[0] = iter[0];
			widget.ub[1] = iter[1];
		    }
		    if (type == GL_SHORT) {
			if (index_format) {
			    *iter2 = widget.s[0];
			} else {
			    /* rough approx */
			    *iter2 = widget.s[0]*2;
			}
		    } else {
			*iter2 = widget.us[0];
		    }
		    break;
		  case GL_INT:
		  case GL_UNSIGNED_INT:
		  case GL_FLOAT:
		    if (myswap_bytes) {
			widget.ub[0] = iter[3];
			widget.ub[1] = iter[2];
			widget.ub[2] = iter[1];
			widget.ub[3] = iter[0];
		    } else {
			widget.ub[0] = iter[0];
			widget.ub[1] = iter[1];
			widget.ub[2] = iter[2];
			widget.ub[3] = iter[3];
		    }
		    if (type == GL_FLOAT) {
			if (index_format) {
			    *iter2 = widget.f;
			} else {
			    *iter2 = 65535 * widget.f;
			}
		    } else if (type == GL_UNSIGNED_INT) {
			if (index_format) {
			    *iter2 = (GLushort)widget.ui;
			} else {
			    *iter2 = widget.ui >> 16;
			}
		    } else {
			if (index_format) {
			    *iter2 = (GLushort)widget.i;
			} else {
			    *iter2 = widget.i >> 15;
			}
		    }
		    break;
		}
		iter += element_size;
		iter2++;
	    }
	    start += rowsize;
	}
    }
}

/*
** Insert array into user's data applying all pixel store modes.
** The internal format is an array of unsigned shorts.
** empty_image() because it is the opposite of fill_image().
*/
static void empty_image(const PixelStorageModes *psm,
			GLint width, GLint height, GLenum format, 
		        GLenum type, GLboolean index_format, 
			const GLushort *oldimage, void *userdata)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint groups_per_line;
    GLint group_size;
    GLint elements_per_line;
    GLubyte *start;
    GLubyte *iter;
    const GLushort *iter2;
    GLint i, j, k;
    GLint myswap_bytes;

    myswap_bytes = psm->pack_swap_bytes;
    components = elements_per_group(format);
    if (psm->pack_row_length > 0) {
	groups_per_line = psm->pack_row_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint bit_offset;
	GLint current_bit;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % psm->pack_alignment);
	if (padding) {
	    rowsize += psm->pack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->pack_skip_rows * rowsize + 
		(psm->pack_skip_pixels * components / 8);
	elements_per_line = width * components;
	iter2 = oldimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    bit_offset = (psm->pack_skip_pixels * components) % 8;
	    for (j = 0; j < elements_per_line; j++) {
		if (index_format) {
		    current_bit = iter2[0] & 1;
		} else {
		    if (iter2[0] > 32767) {
			current_bit = 1;
		    } else {
			current_bit = 0;
		    }
		}

		if (current_bit) {
		    if (psm->pack_lsb_first) {
			*iter |= (1 << bit_offset);
		    } else {
			*iter |= (1 << (7 - bit_offset));
		    }
		} else {
		    if (psm->pack_lsb_first) {
			*iter &= ~(1 << bit_offset);
		    } else {
			*iter &= ~(1 << (7 - bit_offset));
		    }
		}

		bit_offset++;
		if (bit_offset == 8) {
		    bit_offset = 0;
		    iter++;
		}
		iter2++;
	    }
	    start += rowsize;
	}
    } else {
	element_size = bytes_per_element(type);
	group_size = element_size * components;
	if (element_size == 1) myswap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % psm->pack_alignment);
	if (padding) {
	    rowsize += psm->pack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->pack_skip_rows * rowsize + 
		psm->pack_skip_pixels * group_size;
	elements_per_line = width * components;

	iter2 = oldimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    for (j = 0; j < elements_per_line; j++) {
		Type_Widget widget;

		switch(type) {
		  case GL_UNSIGNED_BYTE:
		    if (index_format) {
			*iter = (GLubyte)*iter2;
		    } else {
			*iter = *iter2 >> 8;
		    }
		    break;
		  case GL_BYTE:
		    if (index_format) {
			*((GLbyte *) iter) = (GLbyte)*iter2;
		    } else {
			*((GLbyte *) iter) = *iter2 >> 9;
		    }
		    break;
		  case GL_UNSIGNED_SHORT:
		  case GL_SHORT:
		    if (type == GL_SHORT) {
			if (index_format) {
			    widget.s[0] = *iter2;
			} else {
			    widget.s[0] = *iter2 >> 1;
			}
		    } else {
			widget.us[0] = *iter2;
		    }
		    if (myswap_bytes) {
			iter[0] = widget.ub[1];
			iter[1] = widget.ub[0];
		    } else {
			iter[0] = widget.ub[0];
			iter[1] = widget.ub[1];
		    }
		    break;
		  case GL_INT:
		  case GL_UNSIGNED_INT:
		  case GL_FLOAT:
		    if (type == GL_FLOAT) {
			if (index_format) {
			    widget.f = *iter2;
			} else {
			    widget.f = *iter2 / (float) 65535.0;
			}
		    } else if (type == GL_UNSIGNED_INT) {
			if (index_format) {
			    widget.ui = *iter2;
			} else {
			    widget.ui = (unsigned int) *iter2 * 65537;
			}
		    } else {
			if (index_format) {
			    widget.i = *iter2;
			} else {
			    widget.i = ((unsigned int) *iter2 * 65537)/2;
			}
		    }
		    if (myswap_bytes) {
			iter[3] = widget.ub[0];
			iter[2] = widget.ub[1];
			iter[1] = widget.ub[2];
			iter[0] = widget.ub[3];
		    } else {
			iter[0] = widget.ub[0];
			iter[1] = widget.ub[1];
			iter[2] = widget.ub[2];
			iter[3] = widget.ub[3];
		    }
		    break;
		}
		iter += element_size;
		iter2++;
	    }
	    start += rowsize;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libutil\error.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1994/09/09 06:03:33 $
*/
#ifdef NT
#include <glos.h>
#endif
#include "gluint.h"
#include <GL/glu.h>

#ifndef NT
#include <stdio.h>
#include <stdlib.h>
#else
#include "glstring.h"
#endif

#ifndef NT

static const char *glErrorStrings[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1] = {
    "invalid enumerant",
    "invalid value",
    "invalid operation",
    "stack overflow",
    "stack underflow",
    "out of memory",
};

static const char *gluErrorStrings[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1] = {
    "invalid enumerant",
    "invalid value",
    "out of memory",
};

#define NERRORS (sizeof(errorStrings)/sizeof(errorStrings[0]))

#else

// For NT, rather using statically allocated strings, we use statically
// allocated string resource identifiers.  The string arrays are dynamically
// initialized using the resource ids to load the appropriate string resource.
// This make localization of the strings easier.

static char  *pszNoError;   // "no error"
static WCHAR *pwszNoError;  // L"no error"

static UINT auiGlErrorStrings[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1] = {
    STR_GLU_INVALID_ENUM,   // "invalid enumerant"
    STR_GLU_INVALID_VAL ,   // "invalid value"
    STR_GLU_INVALID_OP  ,   // "invalid operation"
    STR_GLU_STACK_OVER  ,   // "stack overflow"
    STR_GLU_STACK_UNDER ,   // "stack underflow"
    STR_GLU_OUT_OF_MEM      // "out of memory"
};

static const char *glErrorStrings[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1];
static const WCHAR *glErrorStringsW[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1];

static UINT auiGluErrorStrings[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1] = {
    STR_GLU_INVALID_ENUM,   // "invalid enumerant"
    STR_GLU_INVALID_VAL ,   // "invalid value"
    STR_GLU_OUT_OF_MEM      // "out of memory"
};
static const char *gluErrorStrings[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1];
static const WCHAR *gluErrorStringsW[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1];

char *pszGetResourceStringA(HINSTANCE hMod, UINT uiID)
{
    char *pch;
    char ach[MAX_PATH+1];

    if (!LoadStringA(hMod, uiID, ach, MAX_PATH+1))
        ach[0] = '\0';

    pch = (char *) LocalAlloc(LMEM_FIXED, (lstrlenA(ach)+1) * sizeof(char));
    if (pch)
        lstrcpyA(pch, ach);

    return pch;
}

WCHAR *pwszGetResourceStringW(HINSTANCE hMod, UINT uiID)
{
    WCHAR *pwch;
    WCHAR awch[MAX_PATH+1];

    if (!LoadStringW(hMod, uiID, awch, MAX_PATH+1))
        awch[0] = L'\0';

    pwch = (WCHAR *) LocalAlloc(LMEM_FIXED, (lstrlenW(awch)+1) * sizeof(WCHAR));
    if (pwch)
        lstrcpyW(pwch, awch);

    return pwch;
}

VOID vInitGluStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        pszNoError = pszGetResourceStringA(hMod, STR_GLU_NO_ERROR);

        for (i = 0; i < (GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1); i++)
            glErrorStrings[i] = pszGetResourceStringA(hMod, auiGlErrorStrings[i]);

        for (i = 0; i < (GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1); i++)
            gluErrorStrings[i] = pszGetResourceStringA(hMod, auiGluErrorStrings[i]);
    }
    else
    {
        pwszNoError = pwszGetResourceStringW(hMod, STR_GLU_NO_ERROR);

        for (i = 0; i < (GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1); i++)
            glErrorStringsW[i] = pwszGetResourceStringW(hMod, auiGlErrorStrings[i]);

        for (i = 0; i < (GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1); i++)
            gluErrorStringsW[i] = pwszGetResourceStringW(hMod, auiGluErrorStrings[i]);
    }
}

VOID vInitErrorStrings(BOOL bAnsi)
{
    static BOOL bInitializedAnsi = FALSE;
    static BOOL bInitializedUnicode = FALSE;

    if ( (bAnsi && !bInitializedAnsi) ||
         (!bAnsi && !bInitializedUnicode) )
    {
        HINSTANCE hMod = (HINSTANCE) GetModuleHandle("glu32.dll");

        vInitGluStrings(hMod, bAnsi);
        vInitNurbStrings(hMod, bAnsi);
        vInitTessStrings(hMod, bAnsi);

        if (bAnsi)
            bInitializedAnsi = TRUE;
        else
            bInitializedUnicode = TRUE;
    }
}

const wchar_t* APIENTRY gluErrorUnicodeStringEXT(GLenum errorCode)
{
    vInitErrorStrings(FALSE);

    if (errorCode == 0) {
        return (LPCWSTR) pwszNoError;
    }
    if ((errorCode >= GL_INVALID_ENUM) && (errorCode <= GL_OUT_OF_MEMORY)) {
        return (LPCWSTR) glErrorStringsW[errorCode - GL_INVALID_ENUM];
    }
    if ((errorCode >= GLU_INVALID_ENUM) && (errorCode <= GLU_OUT_OF_MEMORY)) {
        return (LPCWSTR) gluErrorStringsW[errorCode - GLU_INVALID_ENUM];
    }
    if ((errorCode >= GLU_NURBS_ERROR1) && (errorCode <= GLU_NURBS_ERROR37)) {
        return (LPCWSTR) __glNURBSErrorStringW(errorCode - (GLU_NURBS_ERROR1 - 1));
    }
    if ((errorCode >= GLU_TESS_ERROR1) && (errorCode <= GLU_TESS_ERROR8)) {
        return (LPCWSTR) __glTessErrorStringW(errorCode - GLU_TESS_ERROR1);
    }
    return 0;
}

#endif

const GLubyte* APIENTRY gluErrorString(GLenum errorCode)
{
#ifdef NT
    vInitErrorStrings(TRUE);
#endif

    if (errorCode == 0) {
#ifdef NT
        return (const unsigned char *) pszNoError;
#else
	return (const unsigned char *) "no error";
#endif
    }
    if ((errorCode >= GL_INVALID_ENUM) && (errorCode <= GL_OUT_OF_MEMORY)) {
	return (const unsigned char *) glErrorStrings[errorCode - GL_INVALID_ENUM];
    }
    if ((errorCode >= GLU_INVALID_ENUM) && (errorCode <= GLU_OUT_OF_MEMORY)) {
	return (const unsigned char *) gluErrorStrings[errorCode - GLU_INVALID_ENUM];
    }
    if ((errorCode >= GLU_NURBS_ERROR1) && (errorCode <= GLU_NURBS_ERROR37)) {
	return (const unsigned char *) __glNURBSErrorString(errorCode - (GLU_NURBS_ERROR1 - 1));
    }
    if ((errorCode >= GLU_TESS_ERROR1) && (errorCode <= GLU_TESS_ERROR8)) {
	return (const unsigned char *) __glTessErrorString(errorCode - GLU_TESS_ERROR1);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libutil\project.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.2 $
** $Date: 1995/06/23 21:27:54 $
*/
#ifdef NT
#include <glos.h>
#endif
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "gluint.h"

/*
** Make m an identity matrix
*/
void __gluMakeIdentityd(GLdouble m[16])
{
    m[0+4*0] = 1; m[0+4*1] = 0; m[0+4*2] = 0; m[0+4*3] = 0;
    m[1+4*0] = 0; m[1+4*1] = 1; m[1+4*2] = 0; m[1+4*3] = 0;
    m[2+4*0] = 0; m[2+4*1] = 0; m[2+4*2] = 1; m[2+4*3] = 0;
    m[3+4*0] = 0; m[3+4*1] = 0; m[3+4*2] = 0; m[3+4*3] = 1;
}

void __gluMakeIdentityf(GLfloat m[16])
{
    m[0+4*0] = 1; m[0+4*1] = 0; m[0+4*2] = 0; m[0+4*3] = 0;
    m[1+4*0] = 0; m[1+4*1] = 1; m[1+4*2] = 0; m[1+4*3] = 0;
    m[2+4*0] = 0; m[2+4*1] = 0; m[2+4*2] = 1; m[2+4*3] = 0;
    m[3+4*0] = 0; m[3+4*1] = 0; m[3+4*2] = 0; m[3+4*3] = 1;
}

void APIENTRY gluOrtho2D(GLdouble left, GLdouble right,
	       GLdouble bottom, GLdouble top)

{
    glOrtho(left, right, bottom, top, -1, 1);
}

#define __glPi 3.14159265358979323846

void APIENTRY gluPerspective(GLdouble fovy, GLdouble aspect,
		  GLdouble zNear, GLdouble zFar)
{
    GLdouble m[4][4];
    double sine, cotangent, deltaZ;
    double radians = fovy / 2 * __glPi / 180;

    deltaZ = zFar - zNear;
    sine = sin(radians);
    if ((deltaZ == 0) || (sine == 0) || (aspect == 0)) {
	return;
    }
    cotangent = COS(radians) / sine;

    __gluMakeIdentityd(&m[0][0]);
    m[0][0] = cotangent / aspect;
    m[1][1] = cotangent;
    m[2][2] = -(zFar + zNear) / deltaZ;
    m[2][3] = -1;
    m[3][2] = -2 * zNear * zFar / deltaZ;
    m[3][3] = 0;
    glMultMatrixd(&m[0][0]);
}

static void normalize(float v[3])
{
    float r;

    r = sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    if (r == 0.0) return;

    v[0] /= r;
    v[1] /= r;
    v[2] /= r;
}

static void cross(float v1[3], float v2[3], float result[3])
{
    result[0] = v1[1]*v2[2] - v1[2]*v2[1];
    result[1] = v1[2]*v2[0] - v1[0]*v2[2];
    result[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

void APIENTRY gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez,
	      GLdouble centerx, GLdouble centery, GLdouble centerz,
	      GLdouble upx, GLdouble upy, GLdouble upz)
{
    int i;
    float forward[3], side[3], up[3];
    GLfloat m[4][4];

    forward[0] = centerx - eyex;
    forward[1] = centery - eyey;
    forward[2] = centerz - eyez;

    up[0] = upx;
    up[1] = upy;
    up[2] = upz;

    normalize(forward);

    /* Side = forward x up */
    cross(forward, up, side);
    normalize(side);

    /* Recompute up as: up = side x forward */
    cross(side, forward, up);

    __gluMakeIdentityf(&m[0][0]);
    m[0][0] = side[0];
    m[1][0] = side[1];
    m[2][0] = side[2];

    m[0][1] = up[0];
    m[1][1] = up[1];
    m[2][1] = up[2];

    m[0][2] = -forward[0];
    m[1][2] = -forward[1];
    m[2][2] = -forward[2];

    glMultMatrixf(&m[0][0]);
    glTranslated(-eyex, -eyey, -eyez);
}

void __gluMultMatrixVecd(const GLdouble matrix[16], const GLdouble in[4],
		      GLdouble out[4])
{
    int i;

    for (i=0; i<4; i++) {
	out[i] = 
	    in[0] * matrix[0*4+i] +
	    in[1] * matrix[1*4+i] +
	    in[2] * matrix[2*4+i] +
	    in[3] * matrix[3*4+i];
    }
}

/*
** inverse = invert(src)
*/
int __gluInvertMatrixd(const GLdouble src[16], GLdouble inverse[16])
{
    int i, j, k, swap;
    double t;
    GLdouble temp[4][4];

    for (i=0; i<4; i++) {
	for (j=0; j<4; j++) {
	    temp[i][j] = src[i*4+j];
	}
    }
    __gluMakeIdentityd(inverse);

    for (i = 0; i < 4; i++) {
	/*
	** Look for largest element in column
	*/
	swap = i;
	for (j = i + 1; j < 4; j++) {
	    if (fabs(temp[j][i]) > fabs(temp[i][i])) {
		swap = j;
	    }
	}

	if (swap != i) {
	    /*
	    ** Swap rows.
	    */
	    for (k = 0; k < 4; k++) {
		t = temp[i][k];
		temp[i][k] = temp[swap][k];
		temp[swap][k] = t;

		t = inverse[i*4+k];
		inverse[i*4+k] = inverse[swap*4+k];
		inverse[swap*4+k] = t;
	    }
	}

	if (temp[i][i] == 0) {
	    /*
	    ** No non-zero pivot.  The matrix is singular, which shouldn't
	    ** happen.  This means the user gave us a bad matrix.
	    */
	    return GL_FALSE;
	}

	t = temp[i][i];
	for (k = 0; k < 4; k++) {
	    temp[i][k] /= t;
	    inverse[i*4+k] /= t;
	}
	for (j = 0; j < 4; j++) {
	    if (j != i) {
		t = temp[j][i];
		for (k = 0; k < 4; k++) {
		    temp[j][k] -= temp[i][k]*t;
		    inverse[j*4+k] -= inverse[i*4+k]*t;
		}
	    }
	}
    }
    return GL_TRUE;
}

void __gluMultMatricesd(const GLdouble a[16], const GLdouble b[16], GLdouble r[16])
{
    int i, j;

    for (i = 0; i < 4; i++) {
	for (j = 0; j < 4; j++) {
	    r[i*4+j] = 
		a[i*4+0]*b[0*4+j] +
		a[i*4+1]*b[1*4+j] +
		a[i*4+2]*b[2*4+j] +
		a[i*4+3]*b[3*4+j];
	}
    }
}

GLint APIENTRY gluProject(GLdouble objx, GLdouble objy, GLdouble objz,
	      const GLdouble modelMatrix[16], 
	      const GLdouble projMatrix[16],
              const GLint viewport[4],
	      GLdouble *winx, GLdouble *winy, GLdouble *winz)
{
    double in[4];
    double out[4];

    in[0]=objx;
    in[1]=objy;
    in[2]=objz;
    in[3]=1.0;
    __gluMultMatrixVecd(modelMatrix, in, out);
    __gluMultMatrixVecd(projMatrix, out, in);
    if (in[3] == 0.0) return(GL_FALSE);
    in[0] /= in[3];
    in[1] /= in[3];
    in[2] /= in[3];
    /* Map x, y and z to range 0-1 */
    in[0] = in[0] * 0.5 + 0.5;
    in[1] = in[1] * 0.5 + 0.5;
    in[2] = in[2] * 0.5 + 0.5;

    /* Map x,y to viewport */
    in[0] = in[0] * viewport[2] + viewport[0];
    in[1] = in[1] * viewport[3] + viewport[1];

    *winx=in[0];
    *winy=in[1];
    *winz=in[2];
    return(GL_TRUE);
}

GLint APIENTRY gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz,
		const GLdouble modelMatrix[16], 
		const GLdouble projMatrix[16],
                const GLint viewport[4],
	        GLdouble *objx, GLdouble *objy, GLdouble *objz)
{
    double finalMatrix[16];
    double in[4];
    double out[4];

    __gluMultMatricesd(modelMatrix, projMatrix, finalMatrix);
    if (!__gluInvertMatrixd(finalMatrix, finalMatrix)) return(GL_FALSE);

    in[0]=winx;
    in[1]=winy;
    in[2]=winz;
    in[3]=1.0;

    /* Map x and y from window coordinates */
    in[0] = (in[0] - viewport[0]) / viewport[2];
    in[1] = (in[1] - viewport[1]) / viewport[3];

    /* Map to range -1 to 1 */
    in[0] = in[0] * 2 - 1;
    in[1] = in[1] * 2 - 1;
    in[2] = in[2] * 2 - 1;

    __gluMultMatrixVecd(finalMatrix, in, out);
    if (out[3] == 0.0) return(GL_FALSE);
    out[0] /= out[3];
    out[1] /= out[3];
    out[2] /= out[3];
    *objx = out[0];
    *objy = out[1];
    *objz = out[2];
    return(GL_TRUE);
}

void APIENTRY gluPickMatrix(GLdouble x, GLdouble y, GLdouble deltax, GLdouble deltay,
		  GLint viewport[4])
{
    if (deltax <= 0 || deltay <= 0) { 
	return;
    }

    /* Translate and scale the picked region to the entire window */
    glTranslatef((viewport[2] - 2 * (x - viewport[0])) / deltax,
	    (viewport[3] - 2 * (y - viewport[1])) / deltay, 0);
    glScalef(viewport[2] / deltax, viewport[3] / deltay, 1.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libutil\quad.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.5 $
** $Date: 1996/04/02 00:42:17 $
*/

#ifdef NT
#include <glos.h>
#endif
#include "gluint.h"
#include <stdio.h>

#ifndef NT
#include <stdlib.h>
#else
#include "winmem.h"
#endif

#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>

/* Make it not a power of two to avoid cache thrashing on the chip */
#define CACHE_SIZE	240

#define PI            3.14159265358979323846

struct GLUquadric {
    GLint 	normals;
    GLboolean	textureCoords;
    GLint	orientation;
    GLint	drawStyle;
#ifdef NT
    GLUquadricErrorProc errorCallback;
#else
    void	(*errorCallback)( GLint );
#endif
};

GLUquadric * APIENTRY gluNewQuadric(void)
{
    GLUquadric *newstate;

    newstate = (GLUquadric *) malloc(sizeof(GLUquadric));
    if (newstate == NULL) {
	/* Can't report an error at this point... */
	return NULL;
    }
    newstate->normals = GLU_SMOOTH;
    newstate->textureCoords = GL_FALSE;
    newstate->orientation = GLU_OUTSIDE;
    newstate->drawStyle = GLU_FILL;
#ifdef NT
    newstate->errorCallback = (GLUquadricErrorProc)NULL;
#endif
    return newstate;
}


void APIENTRY gluDeleteQuadric(GLUquadric *state)
{
    free(state);
}

static void gluQuadricError(GLUquadric *qobj, GLenum which)
{
    if (qobj->errorCallback) {
	qobj->errorCallback(which);
    }
}

void APIENTRY gluQuadricCallback(GLUquadric *qobj, GLenum which, void (CALLBACK *fn)())
{
    switch (which) {
      case GLU_ERROR:
#ifdef NT
        qobj->errorCallback = (GLUquadricErrorProc) fn;
#else
	qobj->errorCallback = (void (*)(GLint)) fn;
#endif
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
}

void APIENTRY gluQuadricNormals(GLUquadric *qobj, GLenum normals)
{
    switch (normals) {
      case GLU_SMOOTH:
      case GLU_FLAT:
      case GLU_NONE:
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
    qobj->normals = normals;
}

void APIENTRY gluQuadricTexture(GLUquadric *qobj, GLboolean textureCoords)
{
    qobj->textureCoords = textureCoords;
}

void APIENTRY gluQuadricOrientation(GLUquadric *qobj, GLenum orientation)
{
    switch(orientation) {
      case GLU_OUTSIDE:
      case GLU_INSIDE:
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
    qobj->orientation = orientation;
}

void APIENTRY gluQuadricDrawStyle(GLUquadric *qobj, GLenum drawStyle)
{
    switch(drawStyle) {
      case GLU_POINT:
      case GLU_LINE:
      case GLU_FILL:
      case GLU_SILHOUETTE:
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
    qobj->drawStyle = drawStyle;
}

void APIENTRY gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, 
		GLdouble height, GLint slices, GLint stacks)
{
    GLint i,j,max;
    GLfloat sinCache[CACHE_SIZE];
    GLfloat cosCache[CACHE_SIZE];
    GLfloat sinCache2[CACHE_SIZE];
    GLfloat cosCache2[CACHE_SIZE];
    GLfloat sinCache3[CACHE_SIZE];
    GLfloat cosCache3[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y, zLow, zHigh;
    GLfloat sintemp, costemp;
    GLfloat length;
    GLfloat deltaRadius;
    GLfloat zNormal;
    GLfloat xyNormalRatio;
    GLfloat radiusLow, radiusHigh;
    int needCache2, needCache3;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;

    if (slices < 2 || stacks < 1 || baseRadius < 0.0 || topRadius < 0.0 ||
	    height < 0.0) {
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    /* Compute length (needed for normal calculations) */
    deltaRadius = baseRadius - topRadius;
    length = SQRT(deltaRadius*deltaRadius + height*height);
#ifdef NT
    if (length == (GLfloat)0.0) {
#else
    if (length == 0.0) {
#endif
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    /* Cache is the vertex locations cache */
    /* Cache2 is the various normals at the vertices themselves */
    /* Cache3 is the various normals for the faces */
    needCache2 = needCache3 = 0;
    if (qobj->normals == GLU_SMOOTH) {
	needCache2 = 1;
    }

    if (qobj->normals == GLU_FLAT) {
	if (qobj->drawStyle != GLU_POINT) {
	    needCache3 = 1;
	}
	if (qobj->drawStyle == GLU_LINE) {
	    needCache2 = 1;
	}
    }

    zNormal = deltaRadius / length;
    xyNormalRatio = height / length;

    for (i = 0; i < slices; i++) {
	angle = 2 * PI * i / slices;
	if (needCache2) {
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache2[i] = xyNormalRatio * SIN(angle);
		cosCache2[i] = xyNormalRatio * COS(angle);
	    } else {
		sinCache2[i] = -xyNormalRatio * SIN(angle);
		cosCache2[i] = -xyNormalRatio * COS(angle);
	    }
	} 
	sinCache[i] = SIN(angle);
	cosCache[i] = COS(angle);
    }

    if (needCache3) {
	for (i = 0; i < slices; i++) {
	    angle = 2 * PI * (i-0.5) / slices;
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache3[i] = xyNormalRatio * SIN(angle);
		cosCache3[i] = xyNormalRatio * COS(angle);
	    } else {
		sinCache3[i] = -xyNormalRatio * SIN(angle);
		cosCache3[i] = -xyNormalRatio * COS(angle);
	    }
	}
    } 

    sinCache[slices] = sinCache[0];
    cosCache[slices] = cosCache[0];
    if (needCache2) {
	sinCache2[slices] = sinCache2[0];
	cosCache2[slices] = cosCache2[0];
    }
    if (needCache3) {
	sinCache3[slices] = sinCache3[0];
	cosCache3[slices] = cosCache3[0];
    }

    switch (qobj->drawStyle) {
      case GLU_FILL:
	/* Note:
	** An argument could be made for using a TRIANGLE_FAN for the end
	** of the cylinder of either radii is 0.0 (a cone).  However, a 
	** TRIANGLE_FAN would not work in smooth shading mode (the common 
	** case) because the normal for the apex is different for every
	** triangle (and TRIANGLE_FAN doesn't let me respecify that normal).
	** Now, my choice is GL_TRIANGLES, or leave the GL_QUAD_STRIP and
	** just let the GL trivially reject one of the two triangles of the
	** QUAD.  GL_QUAD_STRIP is probably faster, so I will leave this code
	** alone.
	*/
	for (j = 0; j < stacks; j++) {
	    zLow = j * height / stacks;
	    zHigh = (j + 1) * height / stacks;
	    radiusLow = baseRadius - deltaRadius * ((float) j / stacks);
	    radiusHigh = baseRadius - deltaRadius * ((float) (j + 1) / stacks);

	    glBegin(GL_QUAD_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3[i], cosCache3[i], zNormal);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) j / stacks);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], zLow);
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) (j+1) / stacks);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], zHigh);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) (j+1) / stacks);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], zHigh);
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) j / stacks);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], zLow);
		}
	    }
	    glEnd();
	}
	break;
      case GLU_POINT:
	glBegin(GL_POINTS);
	for (i = 0; i < slices; i++) {
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		break;
	      case GLU_NONE:
	      default:
		break;
	    }
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    for (j = 0; j <= stacks; j++) {
		zLow = j * height / stacks;
		radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sintemp, 
			radiusLow * costemp, zLow);
	    }
	}
	glEnd();
	break;
      case GLU_LINE:
	for (j = 1; j < stacks; j++) {
	    zLow = j * height / stacks;
	    radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3[i], cosCache3[i], zNormal);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sinCache[i], 
			radiusLow * cosCache[i], zLow);
	    }
	    glEnd();
	}
	/* Intentionally fall through here... */
      case GLU_SILHOUETTE:
	for (j = 0; j <= stacks; j += stacks) {
	    zLow = j * height / stacks;
	    radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3[i], cosCache3[i], zNormal);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 
			zLow);
	    }
	    glEnd();
	}
	for (i = 0; i < slices; i++) {
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		glNormal3f(sinCache2[i], cosCache2[i], 0.0);
		break;
	      case GLU_NONE:
	      default:
		break;
	    }
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    glBegin(GL_LINE_STRIP);
	    for (j = 0; j <= stacks; j++) {
		zLow = j * height / stacks;
		radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sintemp, 
			radiusLow * costemp, zLow);
	    }
	    glEnd();
	}
	break;
      default:
	break;
    }
}

void APIENTRY gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, 
	    GLint slices, GLint loops)
{
    gluPartialDisk(qobj, innerRadius, outerRadius, slices, loops, 0.0, 360.0);
}

void APIENTRY gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, 
		   GLdouble outerRadius, GLint slices, GLint loops,
		   GLdouble startAngle, GLdouble sweepAngle)
{
    GLint i,j,max;
    GLfloat sinCache[CACHE_SIZE];
    GLfloat cosCache[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y;
    GLfloat sintemp, costemp;
    GLfloat deltaRadius;
    GLfloat radiusLow, radiusHigh;
    GLfloat texLow, texHigh;
    GLfloat angleOffset;
    GLint slices2;
    GLint finish;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (slices < 2 || loops < 1 || outerRadius <= 0.0 || innerRadius < 0.0 ||
	    innerRadius > outerRadius) {
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    if (sweepAngle < -360.0) sweepAngle = 360.0;
    if (sweepAngle > 360.0) sweepAngle = 360.0;
    if (sweepAngle < 0) {
	startAngle += sweepAngle;
	sweepAngle = -sweepAngle;
    }

    if (sweepAngle == 360.0) {
	slices2 = slices;
    } else {
	slices2 = slices + 1;
    }

    /* Compute length (needed for normal calculations) */
    deltaRadius = outerRadius - innerRadius;

    /* Cache is the vertex locations cache */

    angleOffset = startAngle / 180.0 * PI;
    for (i = 0; i <= slices; i++) {
	angle = angleOffset + ((PI * sweepAngle) / 180.0) * i / slices;
	sinCache[i] = SIN(angle);
	cosCache[i] = COS(angle);
    }

    if (sweepAngle == 360.0) {
	sinCache[slices] = sinCache[0];
	cosCache[slices] = cosCache[0];
    }

    switch(qobj->normals) {
      case GLU_FLAT:
      case GLU_SMOOTH:
	if (qobj->orientation == GLU_OUTSIDE) {
	    glNormal3f(0.0, 0.0, 1.0);
	} else {
	    glNormal3f(0.0, 0.0, -1.0);
	}
	break;
      default:
      case GLU_NONE:
	break;
    }

    switch (qobj->drawStyle) {
      case GLU_FILL:
	if (innerRadius == 0.0) {
	    finish = loops - 1;
	    /* Triangle strip for inner polygons */
	    glBegin(GL_TRIANGLE_FAN);
	    if (qobj->textureCoords) {
		glTexCoord2f(0.5, 0.5);
	    }
	    glVertex3f(0.0, 0.0, 0.0);
	    radiusLow = outerRadius - 
		    deltaRadius * ((float) (loops-1) / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
	    }

	    if (qobj->orientation == GLU_OUTSIDE) {
		for (i = slices; i >= 0; i--) {
		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);
		}
	    } else {
		for (i = 0; i <= slices; i++) {
		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);
		}
	    }
	    glEnd();
	} else {
	    finish = loops;
	}
	for (j = 0; j < finish; j++) {
	    radiusLow = outerRadius - deltaRadius * ((float) j / loops);
	    radiusHigh = outerRadius - deltaRadius * ((float) (j + 1) / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
		texHigh = radiusHigh / outerRadius / 2;
	    }

	    glBegin(GL_QUAD_STRIP);
	    for (i = 0; i <= slices; i++) {
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);

		    if (qobj->textureCoords) {
			glTexCoord2f(texHigh * sinCache[i] + 0.5,
				texHigh * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], 0.0);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(texHigh * sinCache[i] + 0.5,
				texHigh * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], 0.0);

		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);
		}
	    }
	    glEnd();
	}
	break;
      case GLU_POINT:
	glBegin(GL_POINTS);
	for (i = 0; i < slices2; i++) {
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    for (j = 0; j <= loops; j++) {
		radiusLow = outerRadius - deltaRadius * ((float) j / loops);

		if (qobj->textureCoords) {
		    texLow = radiusLow / outerRadius / 2;

		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0);
	    }
	}
	glEnd();
	break;
      case GLU_LINE:
	if (innerRadius == outerRadius) {
	    glBegin(GL_LINE_STRIP);

	    for (i = 0; i <= slices; i++) {
		if (qobj->textureCoords) {
		    glTexCoord2f(sinCache[i] / 2 + 0.5,
			    cosCache[i] / 2 + 0.5);
		}
		glVertex3f(innerRadius * sinCache[i],
			innerRadius * cosCache[i], 0.0);
	    }
	    glEnd();
	    break;
	}
	for (j = 0; j <= loops; j++) {
	    radiusLow = outerRadius - deltaRadius * ((float) j / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		if (qobj->textureCoords) {
		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sinCache[i], 
			radiusLow * cosCache[i], 0.0);
	    }
	    glEnd();
	}
	for (i=0; i < slices2; i++) {
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    glBegin(GL_LINE_STRIP);
	    for (j = 0; j <= loops; j++) {
		radiusLow = outerRadius - deltaRadius * ((float) j / loops);
		if (qobj->textureCoords) {
		    texLow = radiusLow / outerRadius / 2;
		}

		if (qobj->textureCoords) {
		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0);
	    }
	    glEnd();
	}
	break;
      case GLU_SILHOUETTE:
	if (sweepAngle < 360.0) {
	    for (i = 0; i <= slices; i+= slices) {
		sintemp = sinCache[i];
		costemp = cosCache[i];
		glBegin(GL_LINE_STRIP);
		for (j = 0; j <= loops; j++) {
		    radiusLow = outerRadius - deltaRadius * ((float) j / loops);

		    if (qobj->textureCoords) {
			texLow = radiusLow / outerRadius / 2;
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0);
		}
		glEnd();
	    }
	}
	for (j = 0; j <= loops; j += loops) {
	    radiusLow = outerRadius - deltaRadius * ((float) j / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		if (qobj->textureCoords) {
		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sinCache[i], 
			radiusLow * cosCache[i], 0.0);
	    }
	    glEnd();
	    if (innerRadius == outerRadius) break;
	}
	break;
      default:
	break;
    }
}

void APIENTRY gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
{
    GLint i,j,max;
    GLfloat sinCache1a[CACHE_SIZE];
    GLfloat cosCache1a[CACHE_SIZE];
    GLfloat sinCache2a[CACHE_SIZE];
    GLfloat cosCache2a[CACHE_SIZE];
    GLfloat sinCache3a[CACHE_SIZE];
    GLfloat cosCache3a[CACHE_SIZE];
    GLfloat sinCache1b[CACHE_SIZE];
    GLfloat cosCache1b[CACHE_SIZE];
    GLfloat sinCache2b[CACHE_SIZE];
    GLfloat cosCache2b[CACHE_SIZE];
    GLfloat sinCache3b[CACHE_SIZE];
    GLfloat cosCache3b[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y, zLow, zHigh;
    GLfloat sintemp1, sintemp2, sintemp3, sintemp4;
    GLfloat costemp1, costemp2, costemp3, costemp4;
    GLfloat zNormal;
    GLfloat xyNormalRatio;
    GLboolean needCache2, needCache3;
    GLint start, finish;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;
    if (slices < 2 || stacks < 1 || radius < 0.0) {
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    /* Cache is the vertex locations cache */
    /* Cache2 is the various normals at the vertices themselves */
    /* Cache3 is the various normals for the faces */
    needCache2 = needCache3 = GL_FALSE;

    if (qobj->normals == GLU_SMOOTH) {
	needCache2 = GL_TRUE;
    }

    if (qobj->normals == GLU_FLAT) {
	if (qobj->drawStyle != GLU_POINT) {
	    needCache3 = GL_TRUE;
	}
	if (qobj->drawStyle == GLU_LINE) {
	    needCache2 = GL_TRUE;
	}
    }

    for (i = 0; i < slices; i++) {
	angle = 2 * PI * i / slices;
	sinCache1a[i] = SIN(angle);
	cosCache1a[i] = COS(angle);
	if (needCache2) {
	    sinCache2a[i] = sinCache1a[i];
	    cosCache2a[i] = cosCache1a[i];
	}
    }

    for (j = 0; j <= stacks; j++) {
	angle = PI * j / stacks;
	if (needCache2) {
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache2b[j] = SIN(angle);
		cosCache2b[j] = COS(angle);
	    } else {
		sinCache2b[j] = -SIN(angle);
		cosCache2b[j] = -COS(angle);
	    }
	}
	sinCache1b[j] = radius * SIN(angle);
	cosCache1b[j] = radius * COS(angle);
    }
    /* Make sure it comes to a point */
    sinCache1b[0] = 0;
    sinCache1b[stacks] = 0;

    if (needCache3) {
	for (i = 0; i < slices; i++) {
	    angle = 2 * PI * (i-0.5) / slices;
	    sinCache3a[i] = SIN(angle);
	    cosCache3a[i] = COS(angle);
	}
	for (j = 0; j <= stacks; j++) {
	    angle = PI * (j - 0.5) / stacks;
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache3b[j] = SIN(angle);
		cosCache3b[j] = COS(angle);
	    } else {
		sinCache3b[j] = -SIN(angle);
		cosCache3b[j] = -COS(angle);
	    }
	}
    } 

    sinCache1a[slices] = sinCache1a[0];
    cosCache1a[slices] = cosCache1a[0];
    if (needCache2) {
	sinCache2a[slices] = sinCache2a[0];
	cosCache2a[slices] = cosCache2a[0];
    }
    if (needCache3) {
	sinCache3a[slices] = sinCache3a[0];
	cosCache3a[slices] = cosCache3a[0];
    }

    switch (qobj->drawStyle) {
      case GLU_FILL:
	/* Do ends of sphere as TRIANGLE_FAN's (if not texturing)
	** We don't do it when texturing because we need to respecify the
	** texture coordinates of the apex for every adjacent vertex (because
	** it isn't a constant for that point)
	*/
	if (!(qobj->textureCoords)) {
	    start = 1;
	    finish = stacks - 1;

	    /* Low end first (j == 0 iteration) */
	    sintemp2 = sinCache1b[1];
	    zHigh = cosCache1b[1];
	    switch(qobj->normals) {
	      case GLU_FLAT:
		sintemp3 = sinCache3b[1];
		costemp3 = cosCache3b[1];
		break;
	      case GLU_SMOOTH:
		sintemp3 = sinCache2b[1];
		costemp3 = cosCache2b[1];
		glNormal3f(sinCache2a[0] * sinCache2b[0],
			cosCache2a[0] * sinCache2b[0],
			cosCache2b[0]);
		break;
	      default:
		break;
	    }
	    glBegin(GL_TRIANGLE_FAN);
	    glVertex3f(0.0, 0.0, radius);
	    if (qobj->orientation == GLU_OUTSIDE) {
		for (i = slices; i >= 0; i--) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			if (i != slices) {
			    glNormal3f(sinCache3a[i+1] * sintemp3,
				    cosCache3a[i+1] * sintemp3,
				    costemp3);
			}
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    } else {
		for (i = 0; i <= slices; i++) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			glNormal3f(sinCache3a[i] * sintemp3,
				cosCache3a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    }
	    glEnd();

	    /* High end next (j == stacks-1 iteration) */
	    sintemp2 = sinCache1b[stacks-1];
	    zHigh = cosCache1b[stacks-1];
	    switch(qobj->normals) {
	      case GLU_FLAT:
		sintemp3 = sinCache3b[stacks];
		costemp3 = cosCache3b[stacks];
		break;
	      case GLU_SMOOTH:
		sintemp3 = sinCache2b[stacks-1];
		costemp3 = cosCache2b[stacks-1];
		glNormal3f(sinCache2a[stacks] * sinCache2b[stacks],
			cosCache2a[stacks] * sinCache2b[stacks],
			cosCache2b[stacks]);
		break;
	      default:
		break;
	    }
	    glBegin(GL_TRIANGLE_FAN);
	    glVertex3f(0.0, 0.0, -radius);
	    if (qobj->orientation == GLU_OUTSIDE) {
		for (i = 0; i <= slices; i++) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			glNormal3f(sinCache3a[i] * sintemp3,
				cosCache3a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    } else {
		for (i = slices; i >= 0; i--) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			if (i != slices) {
			    glNormal3f(sinCache3a[i+1] * sintemp3,
				    cosCache3a[i+1] * sintemp3,
				    costemp3);
			}
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    }
	    glEnd();
	} else {
	    start = 0;
	    finish = stacks;
	}
	for (j = start; j < finish; j++) {
	    zLow = cosCache1b[j];
	    zHigh = cosCache1b[j+1];
	    sintemp1 = sinCache1b[j];
	    sintemp2 = sinCache1b[j+1];
	    switch(qobj->normals) {
	      case GLU_FLAT:
		sintemp4 = sinCache3b[j+1];
		costemp4 = cosCache3b[j+1];
		break;
	      case GLU_SMOOTH:
		if (qobj->orientation == GLU_OUTSIDE) {
		    sintemp3 = sinCache2b[j+1];
		    costemp3 = cosCache2b[j+1];
		    sintemp4 = sinCache2b[j];
		    costemp4 = cosCache2b[j];
		} else {
		    sintemp3 = sinCache2b[j];
		    costemp3 = cosCache2b[j];
		    sintemp4 = sinCache2b[j+1];
		    costemp4 = cosCache2b[j+1];
		}
		break;
	      default:
	        break;
	    }

	    glBegin(GL_QUAD_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp3,
			    cosCache2a[i] * sintemp3,
			    costemp3);
		    break;
		  case GLU_FLAT:
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) (j+1) / stacks);
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) j / stacks);
		    }
		    glVertex3f(sintemp1 * sinCache1a[i],
			    sintemp1 * cosCache1a[i], zLow);
		}
		switch(qobj->normals) {
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp4,
			    cosCache2a[i] * sintemp4,
			    costemp4);
		    break;
		  case GLU_FLAT:
		    glNormal3f(sinCache3a[i] * sintemp4,
			    cosCache3a[i] * sintemp4,
			    costemp4);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) j / stacks);
		    }
		    glVertex3f(sintemp1 * sinCache1a[i],
			    sintemp1 * cosCache1a[i], zLow);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) (j+1) / stacks);
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    }
	    glEnd();
	}
	break;
      case GLU_POINT:
	glBegin(GL_POINTS);
	for (j = 0; j <= stacks; j++) {
	    sintemp1 = sinCache1b[j];
	    costemp1 = cosCache1b[j];
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		sintemp2 = sinCache2b[j];
		costemp2 = cosCache2b[j];
		break;
	      default:
	        break;
	    }
	    for (i = 0; i < slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp2,
			    cosCache2a[i] * sintemp2,
			    costemp2);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}

		zLow = j * radius / stacks;

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    1 - (float) j / stacks);
		}
		glVertex3f(sintemp1 * sinCache1a[i], 
			sintemp1 * cosCache1a[i], costemp1);
	    }
	}
	glEnd();
	break;
      case GLU_LINE:
      case GLU_SILHOUETTE:
	for (j = 1; j < stacks; j++) {
	    sintemp1 = sinCache1b[j];
	    costemp1 = cosCache1b[j];
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		sintemp2 = sinCache2b[j];
		costemp2 = cosCache2b[j];
		break;
	      default:
		break;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3a[i] * sintemp2,
			    cosCache3a[i] * sintemp2,
			    costemp2);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp2,
			    cosCache2a[i] * sintemp2,
			    costemp2);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    1 - (float) j / stacks);
		}
		glVertex3f(sintemp1 * sinCache1a[i], 
			sintemp1 * cosCache1a[i], costemp1);
	    }
	    glEnd();
	}
	for (i = 0; i < slices; i++) {
	    sintemp1 = sinCache1a[i];
	    costemp1 = cosCache1a[i];
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		sintemp2 = sinCache2a[i];
		costemp2 = cosCache2a[i];
		break;
	      default:
		break;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (j = 0; j <= stacks; j++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sintemp2 * sinCache3b[j],
			    costemp2 * sinCache3b[j],
			    cosCache3b[j]);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sintemp2 * sinCache2b[j],
			    costemp2 * sinCache2b[j],
			    cosCache2b[j]);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    1 - (float) j / stacks);
		}
		glVertex3f(sintemp1 * sinCache1b[j], 
			costemp1 * sinCache1b[j], cosCache1b[j]);
	    }
	    glEnd();
	}
	break;
      default:
	break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\clients\glcurvev.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glcurveval.c++ - curve evaluator
 *
 * $Revision: 1.1 $
 */

/* Polynomial Evaluator Interface */

#include <glos.h>
#include <GL/gl.h>
#include "glimport.h"
#include "glrender.h"
#include "glcurvev.h"
#include "nurbscon.h"
 
OpenGLCurveEvaluator::OpenGLCurveEvaluator(void) 
{ 
}

OpenGLCurveEvaluator::~OpenGLCurveEvaluator(void) 
{ 
}

/* added nonsense to avoid the warning messages at compile time */
void
OpenGLCurveEvaluator::addMap(CurveMap *m)
{
	m = m;
}

void
OpenGLCurveEvaluator::range1f(long type, REAL *from, REAL *to)
{
	type = type;
	from = from;
	to = to;
}

void
OpenGLCurveEvaluator::domain1f(REAL ulo, REAL uhi)
{
	ulo = ulo;
	uhi = uhi;
}

void
OpenGLCurveEvaluator::bgnline(void)
{
    glBegin((GLenum) GL_LINE_STRIP);
}

void
OpenGLCurveEvaluator::endline(void)
{
    glEnd();
}

/*---------------------------------------------------------------------------
 * disable - turn off a curve map
 *---------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::disable(long type)
{
    glDisable((GLenum) type);
}

/*---------------------------------------------------------------------------
 * enable - turn on a curve map
 *---------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::enable(long type)
{
    glEnable((GLenum) type);
}

/*-------------------------------------------------------------------------
 * mapgrid1f - define a lattice of points with origin and offset
 *-------------------------------------------------------------------------
 */
void 
OpenGLCurveEvaluator::mapgrid1f(long nu, REAL u0, REAL u1)
{
    glMapGrid1f((GLint) nu, (GLfloat) u0, (GLfloat) u1);
}

/*-------------------------------------------------------------------------
 * bgnmap1 - preamble to curve definition and evaluations
 *-------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::bgnmap1f(long)
{
    glPushAttrib((GLbitfield) GL_EVAL_BIT);
}

/*-------------------------------------------------------------------------
 * endmap1 - postamble to a curve map
 *-------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::endmap1f(void)
{
    glPopAttrib();
}

/*-------------------------------------------------------------------------
 * map1f - pass a desription of a curve map
 *-------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::map1f(
    long type,		 	/* map type */
    REAL ulo,			/* lower parametric bound */
    REAL uhi,			/* upper parametric bound */
    long stride, 		/* distance to next point in REALS */
    long order,			/* parametric order */
    REAL *pts 			/* control points */
)
{
    glMap1f((GLenum) type, (GLfloat) ulo, (GLfloat) uhi, (GLint) stride, 
	    (GLint) order, (const GLfloat *) pts);
}

/*-------------------------------------------------------------------------
 * mapmesh1f - evaluate a mesh of points on lattice
 *-------------------------------------------------------------------------
 */
void OpenGLCurveEvaluator::mapmesh1f(long style, long from, long to)
{
    switch(style) {
    default:
    case N_MESHFILL:
    case N_MESHLINE:
	glEvalMesh1((GLenum) GL_LINE, (GLint) from, (GLint) to);
	break;
    case N_MESHPOINT:
	glEvalMesh1((GLenum) GL_POINT, (GLint) from, (GLint) to);
	break;
    }
}

/*-------------------------------------------------------------------------
 * evalpoint1i - evaluate a point on a curve
 *-------------------------------------------------------------------------
 */
void OpenGLCurveEvaluator::evalpoint1i(long i)
{
    glEvalPoint1((GLint) i);
}

/*-------------------------------------------------------------------------
 * evalcoord1f - evaluate a point on a curve
 *-------------------------------------------------------------------------
 */
void OpenGLCurveEvaluator::evalcoord1f(long, REAL u)
{
    glEvalCoord1f((GLfloat) u);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\libutil\registry.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1996/03/18 10:54:22 $
*/
#include <glos.h>
#include <GL/glu.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef NT
static const GLubyte versionString[] = "1.2.2.0 Microsoft Corporation";
static const GLubyte extensionString[] = "GL_EXT_bgra";
static const GLubyte nullString[] = "";
#else
static const GLubyte versionString[] = "1.2 Irix 6.2";
static const GLubyte extensionString[] = "";
#endif

const GLubyte * APIENTRY gluGetString(GLenum name)
{
char *str;

    if (name == GLU_VERSION) {
        return versionString;
    } else if (name == GLU_EXTENSIONS) {
        str = (char *) glGetString(GL_EXTENSIONS);
        if (str != NULL)
            if (strstr( str, "GL_EXT_bgra") != NULL)
                return extensionString;
        return nullString;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\clients\glrender.cxx ===
#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glimport.h"
#include "glrender.h"

GLUnurbs::GLUnurbs(void)
	: NurbsTessellator(curveEvaluator, surfaceEvaluator)
{
    redefineMaps();
    defineMap(GL_MAP2_NORMAL, 0, 3);
    defineMap(GL_MAP1_NORMAL, 0, 3);
    defineMap(GL_MAP2_TEXTURE_COORD_1, 0, 1);
    defineMap(GL_MAP1_TEXTURE_COORD_1, 0, 1);
    defineMap(GL_MAP2_TEXTURE_COORD_2, 0, 2);
    defineMap(GL_MAP1_TEXTURE_COORD_2, 0, 2);
    defineMap(GL_MAP2_TEXTURE_COORD_3, 0, 3);
    defineMap(GL_MAP1_TEXTURE_COORD_3, 0, 3);
    defineMap(GL_MAP2_TEXTURE_COORD_4, 1, 4);
    defineMap(GL_MAP1_TEXTURE_COORD_4, 1, 4);
    defineMap(GL_MAP2_VERTEX_4, 1, 4);
    defineMap(GL_MAP1_VERTEX_4, 1, 4);
    defineMap(GL_MAP2_VERTEX_3, 0, 3);
    defineMap(GL_MAP1_VERTEX_3, 0, 3);
    defineMap(GL_MAP2_COLOR_4, 0, 4);
    defineMap(GL_MAP1_COLOR_4, 0, 4);
    defineMap(GL_MAP2_INDEX, 0, 1);
    defineMap(GL_MAP1_INDEX, 0, 1);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_PIXEL_TOLERANCE, (float) 50.0);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_PIXEL_TOLERANCE, (float) 50.0);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_PIXEL_TOLERANCE, (float) 50.0);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_PIXEL_TOLERANCE, (float) 50.0);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_ERROR_TOLERANCE, (float) 0.50);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_ERROR_TOLERANCE, (float) 0.50);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_ERROR_TOLERANCE, (float) 0.50);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_ERROR_TOLERANCE, (float) 0.50);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_S_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_S_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_S_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_S_STEPS, (float) 100.0);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_T_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_T_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_T_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_T_STEPS, (float) 100.0);

    autoloadmode = 1;
    errorCallback = NULL;
}

void
GLUnurbs::bgnrender(void)
{
    if (autoloadmode) {
	loadGLMatrices();
    }
}

void
GLUnurbs::endrender(void)
{
}

void
GLUnurbs::errorHandler(int i)
{
    GLenum gluError;

    gluError = i + (GLU_NURBS_ERROR1 - 1);
    postError( gluError );
}

void 
GLUnurbs::loadGLMatrices(void) 
{
    GLfloat vmat[4][4];
    GLint viewport[4];

    grabGLMatrix((GLfloat (*)[4]) vmat);
    loadCullingMatrix((GLfloat (*)[4]) vmat);
    ::glGetIntegerv((GLenum) GL_VIEWPORT, (GLint *) viewport);
    loadSamplingMatrix((const GLfloat (*)[4]) vmat, (const GLint *) viewport);
}

#ifdef NT
void
GLUnurbs::useGLMatrices(
                          const GLfloat modelMatrix[4][4],
			  const GLfloat projMatrix[4][4],
			  const GLint viewport[4])
{
    GLfloat vmat[4][4];

    multmatrix4d(vmat, modelMatrix, projMatrix);
    loadCullingMatrix(vmat);
    loadSamplingMatrix(vmat, viewport);
}
#else
void
GLUnurbs::useGLMatrices(const GLfloat modelMatrix[16], 
			  const GLfloat projMatrix[16],
			  const GLint viewport[4])
{
    GLfloat vmat[4][4];

    multmatrix4d((GLfloat (*)[4]) vmat, (GLfloat (*)[4]) modelMatrix, 
	    (GLfloat (*)[4]) projMatrix);
    loadCullingMatrix((GLfloat (*)[4]) vmat);
    loadSamplingMatrix((const GLfloat (*)[4]) vmat, (const GLint *) viewport);
}
#endif

/*--------------------------------------------------------------------------
 * grabGLMatrix  
 *--------------------------------------------------------------------------
 */

void
GLUnurbs::grabGLMatrix(GLfloat vmat[4][4])
{
    GLfloat m1[4][4], m2[4][4];

    ::glGetFloatv((GLenum) GL_MODELVIEW_MATRIX, (GLfloat *) &(m1[0][0]));
    ::glGetFloatv((GLenum) GL_PROJECTION_MATRIX, (GLfloat *) &(m2[0][0]));
    multmatrix4d((GLfloat (*)[4]) vmat, 
	    (GLfloat (*)[4]) m1, (GLfloat (*)[4]) m2);
}

void
GLUnurbs::loadSamplingMatrix(const GLfloat vmat[4][4], 
			       const GLint viewport[4])
{

    /* rescale the mapping to correspond to pixels in x/y */
    REAL xsize = 0.5 * (REAL) (viewport[2]);
    REAL ysize = 0.5 * (REAL) (viewport[3]);
 
    INREAL smat[4][4];
    smat[0][0] = vmat[0][0] * xsize;
    smat[1][0] = vmat[1][0] * xsize;
    smat[2][0] = vmat[2][0] * xsize;
    smat[3][0] = vmat[3][0] * xsize;

    smat[0][1] = vmat[0][1] * ysize;
    smat[1][1] = vmat[1][1] * ysize;
    smat[2][1] = vmat[2][1] * ysize;
    smat[3][1] = vmat[3][1] * ysize;

    smat[0][2] = 0.0;
    smat[1][2] = 0.0;
    smat[2][2] = 0.0;
    smat[3][2] = 0.0;

    smat[0][3] = vmat[0][3];
    smat[1][3] = vmat[1][3];
    smat[2][3] = vmat[2][3];
    smat[3][3] = vmat[3][3];

    const long rstride = sizeof(smat[0]) / sizeof(smat[0][0]);
    const long cstride = 1;

    setnurbsproperty(GL_MAP1_VERTEX_3, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
}

void
GLUnurbs::loadCullingMatrix(GLfloat vmat[4][4])
{
    INREAL cmat[4][4];

    cmat[0][0] = vmat[0][0];
    cmat[0][1] = vmat[0][1];
    cmat[0][2] = vmat[0][2];
    cmat[0][3] = vmat[0][3];

    cmat[1][0] = vmat[1][0];
    cmat[1][1] = vmat[1][1];
    cmat[1][2] = vmat[1][2];
    cmat[1][3] = vmat[1][3];

    cmat[2][0] = vmat[2][0];
    cmat[2][1] = vmat[2][1];
    cmat[2][2] = vmat[2][2];
    cmat[2][3] = vmat[2][3];

    cmat[3][0] = vmat[3][0];
    cmat[3][1] = vmat[3][1];
    cmat[3][2] = vmat[3][2];
    cmat[3][3] = vmat[3][3];

    const long rstride = sizeof(cmat[0]) / sizeof(cmat[0][0]);
    const long cstride = 1;

    setnurbsproperty(GL_MAP2_VERTEX_3, N_CULLINGMATRIX, &cmat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_CULLINGMATRIX, &cmat[0][0], rstride, 
	    cstride);
}

/*---------------------------------------------------------------------
 * A = B * MAT ; transform a 4d vector through a 4x4 matrix
 *---------------------------------------------------------------------
 */
void
GLUnurbs::transform4d(GLfloat A[4], GLfloat B[4], GLfloat mat[4][4])
{

    A[0] = B[0]*mat[0][0] + B[1]*mat[1][0] + B[2]*mat[2][0] + B[3]*mat[3][0];
    A[1] = B[0]*mat[0][1] + B[1]*mat[1][1] + B[2]*mat[2][1] + B[3]*mat[3][1];
    A[2] = B[0]*mat[0][2] + B[1]*mat[1][2] + B[2]*mat[2][2] + B[3]*mat[3][2];
    A[3] = B[0]*mat[0][3] + B[1]*mat[1][3] + B[2]*mat[2][3] + B[3]*mat[3][3];
}

/*---------------------------------------------------------------------
 * new = [left][right] ; multiply two matrices together
 *---------------------------------------------------------------------
 */
void
GLUnurbs::multmatrix4d (GLfloat n[4][4], GLfloat left[4][4], GLfloat right[4][4])
{
    transform4d ((GLfloat *) n[0],(GLfloat *) left[0],(GLfloat (*)[4]) right);
    transform4d ((GLfloat *) n[1],(GLfloat *) left[1],(GLfloat (*)[4]) right);
    transform4d ((GLfloat *) n[2],(GLfloat *) left[2],(GLfloat (*)[4]) right);
    transform4d ((GLfloat *) n[3],(GLfloat *) left[3],(GLfloat (*)[4]) right);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\clients\glsurfev.h ===
#ifndef __gluglsurfeval_h_
#define __gluglsurfeval_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glsurfeval.h
 *
 * $Revision: 1.2 $
 */

#ifndef NT
#pragma once
#endif

#include "basicsur.h"

class SurfaceMap;
class OpenGLSurfaceEvaluator;
class StoredVertex;

#define TYPECOORD	1
#define TYPEPOINT	2

/* Cache up to 3 vertices from tmeshes */
#define VERTEX_CACHE_SIZE	3

class StoredVertex {
public:
    		StoredVertex() { type = 0; }
		~StoredVertex(void) {}
    void	saveEvalCoord(REAL x, REAL y) 
		    {coord[0] = x; coord[1] = y; type = TYPECOORD; }
    void	saveEvalPoint(long x, long y)
		    {point[0] = x; point[1] = y; type = TYPEPOINT; }
    void	invoke(OpenGLSurfaceEvaluator *eval);

private:
    int		type;
    REAL	coord[2];
    long	point[2];
};

class OpenGLSurfaceEvaluator : public BasicSurfaceEvaluator {
public:
			OpenGLSurfaceEvaluator();
    			~OpenGLSurfaceEvaluator( void );
    void		polymode( long style );
    void		range2f( long, REAL *, REAL * );
    void		domain2f( REAL, REAL, REAL, REAL );
    void		addMap( SurfaceMap * ) { }

    void		enable( long );
    void		disable( long );
    void		bgnmap2f( long );
    void		map2f( long, REAL, REAL, long, long, 
				     REAL, REAL, long, long, REAL * );
    void		mapgrid2f( long, REAL, REAL, long, REAL, REAL );
    void		mapmesh2f( long, long, long, long, long );
    void		evalcoord2f( long, REAL, REAL );
    void		evalpoint2i( long, long );
    void		endmap2f( void );

    void	 	bgnline( void );
    void	 	endline( void );
    void	 	bgnclosedline( void );
    void	 	endclosedline( void );
    void	 	bgntmesh( void );
    void	 	swaptmesh( void );
    void	 	endtmesh( void );
    void	 	bgnqstrip( void );
    void	 	endqstrip( void );

    void                bgntfan( void );
    void                endtfan( void );
    void                evalUStrip(int n_upper, REAL v_upper, REAL* upper_val,
                                   int n_lower, REAL v_lower, REAL* lower_val);
    void                evalVStrip(int n_left, REAL u_left, REAL* left_val,
                                   int n_right, REAL u_right, REAL* right_val);

    void		coord2f( REAL, REAL );
    void		point2i( long, long );

    void		newtmeshvert( REAL, REAL );
    void		newtmeshvert( long, long );

private:
    StoredVertex	*vertexCache[VERTEX_CACHE_SIZE];
    int			tmeshing;
    int			which;
    int			vcount;
};

inline void StoredVertex::invoke(OpenGLSurfaceEvaluator *eval)
{
    switch(type) {
      case TYPECOORD:
	eval->coord2f(coord[0], coord[1]);
	break;
      case TYPEPOINT:
	eval->point2i(point[0], point[1]);
	break;
      default:
	break;
    }
}

#endif /* __gluglsurfeval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\clients\glcurvev.h ===
#ifndef __gluglcurveval_h_
#define __gluglcurveval_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glcurveval.h
 *
 * $Revision: 1.3 $
 */

#ifndef NT
#pragma once
#endif

#include "basiccrv.h"

class CurveMap;

class OpenGLCurveEvaluator : public BasicCurveEvaluator  {  
public:
			OpenGLCurveEvaluator(void);
			~OpenGLCurveEvaluator(void);
    void		range1f(long, REAL *, REAL *);
    void		domain1f(REAL, REAL);
    void		addMap(CurveMap *);

    void		enable(long);
    void		disable(long);
    void		bgnmap1f(long);
    void		map1f(long, REAL, REAL, long, long, REAL *);
    void		mapgrid1f(long, REAL, REAL);
    void		mapmesh1f(long, long, long);
    void		evalpoint1i(long);
    void		evalcoord1f(long, REAL);
    void		endmap1f(void);

    void		bgnline(void);
    void		endline(void);
};

#endif /* __gluglcurveval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\clients\glinterf.cxx ===
#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glimport.h"
#include "glrender.h"
#include "nurbscon.h"

GLUnurbs *gluNewNurbsRenderer(void)
{
    GLUnurbs *t;

    t = new GLUnurbs;
    return t;
}

void gluDeleteNurbsRenderer(GLUnurbs *r)
{
    delete r;
}

void gluBeginSurface(GLUnurbs *r)
{
    r->bgnsurface(0); 
}

void gluBeginCurve(GLUnurbs *r)
{
    r->bgncurve(0); 
}

void gluEndCurve(GLUnurbs *r)
{
    r->endcurve(); 
}

void gluEndSurface(GLUnurbs *r)
{
    r->endsurface(); 
}

void gluBeginTrim(GLUnurbs *r)
{
    r->bgntrim(); 
}

void gluEndTrim(GLUnurbs *r)
{
    r->endtrim(); 
}

void gluPwlCurve(GLUnurbs *r, GLint count, INREAL array[], 
		GLint stride, GLenum type)
{
    GLenum realType;

    switch(type) {
      case GLU_MAP1_TRIM_2:
	realType = N_P2D;
	break;
      case GLU_MAP1_TRIM_3:
	realType = N_P2DR;
	break;
      default:
	realType = type;
	break;
    }
    r->pwlcurve(count, array, sizeof(INREAL) * stride, realType);
}

void gluNurbsCurve(GLUnurbs *r, GLint nknots, INREAL knot[], GLint stride, 
		  INREAL ctlarray[], GLint order, GLenum type)
{
    GLenum realType;

    switch(type) {
      case GLU_MAP1_TRIM_2:
	realType = N_P2D;
	break;
      case GLU_MAP1_TRIM_3:
	realType = N_P2DR;
	break;
      default:
	realType = type;
	break;
    }
    r->nurbscurve(nknots, knot, sizeof(INREAL) * stride, ctlarray, order, 
	    realType);
}

void gluNurbsSurface(GLUnurbs *r, GLint sknot_count, GLfloat *sknot, 
			    GLint tknot_count, GLfloat *tknot, 
			    GLint s_stride, GLint t_stride, 
			    GLfloat *ctlarray, GLint sorder, GLint torder, 
			    GLenum type)
{
    r->nurbssurface(sknot_count, sknot, tknot_count, tknot, 
	    sizeof(INREAL) * s_stride, sizeof(INREAL) * t_stride, 
	    ctlarray, sorder, torder, type);
}

void gluLoadSamplingMatrices(GLUnurbs *r, const GLfloat modelMatrix[16],
			    const GLfloat projMatrix[16], 
			    const GLint viewport[4])
{
#ifdef NT
    r->useGLMatrices((float (*)[4])modelMatrix, (float (*)[4])projMatrix, viewport);
#else
    r->useGLMatrices(modelMatrix, projMatrix, viewport);
#endif
}

void gluNurbsProperty(GLUnurbs *r, GLenum property, GLfloat value)
{
    GLfloat nurbsValue;
    
    switch (property) {
      case GLU_AUTO_LOAD_MATRIX:
	r->setautoloadmode(value);
	return;
      case GLU_CULLING:
	if (value != 0.0) {
	    nurbsValue = N_CULLINGON;
	} else {
	    nurbsValue = N_NOCULLING;
	}
	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_CULLING, nurbsValue);
	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_CULLING, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_CULLING, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_CULLING, nurbsValue);
        return;

      case GLU_SAMPLING_METHOD:
	if (value == GLU_PATH_LENGTH) {
	    nurbsValue = N_PATHLENGTH;
	} else if (value == GLU_PARAMETRIC_ERROR) {
	    nurbsValue = N_PARAMETRICDISTANCE;
	} else if (value == GLU_DOMAIN_DISTANCE) {
	    nurbsValue = N_DOMAINDISTANCE;
	} else {
            r->postError(GLU_INVALID_VALUE);
            return;
        }

	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMETHOD, nurbsValue);
	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_SAMPLINGMETHOD, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_SAMPLINGMETHOD, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_SAMPLINGMETHOD, nurbsValue);
	return;

      case GLU_SAMPLING_TOLERANCE:
	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_PIXEL_TOLERANCE, value);
	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_PIXEL_TOLERANCE, value);
	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_PIXEL_TOLERANCE, value);
	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_PIXEL_TOLERANCE, value);
	return;

      case GLU_PARAMETRIC_TOLERANCE:
	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_ERROR_TOLERANCE, value);
        r->setnurbsproperty(GL_MAP2_VERTEX_4, N_ERROR_TOLERANCE, value);
        r->setnurbsproperty(GL_MAP1_VERTEX_3, N_ERROR_TOLERANCE, value);
        r->setnurbsproperty(GL_MAP1_VERTEX_4, N_ERROR_TOLERANCE, value);
        return;

      case GLU_DISPLAY_MODE:
	if (value == GLU_FILL) {
	    nurbsValue = N_FILL;
	} else if (value == GLU_OUTLINE_POLYGON) {
	    nurbsValue = N_OUTLINE_POLY;
	} else if (value == GLU_OUTLINE_PATCH) {
	    nurbsValue = N_OUTLINE_PATCH;
	} else {
	    r->postError(GLU_INVALID_VALUE);
	    return;
	}
	r->setnurbsproperty(N_DISPLAY, nurbsValue);
	break;

      case GLU_U_STEP:
    	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_S_STEPS, value);
    	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_S_STEPS, value);
    	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_S_STEPS, value);
    	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_S_STEPS, value);
	break;

      case GLU_V_STEP:
        r->setnurbsproperty(GL_MAP1_VERTEX_3, N_T_STEPS, value);
        r->setnurbsproperty(GL_MAP1_VERTEX_4, N_T_STEPS, value);
        r->setnurbsproperty(GL_MAP2_VERTEX_3, N_T_STEPS, value);
        r->setnurbsproperty(GL_MAP2_VERTEX_4, N_T_STEPS, value);
	break;


      default:
	r->postError(GLU_INVALID_ENUM);
	return;
    }
}

void gluGetNurbsProperty(GLUnurbs *r, GLenum property, GLfloat *value)
{
    GLfloat nurbsValue;

    switch(property) {
      case GLU_AUTO_LOAD_MATRIX:
	if (r->getautoloadmode()) {
	    *value = GL_TRUE;
	} else {
	    *value = GL_FALSE;
	}
	break;
      case GLU_CULLING:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_CULLING, &nurbsValue);
	if (nurbsValue == N_CULLINGON) {
	    *value = GL_TRUE;
	} else {
	    *value = GL_FALSE;
	}
	break;
      case GLU_SAMPLING_METHOD:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMETHOD, value);
	break;
      case GLU_SAMPLING_TOLERANCE:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_PIXEL_TOLERANCE, value);
	break;
      case GLU_PARAMETRIC_TOLERANCE:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_ERROR_TOLERANCE, value);
        break;
      case GLU_U_STEP:
    	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_S_STEPS, value);
	break;
      case GLU_V_STEP:
    	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_T_STEPS, value);
	break;
      case GLU_DISPLAY_MODE:
	r->getnurbsproperty(N_DISPLAY, &nurbsValue);
	if (nurbsValue == N_FILL) {
	    *value = GLU_FILL;
	} else if (nurbsValue == N_OUTLINE_POLY) {
	    *value = GLU_OUTLINE_POLYGON;
	} else {
	    *value = GLU_OUTLINE_PATCH;
	}
	break;
      default:
	r->postError(GLU_INVALID_ENUM);
	return;
    }
}

void gluNurbsCallback(GLUnurbs *r, GLenum which, void (*fn)())
{
    switch (which) {
      case GLU_ERROR:
#ifdef NT
        r->errorCallback = (GLUnurbsErrorProc) fn;
#else
	r->errorCallback = (void (*)( GLenum )) fn;
#endif
	break;
      default:
	r->postError(GLU_INVALID_ENUM);
	return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\clients\glrender.h ===
#ifndef __gluglrenderer_h_
#define __gluglrenderer_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glrenderer.h - $Revision: 1.4 $
 */

#ifndef NT
#pragma once
#endif

#include <GL/gl.h>
#include <GL/glu.h>
#include "nurbstes.h"
#include "glsurfev.h"
#include "glcurvev.h"

class GLUnurbs : public NurbsTessellator {

public:
		GLUnurbs( void );
    void 	loadGLMatrices( void );
#ifdef NT
    void        useGLMatrices( const GLfloat modelMatrix[4][4],
                               const GLfloat projMatrix[4][4],
                               const GLint viewport[4] );
#else
    void        useGLMatrices( const GLfloat modelMatrix[16],
                               const GLfloat projMatrix[16],
                               const GLint viewport[4] );
#endif
    void 	errorHandler( int );
    void	bgnrender( void );
    void	endrender( void );
    void	setautoloadmode( INREAL value )
		    { if (value) autoloadmode = GL_TRUE; 
		      else autoloadmode = GL_FALSE; }
    GLboolean	getautoloadmode( void ) { return autoloadmode; }

#ifdef NT
    GLUnurbsErrorProc           errorCallback;
#else
    void        (*errorCallback)( GLenum );
#endif
    void	postError( GLenum which ) 
		    { if (errorCallback) (*errorCallback)( which ); }

private:
    GLboolean			autoloadmode;
    OpenGLSurfaceEvaluator	surfaceEvaluator;
    OpenGLCurveEvaluator	curveEvaluator;

    void		loadSamplingMatrix( const GLfloat vmat[4][4], 
			        const GLint viewport[4] );
    void		loadCullingMatrix( GLfloat vmat[4][4] );
    static void		grabGLMatrix( GLfloat vmat[4][4] );
    static void		transform4d( GLfloat A[4], GLfloat B[4], 
				GLfloat mat[4][4] );
    static void		multmatrix4d( GLfloat n[4][4], GLfloat left[4][4], 
				GLfloat right[4][4] );

};

#endif /* __gluglrenderer_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\clients\glsurfev.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glsurfeval.c++ - surface evaluator
 *
 * $Revision: 1.5 $
 */

/* Polynomial Evaluator Interface */

#include <glos.h>
#include <GL/gl.h>
#include "glimport.h"
#include "glrender.h"
#include "glsurfev.h"
#include "nurbscon.h"

/*#define USE_INTERNAL_EVAL*/ //use internal evaluator

/*whether do evaluation or not*/
/*#define NO_EVALUATION*/

 
/*for statistics*/
/*#define STATISTICS*/
#ifdef STATISTICS
static int STAT_num_of_triangles=0;
static int STAT_num_of_eval_vertices=0;
static int STAT_num_of_quad_strips=0;
#endif 


OpenGLSurfaceEvaluator::OpenGLSurfaceEvaluator() 
{ 
    int i;

    for (i=0; i<VERTEX_CACHE_SIZE; i++) {
	vertexCache[i] = new StoredVertex;
    }
    tmeshing = 0;
    which = 0;
    vcount = 0;


}

OpenGLSurfaceEvaluator::~OpenGLSurfaceEvaluator() 
{ 
   for (int ii= 0; ii< VERTEX_CACHE_SIZE; ii++) {
      delete vertexCache[ii];
      vertexCache[ii]= 0;
   }
}

/*---------------------------------------------------------------------------
 * disable - turn off a map
 *---------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::disable(long type)
{
    glDisable((GLenum) type);
}

/*---------------------------------------------------------------------------
 * enable - turn on a map
 *---------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::enable(long type)
{
    glEnable((GLenum) type);
}

/*-------------------------------------------------------------------------
 * mapgrid2f - define a lattice of points with origin and offset
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::mapgrid2f(long nu, REAL u0, REAL u1, long nv, REAL v0, REAL v1)
{
#ifdef USE_INTERNAL_EVAL
  inMapGrid2f((int) nu, (REAL) u0, (REAL) u1, (int) nv, 
	      (REAL) v0, (REAL) v1);
#else

    glMapGrid2d((GLint) nu, (GLdouble) u0, (GLdouble) u1, (GLint) nv, 
	    (GLdouble) v0, (GLdouble) v1);
#endif
}

void
OpenGLSurfaceEvaluator::polymode(long style)
{
    switch(style) {
    default:
    case N_MESHFILL:

	glPolygonMode((GLenum) GL_FRONT_AND_BACK, (GLenum) GL_FILL);
	break;
    case N_MESHLINE:
	glPolygonMode((GLenum) GL_FRONT_AND_BACK, (GLenum) GL_LINE);
	break;
    case N_MESHPOINT:
	glPolygonMode((GLenum) GL_FRONT_AND_BACK, (GLenum) GL_POINT);
	break;
    }
}

void
OpenGLSurfaceEvaluator::bgnline(void)
{
    glBegin((GLenum) GL_LINE_STRIP);
}

void
OpenGLSurfaceEvaluator::endline(void)
{
    glEnd();
}

void
OpenGLSurfaceEvaluator::range2f(long type, REAL *from, REAL *to)
{
}

void
OpenGLSurfaceEvaluator::domain2f(REAL ulo, REAL uhi, REAL vlo, REAL vhi)
{
}

void
OpenGLSurfaceEvaluator::bgnclosedline(void)
{
    glBegin((GLenum) GL_LINE_LOOP);
}

void
OpenGLSurfaceEvaluator::endclosedline(void)
{
    glEnd();
}





void
OpenGLSurfaceEvaluator::bgntmesh(void)
{

    tmeshing = 1;
    which = 0;
    vcount = 0;

    glBegin((GLenum) GL_TRIANGLES);

}

void
OpenGLSurfaceEvaluator::swaptmesh(void)
{
    which = 1 - which;

}

void
OpenGLSurfaceEvaluator::endtmesh(void)
{
    tmeshing = 0;

    glEnd();
}

void
OpenGLSurfaceEvaluator::bgntfan(void)
{
 glBegin((GLenum) GL_TRIANGLE_FAN);
}
void
OpenGLSurfaceEvaluator::endtfan(void)
{
 glEnd();
}

void
OpenGLSurfaceEvaluator::evalUStrip(int n_upper, REAL v_upper, REAL* upper_val, int n_lower, REAL v_lower, REAL* lower_val)
{
#ifdef USE_INTERNAL_EVAL
  inEvalUStrip(n_upper, v_upper, upper_val,
	n_lower, v_lower, lower_val);
#else
  int i,j,k,l;
  REAL leftMostV[2];

  /*
   *the algorithm works by scanning from left to right.
   *leftMostV: the left most of the remaining verteces (on both upper and lower).
   *           it could an element of upperVerts or lowerVerts.
   *i: upperVerts[i] is the first vertex to the right of leftMostV on upper line   
   *j: lowerVerts[j] is the first vertex to the right of leftMostV on lower line   
   */
  
  /*initialize i,j,and leftMostV
   */
  if(upper_val[0] <= lower_val[0])
    {
      i=1;
      j=0;

      leftMostV[0] = upper_val[0];
      leftMostV[1] = v_upper;
    }
  else
    {
      i=0;
      j=1;

      leftMostV[0] = lower_val[0];
      leftMostV[1] = v_lower;

    }
  
  /*the main loop.
   *the invariance is that: 
   *at the beginning of each loop, the meaning of i,j,and leftMostV are 
   *maintained
   */
  while(1)
    {
      if(i >= n_upper) /*case1: no more in upper*/
        {
          if(j<n_lower-1) /*at least two vertices in lower*/
            {
              bgntfan();
	      coord2f(leftMostV[0], leftMostV[1]);
//	      glNormal3fv(leftMostNormal);
//              glVertex3fv(leftMostXYZ);

              while(j<n_lower){
		coord2f(lower_val[j], v_lower);
//		glNormal3fv(lowerNormal[j]);
//		glVertex3fv(lowerXYZ[j]);
		j++;

              }
              endtfan();
            }
          break; /*exit the main loop*/
        }
      else if(j>= n_lower) /*case2: no more in lower*/
        {
          if(i<n_upper-1) /*at least two vertices in upper*/
            {
              bgntfan();
	      coord2f(leftMostV[0], leftMostV[1]);
//	      glNormal3fv(leftMostNormal);
//	      glVertex3fv(leftMostXYZ);
	      
              for(k=n_upper-1; k>=i; k--) /*reverse order for two-side lighting*/
		{
		  coord2f(upper_val[k], v_upper);
//		  glNormal3fv(upperNormal[k]);
//		  glVertex3fv(upperXYZ[k]);
		}

              endtfan();
            }
          break; /*exit the main loop*/
        }
      else /* case3: neither is empty, plus the leftMostV, there is at least one triangle to output*/
        {
          if(upper_val[i] <= lower_val[j])
            {
	      bgntfan();
	      coord2f(lower_val[j], v_lower);
//	      glNormal3fv(lowerNormal[j]);
//	      glVertex3fv(lowerXYZ[j]);

              /*find the last k>=i such that 
               *upperverts[k][0] <= lowerverts[j][0]
               */
              k=i;

              while(k<n_upper)
                {
                  if(upper_val[k] > lower_val[j])
                    break;
                  k++;

                }
              k--;


              for(l=k; l>=i; l--)/*the reverse is for two-side lighting*/
                {
		  coord2f(upper_val[l], v_upper);
//		  glNormal3fv(upperNormal[l]);
//		  glVertex3fv(upperXYZ[l]);

                }
	      coord2f(leftMostV[0], leftMostV[1]);
//	      glNormal3fv(leftMostNormal);
//	      glVertex3fv(leftMostXYZ);

              endtfan();

              /*update i and leftMostV for next loop
               */
              i = k+1;

	      leftMostV[0] = upper_val[k];
	      leftMostV[1] = v_upper;
//	      leftMostNormal = upperNormal[k];
//	      leftMostXYZ = upperXYZ[k];
            }
          else /*upperVerts[i][0] > lowerVerts[j][0]*/
            {
	      bgntfan();
	      coord2f(upper_val[i], v_upper);
//	      glNormal3fv(upperNormal[i]);
//	      glVertex3fv(upperXYZ[i]);
	
	      coord2f(leftMostV[0], leftMostV[1]);
//              glNormal3fv(leftMostNormal);
//	      glVertex3fv(leftMostXYZ);
	      

              /*find the last k>=j such that
               *lowerverts[k][0] < upperverts[i][0]
               */
              k=j;
              while(k< n_lower)
                {
                  if(lower_val[k] >= upper_val[i])
                    break;
		  coord2f(lower_val[k], v_lower);
//		  glNormal3fv(lowerNormal[k]);
//		  glVertex3fv(lowerXYZ[k]);

                  k++;
                }
              endtfan();

              /*update j and leftMostV for next loop
               */
              j=k;
	      leftMostV[0] = lower_val[j-1];
	      leftMostV[1] = v_lower;

//	      leftMostNormal = lowerNormal[j-1];
//	      leftMostXYZ = lowerXYZ[j-1];
            }     
        }
    }
  //clean up 
//  free(upperXYZ);
//  free(lowerXYZ);
//  free(upperNormal);
//  free(lowerNormal);
#endif

}
  

void
OpenGLSurfaceEvaluator::evalVStrip(int n_left, REAL u_left, REAL* left_val, int n_right, REAL u_right, REAL* right_val)
{
#ifdef USE_INTERNAL_EVAL
	inEvalVStrip(n_left, u_left, left_val,
	n_right, u_right, right_val);
#else
  int i,j,k,l;
  REAL botMostV[2];
  /*
   *the algorithm works by scanning from bot to top.
   *botMostV: the bot most of the remaining verteces (on both left and right).
   *           it could an element of leftVerts or rightVerts.
   *i: leftVerts[i] is the first vertex to the top of botMostV on left line   
   *j: rightVerts[j] is the first vertex to the top of botMostV on rightline
   */
  
  /*initialize i,j,and botMostV
   */
  if(left_val[0] <= right_val[0])
    {
      i=1;
      j=0;

      botMostV[0] = u_left;
      botMostV[1] = left_val[0];
    }
  else
    {
      i=0;
      j=1;

      botMostV[0] = u_right;
      botMostV[1] = right_val[0];
    }

  /*the main loop.
   *the invariance is that: 
   *at the beginning of each loop, the meaning of i,j,and botMostV are 
   *maintained
   */
  while(1)
    {
      if(i >= n_left) /*case1: no more in left*/
        {
          if(j<n_right-1) /*at least two vertices in right*/
            {
              bgntfan();
	      coord2f(botMostV[0], botMostV[1]);
              while(j<n_right){
		coord2f(u_right, right_val[j]);
//		glNormal3fv(rightNormal[j]);
//		glVertex3fv(rightXYZ[j]);
		j++;

              }
              endtfan();
            }
          break; /*exit the main loop*/
        }
      else if(j>= n_right) /*case2: no more in right*/
        {
          if(i<n_left-1) /*at least two vertices in left*/
            {
              bgntfan();
              coord2f(botMostV[0], botMostV[1]);
//	      glNormal3fv(botMostNormal);
//	      glVertex3fv(botMostXYZ);
	      
              for(k=n_left-1; k>=i; k--) /*reverse order for two-side lighting*/
		{
		  coord2f(u_left, left_val[k]);
//		  glNormal3fv(leftNormal[k]);
//		  glVertex3fv(leftXYZ[k]);
		}

              endtfan();
            }
          break; /*exit the main loop*/
        }
      else /* case3: neither is empty, plus the botMostV, there is at least one triangle to output*/
        {
          if(left_val[i] <= right_val[j])
            {
	      bgntfan();
	      coord2f(u_right, right_val[j]);
//	      glNormal3fv(rightNormal[j]);
//	      glVertex3fv(rightXYZ[j]);

              /*find the last k>=i such that 
               *leftverts[k][0] <= rightverts[j][0]
               */
              k=i;

              while(k<n_left)
                {
                  if(left_val[k] > right_val[j])
                    break;
                  k++;

                }
              k--;


              for(l=k; l>=i; l--)/*the reverse is for two-side lighting*/
                {
		  coord2f(u_left, left_val[l]);
//		  glNormal3fv(leftNormal[l]);
//		  glVertex3fv(leftXYZ[l]);

                }
	      coord2f(botMostV[0], botMostV[1]);
//	      glNormal3fv(botMostNormal);
//	      glVertex3fv(botMostXYZ);

              endtfan();

              /*update i and botMostV for next loop
               */
              i = k+1;

	      botMostV[0] = u_left;
	      botMostV[1] = left_val[k];
//	      botMostNormal = leftNormal[k];
//	      botMostXYZ = leftXYZ[k];
            }
          else /*left_val[i] > right_val[j])*/
            {
	      bgntfan();
	      coord2f(u_left, left_val[i]);
//	      glNormal3fv(leftNormal[i]);
//	      glVertex3fv(leftXYZ[i]);
	      
	      coord2f(botMostV[0], botMostV[1]);
//            glNormal3fv(botMostNormal);
//	      glVertex3fv(botMostXYZ);
	      

              /*find the last k>=j such that
               *rightverts[k][0] < leftverts[i][0]
               */
              k=j;
              while(k< n_right)
                {
                  if(right_val[k] >= left_val[i])
                    break;
		  coord2f(u_right, right_val[k]);
//		  glNormal3fv(rightNormal[k]);
//		  glVertex3fv(rightXYZ[k]);

                  k++;
                }
              endtfan();

              /*update j and botMostV for next loop
               */
              j=k;
	      botMostV[0] = u_right;
	      botMostV[1] = right_val[j-1];

//	      botMostNormal = rightNormal[j-1];
//	      botMostXYZ = rightXYZ[j-1];
            }     
        }
    }
  //clean up 
//  free(leftXYZ);
//  free(leftNormal);
//  free(rightXYZ);
//  free(rightNormal);
#endif
}
  

void
OpenGLSurfaceEvaluator::bgnqstrip(void)
{
    glBegin((GLenum) GL_QUAD_STRIP);
#ifdef STATISTICS
	STAT_num_of_quad_strips++;
#endif
}

void
OpenGLSurfaceEvaluator::endqstrip(void)
{
    glEnd();
}

/*-------------------------------------------------------------------------
 * bgnmap2f - preamble to surface definition and evaluations
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::bgnmap2f(long)
{

    glPushAttrib((GLbitfield) GL_EVAL_BIT);

}

/*-------------------------------------------------------------------------
 * endmap2f - postamble to a map
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::endmap2f(void)
{

    glPopAttrib();

#ifdef STATISTICS
    fprintf(stderr, "num_vertices=%i,num_triangles=%i,num_quads_strips=%i\n", STAT_num_of_eval_vertices,STAT_num_of_triangles,STAT_num_of_quad_strips);
#endif

}

/*-------------------------------------------------------------------------
 * map2f - pass a desription of a surface map
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::map2f(
    long _type,
    REAL _ulower,	/* u lower domain coord		*/
    REAL _uupper,	/* u upper domain coord 	*/
    long _ustride,	/* interpoint distance		*/
    long _uorder,	/* parametric order		*/
    REAL _vlower,	/* v lower domain coord		*/
    REAL _vupper, 	/* v upper domain coord		*/
    long _vstride,	/* interpoint distance		*/
    long _vorder,	/* parametric order		*/
    REAL *pts) 	/* control points		*/
{
#ifdef USE_INTERNAL_EVAL
   inMap2f((int) _type, (REAL) _ulower, (REAL) _uupper, 
	    (int) _ustride, (int) _uorder, (REAL) _vlower, 
	    (REAL) _vupper, (int) _vstride, (int) _vorder, 
	    (REAL *) pts);
#else
    glMap2f((GLenum) _type, (GLfloat) _ulower, (GLfloat) _uupper, 
	    (GLint) _ustride, (GLint) _uorder, (GLfloat) _vlower, 
	    (GLfloat) _vupper, (GLint) _vstride, (GLint) _vorder, 
	    (const GLfloat *) pts);
#endif
}


/*-------------------------------------------------------------------------
 * mapmesh2f - evaluate a mesh of points on lattice
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::mapmesh2f(long style, long umin, long umax, long vmin, long vmax)
{
#ifdef NO_EVALUATION
	return;
#endif

#ifdef USE_INTERNAL_EVAL
    inEvalMesh2((int)umin, (int)vmin, (int)umax, (int)vmax);
#else
    switch(style) {
    default:
    case N_MESHFILL:

	glEvalMesh2((GLenum) GL_FILL, (GLint) umin, (GLint) umax, 
		(GLint) vmin, (GLint) vmax);
	break;
    case N_MESHLINE:
	glEvalMesh2((GLenum) GL_LINE, (GLint) umin, (GLint) umax, 
		(GLint) vmin, (GLint) vmax);
	break;
    case N_MESHPOINT:
	glEvalMesh2((GLenum) GL_POINT, (GLint) umin, (GLint) umax, 
		(GLint) vmin, (GLint) vmax);
	break;
    }
#endif

#ifdef STATISTICS
	STAT_num_of_quad_strips += (umax-umin)*(vmax-vmin);
#endif
}

/*-------------------------------------------------------------------------
 * evalcoord2f - evaluate a point on a surface
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::evalcoord2f(long, REAL u, REAL v)
{


#ifdef NO_EVALUATION
return;
#endif


    newtmeshvert(u, v);
}

/*-------------------------------------------------------------------------
 * evalpoint2i - evaluate a grid point
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::evalpoint2i(long u, long v)
{
#ifdef NO_EVALUATION
return;
#endif

    newtmeshvert(u, v);
}

void
OpenGLSurfaceEvaluator::point2i( long u, long v )
{
#ifdef USE_INTERNAL_EVAL
    inEvalPoint2( (int)u,  (int)v);
#else
    glEvalPoint2((GLint) u, (GLint) v);
#endif

#ifdef STATISTICS
  STAT_num_of_eval_vertices++;
#endif

}

void
OpenGLSurfaceEvaluator::coord2f( REAL u, REAL v )
{
#ifdef USE_INTERNAL_EVAL
    inEvalCoord2f( u, v);
#else
    glEvalCoord2f((GLfloat) u, (GLfloat) v);
#endif


#ifdef STATISTICS
  STAT_num_of_eval_vertices++;
#endif

}

void
OpenGLSurfaceEvaluator::newtmeshvert( long u, long v )
{
    if (tmeshing) {

	if (vcount == 2) {
	    vertexCache[0]->invoke(this);
	    vertexCache[1]->invoke(this);
	    point2i( u,  v);

	} else {
	    vcount++;
	}

	vertexCache[which]->saveEvalPoint(u, v);
	which = 1 - which;
    } else {
	point2i( u,  v);
    }
}

void
OpenGLSurfaceEvaluator::newtmeshvert( REAL u, REAL v )
{

    if (tmeshing) {


	if (vcount == 2) {
	    vertexCache[0]->invoke(this);
	    vertexCache[1]->invoke(this);
            coord2f(u,v);

	} else {
	    vcount++;
	}

	vertexCache[which]->saveEvalCoord(u, v);
	which = 1 - which;
    } else {

	coord2f( u,  v);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\arcsorte.cxx ===
#ifndef __gluarcsorter_c_
#define __gluarcsorter_c_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arcsorter.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "arc.h"
#include "arcsorte.h"
#include "subdivid.h"

ArcSorter::ArcSorter(Subdivider &s) : Sorter( sizeof( Arc ** ) ), subdivider(s)
{
}

int
ArcSorter::qscmp( char *, char * )
{
    dprintf( "ArcSorter::qscmp: pure virtual called\n" );
    return 0;
}

void
ArcSorter::qsort( Arc **a, int n )
{
    Sorter::qsort( (void *) a, n );
}

void		
ArcSorter::qsexc( char *i, char *j )// i<-j, j<-i 
{
    Arc **jarc1 = (Arc **) i;
    Arc **jarc2 = (Arc **) j;
    Arc *tmp = *jarc1;
    *jarc1 = *jarc2;
    *jarc2 = tmp;
}	

void		
ArcSorter::qstexc( char *i, char *j, char *k )// i<-k, k<-j, j<-i
{
    Arc **jarc1 = (Arc **) i;
    Arc **jarc2 = (Arc **) j;
    Arc **jarc3 = (Arc **) k;
    Arc *tmp = *jarc1;
    *jarc1 = *jarc3;
    *jarc3 = *jarc2;
    *jarc2 = tmp;
}
  

ArcSdirSorter::ArcSdirSorter( Subdivider &s ) : ArcSorter(s)
{
}

int
ArcSdirSorter::qscmp( char *i, char *j )
{
    Arc *jarc1 = *(Arc **) i;
    Arc *jarc2 = *(Arc **) j;

    int v1 = (jarc1->getitail() ? 0 : (jarc1->pwlArc->npts - 1));
    int	v2 = (jarc2->getitail() ? 0 : (jarc2->pwlArc->npts - 1));

    REAL diff =  jarc1->pwlArc->pts[v1].param[1] -
	    	 jarc2->pwlArc->pts[v2].param[1];

    if( diff < 0.0)
	return -1;
    else if( diff > 0.0)
	return 1;
    else {
	if( v1 == 0 ) {
	    if( jarc2->tail()[0] < jarc1->tail()[0] ) {
	        return subdivider.ccwTurn_sl( jarc2, jarc1 ) ? 1 : -1;
	    } else {
	        return subdivider.ccwTurn_sr( jarc2, jarc1 ) ? -1 : 1;
	    }
	} else {
	    if( jarc2->head()[0] < jarc1->head()[0] ) {
	        return subdivider.ccwTurn_sl( jarc1, jarc2 ) ? -1 : 1;
	    } else {
	        return subdivider.ccwTurn_sr( jarc1, jarc2 ) ? 1 : -1;
	    }
	}
    }    
}

ArcTdirSorter::ArcTdirSorter( Subdivider &s ) : ArcSorter(s)
{
}

/*----------------------------------------------------------------------------
 * ArcTdirSorter::qscmp - 
  *		   compare two axis monotone arcs that are incident 
 *		   to the line T == compare_value. Determine which of the
 *		   two intersects that line with a LESSER S value.  If
 *		   jarc1 does, return 1.  If jarc2 does, return -1. 
 *----------------------------------------------------------------------------
 */
int
ArcTdirSorter::qscmp( char *i, char *j )
{
    Arc *jarc1 = *(Arc **) i;
    Arc *jarc2 = *(Arc **) j;

    int v1 = (jarc1->getitail() ? 0 : (jarc1->pwlArc->npts - 1));
    int	v2 = (jarc2->getitail() ? 0 : (jarc2->pwlArc->npts - 1));

    REAL diff =  jarc1->pwlArc->pts[v1].param[0] -
	         jarc2->pwlArc->pts[v2].param[0];
 
    if( diff < 0.0)
	return 1;
    else if( diff > 0.0)
	return -1;
    else {
	if( v1 == 0 ) {
	    if (jarc2->tail()[1] < jarc1->tail()[1]) {
	        return subdivider.ccwTurn_tl( jarc2, jarc1 ) ? 1 : -1;
	    } else {
	        return subdivider.ccwTurn_tr( jarc2, jarc1 ) ? -1 : 1;
	    }
	} else {
	    if( jarc2->head()[1] < jarc1->head()[1] )  {
	        return subdivider.ccwTurn_tl( jarc1, jarc2 ) ? -1 : 1;
	    } else {
	        return subdivider.ccwTurn_tr( jarc1, jarc2 ) ? 1 : -1;
	    }
	}
    }
}



#endif /* __gluarcsorter_c_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\arcsorte.h ===
#ifndef __gluarcsorter_h_
#define __gluarcsorter_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arcsorter.h - $Revision: 1.1 $
 */

#include "sorter.h"
#include "arcsorte.h"

class Arc;
class Subdivider;

class ArcSorter : private Sorter {
public:
			ArcSorter(Subdivider &);
    void		qsort( Arc **a, int n );
protected:
    virtual int		qscmp( char *, char * );
    Subdivider&		subdivider;
private:
    void		qsexc( char *i, char *j );	// i<-j, j<-i 
    void		qstexc( char *i, char *j, char *k ); // i<-k, k<-j, j<-i 
};


class ArcSdirSorter : public ArcSorter {
public:
			ArcSdirSorter( Subdivider & );
private:
    int			qscmp( char *, char * );
};


class ArcTdirSorter : public ArcSorter {
public:
			ArcTdirSorter( Subdivider & );
private:
    int			qscmp( char *, char * );
};

#endif /* __gluarcsorter_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\arctess.h ===
#ifndef __gluarctess_h_
#define __gluarctess_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arctess.h - $Revision: 1.1 $
 */

#include "defines.h"
#include "types.h"
#include "arc.h"

class BezierArc;
class Pool;
class TrimVertexPool;

class ArcTessellator {
public:
			ArcTessellator( TrimVertexPool&, Pool& );
			~ArcTessellator( void );
    void		bezier( Arc *, REAL, REAL, REAL, REAL );
    void		pwl( Arc *, REAL, REAL, REAL, REAL, REAL );
    void		pwl_left( Arc *, REAL, REAL, REAL, REAL );
    void		pwl_right( Arc *, REAL, REAL, REAL, REAL );
    void		pwl_top( Arc *, REAL, REAL, REAL, REAL );
    void		pwl_bottom( Arc *, REAL, REAL, REAL, REAL );
    void		tessellateLinear( Arc *, REAL, REAL, int );
    void		tessellateNonlinear( Arc *, REAL, REAL, int );

private:
//mf
#ifdef NT
    static REAL 	gl_Bernstein[][MAXORDER][MAXORDER];
#else
    static const REAL 	gl_Bernstein[][MAXORDER][MAXORDER];
#endif
    Pool&		pwlarcpool;
    TrimVertexPool&	trimvertexpool;
#ifdef NT
    static void		trim_power_coeffs( BezierArc *, REAL *, int );
#else
    static void		trim_power_coeffs( BezierArc *, REAL[MAXORDER], int );
#endif
};

#endif /* __gluarctess_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\arc.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arc.c++ - $Revision: 1.7 $
 * 	Derrick Burns - 1991
 */


#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "arc.h"
#include "bin.h"
#include "bezierar.h"
#include "pwlarc.h"
#include "simplema.h"

/* local preprocessor definitions */
#define	ZERO		0.00001/*0.000001*/

const int 	Arc::bezier_tag = (1<<13);
const int 	Arc::arc_tag = (1<<3);
const int 	Arc::tail_tag = (1<<6);

/*--------------------------------------------------------------------------
 * makeSide - attach a pwl arc to an arc and mark it as a border arc
 *--------------------------------------------------------------------------
 */

void
Arc::makeSide( PwlArc *pwl, arc_side side )
{
    assert( pwl != 0);
    assert( pwlArc == 0 );
    assert( pwl->npts > 0 );
    assert( pwl->pts != 0);
    pwlArc = pwl;
    clearbezier();
    setside( side );
}
 

/*--------------------------------------------------------------------------
 * numpts - count number of points on arc loop
 *--------------------------------------------------------------------------
 */

int
Arc::numpts( void )
{
    Arc_ptr jarc = this;
    int npts = 0;
    do {
	npts += jarc->pwlArc->npts;
	jarc = jarc->next;
    } while( jarc != this );
    return npts;
}

/*--------------------------------------------------------------------------
 * markverts - mark each point with id of arc
 *--------------------------------------------------------------------------
 */

void
Arc::markverts( void )
{
    Arc_ptr jarc = this;
	
    do {
	TrimVertex *p = jarc->pwlArc->pts;
	for( int i=0; i<jarc->pwlArc->npts; i++ )
	    p[i].nuid = jarc->nuid;
	jarc = jarc->next;
    } while( jarc != this );
}

/*--------------------------------------------------------------------------
 * getextrema - find axis extrema on arc loop
 *--------------------------------------------------------------------------
 */

void
Arc::getextrema( Arc_ptr extrema[4] )
{
    REAL leftpt, botpt, rightpt, toppt;

    extrema[0] = extrema[1] = extrema[2] = extrema[3] = this;

    leftpt = rightpt = this->tail()[0];
    botpt  = toppt   = this->tail()[1];

    for( Arc_ptr jarc = this->next; jarc != this; jarc = jarc->next ) {
	if ( jarc->tail()[0] <  leftpt || 
	    (jarc->tail()[0] <= leftpt && jarc->rhead()[0]<=leftpt))  {
	    leftpt = jarc->pwlArc->pts->param[0];
	    extrema[1] = jarc;
	}
	if ( jarc->tail()[0] >  rightpt || 
	    (jarc->tail()[0] >= rightpt && jarc->rhead()[0] >= rightpt)) {
	    rightpt = jarc->pwlArc->pts->param[0];
	    extrema[3] = jarc;
	}
	if ( jarc->tail()[1] <  botpt || 
            (jarc->tail()[1] <= botpt && jarc->rhead()[1] <= botpt ))  {
	    botpt = jarc->pwlArc->pts->param[1];
	    extrema[2] = jarc;
	}
	if ( jarc->tail()[1] >  toppt || 
	    (jarc->tail()[1] >= toppt && jarc->rhead()[1] >= toppt))  {
	    toppt = jarc->pwlArc->pts->param[1];
	    extrema[0] = jarc;
	}
    }
}


/*-------------------------------------------------------------------------
 * show - print to the stdout the vertices of a pwl arc
 *-------------------------------------------------------------------------
 */

void
Arc::show()
{
#ifndef NDEBUG
    dprintf( "\tPWLARC NP: %d FL: 1\n", pwlArc->npts );
    for( int i = 0; i < pwlArc->npts; i++ ) {
         dprintf( "\t\tVERTEX %f %f\n", pwlArc->pts[i].param[0],
			pwlArc->pts[i].param[1] );
    }
#endif
}

/*-------------------------------------------------------------------------
 * print - print out the vertices of all pwl arcs on a loop
 *-------------------------------------------------------------------------
 */

void
Arc::print( void )
{
    Arc_ptr jarc = this;

    if( ! this ) {
#ifndef NDEBUG
	dprintf( "\n\nEMPTY TRIM\n\n" );
#endif
	return;
    }

#ifndef NDEBUG
    dprintf( "BGNTRIM\n" );
#endif
    do {
	jarc->show( );
	jarc = jarc->next;
    } while (jarc != this);
#ifndef NDEBUG
    dprintf("ENDTRIM\n" );
#endif
}

/*-------------------------------------------------------------------------
 * isDisconnected - check if tail of arc and head of prev meet
 *-------------------------------------------------------------------------
 */

int
Arc::isDisconnected( void )
{
    if( pwlArc == 0 ) return 0;
    if( prev->pwlArc == 0 ) return 0;

    REAL *p0 = tail();
    REAL *p1 = prev->rhead();

    if( ((p0[0] - p1[0]) > ZERO) || ((p1[0] - p0[0]) > ZERO) ||
	((p0[1] - p1[1]) > ZERO) || ((p1[1] - p0[1]) > ZERO)  ) {
#ifndef NDEBUG
	dprintf( "x coord = %f %f %f\n", p0[0], p1[0], p0[0] - p1[0] );
	dprintf( "y coord = %f %f %f\n", p0[1], p1[1], p0[1] - p1[1] );
#endif
	return 1;
    } else {
        /* average two points together */
        p0[0] = p1[0] = (p1[0] + p0[0]) * 0.5;
        p0[1] = p1[1] = (p1[1] + p0[1]) * 0.5;
        return 0;
    }
}

/*-------------------------------------------------------------------------
 * neq_vert - assert that two 2D vertices are not equal
 *-------------------------------------------------------------------------
 */

inline static int
neq_vert( REAL	*v1, REAL *v2 )
{
     return ((v1[0] != v2[0]) || (v1[1] != v2[1] )) ? 1 : 0;
}

/*-------------------------------------------------------------------------
 * check - verify consistency of a loop, including
 *		1) if pwl, no two consecutive vertices are identical
 *		2) the circular link pointers are valid
 *		3) the geometric info at the head and tail are consistent
 *-------------------------------------------------------------------------
 */

int
Arc::check( void )
{
    if( this == 0 ) return 1;
    Arc_ptr jarc = this;
    do {
	assert( (jarc->pwlArc != 0) || (jarc->bezierArc != 0) );

        if (jarc->prev == 0 || jarc->next == 0) {
#ifndef NDEBUG
	    dprintf( "checkjarc:null next/prev pointer\n");
	    jarc->print( );
#endif
	    return 0;
        }

        if (jarc->next->prev != jarc) {
#ifndef NDEBUG
	    dprintf( "checkjarc: pointer linkage screwed up\n");
	    jarc->print( );
#endif
	    return 0;
        }

        if( jarc->pwlArc ) {
#ifndef NDEBUG
	    assert( jarc->pwlArc->npts > 1 );
	    assert( jarc->pwlArc->npts < 100000 );
/*
	    for( int i=0; i < jarc->pwlArc->npts-1; i++ )
		assert( neq_vert( jarc->pwlArc->pts[i].param, 
			     jarc->pwlArc->pts[i+1].param) );
*/
#endif
	    if( jarc->prev->pwlArc ) {
		if( jarc->tail()[1] != jarc->prev->rhead()[1] ) {
#ifndef NDEBUG
		    dprintf( "checkjarc: geometric linkage screwed up 1\n");
		    jarc->prev->show();
		    jarc->show();
#endif
		    return 0;
		}
		if( jarc->tail()[0] != jarc->prev->rhead()[0] ) {
		    
#ifndef NDEBUG
		    dprintf( "checkjarc: geometric linkage screwed up 2\n");
		    jarc->prev->show();
		    jarc->show();
#endif
		    return 0;
		}
	    }
	    if( jarc->next->pwlArc ) {
		if( jarc->next->tail()[0] != jarc->rhead()[0] ) {
#ifndef NDEBUG
			dprintf( "checkjarc: geometric linkage screwed up 3\n");
			jarc->show();
			jarc->next->show();
#endif
			return 0;
		}
		if( jarc->next->tail()[1] != jarc->rhead()[1] ) {
#ifndef NDEBUG
			dprintf( "checkjarc: geometric linkage screwed up 4\n");
			jarc->show();
			jarc->next->show();
#endif
			return 0;
		}
	    }
	    if( jarc->isbezier() ) {
		assert( jarc->pwlArc->npts == 2 );
    		assert( (jarc->pwlArc->pts[0].param[0] == \
	    		jarc->pwlArc->pts[1].param[0]) ||\
    	    		(jarc->pwlArc->pts[0].param[1] == \
	    		jarc->pwlArc->pts[1].param[1]) );
	    }
	}
        jarc = jarc->next;
    } while (jarc != this);
    return 1;
}


#define TOL 0.00001

inline long tooclose( REAL x, REAL y )
{
    return (abs(x-y) < TOL) ?  1 : 0;
}


/*--------------------------------------------------------------------------
 * append - append a jordan arc to a circularly linked list
 *--------------------------------------------------------------------------
 */

Arc_ptr
Arc::append( Arc_ptr jarc )
{
    if( jarc != 0 ) {
	next = jarc->next;
	prev = jarc;
   	next->prev = prev->next = this;
    } else {
        next = prev = this;
    }
    return this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\arctess.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arctessellator.c++ - $Revision: 1.6 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "arctess.h"
#include "bufpool.h"
#include "simplema.h"
#include "bezierar.h"
#include "trimvert.h"
#include "trimpool.h"

#define NOELIMINATION

#define steps_function(large, small, rate) (max(1, 1+ (int) ((large-small)/rate)));

/*-----------------------------------------------------------------------------
 * ArcTessellator - construct an ArcTessellator
 *-----------------------------------------------------------------------------
 */

ArcTessellator::ArcTessellator( TrimVertexPool& t, Pool& p ) 
	: trimvertexpool(t), pwlarcpool(p)
{
}

/*-----------------------------------------------------------------------------
 * ~ArcTessellator - destroy an ArcTessellator
 *-----------------------------------------------------------------------------
 */

ArcTessellator::~ArcTessellator( void )
{
}

/*-----------------------------------------------------------------------------
 * bezier - construct a bezier arc and attach it to an Arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::bezier( Arc *arc, REAL s1, REAL s2, REAL t1, REAL t2 )
{
    assert( arc != 0 );
    assert( ! arc->isTessellated() );

#ifndef NDEBUG
    switch( arc->getside() ) {
	case arc_left:
	    assert( s1 == s2 );
	    assert( t2 < t1 );
	    break;
	case arc_right:
	    assert( s1 == s2 );
	    assert( t1 < t2 );
	    break;
	case arc_top:
	    assert( t1 == t2 );
	    assert( s2 < s1 );
	    break;
	case arc_bottom:
	    assert( t1 == t2 );
	    assert( s1 < s2 );
	    break;
	case arc_none:
	    (void) abort();
	    break;
    }
#endif
    
    TrimVertex *p = trimvertexpool.get(2);
    arc->pwlArc = new(pwlarcpool) PwlArc( 2, p );
    p[0].param[0] = s1;
    p[0].param[1] = t1;
    p[1].param[0] = s2;
    p[1].param[1] = t2;
    assert( (s1 == s2) || (t1 == t2) );
    arc->setbezier();
}


/*-----------------------------------------------------------------------------
 * pwl_left - construct a left boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_left( Arc *arc, REAL s, REAL t1, REAL t2, REAL rate )
{
    assert( t2 < t1 );

/*    if(rate <= 0.06) rate = 0.06;*/
/*    int nsteps = 1 + (int) ((t1 - t2) / rate ); */
    int nsteps = steps_function(t1, t2, rate);


    REAL stepsize = (t1 - t2) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = nsteps; i > 0; i-- ) {
	newvert[i].param[0] = s;
	newvert[i].param[1] = t2;
	t2 += stepsize;
    }
    newvert[i].param[0] = s;
    newvert[i].param[1] = t1;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_left );
}

/*-----------------------------------------------------------------------------
 * pwl_right - construct a right boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_right( Arc *arc, REAL s, REAL t1, REAL t2, REAL rate )
{
    assert( t1 < t2 );

/*    if(rate <= 0.06) rate = 0.06;*/

/*    int nsteps = 1 + (int) ((t2 - t1) / rate ); */
    int nsteps = steps_function(t2,t1,rate);
    REAL stepsize = (t2 - t1) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = 0; i < nsteps; i++ ) {
	newvert[i].param[0] = s;
	newvert[i].param[1] = t1;
	t1 += stepsize;
    }
    newvert[i].param[0] = s;
    newvert[i].param[1] = t2;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_right );
}


/*-----------------------------------------------------------------------------
 * pwl_top - construct a top boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_top( Arc *arc, REAL t, REAL s1, REAL s2, REAL rate )
{
    assert( s2 < s1 );

/*    if(rate <= 0.06) rate = 0.06;*/

/*    int nsteps = 1 + (int) ((s1 - s2) / rate ); */
    int nsteps = steps_function(s1,s2,rate);
    REAL stepsize = (s1 - s2) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = nsteps; i > 0; i-- ) {
	newvert[i].param[0] = s2;
	newvert[i].param[1] = t;
	s2 += stepsize;
    }
    newvert[i].param[0] = s1;
    newvert[i].param[1] = t;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_top );
}

/*-----------------------------------------------------------------------------
 * pwl_bottom - construct a bottom boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_bottom( Arc *arc, REAL t, REAL s1, REAL s2, REAL rate )
{
    assert( s1 < s2 );

/*    if(rate <= 0.06) rate = 0.06;*/

/*    int nsteps = 1 + (int) ((s2 - s1) / rate ); */
    int nsteps = steps_function(s2,s1,rate);
    REAL stepsize = (s2 - s1) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = 0; i < nsteps; i++ ) {
	newvert[i].param[0] = s1;
	newvert[i].param[1] = t;
	s1 += stepsize;
    }
    newvert[i].param[0] = s2;
    newvert[i].param[1] = t;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_bottom );
}

/*-----------------------------------------------------------------------------
 * pwl - construct a pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl( Arc *arc, REAL s1, REAL s2, REAL t1, REAL t2, REAL rate )
{

/*    if(rate <= 0.06) rate = 0.06;*/

    int snsteps = 1 + (int) (abs(s2 - s1) / rate );
    int tnsteps = 1 + (int) (abs(t2 - t1) / rate );
    int nsteps = max(1,max( snsteps, tnsteps ));

    REAL sstepsize = (s2 - s1) / (REAL) nsteps;
    REAL tstepsize = (t2 - t1) / (REAL) nsteps;
    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( long i = 0; i < nsteps; i++ ) {
	newvert[i].param[0] = s1;
	newvert[i].param[1] = t1;
	s1 += sstepsize;
	t1 += tstepsize;
    }
    newvert[i].param[0] = s2;
    newvert[i].param[1] = t2;

    /* arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_bottom ); */
    arc->pwlArc = new(pwlarcpool) PwlArc( nsteps+1, newvert );

    arc->clearbezier();
    arc->clearside( );
}


/*-----------------------------------------------------------------------------
 * tessellateLinear - constuct a linear pwl arc and attach it to an Arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::tessellateLinear( Arc *arc, REAL geo_stepsize, REAL arc_stepsize, int isrational )
{
    assert( arc->pwlArc == NULL );
    REAL s1, s2, t1, t2;
    REAL stepsize = geo_stepsize * arc_stepsize;
    BezierArc *b = arc->bezierArc;

    if( isrational ) {
	s1 = b->cpts[0] / b->cpts[2];
	t1 = b->cpts[1] / b->cpts[2];
	s2 = b->cpts[b->stride+0] / b->cpts[b->stride+2];
	t2 = b->cpts[b->stride+1] / b->cpts[b->stride+2];
    } else {
	s1 = b->cpts[0];
	t1 = b->cpts[1];
	s2 = b->cpts[b->stride+0];
	t2 = b->cpts[b->stride+1];
    }
    if( s1 == s2 )
	if( t1 < t2 )
	    pwl_right( arc, s1, t1, t2, stepsize );
	else
	    pwl_left( arc, s1, t1, t2, stepsize );
    else if( t1 == t2 )
	if( s1 < s2 ) 
	    pwl_bottom( arc, t1, s1, s2, stepsize );
	else
	    pwl_top( arc, t1, s1, s2, stepsize );
    else
	pwl( arc, s1, s2, t1, t2, stepsize );
}

/*-----------------------------------------------------------------------------
 * tessellateNonlinear - constuct a nonlinear pwl arc and attach it to an Arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::tessellateNonlinear( Arc *arc, REAL geo_stepsize, REAL arc_stepsize, int isrational )
{
    assert( arc->pwlArc == NULL );

    REAL stepsize	= geo_stepsize * arc_stepsize;

    int	nsteps 		= 1 + (int) (1.0/stepsize);

    TrimVertex *vert	= trimvertexpool.get( nsteps+1 );
    REAL dp 		= 1.0/nsteps;
    BezierArc *bezierArc = arc->bezierArc;

    arc->pwlArc 	= new(pwlarcpool) PwlArc();
    arc->pwlArc->pts 	= vert;

    if( isrational ) {
        REAL pow_u[MAXORDER], pow_v[MAXORDER], pow_w[MAXORDER];
    	trim_power_coeffs( bezierArc, pow_u, 0 );
    	trim_power_coeffs( bezierArc, pow_v, 1 );
        trim_power_coeffs( bezierArc, pow_w, 2 );

	/* compute first point exactly */
        REAL *b = bezierArc->cpts;
	vert->param[0] = b[0]/b[2];
	vert->param[1] = b[1]/b[2];

	/* strength reduction on p = dp * step would introduce error */
	int step;
	int ocanremove = 0;
    	register long order =  bezierArc->order;
	for( step=1, ++vert; step<nsteps; step++, vert++ ) {
	    register REAL p = dp * step;
    	    register REAL u = pow_u[0];
            register REAL v = pow_v[0];
	    register REAL w = pow_w[0];
	    for( register int i = 1; i < order; i++ ) {
	        u = u * p + pow_u[i];
	        v = v * p + pow_v[i];
	        w = w * p + pow_w[i];
            }
            vert->param[0] = u/w;
    	    vert->param[1] = v/w;
#ifndef NOELIMINATION
	    REAL ds = abs(vert[0].param[0] - vert[-1].param[0]);
	    REAL dt = abs(vert[0].param[1] - vert[-1].param[1]);
	    int canremove = (ds<geo_stepsize && dt<geo_stepsize) ? 1 : 0;
	    REAL ods=0.0, odt=0.0;

	    if( ocanremove && canremove ) {
		REAL nds = ds + ods;
		REAL ndt = dt + odt;
		if( nds<geo_stepsize && ndt<geo_stepsize ) {
		    // remove previous point
		    --vert;
		    vert[0].param[0] = vert[1].param[0];
		    vert[0].param[1] = vert[1].param[1];
		    ods = nds;
		    odt = ndt;
		    ocanremove = 1;
		} else {
		    ocanremove = canremove;
		    ods = ds;
		    odt = dt;
		}
	    } else {
		ocanremove = canremove;
		ods = ds;
		odt = dt;
	    }
#endif	
	}

	/* compute last point exactly */
	b += (order - 1) * bezierArc->stride;
	vert->param[0] = b[0]/b[2];
	vert->param[1] = b[1]/b[2];

    } else {
        REAL pow_u[MAXORDER], pow_v[MAXORDER];
	trim_power_coeffs( bezierArc, pow_u, 0 );
	trim_power_coeffs( bezierArc, pow_v, 1 );

	/* compute first point exactly */
        REAL *b = bezierArc->cpts;
	vert->param[0] = b[0];
	vert->param[1] = b[1];

	/* strength reduction on p = dp * step would introduce error */
	int step;
	int ocanremove = 0;
    	register long order =  bezierArc->order;
	for( step=1, ++vert; step<nsteps; step++, vert++ ) {
	    register REAL p = dp * step;
	    register REAL u = pow_u[0];
            register REAL v = pow_v[0];
            for( register int i = 1; i < bezierArc->order; i++ ) {
	        u = u * p + pow_u[i];
	        v = v * p + pow_v[i];
            }
            vert->param[0] = u;
	    vert->param[1] = v;
#ifndef NOELIMINATION
	    REAL ds = abs(vert[0].param[0] - vert[-1].param[0]);
	    REAL dt = abs(vert[0].param[1] - vert[-1].param[1]);
	    int canremove = (ds<geo_stepsize && dt<geo_stepsize) ? 1 : 0;
	    REAL ods=0.0, odt=0.0;

	    if( ocanremove && canremove ) {
		REAL nds = ds + ods;
		REAL ndt = dt + odt;
		if( nds<geo_stepsize && ndt<geo_stepsize ) {
		    // remove previous point
		    --vert;
		    vert[0].param[0] = vert[1].param[0];
		    vert[0].param[1] = vert[1].param[1];
		    ods = nds;
		    odt = ndt;
		    ocanremove = 1;
		} else {
		    ocanremove = canremove;
		    ods = ds;
		    odt = dt;
		}
	    } else {
		ocanremove = canremove;
		ods = ds;
		odt = dt;
	    }
#endif	
	}

	/* compute last point exactly */
	b += (order - 1) * bezierArc->stride;
	vert->param[0] = b[0];
	vert->param[1] = b[1];
    }
    arc->pwlArc->npts = vert - arc->pwlArc->pts + 1;
/*
    for( TrimVertex *vt=pwlArc->pts; vt != vert-1; vt++ ) {
	if( tooclose( vt[0].param[0], vt[1].param[0] ) )
	    vt[1].param[0] = vt[0].param[0];
	if( tooclose( vt[0].param[1], vt[1].param[1] ) )
	    vt[1].param[1] = vt[0].param[1];
    }
*/
}

#ifdef NT
REAL ArcTessellator::gl_Bernstein[][MAXORDER][MAXORDER] = {
#else
const REAL ArcTessellator::gl_Bernstein[][MAXORDER][MAXORDER] = {
#endif
 {
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 1, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {1, -2, 1, 0, 0, 0, 0, 0 },
  {-2, 2, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 3, -3, 1, 0, 0, 0, 0 },
  {3, -6, 3, 0, 0, 0, 0, 0 },
  {-3, 3, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {1, -4, 6, -4, 1, 0, 0, 0 },
  {-4, 12, -12, 4, 0, 0, 0, 0 },
  {6, -12, 6, 0, 0, 0, 0, 0 },
  {-4, 4, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 5, -10, 10, -5, 1, 0, 0 },
  {5, -20, 30, -20, 5, 0, 0, 0 },
  {-10, 30, -30, 10, 0, 0, 0, 0 },
  {10, -20, 10, 0, 0, 0, 0, 0 },
  {-5, 5, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {1, -6, 15, -20, 15, -6, 1, 0 },
  {-6, 30, -60, 60, -30, 6, 0, 0 },
  {15, -60, 90, -60, 15, 0, 0, 0 },
  {-20, 60, -60, 20, 0, 0, 0, 0 },
  {15, -30, 15, 0, 0, 0, 0, 0 },
  {-6, 6, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 7, -21, 35, -35, 21, -7, 1 },
  {7, -42, 105, -140, 105, -42, 7, 0 },
  {-21, 105, -210, 210, -105, 21, 0, 0 },
  {35, -140, 210, -140, 35, 0, 0, 0 },
  {-35, 105, -105, 35, 0, 0, 0, 0 },
  {21, -42, 21, 0, 0, 0, 0, 0 },
  {-7, 7, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 }
 }};


/*-----------------------------------------------------------------------------
 * trim_power_coeffs - compute power basis coefficients from bezier coeffients
 *-----------------------------------------------------------------------------
 */
void
ArcTessellator::trim_power_coeffs( BezierArc *bez_arc, REAL *p, int coord )
{
    register int stride = bez_arc->stride;
    register int order = bez_arc->order;
    register REAL *base = bez_arc->cpts + coord;

#ifdef NT
    REAL (*mat)[MAXORDER][MAXORDER] = &gl_Bernstein[order-1];
    REAL (*lrow)[MAXORDER] = &(*mat)[order];

    REAL (*row)[MAXORDER] = &(*mat)[0];

    for( ; row != lrow; row++ ) {
        register REAL s = (REAL)0.0;
	register REAL *point = base;
        register REAL *mlast = *row + order;
        for( REAL *m = *row; m != mlast; m++, point += stride )
	    s += *(m) * (*point);
	*(p++) = s;
    }
#else
    REAL const (*mat)[MAXORDER][MAXORDER] = &gl_Bernstein[order-1];
    REAL const (*lrow)[MAXORDER] = &(*mat)[order];

    for( REAL const (*row)[MAXORDER] = &(*mat)[0]; row != lrow; row++ ) {
	register REAL s = 0.0;
	register REAL *point = base;
	register REAL const *mlast = *row + order;
	for( REAL const *m = *row; m != mlast; m++, point += stride ) 
	    s += *(m) * (*point);
	*(p++) = s;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\arc.h ===
#ifndef __gluarc_h_
#define __gluarc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arc.h - $Revision: 1.1 $
 */

#include "myassert.h"
#include "bufpool.h"
#include "mystdio.h"
#include "types.h"
#include "pwlarc.h"
#include "trimvert.h"

class Bin;
class Arc;
class BezierArc;	
typedef Arc *Arc_ptr;

enum arc_side { arc_none = 0, arc_right, arc_top, arc_left, arc_bottom };

#ifdef NT
class Arc : public PooledObj { /* an arc, in two list, the trim list and bin */
public:
#else
struct Arc : public PooledObj { /* an arc, in two list, the trim list and bin */
#endif

    static const int bezier_tag;
    static const int arc_tag;
    static const int tail_tag;

    Arc_ptr		prev;		/* trim list pointer */
    Arc_ptr		next;		/* trim list pointer */
    Arc_ptr		link;		/* bin pointers */
    BezierArc *		bezierArc;	/* associated bezier arc */
    PwlArc *		pwlArc;	/* associated pwl arc */
    long		type;		/* curve type */
    long		nuid;

    inline		Arc( Arc *, PwlArc * );
    inline		Arc( arc_side, long );

    Arc_ptr		append( Arc_ptr );
    int			check( void );
    int			isMonotone( void );
    int			isDisconnected( void );
    int			numpts( void );
    void		markverts( void );
    void		getextrema( Arc_ptr[4] );
    void		print( void );
    void		show( void );
    void		makeSide( PwlArc *, arc_side );

    inline int		isTessellated() { return pwlArc ? 1 : 0; }
    inline long 	isbezier() 	{ return type & bezier_tag; }
    inline void 	setbezier() 	{ type |= bezier_tag; }
    inline void 	clearbezier() 	{ type &= ~bezier_tag; }
    inline long		npts() 		{ return pwlArc->npts; }
    inline TrimVertex *	pts() 		{ return pwlArc->pts; }
    inline REAL * 	tail() 		{ return pwlArc->pts[0].param; }
    inline REAL * 	head() 		{ return next->pwlArc->pts[0].param; }
    inline REAL *	rhead() 	{ return pwlArc->pts[pwlArc->npts-1].param; }
    inline long		ismarked()	{ return type & arc_tag; }
    inline void		setmark()	{ type |= arc_tag; }
    inline void		clearmark()	{ type &= (~arc_tag); }
    inline void		clearside() 	{ type &= ~(0x7 << 8); }
    inline void		setside( arc_side s ) { clearside(); type |= (((long)s)<<8); }
    inline arc_side	getside() 	{ return (arc_side) ((type>>8) & 0x7); }
    inline int		getitail()	{ return type & tail_tag; }
    inline void		setitail()	{ type |= tail_tag; }
    inline void		clearitail()	{ type &= (~tail_tag); }
};

/*--------------------------------------------------------------------------
 * Arc - initialize a new Arc with the same type and uid of
 *	    a given Arc and a given pwl arc
 *--------------------------------------------------------------------------
 */

inline
Arc::Arc( Arc *j, PwlArc *p )
{
    bezierArc = NULL;
    pwlArc = p;
    type = j->type;
    nuid = j->nuid;
}

/*--------------------------------------------------------------------------
 * Arc - initialize a new Arc with the same type and uid of
 *	    a given Arc and a given pwl arc
 *--------------------------------------------------------------------------
 */

inline
Arc::Arc( arc_side side, long _nuid )
{
    bezierArc = NULL;
    pwlArc = NULL;
    type = 0;
    setside( side );
    nuid = _nuid;
}

#endif /* __gluarc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\backend.h ===
#ifndef __glubackend_h_
#define __glubackend_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * backend.h - $Revision: 1.2 $
 */

#include "trimvert.h"
#include "gridvert.h"
#include "gridtrim.h"

class BasicCurveEvaluator;
class BasicSurfaceEvaluator;

class Backend {
private:
    BasicCurveEvaluator&	curveEvaluator;
    BasicSurfaceEvaluator&	surfaceEvaluator;
public:
  			Backend( BasicCurveEvaluator &c, BasicSurfaceEvaluator& e )
			: curveEvaluator(c), surfaceEvaluator(e) {}

    /* surface backend routines */
    void		bgnsurf( int, int, long  );
    void		patch( REAL, REAL, REAL, REAL );
    void		surfpts( long, REAL *, long, long, int, int,
          			 REAL, REAL, REAL, REAL );
    void		surfbbox( long, REAL *, REAL * );
    void		surfgrid( REAL, REAL, long, REAL, REAL, long ); 
    void		surfmesh( long, long, long, long ); 
    void		bgntmesh( char * );
    void		endtmesh( void );
    void		swaptmesh( void );
    void		tmeshvert( GridTrimVertex * );
    void		tmeshvert( TrimVertex * );
    void		tmeshvert( GridVertex * );
    void		linevert( TrimVertex * );
    void		linevert( GridVertex * );
    void		bgnoutline( void );
    void		endoutline( void );
    void		endsurf( void );
    void		triangle( TrimVertex*, TrimVertex*, TrimVertex* );

    void                bgntfan();
    void                endtfan();
    void                bgnqstrip();
    void                endqstrip();
    void                evalUStrip(int n_upper, REAL v_upper, REAL* upper_val, 
				   int n_lower, REAL v_lower, REAL* lower_val
				   );
    void                evalVStrip(int n_left, REAL u_left, REAL* left_val, 
				   int n_right, REAL v_right, REAL* right_val
				   );
    void                tmeshvertNOGE(TrimVertex *t);
    void                tmeshvertNOGE_BU(TrimVertex *t);
    void                tmeshvertNOGE_BV(TrimVertex *t);
    void                preEvaluateBU(REAL u);
    void                preEvaluateBV(REAL v);
	

    /* curve backend routines */
    void		bgncurv( void );
    void		segment( REAL, REAL );
    void		curvpts( long, REAL *, long, int, REAL, REAL );
    void		curvgrid( REAL, REAL, long );
    void		curvmesh( long, long );
    void		curvpt( REAL  );  
    void		bgnline( void );
    void		endline( void );
    void		endcurv( void );
private:
#ifndef NOWIREFRAME
    int			wireframetris;
    int			wireframequads;
    int			npts;
    REAL		mesh[3][4];
    int			meshindex;
#endif
};

#endif /* __glubackend_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\backend.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * backend.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

/* Bezier surface backend
	- interprets display mode (wireframe,shaded,...)
*/

#include "glimport.h"
#include "mystdio.h"
#include "backend.h"
#include "basiccrv.h"
#include "basicsur.h"
#include "nurbscon.h"

/*-------------------------------------------------------------------------
 * bgnsurf - preamble to surface definition and evaluations
 *-------------------------------------------------------------------------
 */
void
Backend::bgnsurf( int wiretris, int wirequads, long nuid )
{
#ifndef NOWIREFRAME
    wireframetris = wiretris;
    wireframequads = wirequads;
#endif
    surfaceEvaluator.bgnmap2f( nuid );
}

void
Backend::patch( REAL ulo, REAL uhi, REAL vlo, REAL vhi )
{
    surfaceEvaluator.domain2f( ulo, uhi, vlo, vhi );
}

void
Backend::surfbbox( long type, REAL *from, REAL *to )
{
    surfaceEvaluator.range2f( type, from, to );
}

/*-------------------------------------------------------------------------
 * surfpts - pass a desription of a surface map
 *-------------------------------------------------------------------------
 */
void 
Backend::surfpts(
    long type, 		/* geometry, color, texture, normal	*/
    REAL *pts, 		/* control points			*/
    long ustride,	/* distance to next point in u direction */
    long vstride,	/* distance to next point in v direction */
    int uorder,	/* u parametric order			*/
    int vorder,	/* v parametric order			*/
    REAL ulo,		/* u lower bound			*/
    REAL uhi,		/* u upper bound			*/
    REAL vlo,		/* v lower bound			*/
    REAL vhi )		/* v upper bound			*/
{
    surfaceEvaluator.map2f( type,ulo,uhi,ustride,uorder,vlo,vhi,vstride,vorder,pts );
    surfaceEvaluator.enable( type );
}

/*-------------------------------------------------------------------------
 * surfgrid - define a lattice of points with origin and offset
 *-------------------------------------------------------------------------
 */
void
Backend::surfgrid( REAL u0, REAL u1, long nu, REAL v0, REAL v1, long nv )
{
    surfaceEvaluator.mapgrid2f( nu, u0, u1, nv, v0, v1 );
}

/*-------------------------------------------------------------------------
 * surfmesh - evaluate a mesh of points on lattice
 *-------------------------------------------------------------------------
 */
void
Backend::surfmesh( long u, long v, long n, long m )
{
#ifndef NOWIREFRAME
    if( wireframequads ) {
	long v0,  v1;
	long u0f = u, u1f = u+n;
	long v0f = v, v1f = v+m;
	long parity = (u & 1);

        for( v0 = v0f, v1 = v0f++ ; v0<v1f; v0 = v1, v1++ ) {
	    surfaceEvaluator.bgnline();
	    for( long u = u0f; u<=u1f; u++ ) {
		if( parity ) {
		    surfaceEvaluator.evalpoint2i( u, v0 );
		    surfaceEvaluator.evalpoint2i( u, v1 );
		} else {
		    surfaceEvaluator.evalpoint2i( u, v1 );
		    surfaceEvaluator.evalpoint2i( u, v0 );
		}
		parity = 1 - parity;
	    }
	    surfaceEvaluator.endline();
	}
    } else {
	surfaceEvaluator.mapmesh2f( N_MESHFILL, u, u+n, v, v+m );
    }
#else
    if( wireframequads ) {

	surfaceEvaluator.mapmesh2f( N_MESHLINE, u, u+n, v, v+m );
    } else {

	surfaceEvaluator.mapmesh2f( N_MESHFILL, u, u+n, v, v+m );
    }
#endif
}

/*-------------------------------------------------------------------------
 * endsurf - postamble to surface
 *-------------------------------------------------------------------------
 */
void
Backend::endsurf( void )
{
    surfaceEvaluator.endmap2f();
}

/***************************************/
void
Backend::bgntfan( void )
{
//  surfaceEvaluator.bgntfan();

}

void
Backend::endtfan( void )
{
//   surfaceEvaluator.endtfan();
}

void
Backend::bgnqstrip( void )
{
/*
  if(wireframequads)
    surfaceEvaluator.polymode( N_MESHLINE );
  else
    surfaceEvaluator.polymode( N_MESHFILL );    
*/
   surfaceEvaluator.bgnqstrip();

}

void
Backend::endqstrip( void )
{
   surfaceEvaluator.endqstrip();
}

void
Backend::evalUStrip(int n_upper, REAL v_upper, REAL* upper_val,
                       int n_lower, REAL v_lower, REAL* lower_val
                       )
{
}

void 
Backend::evalVStrip(int n_left, REAL u_left, REAL* left_val, 
		    int n_right, REAL u_right, REAL* right_val
		    )
{
}

/***************************************/
   

/*-------------------------------------------------------------------------
 * bgntmesh - preamble to a triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::bgntmesh( char * )		
{
#ifndef NOWIREFRAME

    meshindex = 0;	/* I think these need to be initialized to zero */
    npts = 0;

    if( !wireframetris ) {
        surfaceEvaluator.bgntmesh();
    }
#else

    if( wireframetris ) {
	surfaceEvaluator.polymode( N_MESHLINE );
        surfaceEvaluator.bgntmesh();
    } else {
	surfaceEvaluator.polymode( N_MESHFILL );
        surfaceEvaluator.bgntmesh();
    }
#endif
}

void
Backend::tmeshvert( GridTrimVertex *v )
{
    if( v->isGridVert() ) {
	tmeshvert( v->g );
    } else {
	tmeshvert( v->t );
    }
}

void
Backend::tmeshvertNOGE(TrimVertex *t)
{
#ifdef USE_OPTTT
//	surfaceEvaluator.inDoEvalCoord2NOGE( t->param[0], t->param[1], t->cache_point, t->cache_normal);    
#endif
}

//opt for a line with the same u.
void
Backend::tmeshvertNOGE_BU(TrimVertex *t)
{
#ifdef USE_OPTTT
//	surfaceEvaluator.inDoEvalCoord2NOGE_BU( t->param[0], t->param[1], t->cache_point, t->cache_normal);    
#endif
}

//opt for a line with the same v.
void
Backend::tmeshvertNOGE_BV(TrimVertex *t)
{
#ifdef USE_OPTTT
//	surfaceEvaluator.inDoEvalCoord2NOGE_BV( t->param[0], t->param[1], t->cache_point, t->cache_normal);    
#endif
}

void
Backend::preEvaluateBU(REAL u)
{
//	surfaceEvaluator.inPreEvaluateBU_intfac(u);
}

void 
Backend::preEvaluateBV(REAL v)
{
//	surfaceEvaluator.inPreEvaluateBV_intfac(v);
}


/*-------------------------------------------------------------------------
 * tmeshvert - evaluate a point on a triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::tmeshvert( TrimVertex *t )
{

    const long nuid = t->nuid;
    const REAL u = t->param[0];
    const REAL v = t->param[1];

#ifndef NOWIREFRAME
    npts++;
    if( wireframetris ) {
	if( npts >= 3 ) {
	    surfaceEvaluator.bgnclosedline();
	    if( mesh[0][2] == 0 )
		surfaceEvaluator.evalcoord2f( mesh[0][3], mesh[0][0], mesh[0][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[0][0], (long) mesh[0][1] );
	    if( mesh[1][2] == 0 )
		surfaceEvaluator.evalcoord2f( mesh[1][3], mesh[1][0], mesh[1][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[1][0], (long) mesh[1][1] );
	    surfaceEvaluator.evalcoord2f( nuid, u, v );
	    surfaceEvaluator.endclosedline();
	}
        mesh[meshindex][0] = u;
        mesh[meshindex][1] = v;
	mesh[meshindex][2] = 0;
	mesh[meshindex][3] = nuid;
        meshindex = (meshindex+1) % 2;
    } else {
	surfaceEvaluator.evalcoord2f( nuid, u, v );
    }
#else
    surfaceEvaluator.evalcoord2f( nuid, u, v );
#endif
}

/*-------------------------------------------------------------------------
 * tmeshvert - evaluate a grid point of a triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::tmeshvert( GridVertex *g )
{
    const long u = g->gparam[0];
    const long v = g->gparam[1];

#ifndef NOWIREFRAME
    npts++;
    if( wireframetris ) {
	if( npts >= 3 ) {
	    surfaceEvaluator.bgnclosedline();
	    if( mesh[0][2] == 0 )
		surfaceEvaluator.evalcoord2f( (long) mesh[0][3], mesh[0][0], mesh[0][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[0][0], (long) mesh[0][1] );
	    if( mesh[1][2] == 0 )
		surfaceEvaluator.evalcoord2f( (long) mesh[1][3], mesh[1][0], mesh[1][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[1][0], (long) mesh[1][1] );
	    surfaceEvaluator.evalpoint2i( u, v );
	    surfaceEvaluator.endclosedline();
	}
        mesh[meshindex][0] = u;
        mesh[meshindex][1] = v;
	mesh[meshindex][2] = 1;
        meshindex = (meshindex+1) % 2;
    } else {
        surfaceEvaluator.evalpoint2i( u, v );
    }
#else
    surfaceEvaluator.evalpoint2i( u, v );
#endif
}

/*-------------------------------------------------------------------------
 * swaptmesh - perform a swap of the triangle mesh pointers
 *-------------------------------------------------------------------------
 */
void
Backend::swaptmesh( void )
{
#ifndef NOWIREFRAME
    if( wireframetris ) {
        meshindex = 1 - meshindex;
    } else {
	surfaceEvaluator.swaptmesh();
    }
#else
    surfaceEvaluator.swaptmesh();
#endif
}

/*-------------------------------------------------------------------------
 * endtmesh - postamble to triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::endtmesh( void )
{
#ifndef NOWIREFRAME
    if( ! wireframetris )
        surfaceEvaluator.endtmesh();
#else
    surfaceEvaluator.endtmesh();
    surfaceEvaluator.polymode( N_MESHFILL );
#endif
}


/*-------------------------------------------------------------------------
 * bgnoutline - preamble to outlined rendering
 *-------------------------------------------------------------------------
 */
void
Backend::bgnoutline( void )
{
    surfaceEvaluator.bgnline();
}

/*-------------------------------------------------------------------------
 * linevert - evaluate a point on an outlined contour
 *-------------------------------------------------------------------------
 */
void
Backend::linevert( TrimVertex *t )
{
    surfaceEvaluator.evalcoord2f( t->nuid, t->param[0], t->param[1] );
}

/*-------------------------------------------------------------------------
 * linevert - evaluate a grid point of an outlined contour
 *-------------------------------------------------------------------------
 */
void
Backend::linevert( GridVertex *g )
{
    surfaceEvaluator.evalpoint2i( g->gparam[0], g->gparam[1] );
}

/*-------------------------------------------------------------------------
 * endoutline - postamble to outlined rendering
 *-------------------------------------------------------------------------
 */
void
Backend::endoutline( void )
{
    surfaceEvaluator.endline();
}

/*-------------------------------------------------------------------------
 * triangle - output a triangle 
 *-------------------------------------------------------------------------
 */
void
Backend::triangle( TrimVertex *a, TrimVertex *b, TrimVertex *c )
{
    bgntmesh( "spittriangle" );
    tmeshvert( a );
    tmeshvert( b );
    tmeshvert( c );
    endtmesh();
}

void 
Backend::bgncurv( void )
{
    curveEvaluator.bgnmap1f( 0 );
}

void
Backend::segment( REAL ulo, REAL uhi )
{
    curveEvaluator.domain1f( ulo, uhi );
} 

void 
Backend::curvpts( 
    long type,		 	/* geometry, color, texture, normal */
    REAL *pts, 			/* control points */
    long stride, 		/* distance to next point */
    int order,			/* parametric order */
    REAL ulo,			/* lower parametric bound */
    REAL uhi )			/* upper parametric bound */

{
    curveEvaluator.map1f( type, ulo, uhi, stride, order, pts );
    curveEvaluator.enable( type );
}

void 
Backend::curvgrid( REAL u0, REAL u1, long nu )
{
    curveEvaluator.mapgrid1f( nu, u0, u1 );
}

void 
Backend::curvmesh( long from, long n )
{
    curveEvaluator.mapmesh1f( N_MESHFILL, from, from+n );
}

void 
Backend::curvpt(REAL u)
{
    curveEvaluator.evalcoord1f( 0, u );
}

void 
Backend::bgnline( void )		
{
    curveEvaluator.bgnline();
}

void 
Backend::endline( void )
{
    curveEvaluator.endline();
}

void 
Backend::endcurv( void )
{
    curveEvaluator.endmap1f();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\basiccrv.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basiccrveval.c++ - $Revision: 1.1 $
 *	Derrick Burns - 1992
 */

#include "mystdio.h"
#include "types.h"
#include "basiccrv.h"

void 
BasicCurveEvaluator::domain1f( REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "domain1f\n" );
#endif
}

void 
BasicCurveEvaluator::range1f( long type, REAL *, REAL * )
{
#ifndef NDEBUG
    dprintf( "range1f\n" );
#endif
}

void 
BasicCurveEvaluator::enable( long )
{
#ifndef NDEBUG
    dprintf( "enable\n" );
#endif
}

void 
BasicCurveEvaluator::disable( long )
{
#ifndef NDEBUG
    dprintf( "disable\n" );
#endif
}

void 
BasicCurveEvaluator::bgnmap1f( long )
{
#ifndef NDEBUG
    dprintf( "bgnmap1f\n" );
#endif
}

void 
BasicCurveEvaluator::map1f( long, REAL, REAL, long, long, REAL * )
{
#ifndef NDEBUG
    dprintf( "map1f\n" );
#endif
}

void 
BasicCurveEvaluator::mapgrid1f( long, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "mapgrid1f\n" );
#endif
}

void 
BasicCurveEvaluator::mapmesh1f( long, long, long )
{
#ifndef NDEBUG
    dprintf( "mapmesh1f\n" );
#endif
}

void 
BasicCurveEvaluator::evalcoord1f( long, REAL )
{
#ifndef NDEBUG
    dprintf( "evalcoord1f\n" );
#endif
}

void 
BasicCurveEvaluator::endmap1f( void )
{
#ifndef NDEBUG
    dprintf( "endmap1f\n" );
#endif
}

void 
BasicCurveEvaluator::bgnline( void )
{
#ifndef NDEBUG
    dprintf( "bgnline\n" );
#endif
}

void 
BasicCurveEvaluator::endline( void )
{
#ifndef NDEBUG
    dprintf( "endline\n" );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\bezierar.h ===
#ifndef __glubezierarc_h
#define __glubezierarc_h

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bezierarc.h - $Revision: 1.1 $
 */

#include "myassert.h"

class Mapdesc;

#ifdef NT
class BezierArc : public PooledObj { /* a bezier arc */
public:
#else
struct BezierArc : public PooledObj { /* a bezier arc */
#endif
    REAL *		cpts;		/* control points of arc */
    int			order;		/* order of arc */
    int			stride;		/* REAL distance between points */
    long		type;		/* curve type */
    Mapdesc *		mapdesc;
};

#endif /* __glubezierarc_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\basicsur.h ===
#ifndef __glubasicsurfeval_h_
#define __glubasicsurfeval_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basicsurfeval.h - $Revision: 1.3 $
 */

#include "types.h"
#include "displaym.h"
#include "cachinge.h"

class BasicSurfaceEvaluator : public CachingEvaluator {
public:
    virtual void	range2f( long, REAL *, REAL * );
    virtual void	domain2f( REAL, REAL, REAL, REAL );

    virtual void	enable( long );
    virtual void	disable( long );
    virtual void	bgnmap2f( long );
    virtual void	map2f( long, REAL, REAL, long, long, 
				     REAL, REAL, long, long, 
				     REAL *  );
    virtual void	mapgrid2f( long, REAL, REAL, long,  REAL, REAL );
    virtual void	mapmesh2f( long, long, long, long, long );
    virtual void	evalcoord2f( long, REAL, REAL );
    virtual void	evalpoint2i( long, long );
    virtual void	endmap2f( void );

    virtual void	polymode( long );
    virtual void 	bgnline( void );
    virtual void 	endline( void );
    virtual void 	bgnclosedline( void );
    virtual void 	endclosedline( void );
    virtual void 	bgntmesh( void );
    virtual void 	swaptmesh( void );
    virtual void 	endtmesh( void );
    virtual void 	bgnqstrip( void );
    virtual void 	endqstrip( void );

    virtual void 	bgntfan( void );
    virtual void 	endtfan( void );

};

#endif /* __glubasicsurfeval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\bin.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bin.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "bin.h"

/*----------------------------------------------------------------------------
 * Constructor and destructor
 *----------------------------------------------------------------------------
 */
Bin::Bin()
{
    head = NULL;
}

Bin::~Bin()
{
    assert( head == NULL);
}

/*----------------------------------------------------------------------------
 * remove_this_arc - remove given Arc_ptr from bin
 *----------------------------------------------------------------------------
 */

void 
Bin::remove_this_arc( Arc_ptr arc )
{
    for( Arc_ptr *j = &(head); (*j != 0) && (*j != arc); j = &((*j)->link) );

    if( *j != 0 ) {
        if( *j == current )
	    current = (*j)->link;
	*j = (*j)->link;
    }
}

/*----------------------------------------------------------------------------
 * numarcs - count number of arcs in bin
 *----------------------------------------------------------------------------
 */

int
Bin::numarcs()
{
    long count = 0;
    for( Arc_ptr jarc = firstarc(); jarc; jarc = nextarc() )
	count++;
    return count;
}

/*----------------------------------------------------------------------------
 * adopt - place an orphaned arcs into their new parents bin
 *----------------------------------------------------------------------------
 */

void 
Bin::adopt()
{
    markall();

    Arc_ptr orphan;
    while( orphan = removearc() ) {
	for( Arc_ptr parent = orphan->next; parent != orphan; parent = parent->next ) {
	    if (! parent->ismarked() ) {
		orphan->link = parent->link;
		parent->link = orphan;
		orphan->clearmark();
		break;
	    }
	}
    }
}


/*----------------------------------------------------------------------------
 * show - print out descriptions of the arcs in the bin
 *----------------------------------------------------------------------------
 */

void
Bin::show( char *name )
{
#ifndef NDEBUG
    dprintf( "%s\n", name );
    for( Arc_ptr jarc = firstarc(); jarc; jarc = nextarc() )
        jarc->show( );
#endif
}



/*----------------------------------------------------------------------------
 * markall - mark all arcs with an identifying tag
 *----------------------------------------------------------------------------
 */

void 
Bin::markall()
{
    for( Arc_ptr jarc=firstarc(); jarc; jarc=nextarc() )
	jarc->setmark();
}

/*----------------------------------------------------------------------------
 * listBezier - print out all arcs that are untessellated border arcs
 *----------------------------------------------------------------------------
 */

void 
Bin::listBezier( void )
{
    for( Arc_ptr jarc=firstarc(); jarc; jarc=nextarc() ) {
	if( jarc->isbezier( ) ) {
    	    assert( jarc->pwlArc->npts == 2 );	
	    TrimVertex  *pts = jarc->pwlArc->pts;
    	    REAL s1 = pts[0].param[0];
    	    REAL t1 = pts[0].param[1];
    	    REAL s2 = pts[1].param[0];
    	    REAL t2 = pts[1].param[1];
#ifndef NDEBUG
	   dprintf( "arc (%g,%g) (%g,%g)\n", s1, t1, s2, t2 );
#endif
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\basiccrv.h ===
#ifndef __glubasiccrveval_h_
#define __glubasiccrveval_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basiccurveeval.h - $Revision: 1.1 $
 */

#include "types.h"
#include "displaym.h"
#include "cachinge.h"

class BasicCurveEvaluator : public CachingEvaluator {
public:
    virtual void	domain1f( REAL, REAL );
    virtual void	range1f( long, REAL *, REAL * );

    virtual void	enable( long );
    virtual void	disable( long );
    virtual void	bgnmap1f( long );
    virtual void	map1f( long, REAL, REAL, long, long, REAL * );
    virtual void	mapgrid1f( long, REAL, REAL );
    virtual void	mapmesh1f( long, long, long );
    virtual void	evalcoord1f( long, REAL );
    virtual void	endmap1f( void );

    virtual void	bgnline( void );
    virtual void	endline( void );
};

#endif /* __glubasiccrveval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\basicsur.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basicsurfaceevaluator.c++ - $Revision: 1.2 $
  *	Derrick Burns - 1992
 */

#include "mystdio.h"
#include "types.h"
#include "basicsur.h"

void 
BasicSurfaceEvaluator::domain2f( REAL, REAL, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "domain2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::polymode( long )
{
#ifndef NDEBUG
    dprintf( "polymode\n" );
#endif
}

void
BasicSurfaceEvaluator::range2f( long type, REAL *from, REAL *to )
{
#ifndef NDEBUG
    dprintf( "range2f type %ld, from (%g,%g), to (%g,%g)\n", 
		type, from[0], from[1], to[0], to[1] );
#endif
}

void 
BasicSurfaceEvaluator::enable( long )
{
#ifndef NDEBUG
    dprintf( "enable\n" );
#endif
}

void 
BasicSurfaceEvaluator::disable( long )
{
#ifndef NDEBUG
    dprintf( "disable\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnmap2f( long )
{
#ifndef NDEBUG
    dprintf( "bgnmap2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::endmap2f( void )
{
#ifndef NDEBUG
    dprintf( "endmap2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::map2f( long, REAL, REAL, long, long, 
				    REAL, REAL, long, long,
			      REAL * )
{
#ifndef NDEBUG
    dprintf( "map2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::mapgrid2f( long, REAL, REAL, long, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "mapgrid2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::mapmesh2f( long, long, long, long, long )
{
#ifndef NDEBUG
    dprintf( "mapmesh2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::evalcoord2f( long, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "evalcoord2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::evalpoint2i( long, long )
{
#ifndef NDEBUG
    dprintf( "evalpoint2i\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnline( void )
{
#ifndef NDEBUG
    dprintf( "bgnline\n" );
#endif
}

void 
BasicSurfaceEvaluator::endline( void )
{
#ifndef NDEBUG
    dprintf( "endline\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnclosedline( void )
{
#ifndef NDEBUG
    dprintf( "bgnclosedline\n" );
#endif
}

void 
BasicSurfaceEvaluator::endclosedline( void )
{
#ifndef NDEBUG
    dprintf( "endclosedline\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgntfan( void )
{
#ifndef NDEBUG
    dprintf( "bgntfan\n" );
#endif
}

void 
BasicSurfaceEvaluator::endtfan( void )
{
}


void 
BasicSurfaceEvaluator::bgntmesh( void )
{
#ifndef NDEBUG
    dprintf( "bgntmesh\n" );
#endif
}

void 
BasicSurfaceEvaluator::swaptmesh( void )
{
#ifndef NDEBUG
    dprintf( "swaptmesh\n" );
#endif
}

void 
BasicSurfaceEvaluator::endtmesh( void )
{
#ifndef NDEBUG
    dprintf( "endtmesh\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnqstrip( void )
{
#ifndef NDEBUG
    dprintf( "bgnqstrip\n" );
#endif
}

void 
BasicSurfaceEvaluator::endqstrip( void )
{
#ifndef NDEBUG
    dprintf( "endqstrip\n" );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\bin.h ===
#ifndef __glubin_h_
#define __glubin_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bin.h - $Revision: 1.2 $
 */

#include "myassert.h"
#include "arc.h"
#include "defines.h"

#ifdef NT
class Bin { /* a linked list of jordan arcs */
#else
struct Bin { /* a linked list of jordan arcs */
#endif
private:
    Arc *		head;		/* first arc on list */
    Arc *		current;	/* current arc on list */
public:
    			Bin();
			~Bin();
    inline Arc *	firstarc( void );
    inline Arc *	nextarc( void );
    inline Arc *	removearc( void );
    inline int		isnonempty( void ) { return (head ? 1 : 0); }
    inline void		addarc( Arc * );
    void 		remove_this_arc( Arc * );
    int			numarcs( void );
    void 		adopt( void );
    void		markall( void );
    void		show( char * );
    void		listBezier( void );
};

/*----------------------------------------------------------------------------
 * Bin::addarc - add an Arc * to head of linked list of Arc *s
 *----------------------------------------------------------------------------
 */

inline void
Bin::addarc( Arc *jarc )
{
   jarc->link = head;
   head = jarc;
}

/*----------------------------------------------------------------------------
 * Bin::removearc - remove first Arc * from bin
 *----------------------------------------------------------------------------
 */

inline Arc *
Bin::removearc( void )
{
    Arc * jarc = head;

    if( jarc ) head = jarc->link;
    return jarc;
}


/*----------------------------------------------------------------------------
 * BinIter::nextarc - return current arc in bin and advance pointer to next arc
 *----------------------------------------------------------------------------
 */

inline Arc *
Bin::nextarc( void )
{
    Arc * jarc = current;

#ifdef DEBUG
    assert( jarc->check() != 0 );
#endif

    if( jarc ) current = jarc->link;
    return jarc;
}

/*----------------------------------------------------------------------------
 * BinIter::firstarc - set current arc to first arc of bin advance to next arc
 *----------------------------------------------------------------------------
 */

inline Arc *
Bin::firstarc( void )
{
    current = head;
    return nextarc( );
}

#endif /* __glubin_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\bufpool.cxx ===
/**************************************************************************
 *    								  *
 *     	 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *    								  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *    								  *
 **************************************************************************/

/*
 *  bufpool.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "bufpool.h"


/*-----------------------------------------------------------------------------
 * Pool - allocate a new pool of buffers
 *-----------------------------------------------------------------------------
 */
Pool::Pool( int _buffersize, int initpoolsize, char *n )
{
    buffersize= (_buffersize < sizeof(Buffer)) ? sizeof(Buffer)	: _buffersize;
    initsize	= initpoolsize * buffersize;
    nextsize	= initsize;
    name	= n;
    magic	= is_allocated;
    nextblock	= 0;
    curblock	= 0;
    freelist	= 0;
    nextfree	= 0;
}

/*-----------------------------------------------------------------------------
 * ~Pool - free a pool of buffers and the pool itself
 *-----------------------------------------------------------------------------
 */

Pool::~Pool( void )
{
    assert( (this != 0) && (magic == is_allocated) );

    while( nextblock ) {
	delete blocklist[--nextblock];
        blocklist[nextblock] = 0;
    }
    magic = is_free;
}


void Pool::grow( void )
{
    assert( (this != 0) && (magic == is_allocated) );
    curblock = new char[nextsize];
    blocklist[nextblock++] = curblock;
    nextfree = nextsize;
    nextsize *= 2;
}

/*-----------------------------------------------------------------------------
 * Pool::clear - free buffers associated with pool but keep pool 
 *-----------------------------------------------------------------------------
 */

void 
Pool::clear( void )
{
    assert( (this != 0) && (magic == is_allocated) );

    while( nextblock ) {
	delete blocklist[--nextblock];
	blocklist[nextblock] = 0;
    }
    curblock	= 0;
    freelist	= 0;
    nextfree	= 0;
    if( nextsize > initsize )
        nextsize /= 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\bufpool.h ===
#ifndef __glubufpool_h_
#define __glubufpool_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bufpool.h - $Revision: 1.3 $
 */

#include "myassert.h"
#include "mystdlib.h"

#define NBLOCKS	32

class Buffer {
	friend class 	Pool;
	Buffer	*	next;		/* next buffer on free list	*/
};

class Pool {
public:
			Pool( int, int, char * );
			~Pool( void );
    inline void*	new_buffer( void );
    inline void		free_buffer( void * );
    void		clear( void );
    
private:
    void		grow( void );

protected:
    Buffer		*freelist;		/* linked list of free buffers */
    char		*blocklist[NBLOCKS];	/* blocks of malloced memory */
    int			nextblock;		/* next free block index */
    char		*curblock;		/* last malloced block */
    int			buffersize;		/* bytes per buffer */
    int			nextsize;		/* size of next block of memory	*/
    int			nextfree;		/* byte offset past next free buffer */
    int			initsize;
    enum Magic { is_allocated = 0xf3a1, is_free = 0xf1a2 };
    char		*name;			/* name of the pool */
    Magic		magic;			/* marker for valid pool */
};

/*-----------------------------------------------------------------------------
 * Pool::free_buffer - return a buffer to a pool
 *-----------------------------------------------------------------------------
 */

inline void
Pool::free_buffer( void *b )
{
    assert( (this != 0) && (magic == is_allocated) );

    /* add buffer to singly connected free list */

    ((Buffer *) b)->next = freelist;
    freelist = (Buffer *) b;
}


/*-----------------------------------------------------------------------------
 * Pool::new_buffer - allocate a buffer from a pool
 *-----------------------------------------------------------------------------
 */

inline void * 
Pool::new_buffer( void )
{
    void *buffer;

    assert( (this != 0) && (magic == is_allocated) );

    /* find free buffer */

    if( freelist ) {
    	buffer = (void *) freelist; 
    	freelist = freelist->next;
    } else {
    	if( ! nextfree )
    	    grow( );
    	nextfree -= buffersize;;
    	buffer = (void *) (curblock + nextfree);
    }
    return buffer;
}
	
class PooledObj {
public:
    inline void *	operator new( size_t, Pool & );
    inline void * 	operator new( size_t, void *);
    inline void * 	operator new( size_t s)
				{ return ::new char[s]; }
    inline void 	operator delete( void * ) { assert( 0 ); }
    inline void		deleteMe( Pool & );
};

inline void *
PooledObj::operator new( size_t, Pool& pool )
{
    return pool.new_buffer();
}

inline void
PooledObj::deleteMe( Pool& pool )
{
    pool.free_buffer( (void *) this );
}

#endif /* __glubufpool_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\cachinge.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * cachingeval.c++ - $Revision: 1.1 $
 */

#include "cachinge.h"

int
CachingEvaluator::canRecord( void )
{
    return 0;
}

int
CachingEvaluator::canPlayAndRecord( void )
{
    return 0;
}

int
CachingEvaluator::createHandle( int )
{
    return 0;
}

void
CachingEvaluator::beginOutput( ServiceMode, int )
{
}

void
CachingEvaluator::endOutput( void )
{
} 

void
CachingEvaluator::discardRecording( int )
{
}

void
CachingEvaluator::playRecording( int )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\ccw.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * ccw.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "subdivid.h"
#include "types.h"
#include "arc.h"
#include "trimvert.h"
#include "simplema.h"

inline int 
Subdivider::bbox( TrimVertex *a, TrimVertex *b, TrimVertex *c, int p )
{
    return bbox( a->param[p], b->param[p], c->param[p], 
	         a->param[1-p], b->param[1-p], c->param[1-p] ); 
}

int
Subdivider::ccwTurn_sr( Arc_ptr j1, Arc_ptr j2 ) // dir = 1
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 0 );
#endif

    // the arcs lie on the line (0 == v1->param[0])
    if( v1->param[0] == v1next->param[0] && v2->param[0] == v2next->param[0] )
	return 0;

    if( v2next->param[0] < v2->param[0] || v1next->param[0] < v1->param[0] )
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[1] < v2->param[1] )
	return 0;
    else if( v1->param[1] > v2->param[1] )
	return 1;

    while( 1 ) {
	if( v1next->param[0] < v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case a\n" );
#endif
	    assert( v1->param[0] <= v1next->param[0] );
	    assert( v2->param[0] <= v1next->param[0] );
	    switch( bbox( v2, v2next, v1next, 1 ) ) {
		case -1:
		    return 0;
		case 0:
		   sgn = ccw( v1next, v2, v2next );
		   if( sgn != -1 ) {
			return sgn;
		   } else {
			dprintf( "decr\n" );
			v1 = v1next--;
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else if( v1next->param[0] > v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case b\n" );
#endif
	    assert( v1->param[0] <= v2next->param[0] );
	    assert( v2->param[0] <= v2next->param[0] );
	    switch( bbox( v1, v1next, v2next, 1 ) ) {
		case -1:
		    return 1;
		case 0:
		   sgn = ccw( v1next, v1, v2next );
		   if( sgn != -1 ) { 
			return sgn;
		   } else {
			dprintf( "incr\n" );
			v2 = v2next++;
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else {
#ifndef NDEBUG
	    dprintf( "case ab\n" );
#endif
	    if( v1next->param[1] < v2next->param[1] )
		return 0;
	    else if( v1next->param[1] > v2next->param[1] )
		return 1;
	    else {
		dprintf( "incr\n" );
		v2 = v2next++;
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}

int
Subdivider::ccwTurn_sl( Arc_ptr j1, Arc_ptr j2 ) // dir = 0
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 0 );
#endif

    // the arcs lie on the line (0 == v1->param[0])
    if( v1->param[0] == v1next->param[0] && v2->param[0] == v2next->param[0] )
	return 0;

    if( v2next->param[0] > v2->param[0] || v1next->param[0] > v1->param[0] ) 
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[1] < v2->param[1] )
	return 1;
    else if( v1->param[1] > v2->param[1] )
	return 0;

    while( 1 ) {
	if( v1next->param[0] > v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case c\n" );
#endif
	    assert( v1->param[0] >= v1next->param[0] );
	    assert( v2->param[0] >= v1next->param[0] );
	    switch( bbox( v2next, v2, v1next, 1 ) ) {
		case -1:
		    return 1;
		case 0:
		    sgn = ccw( v1next, v2, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v1 = v1next--;
			dprintf( "decr\n" );
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else if( v1next->param[0] < v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case d\n" );
#endif
	    assert( v1->param[0] >= v2next->param[0] );
	    assert( v2->param[0] >= v2next->param[0] );
	    switch( bbox( v1next, v1, v2next, 1 ) ) {
		case -1:
		    return 0;
		case 0:
		    sgn = ccw( v1next, v1, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v2 = v2next++;
			dprintf( "incr\n" );
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else {
	    dprintf( "case cd\n" );
	    if( v1next->param[1] < v2next->param[1] )
		return 1;
	    else if( v1next->param[1] > v2next->param[1] )
		return 0;
	    else {
		v2 = v2next++;
		dprintf( "incr\n" );
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}

int
Subdivider::ccwTurn_tr( Arc_ptr j1, Arc_ptr j2 ) // dir = 1
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 1 );
#endif

    // the arcs lie on the line (1 == v1->param[1])
    if( v1->param[1] == v1next->param[1] && v2->param[1] == v2next->param[1] )
	return 0;

    if( v2next->param[1] < v2->param[1] || v1next->param[1] < v1->param[1] )
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[0] < v2->param[0] )
	return 1;
    else if( v1->param[0] > v2->param[0] )
	return 0;

    while( 1 ) {
	if( v1next->param[1] < v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case a\n" );
#endif
	    assert( v1->param[1] <= v1next->param[1] );
	    assert( v2->param[1] <= v1next->param[1] );
	    switch( bbox( v2, v2next, v1next, 0 ) ) {
		case -1:
		    return 1;
		case 0:
		   sgn = ccw( v1next, v2, v2next );
		   if( sgn != -1 ) {
			return sgn;
		   } else {
			dprintf( "decr\n" );
			v1 = v1next--;
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else if( v1next->param[1] > v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case b\n" );
#endif
	    assert( v1->param[1] <= v2next->param[1] );
	    assert( v2->param[1] <= v2next->param[1] );
	    switch( bbox( v1, v1next, v2next, 0 ) ) {
		case -1:
		    return 0;
		case 0:
		   sgn = ccw( v1next, v1, v2next );
		   if( sgn != -1 ) { 
			return sgn;
		   } else {
			dprintf( "incr\n" );
			v2 = v2next++;
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else {
	    dprintf( "case ab\n" );
	    if( v1next->param[0] < v2next->param[0] )
		return 1;
	    else if( v1next->param[0] > v2next->param[0] )
		return 0;
	    else {
		dprintf( "incr\n" );
		v2 = v2next++;
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}

int
Subdivider::ccwTurn_tl( Arc_ptr j1, Arc_ptr j2 )
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 1 );
#endif

    // the arcs lie on the line (1 == v1->param[1])
    if( v1->param[1] == v1next->param[1] && v2->param[1] == v2next->param[1] )
	return 0;

    if( v2next->param[1] > v2->param[1] || v1next->param[1] > v1->param[1] ) 
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[0] < v2->param[0] )
	return 0;
    else if( v1->param[0] > v2->param[0] )
	return 1;

    while( 1 ) {
	if( v1next->param[1] > v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case c\n" );
#endif
	    assert( v1->param[1] >= v1next->param[1] );
	    assert( v2->param[1] >= v1next->param[1] );
	    switch( bbox( v2next, v2, v1next, 0 ) ) {
		case -1:
		    return 0;
		case 0:
		    sgn = ccw( v1next, v2, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v1 = v1next--;
			dprintf( "decr\n" );
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else if( v1next->param[1] < v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case d\n" );
	    assert( v1->param[1] >= v2next->param[1] );
	    assert( v2->param[1] >= v2next->param[1] );
#endif
	    switch( bbox( v1next, v1, v2next, 0 ) ) {
		case -1:
		    return 1;
		case 0:
		    sgn = ccw( v1next, v1, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v2 = v2next++;
			dprintf( "incr\n" );
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else {
	    dprintf( "case cd\n" );
	    if( v1next->param[0] < v2next->param[0] )
		return 0;
	    else if( v1next->param[0] > v2next->param[0] )
		return 1;
	    else {
		v2 = v2next++;
		dprintf( "incr\n" );
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}


#ifndef NDEBUG
int
Subdivider::bbox( register REAL sa, register REAL sb, register REAL sc,
      register REAL ta, register REAL tb, register REAL tc )
#else
int
Subdivider::bbox( register REAL sa, register REAL sb, register REAL sc,
      register REAL   , register REAL   , register REAL    )
#endif
{
#ifndef NDEBUG
    assert( tc >= ta );
    assert( tc <= tb );
#endif

    if( sa < sb ) {
	if( sc <= sa ) {
	    return -1;
	} else if( sb <= sc ) {
	    return 1;
	} else {
	    return 0;
	}
    } else if( sa > sb ) {
	if( sc >= sa ) {
	    return 1;
	} else if( sb >= sc ) {
	    return -1;
	} else {
	    return 0;
	}
    } else {
	if( sc > sa ) {
	    return 1;
	} else if( sb > sc ) {
	    return -1;
	} else {
	    return 0;
	}
    }
}

/*----------------------------------------------------------------------------
 * ccw - determine how three points are oriented by computing their
 *	 determinant.  
 *	 Return 1 if the vertices are ccw oriented, 
 *		0 if they are cw oriented, or 
 *		-1 if the computation is ill-conditioned.
 *----------------------------------------------------------------------------
 */
int
Subdivider::ccw( TrimVertex *a, TrimVertex *b, TrimVertex *c )
{
    REAL d = det3( a, b, c );
    if( abs(d) < 0.0001 ) return -1;
    return (d < 0.0) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\cachinge.h ===
#ifndef __glucachingval_h_
#define __glucachingval_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * cachingeval.h - $Revision: 1.1 $
 */

class CachingEvaluator {
public:
    enum ServiceMode 	{ play, record, playAndRecord };
    virtual int		canRecord( void );
    virtual int		canPlayAndRecord( void );
    virtual int		createHandle( int handle );
    virtual void	beginOutput( ServiceMode, int handle );
    virtual void	endOutput( void ); 
    virtual void	discardRecording( int handle );
    virtual void	playRecording( int handle );
};
#endif /* __glucachingval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\checker.h ===
#ifndef __gluchecker_h_
#define __gluchecker_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * checker.h - $Revision: 1.1 $
 */

#include "types.h"
#include "bufpool.h"

/* local type definitions */
struct Edge : PooledObj {
			Edge( REAL *, REAL *, char * );
    REAL		v1[3];
    REAL		v2[3];
    char *		name;
    int 		count;
    Edge *		next;
};

class Hashtable {
private:
#define NENTRIES	5997
    Pool 		edgepool;
    int			slot;
    Edge *		curentry;
    Edge *		hashtable[NENTRIES];
public:
			Hashtable( void );
    void		init( void );
    void		clear( void );
    Edge *		find( REAL *, REAL * );
    void		insert( REAL *, REAL *, char * );
    long		hashval( REAL *, REAL * );
    Edge *		firstentry( void );
    Edge *		nextentry( void );
    static inline int	equal( REAL *, REAL * );
};

class Checker {
private:
    Hashtable		hashtable;
    long		graphwin;
    int			initialized;
    
    REAL		ulo, uhi, vlo, vhi;
    REAL    		us, vs, dus, dvs;
    int			npts;
    REAL		cache[3][3];
    int			index;
    char *		curname;
    REAL 		tempa[3], tempb[3];	

    inline void		add_edgei( long, long, long, long );
    void		add_edge( REAL *, REAL * );
    void		add_tri( REAL *, REAL *, REAL * );
    void		dump( Edge * );
    void		reference( Edge * );

public:
    inline void *	operator new( size_t ){ return ::malloc( sizeof( Checker ) ); }
    inline void 	operator delete( void *p ) { if( p ) ::free( p ); }
			Checker( void ) { graphwin = 0; initialized = 0; }
    void		init( void );
    void		graph( void );
    void		range( REAL, REAL, REAL, REAL );
    void		grid( REAL, REAL, REAL, REAL );
    void		add_mesh( long, long, long, long );
    void		bgntmesh( char *);
    void		swaptmesh( void );
    void		s2ftmesh( REAL * );
    void		g2ltmesh( long * );
    void		endtmesh( void );
    void		bgnoutline( char * );
    void		s2foutline( REAL * );
    void		g2loutline( long * );
    void		endoutline( void );
};

#endif /* __gluchecker_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\curve.h ===
#ifndef __glucurve_h_
#define __glucurve_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curve.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"

class Mapdesc;
class Quilt;


class Curve {
public:
friend class Curvelist;
    			Curve( Quilt *, REAL, REAL, Curve * );
    			Curve( Curve&, REAL, Curve * );
    Curve *		next;
private:
    Mapdesc *		mapdesc;
    int			stride;
    int		        order;
    int			cullval;
    int			needsSampling;
    REAL		cpts[MAXORDER*MAXCOORDS];
    REAL		spts[MAXORDER*MAXCOORDS];
    REAL		stepsize;
    REAL		minstepsize;
    REAL		range[3];

    void		clamp( void );
    void		setstepsize( REAL );
    void		getstepsize( void );
    int			cullCheck( void );
    int			needsSamplingSubdivision( void );
};
#endif /* __glucurve_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\coveandt.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * coveandtiler.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "coveandt.h"
#include "gridvert.h"
#include "gridtrim.h"
#include "uarray.h"
#include "backend.h"


const int CoveAndTiler::MAXSTRIPSIZE = 1000;

CoveAndTiler::CoveAndTiler( Backend& b )
            : backend( b )
{ }

CoveAndTiler::~CoveAndTiler( void )
{ }

inline void
CoveAndTiler::output( GridVertex &gv )
{
    backend.tmeshvert( &gv );
}

inline void
CoveAndTiler::output( TrimVertex *tv )
{
    backend.tmeshvert( tv );
}

inline void
CoveAndTiler::output( GridTrimVertex& g )
{
    backend.tmeshvert( &g );
}

void 
CoveAndTiler::coveAndTile( void )
{
    long ustart = (top.ustart >= bot.ustart) ? top.ustart : bot.ustart;
    long uend   = (top.uend <= bot.uend)     ? top.uend   : bot.uend;
    if( ustart <= uend ) {
	tile( bot.vindex, ustart, uend );
	if( top.ustart >= bot.ustart )  
	    coveUpperLeft();
	else 
	    coveLowerLeft();
    
	if( top.uend <= bot.uend )  
	    coveUpperRight();
	else
	    coveLowerRight();
    } else {
	TrimVertex blv, tlv, *bl, *tl;
	GridTrimVertex bllv, tllv;
	TrimVertex *lf = left.first();
	TrimVertex *ll = left.last();
	if( lf->param[0] >= ll->param[0] ) {
	    blv.param[0] = lf->param[0];
	    blv.param[1] = ll->param[1];
	    blv.nuid = 0; // XXX
	    assert( blv.param[1] == bot.vval );
	    bl = &blv;
	    tl = lf;
	    tllv.set( lf );
	    if( ll->param[0] > uarray.uarray[top.ustart-1] ) {
		bllv.set( ll );
		assert( ll->param[0] <= uarray.uarray[bot.ustart] );
	    } else {
		bllv.set( top.ustart-1, bot.vindex );
	    }
	    coveUpperLeftNoGrid( bl );
	} else {
	    tlv.param[0] = ll->param[0];
	    tlv.param[1] = lf->param[1];
	    tlv.nuid = 0; // XXX
	    assert( tlv.param[1] == top.vval );
	    tl = &tlv;
	    bl = ll;
	    bllv.set( ll );
	    if( lf->param[0] > uarray.uarray[bot.ustart-1] ) {
		assert( lf->param[0] <= uarray.uarray[bot.ustart] );
		tllv.set( lf );
	    } else {
		tllv.set( bot.ustart-1, top.vindex );
	    }
 	    coveLowerLeftNoGrid( tl );
	}

	TrimVertex brv, trv, *br, *tr;
	GridTrimVertex brrv, trrv;
	TrimVertex *rf = right.first();
	TrimVertex *rl = right.last();

	if( rf->param[0] <= rl->param[0] ) {
	    brv.param[0] = rf->param[0];
	    brv.param[1] = rl->param[1];
	    brv.nuid = 0; // XXX
	    assert( brv.param[1] == bot.vval );
	    br = &brv;
	    tr = rf;
	    trrv.set( rf );
	    if( rl->param[0] < uarray.uarray[top.uend+1] ) {
		assert( rl->param[0] >= uarray.uarray[top.uend] );
		brrv.set( rl );
	    } else {
		brrv.set( top.uend+1, bot.vindex );
	    }
	    coveUpperRightNoGrid( br );
	} else {
	    trv.param[0] = rl->param[0];
	    trv.param[1] = rf->param[1];
	    trv.nuid = 0; // XXX
	    assert( trv.param[1] == top.vval );
	    tr = &trv;
	    br = rl;
	    brrv.set( rl );
	    if( rf->param[0] < uarray.uarray[bot.uend+1] ) {
	        assert( rf->param[0] >= uarray.uarray[bot.uend] );
		trrv.set( rf );
	    } else {
		trrv.set( bot.uend+1, top.vindex );
	    }
	    coveLowerRightNoGrid( tr );
	}

	backend.bgntmesh( "doit" );
	output(trrv);
	output(tllv);
	output( tr );
	output( tl );
	output( br );
	output( bl );
	output(brrv);
	output(bllv);
	backend.endtmesh();
    }
}

void 
CoveAndTiler::tile( long vindex, long ustart, long uend )
{
    long numsteps = uend - ustart;

    if( numsteps == 0 ) return;

    if( numsteps > MAXSTRIPSIZE ) {
	long umid = ustart + (uend - ustart) / 2;
	tile( vindex, ustart, umid );
	tile( vindex, umid, uend );
    } else {
	backend.surfmesh( ustart, vindex-1, numsteps, 1 );
    }
}

void 
CoveAndTiler::coveUpperRight( void )
{
    GridVertex tgv( top.uend, top.vindex );
    GridVertex gv( top.uend, bot.vindex );

    right.first();
    backend.bgntmesh( "coveUpperRight" );
    output( right.next() );
    output( tgv );
    backend.swaptmesh();
    output( gv );
        coveUR();
    backend.endtmesh();
}

void
CoveAndTiler::coveUpperRightNoGrid( TrimVertex* br )
{
    backend.bgntmesh( "coveUpperRight" );
    output( right.first() ); 
    output( right.next() );
    backend.swaptmesh();
    output( br );
        coveUR();
    backend.endtmesh();
}

void 
CoveAndTiler::coveUR( )
{
    GridVertex gv( top.uend, bot.vindex );
    TrimVertex *vert = right.next();
    if( vert == NULL ) return;

    assert( vert->param[0] >= uarray.uarray[gv.gparam[0]]  );

    if( gv.nextu() >= bot.uend ) {
	for( ; vert; vert = right.next() ) {
	    output( vert );
	    backend.swaptmesh();
	}
    } else while( 1 ) {
        if( vert->param[0] < uarray.uarray[gv.gparam[0]]  ) {
	    output( vert );
	    backend.swaptmesh();
	    vert = right.next();
	    if( vert == NULL ) break;
	} else {
	    backend.swaptmesh();
	    output( gv );
	    if( gv.nextu() == bot.uend ) {
		for( ; vert; vert = right.next() ) {
		    output( vert );
		    backend.swaptmesh();
    		}
		break;
	    }
	}
    }
}

void
CoveAndTiler::coveUpperLeft( void )
{
    GridVertex tgv( top.ustart, top.vindex );
    GridVertex gv( top.ustart, bot.vindex );

    left.first();
    backend.bgntmesh( "coveUpperLeft" );
    output( tgv );
    output( left.next() );
    output( gv );
    backend.swaptmesh();
        coveUL();
    backend.endtmesh();
}

void
CoveAndTiler::coveUpperLeftNoGrid( TrimVertex* bl )
{
    backend.bgntmesh( "coveUpperLeftNoGrid" );
    output( left.first() ); 
    output( left.next() );
    output( bl );
    backend.swaptmesh();
        coveUL();
    backend.endtmesh();
}

void 
CoveAndTiler::coveUL()
{
    GridVertex gv( top.ustart, bot.vindex );
    TrimVertex *vert = left.next();
    if( vert == NULL ) return;
    assert( vert->param[0] <= uarray.uarray[gv.gparam[0]]  );

    if( gv.prevu() <= bot.ustart ) {
	for( ; vert; vert = left.next() ) {
	    backend.swaptmesh();
	    output( vert );
	}
    } else while( 1 ) {
	if( vert->param[0] > uarray.uarray[gv.gparam[0]]  ) {
	    backend.swaptmesh();
	    output( vert );
	    vert = left.next();
	    if( vert == NULL ) break;
	} else {
	    output( gv );
	    backend.swaptmesh();
	    if( gv.prevu() == bot.ustart ) {
		for( ; vert; vert = left.next() ) {
		    backend.swaptmesh();
		    output( vert );
		}
		break;
	    }
	}
    }
}

void 
CoveAndTiler::coveLowerLeft( void )
{
    GridVertex bgv( bot.ustart, bot.vindex );
    GridVertex gv( bot.ustart, top.vindex );

    left.last();
    backend.bgntmesh( "coveLowerLeft" );
    output( left.prev() );
    output( bgv );
    backend.swaptmesh();
    output( gv );
        coveLL();
    backend.endtmesh();
}

void
CoveAndTiler::coveLowerLeftNoGrid( TrimVertex* tl )
{
    backend.bgntmesh( "coveLowerLeft" );
    output( left.last() ); 
    output( left.prev() );
    backend.swaptmesh();
    output( tl );
        coveLL( );
    backend.endtmesh();
}

void 
CoveAndTiler::coveLL()
{
    GridVertex gv( bot.ustart, top.vindex );
    TrimVertex *vert = left.prev();
    if( vert == NULL ) return;
    assert( vert->param[0] <= uarray.uarray[gv.gparam[0]]  );

    if( gv.prevu() <= top.ustart ) {
	for( ; vert; vert = left.prev() ) {
	    output( vert );
	    backend.swaptmesh();
	}
    } else while( 1 ) {
        if( vert->param[0] > uarray.uarray[gv.gparam[0]] ){
	    output( vert );
	    backend.swaptmesh();
	    vert = left.prev();
	    if( vert == NULL ) break;
	} else {
	    backend.swaptmesh();
	    output( gv );
	    if( gv.prevu() == top.ustart ) {
    		for( ; vert; vert = left.prev() ) {
		    output( vert );
		    backend.swaptmesh();
    		}
	        break;
	    }
	}
    }
}

void 
CoveAndTiler::coveLowerRight( void )
{
    GridVertex bgv( bot.uend, bot.vindex );
    GridVertex gv( bot.uend, top.vindex );

    right.last();
    backend.bgntmesh( "coveLowerRight" );	
    output( bgv );
    output( right.prev() );
    output( gv );
    backend.swaptmesh();
        coveLR();
    backend.endtmesh( );
}

void
CoveAndTiler::coveLowerRightNoGrid( TrimVertex* tr )
{
    backend.bgntmesh( "coveLowerRIght" );
    output( right.last() ); 
    output( right.prev() );
    output( tr );
    backend.swaptmesh();
        coveLR();
    backend.endtmesh();
}

void 
CoveAndTiler::coveLR( )
{
    GridVertex gv( bot.uend, top.vindex );
    TrimVertex *vert = right.prev();
    if( vert == NULL ) return;
    assert( vert->param[0] >= uarray.uarray[gv.gparam[0]]  );

    if( gv.nextu() >= top.uend ) {
	for( ; vert; vert = right.prev() ) {
	    backend.swaptmesh();
	    output( vert );
	}
    } else while( 1 ) {
        if( vert->param[0] < uarray.uarray[gv.gparam[0]]  ) {
	    backend.swaptmesh();
	    output( vert );
	    vert = right.prev();
	    if( vert == NULL ) break;
	} else {
	    output( gv );
	    backend.swaptmesh();
	    if( gv.nextu() == top.uend ) {
    		for( ; vert; vert = right.prev() ) {
		    backend.swaptmesh();
		    output( vert );
    		}
	        break;
	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\curve.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curve.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mymath.h"
#include "curve.h"
#include "mapdesc.h"
#include "types.h"
#include "quilt.h"
#include "nurbscon.h"

/*--------------------------------------------------------------------------
 * Curve::Curve - copy curve from quilt and transform control points
 *--------------------------------------------------------------------------
 */

Curve::Curve( Quilt_ptr geo, REAL pta, REAL ptb, Curve *c )
{
    mapdesc = geo->mapdesc;
    next = c;
    needsSampling = mapdesc->isRangeSampling() ? 1 : 0;
    cullval = mapdesc->isCulling() ? CULL_ACCEPT : CULL_TRIVIAL_ACCEPT;
    order = geo->qspec[0].order;
    stride = MAXCOORDS;

    REAL *ps  = geo->cpts; 
    Quiltspec_ptr qs = geo->qspec;
    ps += qs->offset;
    ps += qs->index * qs->order * qs->stride;
    REAL *pend = ps + qs->order * qs->stride;

    if( needsSampling )
	mapdesc->xformSampling( ps, qs->order, qs->stride, spts, stride );
	
    if( cullval == CULL_ACCEPT )
	mapdesc->xformCulling(  ps, qs->order, qs->stride, cpts, stride );

    /* set untrimmed curve range */
    range[0] = qs->breakpoints[qs->index];
    range[1] = qs->breakpoints[qs->index+1];
    range[2] = range[1] - range[0];

    if( range[0] != pta ) {
	Curve lower( *this, pta, 0 );
	lower.next = next;
	*this = lower;
    }
    if( range[1] != ptb ) {
	Curve lower( *this, ptb, 0 );
    }
}

/*--------------------------------------------------------------------------
 * Curve::Curve - subdivide a curve along an isoparametric line
 *--------------------------------------------------------------------------
 */

Curve::Curve( Curve& upper, REAL value, Curve *c )
{
    Curve &lower = *this;

    lower.next = c;
    lower.mapdesc = upper.mapdesc;
    lower.needsSampling = upper.needsSampling;
    lower.order = upper.order;
    lower.stride = upper.stride;
    lower.cullval = upper.cullval;

    REAL d = (value - upper.range[0]) / upper.range[2];

    if( needsSampling )
        mapdesc->subdivide( upper.spts, lower.spts, d, upper.stride, upper.order );

    if( cullval == CULL_ACCEPT ) 
        mapdesc->subdivide( upper.cpts, lower.cpts, d, upper.stride, upper.order );

    lower.range[0] = upper.range[0];
    lower.range[1] = value;
    lower.range[2] = value - upper.range[0];
    upper.range[0] = value;
    upper.range[2] = upper.range[1] - value;
}


/*--------------------------------------------------------------------------
 * Curve::clamp - clamp the sampling rate to a given maximum
 *--------------------------------------------------------------------------
 */

void
Curve::clamp( void )
{
    if( stepsize < minstepsize )
        stepsize = mapdesc->clampfactor * minstepsize;
}

void
Curve::setstepsize( REAL max )
{
    stepsize = ( max >= 1.0 ) ? (range[2] / max) : range[2];
    minstepsize = stepsize;
}

void
Curve::getstepsize( void )
{
    minstepsize= 0;

    if( mapdesc->isConstantSampling() ) {
	// fixed number of samples per patch in each direction
	// maxrate is number of s samples per patch
        setstepsize( mapdesc->maxrate );
    } else if( mapdesc->isDomainSampling() ) {
	// maxrate is number of s samples per unit s length of domain
        setstepsize( mapdesc->maxrate * range[2] );
    } else {
	// upper bound on path length between sample points

	assert( order <= MAXORDER );
    
	/* points have been transformed, therefore they are homogeneous */
        REAL tmp[MAXORDER][MAXCOORDS];
	const int tstride = sizeof(tmp[0]) / sizeof(REAL);
	int val = mapdesc->project( spts, stride, &tmp[0][0], tstride,  order ); 

        if( val == 0 ) {
	    // control points cross infinity, therefore derivatives are undefined
            setstepsize( mapdesc->maxrate );
        } else {
            REAL t = mapdesc->getProperty( N_PIXEL_TOLERANCE );
	    if( mapdesc->isParametricDistanceSampling() ) {
		REAL d = mapdesc->calcPartialVelocity( &tmp[0][0], tstride, order, 2, range[2] );
		stepsize = (d > 0.0) ? ::sqrtf( 8.0 * t / d ) : range[2];
		minstepsize = ( mapdesc->maxrate > 0.0 ) ? (range[2] / mapdesc->maxrate) : 0.0;
	    } else if( mapdesc->isPathLengthSampling() ) {
		// t is upper bound on path (arc) length
		REAL d = mapdesc->calcPartialVelocity( &tmp[0][0], tstride, order, 1, range[2] );
		stepsize = ( d > 0.0 ) ? (t / d) : range[2];
		minstepsize = ( mapdesc->maxrate > 0.0 ) ? (range[2] / mapdesc->maxrate) : 0.0;
	    } else {
		// control points cross infinity, therefore partials are undefined
		setstepsize( mapdesc->maxrate );
	    }
	}
    }
}

int
Curve::needsSamplingSubdivision( void )
{
    return ( stepsize < minstepsize )  ? 1 : 0;
}

int
Curve::cullCheck( void )
{
    if( cullval == CULL_ACCEPT ) 
	cullval = mapdesc->cullCheck( cpts, order, stride );
    return cullval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\curvelis.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curvelist.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "quilt.h"
#include "curvelis.h"
#include "curve.h"
#include "nurbscon.h"
#include "types.h"

Curvelist::Curvelist( Quilt *quilts, REAL pta, REAL ptb )
{
    curve = 0;
    for( Quilt *q = quilts; q; q = q->next ) 
	curve = new Curve( q, pta, ptb, curve );
    range[0] = pta;
    range[1] = ptb;
    range[2] = ptb - pta;
}

Curvelist::Curvelist( Curvelist &upper, REAL value )
{
    Curvelist &lower = *this;
    curve = 0;
    for( Curve *c = upper.curve; c; c = c->next )
	curve = new Curve( *c, value, curve );

    lower.range[0] = upper.range[0];
    lower.range[1] = value;
    lower.range[2] = value - upper.range[0];
    upper.range[0] = value;
    upper.range[2] = upper.range[1] - value;
}

Curvelist::~Curvelist()
{
    while( curve ) {
	Curve *c = curve;
	curve = curve->next;
	delete c;
    }
}

int
Curvelist::cullCheck( void )
{
    for( Curve *c = curve; c; c = c->next )
	if( c->cullCheck() == CULL_TRIVIAL_REJECT )
	    return CULL_TRIVIAL_REJECT;
    return CULL_ACCEPT;
}

void
Curvelist::getstepsize( void )
{
    stepsize = range[2];
    for( Curve *c = curve; c; c = c->next ) {
	c->getstepsize();
	c->clamp();
	stepsize =  ((c->stepsize < stepsize) ? c->stepsize : stepsize);
	if( c->needsSamplingSubdivision() ) break;
    }
    needsSubdivision = ( c ) ? 1 : 0;
}

int
Curvelist::needsSamplingSubdivision( void )
{
    return needsSubdivision;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\coveandt.h ===
#ifndef __glucoveandtiler_h
#define __glucoveandtiler_h

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * coveandtiler.h - $Revision: 1.1 $
 */

#include "trimregi.h"

class Backend;
class TrimVertex;
class GridVertex;
class GridTrimVertex;

class CoveAndTiler : virtual public TrimRegion {
public:
    			CoveAndTiler( Backend& );
    			~CoveAndTiler( void );
    void 		coveAndTile( void );
private:
    Backend&		backend;
    static const int 	MAXSTRIPSIZE;
    void		tile( long, long, long );
    void		coveLowerLeft( void );
    void		coveLowerRight( void );
    void		coveUpperLeft( void );
    void		coveUpperRight( void );
    void		coveUpperLeftNoGrid( TrimVertex * );
    void		coveUpperRightNoGrid( TrimVertex * );
    void		coveLowerLeftNoGrid( TrimVertex * );
    void		coveLowerRightNoGrid( TrimVertex * );
    void		coveLL( void );
    void		coveLR( void );
    void		coveUL( void );
    void		coveUR( void );
    inline void		output( GridTrimVertex& );
    inline void		output( GridVertex& );
    inline void		output( TrimVertex* );
};

#endif /* __glucoveandtiler_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\curvelis.h ===
#ifndef __glucurvelist_h_
#define __glucurvelist_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curvelist.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"

class Mapdesc;
class Quilt;
class Curve;

class Curvelist 
{
friend class Subdivider;
public:
			Curvelist( Quilt *, REAL, REAL );
    			Curvelist( Curvelist &, REAL );
			~Curvelist( void );
    int			cullCheck( void );
    void		getstepsize( void );
    int			needsSamplingSubdivision();
private:
    Curve		*curve;
    float		range[3];
    int			needsSubdivision;
    float		stepsize;
};
#endif /* __glucurvelist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\curvesub.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curvesub.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "subdivid.h"
#include "renderhi.h"
#include "backend.h"
#include "quilt.h"
#include "curvelis.h"
#include "curve.h"
#include "nurbscon.h"

/*--------------------------------------------------------------------------
 * drawCurves - main curve rendering entry point
 *--------------------------------------------------------------------------
 */

void
Subdivider::drawCurves( void )
{
    REAL 	from[1], to[1];
    Flist	bpts;
    qlist->getRange( from, to, bpts );

    renderhints.init( );

    backend.bgncurv();
    for( int i=bpts.start; i<bpts.end-1; i++ ) {
        REAL pta, ptb;
	pta = bpts.pts[i];
	ptb = bpts.pts[i+1];

	qlist->downloadAll( &pta, &ptb, backend );

	Curvelist curvelist( qlist, pta, ptb );
	samplingSplit( curvelist, renderhints.maxsubdivisions );
    }
    backend.endcurv();
}


/*--------------------------------------------------------------------------
 * samplingSplit - recursively subdivide patch, cull check each subpatch  
 *--------------------------------------------------------------------------
 */

void
Subdivider::samplingSplit( Curvelist& curvelist, int subdivisions )
{
    if( curvelist.cullCheck() == CULL_TRIVIAL_REJECT )  return;

    curvelist.getstepsize();

    if( curvelist.needsSamplingSubdivision() && (subdivisions > 0) ) {
	REAL mid = ( curvelist.range[0] + curvelist.range[1] ) * 0.5;
	Curvelist lowerlist( curvelist, mid );
	samplingSplit( lowerlist, subdivisions-1 ); // lower
	samplingSplit( curvelist, subdivisions-1 ); // upper
    } else {
	long nu = 1 + ((long) (curvelist.range[2] / curvelist.stepsize));
	backend.curvgrid( curvelist.range[0], curvelist.range[1], nu );
	backend.curvmesh( 0, nu );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\displayl.h ===
#ifndef __gludisplaylist_h_
#define __gludisplaylist_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * displaylist.h - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mysetjmp.h"
#include "mystdio.h"
#include "bufpool.h"

class NurbsTessellator;

typedef void (NurbsTessellator::*PFVS)( void * );

struct Dlnode : public PooledObj {
    			Dlnode( PFVS, void *, PFVS );
    PFVS		work;
    void *		arg;
    PFVS		cleanup;
    Dlnode *		next;
};

inline
Dlnode::Dlnode( PFVS _work, void *_arg, PFVS _cleanup ) 
{
    work = _work;
    arg = _arg;
    cleanup = _cleanup;
}

class DisplayList {
public:
			DisplayList( NurbsTessellator * );
			~DisplayList( void );
    void		play( void );
    void		append( PFVS work, void *arg, PFVS cleanup );
    void		endList( void );
private:
    Dlnode 		*nodes;
    Pool		dlnodePool;
    Dlnode		**lastNode;
    NurbsTessellator 	*nt;
};

#endif /* __gludisplaylist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\defines.h ===
#ifndef __gludefines_h_
#define __gludefines_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * defines.h - $Revision: 1.1 $
 */

/* culling constants */
#define CULL_TRIVIAL_REJECT	0
#define CULL_TRIVIAL_ACCEPT	1
#define CULL_ACCEPT		2

/* maximum order of a B-Spline */ 
#define	MAXORDER 	24

/* maximum dimension of any B-spline range space  */
#define MAXCOORDS	5

#endif /* __gludefines_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\flist.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flist.c++ - $Revision: 1.3 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "flist.h"

/*----------------------------------------------------------------------------
 * Flist::Flist - initialize a REAL number array
 *----------------------------------------------------------------------------
 */
Flist::Flist( void )
{
    npts = 0;
    pts = 0;
    start = end = 0;
}

/*----------------------------------------------------------------------------
 * Flist::~Flist - free a REAL number array
 *----------------------------------------------------------------------------
 */
Flist::~Flist( void )
{
    if( npts ) delete[] pts;
}

void
Flist::add( REAL x )
{
    pts[end++] = x;
    assert( end <= npts );
}

/*----------------------------------------------------------------------------
 * Flist::filter - remove duplicate numbers from array
 *----------------------------------------------------------------------------
 */
void Flist::filter( void )
{
    sorter.qsort( pts, end );
    start = 0;

    int j = 0;
    for( int i = 1; i < end; i++ ) { 
	if( pts[i] == pts[i-j-1] )
	    j++;
	pts[i-j] = pts[i];
    }
    end -= j;
}

/*----------------------------------------------------------------------------
 * Flist::grow - ensure that array is large enough
 *----------------------------------------------------------------------------
 */
void Flist::grow( int maxpts )
{
    if( npts < maxpts ) {
	if( npts ) delete[] pts;
	npts = 2 * maxpts; 
	pts = new REAL[npts];
	assert( pts != 0 );
    }
    start = end = 0;
}

/*----------------------------------------------------------------------------
 * Flist::taper - ignore head and tail of array
 *----------------------------------------------------------------------------
 */
void Flist::taper( REAL from, REAL to )
{
    while( pts[start] != from )
	start++;

    while( pts[end-1] != to )
	end--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\displaym.h ===
#ifndef __gludisplaymode_h_
#define __gludisplaymode_h_

#define N_MESHFILL	0
#define N_MESHLINE	1
#define N_MESHPOINT	2

#endif /* __gludisplaymode_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\flistsor.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flistsorter.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "flistsor.h"

FlistSorter::FlistSorter( void ) : Sorter( sizeof( REAL ) )
{
}

void
FlistSorter::qsort( REAL *p, int n )
{
    Sorter::qsort( (char *)p, n );
}

int
FlistSorter::qscmp( char *i, char *j )
{
    REAL f0 = *(REAL *)i;
    REAL f1 = *(REAL *)j;
    return (f0 < f1) ? -1 : 1;
}

void
FlistSorter::qsexc( char *i, char *j )
{
    REAL *f0 = (REAL *)i;
    REAL *f1 = (REAL *)j;
    REAL tmp = *f0;
    *f0 = *f1;
    *f1 = tmp;
}

void
FlistSorter::qstexc( char *i, char *j, char *k )
{
    REAL *f0 = (REAL *)i;
    REAL *f1 = (REAL *)j;
    REAL *f2 = (REAL *)k;
    REAL tmp = *f0;
    *f0 = *f2;
    *f2 = *f1;
    *f1 = tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\flist.h ===
#ifndef __gluflist_h_
#define __gluflist_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flist.h - $Revision: 1.1 $
 */

#include "types.h"
#include "flistsor.h"

class Flist {
public:
    REAL *		pts;		/* head of array */
    int			npts;		/* number of points in array */
    int			start;		/* first important point index */
    int			end;		/* last important point index */

    			Flist( void );
    			~Flist( void );
    void		add( REAL x );
    void		filter( void );
    void		grow( int);
    void		taper( REAL , REAL );
protected:
    FlistSorter 	sorter;
};

#endif /* __gluflist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\displayl.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * displaylist.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "nurbstes.h"
#include "displayl.h"


DisplayList::DisplayList( NurbsTessellator  *_nt ) :
	dlnodePool( sizeof( Dlnode ), 1, "dlnodepool" )
{
    lastNode = &nodes;
    nt = _nt;
}

DisplayList::~DisplayList( void ) 
{
    for( Dlnode *nextNode; nodes; nodes = nextNode ) {
	nextNode = nodes->next;
	if( nodes->cleanup != 0 ) (nt->*nodes->cleanup)( nodes->arg );
	//nodes->deleteMe(dlnodePool);
    }
}

void 
DisplayList::play( void )
{
    for( Dlnode *node = nodes; node; node = node->next ) 
	if( node->work != 0 ) (nt->*node->work)( node->arg );
}

void 
DisplayList::endList( void )
{
    *lastNode = 0;
}

void 
DisplayList::append( PFVS work, void *arg, PFVS cleanup )
{
    Dlnode *node = new(dlnodePool) Dlnode( work, arg, cleanup );
    *lastNode = node;
    lastNode = &(node->next);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\glimport.h ===
#ifndef __gluimports_h_
#define __gluimports_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glimports.h - $Revision: 1.1 $
 */

#ifdef NT
#include <glos.h>
#include "windows.h"
#else
#include "mystdlib.h"
#include "mystdio.h"
#endif

#ifdef NT
extern "C" DWORD gluMemoryAllocationFailed;
inline void * GLOS_CCALL
operator new( size_t s )
{
    void *p = (void *) LocalAlloc(LMEM_FIXED, s);

    if( p ) {
	return p;
    } else {
        gluMemoryAllocationFailed++;
#ifndef NDEBUG
        MessageBoxA(NULL, "LocalAlloc failed\n", "ERROR", MB_OK);
#endif
	return p;
    }
}

inline void GLOS_CCALL
operator delete( void *p )
{
    if (p) LocalFree(p);
}

#else

operator new( size_t s )
{
    void *p = malloc( s );

    if( p ) {
	return p;
    } else {
        dprintf( "malloc failed\n" );
	return p;
    }
}

inline void
operator delete( void *p )
{
    if( p ) free( p );
}

#endif // NT
#endif /* __gluimports_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\flistsor.h ===
#ifndef __gluflistsorter_h_
#define __gluflistsorter_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flistsorter.h - $Revision: 1.1 $
 */

#include "sorter.h"
#include "types.h"

class FlistSorter : public Sorter {
public:
			FlistSorter(void);
    void		qsort( REAL *a, int n );

protected:	
    virtual int		qscmp( char *, char * );
    virtual void	qsexc( char *i, char *j );	// i<-j, j<-i 
    virtual void	qstexc( char *i, char *j, char *k ); // i<-k, k<-j, j<-i 
};
#endif /* __gluflistsorter_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\gridvert.h ===
#ifndef __glugridvertex_h_
#define __glugridvertex_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * gridvertex.h - $Revision: 1.1 $
 */

#ifdef NT
class GridVertex { public:
#else
struct GridVertex {
#endif
    long 		gparam[2];
			GridVertex( void ) {}
			GridVertex( long u, long v ) { gparam[0] = u, gparam[1] = v; }
    void		set( long u, long v ) { gparam[0] = u, gparam[1] = v; }
    long		nextu() { return gparam[0]++; }
    long		prevu() { return gparam[0]--; }
};

#endif /* __glugridvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\gridline.h ===
#ifndef __glugridline_h_
#define __glugridline_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * gridline.h - $Revision: 1.1 $
 */

#ifdef NT
class Gridline {
public:
#else
struct Gridline {
#endif
    long 		v;
    REAL		vval;
    long		vindex;
    long 		ustart;
    long 		uend;
 };
#endif /* __glugridline_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\hull.h ===
#ifndef __gluhull_h_
#define __gluhull_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * hull.h - $Revision: 1.1 $
 */

#include "trimline.h"
#include "trimregi.h"

class GridTrimVertex;
class Gridline;
class Uarray;

class Hull : virtual public TrimRegion {
public:
    			Hull( void );
    			~Hull( void );
    void		init( void );
    GridTrimVertex *	nextlower( GridTrimVertex * );
    GridTrimVertex *	nextupper( GridTrimVertex * );
private:
    struct Side {
	Trimline 	*left;
	Gridline     	*line;
	Trimline 	*right;
	long 		index;
    };
	
    Side 		lower;
    Side		upper;
    Trimline 		fakeleft;
    Trimline		fakeright;
};


#endif /* __gluhull_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\gridtrim.h ===
#ifndef __glugridtrimvertex_h_
#define __glugridtrimvertex_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * gridtrimvertex.h - $Revision: 1.1 $
 */

#include "mystdlib.h"
#include "bufpool.h"
#include "trimvert.h"
#include "gridvert.h"

class GridTrimVertex : public PooledObj
{
private:
    TrimVertex	dummyt;
    GridVertex	dummyg;
public:
			GridTrimVertex() { g = 0; t = 0; }
    TrimVertex	*t;
    GridVertex	*g;
   
    inline void		set( long, long );
    inline void		set( REAL, REAL );
    inline void		set( TrimVertex * );
    inline void		clear( void ) { t = 0; g = 0; };
    inline int		isGridVert() { return g ? 1 : 0 ; }
    inline int		isTrimVert() { return t ? 1 : 0 ; }
    inline void		output();
};

inline void
GridTrimVertex::set( long x, long y )
{
    g = &dummyg;
    dummyg.gparam[0] = x;
    dummyg.gparam[1] = y;
}

inline void
GridTrimVertex::set( REAL x, REAL y )
{
    g = 0;
    t = &dummyt;
    dummyt.param[0] = x;
    dummyt.param[1] = y;
    dummyt.nuid = 0;
}

inline void
GridTrimVertex::set( TrimVertex *v )
{
    g = 0;
    t = v;
}

typedef GridTrimVertex *GridTrimVertex_p;
#endif /* __glugridtrimvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\intersec.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * intersect.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "subdivid.h"
#include "arc.h"
#include "bin.h"
#include "backend.h"
#include "trimpool.h"

enum i_result { INTERSECT_VERTEX, INTERSECT_EDGE };

/* local functions */
static int		arc_classify( Arc_ptr, int, REAL );
static enum i_result	pwlarc_intersect( PwlArc *, int, REAL, int, int[3] );


void
Subdivider::partition( Bin & bin, Bin & left, Bin & intersections, 
	        Bin & right, Bin & unknown, int param, REAL value )
{
    Bin	headonleft, headonright, tailonleft, tailonright;

    for( Arc_ptr jarc = bin.removearc(); jarc; jarc = bin.removearc() ) {

	REAL tdiff = jarc->tail()[param] - value;
	REAL hdiff = jarc->head()[param] - value;
    
	if( tdiff > 0.0 ) {
	    if( hdiff > 0.0 ) {
		right.addarc( jarc  );
	    } else if( hdiff == 0.0 ) {
		tailonright.addarc( jarc  );
	    } else {
	        Arc_ptr	jtemp;
		switch( arc_split(jarc, param, value, 0) ) {
		    case 2:
			tailonright.addarc( jarc  );
			headonleft.addarc( jarc->next  );
			break;
		    case 31:
			assert( jarc->head()[param] > value );
			right.addarc( jarc  );
			tailonright.addarc( jtemp = jarc->next  );
			headonleft.addarc( jtemp->next  );
		        break;
		    case 32:
			assert( jarc->head()[param] <= value );
			tailonright .addarc( jarc  );
			headonleft.addarc( jtemp = jarc->next  );
			left.addarc( jtemp->next  );
			break;
		    case 4:
			right.addarc( jarc  );
			tailonright.addarc( jtemp = jarc->next  );
			headonleft.addarc( jtemp = jtemp->next  );
			left.addarc( jtemp->next  );
		}
	    }
	} else if( tdiff == 0.0 ) {
	    if( hdiff > 0.0 ) {
		headonright.addarc( jarc  );
	    } else if( hdiff == 0.0 ) {
		unknown.addarc( jarc  );
	    } else {
		headonleft.addarc( jarc  );
	    }
	} else {
	    if( hdiff > 0.0 ) {
	        Arc_ptr	jtemp;
		switch( arc_split(jarc, param, value, 1) ) {
		    case 2:
			tailonleft.addarc( jarc  );
			headonright.addarc( jarc->next  );
			break;
		    case 31:
			assert( jarc->head()[param] < value );
			left.addarc( jarc  );
			tailonleft.addarc( jtemp = jarc->next  );
			headonright.addarc( jtemp->next  );
			break;
		    case 32:
			assert( jarc->head()[param] >= value );
			tailonleft.addarc( jarc  );
			headonright.addarc( jtemp = jarc->next  );
			right.addarc( jtemp->next  );
			break;
		    case 4:
			left.addarc( jarc  );
			tailonleft.addarc( jtemp = jarc->next  );
			headonright.addarc( jtemp = jtemp->next  );
			right.addarc( jtemp->next  );
		}
	    } else if( hdiff == 0.0 ) {
		tailonleft.addarc( jarc  );
	    } else {
		left.addarc( jarc  );
	    }
	}
    }
    if( param == 0 ) {
	classify_headonleft_s( headonleft, intersections, left, value );
	classify_tailonleft_s( tailonleft, intersections, left, value );
	classify_headonright_s( headonright, intersections, right, value );
	classify_tailonright_s( tailonright, intersections, right, value );
    } else {
	classify_headonleft_t( headonleft, intersections, left, value );
	classify_tailonleft_t( tailonleft, intersections, left, value );
	classify_headonright_t( headonright, intersections, right, value );
	classify_tailonright_t( tailonright, intersections, right, value );
    }
}

inline static void 
vert_interp( TrimVertex *n, TrimVertex *l, TrimVertex *r, int p, REAL val )
{
    assert( val > l->param[p]);
    assert( val < r->param[p]);

    n->nuid = l->nuid;

    n->param[p] = val;
    if( l->param[1-p] != r->param[1-p]  ) {
	REAL ratio = (val - l->param[p]) / (r->param[p] - l->param[p]);
	n->param[1-p] = l->param[1-p] + 
		        ratio * (r->param[1-p] - l->param[1-p]);
    } else {
	n->param[1-p] = l->param[1-p];
    }
}
	
int
Subdivider::arc_split( Arc_ptr jarc, int param, REAL value, int dir )
{
    int		maxvertex = jarc->pwlArc->npts;
    Arc_ptr	jarc1, jarc2, jarc3;
    TrimVertex* v = jarc->pwlArc->pts;

    int		loc[3];
    switch( pwlarc_intersect( jarc->pwlArc, param, value, dir, loc ) ) {

    case INTERSECT_VERTEX: {
	    jarc1 = new(arcpool) Arc( jarc, new( pwlarcpool) PwlArc( maxvertex-loc[1], &v[loc[1]] ) );
	    jarc->pwlArc->npts = loc[1] + 1;
	    jarc1->next = jarc->next;
	    jarc1->next->prev = jarc1;
	    jarc->next = jarc1;
	    jarc1->prev = jarc;
	    assert(jarc->check() != 0);
	    return 2;
	}

    case INTERSECT_EDGE: {
	    int i, j;
	    if( dir == 0 ) {
		i = loc[0];
		j = loc[2];
	    } else {
		i = loc[2];
		j = loc[0];
	    }

	    TrimVertex *newjunk = trimvertexpool.get(3);
	    v[i].nuid = jarc->nuid;
	    v[j].nuid = jarc->nuid;
	    newjunk[0] = v[j];
	    newjunk[2] = v[i];
	    vert_interp( &newjunk[1], &v[loc[0]], &v[loc[2]], param, value );

	    if( showingDegenerate() )
		backend.triangle( &newjunk[2], &newjunk[1], &newjunk[0] );

	    if (maxvertex == 2) {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc->pwlArc->npts = 2;
		jarc->pwlArc->pts = newjunk;
		jarc1->next = jarc->next;
		jarc1->next->prev = jarc1;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		assert(jarc->check() != 0);
		return 2;
	    } else if (maxvertex - j == 2) {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk ) );
		jarc2 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc->pwlArc->npts = maxvertex-1;
		jarc2->next = jarc->next;
		jarc2->next->prev = jarc2;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		jarc1->next = jarc2;
		jarc2->prev = jarc1;
		assert(jarc->check() != 0);
		return 31;
	    } else if (i == 1) {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc2 = new(arcpool) Arc( jarc, 
			new(pwlarcpool) PwlArc( maxvertex-1, &jarc->pwlArc->pts[1] ) );
		jarc->pwlArc->npts = 2;
		jarc->pwlArc->pts = newjunk;
		jarc2->next = jarc->next;
		jarc2->next->prev = jarc2;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		jarc1->next = jarc2;
		jarc2->prev = jarc1;
		assert(jarc->check() != 0);
		return 32;
	    } else {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk ) );
		jarc2 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc3 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( maxvertex-i, v+i ) );
		jarc->pwlArc->npts = j + 1;
		jarc3->next = jarc->next;
		jarc3->next->prev = jarc3;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		jarc1->next = jarc2;
		jarc2->prev = jarc1;
		jarc2->next = jarc3;
		jarc3->prev = jarc2;
		assert(jarc->check() != 0);
		return 4;
	    }
	}
	default:
	return -1; //picked -1 since it's not used
    }
}

/*----------------------------------------------------------------------------
 * pwlarc_intersect -  find intersection of pwlArc and isoparametric line
 *----------------------------------------------------------------------------
 */

static enum i_result
pwlarc_intersect(
    PwlArc *pwlArc,
    int param,
    REAL value,
    int dir,
    int loc[3] )
{
    assert( pwlArc->npts > 0 );

    if( dir ) {
	TrimVertex *v = pwlArc->pts;
	int imin = 0; 
	int imax = pwlArc->npts - 1;
	assert( value > v[imin].param[param] );
	assert( value < v[imax].param[param] );	
	while( (imax - imin) > 1 ) {
	    int imid = (imax + imin)/2;
	    if( v[imid].param[param] > value )
		imax = imid;
	    else if( v[imid].param[param] < value )
		imin = imid;
	    else {
		loc[1] = imid;
		return INTERSECT_VERTEX;
	    }
	}
	loc[0] = imin;
	loc[2] = imax;
	return INTERSECT_EDGE;
    } else {
	TrimVertex *v = pwlArc->pts;
	int imax = 0; 
	int imin = pwlArc->npts - 1;
	assert( value > v[imin].param[param] );
	assert( value < v[imax].param[param] );	
	while( (imin - imax) > 1 ) {
	    int imid = (imax + imin)/2;
	    if( v[imid].param[param] > value )
		imax = imid;
	    else if( v[imid].param[param] < value )
		imin = imid;
	    else {
		loc[1] = imid;
		return INTERSECT_VERTEX;
	    }
	}
	loc[0] = imin;
	loc[2] = imax;
	return INTERSECT_EDGE;
    }
}

/*----------------------------------------------------------------------------
 * arc_classify - determine which side of a line a jarc lies 
 *----------------------------------------------------------------------------
 */

static int
arc_classify( Arc_ptr jarc, int param, REAL value )
{
    REAL tdiff, hdiff;
    if( param == 0 ) {
	tdiff = jarc->tail()[0] - value;
	hdiff = jarc->head()[0] - value;
    } else {
	tdiff = jarc->tail()[1] - value;
	hdiff = jarc->head()[1] - value;
    }

    if( tdiff > 0.0 ) {
	if( hdiff > 0.0 ) {
	    return 0x11;
	} else if( hdiff == 0.0 ) {
	    return 0x12;
	} else {
	    return 0x10;
	}
    } else if( tdiff == 0.0 ) {
	if( hdiff > 0.0 ) {
	    return 0x21;
	} else if( hdiff == 0.0 ) {
	    return 0x22;
	} else {
	    return 0x20;
	}
    } else {
	if( hdiff > 0.0 ) {
	    return 0x01;
	} else if( hdiff == 0.0 ) {
	    return 0x02;
	} else {
	    return 0;
	}
    }
}

void
Subdivider::classify_tailonleft_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at left, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x02 );
	j->clearitail();

	REAL diff = j->next->head()[0] - val;
	if( diff > 0.0 ) {
	    in.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_sl( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if( j->next->tail()[1] > j->next->head()[1] ) 
		in.addarc(j);
	    else
		out.addarc(j);
	}
    }
}

void
Subdivider::classify_tailonleft_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at left, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x02 );
	j->clearitail();

        REAL diff = j->next->head()[1] - val;
	if( diff > 0.0 ) {
	    in.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_tl( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if (j->next->tail()[0] > j->next->head()[0] )
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}

void
Subdivider::classify_headonleft_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at left */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x20 );

	j->setitail();

	REAL diff = j->prev->tail()[0] - val;
	if( diff > 0.0 ) {
	    out.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_sl( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if( j->prev->tail()[1] > j->prev->head()[1] )
		in.addarc( j );
	    else
		out.addarc( j );
	}
    }
}

void
Subdivider::classify_headonleft_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at left */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x20 );
	j->setitail();

	REAL diff = j->prev->tail()[1] - val;
	if( diff > 0.0 ) {
	    out.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_tl( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if( j->prev->tail()[0] > j->prev->head()[0] )
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}


void
Subdivider::classify_tailonright_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at right, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x12);
	
	j->clearitail();

        REAL diff = j->next->head()[0] - val;
	if( diff > 0.0 ) {
	    if( ccwTurn_sr( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) {
	    in.addarc( j );
	} else {
	    if( j->next->tail()[1] > j->next->head()[1] ) 
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}

void
Subdivider::classify_tailonright_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at right, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x12);
	
	j->clearitail();

	REAL diff =  j->next->head()[1] - val;
	if( diff > 0.0 ) {
	    if( ccwTurn_tr( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) { 
	    in.addarc( j );
	} else {
	    if( j->next->tail()[0] > j->next->head()[0] ) 
		in.addarc( j );
	    else
		out.addarc( j );
	}
    }
}

void
Subdivider::classify_headonright_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at right */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x21 );
    
	j->setitail();

        REAL diff = j->prev->tail()[0] - val;
	if( diff > 0.0 ) { 
	    if( ccwTurn_sr( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) {
	    out.addarc( j );
	} else {
	    if( j->prev->tail()[1] > j->prev->head()[1] )
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}

void
Subdivider::classify_headonright_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at right */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x21 );
    
	j->setitail();

        REAL diff = j->prev->tail()[1] - val;
	if( diff > 0.0 ) { 
	    if( ccwTurn_tr( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) {
	    out.addarc( j );
	} else {
	    if( j->prev->tail()[0] > j->prev->head()[0] )
		in.addarc( j );
	    else
		out.addarc( j );
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\hull.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * hull.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "hull.h"
#include "gridvert.h"
#include "gridtrim.h"
#include "gridline.h"
#include "trimline.h"
#include "uarray.h"
#include "trimregi.h"

Hull::Hull( void )
{}

Hull::~Hull( void )
{}

/*----------------------------------------------------------------------
 * Hull:init - this routine does the initialization needed before any
 *	 	calls to nextupper or nextlower can be made.
 *----------------------------------------------------------------------
 */
void
Hull::init( void )
{
    TrimVertex *lfirst = left.first();
    TrimVertex *llast = left.last();
    if( lfirst->param[0] <= llast->param[0] ) {
	fakeleft.init( left.first() );
	upper.left = &fakeleft;
	lower.left = &left;
    } else {
	fakeleft.init( left.last() );
	lower.left = &fakeleft;
 	upper.left = &left;
    }
    upper.left->last();
    lower.left->first();

    if( top.ustart <= top.uend ) {
	upper.line = &top;
	upper.index = top.ustart;
    } else
	upper.line = 0;

    if( bot.ustart <= bot.uend ) {
	lower.line = &bot;
	lower.index = bot.ustart;
    } else
	lower.line = 0;

    TrimVertex *rfirst = right.first();
    TrimVertex *rlast = right.last();
    if( rfirst->param[0] <= rlast->param[0] ) {
	fakeright.init( right.last() );
	lower.right = &fakeright;
	upper.right = &right;
    } else {
	fakeright.init( right.first() );
	upper.right = &fakeright;
	lower.right = &right;
    }
    upper.right->first();
    lower.right->last();
}

/*----------------------------------------------------------------------
 * nextupper - find next vertex on upper hull of trim region.
 *		 - if vertex is on trim curve, set vtop point to 
 *		   that vertex.  if vertex is on grid, set vtop to
 *		   point to temporary area and stuff coordinants into
 *		   temporary vertex.  Also, place grid coords in temporary
 *		   grid vertex.
 *----------------------------------------------------------------------
 */
GridTrimVertex *
Hull::nextupper( GridTrimVertex *gv )
{
    if( upper.left ) {
	gv->set( upper.left->prev() );
	if( gv->isTrimVert() ) return gv;
	upper.left = 0;
    } 

    if( upper.line ) {
	assert( upper.index <= upper.line->uend );
	gv->set( uarray.uarray[upper.index], upper.line->vval );
	gv->set( upper.index, upper.line->vindex );
	if( upper.index++ == upper.line->uend ) upper.line = 0;
	return gv; 
    } 

    if( upper.right ) {
	gv->set( upper.right->next() );
	if( gv->isTrimVert() ) return gv;
	upper.right = 0;
    } 

    return 0; 
}

GridTrimVertex *
Hull::nextlower( register GridTrimVertex *gv )
{
    if( lower.left ) {
	gv->set( lower.left->next() );
	if( gv->isTrimVert() ) return gv;
	lower.left = 0;
    } 

    if( lower.line ) {
	gv->set( uarray.uarray[lower.index], lower.line->vval );
	gv->set( lower.index, lower.line->vindex );
	if( lower.index++ == lower.line->uend ) lower.line = 0;
	return gv;
    } 

    if( lower.right ) {
	gv->set( lower.right->prev() );
	if( gv->isTrimVert() ) return gv;
	lower.right = 0;
    } 

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\knot.h ===
#ifndef __gluknot_h_
#define __gluknot_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * knot.h - $Revision: 1.1 $
 */

#include "types.h"

typedef	REAL		Knot, *Knot_ptr;/* knot values */
#endif /* __gluknot_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\jarcloc.h ===
#ifndef __glujarcloc_h_
#define __glujarcloc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * jarcloc.h - $Revision: 1.1 $
 */

#include "arc.h"

class Jarcloc {
private:
    Arc * 		arc;
    TrimVertex		*p;
    TrimVertex		*plast;
public:
    inline void		init( Arc_ptr a, long first, long last ) { arc = a; p=&a->pwlArc->pts[first]; plast = &a->pwlArc->pts[last]; }
    inline TrimVertex *	getnextpt( void );
    inline TrimVertex *	getprevpt( void );
    inline void		reverse();
};

inline void
Jarcloc::reverse()
{
    if( plast == &arc->pwlArc->pts[0] )
	plast =  &arc->pwlArc->pts[arc->pwlArc->npts - 1];
    else
	plast =  &arc->pwlArc->pts[0];
}

inline TrimVertex *
Jarcloc::getnextpt()
{
    assert( p <= plast );
    if( p == plast ) {
	arc = arc->next;
	p = &arc->pwlArc->pts[0];
	plast = &arc->pwlArc->pts[arc->pwlArc->npts - 1];
	assert( p < plast );
    }
    return p++;
}
	
inline TrimVertex *
Jarcloc::getprevpt()
{
    assert( p >= plast );
    if( p == plast ) {
	arc = arc->prev;
	p = &arc->pwlArc->pts[arc->pwlArc->npts - 1];
	plast = &arc->pwlArc->pts[0];
	assert( p > plast );
    }
    return p--;
}
#endif /* __glujarcloc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\knotvect.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * knotvector.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "knotvect.h"
#include "defines.h"


void Knotvector::init( long _knotcount, long _stride, long _order, INREAL *_knotlist )
{
    knotcount = _knotcount; 
    stride = _stride; 
    order = _order; 
    knotlist = new Knot[_knotcount];
    assert( knotlist != 0 );

    for( int i = 0; i != _knotcount; i++ )
        knotlist[i] = (Knot) _knotlist[i]; 
}

Knotvector::Knotvector( void )
{
    knotlist = 0;
}

Knotvector::~Knotvector( void )
{
    if( knotlist ) delete[] knotlist;
}

int Knotvector::validate( void )
{
   /* kindex is used as an array index so subtract one first, 
     * this propagates throughout the code so study carefully */
    long	kindex = knotcount-1;

    if( order < 1 || order > MAXORDER ) {
	// spline order un-supported
	return( 1 );
    }

    if( knotcount < (2 * order) ) {
	// too few knots
	return( 2 );
    }

    if( identical( knotlist[kindex-(order-1)], knotlist[order-1]) ) {
	// valid knot range is empty 
	return( 3 );
    }

    for( long i = 0; i < kindex; i++)
	if( knotlist[i] > knotlist[i+1] ) {
	    // decreasing knot sequence
	    return( 4 );
	}
	
    /* check for valid multiplicity */

    /*	kindex is currently the index of the last knot.
     *	In the next loop  it is decremented to ignore the last knot
     *	and the loop stops when kindex  is 2 so as to ignore the first
     *  knot as well.  These knots are not used in computing 
     *  knot multiplicities.
     */

    long multi = 1;
    for( ; kindex >= 1; kindex-- ) {
	if( knotlist[kindex] - knotlist[kindex-1] < TOLERANCE ) {
	    multi++; 
	    continue;
	} 
	if ( multi > order ) {
            // knot multiplicity greater than order of spline
	    return( 5 );
	} 
	multi = 1;
    }

    if ( multi > order ) {
        // knot multiplicity greater than order of spline
	return( 5 );
    } 

    return 0;
}

void Knotvector::show( char *msg )
{
#ifndef NDEBUG
    dprintf( "%s\n", msg ); 
    dprintf( "order = %ld, count = %ld\n", order, knotcount );

    for( int i=0; i<knotcount; i++ )
	dprintf( "knot[%d] = %g\n", i, knotlist[i] );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\knotvect.h ===
#ifndef __gluknotvector_h_
#define __gluknotvector_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * knotvector.h - $Revision: 1.1 $
 */

#include "types.h"

#ifdef NT
class Knotvector { /* a knot vector */
public:
#else
struct Knotvector { /* a knot vector */
#endif
			Knotvector( void );
			~Knotvector( void );
    void		init( long, long, long, INREAL * );
    int			validate( void );
    void 		show( char * );

    long		order;		/* order of spline  */
    long		knotcount;	/* number of knots  */
    long		stride;		/* bytes between points */
    Knot *		knotlist;	/* global knot vector */
};

/* tolerance to test knot coincidence */
#define TOLERANCE 		10.0e-5

inline int 
identical( Knot x, Knot y )
{
    return ((x-y) < TOLERANCE) ? 1 : 0;
}
#endif /* __gluknotvector_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\maplist.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * maplist.c++ - $Revision: 1.3 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mymath.h"
#include "nurbscon.h"
#include "maplist.h"
#include "mapdesc.h"
#include "backend.h"
 
Maplist::Maplist( Backend& b )
    : mapdescPool( sizeof( Mapdesc ), 10, "mapdesc pool" ),
      backend( b )
{
    maps = 0; lastmap = &maps;
}

void 
Maplist::initialize( void )
{
    freeMaps();
    define( N_P2D, 0, 2 );
    define( N_P2DR, 1, 3 );
}

void 
Maplist::add( long type, int israt, int ncoords )
{
    *lastmap = new(mapdescPool) Mapdesc( type, israt, ncoords, backend );
    lastmap = &((*lastmap)->next);
}

void 
Maplist::define( long type, int israt, int ncoords )
{
    Mapdesc *m = locate( type );
    assert( m == NULL || ( m->isrational == israt && m->ncoords == ncoords ) );
    add( type, israt, ncoords );
}

void 
Maplist::remove( Mapdesc *m )
{
    for( Mapdesc **curmap = &maps; *curmap; curmap = &((*curmap)->next) ) {
	if( *curmap == m ) {
	    *curmap = m->next;
	    m->deleteMe( mapdescPool );
	    return;
	}
    }
#ifndef NT
    abort();
#endif
}

void
Maplist::freeMaps( void )
{
    mapdescPool.clear();
    maps = 0;
    lastmap = &maps;
}

Mapdesc * 
Maplist::find( long type )
{
    Mapdesc *val = locate( type );
    assert( val != 0 );
    return val;
}

Mapdesc * 
Maplist::locate( long type )
{
    for( Mapdesc *m = maps; m; m = m->next )
	if( m->getType() == type ) break;
    return m;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mapdesc.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mapdesc.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mystring.h"
#include "mymath.h"
#include "backend.h"
#include "nurbscon.h"
#include "mapdesc.h"

Mapdesc::Mapdesc( long _type, int _israt, int _ncoords, Backend& b ) 
    : backend( b )
{
    type 		= _type;
    isrational 		= _israt;
    ncoords 		= _ncoords;
    hcoords		= _ncoords + (_israt ? 0 : 1 );
    inhcoords		= _ncoords - (_israt ? 1 : 0 );
    mask 		= ((1<<(inhcoords*2))-1);
    next		= 0;

    assert( hcoords <= MAXCOORDS );
    assert( inhcoords >= 1 );

    pixel_tolerance 	= 1.0;
    error_tolerance	= 1.0;
    bbox_subdividing	= N_NOBBOXSUBDIVISION;
    culling_method 	= N_NOCULLING;		
    sampling_method 	= N_NOSAMPLING;
    clampfactor 	= N_NOCLAMPING;
    minsavings 		= N_NOSAVINGSSUBDIVISION;
    s_steps  		= 0.0;
    t_steps 		= 0.0;
    maxrate 		= ( s_steps < 0.0 ) ? 0.0 : s_steps;
    maxsrate 		= ( s_steps < 0.0 ) ? 0.0 : s_steps;
    maxtrate 		= ( t_steps < 0.0 ) ? 0.0 : t_steps;
    identify( bmat );
    identify( cmat );
    identify( smat );
    for( int i = 0; i != inhcoords; i++ )
	bboxsize[i] = 1.0;
}

void
Mapdesc::setBboxsize( INREAL *mat )
{
    for( int i = 0; i != inhcoords; i++ )
	bboxsize[i] = (REAL) mat[i];
}

void
Mapdesc::identify( REAL dest[MAXCOORDS][MAXCOORDS] )
{
    memset( dest, 0, sizeof( dest ) );
    for( int i=0; i != hcoords; i++ )
	dest[i][i] = 1.0;
}

void
Mapdesc::surfbbox( REAL bb[2][MAXCOORDS] )
{
    backend.surfbbox( type, bb[0], bb[1] );
}

void 
Mapdesc::copy( REAL dest[MAXCOORDS][MAXCOORDS], long n, INREAL *src,
	long rstride, long cstride )
{
    assert( n >= 0 );
    for( int i=0; i != n; i++ )
        for( int j=0; j != n; j++ )
	    dest[i][j] = src[i*rstride + j*cstride];
}

/*--------------------------------------------------------------------------
 * copyPt - copy a homogeneous point
 *--------------------------------------------------------------------------
 */
void
Mapdesc::copyPt( REAL *d, REAL *s )
{
    assert( hcoords > 0 );
    switch( hcoords  ) {
	case 4: 
	    d[3] = s[3];
	    d[2] = s[2];
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	case 3: 
	    d[2] = s[2];
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	case 2: 
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	case 1: 
	    d[0] = s[0];
	    break;
	case 5: 
	    d[4] = s[4];
	    d[3] = s[3];
	    d[2] = s[2];
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	default:
	    memcpy( d, s, hcoords * sizeof( REAL ) );
	    break;
    }
}

/*--------------------------------------------------------------------------
 * sumPt - compute affine combination of two homogeneous points
 *--------------------------------------------------------------------------
 */
void
Mapdesc::sumPt( REAL *dst, REAL *src1, REAL *src2, register REAL alpha, register REAL beta )
{
    assert( hcoords > 0 );
    switch( hcoords  ) {
	case 4: 
	    dst[3] = src1[3] * alpha + src2[3] * beta;
	    dst[2] = src1[2] * alpha + src2[2] * beta;
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 3: 
	    dst[2] = src1[2] * alpha + src2[2] * beta;
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 2: 
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 1: 
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 5: 
	    dst[4] = src1[4] * alpha + src2[4] * beta;
	    dst[3] = src1[3] * alpha + src2[3] * beta;
	    dst[2] = src1[2] * alpha + src2[2] * beta;
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	default: {
		for( int i = 0; i != hcoords; i++ )
		    dst[i] = src1[i] * alpha + src2[i] * beta;
            }
	    break;
    }
}

/*--------------------------------------------------------------------------
 * clipbits - compute bit-vector indicating point/window position
 *		       of a (transformed) homogeneous point
 *--------------------------------------------------------------------------
 */
unsigned int
Mapdesc::clipbits( REAL *p )
{
    assert( inhcoords >= 0 );
    assert( inhcoords <= 3 );

    register int nc = inhcoords;
    register REAL pw = p[nc];
    register REAL nw = -pw;
    register unsigned int bits = 0;

    if( pw == 0.0 ) return mask;

    if( pw > 0.0 ) {
	switch( nc ) {
	case 3:
	    if( p[2] <= pw ) bits |= (1<<5);
	    if( p[2] >= nw ) bits |= (1<<4);
	    if( p[1] <= pw ) bits |= (1<<3);
	    if( p[1] >= nw ) bits |= (1<<2);
	    if( p[0] <= pw ) bits |= (1<<1);
	    if( p[0] >= nw ) bits |= (1<<0);
            return bits;
	case 2:
	    if( p[1] <= pw ) bits |= (1<<3);
	    if( p[1] >= nw ) bits |= (1<<2);
	    if( p[0] <= pw ) bits |= (1<<1);
	    if( p[0] >= nw ) bits |= (1<<0);
            return bits;
	case 1:
	    if( p[0] <= pw ) bits |= (1<<1);
	    if( p[0] >= nw ) bits |= (1<<0);
            return bits;
	default: {
		int bit = 1;
		for( int i=0; i<nc; i++ ) {
		    if( p[i] >= nw ) bits |= bit; 
		    bit <<= 1;
		    if( p[i] <= pw ) bits |= bit; 
		    bit <<= 1;
		}
#ifdef NT
                return 0;
#else
		abort();
#endif
		break;
	    }
	}
    } else { 
	switch( nc ) {
	case 3:
	    if( p[2] <= nw ) bits |= (1<<5);
	    if( p[2] >= pw ) bits |= (1<<4);
	    if( p[1] <= nw ) bits |= (1<<3);
	    if( p[1] >= pw ) bits |= (1<<2);
	    if( p[0] <= nw ) bits |= (1<<1);
	    if( p[0] >= pw ) bits |= (1<<0);
            return bits;
	case 2:
	    if( p[1] <= nw ) bits |= (1<<3);
	    if( p[1] >= pw ) bits |= (1<<2);
	    if( p[0] <= nw ) bits |= (1<<1);
	    if( p[0] >= pw ) bits |= (1<<0);
            return bits;
	case 1:
	    if( p[0] <= nw ) bits |= (1<<1);
	    if( p[0] >= pw ) bits |= (1<<0);
            return bits;
	default: {
		int bit = 1; 
		for( int i=0; i<nc; i++ ) {
		    if( p[i] >= pw ) bits |= bit; 
		    bit <<= 1;
		    if( p[i] <= nw ) bits |= bit; 
		    bit <<= 1;
		}
#ifdef NT
                return 0;
#else
		abort();
#endif
		break;
	    }
	}
    }
    return bits;
}

/*--------------------------------------------------------------------------
 * xformRational - transform a homogeneous point
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformRational( Maxmatrix mat, REAL *d, REAL *s )
{
    assert( hcoords >= 0 );

    if( hcoords == 3 ) {
	REAL x = s[0];
	REAL y = s[1];
	REAL z = s[2];
	d[0] = x*mat[0][0]+y*mat[1][0]+z*mat[2][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+z*mat[2][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+z*mat[2][2];
    } else if( hcoords == 4 ) {
	REAL x = s[0];
	REAL y = s[1];
	REAL z = s[2];
	REAL w = s[3];
	d[0] = x*mat[0][0]+y*mat[1][0]+z*mat[2][0]+w*mat[3][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+z*mat[2][1]+w*mat[3][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+z*mat[2][2]+w*mat[3][2];
	d[3] = x*mat[0][3]+y*mat[1][3]+z*mat[2][3]+w*mat[3][3];
    } else {
	for( int i=0; i != hcoords; i++ ) {
	    d[i] = 0;
	    for( int j = 0; j != hcoords; j++ )
		d[i] += s[j] * mat[j][i];
	}
    }
}

/*--------------------------------------------------------------------------
 * xformNonrational - transform a inhomogeneous point to a homogeneous point
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformNonrational( Maxmatrix mat, REAL *d, REAL *s )
{
    if( inhcoords == 2 ) {
	REAL x = s[0];
	REAL y = s[1];
	d[0] = x*mat[0][0]+y*mat[1][0]+mat[2][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+mat[2][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+mat[2][2];
    } else if( inhcoords == 3 ) {
	REAL x = s[0];
	REAL y = s[1];
	REAL z = s[2];
	d[0] = x*mat[0][0]+y*mat[1][0]+z*mat[2][0]+mat[3][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+z*mat[2][1]+mat[3][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+z*mat[2][2]+mat[3][2];
	d[3] = x*mat[0][3]+y*mat[1][3]+z*mat[2][3]+mat[3][3];
    } else {
        assert( inhcoords >= 0 );
	for( int i=0; i != hcoords; i++ ) {
	    d[i] = mat[inhcoords][i];
	    for( int j = 0; j < inhcoords; j++ )
		d[i] += s[j] * mat[j][i];
	}
    }
}

/*--------------------------------------------------------------------------
 * xformAndCullCheck - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description and
 *	check if they are either completely inside, completely outside, 
 *	or intersecting the viewing frustrum.
 *--------------------------------------------------------------------------
 */
int
Mapdesc::xformAndCullCheck( 
    REAL *pts, int uorder, int ustride, int vorder, int vstride )
{
    assert( uorder > 0 );
    assert( vorder > 0 );

    unsigned int inbits = mask;
    unsigned int outbits = 0;

    REAL *p = pts;
    for( REAL *pend = p + uorder * ustride; p != pend; p += ustride ) {
        REAL *q = p;
        for( REAL *qend = q + vorder * vstride; q != qend; q += vstride ) {
    	    REAL cpts[MAXCOORDS];
	    xformCulling( cpts, q );
	    unsigned int bits = clipbits( cpts );
	    outbits |= bits;
	    inbits &= bits;
	    if( ( outbits == mask ) && ( inbits != mask ) ) return CULL_ACCEPT;
	} 
    }

    if( outbits != mask ) {
	return CULL_TRIVIAL_REJECT;
    } else if( inbits == mask ) {
	return CULL_TRIVIAL_ACCEPT;
    } else {
	return CULL_ACCEPT;
    }
}

/*--------------------------------------------------------------------------
 * cullCheck - check if a set of homogeneous transformed points are 
 *	either completely inside, completely outside, 
 *	or intersecting the viewing frustrum.
 *--------------------------------------------------------------------------
 */
int
Mapdesc::cullCheck( REAL *pts, int uorder, int ustride, int vorder, int vstride )
{
    unsigned int inbits = mask;
    unsigned int outbits  = 0;

    REAL *p = pts;
    for( REAL *pend = p + uorder * ustride; p != pend; p += ustride ) {
        REAL *q = p;
        for( REAL *qend = q + vorder * vstride; q != qend; q += vstride ) {
	    unsigned int bits = clipbits( q );
	    outbits |= bits;
	    inbits &= bits;
	    if( ( outbits == mask ) && ( inbits != mask ) ) return CULL_ACCEPT;
	} 
    }

    if( outbits != mask ) {
	return CULL_TRIVIAL_REJECT;
    } else if( inbits == mask ) {
	return CULL_TRIVIAL_ACCEPT;
    } else {
	return CULL_ACCEPT;
    }
}

/*--------------------------------------------------------------------------
 * cullCheck - check if a set of homogeneous transformed points are 
 *	either completely inside, completely outside, 
 *	or intersecting the viewing frustrum.
 *--------------------------------------------------------------------------
 */
int
Mapdesc::cullCheck( REAL *pts, int order, int stride )
{
    unsigned int inbits = mask;
    unsigned int outbits  = 0;

    REAL *p = pts;
    for( REAL *pend = p + order * stride; p != pend; p += stride ) {
	unsigned int bits = clipbits( p );
	outbits |= bits;
	inbits &= bits;
	if( ( outbits == mask ) && ( inbits != mask ) ) return CULL_ACCEPT;
    }

    if( outbits != mask ) {
	return CULL_TRIVIAL_REJECT;
    } else if( inbits == mask ) {
	return CULL_TRIVIAL_ACCEPT;
    } else {
	return CULL_ACCEPT;
    }
}

/*--------------------------------------------------------------------------
 * xformSampling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into sampling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformSampling( REAL *pts, int order, int stride, REAL *sp, int outstride )
{
    xformMat( smat, pts, order, stride, sp, outstride );
}

void
Mapdesc::xformBounding( REAL *pts, int order, int stride, REAL *sp, int outstride )
{
    xformMat( bmat, pts, order, stride, sp, outstride );
}

/*--------------------------------------------------------------------------
 * xformCulling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into culling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformCulling( REAL *pts, int order, int stride, REAL *cp, int outstride )
{
    xformMat( cmat, pts, order, stride, cp, outstride );
}

/*--------------------------------------------------------------------------
 * xformCulling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into culling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformCulling( REAL *pts, 
    int uorder, int ustride,
    int vorder, int vstride, 
    REAL *cp, int outustride, int outvstride )
{
    xformMat( cmat, pts, uorder, ustride, vorder, vstride, cp, outustride, outvstride );
}

/*--------------------------------------------------------------------------
 * xformSampling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into sampling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformSampling( REAL *pts, 
    int uorder, int ustride, 
    int vorder, int vstride, 
    REAL *sp, int outustride, int outvstride )
{
    xformMat( smat, pts, uorder, ustride, vorder, vstride, sp, outustride, outvstride );
}

void
Mapdesc::xformBounding( REAL *pts, 
    int uorder, int ustride, 
    int vorder, int vstride, 
    REAL *sp, int outustride, int outvstride )
{
    xformMat( bmat, pts, uorder, ustride, vorder, vstride, sp, outustride, outvstride );
}

void
Mapdesc::xformMat( 
    Maxmatrix	mat, 
    REAL *	pts, 
    int 	order, 
    int 	stride,
    REAL *	cp, 
    int 	outstride )
{
    if( isrational ) {
	REAL *pend = pts + order * stride;
	for( REAL *p = pts ; p != pend; p += stride ) {
	    xformRational( mat, cp, p );
	    cp += outstride;
	}       
    } else {
	REAL *pend = pts + order * stride;
	for( REAL *p = pts ; p != pend; p += stride ) {
	    xformNonrational( mat, cp, p );
	    cp += outstride;
	}	
    }
}

void
Mapdesc::xformMat( Maxmatrix mat, REAL *pts, 
    int uorder, int ustride, 
    int vorder, int vstride, 
    REAL *cp, int outustride, int outvstride )
{
    if( isrational ) {
	REAL *pend = pts + uorder * ustride;
	for( REAL *p = pts ; p != pend; p += ustride ) {
	    REAL *cpts2 = cp;
	    REAL *qend = p + vorder * vstride;
	    for( REAL *q = p; q != qend; q += vstride ) {
		xformRational( mat, cpts2, q );
		cpts2 += outvstride;
	    } 
	    cp += outustride;
	}
    } else {
	REAL *pend = pts + uorder * ustride;
	for( REAL *p = pts ; p != pend; p += ustride ) {
	    REAL *cpts2 = cp;
	    REAL *qend = p + vorder * vstride;
	    for( REAL *q = p; q != qend; q += vstride ) {
		xformNonrational( mat, cpts2, q );
		cpts2 += outvstride;
	    } 
	    cp += outustride;
	}
    }
}

/*--------------------------------------------------------------------------
 * subdivide - subdivide a curve along an isoparametric line
 *--------------------------------------------------------------------------
 */

void
Mapdesc::subdivide( REAL *src, REAL *dst, REAL v, int stride, int order )
{
    REAL mv = 1.0 - v;

    for( REAL *send=src+stride*order; src!=send; send-=stride, dst+=stride ) {
	copyPt( dst, src );
	REAL *qpnt = src + stride;
	for( REAL *qp=src; qpnt!=send; qp=qpnt, qpnt+=stride )
	    sumPt( qp, qp, qpnt, mv, v );
    }
}

/*--------------------------------------------------------------------------
 * subdivide - subdivide a patch along an isoparametric line
 *--------------------------------------------------------------------------
 */

void
Mapdesc::subdivide( REAL *src, REAL *dst, REAL v, 
    int so, int ss, int to, int ts  )
{
    REAL mv = 1.0 - v;

    for( REAL *slast = src+ss*so; src != slast; src += ss, dst += ss ) {
	REAL *sp = src;
	REAL *dp = dst;
        for( REAL *send = src+ts*to; sp != send; send -= ts, dp += ts ) {
	    copyPt( dp, sp );
	    REAL *qp = sp;
	    for( REAL *qpnt = sp+ts; qpnt != send; qp = qpnt, qpnt += ts )
	        sumPt( qp, qp, qpnt, mv, v );
	}
    }
}


#define sign(x)	((x > 0) ? 1 : ((x < 0.0) ? -1 : 0))

/*--------------------------------------------------------------------------
 * project - project a set of homogeneous coordinates into inhomogeneous ones
 *--------------------------------------------------------------------------
 */
int
Mapdesc::project( REAL *src, int rstride, int cstride, 
	          REAL *dest, int trstride, int tcstride,
		  int nrows, int ncols )
{
    int s = sign( src[inhcoords] );
    REAL *rlast = src + nrows * rstride;
    REAL *trptr = dest;
    for( REAL *rptr=src; rptr != rlast; rptr+=rstride, trptr+=trstride ) {
	REAL *clast = rptr + ncols * cstride;
	REAL *tcptr = trptr;
	for( REAL *cptr = rptr; cptr != clast; cptr+=cstride, tcptr+=tcstride ) {
	    REAL *coordlast = cptr + inhcoords;
	    if( sign( *coordlast ) != s ) return 0;
	    REAL *tcoord = tcptr;
	    for( REAL *coord = cptr; coord != coordlast; coord++, tcoord++ ) {
		*tcoord = *coord / *coordlast;
	    }
	}
    }
    return 1;
}

/*--------------------------------------------------------------------------
 * project - project a set of homogeneous coordinates into inhomogeneous ones
 *--------------------------------------------------------------------------
 */
int
Mapdesc::project( REAL *src, int stride, REAL *dest, int tstride, int ncols )
{
    int s = sign( src[inhcoords] );

    REAL *clast = src + ncols * stride;
    for( REAL *cptr = src, *tcptr = dest; cptr != clast; cptr+=stride, tcptr+=tstride ) {
	REAL *coordlast = cptr + inhcoords;
	if( sign( *coordlast ) != s ) return 0;
	for( REAL *coord = cptr, *tcoord = tcptr; coord != coordlast; coord++, tcoord++ ) 
	    *tcoord = *coord / *coordlast;
    }

    return 1;
}

int
Mapdesc::bboxTooBig( 
    REAL *p, 
    int	 rstride,
    int	 cstride,
    int	 nrows,
    int	 ncols,
    REAL bb[2][MAXCOORDS] )
{
    REAL bbpts[MAXORDER][MAXORDER][MAXCOORDS];
    const int trstride = sizeof(bbpts[0]) / sizeof(REAL);
    const int tcstride = sizeof(bbpts[0][0]) / sizeof(REAL); 

    // points have been transformed, therefore they are homogeneous
    // project points
    int val = project( p, rstride, cstride, 
	     &bbpts[0][0][0], trstride, tcstride, nrows, ncols );
    if( val == 0 ) return -1;

    // compute bounding box
    bbox( bb, &bbpts[0][0][0], trstride, tcstride, nrows, ncols );

    // find out if bounding box can't fit in unit cube
    if( bbox_subdividing == N_BBOXROUND ) {
	for( int k=0; k != inhcoords; k++ )
	    if( ceilf(bb[1][k]) - floorf(bb[0][k]) > bboxsize[k] ) return 1;
    } else {
	for( int k=0; k != inhcoords; k++ )
	    if( bb[1][k] - bb[0][k] > bboxsize[k] ) return 1;
    }
    return 0;  
}

void
Mapdesc::bbox( 
    REAL bb[2][MAXCOORDS], 
    REAL *p, 
    int	 rstride,
    int	 cstride,
    int	 nrows,
    int	 ncols )
{
    for( int k=0; k != inhcoords; k++ )
	 bb[0][k] = bb[1][k] = p[k];

    for( int i=0; i != nrows; i++ ) 
	for( int j=0; j != ncols; j++ ) 
	    for( k=0; k != inhcoords; k++ ) {
		REAL x = p[i*rstride + j*cstride + k];
		if(  x < bb[0][k] ) bb[0][k] = x;
		else if( x > bb[1][k] ) bb[1][k] = x;
	    }
}

/*--------------------------------------------------------------------------
 * calcVelocityRational - calculate upper bound on first partial derivative 
 *	of a homogeneous set of points and bounds on each row of points.
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcVelocityRational( REAL *p, int stride, int ncols )
{
    REAL tmp[MAXORDER][MAXCOORDS];

    assert( ncols <= MAXORDER );

    const int tstride = sizeof(tmp[0]) / sizeof(REAL); 

    if( project( p, stride, &tmp[0][0], tstride, ncols ) ) {
	return calcPartialVelocity( &tmp[0][0], tstride, ncols, 1, 1.0 );
    } else { /* XXX */
	return calcPartialVelocity( &tmp[0][0], tstride, ncols, 1, 1.0 );
    }
}

/*--------------------------------------------------------------------------
 * calcVelocityNonrational - calculate upper bound on  first partial 
 *	derivative of a inhomogeneous set of points.
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcVelocityNonrational( REAL *pts, int stride, int ncols )
{
    return calcPartialVelocity( pts, stride, ncols, 1, 1.0 );
}

int
Mapdesc::isProperty( long property )
{
    switch ( property ) {
	case N_PIXEL_TOLERANCE:
	case N_ERROR_TOLERANCE:
	case N_CULLING:
	case N_BBOX_SUBDIVIDING:
	case N_S_STEPS:
	case N_T_STEPS:
        case N_SAMPLINGMETHOD:
        case N_CLAMPFACTOR:
        case N_MINSAVINGS:
	    return 1;
	default:
	    return 0;
    }
}

REAL
Mapdesc::getProperty( long property )
{
    switch ( property ) {
	case N_PIXEL_TOLERANCE:
	    return pixel_tolerance;
	case N_ERROR_TOLERANCE:
	    return error_tolerance;
	case N_CULLING:
	    return culling_method;
	case N_BBOX_SUBDIVIDING:
	    return bbox_subdividing;
	case N_S_STEPS:
	    return s_steps;
	case N_T_STEPS:
	    return t_steps;
        case N_SAMPLINGMETHOD:
	    return sampling_method;
        case N_CLAMPFACTOR:
	    return clampfactor;
        case N_MINSAVINGS:
	    return minsavings;
	default:
#ifdef NT
            return( (REAL) 0.0 );
#else
	    abort();
	    return -1; //not necessary, needed to shut up compiler
#endif
    }
}

void
Mapdesc::setProperty( long property, REAL value )
{

    switch ( property ) {
	case N_PIXEL_TOLERANCE:
	    pixel_tolerance = value;
	    break;
	case N_ERROR_TOLERANCE:
	    error_tolerance = value;
	    break;
	case N_CULLING:
	    culling_method = value;
	    break;
	case N_BBOX_SUBDIVIDING:
	    if( value <= 0.0 ) value = N_NOBBOXSUBDIVISION;
	    bbox_subdividing = value;
	    break;
	case N_S_STEPS:
	    if( value < 0.0 ) value = 0.0;
	    s_steps = value;
	    maxrate = ( value < 0.0 ) ? 0.0 : value;
	    maxsrate = ( value < 0.0 ) ? 0.0 : value;
	    break;
	case N_T_STEPS:
	    if( value < 0.0 ) value = 0.0;
	    t_steps = value;
	    maxtrate = ( value < 0.0 ) ? 0.0 : value;
	    break;
	case N_SAMPLINGMETHOD:
	    sampling_method = value;
	    break;
	case N_CLAMPFACTOR:
	    if( value <= 0.0 ) value = N_NOCLAMPING;
	    clampfactor = value;
	    break;
	case N_MINSAVINGS:
	    if( value <= 0.0 ) value = N_NOSAVINGSSUBDIVISION;
	    minsavings = value;
	    break;
	default:
#ifndef NT
	    abort();
#endif
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\maplist.h ===
#ifndef __glumaplist_h_
#define __glumaplist_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * maplist.h - $Revision: 1.4 $
 */

#include "types.h"
#include "defines.h"
#include "bufpool.h"

class Backend;
class Mapdesc;

class Maplist {
public:
			Maplist( Backend & );
    void 		define( long, int, int );
    inline void 	undefine( long );
    inline int		isMap( long );

    void 		initialize( void );
    Mapdesc * 		find( long );
    Mapdesc * 		locate( long );

private:
    Pool		mapdescPool;
    Mapdesc *		maps;
    Mapdesc **		lastmap;
    Backend &		backend;

    void 		add( long, int, int );
    void 		remove( Mapdesc * );
    void		freeMaps( void );
};

inline int
Maplist::isMap( long type )
{
    return (locate( type ) ? 1 : 0);
}

inline void 
Maplist::undefine( long type )
{
    Mapdesc *m = locate( type );
    assert( m != 0 );
    remove( m );
}
#endif /* __glumaplist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mapdesc.h ===
#ifndef __glumapdesc_h_
#define __glumapdesc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mapdesc.h - $Revision: 1.1 $
 */

#include "mystdio.h"
#include "types.h"
#include "defines.h"
#include "bufpool.h"
#include "nurbscon.h"

typedef REAL Maxmatrix[MAXCOORDS][MAXCOORDS];

class Backend;

class Mapdesc : public PooledObj {
    friend class Maplist;
			
public:
    			Mapdesc( long, int, int, Backend & );
    int			isProperty( long );
    REAL		getProperty( long );
    void		setProperty( long, REAL );
    int			isConstantSampling( void );
    int			isDomainSampling( void );
    int			isRangeSampling( void );
    int			isSampling( void );
    int			isParametricDistanceSampling( void );
    int			isSurfaceAreaSampling( void );
    int			isPathLengthSampling( void );
    int			isCulling( void );
    int			isBboxSubdividing( void );
    long		getType( void );

    /* curve routines */
    void		subdivide( REAL *, REAL *, REAL, int, int );
    int 		cullCheck( REAL *, int, int );
    void		xformBounding( REAL *, int, int, REAL *, int );
    void		xformCulling( REAL *, int, int, REAL *, int );
    void		xformSampling( REAL *, int, int, REAL *, int );
    void		xformMat( Maxmatrix, REAL *, int, int, REAL *, int );
    REAL		calcPartialVelocity ( REAL *, int, int, int, REAL );
    int			project( REAL *, int, REAL *, int, int );
    REAL		calcVelocityRational( REAL *, int, int );
    REAL		calcVelocityNonrational( REAL *, int, int );

    /* surface routines */
    void		subdivide( REAL *, REAL *, REAL, int, int, int, int );
    int 		cullCheck( REAL *, int, int, int, int );
    void		xformBounding( REAL *, int, int, int, int, REAL *, int, int );
    void		xformCulling( REAL *, int, int, int, int, REAL *, int, int );
    void		xformSampling( REAL *, int, int, int, int, REAL *, int, int );
    void		xformMat( Maxmatrix, REAL *, int, int, int, int, REAL *, int, int );
    REAL		calcPartialVelocity ( REAL *, REAL *, int, int, int, int, int, int, REAL, REAL, int );
    int 		project( REAL *, int, int, REAL *, int, int, int, int);
    void		surfbbox( REAL bb[2][MAXCOORDS] );

    int			bboxTooBig( REAL *, int, int, int, int, REAL [2][MAXCOORDS] );
    int 		xformAndCullCheck( REAL *, int, int, int, int );

    void		identify( REAL[MAXCOORDS][MAXCOORDS] );
    void		setBboxsize( INREAL *);
    inline void 	setBmat( INREAL*, long, long );
    inline void 	setCmat( INREAL*, long, long );
    inline void 	setSmat( INREAL*, long, long );
    inline int		isRational( void );
    inline int		getNcoords( void );

    REAL 		pixel_tolerance;    /* pathlength sampling tolerance */
    REAL		error_tolerance;    /* parametric error sampling tolerance*/
    REAL 		clampfactor;
    REAL 		minsavings;
    REAL		maxrate;
    REAL		maxsrate;
    REAL		maxtrate;
    REAL		bboxsize[MAXCOORDS];

private:
    long 		type;
    int 		isrational;
    int 		ncoords;
    int 		hcoords;
    int 		inhcoords;
#ifdef NT
    unsigned int mask;
#else
    int			mask;
#endif
    Maxmatrix 		bmat;
    Maxmatrix 		cmat;
    Maxmatrix 		smat;
    REAL 		s_steps;		/* max samples in s direction */
    REAL 		t_steps;		/* max samples in t direction */
    REAL 		sampling_method;	
    REAL 		culling_method;		/* check for culling */
    REAL		bbox_subdividing;
    Mapdesc *		next;
    Backend &		backend;

    void		bbox( REAL [2][MAXCOORDS], REAL *, int, int, int, int );
    REAL		maxDifference( int, REAL *, int );
    static void 	copy( Maxmatrix, long, INREAL *, long, long );

    /* individual control point routines */
    static void		transform4d( float[4], float[4], float[4][4] );
    static void		multmatrix4d ( float[4][4], float[4][4], float[4][4] );
    void		copyPt( REAL *, REAL * );
    void		sumPt( REAL *, REAL *, REAL *, REAL, REAL );
    void		xformSampling( REAL *, REAL * );
    void		xformCulling( REAL *, REAL * );
    void		xformRational( Maxmatrix, REAL *, REAL * );
    void		xformNonrational( Maxmatrix, REAL *, REAL * );
    unsigned int	clipbits( REAL * );
};

inline void
Mapdesc::setBmat( INREAL *mat, long rstride, long cstride )
{
    copy( bmat, hcoords, mat, rstride, cstride );
}

inline void
Mapdesc::setCmat( INREAL *mat, long rstride, long cstride )
{
    copy( cmat, hcoords, mat, rstride, cstride );
}

inline void
Mapdesc::setSmat( INREAL *mat, long rstride, long cstride )
{
    copy( smat, hcoords, mat, rstride, cstride );
}

inline long
Mapdesc::getType( void )
{
    return type;
}

inline void
Mapdesc::xformCulling( REAL *d, REAL *s )
{
    if( isrational )
        xformRational( cmat, d, s );
    else
	xformNonrational( cmat, d, s );
}

inline void
Mapdesc::xformSampling( REAL *d, REAL *s )
{
    if( isrational )
        xformRational( smat, d, s );
    else
	xformNonrational( smat, d, s );
}

inline int 
Mapdesc::isRational( void )
{
    return isrational ? 1 : 0;
}

inline int		
Mapdesc::getNcoords( void ) 
{
    return ncoords; 
}

inline int			
Mapdesc::isConstantSampling( void ) 
{
    return ((sampling_method == N_FIXEDRATE) ? 1 : 0); 
}

inline int			
Mapdesc::isDomainSampling( void ) 
{ 
    return ((sampling_method == N_DOMAINDISTANCE) ? 1 : 0); 
}

inline int			
Mapdesc::isParametricDistanceSampling( void ) 
{
    return ((sampling_method == N_PARAMETRICDISTANCE) ? 1 : 0);
}

inline int			
Mapdesc::isSurfaceAreaSampling( void ) 
{
    return ((sampling_method == N_SURFACEAREA) ? 1 : 0);
}

inline int			
Mapdesc::isPathLengthSampling( void ) 
{
    return ((sampling_method == N_PATHLENGTH) ? 1 : 0);
}

inline int			
Mapdesc::isRangeSampling( void ) 
{
    return ( isParametricDistanceSampling() || isPathLengthSampling() ||
	    isSurfaceAreaSampling() );
}

inline int
Mapdesc::isSampling( void )
{
    return isRangeSampling() || isConstantSampling() || isDomainSampling();
}

inline int			
Mapdesc::isCulling( void ) 
{
    return ((culling_method != N_NOCULLING) ? 1 : 0);
}

inline int			
Mapdesc::isBboxSubdividing( void ) 
{
    return ((bbox_subdividing != N_NOBBOXSUBDIVISION) ? 1 : 0);
}
#endif /* __glumapdesc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mesher.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mesher.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mesher.h"
#include "gridvert.h"
#include "gridtrim.h"
#include "jarcloc.h"
#include "gridline.h"
#include "trimline.h"
#include "uarray.h"
#include "backend.h"


const float Mesher::ZERO = 0.0;

Mesher::Mesher( Backend& b ) 
	: backend( b ), 
	p( sizeof( GridTrimVertex ), 100, "GridTrimVertexPool" )
{
    stacksize = 0;
    vdata = 0;
    lastedge = 0; //needed to prevent purify UMR 
}

Mesher::~Mesher( void )
{
    if( vdata ) delete[] vdata;
}

void 
Mesher::init( unsigned int npts )
{
    p.clear();
    if( stacksize < npts ) {
	stacksize = 2 * npts;
	if( vdata ) delete[] vdata;		
	vdata = new GridTrimVertex_p[stacksize];
    } 
}

inline void
Mesher::push( GridTrimVertex *gt )
{
    assert( itop+1 != stacksize );
    vdata[++itop] = gt;
}

inline void
Mesher::pop( long )
{
}

inline void
Mesher::openMesh()
{
    backend.bgntmesh( "addedge" );
}

inline void
Mesher::closeMesh()
{
    backend.endtmesh();
}

inline void
Mesher::swapMesh()
{
    backend.swaptmesh();
}

inline void
Mesher::clearStack()
{
    itop = -1;
    last[0] = 0;
}

void
Mesher::finishLower( GridTrimVertex *gtlower )
{
    for( push(gtlower); 
	 nextlower( gtlower=new(p) GridTrimVertex ); 
	 push(gtlower) ) 
	    addLower();
    addLast();
}

void
Mesher::finishUpper( GridTrimVertex *gtupper )
{
    for( push(gtupper); 
	 nextupper( gtupper=new(p) GridTrimVertex ); 
	 push(gtupper) ) 
	    addUpper();
    addLast();
}

void
Mesher::mesh( void )
{
    GridTrimVertex *gtlower, *gtupper;

    Hull::init( );
    nextupper( gtupper = new(p) GridTrimVertex );
    nextlower( gtlower = new(p) GridTrimVertex );

    clearStack();
    openMesh();
    push(gtupper);

    nextupper( gtupper = new(p) GridTrimVertex );
    nextlower( gtlower );

    assert( gtupper->t && gtlower->t );
    
    if( gtupper->t->param[0] < gtlower->t->param[0] ) {
	push(gtupper);
	lastedge = 1;
	if( nextupper( gtupper=new(p) GridTrimVertex ) == 0 ) {
	    finishLower(gtlower);
	    return;
	}
    } else if( gtupper->t->param[0] > gtlower->t->param[0] ) {
	push(gtlower);
	lastedge = 0;
	if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
	    finishUpper(gtupper);
	    return;
	}
    } else {
	if( lastedge == 0 ) {
	    push(gtupper);
	    lastedge = 1;
	    if( nextupper(gtupper=new(p) GridTrimVertex) == 0 ) {
		finishLower(gtlower);
		return;
	    }
	} else {
	    push(gtlower);
	    lastedge = 0;
	    if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
		finishUpper(gtupper);
		return;
	    }
	}
    }

    while ( 1 ) {
	if( gtupper->t->param[0] < gtlower->t->param[0] ) {
            push(gtupper);
	    addUpper();
	    if( nextupper( gtupper=new(p) GridTrimVertex ) == 0 ) {
		finishLower(gtlower);
		return;
	    }
	} else if( gtupper->t->param[0] > gtlower->t->param[0] ) {
    	    push(gtlower);
	    addLower();
	    if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
		finishUpper(gtupper);
		return;
	    }
	} else {
	    if( lastedge == 0 ) {
		push(gtupper);
		addUpper();
		if( nextupper( gtupper=new(p) GridTrimVertex ) == 0 ) {
		    finishLower(gtlower);
		    return;
		}
	    } else {
		push(gtlower);
		addLower();
		if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
		    finishUpper(gtupper);
		    return;
		}
	    }
	}
    }
}

inline int
Mesher::isCcw( int ilast )
{
    REAL area = det3( vdata[ilast]->t, vdata[itop-1]->t, vdata[itop-2]->t );
    return (area < ZERO) ? 0 : 1;
}

inline int
Mesher::isCw( int ilast  )
{
    REAL area = det3( vdata[ilast]->t, vdata[itop-1]->t, vdata[itop-2]->t );
    return (area > -ZERO) ? 0 : 1;
}

inline int
Mesher::equal( int x, int y )
{
    return( last[0] == vdata[x] && last[1] == vdata[y] );
}

inline void
Mesher::copy( int x, int y )
{
    last[0] = vdata[x]; last[1] = vdata[y];
}
 
inline void
Mesher::move( int x, int y ) 
{
    vdata[x] = vdata[y];
}

inline void
Mesher::output( int x )
{
    backend.tmeshvert( vdata[x] );
}

/*---------------------------------------------------------------------------
 * addedge - addedge an edge to the triangulation
 *
 *	This code has been re-written to generate large triangle meshes
 *	from a monotone polygon.  Although smaller triangle meshes
 *	could be generated faster and with less code, larger meshes
 *	actually give better SYSTEM performance.  This is because
 *	vertices are processed in the backend slower than they are
 *	generated by this code and any decrease in the number of vertices
 *	results in a decrease in the time spent in the backend.
 *---------------------------------------------------------------------------
 */

void
Mesher::addLast( )
{
    register int ilast = itop;

    if( lastedge == 0 ) {
	if( equal( 0, 1 ) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = 2; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	} else if( equal( ilast-2, ilast-1) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = ilast-3; i >= 0; i-- ) {
		output( i );
		swapMesh();
	    }
	    copy( 0, ilast );
	} else {
	    closeMesh();	openMesh();
	    output( ilast );
	    output( 0 );
	    for( register int i = 1; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	}
    } else {
	if( equal( 1, 0) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = 2; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	} else if( equal( ilast-1, ilast-2) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = ilast-3; i >= 0; i-- ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, 0 );
	} else {
	    closeMesh();	openMesh();
	    output( 0 );
	    output( ilast );
	    for( register int i = 1; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	}
    }
    closeMesh();
    //for( register long k=0; k<=ilast; k++ ) pop( k );
}

void
Mesher::addUpper( )
{
    register int ilast = itop;

    if( lastedge == 0 ) {
	if( equal( 0, 1 ) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = 2; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	} else if( equal( ilast-2, ilast-1) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = ilast-3; i >= 0; i-- ) {
		output( i );
		swapMesh();
	    }
	    copy( 0, ilast );
	} else {
	    closeMesh();	openMesh();
	    output( ilast );
	    output( 0 );
	    for( register int i = 1; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	}
	lastedge = 1;
        //for( register long k=0; k<ilast-1; k++ ) pop( k );
	move( 0, ilast-1 );
	move( 1, ilast );
	itop = 1;
    } else {
	if( ! isCcw( ilast ) ) return;
	do {
	    itop--;
	} while( (itop > 1) && isCcw( ilast ) );

	if( equal( ilast-1, ilast-2 ) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i=ilast-3; i>=itop-1; i-- ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, itop-1 );
	} else if( equal( itop, itop-1 ) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = itop+1; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	} else {
	    closeMesh();	openMesh();
	    output( ilast );
	    output( ilast-1 );
	    for( register int i=ilast-2; i>=itop-1; i-- ) {
		swapMesh();
		output( i );
	    } 
	    copy( ilast, itop-1 );
	}
        //for( register int k=itop; k<ilast; k++ ) pop( k );
	move( itop, ilast );
    }
}

void
Mesher::addLower()
{
    register int ilast = itop;

    if( lastedge == 1 ) {
	if( equal( 1, 0) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = 2; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	} else if( equal( ilast-1, ilast-2) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = ilast-3; i >= 0; i-- ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, 0 );
	} else {
	    closeMesh();	openMesh();
	    output( 0 );
	    output( ilast );
	    for( register int i = 1; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	}

	lastedge = 0;
        //for( register long k=0; k<ilast-1; k++ ) pop( k );
	move( 0, ilast-1 );
	move( 1, ilast );
	itop = 1;
    } else {
	if( ! isCw( ilast ) ) return;
	do {
	    itop--;
	} while( (itop > 1) && isCw( ilast ) );

	if( equal( ilast-2, ilast-1) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i=ilast-3; i>=itop-1; i--) {
		output( i );
		swapMesh( );
	    }
	    copy( itop-1, ilast );
	} else if( equal( itop-1, itop) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i=itop+1; i<ilast; i++ ) {
		swapMesh( );
		output( i );
	    }
	    copy( ilast, ilast-1 );
	} else {
	    closeMesh();	openMesh();
	    output( ilast-1 );
	    output( ilast );
	    for( register int i=ilast-2; i>=itop-1; i-- ) {
		output( i );
		swapMesh( );
	    }
	    copy( itop-1, ilast );
	}
        //for( register int k=itop; k<ilast; k++ ) pop( k );
	move( itop, ilast );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mesher.h ===
#ifndef __glumesher_h_
#define __glumesher_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mesher.h - $Revision: 1.1 $
 */

#include "hull.h"

class TrimRegion;
class Backend;
class Pool;
class GridTrimVertex;


class Mesher : public Hull {
public:
     			Mesher( Backend & );
			~Mesher( void );
    void		init( unsigned int );
    void		mesh( void );

private:
    static const float	ZERO;
    Backend&		backend;

    Pool		p;
    unsigned int	stacksize;
    GridTrimVertex **	vdata;
    GridTrimVertex *	last[2];
    int			itop;
    int			lastedge;

    inline void		openMesh( void );
    inline void		swapMesh( void );
    inline void		closeMesh( void );
    inline int		isCcw( int );
    inline int		isCw( int );
    inline void		clearStack( void );
    inline void		push( GridTrimVertex * );
    inline void		pop( long );
    inline void		move( int, int );
    inline int 		equal( int, int );
    inline void 	copy( int, int );
    inline void 	output( int );
    void		addUpper( void );
    void		addLower( void );
    void		addLast( void );
    void		finishUpper( GridTrimVertex * );
    void		finishLower( GridTrimVertex * );
};
#endif /* __glumesher_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mapdescv.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mapdescv.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mystring.h"
#include "mymath.h"
#include "nurbscon.h"
#include "mapdesc.h"

/*--------------------------------------------------------------------------
 * calcPartialVelocity - calculate maximum magnitude of a given partial
 * derivative
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcPartialVelocity (
    REAL *p,
    int	 stride,
    int	 ncols,
    int  partial,
    REAL range )
{
    REAL tmp[MAXORDER][MAXCOORDS];
    REAL mag[MAXORDER];

    assert( ncols <= MAXORDER );

    int j, k, t;
    // copy inhomogeneous control points into temporary array
    for( j=0; j != ncols; j++ ) 
	for( k=0; k != inhcoords; k++ )
	    tmp[j][k] = p[j*stride + k];

    for( t=0; t != partial; t++ ) 
	for( j=0; j != ncols-t-1; j++ ) 
	    for( k=0; k != inhcoords; k++ ) 
		tmp[j][k] = tmp[j+1][k] - tmp[j][k];

    // compute magnitude and store in mag array
    for( j=0; j != ncols-partial; j++ ) {
	mag[j] = 0.0;
	for( k=0; k != inhcoords; k++ )
	    mag[j] += tmp[j][k] * tmp[j][k];
    }

    // compute scale factor
    REAL fac = 1;
    REAL invt = 1.0 / range;
    for( t = ncols-1; t != ncols-1-partial; t-- ) 
	fac *= t * invt;

    // compute max magnitude of all entries in array
    REAL max = 0.0;
    for( j=0; j != ncols-partial; j++ )
	if( mag[j] > max ) max = mag[j];
    max = fac * ::sqrtf( (float) max );

    return max;
}

/*--------------------------------------------------------------------------
 * calcPartialVelocity - calculate maximum magnitude of a given partial
 * derivative
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcPartialVelocity (
    REAL *dist,
    REAL *p,
    int	 rstride,
    int	 cstride,
    int	 nrows,
    int	 ncols,
    int  spartial,
    int  tpartial,
    REAL srange, 
    REAL trange,
    int  side )
{
    REAL tmp[MAXORDER][MAXORDER][MAXCOORDS];
    REAL mag[MAXORDER][MAXORDER];

    assert( nrows <= MAXORDER );
    assert( ncols <= MAXORDER );

    REAL *tp = &tmp[0][0][0];
    REAL *mp = &mag[0][0];
    const int istride = sizeof( tmp[0]) / sizeof( tmp[0][0][0] );
    const int jstride = sizeof( tmp[0][0]) / sizeof( tmp[0][0][0] );
    const int kstride = sizeof( tmp[0][0][0]) / sizeof( tmp[0][0][0] );
    const int mistride = sizeof( mag[0]) / sizeof( mag[0][0] );
    const int mjstride = sizeof( mag[0][0]) / sizeof( mag[0][0] );
    const int idist = nrows * istride;
    const int jdist = ncols * jstride;
    const int kdist = inhcoords * kstride;
    const int id = idist - spartial * istride;
    const int jd = jdist - tpartial * jstride;

    {
	// copy control points
	REAL *ti = tp;
	REAL *qi = p;
	REAL *til = tp + idist;
	for( ; ti != til; ) {
	    REAL *tj = ti;
	    REAL *qj = qi;
	    REAL *tjl = ti + jdist;
	    for( ; tj != tjl;  ) {
		for( int k=0; k != inhcoords; k++ ) {
		    tj[k] = qj[k];
		}
		tj += jstride;
		qj += cstride;
	    }
	    ti += istride;
	    qi += rstride; 
	}
    }

    {
        // compute (s)-partial derivative control points
	REAL *til = tp + idist - istride;
	const REAL *till = til - ( spartial * istride );
	for( ; til != till; til -= istride )
	    for( REAL *ti = tp; ti != til; ti += istride )
		for( REAL *tj = ti, *tjl = tj + jdist; tj != tjl; tj += jstride )
		    for( int k=0; k != inhcoords; k++ )
			tj[k] = tj[k+istride] - tj[k];
    }

    {
        // compute (s,t)-partial derivative control points
	REAL *tjl = tp + jdist - jstride;
	const REAL *tjll = tjl - ( tpartial * jstride );
	for( ; tjl != tjll; tjl -= jstride )
	    for( REAL *tj = tp; tj != tjl; tj += jstride )
		for( REAL *ti = tj, *til = ti + id; ti != til; ti += istride )
		    for( int k=0; k != inhcoords; k++ ) 
			ti[k] = ti[k+jstride] - ti[k];

    }

    REAL max = 0.0;
    {
	// compute magnitude and store in mag array
	memset( (void *) mp, 0, sizeof( mag ) );
	for( REAL *ti = tp, *mi = mp, *til = tp + id; ti != til; ti += istride, mi += mistride )
	    for( REAL *tj = ti, *mj = mi, *tjl = ti + jd; tj != tjl; tj += jstride, mj += mjstride ) {
		for( int k=0; k != inhcoords; k++ )
		   *mj += tj[k] * tj[k];
		if( *mj > max ) max = *mj;
	    }

    }

    int i, j;

    // compute scale factor
    REAL fac = 1.0;
    {
	REAL invs = 1.0 / srange;
	REAL invt = 1.0 / trange;
	for( int s = nrows-1, slast = s-spartial; s != slast; s-- ) 
	    fac *= s * invs;
	for( int t = ncols-1, tlast = t-tpartial; t != tlast; t-- ) 
	    fac *= t * invt;
    }

    if( side == 0 ) {
	// compute max magnitude of first and last column
	dist[0] = 0.0;
	dist[1] = 0.0;
	for( i=0; i != nrows-spartial; i++ ) {
	    j = 0;
	    if( mag[i][j] > dist[0] ) dist[0] = mag[i][j];
    
	    j = ncols-tpartial-1;
	    if( mag[i][j] > dist[1] ) dist[1] = mag[i][j];
	}
	dist[0] = fac * ::sqrtf( dist[0] );
	dist[1] = fac * ::sqrtf( dist[1] );
    } else if( side == 1 ) {
	// compute max magnitude of first and last row
	dist[0] = 0.0;
	dist[1] = 0.0;
	for( j=0; j != ncols-tpartial; j++ ) {
	    i = 0;
	    if( mag[i][j] > dist[0] ) dist[0] = mag[i][j];
    
	    i = nrows-spartial-1;
	    if( mag[i][j] > dist[1] ) dist[1] = mag[i][j];
	}
	dist[0] = fac * ::sqrtf( dist[0] );
	dist[1] = fac * ::sqrtf( dist[1] );
    }

    max = fac * ::sqrtf( (float) max );

    return max;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\monotoni.h ===
#ifndef __glumonotonizer_h_
#define __glumonotonizer_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * monotonizer.h - $Revision: 1.1 $
 */

#include "mysetjmp.h"
#include "types.h"

class Arc;
class ArcTessellator;
class Pool;
class Bin;
class PwlArcPool;
class Mapdesc;

class Monotonizer {
    ArcTessellator&	arctessellator;
    Pool&		arcpool;
    Pool&		pwlarcpool;
    jmp_buf&		nurbsJmpBuf;

    enum dir 		{ down, same, up, none };
    void		tessellate( Arc *, REAL );
    void		monotonize( Arc *, Bin & );
    int			isMonotone( Arc * );
public:
    			Monotonizer( ArcTessellator& at, Pool& ap, Pool& p, jmp_buf& j ) 
				: arctessellator(at), arcpool(ap), pwlarcpool(p), nurbsJmpBuf(j) {}
    int			decompose( Bin &, REAL );
};
#endif /* __glumonotonizer_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mybstrin.h ===
#ifndef __glumybstring_h_
#define __glumybstring_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mybstring.h - $Revision: 1.1 $
 */

#ifdef STANDALONE
extern "C" void	bcopy(const void *, void *, int);
extern "C" void	bzero(void *, int);
#else
#include <bstring.h>
#endif

#endif /* __glumybstring_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mycode.cxx ===
#include "mymath.h"

#ifdef NEEDCEILF

float ceilf( float x )
{
   if( x < 0 ) {
	float nx = -x;
	int ix = (int) nx;
	return (float) -ix;
   } else {
	int ix = (int) x;
	if( x == (float) ix ) return x;
	return (float) (ix+1);
   }
}

float floorf( float x )
{
   if( x < 0 ) {
	float nx = -x;
	int ix = (int) nx;
	if( nx == (float) ix ) return x;
	return (float) -(ix+1);
   } else {
	int ix = (int) x;
	return (float) ix;
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\myassert.h ===
#ifndef __glumyassert_h_
#define __glumyassert_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * myassert.h - $Revision: 1.1 $
 */

#ifdef STANDALONE
#define assert(EX) ((void)0)
#endif

#ifdef LIBRARYBUILD
#include <assert.h>
#endif

#ifdef GLBUILD
#define assert(EX) ((void)0)
#endif

#endif /* __glumyassert_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\monotoni.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * monotonizer.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "arc.h"
#include "arctess.h"
#include "bezierar.h"
#include "bin.h"
#include "mapdesc.h"
#include "nurbscon.h"
#include "subdivid.h"

/*-----------------------------------------------------------------------------
 * Subdivider::decompose - break all curves into monotone arcs
 *-----------------------------------------------------------------------------
 */
int
Subdivider::decompose( Bin& bin, REAL geo_stepsize )
{
    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( ! jarc->isTessellated() ) {
	    /* points have not been transformed, therefore they may be either
	       homogeneous or inhomogeneous */
	    tessellate( jarc, geo_stepsize );
	    if( jarc->isDisconnected() || jarc->next->isDisconnected() ) 
		return 1;
	}
    }

    for( jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	monotonize( jarc, bin );
    }

#ifndef NDEBUG
    for( jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	assert( isMonotone( jarc ) != 0 );
    }
#endif

    return 0;
}

void
Subdivider::tessellate( Arc_ptr jarc, REAL geo_stepsize )
{
    BezierArc *b = jarc->bezierArc;
    Mapdesc *mapdesc = b->mapdesc;

    if( mapdesc->isRational() ) {
	REAL max = mapdesc->calcVelocityRational( b->cpts, b->stride, b->order );
	REAL arc_stepsize = (max > 1.0) ? (1.0/max) : 1.0; 
	if( jarc->bezierArc->order != 2 )
	    arctessellator.tessellateNonlinear( jarc, geo_stepsize, arc_stepsize, 1 );
	else {
	    arctessellator.tessellateLinear( jarc, geo_stepsize, arc_stepsize, 1 );
	}
    } else { 
	REAL max = mapdesc->calcVelocityNonrational( b->cpts, b->stride, b->order );
	REAL arc_stepsize = (max > 1.0) ? (1.0/max) : 1.0; 
	if( jarc->bezierArc->order != 2 )
	    arctessellator.tessellateNonlinear( jarc, geo_stepsize, arc_stepsize, 0 );
	else {
	    arctessellator.tessellateLinear( jarc, geo_stepsize, arc_stepsize, 0 );
	}
    }
}

/*-------------------------------------------------------------------------
 * Subdivider::monotonize - break up a jordan arc into s,t-monotone
 *	components.  This code will remove degenerate segments, including
 *	arcs of only a single point.
 *-------------------------------------------------------------------------
 */
void
Subdivider::monotonize( Arc_ptr jarc, Bin& bin )
{
    TrimVertex  *firstvert = jarc->pwlArc->pts;
    TrimVertex  *lastvert = firstvert + (jarc->pwlArc->npts - 1);
    long	uid = jarc->nuid;
    arc_side	side = jarc->getside();
    dir		sdir = none;
    dir		tdir = none;
    int 	degenerate = 1;

    int		nudegenerate;
    int		change;

    for( TrimVertex *vert = firstvert; vert != lastvert; vert++ ) {

        nudegenerate = 1;
        change = 0;

	/* check change relative to s axis, clear degenerate bit if needed */
        REAL sdiff = vert[1].param[0] - vert[0].param[0]; 
        if( sdiff == 0 ) {
	    if( sdir != same ) {
	        sdir = same;
		change = 1;
	    }
        } else if( sdiff < 0.0 ) {
	    if( sdir != down ) {
	        sdir = down;
		change = 1;
	    }
	    nudegenerate = 0;
        } else {
	    if( sdir != up ) {
	        sdir = up;
		change = 1;
	    }
	    nudegenerate = 0;
        }
    
	/* check change relative to t axis, clear degenerate bit if needed */
        REAL tdiff = vert[1].param[1] - vert[0].param[1]; 
        if( tdiff == 0 ) { 
	    if( tdir != same ) {
	        tdir = same;
	 	change = 1;
	    }
        } else if( tdiff < 0.0 ) {
	    if( tdir != down ) {
	        tdir = down;
		change = 1;
	    }
	    nudegenerate = 0;
        } else {
	    if( tdir != up ) {
	        tdir = up;
		change = 1;
	    }
	    nudegenerate = 0;
        }
    
	if( change ) {
	    if( ! degenerate ) {
	        /* make last segment into separate pwl curve */
	        jarc->pwlArc->npts = vert - firstvert + 1;
#ifdef NT
                // This works under NT.

                Arc_ptr prevjarc;

                prevjarc = jarc;
                jarc     = new(arcpool) Arc( side, uid );

                jarc->append( prevjarc );

#else
                // However this doesn't.
	        jarc = new(arcpool) Arc( side, uid )->append( jarc );
#endif
	        jarc->pwlArc = new(pwlarcpool) PwlArc();
		bin.addarc( jarc );
	    }
	    firstvert = jarc->pwlArc->pts = vert;
	    degenerate = nudegenerate;
	} 
    }
    jarc->pwlArc->npts = vert - firstvert + 1;

    if( degenerate ) {
	/* remove jarc from circularly linked list */
	jarc->prev->next = jarc->next;
	jarc->next->prev = jarc->prev;

        assert( jarc->prev->check(  ) != 0 );
        assert( jarc->next->check(  ) != 0 );

	/* remove jarc from bin */
	bin.remove_this_arc( jarc  );

	jarc->pwlArc->deleteMe( pwlarcpool ); jarc->pwlArc = 0;
	jarc->deleteMe( arcpool );
    } 
}

/*-------------------------------------------------------------------------
 * Subdivider::isMonotone - return true if arc is monotone AND non-degenerate
 *-------------------------------------------------------------------------
 */
int
Subdivider::isMonotone( Arc_ptr jarc )
{
    TrimVertex  *firstvert = jarc->pwlArc->pts;
    TrimVertex  *lastvert = firstvert + (jarc->pwlArc->npts - 1);

    if( firstvert == lastvert ) return 1;

    TrimVertex	*vert = firstvert;
    enum dir	sdir;
    enum dir	tdir;

    REAL diff = vert[1].param[0] - vert[0].param[0]; 
    if( diff == 0.0 ) 
        sdir = same;
    else if( diff < 0.0 )
        sdir = down;
    else
        sdir = up;

    diff = vert[1].param[1] - vert[0].param[1]; 
    if( diff == 0.0 ) 
        tdir = same;
    else if( diff < 0.0 )
        tdir = down;
    else
        tdir = up;

    if( (sdir == same) && (tdir == same) ) return 0;
    
    for( ++vert ; vert != lastvert; vert++ ) {
        diff = vert[1].param[0] - vert[0].param[0]; 
        if( diff == 0.0 ) {
	    if( sdir != same ) return 0;
        } else if( diff < 0.0 ) {
	    if( sdir != down ) return 0;
        } else {
	    if( sdir != up ) return 0;
        }

        diff = vert[1].param[1] - vert[0].param[1]; 
        if( diff == 0.0 ) {
	    if( tdir != same ) return 0;
        } else if( diff < 0.0 ) {
	    if( tdir != down ) return 0;
        } else {
	    if( tdir != up ) return 0;
        }
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mymath.h ===
#ifndef __glumymath_h_
#define __glumymath_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mymath.h - $Revision: 1.1 $
 */

#ifdef GLBUILD
#define sqrtf		gl_fsqrt
#endif

#if GLBUILD | STANDALONE
#define M_SQRT2		1.41421356237309504880
#define ceilf		myceilf
#define floorf		myfloorf	
#define sqrtf		sqrt
extern "C" double	sqrt(double);
extern "C" float	ceilf(float);
extern "C" float	floorf(float);
#define NEEDCEILF
#endif

#ifdef LIBRARYBUILD
#include <math.h>
#endif

#endif /* __glumymath_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mystdio.h ===
#ifndef __glumystdio_h_
#define __glumystdio_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mystdio.h - $Revision: 1.4 $
 */

#ifdef STANDALONE
inline void dprintf( char *, ... ) { }
#endif

#ifdef LIBRARYBUILD
#ifndef NDEBUG
#include <stdio.h>
#define dprintf printf
#else
inline void dprintf( char *, ... ) { }
#endif
#endif

#ifdef GLBUILD
inline void dprintf( char *, ... ) { }
#endif

#ifndef NULL
#define NULL		0
#endif

#endif /* __glumystdio_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mysetjmp.h ===
#ifndef __glumysetjmp_h_
#define __glumysetjmp_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mysetjmp.h - $Revision: 1.3 $
 */

#ifdef STANDALONE
struct JumpBuffer;
#ifdef NT
extern "C" JumpBuffer * GLOS_CCALL newJumpbuffer( void );
extern "C" void GLOS_CCALL deleteJumpbuffer(JumpBuffer *);
extern "C" void GLOS_CCALL mylongjmp( JumpBuffer *, int );
extern "C" int GLOS_CCALL mysetjmp( JumpBuffer * );
#else
extern "C" JumpBuffer *newJumpbuffer( void );
extern "C" void deleteJumpbuffer(JumpBuffer *);
extern "C" void mylongjmp( JumpBuffer *, int );
extern "C" int mysetjmp( JumpBuffer * );
#endif // NT
#endif

extern "C" DWORD gluMemoryAllocationFailed;

#ifdef GLBUILD
#define setjmp		gl_setjmp
#define longjmp 	gl_longjmp
#endif

#if LIBRARYBUILD | GLBUILD | defined(NT)
#include <setjmp.h>
#ifndef NT
#include <stdlib.h>
#endif

struct JumpBuffer {
    jmp_buf	buf;
};

#ifdef NT
inline JumpBuffer * GLOS_CCALL
#else
inline JumpBuffer *
#endif
newJumpbuffer( void )
{
#ifdef NT
    JumpBuffer *tmp;
    tmp = (JumpBuffer *) LocalAlloc(LMEM_FIXED, sizeof(JumpBuffer));
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
#else
    return (JumpBuffer *) malloc( sizeof( JumpBuffer ) );
#endif
}

#ifdef NT
inline void GLOS_CCALL
#else
inline void
#endif
deleteJumpbuffer(JumpBuffer *jb)
{
#ifdef NT
   LocalFree( (HLOCAL) jb);
#else
   free( (void *) jb);
#endif
}

#ifdef NT
inline void GLOS_CCALL
#else
inline void
#endif
mylongjmp( JumpBuffer *j, int code ) 
{
    ::longjmp( j->buf, code );
}

#ifdef NT
inline int GLOS_CCALL
#else
inline int
#endif
mysetjmp( JumpBuffer *j )
{
    return ::setjmp( j->buf );
}
#endif

#endif /* __glumysetjmp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\nurbscon.h ===
#ifndef __glunurbsconsts_h_
#define __glunurbsconsts_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbsconsts.h - $Revision: 1.1 $
 */

/* NURBS Properties - one set per map, 
   each takes a single INREAL arg */
#define N_SAMPLING_TOLERANCE  	1
#define N_S_RATE		6
#define N_T_RATE		7
#define N_CLAMPFACTOR		13
#define 	N_NOCLAMPING		0.0
#define N_MINSAVINGS		14
#define 	N_NOSAVINGSSUBDIVISION	0.0

/* NURBS Properties - one set per map, 
   each takes an enumerated value */
#define N_CULLING		2
#define 	N_NOCULLING		0.0
#define 	N_CULLINGON		1.0
#define N_SAMPLINGMETHOD	10
#define 	N_NOSAMPLING		0.0
#define 	N_FIXEDRATE		3.0
#define 	N_DOMAINDISTANCE	2.0
#define 	N_PARAMETRICDISTANCE	5.0
#define 	N_PATHLENGTH		6.0
#define 	N_SURFACEAREA		7.0
#define N_BBOX_SUBDIVIDING	17
#define 	N_NOBBOXSUBDIVISION	0.0
#define 	N_BBOXTIGHT		1.0
#define 	N_BBOXROUND		2.0

/* NURBS Rendering Properties - one set per renderer
   each takes an enumerated value */
#define N_DISPLAY		3
#define 	N_FILL			1.0 	
#define 	N_OUTLINE_POLY		2.0
#define 	N_OUTLINE_TRI		3.0
#define 	N_OUTLINE_QUAD	 	4.0
#define 	N_OUTLINE_PATCH		5.0
#define 	N_OUTLINE_PARAM		6.0
#define 	N_OUTLINE_PARAM_S	7.0
#define 	N_OUTLINE_PARAM_ST 	8.0
#define 	N_OUTLINE_SUBDIV 	9.0
#define 	N_OUTLINE_SUBDIV_S 	10.0
#define 	N_OUTLINE_SUBDIV_ST 	11.0
#define 	N_ISOLINE_S		12.0
#define N_ERRORCHECKING		4
#define 	N_NOMSG			0.0
#define 	N_MSG			1.0

/* GL 4.0 propeties not defined above */
#ifndef N_PIXEL_TOLERANCE
#define N_PIXEL_TOLERANCE	N_SAMPLING_TOLERANCE
#define N_ERROR_TOLERANCE	20
#define N_SUBDIVISIONS		5
#define N_TILES			8
#define N_TMP1			9
#define N_TMP2			N_SAMPLINGMETHOD
#define N_TMP3			11
#define N_TMP4			12
#define N_TMP5			N_CLAMPFACTOR
#define N_TMP6			N_MINSAVINGS
#define N_S_STEPS		N_S_RATE
#define N_T_STEPS		N_T_RATE
#endif

/* NURBS Rendering Properties - one set per map,
   each takes an INREAL matrix argument */
#define N_CULLINGMATRIX		1
#define N_SAMPLINGMATRIX	2
#define N_BBOXMATRIX		3


/* NURBS Rendering Properties - one set per map,
   each takes an INREAL vector argument */
#define	N_BBOXSIZE		4

/* type argument for trimming curves */
#ifndef N_P2D
#define N_P2D 	 		0x8	
#define N_P2DR 	 		0xd
#endif	

#endif /* __glunurbsconsts_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mystdlib.h ===
#ifndef __glumystdlib_h_
#define __glumystdlib_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mystdlib.h - $Revision: 1.1 $
 */

#ifdef STANDALONE
#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

extern "C" void 	abort( void );
extern "C" void *	malloc( size_t );
extern "C" void 	free( void * );
#endif

#ifdef LIBRARYBUILD
#include <stdlib.h>
#endif

#ifdef GLBUILD
#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

extern "C" void 	abort( void );
extern "C" void *	malloc( size_t );
extern "C" void 	free( void * );
#endif

#endif /* __glumystdlib_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\mystring.h ===
#ifndef __glumystring_h_
#define __glumystring_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mystring.h - $Revision: 1.1 $
 */

#ifdef STANDALONE

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef NT
extern "C" void *	GLOS_CCALL memcpy(void *, const void *, size_t);
extern "C" void *	GLOS_CCALL memset(void *, int, size_t);
#else
extern "C" void *	memcpy(void *, const void *, size_t);
extern "C" void *	memset(void *, int, size_t);
#endif
#endif

#ifdef GLBUILD
#define memcpy(a,b,c)	bcopy(b,a,c)
#define memset(a,b,c)	bzero(a,c)
extern "C" void		bcopy(const void *, void *, int);
extern "C" void		bzero(void *, int);
#endif

#ifdef LIBRARYBUILD
#include <string.h>
#endif

#endif /* __glumystring_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\nurbstes.h ===
#ifndef __glunurbstess_h_
#define __glunurbstess_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbstess.h - $Revision: 1.2 $
 */

#include "mysetjmp.h"
#include "subdivid.h"
#include "renderhi.h"
#include "backend.h"
#include "maplist.h"
#include "reader.h"
#include "nurbscon.h"

class Knotvector;
class Quilt;
class DisplayList;
class BasicCurveEvaluator;
class BasicSurfaceEvaluator;

class NurbsTessellator {
public:
    			NurbsTessellator( BasicCurveEvaluator &c,
                                          BasicSurfaceEvaluator &e );
    			~NurbsTessellator( void );

    void     		getnurbsproperty( long, INREAL * );
    void     		getnurbsproperty( long, long, INREAL * );
    void     		setnurbsproperty( long, INREAL );
    void     		setnurbsproperty( long, long, INREAL );
    void		setnurbsproperty( long, long, INREAL * );
    void		setnurbsproperty( long, long, INREAL *, long, long );

    // called before a tessellation begins/ends
    virtual void	bgnrender( void );
    virtual void	endrender( void );

    // called to make a display list of the output vertices
    virtual void	makeobj( int n );
    virtual void	closeobj( void );

    // called when a error occurs
    virtual void	errorHandler( int );

    void     		bgnsurface( long );
    void     		endsurface( void );
    void     		bgntrim( void );
    void     		endtrim( void );
    void     		bgncurve( long );
    void     		endcurve( void );
    void     		pwlcurve( long, INREAL[], long, long );
    void     		nurbscurve( long, INREAL[], long, INREAL[], long, long );
    void     		nurbssurface( long, INREAL[], long, INREAL[], long, long,
			    INREAL[], long, long, long );

    void 		defineMap( long, long, long );
    void		redefineMaps( void );

    // recording of input description
    void 		discardRecording( void * );
    void * 		beginRecording( void );
    void 		endRecording( void );
    void 		playRecording( void * );

protected:
    Renderhints		renderhints;
    Maplist		maplist;
    Backend		backend;

private:

    void		resetObjects( void );
    int			do_check_knots( Knotvector *, char * );
    void		do_nurbserror( int );
    void		do_bgncurve( O_curve * );
    void		do_endcurve( void );
    void		do_freeall( void );
    void		do_freecurveall( O_curve * );
    void		do_freebgntrim( O_trim * );
    void		do_freebgncurve( O_curve * );
    void		do_freepwlcurve( O_pwlcurve * );
    void		do_freenurbscurve( O_nurbscurve * );
    void		do_freenurbssurface( O_nurbssurface * );
    void 		do_freebgnsurface( O_surface * );
    void		do_bgnsurface( O_surface * );
    void		do_endsurface( void );
    void		do_bgntrim( O_trim * );
    void		do_endtrim( void );
    void		do_pwlcurve( O_pwlcurve * );
    void		do_nurbscurve( O_nurbscurve * );
    void		do_nurbssurface( O_nurbssurface * );
    void		do_freenurbsproperty( Property * );
    void		do_setnurbsproperty( Property * );
    void		do_setnurbsproperty2( Property * );

    Subdivider		subdivider;
    JumpBuffer* 	jumpbuffer;
    Pool		o_pwlcurvePool;
    Pool		o_nurbscurvePool;
    Pool		o_curvePool;
    Pool		o_trimPool;
    Pool		o_surfacePool;
    Pool		o_nurbssurfacePool;
    Pool		propertyPool;
    Pool		quiltPool;
    TrimVertexPool	extTrimVertexPool;

    int			inSurface;		/* bgnsurface seen */
    int			inCurve;		/* bgncurve seen */
    int			inTrim;			/* bgntrim seen */
    int			isCurveModified;	/* curve changed */
    int			isTrimModified;		/* trim curves changed */
    int			isSurfaceModified;	/* surface changed */
    int			isDataValid;		/* all data is good */
    int			numTrims;		/* valid trim regions */
    int			playBack;

    O_trim**		nextTrim;		/* place to link o_trim */
    O_curve**		nextCurve;		/* place to link o_curve */
    O_nurbscurve**	nextNurbscurve;		/* place to link o_nurbscurve */
    O_pwlcurve**	nextPwlcurve;		/* place to link o_pwlcurve */
    O_nurbssurface**	nextNurbssurface;	/* place to link o_nurbssurface */

    O_surface*		currentSurface;
    O_trim*		currentTrim;
    O_curve*		currentCurve;

    DisplayList		*dl;

};

#endif /* __glunurbstess_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\nurbsint.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbsinterfac.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "nurbscon.h"
#include "nurbstes.h"
#include "bufpool.h"
#include "quilt.h"
#include "displayl.h"
#include "knotvect.h"
#include "mapdesc.h"

#define THREAD( work, arg, cleanup ) \
	if( dl ) {\
	    arg->save = 1;\
	    dl->append( (PFVS)&NurbsTessellator::work, (void *) arg, (PFVS)&NurbsTessellator::cleanup );\
 	} else {\
	    arg->save = 0;\
	    work( arg );\
	}

#define THREAD2( work ) \
	if( dl ) {\
	    dl->append( (PFVS)&NurbsTessellator::work, 0, 0 );\
 	} else {\
	    work( );\
	}

NurbsTessellator::NurbsTessellator( BasicCurveEvaluator &c, BasicSurfaceEvaluator& e) 
	: subdivider( renderhints, backend ),
	  backend( c, e ),
	  maplist( backend ),
	  o_pwlcurvePool( sizeof( O_pwlcurve ), 32, "o_pwlcurvePool" ),
	  o_nurbscurvePool( sizeof( O_nurbscurve ), 32, "o_nurbscurvePool"),
	  o_curvePool( sizeof( O_curve ), 32,  "o_curvePool" ),
	  o_trimPool( sizeof( O_trim ), 32,  "o_trimPool" ),
	  o_surfacePool( sizeof( O_surface ), 1, "o_surfacePool" ),
	  o_nurbssurfacePool( sizeof( O_nurbssurface ), 4, "o_nurbssurfacePool" ),
	  propertyPool( sizeof( Property ), 32, "propertyPool" ),
          quiltPool( sizeof( Quilt  ), 32, "quiltPool" )
{
    dl		= 0;
    inSurface	= 0;
    inCurve	= 0;
    inTrim	= 0;
    playBack	= 0;
    jumpbuffer  = newJumpbuffer();
    subdivider.setJumpbuffer( jumpbuffer );
}

NurbsTessellator::~NurbsTessellator( void ) 
{
    if( inTrim ) {
	do_nurbserror( 12 );
	endtrim();
    }

    if( inSurface ) {
        *nextNurbssurface = 0;
        do_freeall();
    }

    if (jumpbuffer) {
        deleteJumpbuffer(jumpbuffer);
	jumpbuffer= 0;
    }	
}

/*-----------------------------------------------------------------------------
 * bgnsurface - allocate and initialize an o_surface structure
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::bgnsurface( long nuid )
{
    O_surface *o_surface = new(o_surfacePool) O_surface;
    o_surface->nuid = nuid;
    THREAD( do_bgnsurface, o_surface, do_freebgnsurface );
}

/*-----------------------------------------------------------------------------
 * bgncurve - allocate an initialize an o_curve structure
 * 
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::bgncurve( long nuid )
{
    O_curve *o_curve = new(o_curvePool) O_curve;
    o_curve->nuid = nuid;
    THREAD( do_bgncurve, o_curve, do_freebgncurve );
}
/*-----------------------------------------------------------------------------
 * endcurve -
 * 
 * Client:
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::endcurve( void )
{
    THREAD2( do_endcurve );
}

/*-----------------------------------------------------------------------------
 * endsurface - user level end of surface call
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::endsurface( void )
{
    THREAD2( do_endsurface );
}


/*-----------------------------------------------------------------------------
 * bgntrim - allocate and initialize a new trim loop structure (o_trim )
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::bgntrim( void )
{
    O_trim *o_trim = new(o_trimPool) O_trim;
    THREAD( do_bgntrim, o_trim, do_freebgntrim );
}

/*-----------------------------------------------------------------------------
 * endtrim -
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::endtrim( void )
{
    THREAD2( do_endtrim );
}


/*-----------------------------------------------------------------------------
 * pwlcurve -
 *
 *      count        - number of points on curve
 *      array        - array of points on curve
 *      byte_stride  - distance between points in bytes
 *      type         - valid data flag
 *
 * Client: Gl user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::pwlcurve( long count, INREAL array[], long byte_stride, long type )
{
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
	return;
    }

    if ( (type != N_P2D) && (type != N_P2DR) ) {
	do_nurbserror( 22 );
	isDataValid = 0;
	return;
    }
    if( count < 0 ) {
	do_nurbserror( 33 );
	isDataValid = 0;
	return;
    }
    if( byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

#ifdef NOTDEF
    if( mapdesc->isRational() ) {
	INREAL *p = array;
	INREAL x = p[0]; INREAL y = p[1]; INREAL w = p[2];
	p = (INREAL *) (((char *) p) + byte_stride);
	for( long i = 1; i != count; i++ ) {
	    if( p[0] == x && p[1] == y && p[2] == w ) break;
	    x = p[0]; y = p[1]; w = p[2];
	    p = (INREAL *) (((char *) p) + byte_stride);
	}
	if( i != count ) {
	    do_nurbserror( 37 );
	    dprintf( "point %d (%f,%f)\n", i, x, y );
	    isDataValid = 0;
	    return;
	}
    } else {
	INREAL *p = array;
	INREAL x = p[0]; INREAL y = p[1];
	p = (INREAL *) (((char *) p) + byte_stride);
	for( long i = 1; i != count; i++ ) {
	    if( p[0] == x && p[1] == y ) break;
	    x = p[0]; y = p[1];
	    p = (INREAL *) (((char *) p) + byte_stride);
	}
	if( i != count ) {
	    do_nurbserror( 37 );
	    dprintf( "point %d (%f,%f)\n", i, x, y );
	    isDataValid = 0;
	    return;
	}
    }
#endif

    O_pwlcurve	*o_pwlcurve = new(o_pwlcurvePool) O_pwlcurve( type, count, array, byte_stride, extTrimVertexPool.get((int)count) );
    THREAD( do_pwlcurve, o_pwlcurve, do_freepwlcurve );
}


/*-----------------------------------------------------------------------------
 * nurbscurve -
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::nurbscurve(
    long nknots, 		/* number of p knots */
    INREAL knot[], 		/* nondecreasing knot values in p */
    long byte_stride,		/* distance in bytes between control points */
    INREAL ctlarray[], 		/* pointer to first control point */
    long order,			/* order of spline */
    long type )			/* description of range space */
{

    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
	return;
    }

    if( ctlarray == 0 ) {
	do_nurbserror( 36 );
	isDataValid = 0;
	return;
    }

    if( byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

    Knotvector knots;

    knots.init( nknots, byte_stride, order, knot );
    if( do_check_knots( &knots, "curve" ) ) return;
    
    O_nurbscurve *o_nurbscurve = new(o_nurbscurvePool) O_nurbscurve(type);
    o_nurbscurve->bezier_curves = new(quiltPool) Quilt(mapdesc);
    o_nurbscurve->bezier_curves->toBezier( knots,ctlarray, mapdesc->getNcoords() );
 
    THREAD( do_nurbscurve, o_nurbscurve, do_freenurbscurve );
}


/*-----------------------------------------------------------------------------
 * nurbssurface -
 *
 * Client: User routine
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::nurbssurface(
    long sknot_count,		/* number of s knots */
    INREAL sknot[],		/* nondecreasing knot values in s */
    long tknot_count, 		/* number of t knots */
    INREAL tknot[],		/* nondecreasing knot values in t */
    long s_byte_stride,		/* s step size in memory bytes */
    long t_byte_stride,		/* t step size in memory bytes */
    INREAL ctlarray[],		/* pointer to first control point */
    long sorder,		/* order of the spline in s parameter */
    long torder,		/* order of the spline in t parameter */
    long type)			/* description of range space */
{ 
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
	return;
    }

    if( s_byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

    if( t_byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

    Knotvector sknotvector, tknotvector;

    sknotvector.init( sknot_count, s_byte_stride, sorder, sknot );
    if( do_check_knots( &sknotvector, "surface" ) ) return;

    tknotvector.init( tknot_count, t_byte_stride, torder, tknot );
    if( do_check_knots( &tknotvector, "surface" ) ) return;

    O_nurbssurface *o_nurbssurface = new(o_nurbssurfacePool) O_nurbssurface(type);
    o_nurbssurface->bezier_patches = new(quiltPool) Quilt(mapdesc);

    o_nurbssurface->bezier_patches->toBezier( sknotvector, tknotvector,
	ctlarray, mapdesc->getNcoords() ); 
    THREAD( do_nurbssurface, o_nurbssurface, do_freenurbssurface );
}


/*-----------------------------------------------------------------------------
 * setnurbsproperty -
 * 
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::setnurbsproperty( long tag, INREAL value )
{
    if( ! renderhints.isProperty( tag ) ) {
	do_nurbserror( 26 );
    } else {
	Property *prop = new(propertyPool) Property( tag, value );
	THREAD( do_setnurbsproperty, prop, do_freenurbsproperty );
    }
}

/*-----------------------------------------------------------------------------
 * setnurbsproperty -
 * 
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::setnurbsproperty( long type, long tag, INREAL value )
{
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	return;
    }

    if( ! mapdesc->isProperty( tag ) ) {
	do_nurbserror( 26 );
	return;
    }

    Property *prop = new(propertyPool) Property( type, tag, value );
    THREAD( do_setnurbsproperty2, prop, do_freenurbsproperty );
}


/*-----------------------------------------------------------------------------
 * getnurbsproperty - 
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::getnurbsproperty( long tag, INREAL *value )
{
    if( renderhints.isProperty( tag ) ) {
	*value = renderhints.getProperty( tag );
    } else {
	do_nurbserror( 26 );
    }
}

/*-----------------------------------------------------------------------------
 * getnurbsproperty - 
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::getnurbsproperty( long type, long tag, INREAL *value )
{
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) 
	do_nurbserror( 35 );

    if( mapdesc->isProperty( tag  ) ) {
	*value = mapdesc->getProperty( tag );
    } else {
	do_nurbserror( 26 );
    }
}

/*--------------------------------------------------------------------------
 * setnurbsproperty - accept a user supplied matrix as culling or sampling mat
 *--------------------------------------------------------------------------
 */

void 
NurbsTessellator::setnurbsproperty( long type, long purpose, INREAL *mat )
{
    // XXX - cannot be put in display list
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
    } else if( purpose == N_BBOXSIZE ) {
	mapdesc->setBboxsize( mat );
    } else {
#ifndef NDEBUG
        dprintf( "ERRORRORRORR!!!\n");
#endif
    }
}

/*--------------------------------------------------------------------------
 * setnurbsproperty - accept a user supplied matrix as culling or sampling mat
 *--------------------------------------------------------------------------
 */

void 
NurbsTessellator::setnurbsproperty( long type, long purpose, INREAL *mat, 
    long rstride, long cstride )
{
    // XXX - cannot be put in display list
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
    } else if( purpose == N_CULLINGMATRIX ) {
	mapdesc->setCmat( mat, rstride, cstride );
    } else if( purpose == N_SAMPLINGMATRIX ) {
	mapdesc->setSmat( mat, rstride, cstride );
    } else if( purpose == N_BBOXMATRIX ) {
	mapdesc->setBmat( mat, rstride, cstride );
    } else {
#ifndef NDEBUG
        dprintf( "ERRORRORRORR!!!\n");
#endif
    }
}

void	
NurbsTessellator::redefineMaps( void )
{
    maplist.initialize();
}

void 	
NurbsTessellator::defineMap( long type, long rational, long ncoords )
{
    maplist.define( type, (int) rational, (int) ncoords );
}

void 
NurbsTessellator::discardRecording( void *_dl )
{
    delete (DisplayList *) _dl;
}

void * 
NurbsTessellator::beginRecording( void )
{
    dl = new DisplayList( this );
    return (void *) dl;
}

void 
NurbsTessellator::endRecording( void )
{
    dl->endList();
    dl = 0;
}

void 
NurbsTessellator::playRecording( void *_dl )
{
    playBack = 1;
    bgnrender();
    ((DisplayList *)_dl)->play();
    endrender();
    playBack = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\nurbstes.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbstess.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mysetjmp.h"
#include "mystdio.h"
#include "nurbscon.h"
#include "nurbstes.h"
#include "bufpool.h"
#include "quilt.h"
#include "knotvect.h"
#include "mapdesc.h"
#include "maplist.h"

void
NurbsTessellator::resetObjects( void )
{
    subdivider.clear();
}

void
NurbsTessellator::makeobj( int )
{
#ifndef NDEBUG
   dprintf( "makeobj\n" );
#endif
}

void
NurbsTessellator::closeobj( void )
{
#ifndef NDEBUG
   dprintf( "closeobj\n" );
#endif
}

void
NurbsTessellator::bgnrender( void )
{
#ifndef NDEBUG
   dprintf( "bgnrender\n" );
#endif
}

void
NurbsTessellator::endrender( void )
{
#ifndef NDEBUG
    dprintf( "endrender\n" );
#endif
}

/*-----------------------------------------------------------------------------
 * do_freebgnsurface - free o_surface structure 
 *
 * Client: do_freeall(), bgnsurface()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freebgnsurface( O_surface *o_surface )
{
    o_surface->deleteMe( o_surfacePool );
}


/*-----------------------------------------------------------------------------
 * do_bgnsurface - begin the display of a surface
 *
 * Client: bgnsurface()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_bgnsurface( O_surface *o_surface )
{
    if( inSurface ) {
	do_nurbserror( 27 );
	endsurface();
    }
    inSurface = 1;

    if( ! playBack ) bgnrender();

    isTrimModified = 0;
    isSurfaceModified = 0;
    isDataValid = 1;
    numTrims = 0;
    currentSurface = o_surface;
    nextTrim = &( currentSurface->o_trim );
    nextNurbssurface = &( currentSurface->o_nurbssurface );
}

/*-----------------------------------------------------------------------------
 * do_bgncurve - begin the display of a curve 
 * 
 * Client: bgncurve()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_bgncurve( O_curve *o_curve )
{
    if ( inCurve ) {
	do_nurbserror( 6 );
	endcurve();
    }

    inCurve = 1;
    currentCurve = o_curve;
    currentCurve->curvetype = ct_none;

    if( inTrim ) {
        if( *nextCurve != o_curve ) {
	    isCurveModified = 1;
	    *nextCurve = o_curve;
	}
    } else {
        if( ! playBack ) bgnrender();
        isDataValid = 1;
    }
    nextCurve = &(o_curve->next);
    nextPwlcurve = &(o_curve->curve.o_pwlcurve);
    nextNurbscurve = &(o_curve->curve.o_nurbscurve);
}

/*-----------------------------------------------------------------------------
 * do_endcurve -
 * 
 * Client: endcurve()
 *-----------------------------------------------------------------------------
 */
    
void
NurbsTessellator::do_endcurve( void )
{
    if( ! inCurve ) {
	do_nurbserror( 7 );
	return;
    }
    inCurve = 0;

    *nextCurve = 0;
    if (currentCurve->curvetype == ct_nurbscurve)
	*nextNurbscurve = 0;
    else
	*nextPwlcurve = 0;

    if ( ! inTrim ) {
        if( ! isDataValid ) {
            do_freecurveall( currentCurve ); 
	    return;
        }

	int errval;
	errval = ::mysetjmp( jumpbuffer );
	if( errval == 0 ) {
	    if( currentCurve->curvetype == ct_nurbscurve ) {
		subdivider.beginQuilts();
		for( O_nurbscurve *n = currentCurve->curve.o_nurbscurve; n != 0; n = n->next ) 
		    subdivider.addQuilt( n->bezier_curves );
		subdivider.endQuilts();
		subdivider.drawCurves(); 
		if( ! playBack ) endrender();
	    } else {
		/* XXX */
	        if( ! playBack ) endrender();
	        /*do_draw_pwlcurve( currentCurve->curve.o_pwlcurve ) */;
	        do_nurbserror( 9 );
	    }
	} else {
	    if( ! playBack ) endrender();
	    do_nurbserror( errval );
	}
	do_freecurveall( currentCurve );
	resetObjects();
    }
}

/*-----------------------------------------------------------------------------
 * do_endsurface - mark end of surface, display surface, free immediate data 
 *
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_endsurface( void )
{
    if( inTrim ) {
	do_nurbserror( 12 );
	endtrim();
    }

    if( ! inSurface ) {
	do_nurbserror( 13 );
	return;
    }
    inSurface = 0;

    *nextNurbssurface = 0;

    if( ! isDataValid ) {
        do_freeall( ); 
	return;
    }

    if( *nextTrim != 0 ) {
	isTrimModified = 1;
        *nextTrim = 0;
    }

    int errval;

    errval = ::mysetjmp( jumpbuffer );
    if( errval == 0 ) {
        if( numTrims > 0 ) {

	    subdivider.beginTrims();
	    for( O_trim	*trim = currentSurface->o_trim; trim; trim = trim->next ) {
		subdivider.beginLoop();
		for( O_curve *curve = trim->o_curve; curve; curve = curve->next ) {  
		    curve->used = 0;
		    assert( curve->curvetype != ct_none );
		    if (curve->curvetype == ct_pwlcurve) {
			O_pwlcurve *c = curve->curve.o_pwlcurve; 
			subdivider.addArc( c->npts, c->pts, curve->nuid );
		    } else {
			Quilt	   *quilt = curve->curve.o_nurbscurve->bezier_curves;
			Quiltspec  *qspec = quilt->qspec;
			REAL       *cpts  = quilt->cpts + qspec->offset;
			REAL       *cptsend = cpts + (qspec->width * qspec->order * qspec->stride);
			for( ; cpts != cptsend; cpts += qspec->order*qspec->stride ) 
			     subdivider.addArc( cpts, quilt, curve->nuid );
		    }
		}
		subdivider.endLoop();
	    }
	    subdivider.endTrims();
	}

	subdivider.beginQuilts();
	for( O_nurbssurface *n = currentSurface->o_nurbssurface; n; n = n->next ) 
	    subdivider.addQuilt( n->bezier_patches );
	subdivider.endQuilts();
        subdivider.drawSurfaces( currentSurface->nuid ); 
	if( ! playBack ) endrender();
    } else {
	if( ! playBack ) endrender();
	do_nurbserror( errval );
    }

    do_freeall( );
    resetObjects();
}

/*-----------------------------------------------------------------------------
 * do_freeall - free all data allocated in immediate mode
 *
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freeall( void )
{
    for( O_trim *o_trim = currentSurface->o_trim; o_trim; ) {
	O_trim *next_o_trim = o_trim->next;
        for( O_curve *curve = o_trim->o_curve; curve; ) {
	    O_curve *next_o_curve = curve->next;
	    do_freecurveall( curve );
	    curve = next_o_curve;
	}
	if( o_trim->save == 0 ) do_freebgntrim( o_trim );
	o_trim = next_o_trim;
    }

    O_nurbssurface *nurbss, *next_nurbss;
    for( nurbss= currentSurface->o_nurbssurface; nurbss; nurbss = next_nurbss) {
	next_nurbss = nurbss->next;
	if( nurbss->save == 0 )
	    do_freenurbssurface( nurbss );
	else
	    nurbss->used = 0;
    }

    if( currentSurface->save == 0 ) do_freebgnsurface( currentSurface );
}

void
NurbsTessellator::do_freecurveall( O_curve *curve )
{
    assert( curve->curvetype != ct_none );

    if( curve->curvetype == ct_nurbscurve ) {
	O_nurbscurve *ncurve, *next_ncurve;
	for( ncurve=curve->curve.o_nurbscurve; ncurve; ncurve=next_ncurve ) {
	    next_ncurve = ncurve->next;
	    if( ncurve->save == 0 )
		do_freenurbscurve( ncurve );
	    else
		ncurve->used = 0;
	}
    } else {
	O_pwlcurve *pcurve, *next_pcurve;
	for( pcurve=curve->curve.o_pwlcurve; pcurve; pcurve=next_pcurve ) {
	    next_pcurve = pcurve->next;
	    if( pcurve->save == 0 )
		do_freepwlcurve( pcurve );
	    else
		pcurve->used = 0;
	}
    }
    if( curve->save == 0 )
        do_freebgncurve( curve );
}


/*-----------------------------------------------------------------------------
 * do_freebgntrim - free the space allocated for a trim loop
 *
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freebgntrim( O_trim *o_trim )
{ 
    o_trim->deleteMe( o_trimPool );
}


/*-----------------------------------------------------------------------------
 * do_bgntrim - link in a trim loop to the current trimmed surface description
 *
 * Client: bgntrim()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_bgntrim( O_trim *o_trim )
{

    if( ! inSurface ) {
	do_nurbserror( 15 );
	bgnsurface( 0 );
	inSurface = 2;
    }

    if( inTrim ) {
	do_nurbserror( 16 );
	endtrim();
    }
    inTrim = 1;

    if( *nextTrim != o_trim ) {
	isTrimModified = 1;	
        *nextTrim = o_trim;
    }

    currentTrim = o_trim;
    nextTrim = &(o_trim->next);
    nextCurve = &(o_trim->o_curve);
}


/*-----------------------------------------------------------------------------
 * do_endtrim - mark the end of the current trim loop 
 *
 * Client: endtrim()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_endtrim( void )
{
    if( ! inTrim ) {
	do_nurbserror( 17 );
	return;
    }
    inTrim = 0;

    if( currentTrim->o_curve == 0 ) {
	do_nurbserror( 18 );
	isDataValid = 0;
    }

    numTrims++;
   
    if( *nextCurve != 0 ) {
	isTrimModified = 1;
        *nextCurve = 0;	
    }
}

/*-----------------------------------------------------------------------------
 * do_freepwlcurve -
 * 
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freepwlcurve( O_pwlcurve *o_pwlcurve )
{
    o_pwlcurve->deleteMe( o_pwlcurvePool );
}

void
NurbsTessellator::do_freebgncurve( O_curve *o_curve )
{
    o_curve->deleteMe( o_curvePool );
}

/*-----------------------------------------------------------------------------
 * do_pwlcurve - link in pwl trim loop to the current surface description
 * 
 * Client: pwlcurve()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_pwlcurve( O_pwlcurve *o_pwlcurve )
{
    if( ! inTrim ) {
	do_nurbserror( 19 );
	if( o_pwlcurve->save == 0 )
	    do_freepwlcurve(o_pwlcurve );
	return;
    }

    if( ! inCurve ) {
	bgncurve( 0 );
	inCurve = 2;
    }

    if( o_pwlcurve->used ) {
	do_nurbserror( 20 );
	isDataValid = 0;
	return;
    } else
        o_pwlcurve->used = 1;

    if( currentCurve->curvetype == ct_none ) {
        currentCurve->curvetype = ct_pwlcurve;
    } else if( currentCurve->curvetype != ct_pwlcurve ) {
	do_nurbserror( 21 );
	isDataValid = 0;
	return;
    }
	
    if( *nextPwlcurve != o_pwlcurve ) {
	isCurveModified = 1;
        *nextPwlcurve = o_pwlcurve;
    }
    nextPwlcurve = &(o_pwlcurve->next);

    if( o_pwlcurve->owner != currentCurve ) {
	isCurveModified = 1;
	o_pwlcurve->owner = currentCurve;
    }

    if( (inCurve == 2) ) 
	endcurve();
}


/*-----------------------------------------------------------------------------
 * do_freenurbscurve -
 * 
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freenurbscurve( O_nurbscurve *o_nurbscurve )
{
    o_nurbscurve->bezier_curves->deleteMe( quiltPool );
    o_nurbscurve->deleteMe( o_nurbscurvePool );
}


/*-----------------------------------------------------------------------------
 * do_nurbscurve -
 * 
 * Client: nurbscurve() 
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_nurbscurve( O_nurbscurve *o_nurbscurve )
{
    if ( ! inCurve ) {
	bgncurve( 0 );
	inCurve = 2;
    }

    if( o_nurbscurve->used ) {
	/* error - curve was already called in current surface */
	do_nurbserror( 23 );
	isDataValid = 0;
	return;
    } else
        o_nurbscurve->used = 1;

    if( currentCurve->curvetype == ct_none ) {
        currentCurve->curvetype = ct_nurbscurve;
    } else if( currentCurve->curvetype != ct_nurbscurve ) {
	do_nurbserror( 24 );
	isDataValid = 0;
	return;
    }
	
    if( *nextNurbscurve != o_nurbscurve ) {
	isCurveModified = 1;
	*nextNurbscurve = o_nurbscurve;
    }

    nextNurbscurve = &(o_nurbscurve->next);

    if( o_nurbscurve->owner != currentCurve ) {
	isCurveModified = 1;
	o_nurbscurve->owner = currentCurve;
    }

    if( o_nurbscurve->owner == 0 )
	isCurveModified = 1;
    
    if( inCurve == 2 )
        endcurve();
}


/*-----------------------------------------------------------------------------
 * do_freenurbssurface -
 *
 * Client:
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::do_freenurbssurface( O_nurbssurface *o_nurbssurface )
{
    o_nurbssurface->bezier_patches->deleteMe( quiltPool );
    o_nurbssurface->deleteMe( o_nurbssurfacePool );
}

/*-----------------------------------------------------------------------------
 * do_nurbssurface -
 * 
 * Client: nurbssurface()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_nurbssurface( O_nurbssurface *o_nurbssurface )
{
    if( ! inSurface ) {
	bgnsurface( 0 );
	inSurface = 2;
    }

    if( o_nurbssurface->used ) {
	/* error - surface was already called in current block */
	do_nurbserror( 25 );
	isDataValid = 0;
	return;
    } else
        o_nurbssurface->used = 1;

    if( *nextNurbssurface != o_nurbssurface ) {
	isSurfaceModified = 1;
        *nextNurbssurface  = o_nurbssurface;
    }

    if( o_nurbssurface->owner != currentSurface ) {
	isSurfaceModified = 1;
	o_nurbssurface->owner = currentSurface;
    }
    nextNurbssurface = &(o_nurbssurface->next);

    if( inSurface == 2  )
	endsurface();
}


/*-----------------------------------------------------------------------------
 * do_freenurbsproperty
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::do_freenurbsproperty( Property *prop )
{
    prop->deleteMe( propertyPool );
}

    
/*-----------------------------------------------------------------------------
 * do_setnurbsproperty -
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::do_setnurbsproperty( Property *prop )
{
    renderhints.setProperty( prop->tag, prop->value );
    if( prop->save == 0 )
	do_freenurbsproperty( prop );
}

void
NurbsTessellator::do_setnurbsproperty2( Property *prop )
{
    Mapdesc *mapdesc = maplist.find( prop->type );

    mapdesc->setProperty( prop->tag, prop->value );
    if( prop->save == 0 )
	do_freenurbsproperty( prop );
}

void
NurbsTessellator::errorHandler( int )
{
}

void
NurbsTessellator::do_nurbserror( int msg )
{
    errorHandler( msg );
}

int 
NurbsTessellator::do_check_knots( Knotvector *knots, char *msg )
{
    int status = knots->validate();
    if( status ) {
	do_nurbserror( status );
        if( renderhints.errorchecking != N_NOMSG ) knots->show( msg );
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\patch.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by ederal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patch.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1992
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mymath.h"
#include "mystring.h"
#include "patch.h"
#include "mapdesc.h"
#include "quilt.h"
#include "nurbscon.h"
#include "simplema.h" //for abs function in ::singleStep();


/*--------------------------------------------------------------------------
 * Patch - copy patch from quilt and transform control points
 *--------------------------------------------------------------------------
 */

Patch::Patch( Quilt_ptr geo, REAL *pta, REAL *ptb, Patch *n )
{
/* pspec[i].range is uninit here */
    mapdesc = geo->mapdesc;
    cullval = mapdesc->isCulling() ? CULL_ACCEPT : CULL_TRIVIAL_ACCEPT;
    notInBbox = mapdesc->isBboxSubdividing() ? 1 : 0;
    needsSampling = mapdesc->isRangeSampling() ? 1 : 0;
    pspec[0].order = geo->qspec[0].order;
    pspec[1].order = geo->qspec[1].order;
    pspec[0].stride = pspec[1].order * MAXCOORDS;
    pspec[1].stride = MAXCOORDS;

    /* transform control points to sampling and culling spaces */
    REAL *ps  = geo->cpts;
    geo->select( pta, ptb );
    ps += geo->qspec[0].offset;
    ps += geo->qspec[1].offset;
    ps += geo->qspec[0].index * geo->qspec[0].order * geo->qspec[0].stride;
    ps += geo->qspec[1].index * geo->qspec[1].order * geo->qspec[1].stride;

    if( needsSampling ) {
	mapdesc->xformSampling( ps, geo->qspec[0].order, geo->qspec[0].stride, 
				geo->qspec[1].order, geo->qspec[1].stride,
			        spts, pspec[0].stride, pspec[1].stride );
    }

    if( cullval == CULL_ACCEPT  ) {
	mapdesc->xformCulling( ps, geo->qspec[0].order, geo->qspec[0].stride, 
			       geo->qspec[1].order, geo->qspec[1].stride,
			       cpts, pspec[0].stride, pspec[1].stride ); 
    }
    
    if( notInBbox ) {
	mapdesc->xformBounding( ps, geo->qspec[0].order, geo->qspec[0].stride, 
			       geo->qspec[1].order, geo->qspec[1].stride,
			       bpts, pspec[0].stride, pspec[1].stride ); 
    }
    
    /* set scale range */
    pspec[0].range[0] = geo->qspec[0].breakpoints[geo->qspec[0].index];
    pspec[0].range[1] = geo->qspec[0].breakpoints[geo->qspec[0].index+1];
    pspec[0].range[2] = pspec[0].range[1] - pspec[0].range[0];

    pspec[1].range[0] = geo->qspec[1].breakpoints[geo->qspec[1].index];
    pspec[1].range[1] = geo->qspec[1].breakpoints[geo->qspec[1].index+1];
    pspec[1].range[2] = pspec[1].range[1] - pspec[1].range[0];

    // may need to subdivide to match range of sub-patch
    if( pspec[0].range[0] != pta[0] ) {
	assert( pspec[0].range[0] < pta[0] );
	Patch lower( *this, 0, pta[0], 0 );
	*this = lower;
    }

    if( pspec[0].range[1] != ptb[0] ) {
	assert( pspec[0].range[1] > ptb[0] );
	Patch upper( *this, 0, ptb[0], 0 );
    }

    if( pspec[1].range[0] != pta[1] ) {
	assert( pspec[1].range[0] < pta[1] );
	Patch lower( *this, 1, pta[1], 0 );
	*this = lower;
    }

    if( pspec[1].range[1] != ptb[1] ) {
	assert( pspec[1].range[1] > ptb[1] );
	Patch upper( *this, 1, ptb[1], 0 );
    }
    checkBboxConstraint();
    next = n;
}

/*--------------------------------------------------------------------------
 * Patch - subdivide a patch along an isoparametric line
 *--------------------------------------------------------------------------
 */

Patch::Patch( Patch& upper, int param, REAL value, Patch *n )
{
    Patch& lower = *this;

    lower.cullval = upper.cullval;
    lower.mapdesc = upper.mapdesc;
    lower.notInBbox = upper.notInBbox;
    lower.needsSampling = upper.needsSampling;
    lower.pspec[0].order = upper.pspec[0].order;
    lower.pspec[1].order = upper.pspec[1].order;
    lower.pspec[0].stride = upper.pspec[0].stride;
    lower.pspec[1].stride = upper.pspec[1].stride;
    lower.next = n;

    /* reset scale range */
    switch( param ) {
	case 0: {
    	    REAL d = (value-upper.pspec[0].range[0]) / upper.pspec[0].range[2];
	    if( needsSampling )
                mapdesc->subdivide( upper.spts, lower.spts, d, pspec[1].order,
                        pspec[1].stride, pspec[0].order, pspec[0].stride );

    	    if( cullval == CULL_ACCEPT ) 
	        mapdesc->subdivide( upper.cpts, lower.cpts, d, pspec[1].order,
                        pspec[1].stride, pspec[0].order, pspec[0].stride );

    	    if( notInBbox ) 
	        mapdesc->subdivide( upper.bpts, lower.bpts, d, pspec[1].order,
                        pspec[1].stride, pspec[0].order, pspec[0].stride );
	    
            lower.pspec[0].range[0] = upper.pspec[0].range[0];
            lower.pspec[0].range[1] = value;
    	    lower.pspec[0].range[2] = value - upper.pspec[0].range[0];
            upper.pspec[0].range[0] = value;
    	    upper.pspec[0].range[2] = upper.pspec[0].range[1] - value;

            lower.pspec[1].range[0] = upper.pspec[1].range[0];
            lower.pspec[1].range[1] = upper.pspec[1].range[1];
    	    lower.pspec[1].range[2] = upper.pspec[1].range[2];
	    break;
	}
	case 1: {
    	    REAL d = (value-upper.pspec[1].range[0]) / upper.pspec[1].range[2];
	    if( needsSampling )
	        mapdesc->subdivide( upper.spts, lower.spts, d, pspec[0].order,
                        pspec[0].stride, pspec[1].order, pspec[1].stride );
    	    if( cullval == CULL_ACCEPT ) 
	        mapdesc->subdivide( upper.cpts, lower.cpts, d, pspec[0].order,
                        pspec[0].stride, pspec[1].order, pspec[1].stride );
    	    if( notInBbox ) 
	        mapdesc->subdivide( upper.bpts, lower.bpts, d, pspec[0].order,
                        pspec[0].stride, pspec[1].order, pspec[1].stride );
            lower.pspec[0].range[0] = upper.pspec[0].range[0];
            lower.pspec[0].range[1] = upper.pspec[0].range[1];
    	    lower.pspec[0].range[2] = upper.pspec[0].range[2];

            lower.pspec[1].range[0] = upper.pspec[1].range[0];
            lower.pspec[1].range[1] = value;
    	    lower.pspec[1].range[2] = value - upper.pspec[1].range[0];
            upper.pspec[1].range[0] = value;
    	    upper.pspec[1].range[2] = upper.pspec[1].range[1] - value;
	    break;
	}
    }

    // inherit bounding box
    if( mapdesc->isBboxSubdividing() && ! notInBbox )
	memcpy( lower.bb, upper.bb, sizeof( bb ) );
	    
    lower.checkBboxConstraint();
    upper.checkBboxConstraint();
}

/*--------------------------------------------------------------------------
 * clamp - clamp the sampling rate to a given maximum
 *--------------------------------------------------------------------------
 */

void
Patch::clamp( void )
{
    if( mapdesc->clampfactor != N_NOCLAMPING ) {
	pspec[0].clamp( mapdesc->clampfactor );
	pspec[1].clamp( mapdesc->clampfactor );
    }
}

void 
Patchspec::clamp( REAL clampfactor )
{
    if( sidestep[0] < minstepsize )
        sidestep[0] = clampfactor * minstepsize;
    if( sidestep[1] < minstepsize )
        sidestep[1] = clampfactor * minstepsize;
    if( stepsize < minstepsize )
        stepsize = clampfactor * minstepsize;
}

void 
Patch::checkBboxConstraint( void )
{
    if( notInBbox && 
	mapdesc->bboxTooBig( bpts, pspec[0].stride, pspec[1].stride,
				   pspec[0].order, pspec[1].order, bb ) != 1 ) {
	notInBbox = 0;
    }
}

void
Patch::bbox( void )
{
    if( mapdesc->isBboxSubdividing() )
	mapdesc->surfbbox( bb );
}

/*--------------------------------------------------------------------------
 * getstepsize - compute the sampling density across the patch
 * 		and determine if patch needs to be subdivided
 *--------------------------------------------------------------------------
 */

void
Patch::getstepsize( void )
{
    pspec[0].minstepsize = pspec[1].minstepsize = 0;
    pspec[0].needsSubdivision = pspec[1].needsSubdivision = 0;

    if( mapdesc->isConstantSampling() ) {
	// fixed number of samples per patch in each direction
	// maxsrate is number of s samples per patch
	// maxtrate is number of t samples per patch
        pspec[0].getstepsize( mapdesc->maxsrate );
        pspec[1].getstepsize( mapdesc->maxtrate );

    } else if( mapdesc->isDomainSampling() ) {
	// maxsrate is number of s samples per unit s length of domain
	// maxtrate is number of t samples per unit t length of domain
        pspec[0].getstepsize( mapdesc->maxsrate * pspec[0].range[2] );
        pspec[1].getstepsize( mapdesc->maxtrate * pspec[1].range[2] );

    } else if( ! needsSampling ) {
	pspec[0].singleStep();
	pspec[1].singleStep();
    } else {
	// upper bound on path length between sample points
        REAL tmp[MAXORDER][MAXORDER][MAXCOORDS];
	const int trstride = sizeof(tmp[0]) / sizeof(REAL);
	const int tcstride = sizeof(tmp[0][0]) / sizeof(REAL); 

	assert( pspec[0].order <= MAXORDER );
    
	/* points have been transformed, therefore they are homogeneous */

	int val = mapdesc->project( spts, pspec[0].stride, pspec[1].stride, 
		 &tmp[0][0][0], trstride, tcstride, 
		 pspec[0].order, pspec[1].order ); 
        if( val == 0 ) {
	    // control points cross infinity, therefore partials are undefined
            pspec[0].getstepsize( mapdesc->maxsrate );
            pspec[1].getstepsize( mapdesc->maxtrate );
        } else {
            REAL t1 = mapdesc->getProperty( N_PIXEL_TOLERANCE );
	    REAL t2 = mapdesc->getProperty( N_ERROR_TOLERANCE );
	    pspec[0].minstepsize = ( mapdesc->maxsrate > 0.0 ) ? 
			(pspec[0].range[2] / mapdesc->maxsrate) : 0.0;
	    pspec[1].minstepsize = ( mapdesc->maxtrate > 0.0 ) ? 
			(pspec[1].range[2] / mapdesc->maxtrate) : 0.0;
	    if( mapdesc->isParametricDistanceSampling() ) {
		// t2 is upper bound on the distance between surface and tessellant 
		REAL ssv[2], ttv[2];
		REAL ss = mapdesc->calcPartialVelocity( ssv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 2, 0, pspec[0].range[2], pspec[1].range[2], 0 );
		REAL st = mapdesc->calcPartialVelocity(   0, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 1, 1, pspec[0].range[2], pspec[1].range[2], -1 );
		REAL tt = mapdesc->calcPartialVelocity( ttv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 0, 2, pspec[0].range[2], pspec[1].range[2], 1 );
    
		if( ss != 0.0 && tt != 0.0 ) {
		    /* printf( "ssv[0] %g ssv[1] %g ttv[0] %g ttv[1] %g\n", 
			ssv[0], ssv[1], ttv[0], ttv[1] ); */
		    REAL ttq = ::sqrtf( (float) ss );
		    REAL ssq = ::sqrtf( (float) tt );
		    REAL ds = ::sqrtf( 4 * t2 * ttq / ( ss * ttq + st * ssq ) );
		    REAL dt = ::sqrtf( 4 * t2 * ssq / ( tt * ssq + st * ttq ) );
		    pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
		    REAL scutoff = 2.0 * t2 / ( pspec[0].range[2] * pspec[0].range[2]);
		    pspec[0].sidestep[0] = (ssv[0] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[0] ) : pspec[0].range[2];
		    pspec[0].sidestep[1] = (ssv[1] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[1] ) : pspec[0].range[2];
    
		    pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
		    REAL tcutoff = 2.0 * t2 / ( pspec[1].range[2] * pspec[1].range[2]);
		    pspec[1].sidestep[0] = (ttv[0] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[0] ) : pspec[1].range[2];
		    pspec[1].sidestep[1] = (ttv[1] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[1] ) : pspec[1].range[2];
		} else if( ss != 0.0 ) {
		    REAL x = pspec[1].range[2] * st;
		    REAL ds = ( ::sqrtf( x * x + 8.0 * t2 * ss ) - x ) / ss;
		    pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
		    REAL scutoff = 2.0 * t2 / ( pspec[0].range[2] * pspec[0].range[2]);
		    pspec[0].sidestep[0] = (ssv[0] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[0] ) : pspec[0].range[2];
		    pspec[0].sidestep[1] = (ssv[1] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[1] ) : pspec[0].range[2];
		    pspec[1].singleStep();
		} else if( tt != 0.0 ) {
		    REAL x = pspec[0].range[2] * st;
		    REAL dt = ( ::sqrtf( x * x + 8.0 * t2 * tt ) - x )  / tt;
		    pspec[0].singleStep();
		    REAL tcutoff = 2.0 * t2 / ( pspec[1].range[2] * pspec[1].range[2]);
		    pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
		    pspec[1].sidestep[0] = (ttv[0] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[0] ) : pspec[1].range[2];
		    pspec[1].sidestep[1] = (ttv[1] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[1] ) : pspec[1].range[2];
		} else {
		    if( 4.0 * t2  > st * pspec[0].range[2] * pspec[1].range[2] ) {
			pspec[0].singleStep();
			pspec[1].singleStep();
		    } else {
			REAL area = 4.0 * t2 / st;
			REAL ds = ::sqrtf( area * pspec[0].range[2] / pspec[1].range[2] );
			REAL dt = ::sqrtf( area * pspec[1].range[2] / pspec[0].range[2] );
			pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
			pspec[0].sidestep[0] = pspec[0].range[2];
			pspec[0].sidestep[1] = pspec[0].range[2];
	
			pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
			pspec[1].sidestep[0] = pspec[1].range[2];
			pspec[1].sidestep[1] = pspec[1].range[2];
		    }
		}
	    } else if( mapdesc->isPathLengthSampling() ) {
		// t1 is upper bound on path length
		REAL msv[2], mtv[2];
		REAL ms = mapdesc->calcPartialVelocity( msv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 1, 0, pspec[0].range[2], pspec[1].range[2], 0 );
		REAL mt = mapdesc->calcPartialVelocity( mtv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 0, 1, pspec[0].range[2], pspec[1].range[2], 1 );
		if( ms != 0.0 ) {
		    if( mt != 0.0 ) {
/*		    REAL d = t1 / ( ms * ms + mt * mt );*/
/*		    REAL ds = mt * d;*/
		    REAL ds = t1 / (2.0*ms);
/*		    REAL dt = ms * d;*/
		    REAL dt = t1 / (2.0*mt); 
			pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
			pspec[0].sidestep[0] = ( msv[0] * pspec[0].range[2] > t1 ) ? (t1 / msv[0]) : pspec[0].range[2];
			pspec[0].sidestep[1] = ( msv[1] * pspec[0].range[2] > t1 ) ? (t1 / msv[1]) : pspec[0].range[2];
	
			pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
			pspec[1].sidestep[0] = ( mtv[0] * pspec[1].range[2] > t1 ) ? (t1 / mtv[0]) : pspec[1].range[2];
			pspec[1].sidestep[1] = ( mtv[1] * pspec[1].range[2] > t1 ) ? (t1 / mtv[1]) : pspec[1].range[2];
		    } else {
			pspec[0].stepsize = ( t1 < ms * pspec[0].range[2] ) ? (t1 / ms) : pspec[0].range[2];
			pspec[0].sidestep[0] = ( msv[0] * pspec[0].range[2] > t1 ) ? (t1 / msv[0]) : pspec[0].range[2];
			pspec[0].sidestep[1] = ( msv[1] * pspec[0].range[2] > t1 ) ? (t1 / msv[1]) : pspec[0].range[2];
	
			pspec[1].singleStep();
		    }
		} else {
		    if( mt != 0.0 ) {
			pspec[0].singleStep();

			pspec[1].stepsize = ( t1 < mt * pspec[1].range[2] ) ? (t1 / mt) : pspec[1].range[2];
			pspec[1].sidestep[0] = ( mtv[0] * pspec[1].range[2] > t1 ) ? (t1 / mtv[0]) : pspec[1].range[2];
			pspec[1].sidestep[1] = ( mtv[1] * pspec[1].range[2] > t1 ) ? (t1 / mtv[1]) : pspec[1].range[2];
		    } else {
			pspec[0].singleStep();
			pspec[1].singleStep();
		    }
		}
	    } else if( mapdesc->isSurfaceAreaSampling() ) {
		// t is the square root of area
/*
		REAL msv[2], mtv[2];
		REAL ms = mapdesc->calcPartialVelocity( msv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 1, 0, pspec[0].range[2], pspec[1].range[2], 0 );
		REAL mt = mapdesc->calcPartialVelocity( mtv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 0, 1, pspec[0].range[2], pspec[1].range[2], 1 );
		if( ms != 0.0 &&  mt != 0.0 ) {
			REAL d = 1.0 / (ms * mt);
			t *= M_SQRT2;
			REAL ds = t * ::sqrtf( d * pspec[0].range[2] / pspec[1].range[2] );
			REAL dt = t * ::sqrtf( d * pspec[1].range[2] / pspec[0].range[2] );
			pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
			pspec[0].sidestep[0] = ( msv[0] * pspec[0].range[2] > t ) ? (t / msv[0]) : pspec[0].range[2];
			pspec[0].sidestep[1] = ( msv[1] * pspec[0].range[2] > t ) ? (t / msv[1]) : pspec[0].range[2];
	
			pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
			pspec[1].sidestep[0] = ( mtv[0] * pspec[1].range[2] > t ) ? (t / mtv[0]) : pspec[1].range[2];
			pspec[1].sidestep[1] = ( mtv[1] * pspec[1].range[2] > t ) ? (t / mtv[1]) : pspec[1].range[2];
		} else {
		    pspec[0].singleStep();
		    pspec[1].singleStep();
		}
*/
	    } else {
		pspec[0].singleStep();
		pspec[1].singleStep();
	    }
	}
    }

    dprintf( "sidesteps %g %g %g %g, stepsize %g %g\n",
	pspec[0].sidestep[0], pspec[0].sidestep[1],
	pspec[1].sidestep[0], pspec[1].sidestep[1],
	pspec[0].stepsize, pspec[1].stepsize );

    if( mapdesc->minsavings != N_NOSAVINGSSUBDIVISION ) {
	REAL savings = 1./(pspec[0].stepsize * pspec[1].stepsize) ;
	savings-= (2./( pspec[0].sidestep[0] + pspec[0].sidestep[1] )) * 
		  (2./( pspec[1].sidestep[0] + pspec[1].sidestep[1] ));
    
	savings *= pspec[0].range[2] * pspec[1].range[2];
	if( savings > mapdesc->minsavings ) {
	    pspec[0].needsSubdivision = pspec[1].needsSubdivision = 1;
	}
    }

    if( pspec[0].stepsize < pspec[0].minstepsize )  pspec[0].needsSubdivision =  1;
    if( pspec[1].stepsize < pspec[1].minstepsize )  pspec[1].needsSubdivision =  1;
    needsSampling = (needsSampling ? needsSamplingSubdivision() : 0);
}

void
Patchspec::singleStep()
{
    stepsize =  sidestep[0] =  sidestep[1] = abs(range[2]);
}

void 
Patchspec::getstepsize( REAL max ) // max is number of samples for entire patch
{
    stepsize = ( max >= 1.0 ) ? range[2] / max : range[2];
    if (stepsize < 0.0) {
       stepsize = -stepsize;
    }
    sidestep[0]	=  sidestep[1] = minstepsize = stepsize;
}

int
Patch::needsSamplingSubdivision( void )
{
    return (pspec[0].needsSubdivision || pspec[1].needsSubdivision) ? 1 : 0;
}

int
Patch::needsNonSamplingSubdivision( void )
{
    return notInBbox;
}

int
Patch::needsSubdivision( int param )
{
    return pspec[param].needsSubdivision;
}

int
Patch::cullCheck( void )
{
    if( cullval == CULL_ACCEPT ) 
	cullval = mapdesc->cullCheck( cpts, pspec[0].order,  pspec[0].stride,
					    pspec[1].order,  pspec[1].stride );
    return cullval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\patchlis.h ===
#ifndef __glupatchlist_h_
#define __glupatchlist_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patchlist.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"
#include "patch.h"

class Quilt;

class Patchlist {
friend class Subdivider;
public:
    			Patchlist( Quilt *, REAL *, REAL * );
    			Patchlist( Patchlist &, int ,  REAL );
    			~Patchlist();	
    void		bbox();
    int			cullCheck( void );
    void		getstepsize( void );
    int			needsNonSamplingSubdivision( void );
    int			needsSamplingSubdivision( void );
    int			needsSubdivision( int );
    REAL		getStepsize( int );
private:
    Patch		*patch;
    int			notInBbox;
    int			needsSampling;
    Pspec		pspec[2];
};

inline REAL
Patchlist::getStepsize( int param )
{
    return pspec[param].stepsize;
}

#endif /* __glupatchlist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\pwlarc.h ===
#ifndef __glupwlarc_h_
#define __glupwlarc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * pwlarc.h - $Revision: 1.1 $
 */

#include "myassert.h"
#include "nurbscon.h"

class TrimVertex;

struct PwlArc : public PooledObj { /* a piecewise-linear arc */
    TrimVertex *	pts;		/* sample points */
    int			npts;		/* number of sample points */
    long		type;		/* curve type */
    inline		PwlArc( void );
    inline		PwlArc( int, TrimVertex * );
    inline		PwlArc( int, TrimVertex *, long );
};

inline
PwlArc::PwlArc( void )
{
    type = N_P2D;
    pts = 0;
    npts = -1;
}

inline
PwlArc::PwlArc( int _npts, TrimVertex *_pts )
{
    pts = _pts;
    npts = _npts;
    type = N_P2D;
}

inline
PwlArc::PwlArc( int _npts, TrimVertex *_pts, long _type )
{
    pts = _pts;
    npts = _npts;
    type = _type;
}

#endif /* __glupwlarc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\patchlis.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patchlist.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "quilt.h"
#include "patchlis.h"
#include "patch.h"
#include "nurbscon.h"

Patchlist::Patchlist( Quilt *quilts, REAL *pta, REAL *ptb )
{
    patch = 0;
    for( Quilt *q = quilts; q; q = q->next ) 
	patch = new Patch( q, pta, ptb, patch );
    pspec[0].range[0] = pta[0];
    pspec[0].range[1] = ptb[0];
    pspec[0].range[2] = ptb[0] - pta[0];
 
    pspec[1].range[0] = pta[1];
    pspec[1].range[1] = ptb[1];
    pspec[1].range[2] = ptb[1] - pta[1];
}

Patchlist::Patchlist( Patchlist &upper, int param,  REAL value)
{
    Patchlist &lower = *this;
    patch = 0;
    for( Patch *p = upper.patch; p; p = p->next )
	patch = new Patch( *p, param, value, patch );

    if( param == 0 ) {
	lower.pspec[0].range[0] = upper.pspec[0].range[0];
	lower.pspec[0].range[1] = value;
	lower.pspec[0].range[2] = value - upper.pspec[0].range[0];
	upper.pspec[0].range[0] = value;
	upper.pspec[0].range[2] = upper.pspec[0].range[1] - value;
	lower.pspec[1] = upper.pspec[1];
    } else {
	lower.pspec[0] = upper.pspec[0];
	lower.pspec[1].range[0] = upper.pspec[1].range[0];
	lower.pspec[1].range[1] = value;
	lower.pspec[1].range[2] = value - upper.pspec[1].range[0];
	upper.pspec[1].range[0] = value;
	upper.pspec[1].range[2] = upper.pspec[1].range[1] - value;
    }
}

Patchlist::~Patchlist()
{
    while( patch ) {
	Patch *p = patch;
	patch = patch->next;
	delete p;
    }
}

int
Patchlist::cullCheck( void )
{
    for( Patch *p = patch; p; p = p->next )
	if( p->cullCheck() == CULL_TRIVIAL_REJECT )
	    return CULL_TRIVIAL_REJECT;
    return CULL_ACCEPT;
}

void
Patchlist::getstepsize( void )
{
    pspec[0].stepsize    = pspec[0].range[2];
    pspec[0].sidestep[0] = pspec[0].range[2];
    pspec[0].sidestep[1] = pspec[0].range[2];

    pspec[1].stepsize    = pspec[1].range[2];
    pspec[1].sidestep[0] = pspec[1].range[2];
    pspec[1].sidestep[1] = pspec[1].range[2];

    for( Patch *p = patch; p; p = p->next ) {
	p->getstepsize();
	p->clamp();
	pspec[0].stepsize    =  ((p->pspec[0].stepsize < pspec[0].stepsize) ? p->pspec[0].stepsize : pspec[0].stepsize);
	pspec[0].sidestep[0] =  ((p->pspec[0].sidestep[0] < pspec[0].sidestep[0]) ? p->pspec[0].sidestep[0] : pspec[0].sidestep[0]);
	pspec[0].sidestep[1] =  ((p->pspec[0].sidestep[1] < pspec[0].sidestep[1]) ? p->pspec[0].sidestep[1] : pspec[0].sidestep[1]);
	pspec[1].stepsize    =  ((p->pspec[1].stepsize < pspec[1].stepsize) ? p->pspec[1].stepsize : pspec[1].stepsize);
	pspec[1].sidestep[0] =  ((p->pspec[1].sidestep[0] < pspec[1].sidestep[0]) ? p->pspec[1].sidestep[0] : pspec[1].sidestep[0]);
	pspec[1].sidestep[1] =  ((p->pspec[1].sidestep[1] < pspec[1].sidestep[1]) ? p->pspec[1].sidestep[1] : pspec[1].sidestep[1]);
    }
}

void
Patchlist::bbox( void )
{
    for( Patch *p = patch; p; p = p->next )
	p->bbox();
}

int
Patchlist::needsNonSamplingSubdivision( void )
{
    notInBbox = 0;
    for( Patch *p = patch; p; p = p->next )
	notInBbox |= p->needsNonSamplingSubdivision();
    return notInBbox;
}

int
Patchlist::needsSamplingSubdivision( void )
{
    pspec[0].needsSubdivision = 0;
    pspec[1].needsSubdivision = 0;

    for( Patch *p = patch; p; p = p->next ) {
	pspec[0].needsSubdivision |= p->pspec[0].needsSubdivision;
	pspec[1].needsSubdivision |= p->pspec[0].needsSubdivision;
    }
    return (pspec[0].needsSubdivision || pspec[1].needsSubdivision) ? 1 : 0;
}

int
Patchlist::needsSubdivision( int param )
{
    return pspec[param].needsSubdivision;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\patch.h ===
#ifndef __glupatch_h_
#define __glupatch_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patch.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"

class Quilt;
class Mapdesc;


struct Pspec {
    REAL		range[3];
    REAL		sidestep[2];
    REAL		stepsize;
    REAL		minstepsize;
    int			needsSubdivision;
};

struct Patchspec : public Pspec {
    int			order;
    int			stride;
    void 		clamp( REAL );
    void 		getstepsize( REAL );
    void		singleStep( void );
};

class Patch {
public:
friend class Subdivider;
friend class Quilt;
friend class Patchlist;
    			Patch( Quilt *, REAL*, REAL *, Patch * );
    			Patch( Patch &, int, REAL, Patch * );
    void		bbox( void );
    void		clamp( void );
    void		getstepsize( void );
    int			cullCheck( void );
    int			needsSubdivision( int );
    int			needsSamplingSubdivision( void );
    int			needsNonSamplingSubdivision( void );

private:

    Mapdesc*		mapdesc;
    Patch*		next;
    int			cullval;
    int			notInBbox;
    int			needsSampling;
    REAL		cpts[MAXORDER*MAXORDER*MAXCOORDS]; //culling pts 
    REAL		spts[MAXORDER*MAXORDER*MAXCOORDS]; //sampling pts 
    REAL		bpts[MAXORDER*MAXORDER*MAXCOORDS]; //bbox pts
    Patchspec		pspec[2];
    void 		checkBboxConstraint( void );
    REAL 		bb[2][MAXCOORDS];
};
#endif /* __glupatch_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\quilt.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * quilt.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "quilt.h"
#include "backend.h"
#include "mapdesc.h"
#include "flist.h"
#include "knotvect.h"
#include "patchlis.h"
#include "math.h"     //fabs()
#define _abs_defined
#include "simplema.h" //min()

/* local preprocessor definitions */
#define DEF_PATCH_STEPSIZE	.2
#define fsizeof(x)		(sizeof(x)/sizeof(REAL))


Quilt::Quilt( Mapdesc *_mapdesc )
{
    mapdesc = _mapdesc;
}

void
Quilt::deleteMe( Pool& p )
{
    for( Quiltspec *q=qspec; q != eqspec; q++ ) {
#if 1
	if( q->breakpoints) delete[] q->breakpoints;  q->breakpoints = 0;
#else
	if( q->breakpoints) {
	   delete[] q->breakpoints;
	   q->breakpoints = 0;
printf("in here\n");
        }
#endif
    }
    if( cpts ) delete[] cpts;
    cpts = 0;
    PooledObj::deleteMe( p );
}

void
Quilt::show( void )
{
#ifndef NDEBUG
    int nc = mapdesc->getNcoords();
    REAL *ps  = cpts;
    ps += qspec[0].offset;
    ps += qspec[1].offset;
    for( int i=0; i!= qspec[0].order * qspec[0].width; i++ ) {
	for( int j = 0; j!= qspec[1].order * qspec[1].width; j++ ) {
	    for( int k=0; k < nc; k++ )
		dprintf(  "%g ", ps[i*qspec[0].stride + j*qspec[1].stride + k] );
	    dprintf(  "\n" );
	}
	dprintf(  "\n" );
    }
    dprintf( "\n" );
#endif
}

/*--------------------------------------------------------------------------
 * Quilt::select - find which map in each quilt contains the points
 *			pta and ptb with pta[i] < ptb[i]
 *--------------------------------------------------------------------------
 */

void
Quilt::select( REAL *pta, REAL *ptb )
{
    int dim = eqspec - qspec;
    for( int i=0; i<dim; i++) {
	for( int j=qspec[i].width-1; j>=0; j-- )
	    if( (qspec[i].breakpoints[j] <= pta[i]   ) &&
	    	(ptb[i] <= qspec[i].breakpoints[j+1] ) )
		 break;
	assert( j != -1 );
	qspec[i].index = j;
    }
}

void
Quilt::download( Backend &backend )
{
    if( getDimension() == 2 ) {
	REAL *ps  = cpts;
	ps += qspec[0].offset;
	ps += qspec[1].offset;
	ps += qspec[0].index * qspec[0].order * qspec[0].stride;
	ps += qspec[1].index * qspec[1].order * qspec[1].stride;
	backend.surfpts( mapdesc->getType(), ps,
		  qspec[0].stride,
		  qspec[1].stride,
		  qspec[0].order,
		  qspec[1].order,
		  qspec[0].breakpoints[qspec[0].index],
		  qspec[0].breakpoints[qspec[0].index+1],
		  qspec[1].breakpoints[qspec[1].index],
		  qspec[1].breakpoints[qspec[1].index+1] );
    } else {
	REAL *ps  = cpts;
	ps += qspec[0].offset;
	ps += qspec[0].index * qspec[0].order * qspec[0].stride;
	backend.curvpts( mapdesc->getType(), ps,
		      qspec[0].stride,
		      qspec[0].order,
		      qspec[0].breakpoints[qspec[0].index],
		      qspec[0].breakpoints[qspec[0].index+1] );
    }
}

/*--------------------------------------------------------------------------
 * Quilt::downloadAll - download each map that contains the current patch
 *--------------------------------------------------------------------------
 */

void
Quilt::downloadAll( REAL *pta, REAL *ptb, Backend &backend )
{
    for( Quilt *m = this; m; m=m->next ) {
	m->select( pta, ptb );
	m->download( backend );
    }
}

/*--------------------------------------------------------------------------
  * Quilt::isCulled - determine if an entire quilt is trivially rejected.
 *--------------------------------------------------------------------------
 */

int
Quilt::isCulled( void )
{
    if( mapdesc->isCulling() )
	return mapdesc->xformAndCullCheck( cpts + qspec[0].offset + qspec[1].offset,
			qspec[0].order * qspec[0].width, qspec[0].stride,
			qspec[1].order * qspec[1].width, qspec[1].stride );
    else
	return CULL_ACCEPT;
}

/*---------------------------------------------------------------------------
 * Quilt::getRange - retrieve the valid paramater range of a set of quilts
 *---------------------------------------------------------------------------
 */
void
Quilt::getRange( REAL *from, REAL *to, Flist& slist, Flist &tlist )
{
    getRange( from, to, 0, slist );
    getRange( from, to, 1, tlist );
}

/*---------------------------------------------------------------------------
 * Quilt::getRange - retrieve the valid paramater range of a set of quilts
 *---------------------------------------------------------------------------
 */
void
Quilt::getRange( REAL *from, REAL *to, int i, Flist &list )
{
    Quilt *maps = this;
    from[i] = maps->qspec[i].breakpoints[0];
    to[i]   = maps->qspec[i].breakpoints[maps->qspec[i].width];
    int maxpts = 0;
    for( Quilt_ptr m=maps; m; m=m->next ) {
	if( m->qspec[i].breakpoints[0] > from[i] )
	    from[i] = m->qspec[i].breakpoints[0];
	if( m->qspec[i].breakpoints[m->qspec[i].width] < to[i] )
	    to[i] = m->qspec[i].breakpoints[m->qspec[i].width];
	maxpts += m->qspec[i].width + 1;
    }

    list.grow( maxpts );

    for( m=maps; m; m=m->next )
	for( int j=0; j<=m->qspec[i].width; j++ ) {
	    list.add( m->qspec[i].breakpoints[j] );
	}

    list.filter( );
    list.taper( from[i], to[i] );
}

void
Quilt::getRange( REAL *from, REAL *to, Flist& slist )
{
    getRange( from, to, 0, slist );
}

void
Quilt::findRates( Flist& slist, Flist& tlist, REAL rate[2] )
{
    findSampleRates( slist, tlist );
    rate[0] = qspec[0].step_size;
    rate[1] = qspec[1].step_size;

    for( Quilt *q = next; q; q = q->next ) {
	q->findSampleRates( slist, tlist );
	if( q->qspec[0].step_size < rate[0] )
	    rate[0] = q->qspec[0].step_size;
	if( q->qspec[1].step_size < rate[1] )
	    rate[1] = q->qspec[1].step_size;
    }
}

void
Quilt::findSampleRates( Flist& slist, Flist& tlist )
{
    qspec[0].step_size = DEF_PATCH_STEPSIZE *
	    (qspec[0].breakpoints[qspec[0].width] - qspec[0].breakpoints[0]);
    qspec[1].step_size = DEF_PATCH_STEPSIZE *
	    (qspec[1].breakpoints[qspec[1].width] - qspec[1].breakpoints[0]);

    for( int i = slist.start; i < slist.end-1; i++ ) {
	for( int j = tlist.start; j < tlist.end-1; j++ ) {

	    REAL pta[2], ptb[2];
	    pta[0] = slist.pts[i];
	    ptb[0] = slist.pts[i+1];
	    pta[1] = tlist.pts[j];
	    ptb[1] = tlist.pts[j+1];
	    Patchlist patchlist( this, pta, ptb );
	    patchlist.getstepsize();
	
	    {
	    float edge_len_s = min(fabs(ptb[0]-pta[0]),1.0);
	    float edge_len_t = min(fabs(ptb[1]-pta[1]),1.0);

	    if( patchlist.getStepsize(0)/edge_len_s < qspec[0].step_size )
	       qspec[0].step_size = patchlist.getStepsize(0)/edge_len_s;
	    if( patchlist.getStepsize(1)/edge_len_t < qspec[1].step_size )
	      qspec[1].step_size = patchlist.getStepsize(1)/edge_len_t;
	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\quilt.h ===
#ifndef __gluquilt_h_
#define __gluquilt_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * quilt.h - $Revision: 1.1 $
 */

#include "defines.h"
#include "bufpool.h"
#include "types.h"

class Backend;
class Mapdesc;
class Flist;
class Knotvector;

/* constants for memory allocation of NURBS to Bezier conversion */ 
#define	MAXDIM 		2

struct Quiltspec { /* a specification for a dimension of a quilt */
    int			stride;		/* words between points */
    int			width;		/* number of segments */
    int			offset;		/* words to first point */
    int			order;		/* order */
    int			index;		/* current segment number */
    int			bdry[2];	/* boundary edge flag */
    REAL  		step_size;
    Knot *		breakpoints;
};

typedef Quiltspec *Quiltspec_ptr;
    
#ifdef NT
class Quilt : public PooledObj { public: /* an array of bezier patches */
#else
struct Quilt : PooledObj { /* an array of bezier patches */
#endif
    			Quilt( Mapdesc * );
    Mapdesc *		mapdesc;	/* map descriptor */
    REAL *		cpts;		/* control points */
    Quiltspec		qspec[MAXDIM];	/* the dimensional data */
    Quiltspec_ptr	eqspec;		/* qspec trailer */
    Quilt		*next;		/* next quilt in linked list */
			
    void		deleteMe( Pool& );
    void		toBezier( Knotvector &, INREAL *, long  );
    void		toBezier( Knotvector &, Knotvector &, INREAL *, long  );
    void		select( REAL *, REAL * );
    int			getDimension( void ) { return eqspec - qspec; }
    void 		download( Backend & );
    void		downloadAll( REAL *, REAL *, Backend & );
    int 		isCulled( void );
    void		getRange( REAL *, REAL *, Flist&, Flist & );
    void		getRange( REAL *, REAL *, int, Flist & );
    void		getRange( REAL *, REAL *, Flist&  );
    void		findRates( Flist& slist, Flist& tlist, REAL[2] );
    void		findSampleRates( Flist& slist, Flist& tlist );
    void		show();
};

typedef Quilt *Quilt_ptr;

#endif /* __gluquilt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\reader.h ===
#ifndef __glureader_h_
#define __glureader_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * reader.h - $Revision: 1.1 $
 */

#include "bufpool.h"
#include "types.h"

enum Curvetype { ct_nurbscurve, ct_pwlcurve, ct_none };
    
struct Property;
struct O_surface;
struct O_nurbssurface;
struct O_trim;
struct O_pwlcurve;
struct O_nurbscurve;
struct O_curve;
class  Quilt;
class TrimVertex;


struct O_curve : public PooledObj {
    union {
        O_nurbscurve	*o_nurbscurve;
        O_pwlcurve	*o_pwlcurve;
    } curve;
    Curvetype		curvetype;	/* arc type: pwl or nurbs	*/
    O_curve *		next;		/* next arc in loop		*/
    O_surface *		owner;		/* owning surface		*/
    int			used;		/* curve called in cur surf	*/
    int			save;		/* 1 if in display list		*/
    long		nuid;
    			O_curve() { next = 0; used = 0; owner = 0; 
				    curve.o_pwlcurve = 0; }
    };

struct O_nurbscurve : public PooledObj {
    Quilt		*bezier_curves;	/* array of bezier curves	*/
    long		type;		/* range descriptor		*/
    REAL		tesselation;	/* tesselation tolerance 	*/
    int			method;		/* tesselation method 		*/
    O_nurbscurve *	next;		/* next curve in list		*/
    int			used;		/* curve called in cur surf	*/
    int			save;		/* 1 if in display list		*/
    O_curve *		owner;		/* owning curve 		*/
			O_nurbscurve( long _type ) 
			   { type = _type; owner = 0; next = 0; used = 0; }
    };
 
#ifdef NT
struct O_pwlcurve : public PooledObj {
#else
class O_pwlcurve : public PooledObj {
#endif
public:
    TrimVertex		*pts;		/* array of trim vertices	*/
    int			npts;		/* number of trim vertices	*/
    O_pwlcurve *	next;		/* next curve in list		*/
    int			used;		/* curve called in cur surf	*/
    int			save;		/* 1 if in display list		*/
    O_curve *		owner;		/* owning curve 		*/
			O_pwlcurve( long, long, INREAL *, long, TrimVertex * );
    };

struct O_trim : public PooledObj {
    O_curve		*o_curve;	/* closed trim loop	 	*/
    O_trim *		next;		/* next loop along trim 	*/
    int			save;		/* 1 if in display list		*/
			O_trim() { next = 0; o_curve = 0; }
    };

struct O_nurbssurface : public PooledObj {
    Quilt *		bezier_patches;/* array of bezier patches	*/
    long		type;		/* range descriptor		*/
    O_surface *		owner;		/* owning surface		*/
    O_nurbssurface *	next;		/* next surface in chain	*/
    int			save;		/* 1 if in display list		*/
    int			used;		/* 1 if prev called in block	*/
			O_nurbssurface( long _type ) 
			   { type = _type; owner = 0; next = 0; used = 0; }
    };

struct O_surface : public PooledObj {
    O_nurbssurface *	o_nurbssurface;	/* linked list of surfaces	*/
    O_trim *		o_trim;		/* list of trim loops		*/
    int			save;		/* 1 if in display list		*/
    long		nuid;
			O_surface() { o_trim = 0; o_nurbssurface = 0; }
    };

struct Property : public PooledObj {
    long		type;
    long		tag;
    REAL		value;
    int			save;		/* 1 if in display list		*/
			Property( long _type, long _tag, INREAL _value )
			{ type = _type; tag = _tag; value = (REAL) _value; }
			Property( long _tag, INREAL _value )
			{ type = 0; tag = _tag; value = (REAL) _value; }
    };

class NurbsTessellator;
#endif /* __glureader_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\reader.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 *  reader.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "nurbscon.h"
#include "reader.h"
#include "trimvert.h"

O_pwlcurve::O_pwlcurve( long _type, long count, INREAL *array, long byte_stride, TrimVertex *trimpts )
{
    next = 0;
    used = 0;
    owner = 0;
    pts = trimpts;
    npts = (int) count;

    /* copy user data into internal trimming data structures */
    switch( _type ) {
        case N_P2D: {
	    TrimVertex *v = pts;
    	    for( TrimVertex *lastv = v + count; v != lastv; v++ ) {
	        v->param[0] = (REAL) array[0];
	        v->param[1] = (REAL) array[1];
		array = (INREAL *) (((char *) array) + byte_stride);
	    }
	    break;
	}
        case N_P2DR: {
	    TrimVertex *v = pts;
    	    for( TrimVertex *lastv = v + count; v != lastv; v++ ) {
	        v->param[0] = (REAL) array[0] / (REAL) array[2];
	        v->param[1] = (REAL) array[1] / (REAL) array[2];
		array = (INREAL *) (((char *) array) + byte_stride);
	    }
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\renderhi.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * renderhints.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "renderhi.h"
#include "defines.h"
#include "nurbscon.h"


/*--------------------------------------------------------------------------
 * Renderhints::Renderhints - set all window specific options
 *--------------------------------------------------------------------------
 */
Renderhints::Renderhints()
{
    display_method 	= N_FILL;
    errorchecking 	= N_MSG;
    subdivisions 	= 6.0;
    tmp1 		= 0.0;
}

void
Renderhints::init( void )
{
    maxsubdivisions = (int) subdivisions;
    if( maxsubdivisions < 0 ) maxsubdivisions = 0;


    if( display_method == N_FILL ) {
	wiretris = 0;
	wirequads = 0;
    } else if( display_method == N_OUTLINE_TRI ) {
	wiretris = 1;
	wirequads = 0;
    } else if( display_method == N_OUTLINE_QUAD ) {
	wiretris = 0;
	wirequads = 1;
    } else {
	wiretris = 1;
	wirequads = 1;
    }
}

int
Renderhints::isProperty( long property )
{
    switch ( property ) {
	case N_DISPLAY:
	case N_ERRORCHECKING:
	case N_SUBDIVISIONS:
        case N_TMP1:
	    return 1;
	default:
	    return 0;
    }
}

REAL 
Renderhints::getProperty( long property )
{
    switch ( property ) {
	case N_DISPLAY:
	    return display_method;
	case N_ERRORCHECKING:
	    return errorchecking;
	case N_SUBDIVISIONS:
	    return subdivisions;
        case N_TMP1:
	    return tmp1;
	default:
#ifdef NT
        return ((REAL) 0);
#else
	    abort();
	    return -1;  //not necessary, needed to shut up compiler
#endif
    }
}

void 
Renderhints::setProperty( long property, REAL value )
{
    switch ( property ) {
	case N_DISPLAY:
	    display_method = value;
	    break;
	case N_ERRORCHECKING:
	    errorchecking = value;
	    break;
	case N_SUBDIVISIONS:
	    subdivisions = value;
	    break;
	case N_TMP1: /* unused */
	    tmp1 = value;
	    break;
	default:
#ifndef NT
	    abort();
#endif
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\renderhi.h ===
#ifndef __glurenderhints_h_
#define __glurenderhints_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * renderhints.h - $Revision: 1.1 $
 */

#include "types.h"

class Renderhints {
public:
    			Renderhints( void );
    void		init( void );
    int			isProperty( long );
    REAL 		getProperty( long );
    void		setProperty( long, REAL );

    REAL 		display_method;		/* display mode */
    REAL 		errorchecking;		/* activate error checking */
    REAL 		subdivisions;		/* maximum number of subdivisions per patch */
    REAL 		tmp1;			/* unused */

    int			displaydomain;
    int			maxsubdivisions;
    int			wiretris;
    int			wirequads;
};

#endif /* __glurenderhints_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\simplema.h ===
#ifndef __glusimplemath_h_
#define __glusimplemath_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * simplemath.h - $Revision: 1.4 $
 */

/* simple inline routines */

inline int
max( int x, int y ) { return ( x < y ) ? y : x; }

inline REAL
min( REAL x, REAL y ) { return ( x > y ) ? y : x; }

#ifndef _abs_defined
inline REAL
abs( REAL x ) { return ( x < 0.0 ) ? -x : x; }
#endif

#endif /* __glusimplemath_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\slicer.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * slicer.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */
#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "bufpool.h"
#include "slicer.h"
#include "backend.h"
#include "arc.h"
#include "gridtrim.h"
#include "trimvert.h"
#include "varray.h"

Slicer::Slicer( Backend &b ) 
	: CoveAndTiler( b ), Mesher( b ), backend( b )
{
}

Slicer::~Slicer()
{
}

void
Slicer::setisolines( int x )
{
    isolines = x;
}

void
Slicer::setstriptessellation( REAL x, REAL y )
{
    assert(x > 0 && y > 0);
    du = x;
    dv = y;
    setDu( du );
}

void
Slicer::slice( Arc_ptr loop )
{
    loop->markverts();

    Arc_ptr extrema[4];
    loop->getextrema( extrema );

    unsigned int npts = loop->numpts();
    TrimRegion::init( npts, extrema[0] );

    Mesher::init( npts );

    long ulines = uarray.init( du, extrema[1], extrema[3] );

    Varray varray;
    long vlines = varray.init( dv, extrema[0], extrema[2] );

    long botv = 0;
    long topv;
    TrimRegion::init( varray.varray[botv] );
    getGridExtent( &extrema[0]->pwlArc->pts[0], &extrema[0]->pwlArc->pts[0] );

    for( long quad=0; quad<varray.numquads; quad++ ) {
	backend.surfgrid( uarray.uarray[0], 
		       uarray.uarray[ulines-1], 
	 	       ulines-1, 
		       varray.vval[quad], 
		       varray.vval[quad+1], 
		       varray.voffset[quad+1] - varray.voffset[quad] );

	for( long i=varray.voffset[quad]+1; i <= varray.voffset[quad+1]; i++ ) {
    	    topv = botv++;
    	    advance( topv - varray.voffset[quad], 
		     botv - varray.voffset[quad], 
		     varray.varray[botv] );
	    if( i == vlines )
		getPts( extrema[2] );
	    else
		getPts( backend );
	    getGridExtent();
            if( isolines ) {
	        outline();
	    } else {
		if( canTile() ) 
		    coveAndTile();
		else
		    mesh();
	    }
        }
   }
}


void
Slicer::outline( void )
{
    GridTrimVertex upper, lower;
    Hull::init( );

    backend.bgnoutline();
    while( (nextupper( &upper )) ) {
	if( upper.isGridVert() )
	    backend.linevert( upper.g );
	else
	    backend.linevert( upper.t );
    }
    backend.endoutline();

    backend.bgnoutline();
    while( (nextlower( &lower )) ) {
	if( lower.isGridVert() )
	    backend.linevert( lower.g );
	else
	    backend.linevert( lower.t );
    }
    backend.endoutline();
}


void
Slicer::outline( Arc_ptr jarc )
{
    jarc->markverts();

    if( jarc->pwlArc->npts >= 2 ) {
	backend.bgnoutline();
	for( int j = jarc->pwlArc->npts-1; j >= 0; j--  )
	    backend.linevert( &(jarc->pwlArc->pts[j]) );
	backend.endoutline();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\slicer.h ===
#ifndef __gluslicer_h_
#define __gluslicer_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * slicer.h - $Revision: 1.3 $
 */

#include "trimregi.h"
#include "mesher.h"
#include "coveandt.h"

class Backend;
class Arc;
class TrimVertex;

class Slicer : public CoveAndTiler, public Mesher {
public:
    			Slicer( Backend & );
			~Slicer( void );
    void		slice( Arc * );
    void		outline( Arc * );
    void		setstriptessellation( REAL, REAL );
    void		setisolines( int );
private:
    Backend&		backend;
    REAL		oneOverDu;
    REAL		du, dv;
    int			isolines;

    void		outline( void );
    void		initGridlines( void );
    void		advanceGridlines( long );
};
#endif /* __gluslicer_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\sorter.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * sorter.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "sorter.h"
#include "mystdio.h"

Sorter::Sorter( int _es )
{
    es = _es;
}

void
Sorter::qsort( void *a, int n )
{
    qs1( (char *)a, ((char *)a)+n*es);
}

int
Sorter::qscmp( char *, char * )
{
    dprintf( "Sorter::qscmp: pure virtual called\n" );
    return 0;
}


void
Sorter::qsexc( char *, char * )
{
    dprintf( "Sorter::qsexc: pure virtual called\n" );
}


void
Sorter::qstexc( char *, char *, char * )
{
    dprintf( "Sorter::qstexc: pure virtual called\n" );
}

void
Sorter::qs1( char *a,  char *l )
{
    char *i, *j;
    char	*lp, *hp;
    int	c;
    unsigned int n;

start:
#ifdef NT
    if((int)(n=l-a) <= es)
#else
    if((n=l-a) <= es)
#endif
	    return;
    n = es * (n / (2*es));
    hp = lp = a+n;
    i = a;
    j = l-es;
    while(1) {
	if(i < lp) {
	    if((c = qscmp(i, lp)) == 0) {
		qsexc(i, lp -= es);
		continue;
	    }
	    if(c < 0) {
		i += es;
		continue;
	    }
	}

loop:
	if(j > hp) {
	    if((c = qscmp(hp, j)) == 0) {
		qsexc(hp += es, j);
		goto loop;
	    }
	    if(c > 0) {
		if(i == lp) {
		    qstexc(i, hp += es, j);
		    i = lp += es;
		    goto loop;
		}
		qsexc(i, j);
		j -= es;
		i += es;
		continue;
	    }
	    j -= es;
	    goto loop;
	}

	if(i == lp) {
	    if(lp-a >= l-hp) {
		qs1(hp+es, l);
		l = lp;
	    } else {
		qs1(a, lp);
		a = hp+es;
	    }
	    goto start;
	}

	qstexc(j, lp -= es, i);
	j = hp -= es;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\sorter.h ===
#ifndef __glusorter_h_
#define __glusorter_h_

class Sorter {
public:
			Sorter( int es );
    void		qsort( void *a, int n );

protected:	
    virtual int		qscmp( char *, char * );
    virtual void	qsexc( char *i, char *j );	// i<-j, j<-i 
    virtual void	qstexc( char *i, char *j, char *k ); // i<-k, k<-j, j<-i 

private:
    void		qs1( char *, char * );
    int 		es;
};
#endif /* __glusorter_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\tobezier.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* 
 * tobezier.c++ - $Revision: 1.6 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mystring.h"
#include "quilt.h"
#include "knotvect.h"

/* local type definitions */
struct Breakpt {		/* breakpoints	*/
    Knot		value;		/* value	*/
    int			multi;		/* multiplicity	*/
    int			def;		/* deficit */
};

struct Knotspec {		/* knotvector format */
    long		order;		/* order of spline  */
    Knot_ptr		inkbegin;	/* input knot sequence */
    Knot_ptr		inkend;		/* location after last knot */
    Knot_ptr		outkbegin;	/* in-process knot subsequence */
    Knot_ptr		outkend;	/* location after last knot */
    Knot_ptr		kleft;		/* */
    Knot_ptr		kright;		/* */
    Knot_ptr		kfirst;		/* */
    Knot_ptr		klast;		/* */
    Knot_ptr		sbegin;		/* conversion factor values */
    Breakpt *		bbegin;		/* in-process breakpoints */
    Breakpt *		bend;		/* last breakpoint */
    int			ncoords;	/* coordinates per control point */
    int			prestride;	/* stride between input points */
    int			poststride;	/* stride between output points	*/
    int 		preoffset;	/* scaled point offset	*/
    int 		postoffset;	/* scaled point offset	*/
    int 		prewidth;	/* width of dimension	*/
    int 		postwidth;	/* width of dimension	*/
    int 		istransformed;	/* was dimension transformed */
    Knotspec *		next;   	/* next knotspec */
    Knotspec *		kspectotrans;   /* knotspec in transformation direction */

			Knotspec( void );
			~Knotspec( void );
    void		factors( void );
    void		insert( REAL * );
    void		preselect();
    void		select( void );
    void		copy( INREAL *, REAL * );
    void		breakpoints( void );
    void		knots( void );
    void		transform( REAL * );
    void		showpts( REAL * );
    
    void		pt_io_copy( REAL *, INREAL * );
    void		pt_oo_copy( REAL *, REAL * );
    void		pt_oo_sum( REAL*, REAL*, REAL*, Knot, Knot );
};

struct Splinespec {		/* a non-uniform tensor element */
			Splinespec( int );
                        ~Splinespec(void);
    Knotspec		*kspec;	/* format of each param. dir. */
    int			dim;		/* domain dimension */
    REAL *		outcpts;	/* Bezier control points */

    void		kspecinit( Knotvector & );
    void		kspecinit( Knotvector &, Knotvector & );
    void		select( void );
    void		layout( long );
    void		setupquilt( Quilt_ptr );
    void		copy( INREAL * );
    void		transform( void );
};

/*-----------------------------------------------------------------------------
 * Quilt::toBezier - convert from NURBS to rational Bezier 
 *-----------------------------------------------------------------------------
 */

void
Quilt::toBezier( 
    Knotvector& knotvector,	/* a knot vector */
    INREAL *ctlpts,		/* input contol points */
    long ncoords )		/* number of coordinates per control point */
{
    Splinespec spline( 1 );
    spline.kspecinit( knotvector );
    spline.select();
    spline.layout( ncoords );
    spline.setupquilt( this );
    spline.copy( ctlpts );
    spline.transform();
}

void
Quilt::toBezier( 
    Knotvector& sknotvector,	/* a knot vector */
    Knotvector& tknotvector,	/* a knot vector */
    INREAL *ctlpts,		/* input contol points */
    long ncoords )		/* number of coordinates per control point */
{
    Splinespec spline( 2 );
    spline.kspecinit( sknotvector, tknotvector );
    spline.select();
    spline.layout( ncoords );
    spline.setupquilt( this );
    spline.copy( ctlpts );
    spline.transform();
}
Splinespec::Splinespec( int dimen )
{
    dim = dimen;
}

Splinespec::~Splinespec( void )
{
    /* Note: do NOT delete 'outcpts' here since its address (not contents)
     * is copied in 'cpts' in this file in function Splinespec::setupquilt().
     * This block of memory will eventually be deleted in file quilt.c++ in
     * function Quilt::deleteMe() through 'cpts' so do NOT delete it here!
     */	
    Knotspec *ktrav= kspec;         //start at beginning of list 
    while (ktrav != 0) {            //any items to delete? 
       Knotspec *deleteThis= ktrav; //remember to delete this 
       ktrav= ktrav->next;          //go to next item if any
       delete deleteThis;           //delete it
    }	
} /* ~Splinespec() */

/*-----------------------------------------------------------------------------
 * Splinespec::kspecinit - initialize Splinespec structure
 *
 * Client: Quilt::toBezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::kspecinit( Knotvector& knotvector )
{
    kspec = new Knotspec;
    kspec->inkbegin = knotvector.knotlist;
    kspec->inkend = knotvector.knotlist + knotvector.knotcount;
    kspec->prestride = (int) knotvector.stride; 
    kspec->order = knotvector.order;
    kspec->next = NULL;
}

void
Splinespec::kspecinit( Knotvector& sknotvector, Knotvector& tknotvector )
{
    kspec = new Knotspec;
    Knotspec *tkspec = new Knotspec;

    kspec->inkbegin = sknotvector.knotlist;
    kspec->inkend = sknotvector.knotlist + sknotvector.knotcount;
    kspec->prestride = (int) sknotvector.stride; 
    kspec->order = sknotvector.order;
    kspec->next = tkspec;

    tkspec->inkbegin = tknotvector.knotlist;
    tkspec->inkend = tknotvector.knotlist + tknotvector.knotcount;
    tkspec->prestride = (int) tknotvector.stride; 
    tkspec->order = tknotvector.order;
    tkspec->next = NULL;
}


/*-----------------------------------------------------------------------------
 * Splinespec::select - select the subsegments to copy
 *
 * Client: gl_quilt_to_bezier	
 *-----------------------------------------------------------------------------
 */

void
Splinespec::select( )
{
    for( Knotspec *knotspec = kspec; knotspec; knotspec = knotspec->next ) {
	knotspec->preselect();
	knotspec->select();
    }
}

/*-----------------------------------------------------------------------------
 * Splinespec::layout - 
 *
 * Client: gl_quilt_to_bezier	
 *-----------------------------------------------------------------------------
 */

void
Splinespec::layout( long ncoords )
{

    long stride = ncoords;
    for( Knotspec *knotspec = kspec; knotspec; knotspec=knotspec->next ) {
	knotspec->poststride = (int) stride;
	stride *= (long)((knotspec->bend-knotspec->bbegin)*knotspec->order + knotspec->postoffset);
        knotspec->preoffset  *= knotspec->prestride;
	knotspec->prewidth  *= knotspec->poststride;
	knotspec->postwidth *= knotspec->poststride;
	knotspec->postoffset *= knotspec->poststride;
        knotspec->ncoords = (int) ncoords;
    }
    outcpts = new REAL[stride];
    assert( outcpts != 0 );  
}

/*-----------------------------------------------------------------------------
 * Splinespec::copy - copy the control points of current subobject
 *
 * Client: gl_quilt_to_bezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::copy( INREAL *incpts )
{
    kspec->copy( incpts, outcpts );
}

/*-----------------------------------------------------------------------------
 * Splinespec::setupquilt - assign all quilt variables from knotspec 
 *
 * Client: gl_quilt_to_bezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::setupquilt( Quilt_ptr quilt )
{
    Quiltspec_ptr qspec = quilt->qspec;
    quilt->eqspec = qspec + dim;
    for( Knotspec *knotspec = kspec; knotspec; knotspec=knotspec->next, qspec++ ) {
	qspec->stride	= knotspec->poststride;
	qspec->width	= knotspec->bend - knotspec->bbegin;
	qspec->order	= (int) knotspec->order;
	qspec->offset	= knotspec->postoffset;
	qspec->index	= 0;
	qspec->bdry[0]	= (knotspec->kleft == knotspec->kfirst) ? 1 : 0;
	qspec->bdry[1]	= (knotspec->kright == knotspec->klast) ? 1 : 0;
	qspec->breakpoints = new Knot[qspec->width+1];
	Knot_ptr k =  qspec->breakpoints;
	for( Breakpt *bk = knotspec->bbegin; bk <= knotspec->bend; bk++ )
	    *(k++) = bk->value;
    }
    quilt->cpts = outcpts;
    quilt->next = 0;
}

/*-----------------------------------------------------------------------------
 * Splinespec::transform - convert a spline to Bezier format
 *
 * Client: gl_quilt_to_bezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::transform( void )
{
    for( Knotspec *knotspec = kspec; knotspec; knotspec=knotspec->next )
        knotspec->istransformed = 0;

    for( knotspec = kspec; knotspec; knotspec=knotspec->next ) {
	for( Knotspec *kspec2 = kspec; kspec2; kspec2=kspec2->next )
	    kspec2->kspectotrans = knotspec;
	kspec->transform( outcpts );
	knotspec->istransformed = 1;
    }
}


/*-----------------------------------------------------------------------------
 * Knotspec::Knotspec -  constuct a knot spec 
 *-----------------------------------------------------------------------------
 */

Knotspec::Knotspec( void )
{
    bbegin = 0;
    sbegin = 0;
    outkbegin = 0;
}

/*-----------------------------------------------------------------------------
 * Knotspec::copy -  copy the control points along minor direction 
 *
 * Client: Splinespec::copy
 *-----------------------------------------------------------------------------
 */

void
Knotspec::copy( INREAL *inpt, REAL *outpt )
{
    inpt = (INREAL *) (((char *) inpt) + preoffset);

    if( next ) {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride ) {
	    next->copy( inpt, outpt );
	    inpt = (INREAL *) (((char *) inpt) + prestride);
	}
   } else {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride ) {
	    pt_io_copy( outpt, inpt );
	    inpt = (INREAL *) (((char *) inpt) + prestride);
	}
     }
}

/*-----------------------------------------------------------------------------
 * Knotspec::showpts - print out points before transformation
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */
void
Knotspec::showpts( REAL *outpt )
{
    if( next ) {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride )
	    next->showpts( outpt );
    } else {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride )
	    dprintf(  "show %g %g %g\n", outpt[0], outpt[1], outpt[2] );
    }
}

/*-----------------------------------------------------------------------------
 * Knotspec::factors - precompute scale factors 	
 *	   - overwrites knot vector, actual new knot vector is NOT produced
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::factors( void )
{
    Knot *mid = (outkend - 1) - order + bend->multi;
    Knot_ptr fptr = sbegin;

    for( Breakpt *bpt = bend; bpt >= bbegin; bpt-- ) {
    	mid -= bpt->multi;		// last knot less than knot to insert
	int def = bpt->def - 1;		// number of knots to insert
	if( def <= 0 ) continue;
	Knot kv = bpt->value;		// knot to insert

	Knot *kf = (mid-def) + (order-1);
	for( Knot *kl = kf + def; kl != kf; kl-- ) {
	    Knot *kh, *kt;
	    for( kt=kl, kh=mid; kt != kf; kh--, kt-- ) 
		*(fptr++) = (kv - *kh) / (*kt - *kh);
	    *kl = kv;
	}
    }
}

/*-----------------------------------------------------------------------------
 * Knotspec::insert - convert subobject in direction of kspec into Bezier
 *
 * Client: Knotspec::transform
 *-----------------------------------------------------------------------------
 */

void
Knotspec::insert( REAL *p )
{
    Knot_ptr fptr = sbegin;
    REAL *srcpt = p + prewidth - poststride;
    REAL *dstpt = p + postwidth + postoffset - poststride;
    Breakpt *bpt = bend;

   for( REAL *pend = srcpt - poststride*bpt->def; srcpt != pend; pend +=poststride ) {
	REAL *p1 = srcpt;
	for( REAL *p2 = srcpt-poststride; p2 != pend; p1 = p2, p2 -= poststride ) {
	    pt_oo_sum( p1, p1, p2, *fptr, 1.0-*fptr );
	    fptr++;
	}
    }

    for( --bpt; bpt >= bbegin; bpt-- ) {

	for( int multi = bpt->multi; multi > 0; multi-- ) {
	    pt_oo_copy( dstpt, srcpt );
	    dstpt -= poststride;
	    srcpt -= poststride;	
	}
    
	for( REAL *pend = srcpt - poststride*bpt->def; srcpt != pend; pend +=poststride, dstpt-=poststride ) {
	    pt_oo_copy( dstpt, srcpt );
	    REAL *p1 = srcpt;

	    for( REAL *p2 = srcpt-poststride; p2 != pend; p1=p2, p2 -= poststride ) {
		pt_oo_sum( p1, p1, p2, *fptr, 1.0-*fptr );
		fptr++;
	    }
	}
    }
}

/*-----------------------------------------------------------------------------
 * Knotspec::preselect - initialize kspec for processing
 *
 * Client: Splinespec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::preselect( void )
{
    Knot kval; 

    /* position klast after last knot of "last" breakpoint */
    for( klast = inkend - order, kval = *klast; klast != inkend; klast++ ) 
	if( ! identical( *klast, kval ) ) break;

    /* position kfirst after last knot of "first" breakpoint */
    for( kfirst = inkbegin+order-1, kval= *kfirst;  kfirst != inkend; kfirst++ )
	if( ! identical( *kfirst, kval ) ) break;

    /* compute multiplicity of first breakpoint */
    for( Knot_ptr k  = kfirst - 1; k >= inkbegin; k-- ) 
	if( ! identical( kval, *k ) ) break;    
    k++;

    /* allocate space for breakpoints -
       use worst case estimate on number of breakpoints */

    bbegin = new Breakpt[(klast - kfirst)+1];
    /* record multiplicity and value of first breakpoint */
    bbegin->multi = kfirst - k;
    bbegin->value = kval;
    bend = bbegin;

    kleft = kright = kfirst;
}


/*-----------------------------------------------------------------------------
 * Knotspec::select - Knotspec::select segments and precompute scale factors
 *
 * Client: Splinespec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::select( void )
{
    breakpoints();
    knots();
    factors();
    
    preoffset	= kleft - (inkbegin + order);
    postwidth	= (int)((bend - bbegin) * order);
    prewidth 	= (int)((outkend - outkbegin) - order);
    postoffset  = (bbegin->def > 1) ? (bbegin->def-1) : 0;
}
 
/*-----------------------------------------------------------------------------
 * Knotspec::breakpoints - compute breakpoints for knotspec
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::breakpoints( void )
{
    Breakpt *ubpt	= bbegin;
    Breakpt *ubend	= bend;
    long    nfactors  	= 0;

    ubpt->value	= ubend->value;
    ubpt->multi	= ubend->multi;

    kleft = kright;

    for( ; kright != klast; kright++ ) {
        if ( identical(*kright,ubpt->value) ) {
	    (ubpt->multi)++;
	} else {
    	    ubpt->def = (int) (order - ubpt->multi);
    	    nfactors += (ubpt->def * (ubpt->def - 1)) / 2;
	    (++ubpt)->value = *kright;
	    ubpt->multi = 1;
	}
    }
    ubpt->def = (int) (order - ubpt->multi);
    nfactors += (ubpt->def * (ubpt->def - 1)) / 2;

    bend = ubpt;

    if( nfactors ) {	    
        sbegin = new Knot[nfactors];
    } else {
	sbegin = NULL;
    }
}


/*-----------------------------------------------------------------------------
 * Knotspec::knots - copy relevant subsequence of knots into temporary area
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::knots( void )
{
    Knot_ptr inkpt = kleft - order;
    Knot_ptr inkend = kright  + bend->def;

    /* allocate space for knots and factors */
    outkbegin = new Knot[inkend-inkpt];
    for( Knot_ptr outkpt = outkbegin; inkpt != inkend; inkpt++, outkpt++ ) 
	*outkpt = *inkpt;

    outkend = outkpt;
}


/*-----------------------------------------------------------------------------
 * Knotspec::transform -	convert a spline along a given direction 
 *
 * Client: Splienspec::transform
 *-----------------------------------------------------------------------------
 */

void
Knotspec::transform( REAL *p )
{
   if( next ) {
	if( this == kspectotrans ) {
	    next->transform( p );
	} else {
	    if( istransformed ) {
		p += postoffset;
		for( REAL *pend = p + postwidth; p != pend; p += poststride )
		    next->transform( p );
	    } else {
		REAL *pend = p + prewidth;
		for( ; p != pend; p += poststride )
		    next->transform( p );
	    }
	}
   } else {
	if( this == kspectotrans ) {
	    insert( p );
	} else {
	    if( istransformed ) {
		p += postoffset;
		for( REAL *pend = p + postwidth; p != pend; p += poststride )
		    kspectotrans->insert( p );
	    } else {
		REAL *pend = p + prewidth;
		for( ; p != pend; p += poststride )
		    kspectotrans->insert( p );
	    }
	}
   }
}

/*-----------------------------------------------------------------------------
 * Knotspec::~Knotspec - free space alocated for knotspec
 *-----------------------------------------------------------------------------
 */

Knotspec::~Knotspec( void )
{
    if( bbegin ) delete[] bbegin;
    if( sbegin ) delete[] sbegin;
    if( outkbegin ) delete[] outkbegin;
}


/*-----------------------------------------------------------------------------
 * pt_io_copy - make internal copy of input cntrl pt. of x coords
 *-----------------------------------------------------------------------------
 */

void
Knotspec::pt_io_copy( REAL *topt, INREAL *frompt )
{
    switch( ncoords ) {
    case 4:
        topt[3] = (REAL) frompt[3];
    case 3:
        topt[2] = (REAL) frompt[2];
    case 2:
        topt[1] = (REAL) frompt[1];
    case 1:
        topt[0] = (REAL) frompt[0];
	break;
    default: {
	    for( int i = 0; i < ncoords; i++ )
		*topt++ = (REAL) *frompt++;
	}
    }
}

/*-----------------------------------------------------------------------------
 * pt_oo_copy - make internal copy of internal cntrl pt. of x coords
 *-----------------------------------------------------------------------------
 */

void
Knotspec::pt_oo_copy( REAL *topt, REAL *frompt )
{
    switch( ncoords ) {
    case 4:
        topt[3] = frompt[3];
    case 3:
        topt[2] = frompt[2];
    case 2:
        topt[1] = frompt[1];
    case 1:
        topt[0] = frompt[0];
	break;
    default:
	memcpy( topt, frompt, ncoords * sizeof( REAL ) );
    }
}

/*-----------------------------------------------------------------------------
 * pt_oo_sum - compute affine combination of internal cntrl pts
 *-----------------------------------------------------------------------------
 */

void
Knotspec::pt_oo_sum( REAL *x, REAL *y, REAL *z, Knot a, Knot b )
{
    switch( ncoords ) {
    case 4:
        x[3] = a * y[3]  +  b * z[3];
    case 3:
        x[2] = a * y[2]  +  b * z[2];
    case 2:
        x[1] = a * y[1]  +  b * z[1];
    case 1:
        x[0] = a * y[0]  +  b * z[0];
	break;
    default: {
          for( int i = 0; i < ncoords; i++ )
              *x++ = a * *y++   +   b * *z++;
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\trimline.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimline.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "trimline.h"
#include "backend.h"

Trimline::Trimline()
{
    size = 0; pts = 0; numverts = 0;
    tinterp = &t; binterp = &b; 
}

Trimline::~Trimline()
{
    if( pts ) delete[] pts; 
}

void 
Trimline::init( TrimVertex *v )
{
    reset();
    grow(1);
    append(v);
}

inline void
Trimline::grow( long npts )
{
    if( size < npts ) {
	size = 2 * npts;
	if( pts ) delete[] pts; 
        pts = new TrimVertex_p[size];
    }
}

inline void
Trimline::append( TrimVertex *v )
{
    assert( numverts != size ); 
    pts[numverts++] = v;
}

void
Trimline::init( long npts, Arc_ptr jarc, long last )
{
    jarcl.init( jarc, 0, last );
    grow( npts + 2 );
}

inline void
Trimline::swap()
{
    TrimVertex *tmp=tinterp; 
    tinterp=binterp; 
    binterp=tmp;
}

void
Trimline::getNextPt()
{
    *binterp = *jarcl.getnextpt();    
}

void 
Trimline::getPrevPt()
{
    *binterp = *jarcl.getprevpt();
}

/*----------------------------------------------------------------------
 * getNextPts - make arrays of pointers to trim points on left and right
 *		hulls of trim strip.
 *----------------------------------------------------------------------
 */
void
Trimline::getNextPts( REAL vval, Backend& backend )
{
    reset(); swap(); append( tinterp );
    assert( tinterp->param[1] >= vval );

    register TrimVertex *p;
    for( p=jarcl.getnextpt() ; p->param[1] >= vval; p=jarcl.getnextpt() ) {
	append( p ); 
    }

    /* compute and copy pointer to final point on left hull */
    if( interpvert( last(), p, binterp, vval ) ) {
	binterp->nuid = p->nuid;
	backend.triangle( p, binterp, last() );
        append( binterp );
    }
    jarcl.reverse();
    (void) jarcl.getprevpt(); 	/* reset jarcl to proper position */
    jarcl.reverse();
}

void 
Trimline::getPrevPts( REAL vval, Backend& backend )
{
    reset(); swap(); append( tinterp );
    assert( tinterp->param[1] >= vval );

    register TrimVertex *q;
    for( q=jarcl.getprevpt(); q->param[1] >= vval; q=jarcl.getprevpt() ) {
	append( q );
    }

    /* compute and copy pointer to final point on right hull */
    if( interpvert( q, last(), binterp, vval ) ) {
	binterp->nuid = q->nuid;
	backend.triangle( last(), binterp, q );
        append( binterp );
    }
    jarcl.reverse();
    (void) jarcl.getnextpt();  /* reset jarcl to proper position */
    jarcl.reverse();
}

void
Trimline::getNextPts( Arc_ptr botarc )
{
    reset(); swap(); append( tinterp );

    PwlArc *lastpwl = botarc->prev->pwlArc;
    TrimVertex *lastpt1 = &lastpwl->pts[lastpwl->npts-1];
    TrimVertex *lastpt2 = botarc->pwlArc->pts;

    register TrimVertex *p = jarcl.getnextpt();
    for( append( p ); p != lastpt2; append( p ) ) {
	assert( p != lastpt1 );
	p = jarcl.getnextpt();
    }
}

void
Trimline::getPrevPts( Arc_ptr botarc )
{
    reset();  swap(); append( tinterp );

    PwlArc *lastpwl = botarc->prev->pwlArc;
    TrimVertex *lastpt1 = &lastpwl->pts[lastpwl->npts-1];
    TrimVertex *lastpt2 = botarc->pwlArc->pts;

    register TrimVertex *q =  jarcl.getprevpt();
    for( append( q ); q != lastpt1; append( q ) ) {
	assert( q != lastpt2 );
	q = jarcl.getprevpt();
    }
}


long
Trimline::interpvert( TrimVertex *a, TrimVertex *b, TrimVertex *c, REAL vval )
{
    REAL denom = a->param[1] - b->param[1];

    if(denom != 0) {
	if( vval == a->param[1] ) {
	    c->param[0] = a->param[0]; 
	    c->param[1] = a->param[1];
	    c->nuid = a->nuid;
	    return 0;
	} else if( vval == b->param[1] ) {
	    c->param[0] = b->param[0]; 
	    c->param[1] = b->param[1];
	    c->nuid = b->nuid;
	    return 0;
	} else {
	    REAL r = (a->param[1] - vval)/denom;
	    c->param[0] =  a->param[0] - r * (a->param[0] - b->param[0]);
	    c->param[1] = vval;
	    return 1;
	}
    } else {
        c->param[0] = a->param[0]; 
        c->param[1] = a->param[1];
	c->nuid = a->nuid;
	return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\trimline.h ===
#ifndef __glutrimline_h_
#define __glutrimline_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimline.h - $Revision: 1.1 $
 */

class Arc;
class Backend;

#include "trimvert.h"
#include "jarcloc.h"


class Trimline {
private:
    TrimVertex**	pts; 	
    long 		numverts;
    long		i;
    long		size;
    Jarcloc		jarcl;
    TrimVertex		t, b;
    TrimVertex 		*tinterp, *binterp;
    void		reset( void ) { numverts = 0; }
    inline void		grow( long );
    inline void		swap( void );
    inline void		append( TrimVertex * );
    static long		interpvert( TrimVertex *, TrimVertex *, TrimVertex *, REAL );



public:
			Trimline();
			~Trimline();
    void		init( TrimVertex * );
    void		init( long, Arc *, long );
    void		getNextPt( void );
    void		getPrevPt( void );
    void		getNextPts( REAL, Backend & );
    void		getPrevPts( REAL, Backend & );
    void		getNextPts( Arc * );
    void		getPrevPts( Arc * );
    inline TrimVertex *	next( void );
    inline TrimVertex *	prev( void ); 
    inline TrimVertex *	first( void );
    inline TrimVertex *	last( void );
};

inline TrimVertex *
Trimline::next( void ) 
{
    if( i < numverts) return pts[i++]; else return 0; 
} 

inline TrimVertex *
Trimline::prev( void ) 
{
    if( i >= 0 ) return pts[i--]; else return 0; 
} 

inline TrimVertex *
Trimline::first( void ) 
{
    i = 0; return pts[i]; 
}

inline TrimVertex *
Trimline::last( void ) 
{
    i = numverts; return pts[--i]; 
}  
#endif /* __glutrimline_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\splitarc.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * splitarcs.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mysetjmp.h"
#include "mystdio.h"
#include "subdivid.h"
#include "arcsorte.h"
#include "arc.h"
#include "bin.h"

/* local preprocessor definitions */
#define MAXARCS	10

/*----------------------------------------------------------------------------
 * Subdivider::split - split trim regions in source bin by line (param == value). 
 *----------------------------------------------------------------------------
 */

void
Subdivider::split( Bin& bin, Bin& left, Bin& right, int param, REAL value )
{
    Bin	intersections, unknown; 

    partition( bin, left, intersections, right, unknown, param, value );

    int	count = intersections.numarcs();
    if( count % 2 ) {
#ifndef NDEBUG
	left.show( "left" );
	intersections.show( "intersections" );
	right.show( "right" );
#endif
	::mylongjmp( jumpbuffer, 29 );
    }

    Arc_ptr arclist[MAXARCS], *list;
    if( count >= MAXARCS ) {
	list = new Arc_ptr[count];
    } else {
	list = arclist;
    }

    Arc_ptr jarc;
    for( Arc_ptr *last = list; jarc=intersections.removearc(); last++ )
	*last = jarc;

    if( param == 0 ) { /* sort into increasing t order */
	ArcSdirSorter sorter(*this);
	sorter.qsort( list, count );
	
        //::qsort ((void *)list, count, sizeof(Arc_ptr), (cmpfunc)compare_s);
	for( Arc_ptr *lptr=list; lptr<last; lptr+=2 )
	    check_s ( lptr[0], lptr[1] );
	for( lptr=list; lptr<last; lptr+=2 )
	    join_s ( left, right, lptr[0], lptr[1] );
	for( lptr=list; lptr != last; lptr++ ) {
	    if( ((*lptr)->head()[0] <= value) && ((*lptr)->tail()[0] <= value) )
		left.addarc( *lptr  );
	    else
		right.addarc( *lptr  );
	}
    } else { /* sort into decreasing s order */
	ArcTdirSorter sorter(*this);
	sorter.qsort( list, count );
        //::qsort ((void *)list, count, sizeof(Arc_ptr), (cmpfunc)compare_t);
	for( Arc_ptr *lptr=list; lptr<last; lptr+=2 )
	    check_t ( lptr[0], lptr[1] );
	for( lptr=list; lptr<last; lptr+=2 )
	    join_t ( left, right, lptr[0], lptr[1] );
	for( lptr=list; lptr != last; lptr++ ) {
	    if( ((*lptr)->head()[1] <= value) && ((*lptr)->tail()[1] <= value) )
		left.addarc( *lptr  );
	    else
		right.addarc( *lptr  );
	}
    }

    if( list != arclist ) delete[] list;
    unknown.adopt(); 
}


void
Subdivider::check_s( Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
    assert( jarc1 != jarc2 );

    /* XXX - if these assertions fail, it is due to user error or
	     undersampling */
    if( ! ( jarc1->tail()[0] < (jarc1)->head()[0] ) ) {
#ifndef NDEBUG
	dprintf( "s difference %f\n",  (jarc1)->tail()[0] - (jarc1)->head()[0] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }

    if( ! ( jarc2->tail()[0] > (jarc2)->head()[0] ) ) { 
#ifndef NDEBUG
	dprintf( "s difference %f\n",  (jarc2)->tail()[0] - (jarc2)->head()[0] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }
}

inline void
Subdivider::link( Arc_ptr jarc1, Arc_ptr jarc2, Arc_ptr up, Arc_ptr down )
{
    up->nuid = down->nuid = 0;		// XXX

    up->next = jarc2;
    down->next = jarc1;
    up->prev = jarc1->prev;
    down->prev = jarc2->prev;

    down->next->prev = down;
    up->next->prev = up;
    down->prev->next = down;
    up->prev->next = up;
}

inline void 
Subdivider::simple_link( Arc_ptr jarc1, Arc_ptr jarc2 )
{
    Arc_ptr tmp = jarc2->prev;
    jarc2->prev = jarc1->prev;
    jarc1->prev = tmp;
    jarc2->prev->next = jarc2;
    jarc1->prev->next = jarc1;
}


/*----------------------------------------------------------------------------
 * join - add a pair of oppositely directed jordan arcs between two arcs
 *----------------------------------------------------------------------------
 */

void
Subdivider::join_s( Bin& left, Bin& right, Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0);
    assert( jarc2->check( ) != 0);
    assert( jarc1 != jarc2 );

    if( ! jarc1->getitail() )
	jarc1 = jarc1->next;

    if( ! jarc2->getitail() )
	jarc2 = jarc2->next;

    REAL s = jarc1->tail()[0];
    REAL t1 = jarc1->tail()[1];
    REAL t2 = jarc2->tail()[1];

    if( t1 == t2 ) {
	simple_link( jarc1, jarc2 );
    } else {
	Arc_ptr newright = new(arcpool) Arc( arc_right, 0 ); 
	Arc_ptr newleft = new(arcpool) Arc( arc_left, 0 );
	assert( t1 < t2 );
	if( isBezierArcType() ) {
	    arctessellator.bezier( newright, s, s, t1, t2 );
	    arctessellator.bezier( newleft, s, s, t2, t1 );
	} else {
	    arctessellator.pwl_right( newright, s, t1, t2, stepsizes[0] );
	    arctessellator.pwl_left( newleft, s, t2, t1, stepsizes[2] );
	}
	link( jarc1, jarc2, newright, newleft );
	left.addarc( newright  );
	right.addarc( newleft  );
    }

    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0);
    assert( jarc2->next->check( ) != 0);
}

void
Subdivider::check_t( Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
    assert( jarc1 != jarc2 );

    /* XXX - if these assertions fail, it is due to user error or
	     undersampling */
    if( ! ( jarc1->tail()[1] < (jarc1)->head()[1] ) ) {
#ifndef NDEBUG
	dprintf( "t difference %f\n",  jarc1->tail()[1] - (jarc1)->head()[1] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }

    if( ! ( jarc2->tail()[1] > (jarc2)->head()[1] ) ) { 
#ifndef NDEBUG
	dprintf( "t difference %f\n",  jarc2->tail()[1] - (jarc2)->head()[1] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }
}

/*----------------------------------------------------------------------------
 * join_t - add a pair of oppositely directed jordan arcs between two arcs
 *----------------------------------------------------------------------------
 */

void
Subdivider::join_t( Bin& bottom, Bin& top, Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
    assert( jarc1 != jarc2 );

    if( ! jarc1->getitail() )
	jarc1 = jarc1->next;

    if( ! jarc2->getitail() )
	jarc2 = jarc2->next;

    REAL s1 = jarc1->tail()[0];
    REAL s2 = jarc2->tail()[0];
    REAL t  = jarc1->tail()[1];

    if( s1 == s2 ) {
	simple_link( jarc1, jarc2 );
    } else {
	Arc_ptr newtop = new(arcpool) Arc( arc_top, 0 );
	Arc_ptr newbot = new(arcpool) Arc( arc_bottom, 0 );
	assert( s1 > s2 );
	if( isBezierArcType() ) {
	    arctessellator.bezier( newtop, s1, s2, t, t );
	    arctessellator.bezier( newbot, s2, s1, t, t );
	} else {
	    arctessellator.pwl_top( newtop, t, s1, s2, stepsizes[1] );
	    arctessellator.pwl_bottom( newbot, t, s2, s1, stepsizes[3] );
	}
	link( jarc1, jarc2, newtop, newbot );
	bottom.addarc( newtop  );
	top.addarc( newbot  );
    }

    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\subdivid.h ===
#ifndef __glusubdivider_h_
#define __glusubdivider_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * subdivider.h - $Revision: 1.1 $
 */

#include "mysetjmp.h"
#include "bin.h"
#include "flist.h"
#include "slicer.h"
#include "arctess.h"
#include "trimvert.h"
#include "trimpool.h"

class Arc;
class Pool;
class Renderhints;
class Backend;
class Quilt;
class Patchlist;
class Curvelist;
#ifdef NT
struct JumpBuffer;
#else
class JumpBuffer;
#endif

class Subdivider {
public:
			Subdivider( Renderhints&, Backend& );
			~Subdivider( void );
    void		clear( void );

    void		beginTrims( void ) {}
    void		beginLoop( void );
    void		addArc( REAL *, Quilt *, long );
    void		addArc( int, TrimVertex *, long );
    void		endLoop( void ) {}
    void		endTrims( void ) {}

    void		beginQuilts( void );
    void		addQuilt( Quilt * );
    void		endQuilts( void ) {}

    void		drawCurves( void );
    void		drawSurfaces( long );

    int			ccwTurn_sl( Arc *, Arc * );
    int			ccwTurn_sr( Arc *, Arc * );
    int			ccwTurn_tl( Arc *, Arc * );
    int			ccwTurn_tr( Arc *, Arc * );

    void		setJumpbuffer( JumpBuffer * );

private:
    void		classify_headonleft_s( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonleft_s( Bin &, Bin &, Bin &, REAL );
    void		classify_headonright_s( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonright_s( Bin &, Bin &, Bin &, REAL );
    void		classify_headonleft_t( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonleft_t( Bin &, Bin &, Bin &, REAL );
    void		classify_headonright_t( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonright_t( Bin &, Bin &, Bin &, REAL );

    enum dir 		{ down, same, up, none };
    void		tessellate( Arc *, REAL );
    void		monotonize( Arc *, Bin & );
    int			isMonotone( Arc * );
    int			decompose( Bin &, REAL );


    Slicer		slicer;
    ArcTessellator	arctessellator;
    Pool		arcpool;
    Pool		bezierarcpool;
    Pool		pwlarcpool;
    TrimVertexPool	trimvertexpool;

    JumpBuffer*		jumpbuffer;
    Renderhints&	renderhints;
    Backend&		backend;

    Bin			initialbin;
    Arc *		pjarc;
    int 		s_index;
    int			t_index;
    Quilt *		qlist;
    Flist		spbrkpts;
    Flist		tpbrkpts;
    Flist		smbrkpts;
    Flist		tmbrkpts;
    REAL	 	stepsizes[4];
    int			showDegenerate;
    int			isArcTypeBezier;

    void		samplingSplit( Curvelist&, int );

    void		subdivideInS( Bin&  );
    void		splitInS( Bin&, int, int );
    void		splitInT( Bin&, int, int );
    void		samplingSplit( Bin&, Patchlist&, int, int );
    void		nonSamplingSplit( Bin&, Patchlist&, int, int );
    void		tessellation( Bin&, Patchlist& );
    void		monosplitInS( Bin&, int, int );
    void		monosplitInT( Bin&, int, int );

    void		outline( Bin & );
    void		freejarcs( Bin & );
    void		render( Bin & );
    void		split( Bin &, Bin &, Bin &, int, REAL );
    void		tessellate( Bin &, REAL, REAL, REAL, REAL );

    inline void		setDegenerate( void ) { showDegenerate = 1; }
    inline void		setNonDegenerate( void ) { showDegenerate = 0; }
    inline int		showingDegenerate( void ) { return showDegenerate; }
    inline void		setArcTypeBezier( void ) { isArcTypeBezier = 1; }
    inline void		setArcTypePwl( void ) { isArcTypeBezier = 0; }
    inline int		isBezierArcType( void ) { return isArcTypeBezier; }

    void		makeBorderTrim( const REAL *, const REAL * );
    void		split( Bin &, int, const REAL *, int, int );
    void		partition( Bin &, Bin &, Bin &, Bin &, Bin &, int, REAL );
    void		findIrregularS( Bin & );
    void		findIrregularT( Bin & );


    inline int		bbox( TrimVertex *, TrimVertex *, TrimVertex *, int );
    static int		bbox( REAL, REAL, REAL, REAL, REAL, REAL );
    static int		ccw( TrimVertex *, TrimVertex *, TrimVertex * );
    void		join_s( Bin &, Bin &, Arc *, Arc * );
    void		join_t( Bin &, Bin &, Arc *, Arc * );
    int			arc_split( Arc *, int, REAL, int );
    void		check_s( Arc *, Arc * );
    void		check_t( Arc *, Arc * );
    inline void		link( Arc *, Arc *, Arc *, Arc * );
    inline void		simple_link( Arc *, Arc * );
};

inline void
Subdivider::beginLoop( void ) 
{
    pjarc = 0;
}


#endif /* __glusubdivider_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\subdivid.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * subdivider.c++ - $Revision: 1.3 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "subdivid.h"
#include "arc.h"
#include "bezierar.h"
#include "bin.h"
#include "renderhi.h"
#include "backend.h"
#include "mapdesc.h"
#include "quilt.h"
#include "patchlis.h"
#include "patch.h"
#include "nurbscon.h"
#include "trimpool.h"
#include "simplema.h"

/*---------------------------------------------------------------------------
 * Subdivider - construct a subdivider
 *---------------------------------------------------------------------------
 */

Subdivider::Subdivider( Renderhints& r, Backend& b ) 
	: arcpool( sizeof( Arc), 1, "arcpool" ),
 	  bezierarcpool( sizeof( BezierArc ), 1, "Bezarcpool" ),
	  pwlarcpool( sizeof( PwlArc ), 1, "Pwlarcpool" ),
	  renderhints( r ),
	  arctessellator( trimvertexpool, pwlarcpool ), 
	  backend( b ),
	  slicer( b )
{
}

void
Subdivider::setJumpbuffer( JumpBuffer *j )
{
    jumpbuffer = j;
}

/*---------------------------------------------------------------------------
 * clear - reset all state after possible error condition
 *---------------------------------------------------------------------------
 */

void		
Subdivider::clear( void )
{
    trimvertexpool.clear();     
    arcpool.clear();
    pwlarcpool.clear();
    bezierarcpool.clear();
}

/*---------------------------------------------------------------------------
 * ~Subdivider - destroy a subdivider
 *---------------------------------------------------------------------------
 */

Subdivider::~Subdivider( void )
{
}

/*---------------------------------------------------------------------------
 * addArc - add a bezier arc to a trim loop and to a bin
 *---------------------------------------------------------------------------
 */
void
Subdivider::addArc( REAL *cpts, Quilt *quilt, long _nuid )
{
    BezierArc *bezierArc = new(bezierarcpool) BezierArc;
    Arc *jarc  		= new(arcpool) Arc( arc_none, _nuid );
    jarc->pwlArc	= 0;
    jarc->bezierArc	= bezierArc;
    bezierArc->order	= quilt->qspec->order;
    bezierArc->stride	= quilt->qspec->stride;
    bezierArc->mapdesc	= quilt->mapdesc;
    bezierArc->cpts	= cpts;
    initialbin.addarc( jarc );
    pjarc		= jarc->append( pjarc );
}

/*---------------------------------------------------------------------------
 * addArc - add a pwl arc to a trim loop and to a bin
 *---------------------------------------------------------------------------
 */

void
Subdivider::addArc( int npts, TrimVertex *pts, long _nuid ) 
{
    Arc *jarc 		= new(arcpool) Arc( arc_none, _nuid );
    jarc->pwlArc	= new(pwlarcpool) PwlArc( npts, pts );        
    initialbin.addarc( jarc  );
    pjarc		= jarc->append( pjarc );
}

void
Subdivider::beginQuilts( void )
{
    qlist = 0;
}

void
Subdivider::addQuilt( Quilt *quilt )
{
    quilt->next = qlist;
    qlist = quilt;
}

/*---------------------------------------------------------------------------
 * drawSurfaces - main entry point for surface tessellation
 *---------------------------------------------------------------------------
 */

void
Subdivider::drawSurfaces( long nuid )
{
    renderhints.init( );

    if (qlist == NULL) return;
    for( Quilt *q = qlist; q; q = q->next ) {
	if( q->isCulled( ) == CULL_TRIVIAL_REJECT ) {
	    freejarcs( initialbin );
	    return;
	}
    }

    REAL from[2], to[2];
    qlist->getRange( from, to, spbrkpts, tpbrkpts );

    if( ! initialbin.isnonempty() ) {
	makeBorderTrim( from, to );
    } else {
	REAL rate[2];
	qlist->findRates( spbrkpts, tpbrkpts, rate );

    	if( decompose( initialbin, min(rate[0], rate[1]) ) ) 
	    mylongjmp( jumpbuffer, 31 );
    }

    backend.bgnsurf( renderhints.wiretris, renderhints.wirequads, nuid );
    subdivideInS( initialbin );
    backend.endsurf();
}

void
Subdivider::subdivideInS( Bin& source )
{
    if( renderhints.display_method == N_OUTLINE_PARAM ) {
	outline( source );
	freejarcs( source );
    } else {
	setArcTypeBezier();
	setNonDegenerate();
	splitInS( source, spbrkpts.start, spbrkpts.end );
    }
}


/*---------------------------------------------------------------------------
 * splitInS - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::splitInS( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 0, spbrkpts.pts[i] );
	    splitInS( left, start, i );
	    splitInS( right, i+1, end );
        } else {
	    if( start == spbrkpts.start || start == spbrkpts.end ) {
		freejarcs( source );
	    } else if( renderhints.display_method == N_OUTLINE_PARAM_S ) {
		outline( source );
		freejarcs( source );
	    } else {
		setArcTypeBezier();
		setNonDegenerate();
		s_index = start;
		splitInT( source, tpbrkpts.start, tpbrkpts.end );
	    }
        }
    } 
}

/*---------------------------------------------------------------------------
 * splitInT - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::splitInT( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 1, tpbrkpts.pts[i] );
	    splitInT( left, start, i );
	    splitInT( right, i+1, end );
        } else {
	    if( start == tpbrkpts.start || start == tpbrkpts.end ) {
		freejarcs( source );
	    } else if( renderhints.display_method == N_OUTLINE_PARAM_ST ) {
		outline( source );
		freejarcs( source );
	    } else {
		t_index = start;
		setArcTypeBezier();
		setDegenerate();

		REAL pta[2], ptb[2];
		pta[0] = spbrkpts.pts[s_index-1];
		pta[1] = tpbrkpts.pts[t_index-1];

		ptb[0] = spbrkpts.pts[s_index];
		ptb[1] = tpbrkpts.pts[t_index];
		qlist->downloadAll( pta, ptb, backend );
	    
		Patchlist patchlist( qlist, pta, ptb );
		samplingSplit( source, patchlist, renderhints.maxsubdivisions, 0 );
		setNonDegenerate();
		setArcTypeBezier();
	    }
        }
    } 
}

/*--------------------------------------------------------------------------
 * samplingSplit - recursively subdivide patch, cull check each subpatch  
 *--------------------------------------------------------------------------
 */

void
Subdivider::samplingSplit( 
    Bin& source, 
    Patchlist& patchlist, 
    int subdivisions, 
    int param )
{
    if( ! source.isnonempty() ) return;

    if( patchlist.cullCheck() == CULL_TRIVIAL_REJECT ) {
	freejarcs( source );
	return;
    }

    patchlist.getstepsize();

    if( renderhints.display_method == N_OUTLINE_PATCH ) {
        tessellation( source, patchlist );
	outline( source );
	freejarcs( source );
	return;
    } 

    //patchlist.clamp();

    tessellation( source, patchlist );

    if( patchlist.needsSamplingSubdivision() && (subdivisions > 0) ) {
	if( ! patchlist.needsSubdivision( 0 ) )
	    param = 1;
	else if( ! patchlist.needsSubdivision( 1 ) )
	    param = 0;
	else
	    param = 1 - param;

	Bin left, right;
	REAL mid = ( patchlist.pspec[param].range[0] +
		     patchlist.pspec[param].range[1] ) * 0.5;
	split( source, left, right, param, mid );
	Patchlist subpatchlist( patchlist, param, mid );
	samplingSplit( left, subpatchlist, subdivisions-1, param );
	samplingSplit( right, patchlist, subdivisions-1, param );
    } else {
	setArcTypePwl();
	setDegenerate();
	nonSamplingSplit( source, patchlist, subdivisions, param );
	setDegenerate();
	setArcTypeBezier();
    }
}

void
Subdivider::nonSamplingSplit( 
    Bin& source, 
    Patchlist& patchlist, 
    int subdivisions, 
    int param )
{
    if( patchlist.needsNonSamplingSubdivision() && (subdivisions > 0) ) {
	param = 1 - param;

	Bin left, right;
	REAL mid = ( patchlist.pspec[param].range[0] +
		     patchlist.pspec[param].range[1] ) * 0.5;
	split( source, left, right, param, mid );
	Patchlist subpatchlist( patchlist, param, mid );
	if( left.isnonempty() )
	    if( subpatchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
		freejarcs( left );
	    else
	        nonSamplingSplit( left, subpatchlist, subdivisions-1, param );
	if( right.isnonempty() ) 
	    if( patchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
		freejarcs( right );
	    else
	        nonSamplingSplit( right, patchlist, subdivisions-1, param );

    } else {
	// make bbox calls
	patchlist.bbox();
	backend.patch( patchlist.pspec[0].range[0], patchlist.pspec[0].range[1],
		       patchlist.pspec[1].range[0], patchlist.pspec[1].range[1] );
    
	if( renderhints.display_method == N_OUTLINE_SUBDIV ) {
	    outline( source );
	    freejarcs( source );
	} else {
	    setArcTypePwl();
	    setDegenerate();
	    findIrregularS( source );
	    monosplitInS( source, smbrkpts.start, smbrkpts.end );
	}
    }
}

/*--------------------------------------------------------------------------
 * tessellation - set tessellation of interior and boundary of patch
 *--------------------------------------------------------------------------
 */

void
Subdivider::tessellation( Bin& bin, Patchlist &patchlist )
{
    // tessellate unsampled trim curves
    tessellate( bin, patchlist.pspec[1].sidestep[1], patchlist.pspec[0].sidestep[1],
	 patchlist.pspec[1].sidestep[0], patchlist.pspec[0].sidestep[0] );

    // set interior sampling rates
    slicer.setstriptessellation( patchlist.pspec[0].stepsize, patchlist.pspec[1].stepsize );

    // set boundary sampling rates
    stepsizes[0] = patchlist.pspec[1].stepsize;
    stepsizes[1] = patchlist.pspec[0].stepsize;
    stepsizes[2] = patchlist.pspec[1].stepsize;
    stepsizes[3] = patchlist.pspec[0].stepsize;
}

/*---------------------------------------------------------------------------
 * monosplitInS - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::monosplitInS( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 0, smbrkpts.pts[i] );
	    monosplitInS( left, start, i );
	    monosplitInS( right, i+1, end );
        } else {
	    if( renderhints.display_method == N_OUTLINE_SUBDIV_S ) {
		outline( source );
		freejarcs( source );
	    } else {
		setArcTypePwl();
		setDegenerate();
		findIrregularT( source );
		monosplitInT( source, tmbrkpts.start, tmbrkpts.end );
	    }
        }
    } 
}

/*---------------------------------------------------------------------------
 * monosplitInT - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::monosplitInT( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 1, tmbrkpts.pts[i] );
	    monosplitInT( left, start, i );
	    monosplitInT( right, i+1, end );
        } else {
	    if( renderhints.display_method == N_OUTLINE_SUBDIV_ST ) {
		outline( source );
		freejarcs( source );
	    } else {
		render( source );
		freejarcs( source );
	    }
        }
    } 
}


/*----------------------------------------------------------------------------
 * findIrregularS - determine points of non-monotonicity is s direction
 *----------------------------------------------------------------------------
 */

void
Subdivider::findIrregularS( Bin& bin )
{
    assert( bin.firstarc()->check() != 0 );

    smbrkpts.grow( bin.numarcs() );

    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	REAL *a = jarc->prev->tail();
	REAL *b = jarc->tail();
	REAL *c = jarc->head();

	if( b[1] == a[1] && b[1] == c[1] ) continue;

	if( b[1] <= a[1] && b[1] <= c[1] ) {
	    if( ! ccwTurn_tr( jarc->prev, jarc ) )
                smbrkpts.add( b[0] );
	} else if( b[1] >= a[1] && b[1] >= c[1] ) {
	    if( ! ccwTurn_tl( jarc->prev, jarc ) )
                smbrkpts.add( b[0] );
        }
    }

    smbrkpts.filter();
} 

/*----------------------------------------------------------------------------
 * findIrregularT - determine points of non-monotonicity in t direction
 *		     where one arc is parallel to the s axis.
 *----------------------------------------------------------------------------
 */

void
Subdivider::findIrregularT( Bin& bin )
{
    assert( bin.firstarc()->check() != 0 );

    tmbrkpts.grow( bin.numarcs() );

    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	REAL *a = jarc->prev->tail();
	REAL *b = jarc->tail();
	REAL *c = jarc->head();

	if( b[0] == a[0] && b[0] == c[0] ) continue;

	if( b[0] <= a[0] && b[0] <= c[0] ) {
	    if( a[1] != b[1] && b[1] != c[1] ) continue; 
	    if( ! ccwTurn_sr( jarc->prev, jarc ) )
                tmbrkpts.add( b[1] );
	} else if ( b[0] >= a[0] && b[0] >= c[0] ) {
	    if( a[1] != b[1] && b[1] != c[1] ) continue; 
	    if( ! ccwTurn_sl( jarc->prev, jarc ) )
                tmbrkpts.add( b[1] );
	}
    }
    tmbrkpts.filter( );
}

/*-----------------------------------------------------------------------------
 * makeBorderTrim - if no user input trimming data then create 
 * a trimming curve around the boundaries of the Quilt.  The curve consists of
 * four Jordan arcs, one for each side of the Quilt, connected, of course,
 * head to tail. 
 *-----------------------------------------------------------------------------
 */

void
Subdivider::makeBorderTrim( const REAL *from, const REAL *to )
{ 
    REAL smin = from[0];
    REAL smax = to[0];
    REAL tmin = from[1];
    REAL tmax = to[1];

    pjarc = 0;

    Arc_ptr jarc = new(arcpool) Arc( arc_bottom, 0 );
    arctessellator.bezier( jarc, smin, smax, tmin, tmin );
    initialbin.addarc( jarc  );
    pjarc = jarc->append( pjarc );

    jarc = new(arcpool) Arc( arc_right, 0 );
    arctessellator.bezier( jarc, smax, smax, tmin, tmax );
    initialbin.addarc( jarc  );
    pjarc = jarc->append( pjarc );

    jarc = new(arcpool) Arc( arc_top, 0 );
    arctessellator.bezier( jarc, smax, smin, tmax, tmax );
    initialbin.addarc( jarc  );
    pjarc = jarc->append( pjarc );

    jarc = new(arcpool) Arc( arc_left, 0 );
    arctessellator.bezier( jarc, smin, smin, tmax, tmin );
    initialbin.addarc( jarc  );
    jarc->append( pjarc );

    assert( jarc->check() != 0 );
}

/*----------------------------------------------------------------------------
 * render - renders all monotone regions in a bin and frees the bin
 *----------------------------------------------------------------------------
 */

void
Subdivider::render( Bin& bin )
{
    bin.markall();

#ifdef N_ISOLINE_S
    slicer.setisolines( ( renderhints.display_method == N_ISOLINE_S ) ? 1 : 0 );
#else
    slicer.setisolines( 0 );
#endif

    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( jarc->ismarked() ) {
	    assert( jarc->check( ) != 0 );
	    Arc_ptr jarchead = jarc;
	    do {
		jarc->clearmark();
		jarc = jarc->next;
	    } while (jarc != jarchead);
	    slicer.slice( jarc );
	}
    }
}

/*---------------------------------------------------------------------------
 * outline - render the trimmed patch by outlining the boundary 
 *---------------------------------------------------------------------------
 */

void
Subdivider::outline( Bin& bin )
{
    bin.markall();
    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( jarc->ismarked() ) {
	    assert( jarc->check( ) != 0 );
	    Arc_ptr jarchead = jarc;
	    do {
		slicer.outline( jarc );
		jarc->clearmark();
		jarc = jarc->prev;
	    } while (jarc != jarchead);
	}
    }
}

/*---------------------------------------------------------------------------
 * freejarcs - free all arcs in a bin
 *---------------------------------------------------------------------------
 */

void
Subdivider::freejarcs( Bin& bin )
{
    bin.adopt();	/* XXX - should not be necessary */

    Arc_ptr jarc;
    while( jarc = bin.removearc() ) {
	if( jarc->pwlArc ) jarc->pwlArc->deleteMe( pwlarcpool ); jarc->pwlArc = 0;
	if( jarc->bezierArc) jarc->bezierArc->deleteMe( bezierarcpool ); jarc->bezierArc = 0;
	jarc->deleteMe( arcpool );
    }
}

/*----------------------------------------------------------------------------
 * tessellate - tessellate all Bezier arcs in a bin
 * 		   1) only accepts linear Bezier arcs as input 
 * 		   2) the Bezier arcs are stored in the pwlArc structure
 * 		   3) only vertical or horizontal lines work
 * 		-- should 
 * 		   1) represent Bezier arcs in BezierArc structure
 * 		      (this requires a multitude of changes to the code)
 * 		   2) accept high degree Bezier arcs (hard)
 * 		   3) map the curve onto the surface to determine tessellation
 * 		   4) work for curves of arbitrary geometry
 *----------------------------------------------------------------------------
 */


void
Subdivider::tessellate( Bin& bin, REAL rrate, REAL trate, REAL lrate, REAL brate )
{
    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( jarc->isbezier( ) ) {
    	    assert( jarc->pwlArc->npts == 2 );	
	    TrimVertex  *pts = jarc->pwlArc->pts;
    	    REAL s1 = pts[0].param[0];
    	    REAL t1 = pts[0].param[1];
    	    REAL s2 = pts[1].param[0];
    	    REAL t2 = pts[1].param[1];
	    
    	    jarc->pwlArc->deleteMe( pwlarcpool ); jarc->pwlArc = 0;
	    
	    switch( jarc->getside() ) {
		case arc_left:
		    assert( s1 == s2 );
		    arctessellator.pwl_left( jarc, s1, t1, t2, lrate );
		    break;
		case arc_right:
		    assert( s1 == s2 );
		    arctessellator.pwl_right( jarc, s1, t1, t2, rrate );
		    break;
		case arc_top:
		    assert( t1 == t2 );
		    arctessellator.pwl_top( jarc, t1, s1, s2, trate );
		    break;
		case arc_bottom:
		    assert( t1 == t2 );
		    arctessellator.pwl_bottom( jarc, t1, s1, s2, brate );
		    break;
		case arc_none:
#ifndef NT
		    (void) abort();
#endif
		    break;
	    }
	    assert( ! jarc->isbezier() );
    	    assert( jarc->check() != 0 );
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\trimpool.h ===
#ifndef __glutrimvertpool_h_
#define __glutrimvertpool_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimvertexpool.h - $Revision: 1.1 $
 */

#include "bufpool.h"

class TrimVertex;

#define INIT_VERTLISTSIZE  200

class TrimVertexPool {
public:
    			TrimVertexPool( void );
    			~TrimVertexPool( void );
    void		clear( void );
    TrimVertex *	get( int );
private:
    Pool		pool;
    TrimVertex **	vlist;
    int			nextvlistslot;
    int			vlistsize;
};
#endif /* __glutrimvertpool_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\trimregi.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimregion.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "trimregi.h"
#include "backend.h"

TrimRegion::TrimRegion( void )
{
}

void
TrimRegion::setDu( REAL du )
{
    oneOverDu = 1.0/du;
}

void
TrimRegion::init( long npts, Arc_ptr extrema )
{
    left.init( npts, extrema, extrema->pwlArc->npts - 1 ); 
    left.getNextPt();

    right.init( npts, extrema, 0 ); 
    right.getPrevPt();
}

void
TrimRegion::getPts( Arc_ptr extrema )
{
    left.getNextPts( extrema );
    right.getPrevPts( extrema );
}

void
TrimRegion::getPts( Backend &backend )
{
    left.getNextPts( bot.vval, backend );
    right.getPrevPts( bot.vval, backend );
}

void 
TrimRegion::getGridExtent( void )
{
    getGridExtent( left.last(), right.last() );
}

void
TrimRegion::getGridExtent( TrimVertex *l, TrimVertex *r )
{
    bot.ustart = (long) ((l->param[0] - uarray.uarray[0])*oneOverDu);
    if( l->param[0] >= uarray.uarray[bot.ustart] ) bot.ustart++;
//  if( l->param[0] > uarray.uarray[bot.ustart] ) bot.ustart++;
    assert( l->param[0] <= uarray.uarray[bot.ustart] );
    assert( l->param[0] >= uarray.uarray[bot.ustart-1] );

    bot.uend = (long) ((r->param[0] - uarray.uarray[0])*oneOverDu);
    if( uarray.uarray[bot.uend] >= r->param[0] ) bot.uend--;
//  if( uarray.uarray[bot.uend] > r->param[0] ) bot.uend--;
    assert( r->param[0] >= uarray.uarray[bot.uend] );
    assert( r->param[0] <= uarray.uarray[bot.uend+1] );
}

int
TrimRegion::canTile( void )
{
    TrimVertex *lf = left.first();
    TrimVertex *ll = left.last();
    TrimVertex *l = ( ll->param[0] > lf->param[0] ) ? ll : lf; 

    TrimVertex *rf = right.first();
    TrimVertex *rl = right.last();
    TrimVertex *r = ( rl->param[0] < rf->param[0] ) ? rl : rf;
    return (l->param[0] <= r->param[0]) ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\trimregi.h ===
#ifndef __glutrimregion_h_
#define __glutrimregion_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimregion.h - $Revision: 1.2 $
 */

#include "trimline.h"
#include "gridline.h"
#include "uarray.h"

class Arc;
class Backend;

class TrimRegion {
public:
			TrimRegion();
    Trimline		left;
    Trimline		right;
    Gridline		top;
    Gridline		bot;
    Uarray		uarray;

    void		init( REAL );
    void		advance( REAL, REAL, REAL );
    void		setDu( REAL );
    void		init( long, Arc * );
    void		getPts( Arc * );
    void		getPts( Backend & );
    void		getGridExtent( TrimVertex *, TrimVertex * );
    void		getGridExtent( void );
    int			canTile( void );
private:
    REAL		oneOverDu;
};

inline void
TrimRegion::init( REAL vval ) 
{
    bot.vval = vval;
}

inline void
TrimRegion::advance( REAL topVindex, REAL botVindex, REAL botVval )
{
    top.vindex	= (long) topVindex;
    bot.vindex	= (long) botVindex;
    top.vval	= bot.vval;
    bot.vval	= botVval;
    top.ustart	= bot.ustart;
    top.uend	= bot.uend;
}
#endif /* __glutrimregion_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\trimvert.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimvertexpool.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mystring.h"
#include "trimvert.h"
#include "trimpool.h"
#include "bufpool.h"

/*----------------------------------------------------------------------------
 * TrimVertexPool::TrimVertexPool 
 *----------------------------------------------------------------------------
 */
TrimVertexPool::TrimVertexPool( void )
	: pool( sizeof(TrimVertex)*3, 32, "Threevertspool" )
{
    // initialize array of pointers to vertex lists
    nextvlistslot = 0;
    vlistsize = INIT_VERTLISTSIZE;
    vlist = new TrimVertex_p[vlistsize];
}

/*----------------------------------------------------------------------------
 * TrimVertexPool::~TrimVertexPool 
 *----------------------------------------------------------------------------
 */
TrimVertexPool::~TrimVertexPool( void )
{
    // free all arrays of TrimVertices vertices
    while( nextvlistslot ) {
	delete vlist[--nextvlistslot];
    }

    // reallocate space for array of pointers to vertex lists
    if( vlist ) delete[] vlist;
}

/*----------------------------------------------------------------------------
 * TrimVertexPool::clear 
 *----------------------------------------------------------------------------
 */
void
TrimVertexPool::clear( void )
{
    // reinitialize pool of 3 vertex arrays    
    pool.clear();

    // free all arrays of TrimVertices vertices
    while( nextvlistslot ) {
	delete vlist[--nextvlistslot];
	vlist[nextvlistslot] = 0;
    }

    // reallocate space for array of pointers to vertex lists
    if( vlist ) delete[] vlist;
    vlist = new TrimVertex_p[vlistsize];
}


/*----------------------------------------------------------------------------
 * TrimVertexPool::get - allocate a vertex list
 *----------------------------------------------------------------------------
 */
TrimVertex *
TrimVertexPool::get( int n )
{
    TrimVertex	*v;
    if( n == 3 ) {
	v = (TrimVertex *) pool.new_buffer();
    } else {
        if( nextvlistslot == vlistsize ) {
	    vlistsize *= 2;
	    TrimVertex_p *nvlist = new TrimVertex_p[vlistsize];
	    memcpy( nvlist, vlist, nextvlistslot * sizeof(TrimVertex_p) );
	    if( vlist ) delete[] vlist;
	    vlist = nvlist;
        }
        v = vlist[nextvlistslot++] = new TrimVertex[n];
    }
    return v;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\types.h ===
#ifndef __glutypes_h_
#define __glutypes_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * types.h - $Revision: 1.1 $
 */

//typedef double		INREAL;
#define INREAL          float
typedef float		REAL;
typedef void 		(*Pfvv)( void );
typedef void 		(*Pfvf)( float * );
typedef int		(*cmpfunc)(const void *, const void *);
typedef	REAL		Knot, *Knot_ptr;/* knot values */

#endif /* __glutypes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\trimvert.h ===
#ifndef __glutrimvertex_h_
#define __glutrimvertex_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimvertex.h - $Revision: 1.2 $
 */

#include "types.h"

/*#define USE_OPTTT*/

#ifdef NT
class TrimVertex { public: /* a vertex on a trim curve */
#else
struct TrimVertex { /* a vertex on a trim curve */
#endif
    REAL		param[2];	/* parametric space coords */
#ifdef USE_OPTTT
    REAL                cache_point[4]; //only when USE_OPTTT is on in slicer.c++
    REAL                cache_normal[3];
#endif
    long		nuid;
};

typedef TrimVertex *TrimVertex_p;

inline REAL  
det3( TrimVertex *a, TrimVertex *b, TrimVertex *c ) 
{         
    return a->param[0] * (b->param[1]-c->param[1]) + 
	   b->param[0] * (c->param[1]-a->param[1]) + 
	   c->param[0] * (a->param[1]-b->param[1]);
}

#endif /* __glutrimvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\varray.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * varray.c++ - $Revision: 1.6 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "varray.h"
#include "arc.h"
#include "math.h"         // fabs()

#define TINY 0.0001
inline long sgn( REAL x ) 
{
    return (x < -TINY) ? -1 :  ((x > TINY) ? 1 : 0 );
}


Varray::Varray( void )
{
    varray = 0;
    size = 0;
}

Varray::~Varray( void )
{
    if( varray ) delete[] varray; 
}

inline void
Varray::update( Arc_ptr arc, long dir[2], REAL val )
{
    register long ds = sgn(arc->tail()[0] - arc->prev->tail()[0]);
    register long dt = sgn(arc->tail()[1] - arc->prev->tail()[1]);

    if( dir[0] != ds || dir[1] != dt ) {
	dir[0] = ds;
	dir[1] = dt;
	append( val );
    }
}

void
Varray::grow( long guess )
{
    if( size < guess ) {
	size = guess * 2;
	if( varray ) delete[] varray; 
	varray = new REAL[size];
	assert( varray != 0 );
    }
}

long
Varray::init( REAL delta, Arc_ptr toparc, Arc_ptr botarc )
{
    Arc_ptr left = toparc->next;
    Arc_ptr right = toparc;
    long ldir[2], rdir[2];
    
    ldir[0] = sgn( left->tail()[0] - left->prev->tail()[0] );
    ldir[1] = sgn( left->tail()[1] - left->prev->tail()[1] );
    rdir[0] = sgn( right->tail()[0] - right->prev->tail()[0] );
    rdir[1] = sgn( right->tail()[1] - right->prev->tail()[1] );

    vval[0] = toparc->tail()[1];
    numquads = 0;

    while( 1 ) {
	switch( sgn( left->tail()[1] - right->prev->tail()[1] ) ) {
	case 1:
	    left = left->next;
	    update( left, ldir, left->prev->tail()[1] );
	    break;
	case -1: 
	    right = right->prev;
	    update( right, rdir, right->tail()[1] );
	    break;
	case 0:
	    if( fabs(left->tail()[1] - botarc->tail()[1]) < TINY) goto end;
            if( fabs(left->tail()[0]-right->prev->tail()[0]) < TINY &&
                fabs(left->tail()[1]-right->prev->tail()[1]) < TINY) goto end;
	    left = left->next;
	    break;
 	}
    }

end:
    append( botarc->tail()[1] );

    grow( ((long) ((vval[0] - vval[numquads])/delta)) + numquads + 2 );

    long index = 0;
    for( long i=0; i<numquads; i++ ) {
	voffset[i] = index;
        varray[index++] = vval[i];
	REAL dist = vval[i] - vval[i+1];
	if( dist > delta ) {
	    long steps = ((long) (dist/delta)) +1;
	    float deltav = - dist / (REAL) steps;
	    for( long j=1; j<steps; j++ ) 
		varray[index++] = vval[i] + j * deltav; 
	}
    }
    voffset[i] = index;
    varray[index] = vval[i];
    return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\uarray.h ===
#ifndef __gluuarray_h_
#define __gluuarray_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * uarray.h - $Revision: 1.1 $
 */

#include "types.h"

class Arc;

class Uarray {
private:
    long		size;
    long		ulines;
public:
			Uarray();
			~Uarray();
    long		init( REAL, Arc *, Arc * );
    REAL *		uarray;
};

#endif /* __gluuarray_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\uarray.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * uarray.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "uarray.h"
#include "arc.h"

Uarray::Uarray( void )
{
    uarray = 0;
    size = 0;
}

Uarray::~Uarray( void )
{
    if( uarray ) delete[] uarray;		
}

long
Uarray::init( REAL delta, Arc_ptr lo, Arc_ptr hi )
{
    ulines = (long) ((hi->tail()[0] - lo->tail()[0])/delta) + 3;
    if( size < ulines ) {
	size = ulines * 2;
	if( uarray ) delete[] uarray;		
	uarray = new REAL[size];
	assert( uarray != 0);
    }
    uarray[0] = lo->tail()[0] - delta/2.0;
    for( long i = 1 ; i != ulines; i++ )
	uarray[i] = uarray[0] + i*delta;
    return ulines;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\core\varray.h ===
#ifndef __gluvarray_h_
#define __gluvarray_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * varray.h - $Revision: 1.1 $
 */

#include "types.h"

class Arc;

class Varray {
public:
			Varray();
			~Varray();
    long		init( REAL, Arc *, Arc * );
    REAL *		varray;
    REAL		vval[1000];
    long		voffset[1000];
    long 		numquads;

private:
    long		size;
    inline void		update( Arc *, long[2], REAL );
    void		grow( long );
    inline void		append( REAL );
};

inline void
Varray::append( REAL v ) 
{
    if( v != vval[numquads] )
        vval[++numquads] = v; 
}


#endif /* __gluvarray_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\nt\glue.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include <windows.h>
#include <windef.h>
#include <setjmp.h>

// void *malloc( size_t );

struct JumpBuffer *__glnewJumpBuffer( void )
{
    return (struct JumpBuffer *) LocalAlloc(LMEM_FIXED, sizeof(jmp_buf));
}

extern char *__glNurbsErrors [];
extern WCHAR *__glNurbsErrorsW [];

const char *__glNURBSErrorString( int errno )
{
    return __glNurbsErrors[errno];
}

const WCHAR *__glNURBSErrorStringW( int errno )
{
    return __glNurbsErrorsW[errno];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\glu\nurbs\nt\errinit.c ===
/******************************Module*Header*******************************\
* Module Name: errinit.c
*
* Initialize the NURBS error string tables.
*
* Created: 18-Feb-1994 00:06:53
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include "glstring.h"

static UINT auiNurbsErrors[] = {
    STR_NURB_00,    // " "
    STR_NURB_01,    // "spline order un-supported"
    STR_NURB_02,    // "too few knots"
    STR_NURB_03,    // "valid knot range is empty"
    STR_NURB_04,    // "decreasing knot sequence knot"
    STR_NURB_05,    // "knot multiplicity greater than order of spline"
    STR_NURB_06,    // "endcurve() must follow bgncurve()"
    STR_NURB_07,    // "bgncurve() must precede endcurve()"
    STR_NURB_08,    // "missing or extra geometric data"
    STR_NURB_09,    // "can't draw pwlcurves"
    STR_NURB_10,    // "missing or extra domain data"
    STR_NURB_11,    // "missing or extra domain data"
    STR_NURB_12,    // "endtrim() must precede endsurface()"
    STR_NURB_13,    // "bgnsurface() must precede endsurface()"
    STR_NURB_14,    // "curve of improper type passed as trim curve"
    STR_NURB_15,    // "bgnsurface() must precede bgntrim()"
    STR_NURB_16,    // "endtrim() must follow bgntrim()"
    STR_NURB_17,    // "bgntrim() must precede endtrim()"
    STR_NURB_18,    // "invalid or missing trim curve"
    STR_NURB_19,    // "bgntrim() must precede pwlcurve()"
    STR_NURB_20,    // "pwlcurve referenced twice"
    STR_NURB_21,    // "pwlcurve and nurbscurve mixed"
    STR_NURB_22,    // "improper usage of trim data type"
    STR_NURB_23,    // "nurbscurve referenced twice"
    STR_NURB_24,    // "nurbscurve and pwlcurve mixed"
    STR_NURB_25,    // "nurbssurface referenced twice"
    STR_NURB_26,    // "invalid property"
    STR_NURB_27,    // "endsurface() must follow bgnsurface()"
    STR_NURB_28,    // "intersecting or misoriented trim curves"
    STR_NURB_29,    // "intersecting trim curves"
    STR_NURB_30,    // "UNUSED"
    STR_NURB_31,    // "unconnected trim curves"
    STR_NURB_32,    // "unknown knot error"
    STR_NURB_33,    // "negative vertex count encountered"
    STR_NURB_34,    // "negative byte-stride encounteed"
    STR_NURB_35,    // "unknown type descriptor"
    STR_NURB_36,    // "null control point reference"
    STR_NURB_37     // "duplicate point on pwlcurve"
};

#define NERRORS ( sizeof(auiNurbsErrors)/sizeof(auiNurbsErrors[0]) )

char *__glNurbsErrors[NERRORS];
WCHAR *__glNurbsErrorsW[NERRORS];

VOID vInitNurbStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        for (i = 0; i < NERRORS; i++)
            __glNurbsErrors[i] = pszGetResourceStringA(hMod, auiNurbsErrors[i]);
    }
    else
    {
        for (i = 0; i < NERRORS; i++)
            __glNurbsErrorsW[i] = pwszGetResourceStringW(hMod, auiNurbsErrors[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\alloc.h ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// alloc.h
//
// Global allocation macros and routines.
//
// History:
//  Mon Jun 02 16:53:42 1997	-by-	Drew Bliss [drewb]
//   Created
//
//----------------------------------------------------------------------------

#ifndef __ALLOC_H__
#define __ALLOC_H__

#include <types.h>

//
// Usage notes:
//
// ALLOC is a direct replacement for malloc().
// ALLOCZ allocates zero-filled memory.
// REALLOC is a direct replacement for realloc().
// FREE is a direct replacement for free().
//
// On debug builds these macros evaluate to calls to a memory-tracking
// allocator.  On free builds they make direct heap calls.
// All of the rest of the allocation routines are built on top of the
// above macros and so inherit their tracking capabilities.
//
// The basic allocation routines also provide a mechanism to randomly
// cause allocations to fail via manipulation of the glRandomMallocFail
// variable.
//

#if DBG

extern long glRandomMallocFail;

void * FASTCALL dbgAlloc(UINT nbytes, DWORD flags);
void * FASTCALL dbgRealloc(void *mem, UINT nbytes);
void   FASTCALL dbgFree(void *mem);
int    FASTCALL dbgMemSize(void *mem);

#define ALLOC(nbytes)           dbgAlloc((nbytes), 0)
#define ALLOCZ(nbytes)          dbgAlloc((nbytes), HEAP_ZERO_MEMORY)
#define REALLOC(mem, nbytes)    dbgRealloc((mem), (nbytes))
#define FREE(mem)               dbgFree((mem))

#else // DBG

#define ALLOC(nbytes)           HeapAlloc(GetProcessHeap(), 0, (nbytes))
#define ALLOCZ(nbytes)          HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, \
                                          (nbytes))
#define REALLOC(mem, nbytes)    HeapReAlloc(GetProcessHeap(), 0, (mem), \
                                            (nbytes))
#define FREE(mem)               HeapFree(GetProcessHeap(), 0, (mem))

#endif // DBG

//
// 32-byte aligned memory allocator.
//
void * FASTCALL AllocAlign32(UINT nbytes);
void   FASTCALL FreeAlign32(void *mem);

//
// Short-lived memory allocator.  This allocator should be used
// for relatively small allocations (<= 4K) that are only live for
// a function or two.
//
BOOL   FASTCALL InitTempAlloc(void);
void * FASTCALL gcTempAlloc(__GLcontext *gc, UINT nbytes);
void   FASTCALL gcTempFree(__GLcontext *gc, void *mem);

//
// Allocator wrappers which automatically set the gc error on failure.
// The wrappers don't currently do anything extra on frees but
// having matching free calls allows for per-gc tracking if necessary.
//

// Internal worker function.
void * FASTCALL gcAlloc(__GLcontext *gc, UINT nbytes, DWORD flags);

#define GCALLOC(gc, nbytes)  gcAlloc((gc), (nbytes), 0)
#define GCALLOCZ(gc, nbytes) gcAlloc((gc), (nbytes), HEAP_ZERO_MEMORY)
                                              
void * FASTCALL GCREALLOC(__GLcontext *gc, void *mem, UINT nbytes);
#define         GCFREE(gc, mem) FREE(mem)
                       
void * FASTCALL GCALLOCALIGN32(__GLcontext *gc, UINT nbytes);
#define         GCFREEALIGN32(gc, mem) FreeAlign32(mem)

#endif // #ifndef __ALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\compsize.h ===
/******************************Module*Header*******************************\
* Module Name: compsize.h
*
* Function prototypes and macros to compute size of input buffer.
*
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef __COMPSIZE_H__
#define __COMPSIZE_H__


#ifndef _CLIENTSIDE_
GLint __glCallLists_size(GLint n, GLenum type);
GLint __glCltMap1_size(GLenum target);
GLint __glCltMap2_size(GLenum target);
GLint __glGetMap_size(GLenum target, GLenum query);
GLint __glGetPixelMap_size(GLenum map);
GLint __glGet_size(GLenum pname);

#define __glGetMapdv_size(target,query)                         \
        (__glGetMap_size(target,query)*sizeof(GLdouble))
#define __glGetMapfv_size(target,query)                         \
        (__glGetMap_size(target,query)*sizeof(GLfloat))
#define __glGetMapiv_size(target,query)                         \
        (__glGetMap_size(target,query)*sizeof(GLint))
#define __glGetPixelMapfv_size(map)                             \
        (__glGetPixelMap_size(map)*sizeof(GLfloat))
#define __glGetPixelMapuiv_size(map)                            \
        (__glGetPixelMap_size(map)*sizeof(GLuint))
#define __glGetPixelMapusv_size(map)                            \
        (__glGetPixelMap_size(map)*sizeof(GLushort))
#endif

// FOG_ASSERT
#if !(((GL_FOG_INDEX  +1) == GL_FOG_DENSITY) &&  \
      ((GL_FOG_DENSITY+1) == GL_FOG_START  ) &&  \
      ((GL_FOG_START  +1) == GL_FOG_END    ) &&  \
      ((GL_FOG_END    +1) == GL_FOG_MODE   ) &&  \
      ((GL_FOG_MODE   +1) == GL_FOG_COLOR  )     \
     )
#error "bad fog index ordering"
#endif

// LIGHT_SOURCE_ASSERT
#if !(((GL_AMBIENT             +1) == GL_DIFFUSE              ) && \
      ((GL_DIFFUSE             +1) == GL_SPECULAR             ) && \
      ((GL_SPECULAR            +1) == GL_POSITION             ) && \
      ((GL_POSITION            +1) == GL_SPOT_DIRECTION       ) && \
      ((GL_SPOT_DIRECTION      +1) == GL_SPOT_EXPONENT        ) && \
      ((GL_SPOT_EXPONENT       +1) == GL_SPOT_CUTOFF          ) && \
      ((GL_SPOT_CUTOFF         +1) == GL_CONSTANT_ATTENUATION ) && \
      ((GL_CONSTANT_ATTENUATION+1) == GL_LINEAR_ATTENUATION   ) && \
      ((GL_LINEAR_ATTENUATION  +1) == GL_QUADRATIC_ATTENUATION)    \
     )
#error "bad light source index ordering"
#endif

// LIGHT_MODEL_ASSERT
#if !(((GL_LIGHT_MODEL_LOCAL_VIEWER+1) == GL_LIGHT_MODEL_TWO_SIDE) && \
      ((GL_LIGHT_MODEL_TWO_SIDE    +1) == GL_LIGHT_MODEL_AMBIENT )    \
     )
#error "bad light model index ordering"
#endif

// TEX_GEN_ASSERT
#if !(((GL_TEXTURE_GEN_MODE+1) == GL_OBJECT_PLANE) && \
      ((GL_OBJECT_PLANE+1)     ==  GL_EYE_PLANE)      \
     )
#error "bad tex gen index ordering"
#endif

// TEX_PARAMETER_ASSERT
#if !(((GL_TEXTURE_MAG_FILTER  +1) == GL_TEXTURE_MIN_FILTER   ) && \
      ((GL_TEXTURE_MIN_FILTER  +1) == GL_TEXTURE_WRAP_S       ) && \
      ((GL_TEXTURE_WRAP_S      +1) == GL_TEXTURE_WRAP_T       )    \
     )
#error "bad tex parameter index ordering"
#endif

// PIXEL_MAP_ASSERT
#if !(((GL_PIXEL_MAP_I_TO_I+1) == GL_PIXEL_MAP_S_TO_S) &&               \
      ((GL_PIXEL_MAP_S_TO_S+1) == GL_PIXEL_MAP_I_TO_R) &&               \
      ((GL_PIXEL_MAP_I_TO_R+1) == GL_PIXEL_MAP_I_TO_G) &&               \
      ((GL_PIXEL_MAP_I_TO_G+1) == GL_PIXEL_MAP_I_TO_B) &&               \
      ((GL_PIXEL_MAP_I_TO_B+1) == GL_PIXEL_MAP_I_TO_A) &&               \
      ((GL_PIXEL_MAP_I_TO_A+1) == GL_PIXEL_MAP_R_TO_R) &&               \
      ((GL_PIXEL_MAP_R_TO_R+1) == GL_PIXEL_MAP_G_TO_G) &&               \
      ((GL_PIXEL_MAP_G_TO_G+1) == GL_PIXEL_MAP_B_TO_B) &&               \
      ((GL_PIXEL_MAP_B_TO_B+1) == GL_PIXEL_MAP_A_TO_A) &&               \
      ((GL_PIXEL_MAP_I_TO_I_SIZE+1) == GL_PIXEL_MAP_S_TO_S_SIZE) &&     \
      ((GL_PIXEL_MAP_S_TO_S_SIZE+1) == GL_PIXEL_MAP_I_TO_R_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_R_SIZE+1) == GL_PIXEL_MAP_I_TO_G_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_G_SIZE+1) == GL_PIXEL_MAP_I_TO_B_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_B_SIZE+1) == GL_PIXEL_MAP_I_TO_A_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_A_SIZE+1) == GL_PIXEL_MAP_R_TO_R_SIZE) &&     \
      ((GL_PIXEL_MAP_R_TO_R_SIZE+1) == GL_PIXEL_MAP_G_TO_G_SIZE) &&     \
      ((GL_PIXEL_MAP_G_TO_G_SIZE+1) == GL_PIXEL_MAP_B_TO_B_SIZE) &&     \
      ((GL_PIXEL_MAP_B_TO_B_SIZE+1) == GL_PIXEL_MAP_A_TO_A_SIZE)        \
     )
#error "bad pixel map index ordering"
#endif

// MAP1_ASSERT
#if !(((GL_MAP1_COLOR_4        +1) == GL_MAP1_INDEX          ) &&\
      ((GL_MAP1_INDEX          +1) == GL_MAP1_NORMAL         ) &&\
      ((GL_MAP1_NORMAL         +1) == GL_MAP1_TEXTURE_COORD_1) &&\
      ((GL_MAP1_TEXTURE_COORD_1+1) == GL_MAP1_TEXTURE_COORD_2) &&\
      ((GL_MAP1_TEXTURE_COORD_2+1) == GL_MAP1_TEXTURE_COORD_3) &&\
      ((GL_MAP1_TEXTURE_COORD_3+1) == GL_MAP1_TEXTURE_COORD_4) &&\
      ((GL_MAP1_TEXTURE_COORD_4+1) == GL_MAP1_VERTEX_3       ) &&\
      ((GL_MAP1_VERTEX_3       +1) == GL_MAP1_VERTEX_4       )   \
     )
#error "bad map1 index ordering"
#endif

// MAP2_ASSERT
#if !(((GL_MAP2_COLOR_4        +1) == GL_MAP2_INDEX          ) &&\
      ((GL_MAP2_INDEX          +1) == GL_MAP2_NORMAL         ) &&\
      ((GL_MAP2_NORMAL         +1) == GL_MAP2_TEXTURE_COORD_1) &&\
      ((GL_MAP2_TEXTURE_COORD_1+1) == GL_MAP2_TEXTURE_COORD_2) &&\
      ((GL_MAP2_TEXTURE_COORD_2+1) == GL_MAP2_TEXTURE_COORD_3) &&\
      ((GL_MAP2_TEXTURE_COORD_3+1) == GL_MAP2_TEXTURE_COORD_4) &&\
      ((GL_MAP2_TEXTURE_COORD_4+1) == GL_MAP2_VERTEX_3       ) &&\
      ((GL_MAP2_VERTEX_3       +1) == GL_MAP2_VERTEX_4       )   \
     )
#error "bad map2 index ordering"
#endif

// TYPE_ASSERT
#if !(((GL_BYTE          +1) == GL_UNSIGNED_BYTE ) &&  \
      ((GL_UNSIGNED_BYTE +1) == GL_SHORT         ) &&  \
      ((GL_SHORT         +1) == GL_UNSIGNED_SHORT) &&  \
      ((GL_UNSIGNED_SHORT+1) == GL_INT           ) &&  \
      ((GL_INT           +1) == GL_UNSIGNED_INT  ) &&  \
      ((GL_UNSIGNED_INT  +1) == GL_FLOAT         ) &&  \
      ((GL_FLOAT         +1) == GL_2_BYTES       ) &&  \
      ((GL_2_BYTES       +1) == GL_3_BYTES       ) &&  \
      ((GL_3_BYTES       +1) == GL_4_BYTES       ) &&  \
      ((GL_4_BYTES       +1) == GL_DOUBLE        )     \
     )
#error "bad GL type index ordering"
#endif

// ARRAY_TYPE_ASSERT
#if !(((GL_VERTEX_ARRAY        +1) == GL_NORMAL_ARRAY        ) &&  \
      ((GL_NORMAL_ARRAY        +1) == GL_COLOR_ARRAY         ) &&  \
      ((GL_COLOR_ARRAY         +1) == GL_INDEX_ARRAY         ) &&  \
      ((GL_INDEX_ARRAY         +1) == GL_TEXTURE_COORD_ARRAY ) &&  \
      ((GL_TEXTURE_COORD_ARRAY +1) == GL_EDGE_FLAG_ARRAY     )     \
     )
#error "bad GL array type ordering"
#endif

// INTERLEAVED_FORMAT_ASSERT
#if !(((GL_V2F             +1) == GL_V3F             ) && \
      ((GL_V3F             +1) == GL_C4UB_V2F        ) && \
      ((GL_C4UB_V2F        +1) == GL_C4UB_V3F        ) && \
      ((GL_C4UB_V3F        +1) == GL_C3F_V3F         ) && \
      ((GL_C3F_V3F         +1) == GL_N3F_V3F         ) && \
      ((GL_N3F_V3F         +1) == GL_C4F_N3F_V3F     ) && \
      ((GL_C4F_N3F_V3F     +1) == GL_T2F_V3F         ) && \
      ((GL_T2F_V3F         +1) == GL_T4F_V4F         ) && \
      ((GL_T4F_V4F         +1) == GL_T2F_C4UB_V3F    ) && \
      ((GL_T2F_C4UB_V3F    +1) == GL_T2F_C3F_V3F     ) && \
      ((GL_T2F_C3F_V3F     +1) == GL_T2F_N3F_V3F     ) && \
      ((GL_T2F_N3F_V3F     +1) == GL_T2F_C4F_N3F_V3F ) && \
      ((GL_T2F_C4F_N3F_V3F +1) == GL_T4F_C4F_N3F_V4F )    \
     )
#error "bad GL interleaved array format ordering"
#endif

#ifndef _CLIENTSIDE_
#define GLSETERROR(e)        {DBGLEVEL1(LEVEL_INFO,"GLSETERROR(%ld)\n",e);}
#else
#define GLSETERROR(e)        __glSetError(e)
#endif

#endif /* !__COMPSIZE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\batchinf.h ===
#ifndef __BATCHINF_H__
#define __BATCHINF_H__

#define GLMSG_ALIGN(x)           ((ULONG)((((ULONG_PTR)(x))+7)&-8))

#define GLMSG_ALIGNPTR(x)        ((((ULONG_PTR)(x))+7)&-8)

#define GLMSGBATCHSTATS_CLEAR     0     // Clear values
#define GLMSGBATCHSTATS_GETSTATS  1     // Return values

typedef struct {

    ULONG ServerTrips;          // Number of times the server was called
    ULONG ClientCalls;          // Total number of client calls
    ULONG ServerCalls;          // Total number of server calls

} GLMSGBATCHSTATS;

/*
 *  GLMSGBATCHINFO is the first structure in the shared section
 *
 */

typedef struct _GLMSGBATCHINFO {

    ULONG MaximumOffset;        // Threshold for flushing.
    ULONG FirstOffset;          // Where to put the first message
    ULONG NextOffset;           // Where to place the next message
    ULONG ReturnValue;          // Value returned from the server

#ifdef DOGLMSGBATCHSTATS

    GLMSGBATCHSTATS BatchStats;

#endif /* DOGLMSGBATCHSTATS */

} GLMSGBATCHINFO;

#if DBG

#ifdef DODBGPRINTSTRUCT

#define PRINT_GLMSGBATCHINFO(Text, pMsgBatchInfo)                           \
{                                                                           \
    DbgPrint("%s (%d): %s:\n", __FILE__, __LINE__, Text);                   \
    if (NULL == pMsgBatchInfo)                                              \
    {                                                                       \
        DbgPrint("Cannot print pMsgBatchInfo == NULL\n");                   \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        DbgPrint("pMsgBatchInfo:    0x%08lX\n",                             \
            pMsgBatchInfo                  );                               \
        DbgPrint("MaximumOffset.....0x%08lX\n",                             \
            pMsgBatchInfo->MaximumOffset   );                               \
        DbgPrint("FirstOffset       0x%08lX\n",                             \
            pMsgBatchInfo->FirstOffset     );                               \
        DbgPrint("NextOffset........0x%08lX\n",                             \
            pMsgBatchInfo->NextOffset      );                               \
        DbgPrint("\n");                                                     \
    }                                                                       \
}

#else  /* DOPRINT */

#define PRINT_GLMSGBATCHINFO(Text, pMsgBatchInfo)

#endif /* DOPRINT */

#else /* DBG */

#define PRINT_GLMSGBATCHINFO(Text, pMsgBatchInfo)

#endif /* DBG */


#endif /* __BATCHINF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* OpenGL debugging macros.
*
* Created: 23-Oct-1993 18:33:23
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

//
// LEVEL_ALLOC is the highest level of debug output.  For alloc,free, etc.
// LEVEL_ENTRY is for function entry.
// LEVEL_INFO is for general debug information.
// LEVEL_ERROR is for debug error information.
//
#define LEVEL_ERROR 1L
#define LEVEL_INFO  2L
#define LEVEL_ENTRY 8L
#define LEVEL_ALLOC 10L

#if DBG

extern long glDebugLevel;
extern ULONG glDebugFlags;

#define GLDEBUG_DISABLEMCD      0x00000001  // disable MCD driver
#define GLDEBUG_DISABLEPRIM     0x00000002  // disable MCD primitives
#define GLDEBUG_DISABLEDCI      0x00000004  // disable DCI buffer access

// These debug macros are useful for assertions.  They are not controlled
// by the warning level.

#define WARNING(str)             DbgPrint("%s(%d): " str,__FILE__,__LINE__)
#define WARNING1(str,a)          DbgPrint("%s(%d): " str,__FILE__,__LINE__,a)
#define WARNING2(str,a,b)        DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b)
#define WARNING3(str,a,b,c)      DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c)
#define WARNING4(str,a,b,c,d)    DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c,d)
#define RIP(str)                 {WARNING(str); DebugBreak();}
#define RIP1(str,a)              {WARNING1(str,a); DebugBreak();}
#define RIP2(str,a,b)            {WARNING2(str,a,b); DebugBreak();}
#define ASSERTOPENGL(expr,str)            if(!(expr)) RIP(str)
#define ASSERTOPENGL1(expr,str,a)         if(!(expr)) RIP1(str,a)
#define ASSERTOPENGL2(expr,str,a,b)       if(!(expr)) RIP2(str,a,b)

//
// Use DBGPRINT for general purpose debug message that are NOT
// controlled by the warning level.
//

#define DBGPRINT(str)            DbgPrint("OPENGL32: " str)
#define DBGPRINT1(str,a)         DbgPrint("OPENGL32: " str,a)
#define DBGPRINT2(str,a,b)       DbgPrint("OPENGL32: " str,a,b)
#define DBGPRINT3(str,a,b,c)     DbgPrint("OPENGL32: " str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)   DbgPrint("OPENGL32: " str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e) DbgPrint("OPENGL32: " str,a,b,c,d,e)

//
// Use DBGLEVEL for general purpose debug messages gated by an
// arbitrary warning level.
//
#define DBGLEVEL(n,str)            if (glDebugLevel >= (n)) DBGPRINT(str)
#define DBGLEVEL1(n,str,a)         if (glDebugLevel >= (n)) DBGPRINT1(str,a)
#define DBGLEVEL2(n,str,a,b)       if (glDebugLevel >= (n)) DBGPRINT2(str,a,b)    
#define DBGLEVEL3(n,str,a,b,c)     if (glDebugLevel >= (n)) DBGPRINT3(str,a,b,c)  
#define DBGLEVEL4(n,str,a,b,c,d)   if (glDebugLevel >= (n)) DBGPRINT4(str,a,b,c,d)
#define DBGLEVEL5(n,str,a,b,c,d,e) if (glDebugLevel >= (n)) DBGPRINT5(str,a,b,c,d,e)

//
// Use DBGERROR for error info.  Debug string must not have arguments.
//
#define DBGERROR(s)     if (glDebugLevel >= LEVEL_ERROR) DbgPrint("%s(%d): %s", __FILE__, __LINE__, s)

//
// Use DBGINFO for general debug info.  Debug string must not have
// arguments.
//
#define DBGINFO(s)      if (glDebugLevel >= LEVEL_INFO)  DBGPRINT(s)

//
// Use DBGENTRY for function entry.  Debug string must not have
// arguments.
//
#define DBGENTRY(s)     if (glDebugLevel >= LEVEL_ENTRY) DBGPRINT(s)

//
// DBGBEGIN/DBGEND for more complex debugging output (for
// example, those requiring formatting arguments--%ld, %s, etc.).
//
// Note: DBGBEGIN/END blocks must be bracketed by #if DBG/#endif.  To
// enforce this, we will not define these macros in the DBG == 0 case.
// Therefore, without the #if DBG bracketing use of this macro, a
// compiler (or linker) error will be generated.  This is by design.
//
#define DBGBEGIN(n)     if (glDebugLevel >= (n)) {
#define DBGEND          }

#else

#define WARNING(str)
#define WARNING1(str,a)
#define WARNING2(str,a,b)
#define WARNING3(str,a,b,c)
#define WARNING4(str,a,b,c,d)
#define RIP(str)
#define RIP1(str,a)
#define RIP2(str,a,b)
#define ASSERTOPENGL(expr,str)
#define ASSERTOPENGL1(expr,str,a)
#define ASSERTOPENGL2(expr,str,a,b)
#define DBGPRINT(str)
#define DBGPRINT1(str,a)
#define DBGPRINT2(str,a,b)
#define DBGPRINT3(str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e)
#define DBGLEVEL(n,str)
#define DBGLEVEL1(n,str,a)
#define DBGLEVEL2(n,str,a,b)
#define DBGLEVEL3(n,str,a,b,c)
#define DBGLEVEL4(n,str,a,b,c,d)
#define DBGLEVEL5(n,str,a,b,c,d,e)
#define DBGERROR(s)
#define DBGINFO(s)
#define DBGENTRY(s)

#endif /* DBG */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\dispindx.h ===
/******************************Module*Header*******************************\
* Module Name: dispindx.h
*
* OpenGL API function table indices.  Same as glapi.inc.
*
* Created: 1/15/1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __DISPINDX_H__
#define __DISPINDX_H__

// OpenGL function index in the dispatch table.
// NOTE: Extension indices are based on 336 non-extension indices

#define INDEX_glNewList                 0
#define INDEX_glEndList                 1
#define INDEX_glCallList                2
#define INDEX_glCallLists               3
#define INDEX_glDeleteLists             4
#define INDEX_glGenLists                5
#define INDEX_glListBase                6
#define INDEX_glBegin                   7
#define INDEX_glBitmap                  8
#define INDEX_glColor3b                 9
#define INDEX_glColor3bv                10
#define INDEX_glColor3d                 11
#define INDEX_glColor3dv                12
#define INDEX_glColor3f                 13
#define INDEX_glColor3fv                14
#define INDEX_glColor3i                 15
#define INDEX_glColor3iv                16
#define INDEX_glColor3s                 17
#define INDEX_glColor3sv                18
#define INDEX_glColor3ub                19
#define INDEX_glColor3ubv               20
#define INDEX_glColor3ui                21
#define INDEX_glColor3uiv               22
#define INDEX_glColor3us                23
#define INDEX_glColor3usv               24
#define INDEX_glColor4b                 25
#define INDEX_glColor4bv                26
#define INDEX_glColor4d                 27
#define INDEX_glColor4dv                28
#define INDEX_glColor4f                 29
#define INDEX_glColor4fv                30
#define INDEX_glColor4i                 31
#define INDEX_glColor4iv                32
#define INDEX_glColor4s                 33
#define INDEX_glColor4sv                34
#define INDEX_glColor4ub                35
#define INDEX_glColor4ubv               36
#define INDEX_glColor4ui                37
#define INDEX_glColor4uiv               38
#define INDEX_glColor4us                39
#define INDEX_glColor4usv               40
#define INDEX_glEdgeFlag                41
#define INDEX_glEdgeFlagv               42
#define INDEX_glEnd                     43
#define INDEX_glIndexd                  44
#define INDEX_glIndexdv                 45
#define INDEX_glIndexf                  46
#define INDEX_glIndexfv                 47
#define INDEX_glIndexi                  48
#define INDEX_glIndexiv                 49
#define INDEX_glIndexs                  50
#define INDEX_glIndexsv                 51
#define INDEX_glNormal3b                52
#define INDEX_glNormal3bv               53
#define INDEX_glNormal3d                54
#define INDEX_glNormal3dv               55
#define INDEX_glNormal3f                56
#define INDEX_glNormal3fv               57
#define INDEX_glNormal3i                58
#define INDEX_glNormal3iv               59
#define INDEX_glNormal3s                60
#define INDEX_glNormal3sv               61
#define INDEX_glRasterPos2d             62
#define INDEX_glRasterPos2dv            63
#define INDEX_glRasterPos2f             64
#define INDEX_glRasterPos2fv            65
#define INDEX_glRasterPos2i             66
#define INDEX_glRasterPos2iv            67
#define INDEX_glRasterPos2s             68
#define INDEX_glRasterPos2sv            69
#define INDEX_glRasterPos3d             70
#define INDEX_glRasterPos3dv            71
#define INDEX_glRasterPos3f             72
#define INDEX_glRasterPos3fv            73
#define INDEX_glRasterPos3i             74
#define INDEX_glRasterPos3iv            75
#define INDEX_glRasterPos3s             76
#define INDEX_glRasterPos3sv            77
#define INDEX_glRasterPos4d             78
#define INDEX_glRasterPos4dv            79
#define INDEX_glRasterPos4f             80
#define INDEX_glRasterPos4fv            81
#define INDEX_glRasterPos4i             82
#define INDEX_glRasterPos4iv            83
#define INDEX_glRasterPos4s             84
#define INDEX_glRasterPos4sv            85
#define INDEX_glRectd                   86
#define INDEX_glRectdv                  87
#define INDEX_glRectf                   88
#define INDEX_glRectfv                  89
#define INDEX_glRecti                   90
#define INDEX_glRectiv                  91
#define INDEX_glRects                   92
#define INDEX_glRectsv                  93
#define INDEX_glTexCoord1d              94
#define INDEX_glTexCoord1dv             95
#define INDEX_glTexCoord1f              96
#define INDEX_glTexCoord1fv             97
#define INDEX_glTexCoord1i              98
#define INDEX_glTexCoord1iv             99
#define INDEX_glTexCoord1s              100
#define INDEX_glTexCoord1sv             101
#define INDEX_glTexCoord2d              102
#define INDEX_glTexCoord2dv             103
#define INDEX_glTexCoord2f              104
#define INDEX_glTexCoord2fv             105
#define INDEX_glTexCoord2i              106
#define INDEX_glTexCoord2iv             107
#define INDEX_glTexCoord2s              108
#define INDEX_glTexCoord2sv             109
#define INDEX_glTexCoord3d              110
#define INDEX_glTexCoord3dv             111
#define INDEX_glTexCoord3f              112
#define INDEX_glTexCoord3fv             113
#define INDEX_glTexCoord3i              114
#define INDEX_glTexCoord3iv             115
#define INDEX_glTexCoord3s              116
#define INDEX_glTexCoord3sv             117
#define INDEX_glTexCoord4d              118
#define INDEX_glTexCoord4dv             119
#define INDEX_glTexCoord4f              120
#define INDEX_glTexCoord4fv             121
#define INDEX_glTexCoord4i              122
#define INDEX_glTexCoord4iv             123
#define INDEX_glTexCoord4s              124
#define INDEX_glTexCoord4sv             125
#define INDEX_glVertex2d                126
#define INDEX_glVertex2dv               127
#define INDEX_glVertex2f                128
#define INDEX_glVertex2fv               129
#define INDEX_glVertex2i                130
#define INDEX_glVertex2iv               131
#define INDEX_glVertex2s                132
#define INDEX_glVertex2sv               133
#define INDEX_glVertex3d                134
#define INDEX_glVertex3dv               135
#define INDEX_glVertex3f                136
#define INDEX_glVertex3fv               137
#define INDEX_glVertex3i                138
#define INDEX_glVertex3iv               139
#define INDEX_glVertex3s                140
#define INDEX_glVertex3sv               141
#define INDEX_glVertex4d                142
#define INDEX_glVertex4dv               143
#define INDEX_glVertex4f                144
#define INDEX_glVertex4fv               145
#define INDEX_glVertex4i                146
#define INDEX_glVertex4iv               147
#define INDEX_glVertex4s                148
#define INDEX_glVertex4sv               149
#define INDEX_glClipPlane               150
#define INDEX_glColorMaterial           151
#define INDEX_glCullFace                152
#define INDEX_glFogf                    153
#define INDEX_glFogfv                   154
#define INDEX_glFogi                    155
#define INDEX_glFogiv                   156
#define INDEX_glFrontFace               157
#define INDEX_glHint                    158
#define INDEX_glLightf                  159
#define INDEX_glLightfv                 160
#define INDEX_glLighti                  161
#define INDEX_glLightiv                 162
#define INDEX_glLightModelf             163
#define INDEX_glLightModelfv            164
#define INDEX_glLightModeli             165
#define INDEX_glLightModeliv            166
#define INDEX_glLineStipple             167
#define INDEX_glLineWidth               168
#define INDEX_glMaterialf               169
#define INDEX_glMaterialfv              170
#define INDEX_glMateriali               171
#define INDEX_glMaterialiv              172
#define INDEX_glPointSize               173
#define INDEX_glPolygonMode             174
#define INDEX_glPolygonStipple          175
#define INDEX_glScissor                 176
#define INDEX_glShadeModel              177
#define INDEX_glTexParameterf           178
#define INDEX_glTexParameterfv          179
#define INDEX_glTexParameteri           180
#define INDEX_glTexParameteriv          181
#define INDEX_glTexImage1D              182
#define INDEX_glTexImage2D              183
#define INDEX_glTexEnvf                 184
#define INDEX_glTexEnvfv                185
#define INDEX_glTexEnvi                 186
#define INDEX_glTexEnviv                187
#define INDEX_glTexGend                 188
#define INDEX_glTexGendv                189
#define INDEX_glTexGenf                 190
#define INDEX_glTexGenfv                191
#define INDEX_glTexGeni                 192
#define INDEX_glTexGeniv                193
#define INDEX_glFeedbackBuffer          194
#define INDEX_glSelectBuffer            195
#define INDEX_glRenderMode              196
#define INDEX_glInitNames               197
#define INDEX_glLoadName                198
#define INDEX_glPassThrough             199
#define INDEX_glPopName                 200
#define INDEX_glPushName                201
#define INDEX_glDrawBuffer              202
#define INDEX_glClear                   203
#define INDEX_glClearAccum              204
#define INDEX_glClearIndex              205
#define INDEX_glClearColor              206
#define INDEX_glClearStencil            207
#define INDEX_glClearDepth              208
#define INDEX_glStencilMask             209
#define INDEX_glColorMask               210
#define INDEX_glDepthMask               211
#define INDEX_glIndexMask               212
#define INDEX_glAccum                   213
#define INDEX_glDisable                 214
#define INDEX_glEnable                  215
#define INDEX_glFinish                  216
#define INDEX_glFlush                   217
#define INDEX_glPopAttrib               218
#define INDEX_glPushAttrib              219
#define INDEX_glMap1d                   220
#define INDEX_glMap1f                   221
#define INDEX_glMap2d                   222
#define INDEX_glMap2f                   223
#define INDEX_glMapGrid1d               224
#define INDEX_glMapGrid1f               225
#define INDEX_glMapGrid2d               226
#define INDEX_glMapGrid2f               227
#define INDEX_glEvalCoord1d             228
#define INDEX_glEvalCoord1dv            229
#define INDEX_glEvalCoord1f             230
#define INDEX_glEvalCoord1fv            231
#define INDEX_glEvalCoord2d             232
#define INDEX_glEvalCoord2dv            233
#define INDEX_glEvalCoord2f             234
#define INDEX_glEvalCoord2fv            235
#define INDEX_glEvalMesh1               236
#define INDEX_glEvalPoint1              237
#define INDEX_glEvalMesh2               238
#define INDEX_glEvalPoint2              239
#define INDEX_glAlphaFunc               240
#define INDEX_glBlendFunc               241
#define INDEX_glLogicOp                 242
#define INDEX_glStencilFunc             243
#define INDEX_glStencilOp               244
#define INDEX_glDepthFunc               245
#define INDEX_glPixelZoom               246
#define INDEX_glPixelTransferf          247
#define INDEX_glPixelTransferi          248
#define INDEX_glPixelStoref             249
#define INDEX_glPixelStorei             250
#define INDEX_glPixelMapfv              251
#define INDEX_glPixelMapuiv             252
#define INDEX_glPixelMapusv             253
#define INDEX_glReadBuffer              254
#define INDEX_glCopyPixels              255
#define INDEX_glReadPixels              256
#define INDEX_glDrawPixels              257
#define INDEX_glGetBooleanv             258
#define INDEX_glGetClipPlane            259
#define INDEX_glGetDoublev              260
#define INDEX_glGetError                261
#define INDEX_glGetFloatv               262
#define INDEX_glGetIntegerv             263
#define INDEX_glGetLightfv              264
#define INDEX_glGetLightiv              265
#define INDEX_glGetMapdv                266
#define INDEX_glGetMapfv                267
#define INDEX_glGetMapiv                268
#define INDEX_glGetMaterialfv           269
#define INDEX_glGetMaterialiv           270
#define INDEX_glGetPixelMapfv           271
#define INDEX_glGetPixelMapuiv          272
#define INDEX_glGetPixelMapusv          273
#define INDEX_glGetPolygonStipple       274
#define INDEX_glGetString               275
#define INDEX_glGetTexEnvfv             276
#define INDEX_glGetTexEnviv             277
#define INDEX_glGetTexGendv             278
#define INDEX_glGetTexGenfv             279
#define INDEX_glGetTexGeniv             280
#define INDEX_glGetTexImage             281
#define INDEX_glGetTexParameterfv       282
#define INDEX_glGetTexParameteriv       283
#define INDEX_glGetTexLevelParameterfv  284
#define INDEX_glGetTexLevelParameteriv  285
#define INDEX_glIsEnabled               286
#define INDEX_glIsList                  287
#define INDEX_glDepthRange              288
#define INDEX_glFrustum                 289
#define INDEX_glLoadIdentity            290
#define INDEX_glLoadMatrixf             291
#define INDEX_glLoadMatrixd             292
#define INDEX_glMatrixMode              293
#define INDEX_glMultMatrixf             294
#define INDEX_glMultMatrixd             295
#define INDEX_glOrtho                   296
#define INDEX_glPopMatrix               297
#define INDEX_glPushMatrix              298
#define INDEX_glRotated                 299
#define INDEX_glRotatef                 300
#define INDEX_glScaled                  301
#define INDEX_glScalef                  302
#define INDEX_glTranslated              303
#define INDEX_glTranslatef              304
#define INDEX_glViewport                305
#define INDEX_glArrayElement            306
#define INDEX_glBindTexture             307
#define INDEX_glColorPointer            308
#define INDEX_glDisableClientState      309
#define INDEX_glDrawArrays              310
#define INDEX_glDrawElements            311
#define INDEX_glEdgeFlagPointer         312
#define INDEX_glEnableClientState       313
#define INDEX_glIndexPointer            314
#define INDEX_glIndexub                 315
#define INDEX_glIndexubv                316
#define INDEX_glInterleavedArrays       317
#define INDEX_glNormalPointer           318
#define INDEX_glPolygonOffset           319
#define INDEX_glTexCoordPointer         320
#define INDEX_glVertexPointer           321
#define INDEX_glAreTexturesResident     322
#define INDEX_glCopyTexImage1D          323
#define INDEX_glCopyTexImage2D          324
#define INDEX_glCopyTexSubImage1D       325
#define INDEX_glCopyTexSubImage2D       326
#define INDEX_glDeleteTextures          327
#define INDEX_glGenTextures             328
#define INDEX_glGetPointerv             329
#define INDEX_glIsTexture               330
#define INDEX_glPrioritizeTextures      331
#define INDEX_glTexSubImage1D           332
#define INDEX_glTexSubImage2D           333
#define INDEX_glPopClientAttrib         334
#define INDEX_glPushClientAttrib        335
#define INDEX_glLastFunc                335

#if !(INDEX_glLastFunc == INDEX_glPushClientAttrib)
#error "bad last function index\n"
#endif

#define INDEX_glDrawRangeElementsWIN        (INDEX_glLastFunc+1)
#define INDEX_glColorTableEXT               (INDEX_glLastFunc+2)
#define INDEX_glColorSubTableEXT            (INDEX_glLastFunc+3)
#define INDEX_glGetColorTableEXT            (INDEX_glLastFunc+4)
#define INDEX_glGetColorTableParameterivEXT (INDEX_glLastFunc+5)
#define INDEX_glGetColorTableParameterfvEXT (INDEX_glLastFunc+6)
#define INDEX_glCurrentTextureIndexWIN      (INDEX_glLastFunc+7)
#define INDEX_glMultiTexCoord1dWIN          (INDEX_glLastFunc+8)
#define INDEX_glMultiTexCoord1dvWIN         (INDEX_glLastFunc+9)
#define INDEX_glMultiTexCoord1fWIN          (INDEX_glLastFunc+10)
#define INDEX_glMultiTexCoord1fvWIN         (INDEX_glLastFunc+11)
#define INDEX_glMultiTexCoord1iWIN          (INDEX_glLastFunc+12)
#define INDEX_glMultiTexCoord1ivWIN         (INDEX_glLastFunc+13)
#define INDEX_glMultiTexCoord1sWIN          (INDEX_glLastFunc+14)
#define INDEX_glMultiTexCoord1svWIN         (INDEX_glLastFunc+15)
#define INDEX_glMultiTexCoord2dWIN          (INDEX_glLastFunc+16)
#define INDEX_glMultiTexCoord2dvWIN         (INDEX_glLastFunc+17)
#define INDEX_glMultiTexCoord2fWIN          (INDEX_glLastFunc+18)
#define INDEX_glMultiTexCoord2fvWIN         (INDEX_glLastFunc+19)
#define INDEX_glMultiTexCoord2iWIN          (INDEX_glLastFunc+20)
#define INDEX_glMultiTexCoord2ivWIN         (INDEX_glLastFunc+21)
#define INDEX_glMultiTexCoord2sWIN          (INDEX_glLastFunc+22)
#define INDEX_glMultiTexCoord2svWIN         (INDEX_glLastFunc+23)
#define INDEX_glMultiTexCoord3dWIN          (INDEX_glLastFunc+24)
#define INDEX_glMultiTexCoord3dvWIN         (INDEX_glLastFunc+25)
#define INDEX_glMultiTexCoord3fWIN          (INDEX_glLastFunc+26)
#define INDEX_glMultiTexCoord3fvWIN         (INDEX_glLastFunc+27)
#define INDEX_glMultiTexCoord3iWIN          (INDEX_glLastFunc+28)
#define INDEX_glMultiTexCoord3ivWIN         (INDEX_glLastFunc+29)
#define INDEX_glMultiTexCoord3sWIN          (INDEX_glLastFunc+30)
#define INDEX_glMultiTexCoord3svWIN         (INDEX_glLastFunc+31)
#define INDEX_glMultiTexCoord4dWIN          (INDEX_glLastFunc+32)
#define INDEX_glMultiTexCoord4dvWIN         (INDEX_glLastFunc+33)
#define INDEX_glMultiTexCoord4fWIN          (INDEX_glLastFunc+34)
#define INDEX_glMultiTexCoord4fvWIN         (INDEX_glLastFunc+35)
#define INDEX_glMultiTexCoord4iWIN          (INDEX_glLastFunc+36)
#define INDEX_glMultiTexCoord4ivWIN         (INDEX_glLastFunc+37)
#define INDEX_glMultiTexCoord4sWIN          (INDEX_glLastFunc+38)
#define INDEX_glMultiTexCoord4svWIN         (INDEX_glLastFunc+39)
#define INDEX_glBindNthTextureWIN           (INDEX_glLastFunc+40)
#define INDEX_glNthTexCombineFuncWIN        (INDEX_glLastFunc+41)

// OpenGL function index in the dispatch table cache in the TEB.
// These indices are used to access the FP cache in the TEB.  These
// cached functions have less overhead because we can avoid dereferencing
// the dispatch table pointer stored in the TEB (save one level of
// indirection).
//
// NOTE: If you modify these indices, you also need to modify the
// GLDISPATCHTABLE_FAST structure definiton.

#define FASTINDEX_glCallList            0
#define FASTINDEX_glCallLists           1
#define FASTINDEX_glBegin               2
#define FASTINDEX_glColor3b             3
#define FASTINDEX_glColor3bv            4
#define FASTINDEX_glColor3d             5
#define FASTINDEX_glColor3dv            6
#define FASTINDEX_glColor3f             7
#define FASTINDEX_glColor3fv            8
#define FASTINDEX_glColor3i             9
#define FASTINDEX_glColor3iv            10
#define FASTINDEX_glColor3s             11
#define FASTINDEX_glColor3sv            12
#define FASTINDEX_glColor3ub            13
#define FASTINDEX_glColor3ubv           14
#define FASTINDEX_glColor3ui            15
#define FASTINDEX_glColor3uiv           16
#define FASTINDEX_glColor3us            17
#define FASTINDEX_glColor3usv           18
#define FASTINDEX_glColor4b             19
#define FASTINDEX_glColor4bv            20
#define FASTINDEX_glColor4d             21
#define FASTINDEX_glColor4dv            22
#define FASTINDEX_glColor4f             23
#define FASTINDEX_glColor4fv            24
#define FASTINDEX_glColor4i             25
#define FASTINDEX_glColor4iv            26
#define FASTINDEX_glColor4s             27
#define FASTINDEX_glColor4sv            28
#define FASTINDEX_glColor4ub            29
#define FASTINDEX_glColor4ubv           30
#define FASTINDEX_glColor4ui            31
#define FASTINDEX_glColor4uiv           32
#define FASTINDEX_glColor4us            33
#define FASTINDEX_glColor4usv           34
#define FASTINDEX_glEdgeFlag            35
#define FASTINDEX_glEdgeFlagv           36
#define FASTINDEX_glEnd                 37
#define FASTINDEX_glIndexd              38
#define FASTINDEX_glIndexdv             39
#define FASTINDEX_glIndexf              40
#define FASTINDEX_glIndexfv             41
#define FASTINDEX_glIndexi              42
#define FASTINDEX_glIndexiv             43
#define FASTINDEX_glIndexs              44
#define FASTINDEX_glIndexsv             45
#define FASTINDEX_glNormal3b            46
#define FASTINDEX_glNormal3bv           47
#define FASTINDEX_glNormal3d            48
#define FASTINDEX_glNormal3dv           49
#define FASTINDEX_glNormal3f            50
#define FASTINDEX_glNormal3fv           51
#define FASTINDEX_glNormal3i            52
#define FASTINDEX_glNormal3iv           53
#define FASTINDEX_glNormal3s            54
#define FASTINDEX_glNormal3sv           55
#define FASTINDEX_glTexCoord1d          56
#define FASTINDEX_glTexCoord1dv         57
#define FASTINDEX_glTexCoord1f          58
#define FASTINDEX_glTexCoord1fv         59
#define FASTINDEX_glTexCoord1i          60
#define FASTINDEX_glTexCoord1iv         61
#define FASTINDEX_glTexCoord1s          62
#define FASTINDEX_glTexCoord1sv         63
#define FASTINDEX_glTexCoord2d          64
#define FASTINDEX_glTexCoord2dv         65
#define FASTINDEX_glTexCoord2f          66
#define FASTINDEX_glTexCoord2fv         67
#define FASTINDEX_glTexCoord2i          68
#define FASTINDEX_glTexCoord2iv         69
#define FASTINDEX_glTexCoord2s          70
#define FASTINDEX_glTexCoord2sv         71
#define FASTINDEX_glTexCoord3d          72
#define FASTINDEX_glTexCoord3dv         73
#define FASTINDEX_glTexCoord3f          74
#define FASTINDEX_glTexCoord3fv         75
#define FASTINDEX_glTexCoord3i          76
#define FASTINDEX_glTexCoord3iv         77
#define FASTINDEX_glTexCoord3s          78
#define FASTINDEX_glTexCoord3sv         79
#define FASTINDEX_glTexCoord4d          80
#define FASTINDEX_glTexCoord4dv         81
#define FASTINDEX_glTexCoord4f          82
#define FASTINDEX_glTexCoord4fv         83
#define FASTINDEX_glTexCoord4i          84
#define FASTINDEX_glTexCoord4iv         85
#define FASTINDEX_glTexCoord4s          86
#define FASTINDEX_glTexCoord4sv         87
#define FASTINDEX_glVertex2d            88
#define FASTINDEX_glVertex2dv           89
#define FASTINDEX_glVertex2f            90
#define FASTINDEX_glVertex2fv           91
#define FASTINDEX_glVertex2i            92
#define FASTINDEX_glVertex2iv           93
#define FASTINDEX_glVertex2s            94
#define FASTINDEX_glVertex2sv           95
#define FASTINDEX_glVertex3d            96
#define FASTINDEX_glVertex3dv           97
#define FASTINDEX_glVertex3f            98
#define FASTINDEX_glVertex3fv           99
#define FASTINDEX_glVertex3i            100
#define FASTINDEX_glVertex3iv           101
#define FASTINDEX_glVertex3s            102
#define FASTINDEX_glVertex3sv           103
#define FASTINDEX_glVertex4d            104
#define FASTINDEX_glVertex4dv           105
#define FASTINDEX_glVertex4f            106
#define FASTINDEX_glVertex4fv           107
#define FASTINDEX_glVertex4i            108
#define FASTINDEX_glVertex4iv           109
#define FASTINDEX_glVertex4s            110
#define FASTINDEX_glVertex4sv           111
#define FASTINDEX_glMaterialf           112
#define FASTINDEX_glMaterialfv          113
#define FASTINDEX_glMateriali           114
#define FASTINDEX_glMaterialiv          115
#define FASTINDEX_glDisable             116
#define FASTINDEX_glEnable              117
#define FASTINDEX_glPopAttrib           118
#define FASTINDEX_glPushAttrib          119
#define FASTINDEX_glEvalCoord1d         120
#define FASTINDEX_glEvalCoord1dv        121
#define FASTINDEX_glEvalCoord1f         122
#define FASTINDEX_glEvalCoord1fv        123
#define FASTINDEX_glEvalCoord2d         124
#define FASTINDEX_glEvalCoord2dv        125
#define FASTINDEX_glEvalCoord2f         126
#define FASTINDEX_glEvalCoord2fv        127
#define FASTINDEX_glEvalPoint1          128
#define FASTINDEX_glEvalPoint2          129
#define FASTINDEX_glLoadIdentity        130
#define FASTINDEX_glLoadMatrixf         131
#define FASTINDEX_glLoadMatrixd         132
#define FASTINDEX_glMatrixMode          133
#define FASTINDEX_glMultMatrixf         134
#define FASTINDEX_glMultMatrixd         135
#define FASTINDEX_glPopMatrix           136
#define FASTINDEX_glPushMatrix          137
#define FASTINDEX_glRotated             138
#define FASTINDEX_glRotatef             139
#define FASTINDEX_glScaled              140
#define FASTINDEX_glScalef              141
#define FASTINDEX_glTranslated          142
#define FASTINDEX_glTranslatef          143
#define FASTINDEX_glArrayElement        144
#define FASTINDEX_glBindTexture         145
#define FASTINDEX_glColorPointer        146
#define FASTINDEX_glDisableClientState  147
#define FASTINDEX_glDrawArrays          148
#define FASTINDEX_glDrawElements        149
#define FASTINDEX_glEdgeFlagPointer     150
#define FASTINDEX_glEnableClientState   151
#define FASTINDEX_glIndexPointer        152
#define FASTINDEX_glIndexub             153
#define FASTINDEX_glIndexubv            154
#define FASTINDEX_glInterleavedArrays   155
#define FASTINDEX_glNormalPointer       156
#define FASTINDEX_glPolygonOffset       157
#define FASTINDEX_glTexCoordPointer     158
#define FASTINDEX_glVertexPointer       159
#define FASTINDEX_glGetPointerv         160
#define FASTINDEX_glPopClientAttrib     161
#define FASTINDEX_glPushClientAttrib    162
#define FASTINDEX_glDrawRangeElementsWIN 163
#define FASTINDEX_glColorTableEXT       164
#define FASTINDEX_glColorSubTableEXT    165
#define FASTINDEX_glCurrentTextureIndexWIN 166
#define FASTINDEX_glBindNthTextureWIN   167
#define FASTINDEX_glNthTexCombineFuncWIN 168
#define FASTINDEX_glMultiTexCoord1fWIN  169
#define FASTINDEX_glMultiTexCoord1fvWIN 170
#define FASTINDEX_glMultiTexCoord1iWIN  171
#define FASTINDEX_glMultiTexCoord1ivWIN 172
#define FASTINDEX_glMultiTexCoord2fWIN  173
#define FASTINDEX_glMultiTexCoord2fvWIN 174
#define FASTINDEX_glMultiTexCoord2iWIN  175
#define FASTINDEX_glMultiTexCoord2ivWIN 176

#endif /* !__DISPINDX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\exttable.h ===
/******************************Module*Header*******************************\
* Module Name: exttable.h
*
* Dispatch table for extension functions
*
* Created: 11/27/95
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/

#ifndef __EXTTABLE_H__
#define __EXTTABLE_H__

typedef struct _GLEXTDISPATCHTABLE
{
    void (APIENTRY *glDrawRangeElementsWIN)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
    void (APIENTRY *glColorTableEXT)       ( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
    void (APIENTRY *glColorSubTableEXT)    ( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
    void (APIENTRY *glGetColorTableEXT)    ( GLenum target, GLenum format, GLenum type, GLvoid *data);
    void (APIENTRY *glGetColorTableParameterivEXT) ( GLenum target, GLenum pname, GLint *params);
    void (APIENTRY *glGetColorTableParameterfvEXT) ( GLenum target, GLenum pname, GLfloat *params);
#ifdef GL_WIN_multiple_textures
    void (APIENTRY *glCurrentTextureIndexWIN)
        (GLuint index);
    void (APIENTRY *glMultiTexCoord1dWIN)
        (GLbitfield mask, GLdouble s);
    void (APIENTRY *glMultiTexCoord1dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord1fWIN)
        (GLbitfield mask, GLfloat s);
    void (APIENTRY *glMultiTexCoord1fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord1iWIN)
        (GLbitfield mask, GLint s);
    void (APIENTRY *glMultiTexCoord1ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord1sWIN)
        (GLbitfield mask, GLshort s);
    void (APIENTRY *glMultiTexCoord1svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glMultiTexCoord2dWIN)
        (GLbitfield mask, GLdouble s, GLdouble t);
    void (APIENTRY *glMultiTexCoord2dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord2fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t);
    void (APIENTRY *glMultiTexCoord2fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord2iWIN)
        (GLbitfield mask, GLint s, GLint t);
    void (APIENTRY *glMultiTexCoord2ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord2sWIN)
        (GLbitfield mask, GLshort s, GLshort t);
    void (APIENTRY *glMultiTexCoord2svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glMultiTexCoord3dWIN)
        (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
    void (APIENTRY *glMultiTexCoord3dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord3fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
    void (APIENTRY *glMultiTexCoord3fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord3iWIN)
        (GLbitfield mask, GLint s, GLint t, GLint r);
    void (APIENTRY *glMultiTexCoord3ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord3sWIN)
        (GLbitfield mask, GLshort s, GLshort t, GLshort r);
    void (APIENTRY *glMultiTexCoord3svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glMultiTexCoord4dWIN)
        (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
    void (APIENTRY *glMultiTexCoord4dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord4fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
    void (APIENTRY *glMultiTexCoord4fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord4iWIN)
        (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
    void (APIENTRY *glMultiTexCoord4ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord4sWIN)
        (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
    void (APIENTRY *glMultiTexCoord4svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glBindNthTextureWIN)
        (GLuint index, GLenum target, GLuint texture);
    void (APIENTRY *glNthTexCombineFuncWIN)
        (GLuint index,
         GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
         GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures
} GLEXTDISPATCHTABLE, *PGLEXTDISPATCHTABLE;

typedef struct _GLEXTPROCTABLE
{
    int                cEntries;        // Number of function entries in table
    GLEXTDISPATCHTABLE glDispatchTable; // OpenGL function dispatch table
} GLEXTPROCTABLE, *PGLEXTPROCTABLE;

#endif // __EXTTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glapi.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: glapi.inc
;
; OpenGL API function table indices.
;
; Created: 11/16/1993
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1993 Microsoft Corporation
;----------------------------------------------------------------------;

; OpenGL function index in the dispatch table.
; NOTE: Extension indices are based on 336 non-extension indices

INDEX_glNewList                 equ     0
INDEX_glEndList                 equ     1
INDEX_glCallList                equ     2
INDEX_glCallLists               equ     3
INDEX_glDeleteLists             equ     4
INDEX_glGenLists                equ     5
INDEX_glListBase                equ     6
INDEX_glBegin                   equ     7
INDEX_glBitmap                  equ     8
INDEX_glColor3b                 equ     9
INDEX_glColor3bv                equ     10
INDEX_glColor3d                 equ     11
INDEX_glColor3dv                equ     12
INDEX_glColor3f                 equ     13
INDEX_glColor3fv                equ     14
INDEX_glColor3i                 equ     15
INDEX_glColor3iv                equ     16
INDEX_glColor3s                 equ     17
INDEX_glColor3sv                equ     18
INDEX_glColor3ub                equ     19
INDEX_glColor3ubv               equ     20
INDEX_glColor3ui                equ     21
INDEX_glColor3uiv               equ     22
INDEX_glColor3us                equ     23
INDEX_glColor3usv               equ     24
INDEX_glColor4b                 equ     25
INDEX_glColor4bv                equ     26
INDEX_glColor4d                 equ     27
INDEX_glColor4dv                equ     28
INDEX_glColor4f                 equ     29
INDEX_glColor4fv                equ     30
INDEX_glColor4i                 equ     31
INDEX_glColor4iv                equ     32
INDEX_glColor4s                 equ     33
INDEX_glColor4sv                equ     34
INDEX_glColor4ub                equ     35
INDEX_glColor4ubv               equ     36
INDEX_glColor4ui                equ     37
INDEX_glColor4uiv               equ     38
INDEX_glColor4us                equ     39
INDEX_glColor4usv               equ     40
INDEX_glEdgeFlag                equ     41
INDEX_glEdgeFlagv               equ     42
INDEX_glEnd                     equ     43
INDEX_glIndexd                  equ     44
INDEX_glIndexdv                 equ     45
INDEX_glIndexf                  equ     46
INDEX_glIndexfv                 equ     47
INDEX_glIndexi                  equ     48
INDEX_glIndexiv                 equ     49
INDEX_glIndexs                  equ     50
INDEX_glIndexsv                 equ     51
INDEX_glNormal3b                equ     52
INDEX_glNormal3bv               equ     53
INDEX_glNormal3d                equ     54
INDEX_glNormal3dv               equ     55
INDEX_glNormal3f                equ     56
INDEX_glNormal3fv               equ     57
INDEX_glNormal3i                equ     58
INDEX_glNormal3iv               equ     59
INDEX_glNormal3s                equ     60
INDEX_glNormal3sv               equ     61
INDEX_glRasterPos2d             equ     62
INDEX_glRasterPos2dv            equ     63
INDEX_glRasterPos2f             equ     64
INDEX_glRasterPos2fv            equ     65
INDEX_glRasterPos2i             equ     66
INDEX_glRasterPos2iv            equ     67
INDEX_glRasterPos2s             equ     68
INDEX_glRasterPos2sv            equ     69
INDEX_glRasterPos3d             equ     70
INDEX_glRasterPos3dv            equ     71
INDEX_glRasterPos3f             equ     72
INDEX_glRasterPos3fv            equ     73
INDEX_glRasterPos3i             equ     74
INDEX_glRasterPos3iv            equ     75
INDEX_glRasterPos3s             equ     76
INDEX_glRasterPos3sv            equ     77
INDEX_glRasterPos4d             equ     78
INDEX_glRasterPos4dv            equ     79
INDEX_glRasterPos4f             equ     80
INDEX_glRasterPos4fv            equ     81
INDEX_glRasterPos4i             equ     82
INDEX_glRasterPos4iv            equ     83
INDEX_glRasterPos4s             equ     84
INDEX_glRasterPos4sv            equ     85
INDEX_glRectd                   equ     86
INDEX_glRectdv                  equ     87
INDEX_glRectf                   equ     88
INDEX_glRectfv                  equ     89
INDEX_glRecti                   equ     90
INDEX_glRectiv                  equ     91
INDEX_glRects                   equ     92
INDEX_glRectsv                  equ     93
INDEX_glTexCoord1d              equ     94
INDEX_glTexCoord1dv             equ     95
INDEX_glTexCoord1f              equ     96
INDEX_glTexCoord1fv             equ     97
INDEX_glTexCoord1i              equ     98
INDEX_glTexCoord1iv             equ     99
INDEX_glTexCoord1s              equ     100
INDEX_glTexCoord1sv             equ     101
INDEX_glTexCoord2d              equ     102
INDEX_glTexCoord2dv             equ     103
INDEX_glTexCoord2f              equ     104
INDEX_glTexCoord2fv             equ     105
INDEX_glTexCoord2i              equ     106
INDEX_glTexCoord2iv             equ     107
INDEX_glTexCoord2s              equ     108
INDEX_glTexCoord2sv             equ     109
INDEX_glTexCoord3d              equ     110
INDEX_glTexCoord3dv             equ     111
INDEX_glTexCoord3f              equ     112
INDEX_glTexCoord3fv             equ     113
INDEX_glTexCoord3i              equ     114
INDEX_glTexCoord3iv             equ     115
INDEX_glTexCoord3s              equ     116
INDEX_glTexCoord3sv             equ     117
INDEX_glTexCoord4d              equ     118
INDEX_glTexCoord4dv             equ     119
INDEX_glTexCoord4f              equ     120
INDEX_glTexCoord4fv             equ     121
INDEX_glTexCoord4i              equ     122
INDEX_glTexCoord4iv             equ     123
INDEX_glTexCoord4s              equ     124
INDEX_glTexCoord4sv             equ     125
INDEX_glVertex2d                equ     126
INDEX_glVertex2dv               equ     127
INDEX_glVertex2f                equ     128
INDEX_glVertex2fv               equ     129
INDEX_glVertex2i                equ     130
INDEX_glVertex2iv               equ     131
INDEX_glVertex2s                equ     132
INDEX_glVertex2sv               equ     133
INDEX_glVertex3d                equ     134
INDEX_glVertex3dv               equ     135
INDEX_glVertex3f                equ     136
INDEX_glVertex3fv               equ     137
INDEX_glVertex3i                equ     138
INDEX_glVertex3iv               equ     139
INDEX_glVertex3s                equ     140
INDEX_glVertex3sv               equ     141
INDEX_glVertex4d                equ     142
INDEX_glVertex4dv               equ     143
INDEX_glVertex4f                equ     144
INDEX_glVertex4fv               equ     145
INDEX_glVertex4i                equ     146
INDEX_glVertex4iv               equ     147
INDEX_glVertex4s                equ     148
INDEX_glVertex4sv               equ     149
INDEX_glClipPlane               equ     150
INDEX_glColorMaterial           equ     151
INDEX_glCullFace                equ     152
INDEX_glFogf                    equ     153
INDEX_glFogfv                   equ     154
INDEX_glFogi                    equ     155
INDEX_glFogiv                   equ     156
INDEX_glFrontFace               equ     157
INDEX_glHint                    equ     158
INDEX_glLightf                  equ     159
INDEX_glLightfv                 equ     160
INDEX_glLighti                  equ     161
INDEX_glLightiv                 equ     162
INDEX_glLightModelf             equ     163
INDEX_glLightModelfv            equ     164
INDEX_glLightModeli             equ     165
INDEX_glLightModeliv            equ     166
INDEX_glLineStipple             equ     167
INDEX_glLineWidth               equ     168
INDEX_glMaterialf               equ     169
INDEX_glMaterialfv              equ     170
INDEX_glMateriali               equ     171
INDEX_glMaterialiv              equ     172
INDEX_glPointSize               equ     173
INDEX_glPolygonMode             equ     174
INDEX_glPolygonStipple          equ     175
INDEX_glScissor                 equ     176
INDEX_glShadeModel              equ     177
INDEX_glTexParameterf           equ     178
INDEX_glTexParameterfv          equ     179
INDEX_glTexParameteri           equ     180
INDEX_glTexParameteriv          equ     181
INDEX_glTexImage1D              equ     182
INDEX_glTexImage2D              equ     183
INDEX_glTexEnvf                 equ     184
INDEX_glTexEnvfv                equ     185
INDEX_glTexEnvi                 equ     186
INDEX_glTexEnviv                equ     187
INDEX_glTexGend                 equ     188
INDEX_glTexGendv                equ     189
INDEX_glTexGenf                 equ     190
INDEX_glTexGenfv                equ     191
INDEX_glTexGeni                 equ     192
INDEX_glTexGeniv                equ     193
INDEX_glFeedbackBuffer          equ     194
INDEX_glSelectBuffer            equ     195
INDEX_glRenderMode              equ     196
INDEX_glInitNames               equ     197
INDEX_glLoadName                equ     198
INDEX_glPassThrough             equ     199
INDEX_glPopName                 equ     200
INDEX_glPushName                equ     201
INDEX_glDrawBuffer              equ     202
INDEX_glClear                   equ     203
INDEX_glClearAccum              equ     204
INDEX_glClearIndex              equ     205
INDEX_glClearColor              equ     206
INDEX_glClearStencil            equ     207
INDEX_glClearDepth              equ     208
INDEX_glStencilMask             equ     209
INDEX_glColorMask               equ     210
INDEX_glDepthMask               equ     211
INDEX_glIndexMask               equ     212
INDEX_glAccum                   equ     213
INDEX_glDisable                 equ     214
INDEX_glEnable                  equ     215
INDEX_glFinish                  equ     216
INDEX_glFlush                   equ     217
INDEX_glPopAttrib               equ     218
INDEX_glPushAttrib              equ     219
INDEX_glMap1d                   equ     220
INDEX_glMap1f                   equ     221
INDEX_glMap2d                   equ     222
INDEX_glMap2f                   equ     223
INDEX_glMapGrid1d               equ     224
INDEX_glMapGrid1f               equ     225
INDEX_glMapGrid2d               equ     226
INDEX_glMapGrid2f               equ     227
INDEX_glEvalCoord1d             equ     228
INDEX_glEvalCoord1dv            equ     229
INDEX_glEvalCoord1f             equ     230
INDEX_glEvalCoord1fv            equ     231
INDEX_glEvalCoord2d             equ     232
INDEX_glEvalCoord2dv            equ     233
INDEX_glEvalCoord2f             equ     234
INDEX_glEvalCoord2fv            equ     235
INDEX_glEvalMesh1               equ     236
INDEX_glEvalPoint1              equ     237
INDEX_glEvalMesh2               equ     238
INDEX_glEvalPoint2              equ     239
INDEX_glAlphaFunc               equ     240
INDEX_glBlendFunc               equ     241
INDEX_glLogicOp                 equ     242
INDEX_glStencilFunc             equ     243
INDEX_glStencilOp               equ     244
INDEX_glDepthFunc               equ     245
INDEX_glPixelZoom               equ     246
INDEX_glPixelTransferf          equ     247
INDEX_glPixelTransferi          equ     248
INDEX_glPixelStoref             equ     249
INDEX_glPixelStorei             equ     250
INDEX_glPixelMapfv              equ     251
INDEX_glPixelMapuiv             equ     252
INDEX_glPixelMapusv             equ     253
INDEX_glReadBuffer              equ     254
INDEX_glCopyPixels              equ     255
INDEX_glReadPixels              equ     256
INDEX_glDrawPixels              equ     257
INDEX_glGetBooleanv             equ     258
INDEX_glGetClipPlane            equ     259
INDEX_glGetDoublev              equ     260
INDEX_glGetError                equ     261
INDEX_glGetFloatv               equ     262
INDEX_glGetIntegerv             equ     263
INDEX_glGetLightfv              equ     264
INDEX_glGetLightiv              equ     265
INDEX_glGetMapdv                equ     266
INDEX_glGetMapfv                equ     267
INDEX_glGetMapiv                equ     268
INDEX_glGetMaterialfv           equ     269
INDEX_glGetMaterialiv           equ     270
INDEX_glGetPixelMapfv           equ     271
INDEX_glGetPixelMapuiv          equ     272
INDEX_glGetPixelMapusv          equ     273
INDEX_glGetPolygonStipple       equ     274
INDEX_glGetString               equ     275
INDEX_glGetTexEnvfv             equ     276
INDEX_glGetTexEnviv             equ     277
INDEX_glGetTexGendv             equ     278
INDEX_glGetTexGenfv             equ     279
INDEX_glGetTexGeniv             equ     280
INDEX_glGetTexImage             equ     281
INDEX_glGetTexParameterfv       equ     282
INDEX_glGetTexParameteriv       equ     283
INDEX_glGetTexLevelParameterfv  equ     284
INDEX_glGetTexLevelParameteriv  equ     285
INDEX_glIsEnabled               equ     286
INDEX_glIsList                  equ     287
INDEX_glDepthRange              equ     288
INDEX_glFrustum                 equ     289
INDEX_glLoadIdentity            equ     290
INDEX_glLoadMatrixf             equ     291
INDEX_glLoadMatrixd             equ     292
INDEX_glMatrixMode              equ     293
INDEX_glMultMatrixf             equ     294
INDEX_glMultMatrixd             equ     295
INDEX_glOrtho                   equ     296
INDEX_glPopMatrix               equ     297
INDEX_glPushMatrix              equ     298
INDEX_glRotated                 equ     299
INDEX_glRotatef                 equ     300
INDEX_glScaled                  equ     301
INDEX_glScalef                  equ     302
INDEX_glTranslated              equ     303
INDEX_glTranslatef              equ     304
INDEX_glViewport                equ     305
INDEX_glArrayElement            equ     306
INDEX_glBindTexture             equ     307
INDEX_glColorPointer            equ     308
INDEX_glDisableClientState      equ     309
INDEX_glDrawArrays              equ     310
INDEX_glDrawElements            equ     311
INDEX_glEdgeFlagPointer         equ     312
INDEX_glEnableClientState       equ     313
INDEX_glIndexPointer            equ     314
INDEX_glIndexub                 equ     315
INDEX_glIndexubv                equ     316
INDEX_glInterleavedArrays       equ     317
INDEX_glNormalPointer           equ     318
INDEX_glPolygonOffset           equ     319
INDEX_glTexCoordPointer         equ     320
INDEX_glVertexPointer           equ     321
INDEX_glAreTexturesResident     equ     322
INDEX_glCopyTexImage1D          equ     323
INDEX_glCopyTexImage2D          equ     324
INDEX_glCopyTexSubImage1D       equ     325
INDEX_glCopyTexSubImage2D       equ     326
INDEX_glDeleteTextures          equ     327
INDEX_glGenTextures             equ     328
INDEX_glGetPointerv             equ     329
INDEX_glIsTexture               equ     330
INDEX_glPrioritizeTextures      equ     331
INDEX_glTexSubImage1D           equ     332
INDEX_glTexSubImage2D           equ     333
INDEX_glPopClientAttrib         equ     334
INDEX_glPushClientAttrib        equ     335
INDEX_glLastFunc                equ     335

INDEX_glDrawRangeElementsWIN    equ     (INDEX_glLastFunc+1)
INDEX_glColorTableEXT           equ     (INDEX_glLastFunc+2)
INDEX_glColorSubTableEXT        equ     (INDEX_glLastFunc+3)
INDEX_glGetColorTableEXT        equ     (INDEX_glLastFunc+4)
INDEX_glGetColorTableParameterivEXT equ (INDEX_glLastFunc+5)
INDEX_glGetColorTableParameterfvEXT equ (INDEX_glLastFunc+6)
INDEX_glCurrentTextureIndexWIN	equ     (INDEX_glLastFunc+7)
INDEX_glMultiTexCoord1dWIN	equ     (INDEX_glLastFunc+8)
INDEX_glMultiTexCoord1dvWIN	equ     (INDEX_glLastFunc+9)
INDEX_glMultiTexCoord1fWIN	equ     (INDEX_glLastFunc+10)
INDEX_glMultiTexCoord1fvWIN	equ     (INDEX_glLastFunc+11)
INDEX_glMultiTexCoord1iWIN	equ     (INDEX_glLastFunc+12)
INDEX_glMultiTexCoord1ivWIN	equ     (INDEX_glLastFunc+13)
INDEX_glMultiTexCoord1sWIN	equ     (INDEX_glLastFunc+14)
INDEX_glMultiTexCoord1svWIN	equ     (INDEX_glLastFunc+15)
INDEX_glMultiTexCoord2dWIN	equ     (INDEX_glLastFunc+16)
INDEX_glMultiTexCoord2dvWIN	equ     (INDEX_glLastFunc+17)
INDEX_glMultiTexCoord2fWIN	equ     (INDEX_glLastFunc+18)
INDEX_glMultiTexCoord2fvWIN	equ     (INDEX_glLastFunc+19)
INDEX_glMultiTexCoord2iWIN	equ     (INDEX_glLastFunc+20)
INDEX_glMultiTexCoord2ivWIN	equ     (INDEX_glLastFunc+21)
INDEX_glMultiTexCoord2sWIN	equ     (INDEX_glLastFunc+22)
INDEX_glMultiTexCoord2svWIN	equ     (INDEX_glLastFunc+23)
INDEX_glMultiTexCoord3dWIN	equ     (INDEX_glLastFunc+24)
INDEX_glMultiTexCoord3dvWIN	equ     (INDEX_glLastFunc+25)
INDEX_glMultiTexCoord3fWIN	equ     (INDEX_glLastFunc+26)
INDEX_glMultiTexCoord3fvWIN	equ     (INDEX_glLastFunc+27)
INDEX_glMultiTexCoord3iWIN	equ     (INDEX_glLastFunc+28)
INDEX_glMultiTexCoord3ivWIN	equ     (INDEX_glLastFunc+29)
INDEX_glMultiTexCoord3sWIN	equ     (INDEX_glLastFunc+30)
INDEX_glMultiTexCoord3svWIN	equ     (INDEX_glLastFunc+31)
INDEX_glMultiTexCoord4dWIN	equ     (INDEX_glLastFunc+32)
INDEX_glMultiTexCoord4dvWIN	equ     (INDEX_glLastFunc+33)
INDEX_glMultiTexCoord4fWIN	equ     (INDEX_glLastFunc+34)
INDEX_glMultiTexCoord4fvWIN	equ     (INDEX_glLastFunc+35)
INDEX_glMultiTexCoord4iWIN	equ     (INDEX_glLastFunc+36)
INDEX_glMultiTexCoord4ivWIN	equ     (INDEX_glLastFunc+37)
INDEX_glMultiTexCoord4sWIN	equ     (INDEX_glLastFunc+38)
INDEX_glMultiTexCoord4svWIN	equ     (INDEX_glLastFunc+39)
INDEX_glBindNthTextureWIN	equ     (INDEX_glLastFunc+40)
INDEX_glNthTexCombineFuncWIN	equ     (INDEX_glLastFunc+41)

; OpenGL function index in the dispatch table cache in the TEB.

FASTINDEX_glCallList            equ     0
FASTINDEX_glCallLists           equ     1
FASTINDEX_glBegin               equ     2
FASTINDEX_glColor3b             equ     3
FASTINDEX_glColor3bv            equ     4
FASTINDEX_glColor3d             equ     5
FASTINDEX_glColor3dv            equ     6
FASTINDEX_glColor3f             equ     7
FASTINDEX_glColor3fv            equ     8
FASTINDEX_glColor3i             equ     9
FASTINDEX_glColor3iv            equ     10
FASTINDEX_glColor3s             equ     11
FASTINDEX_glColor3sv            equ     12
FASTINDEX_glColor3ub            equ     13
FASTINDEX_glColor3ubv           equ     14
FASTINDEX_glColor3ui            equ     15
FASTINDEX_glColor3uiv           equ     16
FASTINDEX_glColor3us            equ     17
FASTINDEX_glColor3usv           equ     18
FASTINDEX_glColor4b             equ     19
FASTINDEX_glColor4bv            equ     20
FASTINDEX_glColor4d             equ     21
FASTINDEX_glColor4dv            equ     22
FASTINDEX_glColor4f             equ     23
FASTINDEX_glColor4fv            equ     24
FASTINDEX_glColor4i             equ     25
FASTINDEX_glColor4iv            equ     26
FASTINDEX_glColor4s             equ     27
FASTINDEX_glColor4sv            equ     28
FASTINDEX_glColor4ub            equ     29
FASTINDEX_glColor4ubv           equ     30
FASTINDEX_glColor4ui            equ     31
FASTINDEX_glColor4uiv           equ     32
FASTINDEX_glColor4us            equ     33
FASTINDEX_glColor4usv           equ     34
FASTINDEX_glEdgeFlag            equ     35
FASTINDEX_glEdgeFlagv           equ     36
FASTINDEX_glEnd                 equ     37
FASTINDEX_glIndexd              equ     38
FASTINDEX_glIndexdv             equ     39
FASTINDEX_glIndexf              equ     40
FASTINDEX_glIndexfv             equ     41
FASTINDEX_glIndexi              equ     42
FASTINDEX_glIndexiv             equ     43
FASTINDEX_glIndexs              equ     44
FASTINDEX_glIndexsv             equ     45
FASTINDEX_glNormal3b            equ     46
FASTINDEX_glNormal3bv           equ     47
FASTINDEX_glNormal3d            equ     48
FASTINDEX_glNormal3dv           equ     49
FASTINDEX_glNormal3f            equ     50
FASTINDEX_glNormal3fv           equ     51
FASTINDEX_glNormal3i            equ     52
FASTINDEX_glNormal3iv           equ     53
FASTINDEX_glNormal3s            equ     54
FASTINDEX_glNormal3sv           equ     55
FASTINDEX_glTexCoord1d          equ     56
FASTINDEX_glTexCoord1dv         equ     57
FASTINDEX_glTexCoord1f          equ     58
FASTINDEX_glTexCoord1fv         equ     59
FASTINDEX_glTexCoord1i          equ     60
FASTINDEX_glTexCoord1iv         equ     61
FASTINDEX_glTexCoord1s          equ     62
FASTINDEX_glTexCoord1sv         equ     63
FASTINDEX_glTexCoord2d          equ     64
FASTINDEX_glTexCoord2dv         equ     65
FASTINDEX_glTexCoord2f          equ     66
FASTINDEX_glTexCoord2fv         equ     67
FASTINDEX_glTexCoord2i          equ     68
FASTINDEX_glTexCoord2iv         equ     69
FASTINDEX_glTexCoord2s          equ     70
FASTINDEX_glTexCoord2sv         equ     71
FASTINDEX_glTexCoord3d          equ     72
FASTINDEX_glTexCoord3dv         equ     73
FASTINDEX_glTexCoord3f          equ     74
FASTINDEX_glTexCoord3fv         equ     75
FASTINDEX_glTexCoord3i          equ     76
FASTINDEX_glTexCoord3iv         equ     77
FASTINDEX_glTexCoord3s          equ     78
FASTINDEX_glTexCoord3sv         equ     79
FASTINDEX_glTexCoord4d          equ     80
FASTINDEX_glTexCoord4dv         equ     81
FASTINDEX_glTexCoord4f          equ     82
FASTINDEX_glTexCoord4fv         equ     83
FASTINDEX_glTexCoord4i          equ     84
FASTINDEX_glTexCoord4iv         equ     85
FASTINDEX_glTexCoord4s          equ     86
FASTINDEX_glTexCoord4sv         equ     87
FASTINDEX_glVertex2d            equ     88
FASTINDEX_glVertex2dv           equ     89
FASTINDEX_glVertex2f            equ     90
FASTINDEX_glVertex2fv           equ     91
FASTINDEX_glVertex2i            equ     92
FASTINDEX_glVertex2iv           equ     93
FASTINDEX_glVertex2s            equ     94
FASTINDEX_glVertex2sv           equ     95
FASTINDEX_glVertex3d            equ     96
FASTINDEX_glVertex3dv           equ     97
FASTINDEX_glVertex3f            equ     98
FASTINDEX_glVertex3fv           equ     99
FASTINDEX_glVertex3i            equ     100
FASTINDEX_glVertex3iv           equ     101
FASTINDEX_glVertex3s            equ     102
FASTINDEX_glVertex3sv           equ     103
FASTINDEX_glVertex4d            equ     104
FASTINDEX_glVertex4dv           equ     105
FASTINDEX_glVertex4f            equ     106
FASTINDEX_glVertex4fv           equ     107
FASTINDEX_glVertex4i            equ     108
FASTINDEX_glVertex4iv           equ     109
FASTINDEX_glVertex4s            equ     110
FASTINDEX_glVertex4sv           equ     111
FASTINDEX_glMaterialf           equ     112
FASTINDEX_glMaterialfv          equ     113
FASTINDEX_glMateriali           equ     114
FASTINDEX_glMaterialiv          equ     115
FASTINDEX_glDisable             equ     116
FASTINDEX_glEnable              equ     117
FASTINDEX_glPopAttrib           equ     118
FASTINDEX_glPushAttrib          equ     119
FASTINDEX_glEvalCoord1d         equ     120
FASTINDEX_glEvalCoord1dv        equ     121
FASTINDEX_glEvalCoord1f         equ     122
FASTINDEX_glEvalCoord1fv        equ     123
FASTINDEX_glEvalCoord2d         equ     124
FASTINDEX_glEvalCoord2dv        equ     125
FASTINDEX_glEvalCoord2f         equ     126
FASTINDEX_glEvalCoord2fv        equ     127
FASTINDEX_glEvalPoint1          equ     128
FASTINDEX_glEvalPoint2          equ     129
FASTINDEX_glLoadIdentity        equ     130
FASTINDEX_glLoadMatrixf         equ     131
FASTINDEX_glLoadMatrixd         equ     132
FASTINDEX_glMatrixMode          equ     133
FASTINDEX_glMultMatrixf         equ     134
FASTINDEX_glMultMatrixd         equ     135
FASTINDEX_glPopMatrix           equ     136
FASTINDEX_glPushMatrix          equ     137
FASTINDEX_glRotated             equ     138
FASTINDEX_glRotatef             equ     139
FASTINDEX_glScaled              equ     140
FASTINDEX_glScalef              equ     141
FASTINDEX_glTranslated          equ     142
FASTINDEX_glTranslatef          equ     143
FASTINDEX_glArrayElement        equ     144
FASTINDEX_glBindTexture         equ     145
FASTINDEX_glColorPointer        equ     146
FASTINDEX_glDisableClientState  equ     147
FASTINDEX_glDrawArrays          equ     148
FASTINDEX_glDrawElements        equ     149
FASTINDEX_glEdgeFlagPointer     equ     150
FASTINDEX_glEnableClientState   equ     151
FASTINDEX_glIndexPointer        equ     152
FASTINDEX_glIndexub             equ     153
FASTINDEX_glIndexubv            equ     154
FASTINDEX_glInterleavedArrays   equ     155
FASTINDEX_glNormalPointer       equ     156
FASTINDEX_glPolygonOffset       equ     157
FASTINDEX_glTexCoordPointer     equ     158
FASTINDEX_glVertexPointer       equ     159
FASTINDEX_glGetPointerv         equ     160
FASTINDEX_glPopClientAttrib     equ     161
FASTINDEX_glPushClientAttrib    equ     162
FASTINDEX_glDrawRangeElementsWIN equ    163
FASTINDEX_glColorTableEXT       equ     164
FASTINDEX_glColorSubTableEXT    equ     165
FASTINDEX_glCurrentTextureIndexWIN equ  166
FASTINDEX_glBindNthTextureWIN	equ     167
FASTINDEX_glNthTexCombineFuncWIN equ    168
FASTINDEX_glMultiTexCoord1fWIN	equ     169
FASTINDEX_glMultiTexCoord1fvWIN	equ     170
FASTINDEX_glMultiTexCoord1iWIN	equ     171
FASTINDEX_glMultiTexCoord1ivWIN	equ     172
FASTINDEX_glMultiTexCoord2fWIN	equ     173
FASTINDEX_glMultiTexCoord2fvWIN	equ     174
FASTINDEX_glMultiTexCoord2iWIN	equ     175
FASTINDEX_glMultiTexCoord2ivWIN	equ     176
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glos.h ===
#ifndef __GLOS_H__
#define __GLOS_H__

#ifdef NT

#ifdef GLU32

/*
 *  Turn off a bunch of stuff so the we can compile the glu cleanly.
 *
 *  NOGDI       ; No gdi prototypes. (was having problems with 'Arc'
 *              ; being defined as a class and as a function
 *  NOMINMAX    ; The glu code defines its own inline min, max functions
 */

#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#include <windows.h>

/* Disable long to float conversion warning */
#pragma warning (disable:4244)

#else

#include <windows.h>

#endif  /* GLU32 */


#define GLOS_ALTCALL    WINAPI      /* Alternate calling convention     */
#define GLOS_CCALL      WINAPIV     /* C calling convention             */
#define GLOS_CALLBACK   CALLBACK

#endif  /* NT */

#ifdef UNIX

/*
 * ALTCALL and CCALL are used in the x86 world
 * to specify calling conventions.
 */

#define GLOS_ALTCALL
#define GLOS_CCALL
#define GLOS_CALLBACK

#endif  /* UNIX */

#endif  /* !__GLOS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glgenwin.h ===
/******************************Module*Header*******************************\
* Module Name: glgenwin.h
*
* Client side replacement for WNDOBJ.  Tracks window state (size, location,
* clip region, etc.).
*
* Created: 12-Jan-1995 00:31:42
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef _GLGENWIN_H_
#define _GLGENWIN_H_

// Tracks lock/unlock calls on windows if defined.  This is always
// on for checked builds.
#define TRACK_WINCRIT

#if DBG && !defined(TRACK_WINCRIT)
#define TRACK_WINCRIT
#endif

// Not defined in NT 3.51!
typedef ULONG FLONG;

/*
 * GLGENscan structure
 *
 * Represents a single scan of a region.  Consists of a top, a bottom
 * and an even number of walls.
 *
 * Part of the GLGENscanData structure.
 */
typedef struct GLGENscanRec GLGENscan;
typedef struct GLGENscanRec
{
// Accelerator points to next GLGENscan in the array (we could compute).

    GLGENscan *pNext;

    ULONG     cWalls;
    LONG      top;
    LONG      bottom;
#ifdef _IA64_
	LONG      pad;
#endif
    LONG      alWalls[1];   // array of walls

} GLGENscan;

/*
 * GLGENscanData structure
 *
 * Scan line oriented version of the visible region info in the RGNDATA
 * structure.
 */
typedef struct GLGENscanDataRec
{
    ULONG     cScans;
    GLGENscan aScans[1];    // array of scans

} GLGENscanData;

/*
 * GLGENlayerInfo structure
 *
 * Information about an overlay/underlay.
 */
typedef struct GLGENlayerInfo
{
    LONG     cPalEntries;
    COLORREF pPalEntries[1];
} GLGENlayerInfo;

/*
 * GLGENlayers structure
 *
 *
 */
typedef struct GLGENlayers
{
    GLGENlayerInfo *overlayInfo[15];
    GLGENlayerInfo *underlayInfo[15];
} GLGENlayers;

/*
 * Identifying information for a window
 */

#define GLWID_ERROR          0
#define GLWID_HWND           1
#define GLWID_HDC            2
#define GLWID_DDRAW          3

typedef struct IDirectDrawSurface *LPDIRECTDRAWSURFACE;

typedef struct _GLWINDOWID
{
    int iType;
    HWND hwnd;
    HDC hdc;
    LPDIRECTDRAWSURFACE pdds;
} GLWINDOWID;

#define CLC_TRIVIAL     0
#define CLC_RECT        1
#define CLC_COMPLEX     2

/*
 * GLGENwindows structure
 *
 * Substitute for the NT DDI's WNDOBJ service.  This structure is used to
 * track the current state of a window (size, location, clipping).  A
 * semaphore protected linked list of these is kept globally per-process.
 */
typedef struct GLGENwindowRec GLGENwindow;
typedef struct GLGENwindowRec
{
    struct __GLGENbuffersRec *buffers; // Buffer information
    int         clipComplexity; // Clipping area complexity
    RECTL       rclBounds;      // Clip area bounds
    RECTL       rclClient;      // Window client rect
    GLGENwindow *pNext;         // linked list
    GLWINDOWID  gwid;           // Identifying information
    int         ipfd;           // pixel format assigned to this window
    int         ipfdDevMax;     // max. device pixel format
    WNDPROC     pfnOldWndProc;  // original WndProc function
    ULONG       ulPaletteUniq;  // uniq palette id
    ULONG       ulFlags;

// These fields are used for direct screen access

    LPDIRECTDRAWCLIPPER pddClip;// DirectDraw clipper assocated with window
    UINT        cjrgndat;       // size of RGNDATA struct
    RGNDATA     *prgndat;       // pointer to RGNDATA struct

// Scan version of RGNDATA.

    UINT        cjscandat;      // size of GLGENscanData struct
    GLGENscanData *pscandat;    // pointer to GLGENscanData struct

// Installable client drivers ONLY.

    PVOID       pvDriver;       // pointer to GLDRIVER for window

// Layer palettes for MCD drivers ONLY.

    GLGENlayers *plyr;          // pointer to GLGENlayers for window
                                // non-NULL only if overlays for MCD are
                                // actively in use

    // DirectDraw surface vtbl pointer for doing DDraw surface validation
    void *pvSurfaceVtbl;
    
    // DirectDraw surface locked if DIRECTSCREEN is set
    LPDIRECTDRAWSURFACE pddsDirectScreen;
    void *pvDirectScreen;
    void *pvDirectScreenLock;

    // MCD server-side handle for this window
    ULONG_PTR dwMcdWindow;

    //
    // Reference counting and serialization.
    //
    
    // Count of things holding a pointer to this window.
    LONG lUsers;
    
    // All accesses to this window's data must occur under this lock.
    CRITICAL_SECTION sem;

    // Context that is currently holding this window's lock.
    struct __GLGENcontextRec *gengc;
    
    // Thread that is currently holding this window's lock and
    // recursion count on this window's lock.  This information may
    // be in the critical section but to be cross-platform we
    // maintain it ourselves.
    DWORD owningThread;
    DWORD lockRecursion;
} GLGENwindow;

/*
 * GLGENwindow::ulFlags
 *
 *  GLGENWIN_DIRECTSCREEN       Direct screen access locks are held
 *  GLGENWIN_OTHERPROCESS       The window handle is from another process
 *  GLGENWIN_DRIVERSET          pvDriver has been set
 */
#define GLGENWIN_DIRECTSCREEN   0x00000001
#define GLGENWIN_OTHERPROCESS   0x00000002
#define GLGENWIN_DRIVERSET      0x00000004

/*
 * Global header node for the linked list of GLGENwindow structures.
 * The semaphore in the header node is used as the list access semaphore.
 */
extern GLGENwindow gwndHeader;

/*
 * GLGENwindow list management functions.
 */

// Retrieves the GLGENwindow that corresponds to the specified HWND.
// NULL if failure.
// Increments lUsers
extern GLGENwindow * APIENTRY pwndGetFromHWND(HWND hwnd);

// Retrieves the GLGENwindow that corresponds to the specified HDC.
// NULL if failure.
// Increments lUsers
extern GLGENwindow * APIENTRY pwndGetFromMemDC(HDC hdc);

// Retrieves the GLGENwindow that corresponds to the specified DDraw surface.
// NULL if failure.
// Increments lUsers
GLGENwindow *pwndGetFromDdraw(LPDIRECTDRAWSURFACE pdds);

// General retrieval
// NULL if failure.
// Increments lUsers
extern GLGENwindow * APIENTRY pwndGetFromID(GLWINDOWID *pgwid);

// Allocates a new GLGENwindow structure and puts it into the linked list.
// NULL if failure.
// Starts lUsers at 1
extern GLGENwindow * APIENTRY pwndNew(GLGENwindow *pwndInit);

// Creates a GLGENwindow for the given information
extern GLGENwindow * APIENTRY CreatePwnd(GLWINDOWID *pgwid, int ipfd,
                                         int ipfdDevMax, DWORD dwObjectType,
                                         RECTL *prcl, BOOL *pbNew);

// Cleans up resources for a GLGENwindow
// NULL if success; pointer to GLGENwindow structure if failure.
extern GLGENwindow * APIENTRY pwndFree(GLGENwindow *pwnd,
                                       BOOL bExitProcess);

// Removes an active GLGENwindow from the window list and
// waits for a safe time to clean it up, then pwndFrees it
extern void APIENTRY pwndCleanup(GLGENwindow *pwnd);

// Decrements lUsers
#if DBG
extern void APIENTRY pwndRelease(GLGENwindow *pwnd);
#else
#define pwndRelease(pwnd) \
    InterlockedDecrement(&(pwnd)->lUsers)
#endif

// Unlocks pwnd->sem and does pwndRelease
extern void APIENTRY pwndUnlock(GLGENwindow *pwnd,
                                struct __GLGENcontextRec *gengc);

// Removes and deletes all GLGENwindow structures from the linked list.
// Must *ONLY* be called from process detach (GLUnInitializeProcess).
extern VOID APIENTRY vCleanupWnd(VOID);

// Retrieves layer information for the specified layer of the pwnd.
// Allocates if necessary.
extern GLGENlayerInfo * APIENTRY plyriGet(GLGENwindow *pwnd, HDC hdc, int iLayer);

void APIENTRY WindowIdFromHdc(HDC hdc, GLWINDOWID *pgwid);

//
// Begin/end direct screen access
//
extern BOOL BeginDirectScreenAccess(struct __GLGENcontextRec *gengc,
                                    GLGENwindow *pwnd,
                                    PIXELFORMATDESCRIPTOR *ppfd);
extern VOID EndDirectScreenAccess(GLGENwindow *pwnd);

//
// Debugging support for tracking lock/unlock on a window.
//

#if DBG || defined(TRACK_WINCRIT)
// Don't use ASSERTOPENGL so this can be used on free builds.
#define ASSERT_WINCRIT(pwnd) \
    if ((pwnd)->owningThread != GetCurrentThreadId()) \
    { \
        DbgPrint("Window 0x%08lX owned by 0x%X, not 0x%X\n", \
                 (pwnd), (pwnd)->owningThread, GetCurrentThreadId()); \
        DebugBreak(); \
    }
#define ASSERT_NOT_WINCRIT(pwnd) \
    if ((pwnd)->owningThread == GetCurrentThreadId()) \
    { \
        DbgPrint("Window 0x%08lX already owned by 0x%X\n", \
                 (pwnd), (pwnd)->owningThread); \
        DebugBreak(); \
    }
// Asserts that the current thread can recursively take the given
// wincrit.  For this to be true it must be unowned or owned by
// the same thread.
#define ASSERT_COMPATIBLE_WINCRIT(pwnd) \
    if ((pwnd)->owningThread != 0 && \
        (pwnd)->owningThread != GetCurrentThreadId()) \
    { \
        DbgPrint("Window 0x%08lX owned by 0x%X, not 0x%X\n", \
                 (pwnd), (pwnd)->owningThread, GetCurrentThreadId()); \
        DebugBreak(); \
    }
#else
#define ASSERT_WINCRIT(pwnd)
#define ASSERT_NOT_WINCRIT(pwnd)
#define ASSERT_COMPATIBLE_WINCRIT(pwnd)
#endif

// Use both GC and non-GC forms so it's possible to write macros
// for both cases if we want to in the future.

void ENTER_WINCRIT_GC(GLGENwindow *pwnd, struct __GLGENcontextRec *gengc);
void LEAVE_WINCRIT_GC(GLGENwindow *pwnd, struct __GLGENcontextRec *gengc);

#define ENTER_WINCRIT(pwnd) ENTER_WINCRIT_GC(pwnd, NULL)
#define LEAVE_WINCRIT(pwnd) LEAVE_WINCRIT_GC(pwnd, NULL)

#endif //_GLGENWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glmf.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE APIENTRY

#include <windef.h>
#include <wingdi.h>
#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef __int64 GLlong;
typedef unsigned __int64 GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (GLS_LINKAGE *GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (GLS_LINKAGE *GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (GLS_LINKAGE *GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (GLS_LINKAGE *GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (GLS_LINKAGE *GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorSubTableEXT                 65424
#define GLS_OP_glDrawRangeElementsWIN             65425
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableEXT                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvEXT      65481
#define GLS_OP_glGetColorTableParameterivEXT      65482
#define GLS_OP_glGetColorTableEXT                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

#define GLS_OP_glArrayElement                     370
#define GLS_OP_glBindTexture                      371
#define GLS_OP_glColorPointer                     372
#define GLS_OP_glDisableClientState               373
#define GLS_OP_glDrawArrays                       374
#define GLS_OP_glDrawElements                     375
#define GLS_OP_glEdgeFlagPointer                  376
#define GLS_OP_glEnableClientState                377
#define GLS_OP_glIndexPointer                     378
#define GLS_OP_glIndexub                          379
#define GLS_OP_glIndexubv                         380
#define GLS_OP_glInterleavedArrays                381
#define GLS_OP_glNormalPointer                    382
#define GLS_OP_glPolygonOffset                    383
#define GLS_OP_glTexCoordPointer                  384
#define GLS_OP_glVertexPointer                    385
#define GLS_OP_glAreTexturesResident              386
#define GLS_OP_glCopyTexImage1D                   387
#define GLS_OP_glCopyTexImage2D                   388
#define GLS_OP_glCopyTexSubImage1D                389
#define GLS_OP_glCopyTexSubImage2D                390
#define GLS_OP_glDeleteTextures                   391
#define GLS_OP_glGenTextures                      392
#define GLS_OP_glGetPointerv                      393
#define GLS_OP_glIsTexture                        394
#define GLS_OP_glPrioritizeTextures               395
#define GLS_OP_glTexSubImage1D                    396
#define GLS_OP_glTexSubImage2D                    397
#define GLS_OP_glPushClientAttrib                 398
#define GLS_OP_glPopClientAttrib                  399

/*************************************************************/

/* GLS global commands */
extern GLSenum GLS_LINKAGE glsBinary (GLboolean inSwapped);
extern GLSenum GLS_LINKAGE glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* GLS_LINKAGE glsCommandString (GLSopcode inOpcode);
extern void GLS_LINKAGE glsContext (GLuint inContext);
extern void GLS_LINKAGE glsDeleteContext (GLuint inContext);
extern const GLubyte* GLS_LINKAGE glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint GLS_LINKAGE glsGenContext (void);
extern GLuint* GLS_LINKAGE glsGetAllContexts (void);
extern GLScommandAlignment* GLS_LINKAGE glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield GLS_LINKAGE glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint GLS_LINKAGE glsGetConsti (GLSenum inAttrib);
extern const GLint* GLS_LINKAGE glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetConstubz (GLSenum inAttrib);
extern GLuint GLS_LINKAGE glsGetCurrentContext (void);
extern GLint* GLS_LINKAGE glsGetCurrentTime (GLint *outTime);
extern GLSenum GLS_LINKAGE glsGetError (GLboolean inClear);
extern GLint GLS_LINKAGE glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* GLS_LINKAGE glsGetOpcodes (GLSenum inAPI);
extern GLboolean GLS_LINKAGE glsIsContext (GLuint inContext);
extern GLboolean GLS_LINKAGE glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean GLS_LINKAGE glsIsUTF8String (const GLubyte *inString);
extern GLlong GLS_LINKAGE glsLong (GLint inHigh, GLuint inLow);
extern GLint GLS_LINKAGE glsLongHigh (GLlong inVal);
extern GLuint GLS_LINKAGE glsLongLow (GLlong inVal);
extern GLSfunc GLS_LINKAGE glsNullCommandFunc (GLSopcode inOpcode);
extern void GLS_LINKAGE glsPixelSetup (void);
extern GLulong GLS_LINKAGE glsULong (GLuint inHigh, GLuint inLow);
extern GLuint GLS_LINKAGE glsULongHigh (GLulong inVal);
extern GLuint GLS_LINKAGE glsULongLow (GLulong inVal);
extern GLint GLS_LINKAGE glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* GLS_LINKAGE glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint GLS_LINKAGE glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean GLS_LINKAGE glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean GLS_LINKAGE glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void GLS_LINKAGE glsAbortCall (GLSenum inMode);
extern GLboolean GLS_LINKAGE glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void GLS_LINKAGE glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void GLS_LINKAGE glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void GLS_LINKAGE glsChannel (GLSenum inTarget, FILE *inChannel);
extern void GLS_LINKAGE glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum GLS_LINKAGE glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsDataPointer (GLvoid *inPointer);
extern void GLS_LINKAGE glsDeleteReadPrefix (GLuint inIndex);
extern void GLS_LINKAGE glsDeleteStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndCapture (void);
extern void GLS_LINKAGE glsFlush (GLSenum inFlushType);
extern GLbitfield GLS_LINKAGE glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetContextFunc (GLSenum inAttrib);
extern GLlong GLS_LINKAGE glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* GLS_LINKAGE glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* GLS_LINKAGE glsGetContextPointer (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetContexti (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetContextubz (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* GLS_LINKAGE glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint GLS_LINKAGE glsGetHeaderi (GLSenum inAttrib);
extern GLint* GLS_LINKAGE glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* GLS_LINKAGE glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield GLS_LINKAGE glsGetStreamAttrib (const GLubyte *inName);
extern GLuint GLS_LINKAGE glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* GLS_LINKAGE glsGetStreamReadName (const GLubyte *inName);
extern size_t GLS_LINKAGE glsGetStreamSize (const GLubyte *inName);
extern GLSenum GLS_LINKAGE glsGetStreamType (const GLubyte *inName);
extern GLboolean GLS_LINKAGE glsIsContextStream (const GLubyte *inName);
extern void GLS_LINKAGE glsPixelSetupGen (GLboolean inEnabled);
extern void GLS_LINKAGE glsReadFunc (GLSreadFunc inFunc);
extern void GLS_LINKAGE glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void GLS_LINKAGE glsUnreadFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWriteFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void GLS_LINKAGE glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void GLS_LINKAGE glsBlock (GLSenum inBlockType);
extern GLSenum GLS_LINKAGE glsCallStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndGLS (void);
extern void GLS_LINKAGE glsError (GLSopcode inOpcode, GLSenum inError);
extern void GLS_LINKAGE glsGLRC (GLuint inGLRC);
extern void GLS_LINKAGE glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void GLS_LINKAGE glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void GLS_LINKAGE glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void GLS_LINKAGE glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void GLS_LINKAGE glsRequireExtension (const GLubyte *inExtension);
extern void GLS_LINKAGE glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void GLS_LINKAGE glsAppRef (GLulong inAddress, GLuint inCount);
extern void GLS_LINKAGE glsBeginObj (const GLubyte *inTag);
extern void GLS_LINKAGE glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void GLS_LINKAGE glsComment (const GLubyte *inComment);
extern void GLS_LINKAGE glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsEndObj (void);
extern void GLS_LINKAGE glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void GLS_LINKAGE glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void GLS_LINKAGE glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void GLS_LINKAGE glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void GLS_LINKAGE glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void GLS_LINKAGE glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsNumi (const GLubyte *inTag, GLint inVal);
extern void GLS_LINKAGE glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void GLS_LINKAGE glsNuml (const GLubyte *inTag, GLlong inVal);
extern void GLS_LINKAGE glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void GLS_LINKAGE glsNums (const GLubyte *inTag, GLshort inVal);
extern void GLS_LINKAGE glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void GLS_LINKAGE glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void GLS_LINKAGE glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void GLS_LINKAGE glsNumui (const GLubyte *inTag, GLuint inVal);
extern void GLS_LINKAGE glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void GLS_LINKAGE glsNumul (const GLubyte *inTag, GLulong inVal);
extern void GLS_LINKAGE glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void GLS_LINKAGE glsNumus (const GLubyte *inTag, GLushort inVal);
extern void GLS_LINKAGE glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void GLS_LINKAGE glsPad (void);
extern void GLS_LINKAGE glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glgdimsg.h ===
/*
 *  Copyright 1991, 1992, Silicon Graphics, Inc.
 *  All Rights Reserved.
 *
 *  This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
 *  the contents of this file may not be disclosed to third parties, copied or
 *  duplicated in any form, in whole or in part, without the prior written
 *  permission of Silicon Graphics, Inc.
 *
 *  RESTRICTED RIGHTS LEGEND:
 *  Use, duplication or disclosure by the Government is subject to restrictions
 *  as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
 *  and Computer Software clause at DFARS 252.227-7013, and/or in similar or
 *  successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
 *  rights reserved under the Copyright Laws of the United States.
 */

#ifndef __GLGDIMSG_H__
#define __GLGDIMSG_H__

// These are new GDI messages used by the sub batching code.

#ifdef DOGLMSGBATCHSTATS

typedef struct _MSG_GLMSGBATCHSTATS
{
    CSR_QLPC_API_MSG msg;
    LONG Action;
    GLMSGBATCHSTATS BatchStats;

} MSG_GLMSGBATCHSTATS, *PMSG_GLMSGBATCHSTATS;

#endif /* DOGLMSGBATCHSTATS */

#endif /* __GLGDIMSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glapi.h ===
/******************************Module*Header*******************************\
* Module Name: glapi.h
*
* OpenGL API function table indices and cached fast dispatch table
*
* Created: 12/27/1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef __GLAPI_H__
#define __GLAPI_H__

// Opengl dispatch table indices
#include "dispindx.h"

// OpenGL fast function dispatch table in the TEB's glDispatchTable field.
// These cached functions have less overhead because we can avoid
// dereferencing the dispatch table pointer stored in the TEB (save one
// level of indirection).
//
// NOTE: If you modify the table, you also need to modify the above fast
// indices.

typedef struct _GLDISPATCHTABLE_FAST {
    void      (APIENTRY *glCallList               )( GLuint list );
    void      (APIENTRY *glCallLists              )( GLsizei n, GLenum type, const GLvoid *lists );
    void      (APIENTRY *glBegin                  )( GLenum mode );
    void      (APIENTRY *glColor3b                )( GLbyte red, GLbyte green, GLbyte blue );
    void      (APIENTRY *glColor3bv               )( const GLbyte *v );
    void      (APIENTRY *glColor3d                )( GLdouble red, GLdouble green, GLdouble blue );
    void      (APIENTRY *glColor3dv               )( const GLdouble *v );
    void      (APIENTRY *glColor3f                )( GLfloat red, GLfloat green, GLfloat blue );
    void      (APIENTRY *glColor3fv               )( const GLfloat *v );
    void      (APIENTRY *glColor3i                )( GLint red, GLint green, GLint blue );
    void      (APIENTRY *glColor3iv               )( const GLint *v );
    void      (APIENTRY *glColor3s                )( GLshort red, GLshort green, GLshort blue );
    void      (APIENTRY *glColor3sv               )( const GLshort *v );
    void      (APIENTRY *glColor3ub               )( GLubyte red, GLubyte green, GLubyte blue );
    void      (APIENTRY *glColor3ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor3ui               )( GLuint red, GLuint green, GLuint blue );
    void      (APIENTRY *glColor3uiv              )( const GLuint *v );
    void      (APIENTRY *glColor3us               )( GLushort red, GLushort green, GLushort blue );
    void      (APIENTRY *glColor3usv              )( const GLushort *v );
    void      (APIENTRY *glColor4b                )( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha );
    void      (APIENTRY *glColor4bv               )( const GLbyte *v );
    void      (APIENTRY *glColor4d                )( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha );
    void      (APIENTRY *glColor4dv               )( const GLdouble *v );
    void      (APIENTRY *glColor4f                )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glColor4fv               )( const GLfloat *v );
    void      (APIENTRY *glColor4i                )( GLint red, GLint green, GLint blue, GLint alpha );
    void      (APIENTRY *glColor4iv               )( const GLint *v );
    void      (APIENTRY *glColor4s                )( GLshort red, GLshort green, GLshort blue, GLshort alpha );
    void      (APIENTRY *glColor4sv               )( const GLshort *v );
    void      (APIENTRY *glColor4ub               )( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha );
    void      (APIENTRY *glColor4ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor4ui               )( GLuint red, GLuint green, GLuint blue, GLuint alpha );
    void      (APIENTRY *glColor4uiv              )( const GLuint *v );
    void      (APIENTRY *glColor4us               )( GLushort red, GLushort green, GLushort blue, GLushort alpha );
    void      (APIENTRY *glColor4usv              )( const GLushort *v );
    void      (APIENTRY *glEdgeFlag               )( GLboolean flag );
    void      (APIENTRY *glEdgeFlagv              )( const GLboolean *flag );
    void      (APIENTRY *glEnd                    )( void );
    void      (APIENTRY *glIndexd                 )( GLdouble c );
    void      (APIENTRY *glIndexdv                )( const GLdouble *c );
    void      (APIENTRY *glIndexf                 )( GLfloat c );
    void      (APIENTRY *glIndexfv                )( const GLfloat *c );
    void      (APIENTRY *glIndexi                 )( GLint c );
    void      (APIENTRY *glIndexiv                )( const GLint *c );
    void      (APIENTRY *glIndexs                 )( GLshort c );
    void      (APIENTRY *glIndexsv                )( const GLshort *c );
    void      (APIENTRY *glNormal3b               )( GLbyte nx, GLbyte ny, GLbyte nz );
    void      (APIENTRY *glNormal3bv              )( const GLbyte *v );
    void      (APIENTRY *glNormal3d               )( GLdouble nx, GLdouble ny, GLdouble nz );
    void      (APIENTRY *glNormal3dv              )( const GLdouble *v );
    void      (APIENTRY *glNormal3f               )( GLfloat nx, GLfloat ny, GLfloat nz );
    void      (APIENTRY *glNormal3fv              )( const GLfloat *v );
    void      (APIENTRY *glNormal3i               )( GLint nx, GLint ny, GLint nz );
    void      (APIENTRY *glNormal3iv              )( const GLint *v );
    void      (APIENTRY *glNormal3s               )( GLshort nx, GLshort ny, GLshort nz );
    void      (APIENTRY *glNormal3sv              )( const GLshort *v );
    void      (APIENTRY *glTexCoord1d             )( GLdouble s );
    void      (APIENTRY *glTexCoord1dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord1f             )( GLfloat s );
    void      (APIENTRY *glTexCoord1fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord1i             )( GLint s );
    void      (APIENTRY *glTexCoord1iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord1s             )( GLshort s );
    void      (APIENTRY *glTexCoord1sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord2d             )( GLdouble s, GLdouble t );
    void      (APIENTRY *glTexCoord2dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord2f             )( GLfloat s, GLfloat t );
    void      (APIENTRY *glTexCoord2fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord2i             )( GLint s, GLint t );
    void      (APIENTRY *glTexCoord2iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord2s             )( GLshort s, GLshort t );
    void      (APIENTRY *glTexCoord2sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord3d             )( GLdouble s, GLdouble t, GLdouble r );
    void      (APIENTRY *glTexCoord3dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord3f             )( GLfloat s, GLfloat t, GLfloat r );
    void      (APIENTRY *glTexCoord3fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord3i             )( GLint s, GLint t, GLint r );
    void      (APIENTRY *glTexCoord3iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord3s             )( GLshort s, GLshort t, GLshort r );
    void      (APIENTRY *glTexCoord3sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord4d             )( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
    void      (APIENTRY *glTexCoord4dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord4f             )( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
    void      (APIENTRY *glTexCoord4fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord4i             )( GLint s, GLint t, GLint r, GLint q );
    void      (APIENTRY *glTexCoord4iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord4s             )( GLshort s, GLshort t, GLshort r, GLshort q );
    void      (APIENTRY *glTexCoord4sv            )( const GLshort *v );
    void      (APIENTRY *glVertex2d               )( GLdouble x, GLdouble y );
    void      (APIENTRY *glVertex2dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex2f               )( GLfloat x, GLfloat y );
    void      (APIENTRY *glVertex2fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex2i               )( GLint x, GLint y );
    void      (APIENTRY *glVertex2iv              )( const GLint *v );
    void      (APIENTRY *glVertex2s               )( GLshort x, GLshort y );
    void      (APIENTRY *glVertex2sv              )( const GLshort *v );
    void      (APIENTRY *glVertex3d               )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glVertex3dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex3f               )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glVertex3fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex3i               )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glVertex3iv              )( const GLint *v );
    void      (APIENTRY *glVertex3s               )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glVertex3sv              )( const GLshort *v );
    void      (APIENTRY *glVertex4d               )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glVertex4dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex4f               )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glVertex4fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex4i               )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glVertex4iv              )( const GLint *v );
    void      (APIENTRY *glVertex4s               )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glVertex4sv              )( const GLshort *v );
    void      (APIENTRY *glMaterialf              )( GLenum face, GLenum pname, GLfloat param );
    void      (APIENTRY *glMaterialfv             )( GLenum face, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glMateriali              )( GLenum face, GLenum pname, GLint param );
    void      (APIENTRY *glMaterialiv             )( GLenum face, GLenum pname, const GLint *params );
    void      (APIENTRY *glDisable                )( GLenum cap );
    void      (APIENTRY *glEnable                 )( GLenum cap );
    void      (APIENTRY *glPopAttrib              )( void );
    void      (APIENTRY *glPushAttrib             )( GLbitfield mask );
    void      (APIENTRY *glEvalCoord1d            )( GLdouble u );
    void      (APIENTRY *glEvalCoord1dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord1f            )( GLfloat u );
    void      (APIENTRY *glEvalCoord1fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalCoord2d            )( GLdouble u, GLdouble v );
    void      (APIENTRY *glEvalCoord2dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord2f            )( GLfloat u, GLfloat v );
    void      (APIENTRY *glEvalCoord2fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalPoint1             )( GLint i );
    void      (APIENTRY *glEvalPoint2             )( GLint i, GLint j );
    void      (APIENTRY *glLoadIdentity           )( void );
    void      (APIENTRY *glLoadMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glLoadMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glMatrixMode             )( GLenum mode );
    void      (APIENTRY *glMultMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glMultMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glPopMatrix              )( void );
    void      (APIENTRY *glPushMatrix             )( void );
    void      (APIENTRY *glRotated                )( GLdouble angle, GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRotatef                )( GLfloat angle, GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glScaled                 )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glScalef                 )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glTranslated             )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glTranslatef             )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glArrayElement           )(GLint i);
    void      (APIENTRY *glBindTexture            )(GLenum target, GLuint texture);
    void      (APIENTRY *glColorPointer           )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glDisableClientState     )(GLenum array);
    void      (APIENTRY *glDrawArrays             )(GLenum mode, GLint first, GLsizei count);
    void      (APIENTRY *glDrawElements           )(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
    void      (APIENTRY *glEdgeFlagPointer        )(GLsizei stride, const GLvoid* *pointer);
    void      (APIENTRY *glEnableClientState      )(GLenum array);
    void      (APIENTRY *glIndexPointer           )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glIndexub                )(GLubyte c);
    void      (APIENTRY *glIndexubv               )(const GLubyte *c);
    void      (APIENTRY *glInterleavedArrays      )(GLenum format, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glNormalPointer          )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glPolygonOffset          )(GLfloat factor, GLfloat units);
    void      (APIENTRY *glTexCoordPointer        )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glVertexPointer          )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glGetPointerv            )(GLenum pname, GLvoid* *params);
    void      (APIENTRY *glPopClientAttrib        )(void);
    void      (APIENTRY *glPushClientAttrib       )(GLbitfield mask);
    void (APIENTRY *glDrawRangeElementsWIN)
        (GLenum mode, GLuint start, GLuint end, GLsizei count,
         GLenum type, const GLvoid *indices);
    void (APIENTRY *glColorTableEXT)
        (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
         GLenum type, const GLvoid *data);
    void (APIENTRY *glColorSubTableEXT)
        (GLenum target, GLsizei start, GLsizei count, GLenum format,
         GLenum type, const GLvoid *data);
#ifdef GL_WIN_multiple_textures
    void (APIENTRY *glCurrentTextureIndexWIN)
        (GLuint index);
    void (APIENTRY *glBindNthTextureWIN)
        (GLenum index, GLenum target, GLuint texture);
    void (APIENTRY *glNthTexCombineFuncWIN)
        (GLenum index,
         GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
         GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
    void (APIENTRY *glMultiTexCoord1fWIN)
        (GLbitfield mask, GLfloat s);
    void (APIENTRY *glMultiTexCoord1fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord1iWIN)
        (GLbitfield mask, GLint s);
    void (APIENTRY *glMultiTexCoord1ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord2fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t);
    void (APIENTRY *glMultiTexCoord2fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord2iWIN)
        (GLbitfield mask, GLint s, GLint t);
    void (APIENTRY *glMultiTexCoord2ivWIN)
        (GLbitfield mask, const GLint *v);
#endif // GL_WIN_multiple_textures
} GLDISPATCHTABLE_FAST, *PGLDISPATCHTABLE_FAST;

#endif /* !__GLAPI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glclt.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#ifndef __GLCLT_H__
#define __GLCLT_H__

/* Client Side Prototypes */

/* gl Entry points */

void      APIENTRY glcltNewList                ( IN GLuint list, IN GLenum mode );
void      APIENTRY glcltEndList                ( void );
void      APIENTRY glcltCallList               ( IN GLuint list );
void      APIENTRY glcltCallLists              ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists );
void      APIENTRY glcltDeleteLists            ( IN GLuint list, IN GLsizei range );
GLuint    APIENTRY glcltGenLists               ( IN GLsizei range );
void      APIENTRY glcltListBase               ( IN GLuint base );
void      APIENTRY glcltBegin                  ( IN GLenum mode );
void      APIENTRY glcltBitmap                 ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] );
void      APIENTRY glcltColor3b_InRGBA         ( IN GLbyte red, IN GLbyte green, IN GLbyte blue );
void      APIENTRY glcltColor3bv_InRGBA        ( IN const GLbyte v[3] );
void      APIENTRY glcltColor3d_InRGBA         ( IN GLdouble red, IN GLdouble green, IN GLdouble blue );
void      APIENTRY glcltColor3dv_InRGBA        ( IN const GLdouble v[3] );
void      APIENTRY glcltColor3f_InRGBA         ( IN GLfloat red, IN GLfloat green, IN GLfloat blue );
void      APIENTRY glcltColor3fv_InRGBA        ( IN const GLfloat v[3] );
void      APIENTRY glcltColor3i_InRGBA         ( IN GLint red, IN GLint green, IN GLint blue );
void      APIENTRY glcltColor3iv_InRGBA        ( IN const GLint v[3] );
void      APIENTRY glcltColor3s_InRGBA         ( IN GLshort red, IN GLshort green, IN GLshort blue );
void      APIENTRY glcltColor3sv_InRGBA        ( IN const GLshort v[3] );
void      APIENTRY glcltColor3ub_InRGBA        ( IN GLubyte red, IN GLubyte green, IN GLubyte blue );
void      APIENTRY glcltColor3ubv_InRGBA       ( IN const GLubyte v[3] );
void      APIENTRY glcltColor3ui_InRGBA        ( IN GLuint red, IN GLuint green, IN GLuint blue );
void      APIENTRY glcltColor3uiv_InRGBA       ( IN const GLuint v[3] );
void      APIENTRY glcltColor3us_InRGBA        ( IN GLushort red, IN GLushort green, IN GLushort blue );
void      APIENTRY glcltColor3usv_InRGBA       ( IN const GLushort v[3] );
void      APIENTRY glcltColor4b_InRGBA         ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha );
void      APIENTRY glcltColor4bv_InRGBA        ( IN const GLbyte v[4] );
void      APIENTRY glcltColor4d_InRGBA         ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha );
void      APIENTRY glcltColor4dv_InRGBA        ( IN const GLdouble v[4] );
void      APIENTRY glcltColor4f_InRGBA         ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY glcltColor4fv_InRGBA        ( IN const GLfloat v[4] );
void      APIENTRY glcltColor4i_InRGBA         ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha );
void      APIENTRY glcltColor4iv_InRGBA        ( IN const GLint v[4] );
void      APIENTRY glcltColor4s_InRGBA         ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha );
void      APIENTRY glcltColor4sv_InRGBA        ( IN const GLshort v[4] );
void      APIENTRY glcltColor4ub_InRGBA        ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha );
void      APIENTRY glcltColor4ubv_InRGBA       ( IN const GLubyte v[4] );
void      APIENTRY glcltColor4ui_InRGBA        ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha );
void      APIENTRY glcltColor4uiv_InRGBA       ( IN const GLuint v[4] );
void      APIENTRY glcltColor4us_InRGBA        ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha );
void      APIENTRY glcltColor4usv_InRGBA       ( IN const GLushort v[4] );
void      APIENTRY glcltColor3b_InCI           ( IN GLbyte red, IN GLbyte green, IN GLbyte blue );
void      APIENTRY glcltColor3bv_InCI          ( IN const GLbyte v[3] );
void      APIENTRY glcltColor3d_InCI           ( IN GLdouble red, IN GLdouble green, IN GLdouble blue );
void      APIENTRY glcltColor3dv_InCI          ( IN const GLdouble v[3] );
void      APIENTRY glcltColor3f_InCI           ( IN GLfloat red, IN GLfloat green, IN GLfloat blue );
void      APIENTRY glcltColor3fv_InCI          ( IN const GLfloat v[3] );
void      APIENTRY glcltColor3i_InCI           ( IN GLint red, IN GLint green, IN GLint blue );
void      APIENTRY glcltColor3iv_InCI          ( IN const GLint v[3] );
void      APIENTRY glcltColor3s_InCI           ( IN GLshort red, IN GLshort green, IN GLshort blue );
void      APIENTRY glcltColor3sv_InCI          ( IN const GLshort v[3] );
void      APIENTRY glcltColor3ub_InCI          ( IN GLubyte red, IN GLubyte green, IN GLubyte blue );
void      APIENTRY glcltColor3ubv_InCI         ( IN const GLubyte v[3] );
void      APIENTRY glcltColor3ui_InCI          ( IN GLuint red, IN GLuint green, IN GLuint blue );
void      APIENTRY glcltColor3uiv_InCI         ( IN const GLuint v[3] );
void      APIENTRY glcltColor3us_InCI          ( IN GLushort red, IN GLushort green, IN GLushort blue );
void      APIENTRY glcltColor3usv_InCI         ( IN const GLushort v[3] );
void      APIENTRY glcltColor4b_InCI           ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha );
void      APIENTRY glcltColor4bv_InCI          ( IN const GLbyte v[4] );
void      APIENTRY glcltColor4d_InCI           ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha );
void      APIENTRY glcltColor4dv_InCI          ( IN const GLdouble v[4] );
void      APIENTRY glcltColor4f_InCI           ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY glcltColor4fv_InCI          ( IN const GLfloat v[4] );
void      APIENTRY glcltColor4i_InCI           ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha );
void      APIENTRY glcltColor4iv_InCI          ( IN const GLint v[4] );
void      APIENTRY glcltColor4s_InCI           ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha );
void      APIENTRY glcltColor4sv_InCI          ( IN const GLshort v[4] );
void      APIENTRY glcltColor4ub_InCI          ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha );
void      APIENTRY glcltColor4ubv_InCI         ( IN const GLubyte v[4] );
void      APIENTRY glcltColor4ui_InCI          ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha );
void      APIENTRY glcltColor4uiv_InCI         ( IN const GLuint v[4] );
void      APIENTRY glcltColor4us_InCI          ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha );
void      APIENTRY glcltColor4usv_InCI         ( IN const GLushort v[4] );
void      APIENTRY glcltEdgeFlag               ( IN GLboolean flag );
void      APIENTRY glcltEdgeFlagv              ( IN const GLboolean flag[1] );
void      APIENTRY glcltEnd                    ( void );
void      APIENTRY glcltIndexd_InCI            ( IN GLdouble c );
void      APIENTRY glcltIndexdv_InCI           ( IN const GLdouble c[1] );
void      APIENTRY glcltIndexf_InCI            ( IN GLfloat c );
void      APIENTRY glcltIndexfv_InCI           ( IN const GLfloat c[1] );
void      APIENTRY glcltIndexi_InCI            ( IN GLint c );
void      APIENTRY glcltIndexiv_InCI           ( IN const GLint c[1] );
void      APIENTRY glcltIndexs_InCI            ( IN GLshort c );
void      APIENTRY glcltIndexsv_InCI           ( IN const GLshort c[1] );
void      APIENTRY glcltIndexd_InRGBA          ( IN GLdouble c );
void      APIENTRY glcltIndexdv_InRGBA         ( IN const GLdouble c[1] );
void      APIENTRY glcltIndexf_InRGBA          ( IN GLfloat c );
void      APIENTRY glcltIndexfv_InRGBA         ( IN const GLfloat c[1] );
void      APIENTRY glcltIndexi_InRGBA          ( IN GLint c );
void      APIENTRY glcltIndexiv_InRGBA         ( IN const GLint c[1] );
void      APIENTRY glcltIndexs_InRGBA          ( IN GLshort c );
void      APIENTRY glcltIndexsv_InRGBA         ( IN const GLshort c[1] );
void      APIENTRY glcltNormal3b               ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz );
void      APIENTRY glcltNormal3bv              ( IN const GLbyte v[3] );
void      APIENTRY glcltNormal3d               ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz );
void      APIENTRY glcltNormal3dv              ( IN const GLdouble v[3] );
void      APIENTRY glcltNormal3f               ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz );
void      APIENTRY glcltNormal3fv              ( IN const GLfloat v[3] );
void      APIENTRY glcltNormal3i               ( IN GLint nx, IN GLint ny, IN GLint nz );
void      APIENTRY glcltNormal3iv              ( IN const GLint v[3] );
void      APIENTRY glcltNormal3s               ( IN GLshort nx, IN GLshort ny, IN GLshort nz );
void      APIENTRY glcltNormal3sv              ( IN const GLshort v[3] );
void      APIENTRY glcltRasterPos2d            ( IN GLdouble x, IN GLdouble y );
void      APIENTRY glcltRasterPos2dv           ( IN const GLdouble v[2] );
void      APIENTRY glcltRasterPos2f            ( IN GLfloat x, IN GLfloat y );
void      APIENTRY glcltRasterPos2fv           ( IN const GLfloat v[2] );
void      APIENTRY glcltRasterPos2i            ( IN GLint x, IN GLint y );
void      APIENTRY glcltRasterPos2iv           ( IN const GLint v[2] );
void      APIENTRY glcltRasterPos2s            ( IN GLshort x, IN GLshort y );
void      APIENTRY glcltRasterPos2sv           ( IN const GLshort v[2] );
void      APIENTRY glcltRasterPos3d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltRasterPos3dv           ( IN const GLdouble v[3] );
void      APIENTRY glcltRasterPos3f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltRasterPos3fv           ( IN const GLfloat v[3] );
void      APIENTRY glcltRasterPos3i            ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY glcltRasterPos3iv           ( IN const GLint v[3] );
void      APIENTRY glcltRasterPos3s            ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY glcltRasterPos3sv           ( IN const GLshort v[3] );
void      APIENTRY glcltRasterPos4d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY glcltRasterPos4dv           ( IN const GLdouble v[4] );
void      APIENTRY glcltRasterPos4f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY glcltRasterPos4fv           ( IN const GLfloat v[4] );
void      APIENTRY glcltRasterPos4i            ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY glcltRasterPos4iv           ( IN const GLint v[4] );
void      APIENTRY glcltRasterPos4s            ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY glcltRasterPos4sv           ( IN const GLshort v[4] );
void      APIENTRY glcltRectd                  ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 );
void      APIENTRY glcltRectdv                 ( IN const GLdouble v1[2], IN const GLdouble v2[2] );
void      APIENTRY glcltRectf                  ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 );
void      APIENTRY glcltRectfv                 ( IN const GLfloat v1[2], IN const GLfloat v2[2] );
void      APIENTRY glcltRecti                  ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 );
void      APIENTRY glcltRectiv                 ( IN const GLint v1[2], IN const GLint v2[2] );
void      APIENTRY glcltRects                  ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 );
void      APIENTRY glcltRectsv                 ( IN const GLshort v1[2], IN const GLshort v2[2] );
void      APIENTRY glcltTexCoord1d             ( IN GLdouble s );
void      APIENTRY glcltTexCoord1dv            ( IN const GLdouble v[1] );
void      APIENTRY glcltTexCoord1f             ( IN GLfloat s );
void      APIENTRY glcltTexCoord1fv            ( IN const GLfloat v[1] );
void      APIENTRY glcltTexCoord1i             ( IN GLint s );
void      APIENTRY glcltTexCoord1iv            ( IN const GLint v[1] );
void      APIENTRY glcltTexCoord1s             ( IN GLshort s );
void      APIENTRY glcltTexCoord1sv            ( IN const GLshort v[1] );
void      APIENTRY glcltTexCoord2d             ( IN GLdouble s, IN GLdouble t );
void      APIENTRY glcltTexCoord2dv            ( IN const GLdouble v[2] );
void      APIENTRY glcltTexCoord2f             ( IN GLfloat s, IN GLfloat t );
void      APIENTRY glcltTexCoord2fv            ( IN const GLfloat v[2] );
void      APIENTRY glcltTexCoord2i             ( IN GLint s, IN GLint t );
void      APIENTRY glcltTexCoord2iv            ( IN const GLint v[2] );
void      APIENTRY glcltTexCoord2s             ( IN GLshort s, IN GLshort t );
void      APIENTRY glcltTexCoord2sv            ( IN const GLshort v[2] );
void      APIENTRY glcltTexCoord3d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r );
void      APIENTRY glcltTexCoord3dv            ( IN const GLdouble v[3] );
void      APIENTRY glcltTexCoord3f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r );
void      APIENTRY glcltTexCoord3fv            ( IN const GLfloat v[3] );
void      APIENTRY glcltTexCoord3i             ( IN GLint s, IN GLint t, IN GLint r );
void      APIENTRY glcltTexCoord3iv            ( IN const GLint v[3] );
void      APIENTRY glcltTexCoord3s             ( IN GLshort s, IN GLshort t, IN GLshort r );
void      APIENTRY glcltTexCoord3sv            ( IN const GLshort v[3] );
void      APIENTRY glcltTexCoord4d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q );
void      APIENTRY glcltTexCoord4dv            ( IN const GLdouble v[4] );
void      APIENTRY glcltTexCoord4f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q );
void      APIENTRY glcltTexCoord4fv            ( IN const GLfloat v[4] );
void      APIENTRY glcltTexCoord4i             ( IN GLint s, IN GLint t, IN GLint r, IN GLint q );
void      APIENTRY glcltTexCoord4iv            ( IN const GLint v[4] );
void      APIENTRY glcltTexCoord4s             ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q );
void      APIENTRY glcltTexCoord4sv            ( IN const GLshort v[4] );
void      APIENTRY glcltVertex2d               ( IN GLdouble x, IN GLdouble y );
void      APIENTRY glcltVertex2dv              ( IN const GLdouble v[2] );
void      APIENTRY glcltVertex2f               ( IN GLfloat x, IN GLfloat y );
void      APIENTRY glcltVertex2fv              ( IN const GLfloat v[2] );
void      APIENTRY glcltVertex2i               ( IN GLint x, IN GLint y );
void      APIENTRY glcltVertex2iv              ( IN const GLint v[2] );
void      APIENTRY glcltVertex2s               ( IN GLshort x, IN GLshort y );
void      APIENTRY glcltVertex2sv              ( IN const GLshort v[2] );
void      APIENTRY glcltVertex3d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltVertex3dv              ( IN const GLdouble v[3] );
void      APIENTRY glcltVertex3f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltVertex3fv              ( IN const GLfloat v[3] );
void      APIENTRY glcltVertex3i               ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY glcltVertex3iv              ( IN const GLint v[3] );
void      APIENTRY glcltVertex3s               ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY glcltVertex3sv              ( IN const GLshort v[3] );
void      APIENTRY glcltVertex4d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY glcltVertex4dv              ( IN const GLdouble v[4] );
void      APIENTRY glcltVertex4f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY glcltVertex4fv              ( IN const GLfloat v[4] );
void      APIENTRY glcltVertex4i               ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY glcltVertex4iv              ( IN const GLint v[4] );
void      APIENTRY glcltVertex4s               ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY glcltVertex4sv              ( IN const GLshort v[4] );
void      APIENTRY glcltClipPlane              ( IN GLenum plane, IN const GLdouble equation[4] );
void      APIENTRY glcltColorMaterial          ( IN GLenum face, IN GLenum mode );
void      APIENTRY glcltCullFace               ( IN GLenum mode );
void      APIENTRY glcltFogf                   ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltFogfv                  ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltFogi                   ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltFogiv                  ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltFrontFace              ( IN GLenum mode );
void      APIENTRY glcltHint                   ( IN GLenum target, IN GLenum mode );
void      APIENTRY glcltLightf                 ( IN GLenum light, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltLightfv                ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltLighti                 ( IN GLenum light, IN GLenum pname, IN GLint param );
void      APIENTRY glcltLightiv                ( IN GLenum light, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltLightModelf            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltLightModelfv           ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltLightModeli            ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltLightModeliv           ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltLineStipple            ( IN GLint factor, IN GLushort pattern );
void      APIENTRY glcltLineWidth              ( IN GLfloat width );
void      APIENTRY glcltMaterialf              ( IN GLenum face, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltMaterialfv             ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltMateriali              ( IN GLenum face, IN GLenum pname, IN GLint param );
void      APIENTRY glcltMaterialiv             ( IN GLenum face, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltPointSize              ( IN GLfloat size );
void      APIENTRY glcltPolygonMode            ( IN GLenum face, IN GLenum mode );
void      APIENTRY glcltPolygonStipple         ( IN const GLubyte mask[] );
void      APIENTRY glcltScissor                ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY glcltShadeModel             ( IN GLenum mode );
void      APIENTRY glcltTexParameterf          ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltTexParameterfv         ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltTexParameteri          ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY glcltTexParameteriv         ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltTexImage1D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY glcltTexImage2D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY glcltTexEnvf                ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltTexEnvfv               ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltTexEnvi                ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY glcltTexEnviv               ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltTexGend                ( IN GLenum coord, IN GLenum pname, IN GLdouble param );
void      APIENTRY glcltTexGendv               ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] );
void      APIENTRY glcltTexGenf                ( IN GLenum coord, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltTexGenfv               ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltTexGeni                ( IN GLenum coord, IN GLenum pname, IN GLint param );
void      APIENTRY glcltTexGeniv               ( IN GLenum coord, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltFeedbackBuffer         ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] );
void      APIENTRY glcltSelectBuffer           ( IN GLsizei size, OUT GLuint buffer[] );
GLint     APIENTRY glcltRenderMode             ( IN GLenum mode );
void      APIENTRY glcltInitNames              ( void );
void      APIENTRY glcltLoadName               ( IN GLuint name );
void      APIENTRY glcltPassThrough            ( IN GLfloat token );
void      APIENTRY glcltPopName                ( void );
void      APIENTRY glcltPushName               ( IN GLuint name );
void      APIENTRY glcltDrawBuffer             ( IN GLenum mode );
void      APIENTRY glcltClear                  ( IN GLbitfield mask );
void      APIENTRY glcltClearAccum             ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY glcltClearIndex             ( IN GLfloat c );
void      APIENTRY glcltClearColor             ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha );
void      APIENTRY glcltClearStencil           ( IN GLint s );
void      APIENTRY glcltClearDepth             ( IN GLclampd depth );
void      APIENTRY glcltStencilMask            ( IN GLuint mask );
void      APIENTRY glcltColorMask              ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha );
void      APIENTRY glcltDepthMask              ( IN GLboolean flag );
void      APIENTRY glcltIndexMask              ( IN GLuint mask );
void      APIENTRY glcltAccum                  ( IN GLenum op, IN GLfloat value );
void      APIENTRY glcltDisable                ( IN GLenum cap );
void      APIENTRY glcltEnable                 ( IN GLenum cap );
void      APIENTRY glcltFinish                 ( void );
void      APIENTRY glcltFlush                  ( void );
void      APIENTRY glcltPopAttrib              ( void );
void      APIENTRY glcltPushAttrib             ( IN GLbitfield mask );
void      APIENTRY glcltMap1d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] );
void      APIENTRY glcltMap1f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] );
void      APIENTRY glcltMap2d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] );
void      APIENTRY glcltMap2f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] );
void      APIENTRY glcltMapGrid1d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2 );
void      APIENTRY glcltMapGrid1f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2 );
void      APIENTRY glcltMapGrid2d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 );
void      APIENTRY glcltMapGrid2f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 );
void      APIENTRY glcltEvalCoord1d            ( IN GLdouble u );
void      APIENTRY glcltEvalCoord1dv           ( IN const GLdouble u[1] );
void      APIENTRY glcltEvalCoord1f            ( IN GLfloat u );
void      APIENTRY glcltEvalCoord1fv           ( IN const GLfloat u[1] );
void      APIENTRY glcltEvalCoord2d            ( IN GLdouble u, IN GLdouble v );
void      APIENTRY glcltEvalCoord2dv           ( IN const GLdouble u[2] );
void      APIENTRY glcltEvalCoord2f            ( IN GLfloat u, IN GLfloat v );
void      APIENTRY glcltEvalCoord2fv           ( IN const GLfloat u[2] );
void      APIENTRY glcltEvalMesh1              ( IN GLenum mode, IN GLint i1, IN GLint i2 );
void      APIENTRY glcltEvalPoint1             ( IN GLint i );
void      APIENTRY glcltEvalMesh2              ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 );
void      APIENTRY glcltEvalPoint2             ( IN GLint i, IN GLint j );
void      APIENTRY glcltAlphaFunc              ( IN GLenum func, IN GLclampf ref );
void      APIENTRY glcltBlendFunc              ( IN GLenum sfactor, IN GLenum dfactor );
void      APIENTRY glcltLogicOp                ( IN GLenum opcode );
void      APIENTRY glcltStencilFunc            ( IN GLenum func, IN GLint ref, IN GLuint mask );
void      APIENTRY glcltStencilOp              ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass );
void      APIENTRY glcltDepthFunc              ( IN GLenum func );
void      APIENTRY glcltPixelZoom              ( IN GLfloat xfactor, IN GLfloat yfactor );
void      APIENTRY glcltPixelTransferf         ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltPixelTransferi         ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltPixelStoref            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltPixelStorei            ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltPixelMapfv             ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] );
void      APIENTRY glcltPixelMapuiv            ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] );
void      APIENTRY glcltPixelMapusv            ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] );
void      APIENTRY glcltReadBuffer             ( IN GLenum mode );
void      APIENTRY glcltCopyPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type );
void      APIENTRY glcltReadPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY glcltDrawPixels             ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY glcltGetBooleanv            ( IN GLenum pname, OUT GLboolean params[] );
void      APIENTRY glcltGetClipPlane           ( IN GLenum plane, OUT GLdouble equation[4] );
void      APIENTRY glcltGetDoublev             ( IN GLenum pname, OUT GLdouble params[] );
GLenum    APIENTRY glcltGetError               ( void );
void      APIENTRY glcltGetFloatv              ( IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetIntegerv            ( IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetLightfv             ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetLightiv             ( IN GLenum light, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetMapdv               ( IN GLenum target, IN GLenum query, OUT GLdouble v[] );
void      APIENTRY glcltGetMapfv               ( IN GLenum target, IN GLenum query, OUT GLfloat v[] );
void      APIENTRY glcltGetMapiv               ( IN GLenum target, IN GLenum query, OUT GLint v[] );
void      APIENTRY glcltGetMaterialfv          ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetMaterialiv          ( IN GLenum face, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetPixelMapfv          ( IN GLenum map, OUT GLfloat values[] );
void      APIENTRY glcltGetPixelMapuiv         ( IN GLenum map, OUT GLuint values[] );
void      APIENTRY glcltGetPixelMapusv         ( IN GLenum map, OUT GLushort values[] );
void      APIENTRY glcltGetPolygonStipple      ( OUT GLubyte mask[] );
const GLubyte * APIENTRY glcltGetString        ( IN GLenum name );
void      APIENTRY glcltGetTexEnvfv            ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexEnviv            ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetTexGendv            ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] );
void      APIENTRY glcltGetTexGenfv            ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexGeniv            ( IN GLenum coord, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetTexImage            ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY glcltGetTexParameterfv      ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexParameteriv      ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] );
GLboolean APIENTRY glcltIsEnabled              ( IN GLenum cap );
GLboolean APIENTRY glcltIsList                 ( IN GLuint list );
void      APIENTRY glcltDepthRange             ( IN GLclampd zNear, IN GLclampd zFar );
void      APIENTRY glcltFrustum                ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY glcltLoadIdentity           ( void );
void      APIENTRY glcltLoadMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY glcltLoadMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY glcltMatrixMode             ( IN GLenum mode );
void      APIENTRY glcltMultMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY glcltMultMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY glcltOrtho                  ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY glcltPopMatrix              ( void );
void      APIENTRY glcltPushMatrix             ( void );
void      APIENTRY glcltRotated                ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltRotatef                ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltScaled                 ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltScalef                 ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltTranslated             ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltTranslatef             ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltViewport               ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY glcltAddSwapHintRectWIN     ( IN GLint x, IN GLint y, IN GLint width, IN GLint height );
void      APIENTRY glsimVertexPointerEXT       ( IN GLint size, IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimColorPointerEXT        ( IN GLint size, IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimTexCoordPointerEXT     ( IN GLint size, IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimNormalPointerEXT       ( IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimIndexPointerEXT        ( IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimEdgeFlagPointerEXT     ( IN GLsizei stride, IN GLsizei count, IN const GLboolean* pointer);
void      APIENTRY glsimArrayElementEXT        ( IN GLint i );
void      APIENTRY glsimArrayElementArrayEXT      ( IN GLenum mode, IN GLsizei count, IN const GLvoid* pi);
void      APIENTRY glsimDrawArraysEXT          ( IN GLenum mode, IN GLint first, IN GLsizei count);
void      APIENTRY glsimGetPointervEXT         ( IN GLenum pname, OUT void** params);
void      APIENTRY glcltArrayElement           (GLint i);
void      APIENTRY glcltColorPointer           (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltDisableClientState     (GLenum array);
void      APIENTRY glcltDrawArrays             (GLenum mode, GLint first, GLsizei count);
void      APIENTRY glcltDrawElements           (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
void      APIENTRY glcltDrawRangeElementsWIN   (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
void      APIENTRY glcltEdgeFlagPointer        (GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltEnableClientState      (GLenum array);
void      APIENTRY glcltIndexub_InRGBA         (GLubyte c);
void      APIENTRY glcltIndexubv_InRGBA        (const GLubyte *c);
void      APIENTRY glcltIndexub_InCI           (GLubyte c);
void      APIENTRY glcltIndexubv_InCI          (const GLubyte *c);
void      APIENTRY glcltIndexPointer           (GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltInterleavedArrays      (GLenum format, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltNormalPointer          (GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltPolygonOffset          (GLfloat factor, GLfloat units);
void      APIENTRY glcltTexCoordPointer        (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltVertexPointer          (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltGetPointerv            (GLenum pname, GLvoid* *params);
void      APIENTRY glcltPopClientAttrib        (void);
void      APIENTRY glcltPushClientAttrib       (IN GLbitfield mask);
GLboolean APIENTRY glcltAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences);
void APIENTRY glcltBindTexture(GLenum target, GLuint texture);
void APIENTRY glcltCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border);
void APIENTRY glcltCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border);
void APIENTRY glcltCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width);
void APIENTRY glcltCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height);
void APIENTRY glcltDeleteTextures(GLsizei n, const GLuint *textures);
void APIENTRY glcltGenTextures(GLsizei n, GLuint *textures);
GLboolean APIENTRY glcltIsTexture(GLuint texture);
void APIENTRY glcltPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities);
void APIENTRY glcltTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels);
void APIENTRY glcltTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);

void APIENTRY glcltColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
void APIENTRY glcltColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
void APIENTRY glcltGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data);
void APIENTRY glcltGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params);
void APIENTRY glcltGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params);

#ifdef GL_WIN_multiple_textures
void APIENTRY glcltCurrentTextureIndexWIN
    (GLuint index);
void APIENTRY glcltMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s);
void APIENTRY glcltMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s);
void APIENTRY glcltMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord1iWIN
    (GLbitfield mask, GLint s);
void APIENTRY glcltMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s);
void APIENTRY glcltMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t);
void APIENTRY glcltMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t);
void APIENTRY glcltMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t);
void APIENTRY glcltMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t);
void APIENTRY glcltMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
void APIENTRY glcltMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
void APIENTRY glcltMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r);
void APIENTRY glcltMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r);
void APIENTRY glcltMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
void APIENTRY glcltMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
void APIENTRY glcltMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
void APIENTRY glcltMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
void APIENTRY glcltMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture);
void APIENTRY glcltNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

#endif /* __GLCLT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glp.h ===
/******************************Module*Header*******************************\
* Module Name: glp.h
*
* GL system routines shared between the front and back end
*
* Created: 12-Nov-1993 17:36:00
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _glp_
#define _glp_

// Calls into the back end
typedef struct GLGENwindowRec GLGENwindow;

// Fake object type for DirectDraw.  BITMAP is used because it
// shouldn't come up in the places we use GetObjectType.
#define OBJ_DDRAW OBJ_BITMAP

// Surface flags

// HDC available
#define GLSURF_HDC                      0x00000001
// DirectDraw surfaces available
#define GLSURF_DIRECTDRAW               0x00000002
// Metafile-based
#define GLSURF_METAFILE                 0x00000004
// Direct memory access possible
#define GLSURF_DIRECT_ACCESS            0x00000008
// Screen surface, only set for HDC surfaces
#define GLSURF_SCREEN                   0x00000010
// Direct DC surface
#define GLSURF_DIRECTDC                 0x00000020
// Surface is in video memory
#define GLSURF_VIDEO_MEMORY             0x00000040

// Special surface types

// Memory DC
#define GLSURF_IS_MEMDC(dwFlags) \
    (((dwFlags) & (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_METAFILE)) == \
     GLSURF_HDC)
// Non-memory, non-info DC
#define GLSURF_IS_DIRECTDC(dwFlags) \
    (((dwFlags) & (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_METAFILE)) == \
     (GLSURF_HDC | GLSURF_DIRECTDC))
// Direct DC for the screen
#define GLSURF_IS_SCREENDC(dwFlags) \
    (((dwFlags) & (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_METAFILE | \
                   GLSURF_SCREEN)) == \
     (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_SCREEN))

typedef struct IDirectDrawSurface *LPDIRECTDRAWSURFACE;

typedef struct _GLDDSURF
{
    LPDIRECTDRAWSURFACE pdds;
    DDSURFACEDESC ddsd;
    DWORD dwBitDepth;
} GLDDSURF;

typedef struct _GLDDSURFACES
{
    GLDDSURF gddsFront;
    GLDDSURF gddsZ;
} GLDDSURFACES;

typedef struct _GLSURF
{
    DWORD dwFlags;
    int iLayer;
    int ipfd;
    
    PIXELFORMATDESCRIPTOR pfd;

    // Needed for ExtEscape calls for hardware even for surfaces, like
    // DirectDraw surfaces, which don't need a DC for access
    HDC hdc;
    
    // Source-specific fields
    union
    {
        HWND hwnd;
        GLDDSURFACES dd;
    };
} GLSURF;

DWORD APIENTRY DdbdToCount(DWORD ddbd);
// The documentation says that depths returned in DDPIXELFORMATs are
// DDBD_ constants, but they seem to be real numbers.  Hide the conversion
// necessary in case it needs to change.
#define DdPixDepthToCount(ddpd) (ddpd)
BYTE APIENTRY DdPixelDepth(DDSURFACEDESC *pddsd);

void  APIENTRY MaskToBitsAndShift(DWORD dwMask, BYTE *pbBits, BYTE *pbShift);
BOOL  APIENTRY InitDeviceSurface(HDC hdc, int ipfd, int iLayer,
                                 DWORD dwObjectType, BOOL bUpdatePfd,
                                 GLSURF *pgsurf);

BOOL  APIENTRY IsDirectDrawDevice(HDC hdc);

BOOL  APIENTRY glsrvAttention(PVOID, PVOID, PVOID, HANDLE);
PVOID APIENTRY glsrvCreateContext(struct _GLWINDOWID *, GLSURF *);
BOOL  APIENTRY glsrvMakeCurrent(struct _GLWINDOWID *, PVOID, GLGENwindow *);
VOID  APIENTRY glsrvLoseCurrent(PVOID);
BOOL  APIENTRY glsrvDeleteContext(PVOID);
BOOL  APIENTRY glsrvSwapBuffers(HDC, GLGENwindow *);
VOID  APIENTRY glsrvThreadExit(void);
VOID  APIENTRY glsrvCleanupWindow(PVOID, GLGENwindow *);
ULONG APIENTRY glsrvShareLists(PVOID, PVOID);
BOOL  APIENTRY glsrvCopyContext(PVOID, PVOID, UINT);
BOOL  APIENTRY glsrvBindDirectDrawTexture(struct __GLcontextRec *, int,
                                          LPDIRECTDRAWSURFACE *,
                                          DDSURFACEDESC *, ULONG);
void  APIENTRY glsrvUnbindDirectDrawTexture(struct __GLcontextRec *);

BOOL APIENTRY __wglGetBitfieldColorFormat(HDC hdc, UINT cColorBits,
                                          PIXELFORMATDESCRIPTOR *ppfd,
                                          BOOL bDescribeSurf);

BOOL APIENTRY wglIsDirectDevice(HDC hdc);

// Cleans up any orphaned window information
VOID  APIENTRY wglValidateWindows(void);

// GL metafile support function
DWORD APIENTRY wglObjectType(HDC hdc);

// Find pixel format counts
VOID APIENTRY wglNumHardwareFormats(HDC hdc, DWORD dwType,
                                    int *piMcd, int *piIcd);

// Calls from the back end to the front end
int  WINAPI __DrvDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                     LPPIXELFORMATDESCRIPTOR ppfd);
BOOL WINAPI __DrvSetPixelFormat(HDC hdc, int ipfd, PVOID *pwnd);
BOOL WINAPI __DrvSwapBuffers(HDC hdc, BOOL bFinish);

extern CRITICAL_SECTION gcsPixelFormat;

extern CRITICAL_SECTION gcsPaletteWatcher;
extern DWORD tidPaletteWatcherThread;
extern ULONG ulPaletteWatcherCount;
extern HWND hwndPaletteWatcher;

extern DWORD dwPlatformId;
#define NT_PLATFORM     ( dwPlatformId == VER_PLATFORM_WIN32_NT )
#define WIN95_PLATFORM  ( dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )

extern LONG lThreadsAttached;

typedef HRESULT (WINAPI *PFN_GETSURFACEFROMDC)(HDC, LPDIRECTDRAWSURFACE *,
                                               HDC *);
extern PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC;

#ifdef GL_METAFILE
// OpenGL metafile support routines in GDI, dynamically linked
// so the DLL can be run on platforms without metafile support
extern BOOL (APIENTRY *pfnGdiAddGlsRecord)(HDC hdc, DWORD cb, BYTE *pb,
                                           LPRECTL prclBounds);
extern BOOL (APIENTRY *pfnGdiAddGlsBounds)(HDC hdc, LPRECTL prclBounds);
extern BOOL (APIENTRY *pfnGdiIsMetaPrintDC)(HDC hdc);

#if DBG
// Use NULL-checking thunks in debug mode to check erroneous DLL usage
BOOL APIENTRY GlGdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds);
BOOL APIENTRY GlGdiAddGlsBounds(HDC hdc, LPRECTL prclBounds);
BOOL APIENTRY GlGdiIsMetaPrintDC(HDC hdc);
#else
// Call directly through points in retail builds
#define GlGdiAddGlsRecord(hdc, cb, pb, prcl) \
    pfnGdiAddGlsRecord(hdc, cb, pb, prcl)
#define GlGdiAddGlsBounds(hdc, prcl) \
    pfnGdiAddGlsBounds(hdc, prcl)
#define GlGdiIsMetaPrintDC(hdc) \
    pfnGdiIsMetaPrintDC(hdc)
#endif
#endif

#include <alloc.h>
#include <debug.h>

#endif // _glp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glsbcltu.h ===
/*
 *  Copyright 1991, 1992, Silicon Graphics, Inc.
 *  All Rights Reserved.
 *
 *  This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
 *  the contents of this file may not be disclosed to third parties, copied or
 *  duplicated in any form, in whole or in part, without the prior written
 *  permission of Silicon Graphics, Inc.
 *
 *  RESTRICTED RIGHTS LEGEND:
 *  Use, duplication or disclosure by the Government is subject to restrictions
 *  as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
 *  and Computer Software clause at DFARS 252.227-7013, and/or in similar or
 *  successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
 *  rights reserved under the Copyright Laws of the United States.
 */

#ifndef __GLSBCLTU_H__
#define __GLSBCLTU_H__

#ifndef _CLIENTSIDE_
BOOL APIENTRY glsbCreateAndDuplicateSection ( DWORD SectionSize );
BOOL APIENTRY glsbMsgStats ( LONG Action, GLMSGBATCHSTATS *BatchStats );
void APIENTRY glsbCloseAndDestroySection( void );
#endif
BOOL APIENTRY glsbAttention ( void );
ULONG APIENTRY glsbAttentionAlt(ULONG Offset);
VOID APIENTRY glsbResetBuffers(BOOL);

#endif /* __GLSBCLTU_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glsize.h ===
#ifndef __GLSIZE_H__
#define __GLSIZE_H__

#define RANGE(n, a, b)  \
	(((unsigned)(n) >= (unsigned)(a)) && ((unsigned)(n) <= (unsigned)(b)))

#define __GLTYPESIZE(n)          __glTypeSize[(n)-GL_BYTE]
extern GLint __glTypeSize[];
// #define RANGE_GLTYPESIZE(n)   RANGE(n,GL_BYTE,GL_DOUBLE)

#endif  /* !__GLSIZE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glsbmsg.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#ifndef __GLSBMSG_H__
#define __GLSBMSG_H__

/*
 * Sub batching Messages
 */
typedef struct
{
    ULONG ProcOffset;
    GLint xs;
    GLint ys;
    GLint xe;
    GLint ye;

} GLMSG_ADDSWAPHINTRECTWIN;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;
    GLenum mode;

} GLMSG_NEWLIST;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_ENDLIST;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;

} GLMSG_CALLLIST;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    GLenum type;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG listsOff;

} GLMSG_CALLLISTS;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;
    GLsizei range;

} GLMSG_DELETELISTS;

typedef struct
{
    ULONG ProcOffset;
    GLsizei range;

} GLMSG_GENLISTS;

typedef struct
{
    ULONG ProcOffset;
    GLuint base;

} GLMSG_LISTBASE;

typedef struct
{
    ULONG ProcOffset;
    PVOID pa0;
    PVOID paLast;
    ULONG pad[512];

} GLMSG_DRAWPOLYARRAY_LARGE;	// this must be the largest message!

typedef struct
{
    ULONG ProcOffset;
    PVOID pa0;
    PVOID paLast;

} GLMSG_DRAWPOLYARRAY;

typedef struct
{
    ULONG ProcOffset;
    GLbyte red;
    GLbyte green;
    GLbyte blue;

} GLMSG_COLOR3B;

typedef struct
{
    ULONG ProcOffset;
    GLbyte v[3];

} GLMSG_COLOR3BV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble red;
    GLdouble green;
    GLdouble blue;

} GLMSG_COLOR3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_COLOR3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat red;
    GLfloat green;
    GLfloat blue;

} GLMSG_COLOR3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_COLOR3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint red;
    GLint green;
    GLint blue;

} GLMSG_COLOR3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_COLOR3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort red;
    GLshort green;
    GLshort blue;

} GLMSG_COLOR3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_COLOR3SV;

typedef struct
{
    ULONG ProcOffset;
    GLubyte red;
    GLubyte green;
    GLubyte blue;

} GLMSG_COLOR3UB;

typedef struct
{
    ULONG ProcOffset;
    GLubyte v[3];

} GLMSG_COLOR3UBV;

typedef struct
{
    ULONG ProcOffset;
    GLuint red;
    GLuint green;
    GLuint blue;

} GLMSG_COLOR3UI;

typedef struct
{
    ULONG ProcOffset;
    GLuint v[3];

} GLMSG_COLOR3UIV;

typedef struct
{
    ULONG ProcOffset;
    GLushort red;
    GLushort green;
    GLushort blue;

} GLMSG_COLOR3US;

typedef struct
{
    ULONG ProcOffset;
    GLushort v[3];

} GLMSG_COLOR3USV;

typedef struct
{
    ULONG ProcOffset;
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    GLbyte alpha;

} GLMSG_COLOR4B;

typedef struct
{
    ULONG ProcOffset;
    GLbyte v[4];

} GLMSG_COLOR4BV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble red;
    GLdouble green;
    GLdouble blue;
    GLdouble alpha;

} GLMSG_COLOR4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_COLOR4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;

} GLMSG_COLOR4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_COLOR4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;

} GLMSG_COLOR4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_COLOR4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort red;
    GLshort green;
    GLshort blue;
    GLshort alpha;

} GLMSG_COLOR4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_COLOR4SV;

typedef struct
{
    ULONG ProcOffset;
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    GLubyte alpha;

} GLMSG_COLOR4UB;

typedef struct
{
    ULONG ProcOffset;
    GLubyte v[4];

} GLMSG_COLOR4UBV;

typedef struct
{
    ULONG ProcOffset;
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;

} GLMSG_COLOR4UI;

typedef struct
{
    ULONG ProcOffset;
    GLuint v[4];

} GLMSG_COLOR4UIV;

typedef struct
{
    ULONG ProcOffset;
    GLushort red;
    GLushort green;
    GLushort blue;
    GLushort alpha;

} GLMSG_COLOR4US;

typedef struct
{
    ULONG ProcOffset;
    GLushort v[4];

} GLMSG_COLOR4USV;

typedef struct
{
    ULONG ProcOffset;
    GLboolean flag;

} GLMSG_EDGEFLAG;

typedef struct
{
    ULONG ProcOffset;
    GLboolean flag[1];

} GLMSG_EDGEFLAGV;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_END;

typedef struct
{
    ULONG ProcOffset;
    GLdouble c;

} GLMSG_INDEXD;

typedef struct
{
    ULONG ProcOffset;
    GLdouble c[1];

} GLMSG_INDEXDV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat c;

} GLMSG_INDEXF;

typedef struct
{
    ULONG ProcOffset;
    GLfloat c[1];

} GLMSG_INDEXFV;

typedef struct
{
    ULONG ProcOffset;
    GLint c;

} GLMSG_INDEXI;

typedef struct
{
    ULONG ProcOffset;
    GLint c[1];

} GLMSG_INDEXIV;

typedef struct
{
    ULONG ProcOffset;
    GLshort c;

} GLMSG_INDEXS;

typedef struct
{
    ULONG ProcOffset;
    GLshort c[1];

} GLMSG_INDEXSV;

typedef struct
{
    ULONG ProcOffset;
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;

} GLMSG_NORMAL3B;

typedef struct
{
    ULONG ProcOffset;
    GLbyte v[3];

} GLMSG_NORMAL3BV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble nx;
    GLdouble ny;
    GLdouble nz;

} GLMSG_NORMAL3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_NORMAL3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;

} GLMSG_NORMAL3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_NORMAL3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint nx;
    GLint ny;
    GLint nz;

} GLMSG_NORMAL3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_NORMAL3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort nx;
    GLshort ny;
    GLshort nz;

} GLMSG_NORMAL3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_NORMAL3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;

} GLMSG_RASTERPOS2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[2];

} GLMSG_RASTERPOS2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;

} GLMSG_RASTERPOS2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[2];

} GLMSG_RASTERPOS2FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;

} GLMSG_RASTERPOS2I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[2];

} GLMSG_RASTERPOS2IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;

} GLMSG_RASTERPOS2S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[2];

} GLMSG_RASTERPOS2SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_RASTERPOS3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_RASTERPOS3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_RASTERPOS3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_RASTERPOS3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;

} GLMSG_RASTERPOS3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_RASTERPOS3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;

} GLMSG_RASTERPOS3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_RASTERPOS3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;

} GLMSG_RASTERPOS4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_RASTERPOS4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;

} GLMSG_RASTERPOS4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_RASTERPOS4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;
    GLint w;

} GLMSG_RASTERPOS4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_RASTERPOS4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;

} GLMSG_RASTERPOS4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_RASTERPOS4SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x1;
    GLdouble y1;
    GLdouble x2;
    GLdouble y2;

} GLMSG_RECTD;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v1[2];
    GLdouble v2[2];

} GLMSG_RECTDV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x1;
    GLfloat y1;
    GLfloat x2;
    GLfloat y2;

} GLMSG_RECTF;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v1[2];
    GLfloat v2[2];

} GLMSG_RECTFV;

typedef struct
{
    ULONG ProcOffset;
    GLint x1;
    GLint y1;
    GLint x2;
    GLint y2;

} GLMSG_RECTI;

typedef struct
{
    ULONG ProcOffset;
    GLint v1[2];
    GLint v2[2];

} GLMSG_RECTIV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x1;
    GLshort y1;
    GLshort x2;
    GLshort y2;

} GLMSG_RECTS;

typedef struct
{
    ULONG ProcOffset;
    GLshort v1[2];
    GLshort v2[2];

} GLMSG_RECTSV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;

} GLMSG_TEXCOORD1D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[1];

} GLMSG_TEXCOORD1DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;

} GLMSG_TEXCOORD1F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[1];

} GLMSG_TEXCOORD1FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;

} GLMSG_TEXCOORD1I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[1];

} GLMSG_TEXCOORD1IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;

} GLMSG_TEXCOORD1S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[1];

} GLMSG_TEXCOORD1SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;
    GLdouble t;

} GLMSG_TEXCOORD2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[2];

} GLMSG_TEXCOORD2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;
    GLfloat t;

} GLMSG_TEXCOORD2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[2];

} GLMSG_TEXCOORD2FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;
    GLint t;

} GLMSG_TEXCOORD2I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[2];

} GLMSG_TEXCOORD2IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;
    GLshort t;

} GLMSG_TEXCOORD2S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[2];

} GLMSG_TEXCOORD2SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;
    GLdouble t;
    GLdouble r;

} GLMSG_TEXCOORD3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_TEXCOORD3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;
    GLfloat t;
    GLfloat r;

} GLMSG_TEXCOORD3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_TEXCOORD3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;
    GLint t;
    GLint r;

} GLMSG_TEXCOORD3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_TEXCOORD3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;
    GLshort t;
    GLshort r;

} GLMSG_TEXCOORD3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_TEXCOORD3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;
    GLdouble t;
    GLdouble r;
    GLdouble q;

} GLMSG_TEXCOORD4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_TEXCOORD4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;

} GLMSG_TEXCOORD4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_TEXCOORD4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;
    GLint t;
    GLint r;
    GLint q;

} GLMSG_TEXCOORD4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_TEXCOORD4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;

} GLMSG_TEXCOORD4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_TEXCOORD4SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;

} GLMSG_VERTEX2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[2];

} GLMSG_VERTEX2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;

} GLMSG_VERTEX2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[2];

} GLMSG_VERTEX2FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;

} GLMSG_VERTEX2I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[2];

} GLMSG_VERTEX2IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;

} GLMSG_VERTEX2S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[2];

} GLMSG_VERTEX2SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_VERTEX3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_VERTEX3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_VERTEX3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_VERTEX3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;

} GLMSG_VERTEX3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_VERTEX3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;

} GLMSG_VERTEX3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_VERTEX3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;

} GLMSG_VERTEX4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_VERTEX4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;

} GLMSG_VERTEX4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_VERTEX4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;
    GLint w;

} GLMSG_VERTEX4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_VERTEX4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;

} GLMSG_VERTEX4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_VERTEX4SV;

typedef struct
{
    ULONG ProcOffset;
    GLenum plane;
    GLdouble equation[4];

} GLMSG_CLIPPLANE;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum mode;

} GLMSG_COLORMATERIAL;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_CULLFACE;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_FRONTFACE;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum mode;

} GLMSG_HINT;

typedef struct
{
    ULONG ProcOffset;
    GLint factor;
    GLushort pattern;

} GLMSG_LINESTIPPLE;

typedef struct
{
    ULONG ProcOffset;
    GLfloat width;

} GLMSG_LINEWIDTH;

typedef struct
{
    ULONG ProcOffset;
    GLfloat size;

} GLMSG_POINTSIZE;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum mode;

} GLMSG_POLYGONMODE;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;

} GLMSG_SCISSOR;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_SHADEMODEL;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_INITNAMES;

typedef struct
{
    ULONG ProcOffset;
    GLuint name;

} GLMSG_LOADNAME;

typedef struct
{
    ULONG ProcOffset;
    GLfloat token;

} GLMSG_PASSTHROUGH;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_POPNAME;

typedef struct
{
    ULONG ProcOffset;
    GLuint name;

} GLMSG_PUSHNAME;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_DRAWBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLbitfield mask;

} GLMSG_CLEAR;

typedef struct
{
    ULONG ProcOffset;
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;

} GLMSG_CLEARACCUM;

typedef struct
{
    ULONG ProcOffset;
    GLfloat c;

} GLMSG_CLEARINDEX;

typedef struct
{
    ULONG ProcOffset;
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;

} GLMSG_CLEARCOLOR;

typedef struct
{
    ULONG ProcOffset;
    GLint s;

} GLMSG_CLEARSTENCIL;

typedef struct
{
    ULONG ProcOffset;
    GLclampd depth;

} GLMSG_CLEARDEPTH;

typedef struct
{
    ULONG ProcOffset;
    GLuint mask;

} GLMSG_STENCILMASK;

typedef struct
{
    ULONG ProcOffset;
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;

} GLMSG_COLORMASK;

typedef struct
{
    ULONG ProcOffset;
    GLboolean flag;

} GLMSG_DEPTHMASK;

typedef struct
{
    ULONG ProcOffset;
    GLuint mask;

} GLMSG_INDEXMASK;

typedef struct
{
    ULONG ProcOffset;
    GLenum op;
    GLfloat value;

} GLMSG_ACCUM;

typedef struct
{
    ULONG ProcOffset;
    GLenum cap;

} GLMSG_DISABLE;

typedef struct
{
    ULONG ProcOffset;
    GLenum cap;

} GLMSG_ENABLE;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_FINISH;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_FLUSH;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_POPATTRIB;

typedef struct
{
    ULONG ProcOffset;
    GLbitfield mask;

} GLMSG_PUSHATTRIB;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLdouble u1;
    GLdouble u2;

} GLMSG_MAPGRID1D;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLfloat u1;
    GLfloat u2;

} GLMSG_MAPGRID1F;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLdouble u1;
    GLdouble u2;
    GLint vn;
    GLdouble v1;
    GLdouble v2;

} GLMSG_MAPGRID2D;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLfloat u1;
    GLfloat u2;
    GLint vn;
    GLfloat v1;
    GLfloat v2;

} GLMSG_MAPGRID2F;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u;

} GLMSG_EVALCOORD1D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u[1];

} GLMSG_EVALCOORD1DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u;

} GLMSG_EVALCOORD1F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u[1];

} GLMSG_EVALCOORD1FV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u;
    GLdouble v;

} GLMSG_EVALCOORD2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u[2];

} GLMSG_EVALCOORD2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u;
    GLfloat v;

} GLMSG_EVALCOORD2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u[2];

} GLMSG_EVALCOORD2FV;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;
    GLint i1;
    GLint i2;

} GLMSG_EVALMESH1;

typedef struct
{
    ULONG ProcOffset;
    GLint i;

} GLMSG_EVALPOINT1;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;
    GLint i1;
    GLint i2;
    GLint j1;
    GLint j2;

} GLMSG_EVALMESH2;

typedef struct
{
    ULONG ProcOffset;
    GLint i;
    GLint j;

} GLMSG_EVALPOINT2;

typedef struct
{
    ULONG ProcOffset;
    GLenum func;
    GLclampf ref;

} GLMSG_ALPHAFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLenum sfactor;
    GLenum dfactor;

} GLMSG_BLENDFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLenum opcode;

} GLMSG_LOGICOP;

typedef struct
{
    ULONG ProcOffset;
    GLenum func;
    GLint ref;
    GLuint mask;

} GLMSG_STENCILFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLenum fail;
    GLenum zfail;
    GLenum zpass;

} GLMSG_STENCILOP;

typedef struct
{
    ULONG ProcOffset;
    GLenum func;

} GLMSG_DEPTHFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLfloat xfactor;
    GLfloat yfactor;

} GLMSG_PIXELZOOM;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat param;

} GLMSG_PIXELTRANSFERF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint param;

} GLMSG_PIXELTRANSFERI;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat param;

} GLMSG_PIXELSTOREF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint param;

} GLMSG_PIXELSTOREI;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    GLint mapsize;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_PIXELMAPFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    GLint mapsize;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_PIXELMAPUIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    GLint mapsize;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_PIXELMAPUSV;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_READBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum type;

} GLMSG_COPYPIXELS;

typedef struct
{
    ULONG ProcOffset;
    GLenum plane;
#ifdef _CLIENTSIDE_
    GLdouble *equation;
#else
    GLdouble equation[4];
#endif

} GLMSG_GETCLIPPLANE;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_GETERROR;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum query;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR vOff;

} GLMSG_GETMAPDV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum query;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR vOff;

} GLMSG_GETMAPFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum query;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR vOff;

} GLMSG_GETMAPIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_GETPIXELMAPFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_GETPIXELMAPUIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_GETPIXELMAPUSV;

typedef struct
{
    ULONG ProcOffset;
    GLenum cap;

} GLMSG_ISENABLED;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;

} GLMSG_ISLIST;

typedef struct
{
    ULONG ProcOffset;
    GLclampd zNear;
    GLclampd zFar;

} GLMSG_DEPTHRANGE;

typedef struct
{
    ULONG ProcOffset;
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;

} GLMSG_FRUSTUM;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_LOADIDENTITY;

typedef struct
{
    ULONG ProcOffset;
    GLfloat m[16];

} GLMSG_LOADMATRIXF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble m[16];

} GLMSG_LOADMATRIXD;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_MATRIXMODE;

typedef struct
{
    ULONG ProcOffset;
    GLfloat m[16];

} GLMSG_MULTMATRIXF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble m[16];

} GLMSG_MULTMATRIXD;

typedef struct
{
    ULONG ProcOffset;
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;

} GLMSG_ORTHO;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_POPMATRIX;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_PUSHMATRIX;

typedef struct
{
    ULONG ProcOffset;
    GLdouble angle;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_ROTATED;

typedef struct
{
    ULONG ProcOffset;
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_ROTATEF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_SCALED;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_SCALEF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_TRANSLATED;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_TRANSLATEF;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;

} GLMSG_VIEWPORT;

#endif /* !__GLSBMSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glsbmsgh.h ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * Message for handcoded OpenGL functions going through the subbatch
 */

#ifndef __GLSBMSGH_H__
#define __GLSBMSGH_H__

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat params[4];

} GLMSG_FOGFV, GLMSG_FOGF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint params[4];

} GLMSG_FOGIV, GLMSG_FOGI;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
    GLfloat params[4];

} GLMSG_LIGHTFV, GLMSG_LIGHTF;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
    GLint params[4];

} GLMSG_LIGHTIV, GLMSG_LIGHTI;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat params[4];

} GLMSG_LIGHTMODELFV, GLMSG_LIGHTMODELF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint params[4];

} GLMSG_LIGHTMODELIV, GLMSG_LIGHTMODELI;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
    GLfloat params[4];

} GLMSG_MATERIALFV, GLMSG_MATERIALF;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
    GLint params[4];

} GLMSG_MATERIALIV, GLMSG_MATERIALI;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLfloat params[4];

} GLMSG_TEXPARAMETERFV, GLMSG_TEXPARAMETERF;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLint params[4];

} GLMSG_TEXPARAMETERIV, GLMSG_TEXPARAMETERI;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLfloat params[4];

} GLMSG_TEXENVFV, GLMSG_TEXENVF;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLint params[4];

} GLMSG_TEXENVIV, GLMSG_TEXENVI;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
    GLdouble params[4];

} GLMSG_TEXGENDV, GLMSG_TEXGEND;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
    GLfloat params[4];

} GLMSG_TEXGENFV, GLMSG_TEXGENF;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
    GLint params[4];

} GLMSG_TEXGENIV, GLMSG_TEXGENI;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLboolean *params;
#else
    GLboolean params[16];
#endif

} GLMSG_GETBOOLEANV;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLdouble *params;
#else
    GLdouble params[16];
#endif

} GLMSG_GETDOUBLEV;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[16];
#endif

} GLMSG_GETFLOATV;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[16];
#endif

} GLMSG_GETINTEGERV;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETLIGHTFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETLIGHTIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETMATERIALFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETMATERIALIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETTEXENVFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETTEXENVIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLdouble *params;
#else
    GLdouble params[4];
#endif

} GLMSG_GETTEXGENDV;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETTEXGENFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETTEXGENIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETTEXPARAMETERFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETTEXPARAMETERIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[1];
#endif

} GLMSG_GETTEXLEVELPARAMETERFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[1];
#endif

} GLMSG_GETTEXLEVELPARAMETERIV;

typedef struct
{
    ULONG_PTR ProcOffset;
    GLsizei size;
    GLenum type;
    ULONG_PTR bufferOff;

} GLMSG_FEEDBACKBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLsizei size;
    ULONG_PTR bufferOff;

} GLMSG_SELECTBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_RENDERMODE;

typedef struct
{
    // This only used so that the code compiles.
    // GetString is included in the proctables.
    // However, GetString() is currently implemented
    // on the client side.

    ULONG ProcOffset;

} GLMSG_GETSTRING;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint stride;
    GLint order;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP1F;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint ustride;
    GLint uorder;
    GLdouble v1;
    GLdouble v2;
    GLint vstride;
    GLint vorder;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP2D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP2F;

typedef struct
{
    ULONG ProcOffset    ;
    GLint x             ;
    GLint y             ;
    GLsizei width       ;
    GLsizei height      ;
    GLenum format       ;
    GLenum type         ;
    ULONG_PTR pixelsOff ;

} GLMSG_READPIXELS;

typedef struct
{
    ULONG  ProcOffset   ;
    GLenum target       ;
    GLint  level        ;
    GLenum format       ;
    GLenum type         ;
    ULONG_PTR pixelsOff ;

} GLMSG_GETTEXIMAGE;

typedef struct
{
    ULONG   ProcOffset  ;
    GLsizei width       ;
    GLsizei height      ;
    GLenum  format      ;
    GLenum  type        ;
    ULONG_PTR pixelsOff ;
    GLboolean _IsDlist  ;

} GLMSG_DRAWPIXELS;

typedef struct
{
    ULONG   ProcOffset  ;
    GLsizei width       ;
    GLsizei height      ;
    GLfloat xorig       ;
    GLfloat yorig       ;
    GLfloat xmove       ;
    GLfloat ymove       ;
    ULONG_PTR bitmapOff ;
    GLboolean _IsDlist  ;

} GLMSG_BITMAP;

typedef struct
{
    ULONG ProcOffset    ;
    ULONG_PTR maskOff       ;
    GLboolean _IsDlist  ;

} GLMSG_POLYGONSTIPPLE, GLMSG_GETPOLYGONSTIPPLE;

typedef struct
{
    ULONG   ProcOffset  ;
    GLenum  target      ;
    GLint   level       ;
    GLint   components  ;
    GLsizei width       ;
    GLint   border      ;
    GLenum  format      ;
    GLenum  type        ;
    ULONG_PTR pixelsOff ;
    GLboolean _IsDlist  ;

} GLMSG_TEXIMAGE1D;

typedef struct
{
    ULONG   ProcOffset  ;
    GLenum  target      ;
    GLint   level       ;
    GLint   components  ;
    GLsizei width       ;
    GLsizei height      ;
    GLint   border      ;
    GLenum  format      ;
    GLenum  type        ;
    ULONG_PTR pixelsOff ;
    GLboolean _IsDlist  ;

} GLMSG_TEXIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    const GLuint *textures;
    GLboolean *residences;
} GLMSG_ARETEXTURESRESIDENT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLuint texture;
} GLMSG_BINDTEXTURE;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} GLMSG_COPYTEXIMAGE1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} GLMSG_COPYTEXIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
} GLMSG_COPYTEXSUBIMAGE1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} GLMSG_COPYTEXSUBIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    const GLuint *textures;
} GLMSG_DELETETEXTURES;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    GLuint *textures;
} GLMSG_GENTEXTURES;

typedef struct
{
    ULONG ProcOffset;
    GLuint texture;
} GLMSG_ISTEXTURE;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    const GLuint *textures;
    const GLclampf *priorities;
} GLMSG_PRIORITIZETEXTURES;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    ULONG_PTR pixelsOff;
    GLboolean _IsDlist  ;
} GLMSG_TEXSUBIMAGE1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    ULONG_PTR pixelsOff;
    GLboolean _IsDlist  ;
} GLMSG_TEXSUBIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLenum format;
    GLenum type;
    const GLvoid *data;
    GLboolean _IsDlist;
} GLMSG_COLORTABLEEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLuint start;
    GLsizei count;
    GLenum format;
    GLenum type;
    const GLvoid *data;
    GLboolean _IsDlist;
} GLMSG_COLORSUBTABLEEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid *data;
} GLMSG_GETCOLORTABLEEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLint *params;
} GLMSG_GETCOLORTABLEPARAMETERIVEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLfloat *params;
} GLMSG_GETCOLORTABLEPARAMETERFVEXT;

typedef struct
{
    ULONG ProcOffset;
    GLfloat factor;
    GLfloat units;
} GLMSG_POLYGONOFFSET;

#ifdef GL_WIN_multiple_textures
typedef struct
{
    ULONG ProcOffset;
    GLuint index;
} GLMSG_CURRENTTEXTUREINDEXWIN;

typedef struct
{
    ULONG ProcOffset;
    GLuint index;
    GLenum target;
    GLuint texture;
} GLMSG_BINDNTHTEXTUREWIN;

typedef struct
{
    ULONG ProcOffset;
    GLuint index;
    GLenum leftColorFactor;
    GLenum colorOp;
    GLenum rightColorFactor;
    GLenum leftAlphaFactor;
    GLenum alphaOp;
    GLenum rightAlphaFactor;
} GLMSG_NTHTEXCOMBINEFUNCWIN;
#endif // GL_WIN_multiple_textures

#endif /* !__GLSBMSGH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glscreen.h ===
/******************************Module*Header*******************************\
* Module Name: glscreen.h
*
* OpenGL direct screen access support
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef _GLSCREEN_H_
#define _GLSCREEN_H_

#include <ddraw.h>

//
// Structure that contains all the info we need to access the framebuffer
//
typedef struct _SCREENINFO_ {
    LPDIRECTDRAW pdd;
    GLDDSURF gdds;
} SCREENINFO;

//
// Global pointer to SCREENINFO structure that is non-NULL if and only if
// direct access to the framebuffer is available.
//
extern SCREENINFO *gpScreenInfo;

//
// Direct access macros:
//
//  GLDIRECTSCREEN  TRUE if direct access is enabled
//  GLSCREENINFO    Pointer to global SCREENINFO.
//
#define GLDIRECTSCREEN  ( gpScreenInfo != NULL )
#define GLSCREENINFO    ( gpScreenInfo )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glsrvspt.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

/* Server Side Sub Batching Procedure Table */


#ifndef __GLSRVSPT_H__
#define __GLSRVSPT_H__

// NOTE:
//   When adding a new server side function, you need to modify the following
//   files:
//
//   opengl\inc\glsrvspt.h
//   opengl\server\inc\dispatch.h
//   opengl\server\inc\imfuncs.h
//   opengl\server\generic\dispatch.c
//   opengl\server\wgl\driver.c
//   opengl\server\wgl\glsrvgs.c
//   opengl\server\wgl\glsrvspt.c
//   opengl\server\wgl\glsrvsb.h

typedef struct _GLSRVSBPROCTABLE {

/* First entry is Null and marks the last message */

    VOID (APIENTRY *NullEntry)( VOID );

/* gl Entry points */

    VOID * (FASTCALL *glsrvDrawPolyArray          )( __GLcontext *, IN GLMSG_DRAWPOLYARRAY          *pMsg );
    VOID * (FASTCALL *glsrvBitmap                 )( __GLcontext *, IN GLMSG_BITMAP                 *pMsg );
    VOID * (FASTCALL *glsrvColor4fv               )( __GLcontext *, IN GLMSG_COLOR4FV               *pMsg );
    VOID * (FASTCALL *glsrvEdgeFlag               )( __GLcontext *, IN GLMSG_EDGEFLAG               *pMsg );
    VOID * (FASTCALL *glsrvIndexf                 )( __GLcontext *, IN GLMSG_INDEXF                 *pMsg );
    VOID * (FASTCALL *glsrvNormal3fv              )( __GLcontext *, IN GLMSG_NORMAL3FV              *pMsg );
    VOID * (FASTCALL *glsrvRasterPos4fv           )( __GLcontext *, IN GLMSG_RASTERPOS4FV           *pMsg );
    VOID * (FASTCALL *glsrvTexCoord4fv            )( __GLcontext *, IN GLMSG_TEXCOORD4FV            *pMsg );
    VOID * (FASTCALL *glsrvClipPlane              )( __GLcontext *, IN GLMSG_CLIPPLANE              *pMsg );
    VOID * (FASTCALL *glsrvColorMaterial          )( __GLcontext *, IN GLMSG_COLORMATERIAL          *pMsg );
    VOID * (FASTCALL *glsrvCullFace               )( __GLcontext *, IN GLMSG_CULLFACE               *pMsg );
    VOID * (FASTCALL *glsrvAddSwapHintRectWIN     )( __GLcontext *, IN GLMSG_ADDSWAPHINTRECTWIN     *pMsg );
    VOID * (FASTCALL *glsrvFogfv                  )( __GLcontext *, IN GLMSG_FOGFV                  *pMsg );
    VOID * (FASTCALL *glsrvFrontFace              )( __GLcontext *, IN GLMSG_FRONTFACE              *pMsg );
    VOID * (FASTCALL *glsrvHint                   )( __GLcontext *, IN GLMSG_HINT                   *pMsg );
    VOID * (FASTCALL *glsrvLightfv                )( __GLcontext *, IN GLMSG_LIGHTFV                *pMsg );
    VOID * (FASTCALL *glsrvLightModelfv           )( __GLcontext *, IN GLMSG_LIGHTMODELFV           *pMsg );
    VOID * (FASTCALL *glsrvLineStipple            )( __GLcontext *, IN GLMSG_LINESTIPPLE            *pMsg );
    VOID * (FASTCALL *glsrvLineWidth              )( __GLcontext *, IN GLMSG_LINEWIDTH              *pMsg );
    VOID * (FASTCALL *glsrvMaterialfv             )( __GLcontext *, IN GLMSG_MATERIALFV             *pMsg );
    VOID * (FASTCALL *glsrvPointSize              )( __GLcontext *, IN GLMSG_POINTSIZE              *pMsg );
    VOID * (FASTCALL *glsrvPolygonMode            )( __GLcontext *, IN GLMSG_POLYGONMODE            *pMsg );
    VOID * (FASTCALL *glsrvPolygonStipple         )( __GLcontext *, IN GLMSG_POLYGONSTIPPLE         *pMsg );
    VOID * (FASTCALL *glsrvScissor                )( __GLcontext *, IN GLMSG_SCISSOR                *pMsg );
    VOID * (FASTCALL *glsrvShadeModel             )( __GLcontext *, IN GLMSG_SHADEMODEL             *pMsg );
    VOID * (FASTCALL *glsrvTexParameterfv         )( __GLcontext *, IN GLMSG_TEXPARAMETERFV         *pMsg );
    VOID * (FASTCALL *glsrvTexParameteriv         )( __GLcontext *, IN GLMSG_TEXPARAMETERIV         *pMsg );
    VOID * (FASTCALL *glsrvTexImage1D             )( __GLcontext *, IN GLMSG_TEXIMAGE1D             *pMsg );
    VOID * (FASTCALL *glsrvTexImage2D             )( __GLcontext *, IN GLMSG_TEXIMAGE2D             *pMsg );
    VOID * (FASTCALL *glsrvTexEnvfv               )( __GLcontext *, IN GLMSG_TEXENVFV               *pMsg );
    VOID * (FASTCALL *glsrvTexEnviv               )( __GLcontext *, IN GLMSG_TEXENVIV               *pMsg );
    VOID * (FASTCALL *glsrvTexGenfv               )( __GLcontext *, IN GLMSG_TEXGENFV               *pMsg );
    VOID * (FASTCALL *glsrvFeedbackBuffer         )( __GLcontext *, IN GLMSG_FEEDBACKBUFFER         *pMsg );
    VOID * (FASTCALL *glsrvSelectBuffer           )( __GLcontext *, IN GLMSG_SELECTBUFFER           *pMsg );
    VOID * (FASTCALL *glsrvRenderMode             )( __GLcontext *, IN GLMSG_RENDERMODE             *pMsg );
    VOID * (FASTCALL *glsrvInitNames              )( __GLcontext *, IN GLMSG_INITNAMES              *pMsg );
    VOID * (FASTCALL *glsrvLoadName               )( __GLcontext *, IN GLMSG_LOADNAME               *pMsg );
    VOID * (FASTCALL *glsrvPassThrough            )( __GLcontext *, IN GLMSG_PASSTHROUGH            *pMsg );
    VOID * (FASTCALL *glsrvPopName                )( __GLcontext *, IN GLMSG_POPNAME                *pMsg );
    VOID * (FASTCALL *glsrvPushName               )( __GLcontext *, IN GLMSG_PUSHNAME               *pMsg );
    VOID * (FASTCALL *glsrvDrawBuffer             )( __GLcontext *, IN GLMSG_DRAWBUFFER             *pMsg );
    VOID * (FASTCALL *glsrvClear                  )( __GLcontext *, IN GLMSG_CLEAR                  *pMsg );
    VOID * (FASTCALL *glsrvClearAccum             )( __GLcontext *, IN GLMSG_CLEARACCUM             *pMsg );
    VOID * (FASTCALL *glsrvClearIndex             )( __GLcontext *, IN GLMSG_CLEARINDEX             *pMsg );
    VOID * (FASTCALL *glsrvClearColor             )( __GLcontext *, IN GLMSG_CLEARCOLOR             *pMsg );
    VOID * (FASTCALL *glsrvClearStencil           )( __GLcontext *, IN GLMSG_CLEARSTENCIL           *pMsg );
    VOID * (FASTCALL *glsrvClearDepth             )( __GLcontext *, IN GLMSG_CLEARDEPTH             *pMsg );
    VOID * (FASTCALL *glsrvStencilMask            )( __GLcontext *, IN GLMSG_STENCILMASK            *pMsg );
    VOID * (FASTCALL *glsrvColorMask              )( __GLcontext *, IN GLMSG_COLORMASK              *pMsg );
    VOID * (FASTCALL *glsrvDepthMask              )( __GLcontext *, IN GLMSG_DEPTHMASK              *pMsg );
    VOID * (FASTCALL *glsrvIndexMask              )( __GLcontext *, IN GLMSG_INDEXMASK              *pMsg );
    VOID * (FASTCALL *glsrvAccum                  )( __GLcontext *, IN GLMSG_ACCUM                  *pMsg );
    VOID * (FASTCALL *glsrvDisable                )( __GLcontext *, IN GLMSG_DISABLE                *pMsg );
    VOID * (FASTCALL *glsrvEnable                 )( __GLcontext *, IN GLMSG_ENABLE                 *pMsg );
    VOID * (FASTCALL *glsrvPopAttrib              )( __GLcontext *, IN GLMSG_POPATTRIB              *pMsg );
    VOID * (FASTCALL *glsrvPushAttrib             )( __GLcontext *, IN GLMSG_PUSHATTRIB             *pMsg );
    VOID * (FASTCALL *glsrvAlphaFunc              )( __GLcontext *, IN GLMSG_ALPHAFUNC              *pMsg );
    VOID * (FASTCALL *glsrvBlendFunc              )( __GLcontext *, IN GLMSG_BLENDFUNC              *pMsg );
    VOID * (FASTCALL *glsrvLogicOp                )( __GLcontext *, IN GLMSG_LOGICOP                *pMsg );
    VOID * (FASTCALL *glsrvStencilFunc            )( __GLcontext *, IN GLMSG_STENCILFUNC            *pMsg );
    VOID * (FASTCALL *glsrvStencilOp              )( __GLcontext *, IN GLMSG_STENCILOP              *pMsg );
    VOID * (FASTCALL *glsrvDepthFunc              )( __GLcontext *, IN GLMSG_DEPTHFUNC              *pMsg );
    VOID * (FASTCALL *glsrvPixelZoom              )( __GLcontext *, IN GLMSG_PIXELZOOM              *pMsg );
    VOID * (FASTCALL *glsrvPixelTransferf         )( __GLcontext *, IN GLMSG_PIXELTRANSFERF         *pMsg );
    VOID * (FASTCALL *glsrvPixelTransferi         )( __GLcontext *, IN GLMSG_PIXELTRANSFERI         *pMsg );
    VOID * (FASTCALL *glsrvPixelStoref            )( __GLcontext *, IN GLMSG_PIXELSTOREF            *pMsg );
    VOID * (FASTCALL *glsrvPixelStorei            )( __GLcontext *, IN GLMSG_PIXELSTOREI            *pMsg );
    VOID * (FASTCALL *glsrvPixelMapfv             )( __GLcontext *, IN GLMSG_PIXELMAPFV             *pMsg );
    VOID * (FASTCALL *glsrvPixelMapuiv            )( __GLcontext *, IN GLMSG_PIXELMAPUIV            *pMsg );
    VOID * (FASTCALL *glsrvPixelMapusv            )( __GLcontext *, IN GLMSG_PIXELMAPUSV            *pMsg );
    VOID * (FASTCALL *glsrvReadBuffer             )( __GLcontext *, IN GLMSG_READBUFFER             *pMsg );
    VOID * (FASTCALL *glsrvCopyPixels             )( __GLcontext *, IN GLMSG_COPYPIXELS             *pMsg );
    VOID * (FASTCALL *glsrvReadPixels             )( __GLcontext *, IN GLMSG_READPIXELS             *pMsg );
    VOID * (FASTCALL *glsrvDrawPixels             )( __GLcontext *, IN GLMSG_DRAWPIXELS             *pMsg );
    VOID * (FASTCALL *glsrvGetBooleanv            )( __GLcontext *, IN GLMSG_GETBOOLEANV            *pMsg );
    VOID * (FASTCALL *glsrvGetClipPlane           )( __GLcontext *, IN GLMSG_GETCLIPPLANE           *pMsg );
    VOID * (FASTCALL *glsrvGetDoublev             )( __GLcontext *, IN GLMSG_GETDOUBLEV             *pMsg );
    VOID * (FASTCALL *glsrvGetError               )( __GLcontext *, IN GLMSG_GETERROR               *pMsg );
    VOID * (FASTCALL *glsrvGetFloatv              )( __GLcontext *, IN GLMSG_GETFLOATV              *pMsg );
    VOID * (FASTCALL *glsrvGetIntegerv            )( __GLcontext *, IN GLMSG_GETINTEGERV            *pMsg );
    VOID * (FASTCALL *glsrvGetLightfv             )( __GLcontext *, IN GLMSG_GETLIGHTFV             *pMsg );
    VOID * (FASTCALL *glsrvGetLightiv             )( __GLcontext *, IN GLMSG_GETLIGHTIV             *pMsg );
    VOID * (FASTCALL *glsrvGetMapdv               )( __GLcontext *, IN GLMSG_GETMAPDV               *pMsg );
    VOID * (FASTCALL *glsrvGetMapfv               )( __GLcontext *, IN GLMSG_GETMAPFV               *pMsg );
    VOID * (FASTCALL *glsrvGetMapiv               )( __GLcontext *, IN GLMSG_GETMAPIV               *pMsg );
    VOID * (FASTCALL *glsrvGetMaterialfv          )( __GLcontext *, IN GLMSG_GETMATERIALFV          *pMsg );
    VOID * (FASTCALL *glsrvGetMaterialiv          )( __GLcontext *, IN GLMSG_GETMATERIALIV          *pMsg );
    VOID * (FASTCALL *glsrvGetPixelMapfv          )( __GLcontext *, IN GLMSG_GETPIXELMAPFV          *pMsg );
    VOID * (FASTCALL *glsrvGetPixelMapuiv         )( __GLcontext *, IN GLMSG_GETPIXELMAPUIV         *pMsg );
    VOID * (FASTCALL *glsrvGetPixelMapusv         )( __GLcontext *, IN GLMSG_GETPIXELMAPUSV         *pMsg );
    VOID * (FASTCALL *glsrvGetPolygonStipple      )( __GLcontext *, IN GLMSG_GETPOLYGONSTIPPLE      *pMsg );
    VOID * (FASTCALL *glsrvGetTexEnvfv            )( __GLcontext *, IN GLMSG_GETTEXENVFV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexEnviv            )( __GLcontext *, IN GLMSG_GETTEXENVIV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexGendv            )( __GLcontext *, IN GLMSG_GETTEXGENDV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexGenfv            )( __GLcontext *, IN GLMSG_GETTEXGENFV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexGeniv            )( __GLcontext *, IN GLMSG_GETTEXGENIV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexImage            )( __GLcontext *, IN GLMSG_GETTEXIMAGE            *pMsg );
    VOID * (FASTCALL *glsrvGetTexParameterfv      )( __GLcontext *, IN GLMSG_GETTEXPARAMETERFV      *pMsg );
    VOID * (FASTCALL *glsrvGetTexParameteriv      )( __GLcontext *, IN GLMSG_GETTEXPARAMETERIV      *pMsg );
    VOID * (FASTCALL *glsrvGetTexLevelParameterfv )( __GLcontext *, IN GLMSG_GETTEXLEVELPARAMETERFV *pMsg );
    VOID * (FASTCALL *glsrvGetTexLevelParameteriv )( __GLcontext *, IN GLMSG_GETTEXLEVELPARAMETERIV *pMsg );
    VOID * (FASTCALL *glsrvIsEnabled              )( __GLcontext *, IN GLMSG_ISENABLED              *pMsg );
    VOID * (FASTCALL *glsrvDepthRange             )( __GLcontext *, IN GLMSG_DEPTHRANGE             *pMsg );
    VOID * (FASTCALL *glsrvFrustum                )( __GLcontext *, IN GLMSG_FRUSTUM                *pMsg );
    VOID * (FASTCALL *glsrvLoadIdentity           )( __GLcontext *, IN GLMSG_LOADIDENTITY           *pMsg );
    VOID * (FASTCALL *glsrvLoadMatrixf            )( __GLcontext *, IN GLMSG_LOADMATRIXF            *pMsg );
    VOID * (FASTCALL *glsrvMatrixMode             )( __GLcontext *, IN GLMSG_MATRIXMODE             *pMsg );
    VOID * (FASTCALL *glsrvMultMatrixf            )( __GLcontext *, IN GLMSG_MULTMATRIXF            *pMsg );
    VOID * (FASTCALL *glsrvOrtho                  )( __GLcontext *, IN GLMSG_ORTHO                  *pMsg );
    VOID * (FASTCALL *glsrvPopMatrix              )( __GLcontext *, IN GLMSG_POPMATRIX              *pMsg );
    VOID * (FASTCALL *glsrvPushMatrix             )( __GLcontext *, IN GLMSG_PUSHMATRIX             *pMsg );
    VOID * (FASTCALL *glsrvRotatef                )( __GLcontext *, IN GLMSG_ROTATEF                *pMsg );
    VOID * (FASTCALL *glsrvScalef                 )( __GLcontext *, IN GLMSG_SCALEF                 *pMsg );
    VOID * (FASTCALL *glsrvTranslatef             )( __GLcontext *, IN GLMSG_TRANSLATEF             *pMsg );
    VOID * (FASTCALL *glsrvViewport               )( __GLcontext *, IN GLMSG_VIEWPORT               *pMsg );
    VOID * (FASTCALL *glsrvAreTexturesResident    )( __GLcontext *, IN GLMSG_ARETEXTURESRESIDENT    *pMsg);
    VOID * (FASTCALL *glsrvBindTexture            )( __GLcontext *, IN GLMSG_BINDTEXTURE            *pMsg);
    VOID * (FASTCALL *glsrvCopyTexImage1D         )( __GLcontext *, IN GLMSG_COPYTEXIMAGE1D         *pMsg);
    VOID * (FASTCALL *glsrvCopyTexImage2D         )( __GLcontext *, IN GLMSG_COPYTEXIMAGE2D         *pMsg);
    VOID * (FASTCALL *glsrvCopyTexSubImage1D      )( __GLcontext *, IN GLMSG_COPYTEXSUBIMAGE1D      *pMsg);
    VOID * (FASTCALL *glsrvCopyTexSubImage2D      )( __GLcontext *, IN GLMSG_COPYTEXSUBIMAGE2D      *pMsg);
    VOID * (FASTCALL *glsrvDeleteTextures         )( __GLcontext *, IN GLMSG_DELETETEXTURES         *pMsg);
    VOID * (FASTCALL *glsrvGenTextures            )( __GLcontext *, IN GLMSG_GENTEXTURES            *pMsg);
    VOID * (FASTCALL *glsrvIsTexture              )( __GLcontext *, IN GLMSG_ISTEXTURE              *pMsg);
    VOID * (FASTCALL *glsrvPrioritizeTextures     )( __GLcontext *, IN GLMSG_PRIORITIZETEXTURES     *pMsg);
    VOID * (FASTCALL *glsrvTexSubImage1D          )( __GLcontext *, IN GLMSG_TEXSUBIMAGE1D          *pMsg);
    VOID * (FASTCALL *glsrvTexSubImage2D          )( __GLcontext *, IN GLMSG_TEXSUBIMAGE2D          *pMsg);
    VOID * (FASTCALL *glsrvColorTableEXT          )( __GLcontext *, IN GLMSG_COLORTABLEEXT          *pMsg);
    VOID * (FASTCALL *glsrvColorSubTableEXT       )( __GLcontext *, IN GLMSG_COLORSUBTABLEEXT       *pMsg);
    VOID * (FASTCALL *glsrvGetColorTableEXT       )( __GLcontext *, IN GLMSG_GETCOLORTABLEEXT       *pMsg);
    VOID * (FASTCALL *glsrvGetColorTableParameterivEXT)( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERIVEXT *pMsg);
    VOID * (FASTCALL *glsrvGetColorTableParameterfvEXT)( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERFVEXT *pMsg);
    VOID * (FASTCALL *glsrvPolygonOffset          )( __GLcontext *, IN GLMSG_POLYGONOFFSET          *pMsg);
#ifdef GL_WIN_multiple_textures
    VOID *(FASTCALL *glsrvCurrentTextureIndexWIN)( __GLcontext *, IN GLMSG_CURRENTTEXTUREINDEXWIN *pMsg);
    VOID *(FASTCALL *glsrvBindNthTextureWIN)( __GLcontext *, IN GLMSG_BINDNTHTEXTUREWIN *pMsg);
    VOID *(FASTCALL *glsrvNthTexCombineFuncWIN)( __GLcontext *, IN GLMSG_NTHTEXCOMBINEFUNCWIN *pMsg);
#endif // GL_WIN_multiple_textures
} GLSRVSBPROCTABLE, *PGLSRVSBPROCTABLE;

#endif /* !__GLSRVSPT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\glteb.h ===
/******************************Module*Header*******************************\
* Module Name: glteb.h
*
* TEB related structures.
*
* Created: 12/27/1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993-96 Microsoft Corporation
\**************************************************************************/

#ifndef __GLTEB_H__
#define __GLTEB_H__

#include <gldrv.h> // Dispatch table sizes

#include "oleauto.h"
#include "exttable.h"

// OpenGL reserves a few entries in the NT TEB and allocates TLS storage to
// keep thread local states.
//
// In Win95, the NT TEB storage is not available in the TEB and is made
// part of its TLS storage.
//
// For code simplicity, a special NT_CURRENT_TEB macro is used to access
// fields that are defined in NT TEB.  Another macro CURRENT_GLTEBINFO is
// used to access the other fields.  This convention should be followed.

// Shared section size

#define SHARED_SECTION_SIZE     8192

// Number of entries in the extended dispatch table
#define GL_EXT_PROC_TABLE_SIZE      (sizeof(GLEXTDISPATCHTABLE)/sizeof(PROC))

// Offset of entries for extension functions.  This offset must
// be greater than all possible non-extension entries
#define GL_EXT_PROC_TABLE_OFFSET    OPENGL_VERSION_110_ENTRIES

typedef struct _GLTEBINFO {
    // glCltDispatchTable must be the first field for the assembly code to work.
    // We pad the table with an extra entry if necessary to make glMsgBatchInfo
    // start at a qword boundary.
    PVOID glCltDispatchTable[(OPENGL_VERSION_110_ENTRIES+GL_EXT_PROC_TABLE_SIZE+1)/2*2];

    // This field must be qword aligned!
    BYTE glMsgBatchInfo[SHARED_SECTION_SIZE];

#ifdef _WIN95_
    // These fields must match the NT TEB definitions!

    PVOID glDispatchTable[233]; // fast dispatch table
    ULONG glReserved1[29];      // POLYARRAY structure
    PVOID glReserved2;          // pointer to POLYMATERIAL structure
    PVOID glSectionInfo;        // generic server GC
    PVOID glSection;            // Not used
    PVOID glTable;              // Used only for NT x86
    PVOID glCurrentRC;          // generic client RC
    PVOID glContext;            // reserved by OpenGL ICD drivers
#endif // _WIN95_
} GLTEBINFO, *PGLTEBINFO;

extern DWORD dwTlsOffset;

#if !defined(_WIN95_)
#if defined(_WIN64)
#define TeglDispatchTable       0x9f0
#define TeglReserved1           0x1138
#define TeglReserved2           0x1220
#define TeglSectionInfo         0x1228
#define TeglSection             0x1230
#define TeglTable               0x1238
#define TeglCurrentRC           0x1240
#define TeglContext             0x1248
#else
#define TeglDispatchTable       0x7c4
#define TeglReserved1           0xb68
#define TeglPaTeb               0xbb0
#define TeglReserved2           0xbdc
#define TeglSectionInfo         0xbe0
#define TeglSection             0xbe4
#define TeglTable               0xbe8
#define TeglCurrentRC           0xbec
#define TeglContext             0xbf0
#endif
#endif

#if defined(_WIN95_) || !defined(_X86_)

// Use NT_CURRENT_TEB to access the fields defined in NT TEB only!
// Do not use it to access other fields such as glCltDispatchTable and
// glMsgBatchInfo.
// Use CURRENT_GLTEBINFO to access the fields *not* defined in NT TEB only!
// E.g. glCltDispatchTable and glMsgBatchInfo.

#ifdef _WIN95_
#define NT_CURRENT_TEB() \
    (*(PGLTEBINFO *)((PBYTE)NtCurrentTeb()+dwTlsOffset))
#else
#define NT_CURRENT_TEB() \
    (NtCurrentTeb())
#endif

#define CURRENT_GLTEBINFO() \
    (*(PGLTEBINFO *)((PBYTE)NtCurrentTeb()+dwTlsOffset))
#define SET_CURRENT_GLTEBINFO(pglti) \
    (*(PGLTEBINFO *)((PBYTE)NtCurrentTeb()+dwTlsOffset) = (pglti))

// Cached POLYARRAY structure.
#define GLTEB_CLTPOLYARRAY() \
    ((struct _POLYARRAY *)(NT_CURRENT_TEB()->glReserved1))

// Pointer to POLYMATERIAL structure.
#define GLTEB_CLTPOLYMATERIAL() \
    ((POLYMATERIAL *)(NT_CURRENT_TEB()->glReserved2))

#define GLTEB_SET_CLTPOLYMATERIAL(pm) \
    (NT_CURRENT_TEB()->glReserved2 = (PVOID)(pm))

// Table containing OpenGL function pointers for faster dispatch.  Use this
// table where possible.
#define GLTEB_CLTDISPATCHTABLE_FAST()                                   \
    ((PGLDISPATCHTABLE_FAST)(NT_CURRENT_TEB()->glDispatchTable))

// Client side RC structure.
#ifdef _WIN95_
#define GLTEB_CLTCURRENTRC()                                            \
    (NT_CURRENT_TEB() ? (PLRC)NT_CURRENT_TEB()->glCurrentRC : (PLRC)0)
#else
#define GLTEB_CLTCURRENTRC()                                            \
    ((PLRC)NT_CURRENT_TEB()->glCurrentRC)
#endif

#define GLTEB_SET_CLTCURRENTRC(RC)                                      \
    (NT_CURRENT_TEB()->glCurrentRC = (PVOID)(RC))

// Client driver private data.
#define GLTEB_CLTDRIVERSLOT()                                           \
    (NT_CURRENT_TEB()->glContext)

#define GLTEB_SET_CLTDRIVERSLOT(pv)                                     \
    (NT_CURRENT_TEB()->glContext = (pv))

#define GLTEB_SRVCONTEXT()                                              \
    ((struct __GLcontextRec *)(NT_CURRENT_TEB()->glSectionInfo))

#define GLTEB_SET_SRVCONTEXT(Context)                                   \
    (NT_CURRENT_TEB()->glSectionInfo = (PVOID)(Context))

#else // _WIN95_ || !_X86_

#pragma warning(disable:4035) // Function doesn't return a value

#define NT_CURRENT_TEB() \
    (NtCurrentTeb())
__inline PGLTEBINFO CURRENT_GLTEBINFO(void)
{
    __asm mov eax, [dwTlsOffset]
    __asm mov eax, fs:[eax]
}
__inline void SET_CURRENT_GLTEBINFO(PGLTEBINFO pglti)
{
    __asm mov eax, pglti
    __asm mov edx, [dwTlsOffset]
    __asm mov fs:[edx], eax
}

// Cached POLYARRAY structure.
// Returns cached linear pointer into TEB
__inline struct _POLYARRAY *GLTEB_CLTPOLYARRAY(void)
{
    __asm mov eax, fs:[TeglPaTeb]
}

// Pointer to POLYMATERIAL structure.
__inline struct _POLYMATERIAL *GLTEB_CLTPOLYMATERIAL(void)
{
    __asm mov eax, fs:[TeglReserved2]
}
__inline void GLTEB_SET_CLTPOLYMATERIAL(struct _POLYMATERIAL *pm)
{
    __asm mov eax, pm
    __asm mov fs:[TeglReserved2], eax
}

// Table containing OpenGL function pointers for faster dispatch.  Use this
// table where possible.
// Returns cached linear pointer into TEB
__inline struct _GLDISPATCHTABLE_FAST *GLTEB_CLTDISPATCHTABLE_FAST(void)
{
    __asm mov eax, fs:[TeglTable]
}

// Client side RC structure.
__inline struct _LRC *GLTEB_CLTCURRENTRC(void)
{
    __asm mov eax, fs:[TeglCurrentRC]
}
__inline void GLTEB_SET_CLTCURRENTRC(struct _LRC *RC)
{
    __asm mov eax, RC
    __asm mov fs:[TeglCurrentRC], eax
}

// Client driver private data.
__inline PVOID GLTEB_CLTDRIVERSLOT(void)
{
    __asm mov eax, fs:[TeglContext]
}
__inline void GLTEB_SET_CLTDRIVERSLOT(PVOID pv)
{
    __asm mov eax, pv
    __asm mov fs:[TeglContext], eax
}

__inline struct __GLcontextRec *GLTEB_SRVCONTEXT(void)
{
    __asm mov eax, fs:[TeglSectionInfo]
}
__inline void GLTEB_SET_SRVCONTEXT(struct __GLcontextRec *Context)
{
    __asm mov eax, Context
    __asm mov fs:[TeglSectionInfo], eax
}

#pragma warning(default:4035) // Reset to default

#endif // _WIN95_ || !_X86_

// Table containing all OpenGL API function pointers.
#define GLTEB_CLTDISPATCHTABLE()                                        \
    ((PGLDISPATCHTABLE)(CURRENT_GLTEBINFO()->glCltDispatchTable))

// Table containing all generic implementation's extension function pointers.
#define GLTEB_EXTDISPATCHTABLE()                                        \
    ((PGLEXTDISPATCHTABLE)(CURRENT_GLTEBINFO()->glCltDispatchTable+GL_EXT_PROC_TABLE_OFFSET))

// Command buffer for batching.
#define GLTEB_SHAREDMEMORYSECTION()                                     \
    ((GLMSGBATCHINFO *) (CURRENT_GLTEBINFO()->glMsgBatchInfo))

// OpenGL function return value subbatch storage

#define GLTEB_RETURNVALUE()                                             \
    GLTEB_SHAREDMEMORYSECTION()->ReturnValue

// Initialize both glCltDispatchTable and glDispatchTable with the new
// function pointers.
// glCltDispatchTable contains all OpenGL API function pointers followed
// by the generic implementation's extension function pointers.
// glDispatchTable contains a subset of OpenGL function pointers for "fast"
// dispatch.
extern void vInitTebCache(PVOID);
extern void SetCltProcTable(struct _GLCLTPROCTABLE *pgcpt,
                            struct _GLEXTPROCTABLE *pgept,
                            BOOL fForce);
extern void GetCltProcTable(struct _GLCLTPROCTABLE *pgcpt,
                            struct _GLEXTPROCTABLE *pgept,
                            BOOL fForce);

#endif /* __GLTEB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\parray.h ===
#ifndef __PARRAY_H__
#define __PARRAY_H__

#include "phong.h"

// Number of polydata entries in the context.  Must be at least 32.
// It includes room for the polyarray entry and others.
// It's currently based on POLYDATA_BUFFER_SIZE+1 vertices of size 128
// fitting in 64K, which yields 511
#define POLYDATA_BUFFER_SIZE     511
// DrawElements expects at least this many vertices in the vertex buffer.
// It is the sum of the following (currently sum is 278):
//    Number of vertex entries in a batch
//    Number of entries used for index map
//    An extra vertex entry to prevent calling PolyArrayFlushPartialPrimitive
//        in the Vertex routines.
//    An entry for POLYARRAY
//    4 spare entries to be safe
// It is given by
//    VA_DRAWELEM_MAP_SIZE +
//    (VA_DRAWELEM_INDEX_SIZE + sizeof(POLYDATA) - 1) / sizeof(POLYDATA) +
//    1 + 1 + 4
#define MINIMUM_POLYDATA_BUFFER_SIZE    300

// Minimun number of polydata entries required before processing a primitive.
// Must be at least 16.
#define MIN_POLYDATA_BATCH_SIZE  68

#if !((MIN_POLYDATA_BATCH_SIZE <= MINIMUM_POLYDATA_BUFFER_SIZE) && \
      (MINIMUM_POLYDATA_BUFFER_SIZE <= POLYDATA_BUFFER_SIZE)       \
     )
#error "bad sizes\n"
#endif

// Maximun number of vertices handled by the polygon decomposer.
// It allocates stack space based on this constant.  It must be at least 6.
#define __GL_MAX_POLYGON_CLIP_SIZE   256

// The POLYMATERIAL structure contains an index to the next available
// __GLmatChange structure, an array of pointers to __GLmatChange arrays,
// and a pointer to an array of PDMATERIAL structures each containing
// pointers to the front and back material changes for each POLYDATA
// elements in vertex buffer.
//
// The __GLmatChange structures are used to record material changes to
// vertices in the vertex buffer.  Since there can be up to two material
// changes per vertex, we need up to (POLYDATA_BUFFER_SIZE * 2) material
// changes per rendering thread.
//
// The PDMATERIAL array is part of the POLYMATERIAL structure and follows
// the aMat field immediately.  Its elements correspond to the POLYDATA
// elements in the vertex buffer.
//
// To reduce memory requirement, the POLYMATERIAL structure keeps an array
// of pointers to __GLmatChange arrays.  Each __GLmatChange array of up to
// 4K size is allocated as needed.
//
// An iMat index is used to keep track of the next free __GLmatChange
// entry.  When the poly array buffer is flushed in glsbAttention, iMat
// is reset to 0.
//
// The POLYMATERIAL structure and its __GLmatChange arrays are part of
// a thread local storage and are freed when the thread exits.

#define POLYMATERIAL_ARRAY_SIZE       (4096 / sizeof(__GLmatChange))

// This structure is shared with MCD as MCDMATERIALCHANGE.
typedef struct __GLmatChangeRec {
    GLuint dirtyBits;
    __GLcolor ambient;
    __GLcolor diffuse;
    __GLcolor specular;
    __GLcolor emissive;
    __GLfloat shininess;
    __GLfloat cmapa, cmapd, cmaps;
} __GLmatChange;

// Pointers to front and back material change structures.  They are
// valid only when the POLYDATA_MATERIAL_FRONT or POLYDATA_MATERIAL_BACK
// flag of the corresponding POLYDATA in the vertex buffer is set.
//
// This structure is shared with MCD as MCDMATERIALCHANGES.
typedef struct {
    __GLmatChange *front;	// pointer to the front material changes
    __GLmatChange *back;	// pointer to the back material changes
} PDMATERIAL;

typedef struct _POLYMATERIAL {
    GLuint iMat;  // next available material structure for this command batch
    PDMATERIAL *pdMaterial0;	// pointer to the PDMATERIAL array
    GLuint aMatSize;		// number of aMat entries
    __GLmatChange *aMat[1];	// array of array of __GLmatChange structures
} POLYMATERIAL;

#ifdef GL_WIN_phong_shading

#define __GL_PHONG_FRONT_FIRST_VALID    0x00000001
#define __GL_PHONG_BACK_FIRST_VALID     0x00000002
#define __GL_PHONG_FRONT_TRAIL_VALID    0x00000004
#define __GL_PHONG_BACK_TRAIL_VALID     0x00000008


#define __GL_PHONG_FRONT_FIRST  0
#define __GL_PHONG_BACK_FIRST   1
#define __GL_PHONG_FRONT_TRAIL  2
#define __GL_PHONG_BACK_TRAIL   3


typedef struct __GLphongMaterialDataRec
{
    GLuint flags;
  __GLmatChange matChange[4];
} __GLphongMaterialData;

#endif //GL_WIN_phong_shading

/*
** Vertex structure.  Each vertex contains enough state to properly
** render the active primitive.  It is used by the front-end geometry
** and back-end rasterization pipelines.
**
** NOTE: Same as __GLvertex structure!
** NOTE: This structure is used by RasterPos and evaluator too!
**
** To minimize storage requirement, some front-end storage (e.g. obj and normal)
** is shared with back-end storage.
*/
typedef struct _POLYDATA {
    /*
    ** Keep this data structure aligned: have all vectors start on
    ** 4-word boundary, and sizeof this struct should be kept at
    ** a multiple of 4 words. Also helps to bunch together most
    ** frequently used items, helps cache.
    */

    /*
    ** Bits are set in this indicating which fields of the vertex are
    ** valid.  This field is shared with the back-end has field!
    */
    GLuint flags;

    /*
    ** Moved up here to keep GLcoords aligned.
    */
    __GLcolor *color;

    /*
    ** Clipping code mask.  One bit is set for each clipping plane that
    ** the vertex is out on.
    */
    GLuint clipCode;

    /*
    ** Fog value for the vertex.  This is only filled when doing cheap
    ** fogging.
    */
    __GLfloat fog;

    /*
    ** Coordinates straight from client. These fields may not be
    ** set depending on the active modes.  The normal and texture
    ** coordinate are used by lighting and texturing.  These cells
    ** may be overwritten by the eyeNormal and the generated texture
    ** coordinate, depending on the active modes.
    */
    /*
    ** Projected eye coodinate.  This field is filled in when the users
    ** eye coordinate has been multiplied by the projection matrix.
    */
    union
    {
        __GLcoord obj;
        __GLcoord clip;
    };

    /*
    ** Window coordinate. This field is filled in when the eye coordinate
    ** is converted to a drawing surface relative "window" coordinate.
    ** NOTE: the window.w coordinate contains 1/clip.w.
    */
    __GLcoord window;

    __GLcoord texture;
    __GLcoord normal;
    /*
    ** Colors.  colors[0] is the "front" color, colors[1] is the "back" color.
    ** The color pointer points to which color is current for this
    ** vertex.  Verticies can have more than one color when two sided
    ** lighting is enabled. (note color pointer moved up top).
    */
    __GLcolor colors[2];

    /*
    ** Eye coordinate. This field is filled in when the object coordinate
    ** has been multiplied by the model-view matrix.  If no eye coordinate
    ** was needed then this field contains undefined values.
    */
    union {
        __GLcoord eye;
        struct {
            __GLfloat eyeX;
            __GLfloat eyeZ;
            __GLfloat eyeY;
            union {
                __GLfloat eyeW;
                __GLcolor *lastColor;
            };
        };
    };

    /*
    ** On Win64 the POLYARRAY structure is larger than the POLYDATA
    ** structure since the later contains several pointers which are
    ** 8 bytes on the 64-bit system. Therefore, this structure must
    ** be padded to be the same size as the POLYARRAY structure.
    **
    ** N.B. Since the structure must be the same size as the __GLvertex
    **      structure, then that structure must also be padded.
    **
    */

#if defined(_WIN64)

    PVOID Filler[7];

#endif

} POLYDATA;

// This structure is used by RasterPos and evaluator too!
// This structure is also in the TEB!
typedef struct _POLYARRAY {
    // Flags for this batch.  Keep it first!
    GLuint flags;

    // Pointer to the next vertex in this batch.
    POLYDATA *pdNextVertex;

    // Pointer to the last vertex modifying the current color, RGBA or CI
    // depending on color mode, in this batch.
    POLYDATA *pdCurColor;

    // Pointer to the last vertex modifying normal coordinates in this batch.
    POLYDATA *pdCurNormal;

    // Pointer to the last vertex modifying texture coordinates in this batch.
    POLYDATA *pdCurTexture;

    // Pointer to the last vertex modifying edge flag in this batch.
    POLYDATA *pdCurEdgeFlag;

    // Pointer to the first vertex of this batch.
    // (pd0-1) points to this batch's POLYARRAY structure.
    POLYDATA *pd0;

    // Pointer to the flush vertex of this batch.
    POLYDATA *pdFlush;

    // Pointer to the vertex buffer entry in the gc for the next batch.
    POLYDATA *pdBufferNext;

    // Pointer to the first vertex buffer entry in the gc.
    POLYDATA *pdBuffer0;

    // Pointer to the last vertex buffer entry in the gc.
    POLYDATA *pdBufferMax;

    // In RGBA mode, otherColor.r is the last modified color index value in
    // this batch.  In CI mode, otherColor is the last modified RGBA color in
    // this batch.  Keep this field aligned!
    __GLcolor    otherColor;

    // Primitive type.
    GLenum primType;

    // Or result of all vertex clipCode's in this batch.
    GLuint  orClipCodes;

    // Pointer to the next message offset in the batching command buffer.
    // We use this offset to determine if 2 POLYARRAY's can be linked in
    // a DrawPolyArray command.
    ULONG        nextMsgOffset;

    // Linear pointer to this thread's TEB POLYARRAY, kept here
    // so the current POLYARRAY pointer can be retrieved from the
    // TEB with a single instruction
    struct _POLYARRAY *paTeb;

    // This is used to form a linked list of POLYARRAY data to be
    // processed in the DrawPolyArray command.
    struct _POLYARRAY *paNext;

    // Number of vertices in this primitive.
    GLint   nIndices;

    // Index map array defining vertex drawing order.  If NULL, the
    // vertex order starts from pd0 through (pdNextVertex-1).
    GLubyte *aIndices;

    // Fast pointer access to the shared command message buffer.
    PVOID   pMsgBatchInfo;

    // MCD Driver-private texture handle, or key
    DWORD textureKey;

    // And result of all vertex clipCode's in this batch.
    GLuint  andClipCodes;

    // Currently unused but space is reserved in the TEB for it
#ifdef GL_WIN_phong_shading
    // anankan: Using it to store a ptr to the Phong data store.
    __GLphongMaterialData *phong;
#else
    ULONG ulUnused[1];
#endif //GL_WIN_phong_shading
    POLYDATA *pdLastEvalColor;
    POLYDATA *pdLastEvalNormal;
    POLYDATA *pdLastEvalTexture;
} POLYARRAY;


// Special values for POLYARRAY members

// Initial value for aIndices
#define PA_aIndices_INITIAL_VALUE       ((GLubyte *) -1)
// Reset value for nextMsgOffset
#define PA_nextMsgOffset_RESET_VALUE    ((ULONG) -1)

/*
** Edge tag.  When POLYDATA_EDGEFLAG_BOUNDARY is set, this vertex and the next
** form a boundary edge on the primitive (polygon, tstrip, tfan, qstrip).
*/
#define POLYDATA_EDGEFLAG_BOUNDARY    	0x00000001 // must be 1, same as
						   // __GL_HAS_EDGEFLAG_BOUNDARY
#define POLYDATA_EDGEFLAG_VALID       	0x00000002
#define POLYDATA_COLOR_VALID        	0x00000004
#define POLYDATA_NORMAL_VALID       	0x00000008
#define POLYDATA_TEXTURE_VALID       	0x00000010
#define POLYDATA_VERTEX2           	0x00000020 // same as POLYARRAY_
#define POLYDATA_VERTEX3           	0x00000040 // same as POLYARRAY_
#define POLYDATA_VERTEX4           	0x00000080 // same as POLYARRAY_

/* flags for evaluators */
#define POLYDATA_EVALCOORD          	0x00000100 // same as POLYARRAY_
#define POLYDATA_EVAL_TEXCOORD         	0x00000200 // same as POLYARRAY_
#define POLYDATA_EVAL_NORMAL          	0x00000400 // same as POLYARRAY_
#define POLYDATA_EVAL_COLOR          	0x00000800 // same as POLYARRAY_

#define POLYDATA_DLIST_COLOR_4	    	0x00002000 // client side dlist flag
#define POLYDATA_FOG_VALID	        0x00004000 // same as __GL_HAS_FOG
                                    //  0x00008000 // reserved
#define POLYDATA_DLIST_TEXTURE1       	0x00100000 // client side dlist flag
#define POLYDATA_DLIST_TEXTURE2       	0x00200000 // client side dlist flag
#define POLYDATA_DLIST_TEXTURE3       	0x00400000 // client side dlist flag
#define POLYDATA_DLIST_TEXTURE4       	0x00800000 // client side dlist flag
#define POLYDATA_MATERIAL_FRONT    		0x10000000 // same as POLYARRAY_
#define POLYDATA_MATERIAL_BACK    		0x20000000 // same as POLYARRAY_
//
// This flag is valid when POLYARRAY_HAS_CULLED_VERTEX is set only.
// We have to process vertex when this flag set
//
#ifdef GL_EXT_cull_vertex
#define POLYDATA_VERTEX_USED            0x01000000
#endif //GL_EXT_cull_vertex

#define POLYARRAY_IN_BEGIN          	0x00000001
#define POLYARRAY_EYE_PROCESSED     	0x00000002
#define POLYARRAY_OTHER_COLOR          	0x00000004
#define POLYARRAY_PARTIAL_BEGIN        	0x00000008
#define POLYARRAY_PARTIAL_END          	0x00000010
#define POLYARRAY_VERTEX2           	0x00000020 // same as POLYDATA_
#define POLYARRAY_VERTEX3           	0x00000040 // same as POLYDATA_
#define POLYARRAY_VERTEX4           	0x00000080 // same as POLYDATA_

/* Recycling these flags for evaluators */
#define POLYARRAY_EVALCOORD 	   	    0x00000100 // same as POLYDATA_
#define POLYARRAY_EVAL_TEXCOORD	   	    0x00000200 // same as POLYDATA_
#define POLYARRAY_EVAL_NORMAL          	0x00000400 // same as POLYDATA_
#define POLYARRAY_EVAL_COLOR          	0x00000800 // same as POLYDATA_
#define POLYARRAY_REMOVE_PRIMITIVE  	0x00001000

//
// This flag is set when one of vertices has been culled by dot product
// between normal at the vertex and eye direction
//
#ifdef GL_EXT_cull_vertex
#define POLYARRAY_HAS_CULLED_VERTEX     0x02000000
#endif //GL_EXT_cull_vertex

#ifdef GL_WIN_phong_shading
#define POLYARRAY_PHONG_DATA_VALID      0x00002000
#endif //GL_WIN_phong_shading

#define POLYARRAY_RESET_STIPPLE	    	0x00004000
#define POLYARRAY_RENDER_PRIMITIVE  	0x00008000
#define POLYARRAY_SAME_POLYDATA_TYPE 	0x00010000
#define POLYARRAY_RASTERPOS          	0x00020000
#define POLYARRAY_SAME_COLOR_DATA	0x00040000
#define POLYARRAY_TEXTURE1          	0x00100000 // same as POLYDATA_DLIST_
#define POLYARRAY_TEXTURE2          	0x00200000 // same as POLYDATA_DLIST_
#define POLYARRAY_TEXTURE3          	0x00400000 // same as POLYDATA_DLIST_
#define POLYARRAY_TEXTURE4          	0x00800000 // same as POLYDATA_DLIST_
#define POLYARRAY_MATERIAL_FRONT    	0x10000000 // same as POLYDATA_
#define POLYARRAY_MATERIAL_BACK			0x20000000 // same as POLYDATA_
#define POLYARRAY_CLAMP_COLOR        	0x80000000 // must be 0x80000000

/************************************************************************/

GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
                                     POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckAll(__GLcontext *gc, POLYARRAY *pa,
                               POLYDATA *pdLast);

typedef void (FASTCALL *PFN_POLYARRAYCALCCOLORSKIP)
    (__GLcontext *, POLYARRAY *, GLint);
typedef void (FASTCALL *PFN_POLYARRAYCALCCOLOR)
    (__GLcontext *, GLint, POLYARRAY *, POLYDATA *, POLYDATA *);
typedef void (FASTCALL *PFN_POLYARRAYAPPLYCHEAPFOG)
    (__GLcontext *gc, POLYARRAY *pa);

void FASTCALL PolyArrayFillIndex0(__GLcontext *gc, POLYARRAY *pa, GLint face);
void FASTCALL PolyArrayFillColor0(__GLcontext *gc, POLYARRAY *pa, GLint face);

#ifdef GL_WIN_phong_shading
void FASTCALL PolyArrayPhongPropagateColorNormal(__GLcontext *gc,
                                                 POLYARRAY *pa);
#endif //GL_WIN_phong_shading

void FASTCALL PolyArrayCalcRGBColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayFastCalcRGBColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayCalcCIColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayFastCalcCIColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayCheapFogRGBColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCheapFogCIColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayFlushPartialPrimitive(void);
__GLmatChange * FASTCALL PAMatAlloc(void);
void FASTCALL FreePolyMaterial(void);
GLboolean FASTCALL PolyArrayAllocBuffer(__GLcontext *gc, GLuint nVertices);
GLvoid    FASTCALL PolyArrayFreeBuffer(__GLcontext *gc);
GLvoid    FASTCALL PolyArrayResetBuffer(__GLcontext *gc);
GLvoid    FASTCALL PolyArrayRestoreColorPointer(POLYARRAY *pa);

#endif /* __PARRAY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\lcfuncs.h ===
#ifndef __lcfuncs_h__
#define __lcfuncs_h__

/* Client Side Prototypes */

/* gl Entry points */

void      APIENTRY __gllc_NewList                ( IN GLuint list, IN GLenum mode );
void      APIENTRY __gllc_EndList                ( void );
void      APIENTRY __gllc_CallList               ( IN GLuint list );
void      APIENTRY __gllc_CallLists              ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists );
void      APIENTRY __gllc_DeleteLists            ( IN GLuint list, IN GLsizei range );
GLuint    APIENTRY __gllc_GenLists               ( IN GLsizei range );
void      APIENTRY __gllc_ListBase               ( IN GLuint base );
void      APIENTRY __gllc_Begin                  ( IN GLenum mode );
void      APIENTRY __gllc_Bitmap                 ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] );
void      APIENTRY __gllc_Color3b                ( IN GLbyte red, IN GLbyte green, IN GLbyte blue );
void      APIENTRY __gllc_Color3bv               ( IN const GLbyte v[3] );
void      APIENTRY __gllc_Color3d                ( IN GLdouble red, IN GLdouble green, IN GLdouble blue );
void      APIENTRY __gllc_Color3dv               ( IN const GLdouble v[3] );
void      APIENTRY __gllc_Color3f                ( IN GLfloat red, IN GLfloat green, IN GLfloat blue );
void      APIENTRY __gllc_Color3fv               ( IN const GLfloat v[3] );
void      APIENTRY __gllc_Color3i                ( IN GLint red, IN GLint green, IN GLint blue );
void      APIENTRY __gllc_Color3iv               ( IN const GLint v[3] );
void      APIENTRY __gllc_Color3s                ( IN GLshort red, IN GLshort green, IN GLshort blue );
void      APIENTRY __gllc_Color3sv               ( IN const GLshort v[3] );
void      APIENTRY __gllc_Color3ub               ( IN GLubyte red, IN GLubyte green, IN GLubyte blue );
void      APIENTRY __gllc_Color3ubv              ( IN const GLubyte v[3] );
void      APIENTRY __gllc_Color3ui               ( IN GLuint red, IN GLuint green, IN GLuint blue );
void      APIENTRY __gllc_Color3uiv              ( IN const GLuint v[3] );
void      APIENTRY __gllc_Color3us               ( IN GLushort red, IN GLushort green, IN GLushort blue );
void      APIENTRY __gllc_Color3usv              ( IN const GLushort v[3] );
void      APIENTRY __gllc_Color4b                ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha );
void      APIENTRY __gllc_Color4bv               ( IN const GLbyte v[4] );
void      APIENTRY __gllc_Color4d                ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha );
void      APIENTRY __gllc_Color4dv               ( IN const GLdouble v[4] );
void      APIENTRY __gllc_Color4f                ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY __gllc_Color4fv               ( IN const GLfloat v[4] );
void      APIENTRY __gllc_Color4i                ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha );
void      APIENTRY __gllc_Color4iv               ( IN const GLint v[4] );
void      APIENTRY __gllc_Color4s                ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha );
void      APIENTRY __gllc_Color4sv               ( IN const GLshort v[4] );
void      APIENTRY __gllc_Color4ub               ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha );
void      APIENTRY __gllc_Color4ubv              ( IN const GLubyte v[4] );
void      APIENTRY __gllc_Color4ui               ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha );
void      APIENTRY __gllc_Color4uiv              ( IN const GLuint v[4] );
void      APIENTRY __gllc_Color4us               ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha );
void      APIENTRY __gllc_Color4usv              ( IN const GLushort v[4] );
void      APIENTRY __gllc_EdgeFlag               ( IN GLboolean flag );
void      APIENTRY __gllc_EdgeFlagv              ( IN const GLboolean flag[1] );
void      APIENTRY __gllc_End                    ( void );
void      APIENTRY __gllc_Indexd                 ( IN GLdouble c );
void      APIENTRY __gllc_Indexdv                ( IN const GLdouble c[1] );
void      APIENTRY __gllc_Indexf                 ( IN GLfloat c );
void      APIENTRY __gllc_Indexfv                ( IN const GLfloat c[1] );
void      APIENTRY __gllc_Indexi                 ( IN GLint c );
void      APIENTRY __gllc_Indexiv                ( IN const GLint c[1] );
void      APIENTRY __gllc_Indexs                 ( IN GLshort c );
void      APIENTRY __gllc_Indexsv                ( IN const GLshort c[1] );
void      APIENTRY __gllc_Normal3b               ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz );
void      APIENTRY __gllc_Normal3bv              ( IN const GLbyte v[3] );
void      APIENTRY __gllc_Normal3d               ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz );
void      APIENTRY __gllc_Normal3dv              ( IN const GLdouble v[3] );
void      APIENTRY __gllc_Normal3f               ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz );
void      APIENTRY __gllc_Normal3fv              ( IN const GLfloat v[3] );
void      APIENTRY __gllc_Normal3i               ( IN GLint nx, IN GLint ny, IN GLint nz );
void      APIENTRY __gllc_Normal3iv              ( IN const GLint v[3] );
void      APIENTRY __gllc_Normal3s               ( IN GLshort nx, IN GLshort ny, IN GLshort nz );
void      APIENTRY __gllc_Normal3sv              ( IN const GLshort v[3] );
void      APIENTRY __gllc_RasterPos2d            ( IN GLdouble x, IN GLdouble y );
void      APIENTRY __gllc_RasterPos2dv           ( IN const GLdouble v[2] );
void      APIENTRY __gllc_RasterPos2f            ( IN GLfloat x, IN GLfloat y );
void      APIENTRY __gllc_RasterPos2fv           ( IN const GLfloat v[2] );
void      APIENTRY __gllc_RasterPos2i            ( IN GLint x, IN GLint y );
void      APIENTRY __gllc_RasterPos2iv           ( IN const GLint v[2] );
void      APIENTRY __gllc_RasterPos2s            ( IN GLshort x, IN GLshort y );
void      APIENTRY __gllc_RasterPos2sv           ( IN const GLshort v[2] );
void      APIENTRY __gllc_RasterPos3d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_RasterPos3dv           ( IN const GLdouble v[3] );
void      APIENTRY __gllc_RasterPos3f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_RasterPos3fv           ( IN const GLfloat v[3] );
void      APIENTRY __gllc_RasterPos3i            ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY __gllc_RasterPos3iv           ( IN const GLint v[3] );
void      APIENTRY __gllc_RasterPos3s            ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY __gllc_RasterPos3sv           ( IN const GLshort v[3] );
void      APIENTRY __gllc_RasterPos4d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY __gllc_RasterPos4dv           ( IN const GLdouble v[4] );
void      APIENTRY __gllc_RasterPos4f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY __gllc_RasterPos4fv           ( IN const GLfloat v[4] );
void      APIENTRY __gllc_RasterPos4i            ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY __gllc_RasterPos4iv           ( IN const GLint v[4] );
void      APIENTRY __gllc_RasterPos4s            ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY __gllc_RasterPos4sv           ( IN const GLshort v[4] );
void      APIENTRY __gllc_Rectd                  ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 );
void      APIENTRY __gllc_Rectdv                 ( IN const GLdouble v1[2], IN const GLdouble v2[2] );
void      APIENTRY __gllc_Rectf                  ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 );
void      APIENTRY __gllc_Rectfv                 ( IN const GLfloat v1[2], IN const GLfloat v2[2] );
void      APIENTRY __gllc_Recti                  ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 );
void      APIENTRY __gllc_Rectiv                 ( IN const GLint v1[2], IN const GLint v2[2] );
void      APIENTRY __gllc_Rects                  ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 );
void      APIENTRY __gllc_Rectsv                 ( IN const GLshort v1[2], IN const GLshort v2[2] );
void      APIENTRY __gllc_TexCoord1d             ( IN GLdouble s );
void      APIENTRY __gllc_TexCoord1dv            ( IN const GLdouble v[1] );
void      APIENTRY __gllc_TexCoord1f             ( IN GLfloat s );
void      APIENTRY __gllc_TexCoord1fv            ( IN const GLfloat v[1] );
void      APIENTRY __gllc_TexCoord1i             ( IN GLint s );
void      APIENTRY __gllc_TexCoord1iv            ( IN const GLint v[1] );
void      APIENTRY __gllc_TexCoord1s             ( IN GLshort s );
void      APIENTRY __gllc_TexCoord1sv            ( IN const GLshort v[1] );
void      APIENTRY __gllc_TexCoord2d             ( IN GLdouble s, IN GLdouble t );
void      APIENTRY __gllc_TexCoord2dv            ( IN const GLdouble v[2] );
void      APIENTRY __gllc_TexCoord2f             ( IN GLfloat s, IN GLfloat t );
void      APIENTRY __gllc_TexCoord2fv            ( IN const GLfloat v[2] );
void      APIENTRY __gllc_TexCoord2i             ( IN GLint s, IN GLint t );
void      APIENTRY __gllc_TexCoord2iv            ( IN const GLint v[2] );
void      APIENTRY __gllc_TexCoord2s             ( IN GLshort s, IN GLshort t );
void      APIENTRY __gllc_TexCoord2sv            ( IN const GLshort v[2] );
void      APIENTRY __gllc_TexCoord3d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r );
void      APIENTRY __gllc_TexCoord3dv            ( IN const GLdouble v[3] );
void      APIENTRY __gllc_TexCoord3f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r );
void      APIENTRY __gllc_TexCoord3fv            ( IN const GLfloat v[3] );
void      APIENTRY __gllc_TexCoord3i             ( IN GLint s, IN GLint t, IN GLint r );
void      APIENTRY __gllc_TexCoord3iv            ( IN const GLint v[3] );
void      APIENTRY __gllc_TexCoord3s             ( IN GLshort s, IN GLshort t, IN GLshort r );
void      APIENTRY __gllc_TexCoord3sv            ( IN const GLshort v[3] );
void      APIENTRY __gllc_TexCoord4d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q );
void      APIENTRY __gllc_TexCoord4dv            ( IN const GLdouble v[4] );
void      APIENTRY __gllc_TexCoord4f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q );
void      APIENTRY __gllc_TexCoord4fv            ( IN const GLfloat v[4] );
void      APIENTRY __gllc_TexCoord4i             ( IN GLint s, IN GLint t, IN GLint r, IN GLint q );
void      APIENTRY __gllc_TexCoord4iv            ( IN const GLint v[4] );
void      APIENTRY __gllc_TexCoord4s             ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q );
void      APIENTRY __gllc_TexCoord4sv            ( IN const GLshort v[4] );
void      APIENTRY __gllc_Vertex2d               ( IN GLdouble x, IN GLdouble y );
void      APIENTRY __gllc_Vertex2dv              ( IN const GLdouble v[2] );
void      APIENTRY __gllc_Vertex2f               ( IN GLfloat x, IN GLfloat y );
void      APIENTRY __gllc_Vertex2fv              ( IN const GLfloat v[2] );
void      APIENTRY __gllc_Vertex2i               ( IN GLint x, IN GLint y );
void      APIENTRY __gllc_Vertex2iv              ( IN const GLint v[2] );
void      APIENTRY __gllc_Vertex2s               ( IN GLshort x, IN GLshort y );
void      APIENTRY __gllc_Vertex2sv              ( IN const GLshort v[2] );
void      APIENTRY __gllc_Vertex3d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Vertex3dv              ( IN const GLdouble v[3] );
void      APIENTRY __gllc_Vertex3f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Vertex3fv              ( IN const GLfloat v[3] );
void      APIENTRY __gllc_Vertex3i               ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY __gllc_Vertex3iv              ( IN const GLint v[3] );
void      APIENTRY __gllc_Vertex3s               ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY __gllc_Vertex3sv              ( IN const GLshort v[3] );
void      APIENTRY __gllc_Vertex4d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY __gllc_Vertex4dv              ( IN const GLdouble v[4] );
void      APIENTRY __gllc_Vertex4f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY __gllc_Vertex4fv              ( IN const GLfloat v[4] );
void      APIENTRY __gllc_Vertex4i               ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY __gllc_Vertex4iv              ( IN const GLint v[4] );
void      APIENTRY __gllc_Vertex4s               ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY __gllc_Vertex4sv              ( IN const GLshort v[4] );
void      APIENTRY __gllc_ClipPlane              ( IN GLenum plane, IN const GLdouble equation[4] );
void      APIENTRY __gllc_ColorMaterial          ( IN GLenum face, IN GLenum mode );
void      APIENTRY __gllc_CullFace               ( IN GLenum mode );
void      APIENTRY __gllc_Fogf                   ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_Fogfv                  ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_Fogi                   ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_Fogiv                  ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_FrontFace              ( IN GLenum mode );
void      APIENTRY __gllc_Hint                   ( IN GLenum target, IN GLenum mode );
void      APIENTRY __gllc_Lightf                 ( IN GLenum light, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_Lightfv                ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_Lighti                 ( IN GLenum light, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_Lightiv                ( IN GLenum light, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_LightModelf            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_LightModelfv           ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_LightModeli            ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_LightModeliv           ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_LineStipple            ( IN GLint factor, IN GLushort pattern );
void      APIENTRY __gllc_LineWidth              ( IN GLfloat width );
void      APIENTRY __gllc_Materialf              ( IN GLenum face, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_Materialfv             ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_Materiali              ( IN GLenum face, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_Materialiv             ( IN GLenum face, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_PointSize              ( IN GLfloat size );
void      APIENTRY __gllc_PolygonMode            ( IN GLenum face, IN GLenum mode );
void      APIENTRY __gllc_PolygonStipple         ( IN const GLubyte mask[] );
void      APIENTRY __gllc_Scissor                ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY __gllc_ShadeModel             ( IN GLenum mode );
void      APIENTRY __gllc_TexParameterf          ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_TexParameterfv         ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_TexParameteri          ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_TexParameteriv         ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_TexImage1D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY __gllc_TexImage2D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY __gllc_TexEnvf                ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_TexEnvfv               ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_TexEnvi                ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_TexEnviv               ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_TexGend                ( IN GLenum coord, IN GLenum pname, IN GLdouble param );
void      APIENTRY __gllc_TexGendv               ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] );
void      APIENTRY __gllc_TexGenf                ( IN GLenum coord, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_TexGenfv               ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_TexGeni                ( IN GLenum coord, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_TexGeniv               ( IN GLenum coord, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_FeedbackBuffer         ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] );
void      APIENTRY __gllc_SelectBuffer           ( IN GLsizei size, OUT GLuint buffer[] );
GLint     APIENTRY __gllc_RenderMode             ( IN GLenum mode );
void      APIENTRY __gllc_InitNames              ( void );
void      APIENTRY __gllc_LoadName               ( IN GLuint name );
void      APIENTRY __gllc_PassThrough            ( IN GLfloat token );
void      APIENTRY __gllc_PopName                ( void );
void      APIENTRY __gllc_PushName               ( IN GLuint name );
void      APIENTRY __gllc_DrawBuffer             ( IN GLenum mode );
void      APIENTRY __gllc_Clear                  ( IN GLbitfield mask );
void      APIENTRY __gllc_ClearAccum             ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY __gllc_ClearIndex             ( IN GLfloat c );
void      APIENTRY __gllc_ClearColor             ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha );
void      APIENTRY __gllc_ClearStencil           ( IN GLint s );
void      APIENTRY __gllc_ClearDepth             ( IN GLclampd depth );
void      APIENTRY __gllc_StencilMask            ( IN GLuint mask );
void      APIENTRY __gllc_ColorMask              ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha );
void      APIENTRY __gllc_DepthMask              ( IN GLboolean flag );
void      APIENTRY __gllc_IndexMask              ( IN GLuint mask );
void      APIENTRY __gllc_Accum                  ( IN GLenum op, IN GLfloat value );
void      APIENTRY __gllc_Disable                ( IN GLenum cap );
void      APIENTRY __gllc_Enable                 ( IN GLenum cap );
void      APIENTRY __gllc_Finish                 ( void );
void      APIENTRY __gllc_Flush                  ( void );
void      APIENTRY __gllc_PopAttrib              ( void );
void      APIENTRY __gllc_PushAttrib             ( IN GLbitfield mask );
void      APIENTRY __gllc_Map1d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] );
void      APIENTRY __gllc_Map1f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] );
void      APIENTRY __gllc_Map2d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] );
void      APIENTRY __gllc_Map2f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] );
void      APIENTRY __gllc_MapGrid1d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2 );
void      APIENTRY __gllc_MapGrid1f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2 );
void      APIENTRY __gllc_MapGrid2d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 );
void      APIENTRY __gllc_MapGrid2f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 );
void      APIENTRY __gllc_EvalCoord1d            ( IN GLdouble u );
void      APIENTRY __gllc_EvalCoord1dv           ( IN const GLdouble u[1] );
void      APIENTRY __gllc_EvalCoord1f            ( IN GLfloat u );
void      APIENTRY __gllc_EvalCoord1fv           ( IN const GLfloat u[1] );
void      APIENTRY __gllc_EvalCoord2d            ( IN GLdouble u, IN GLdouble v );
void      APIENTRY __gllc_EvalCoord2dv           ( IN const GLdouble u[2] );
void      APIENTRY __gllc_EvalCoord2f            ( IN GLfloat u, IN GLfloat v );
void      APIENTRY __gllc_EvalCoord2fv           ( IN const GLfloat u[2] );
void      APIENTRY __gllc_EvalMesh1              ( IN GLenum mode, IN GLint i1, IN GLint i2 );
void      APIENTRY __gllc_EvalPoint1             ( IN GLint i );
void      APIENTRY __gllc_EvalMesh2              ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 );
void      APIENTRY __gllc_EvalPoint2             ( IN GLint i, IN GLint j );
void      APIENTRY __gllc_AlphaFunc              ( IN GLenum func, IN GLclampf ref );
void      APIENTRY __gllc_BlendFunc              ( IN GLenum sfactor, IN GLenum dfactor );
void      APIENTRY __gllc_LogicOp                ( IN GLenum opcode );
void      APIENTRY __gllc_StencilFunc            ( IN GLenum func, IN GLint ref, IN GLuint mask );
void      APIENTRY __gllc_StencilOp              ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass );
void      APIENTRY __gllc_DepthFunc              ( IN GLenum func );
void      APIENTRY __gllc_PixelZoom              ( IN GLfloat xfactor, IN GLfloat yfactor );
void      APIENTRY __gllc_PixelTransferf         ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_PixelTransferi         ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_PixelStoref            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_PixelStorei            ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_PixelMapfv             ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] );
void      APIENTRY __gllc_PixelMapuiv            ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] );
void      APIENTRY __gllc_PixelMapusv            ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] );
void      APIENTRY __gllc_ReadBuffer             ( IN GLenum mode );
void      APIENTRY __gllc_CopyPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type );
void      APIENTRY __gllc_ReadPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY __gllc_DrawPixels             ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY __gllc_GetBooleanv            ( IN GLenum pname, OUT GLboolean params[] );
void      APIENTRY __gllc_GetClipPlane           ( IN GLenum plane, OUT GLdouble equation[4] );
void      APIENTRY __gllc_GetDoublev             ( IN GLenum pname, OUT GLdouble params[] );
GLenum    APIENTRY __gllc_GetError               ( void );
void      APIENTRY __gllc_GetFloatv              ( IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetIntegerv            ( IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetLightfv             ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetLightiv             ( IN GLenum light, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetMapdv               ( IN GLenum target, IN GLenum query, OUT GLdouble v[] );
void      APIENTRY __gllc_GetMapfv               ( IN GLenum target, IN GLenum query, OUT GLfloat v[] );
void      APIENTRY __gllc_GetMapiv               ( IN GLenum target, IN GLenum query, OUT GLint v[] );
void      APIENTRY __gllc_GetMaterialfv          ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetMaterialiv          ( IN GLenum face, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetPixelMapfv          ( IN GLenum map, OUT GLfloat values[] );
void      APIENTRY __gllc_GetPixelMapuiv         ( IN GLenum map, OUT GLuint values[] );
void      APIENTRY __gllc_GetPixelMapusv         ( IN GLenum map, OUT GLushort values[] );
void      APIENTRY __gllc_GetPolygonStipple      ( OUT GLubyte mask[] );
const GLubyte * APIENTRY __gllc_GetString        ( IN GLenum name );
void      APIENTRY __gllc_GetTexEnvfv            ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexEnviv            ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetTexGendv            ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] );
void      APIENTRY __gllc_GetTexGenfv            ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexGeniv            ( IN GLenum coord, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetTexImage            ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY __gllc_GetTexParameterfv      ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexParameteriv      ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] );
GLboolean APIENTRY __gllc_IsEnabled              ( IN GLenum cap );
GLboolean APIENTRY __gllc_IsList                 ( IN GLuint list );
void      APIENTRY __gllc_DepthRange             ( IN GLclampd zNear, IN GLclampd zFar );
void      APIENTRY __gllc_Frustum                ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY __gllc_LoadIdentity           ( void );
void      APIENTRY __gllc_LoadMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY __gllc_LoadMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY __gllc_MatrixMode             ( IN GLenum mode );
void      APIENTRY __gllc_MultMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY __gllc_MultMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY __gllc_Ortho                  ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY __gllc_PopMatrix              ( void );
void      APIENTRY __gllc_PushMatrix             ( void );
void      APIENTRY __gllc_Rotated                ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Rotatef                ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Scaled                 ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Scalef                 ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Translated             ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Translatef             ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Viewport               ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY __gllc_AddSwapHintRectWIN     ( IN GLint x, IN GLint y, IN GLint width, IN GLint height );
void      APIENTRY __gllc_Indexub                ( IN GLubyte c );
void      APIENTRY __gllc_Indexubv               ( IN const GLubyte c[1] );
GLboolean APIENTRY __gllc_AreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences);
void APIENTRY __gllc_BindTexture(GLenum target, GLuint texture);
void APIENTRY __gllc_CopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border);
void APIENTRY __gllc_CopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border);
void APIENTRY __gllc_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width);
void APIENTRY __gllc_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height);
void APIENTRY __gllc_DeleteTextures(GLsizei n, const GLuint *textures);
void APIENTRY __gllc_GenTextures(GLsizei n, GLuint *textures);
GLboolean APIENTRY __gllc_IsTexture(GLuint texture);
void APIENTRY __gllc_PrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities);
void APIENTRY __gllc_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels);
void APIENTRY __gllc_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);

void APIENTRY __gllc_PolygonOffset (GLfloat factor, GLfloat units);

void APIENTRY __gllc_ColorTableEXT (GLenum target,
                                    GLenum internalFormat,
                                    GLsizei width,
                                    GLenum format,
                                    GLenum type,
                                    const GLvoid *data);
void APIENTRY __gllc_ColorSubTableEXT (GLenum target,
                                       GLsizei start,
                                       GLsizei count,
                                       GLenum format,
                                       GLenum type,
                                       const GLvoid *data);
void APIENTRY __gllc_ArrayElement(GLint i);
void APIENTRY __gllc_DrawArrays(GLenum mode, GLint first, GLsizei count);
void APIENTRY __gllc_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
void APIENTRY __gllc_DrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

#ifdef GL_WIN_multiple_textures
void APIENTRY __gllc_CurrentTextureIndexWIN
    (GLuint index);
void APIENTRY __gllc_MultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s);
void APIENTRY __gllc_MultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s);
void APIENTRY __gllc_MultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord1iWIN
    (GLbitfield mask, GLint s);
void APIENTRY __gllc_MultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord1sWIN
    (GLbitfield mask, GLshort s);
void APIENTRY __gllc_MultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_MultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t);
void APIENTRY __gllc_MultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t);
void APIENTRY __gllc_MultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t);
void APIENTRY __gllc_MultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t);
void APIENTRY __gllc_MultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_MultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
void APIENTRY __gllc_MultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
void APIENTRY __gllc_MultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r);
void APIENTRY __gllc_MultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r);
void APIENTRY __gllc_MultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_MultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
void APIENTRY __gllc_MultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
void APIENTRY __gllc_MultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
void APIENTRY __gllc_MultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
void APIENTRY __gllc_MultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_BindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture);
void APIENTRY __gllc_NthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

#endif /* __lcfuncs_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\client\debug.c ===
#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

ULONG
DbgPrint(
    PCH DebugMessage,
    ...
    )
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    OutputDebugStringA(buffer);

    va_end(ap);

    return(0);
}

VOID NTAPI
DbgBreakPoint(VOID)
{
    DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\inc\subbatch.h ===
/******************************Module*Header*******************************\
* Module Name: subbatch.h
*
* OpenGL batching macros.
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef __SUBBATCH_H__
#define __SUBBATCH_H__

#ifdef DOGLMSGBATCHSTATS
#define STATS_INC_CLIENTCALLS()     (pMsgBatchInfo->BatchStats.ClientCalls++)
#else
#define STATS_INC_CLIENTCALLS()
#endif

// Put a message into shared area.  If it does not fit, flush what is
// currently in the buffer and then put the message at start of the buffer
//
// NOTE: glsbAttentionAlt() updates pMsgBatchInfo->NextOffset on return.
//       If you modify this macro, you have to fix the glsbAttentionAlt()
//       function!

#define GLCLIENT_BEGIN(ProcName,MsgStruct)                                  \
{                                                                           \
    GLMSGBATCHINFO *pMsgBatchInfo;                                          \
    GLMSG_##MsgStruct *pMsg;                                                \
    ULONG CurrentOffset;                                                    \
                                                                            \
    /* Get shared memory window from the TEB */                             \
    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();                            \
    STATS_INC_CLIENTCALLS();                                                \
                                                                            \
    /* Get and update the offset of the next message */                     \
    CurrentOffset = pMsgBatchInfo->NextOffset;                              \
    pMsgBatchInfo->NextOffset += GLMSG_ALIGN(sizeof(GLMSG_##MsgStruct));    \
                                                                            \
    /* Flush message if shared memory window is full */                     \
    if (pMsgBatchInfo->NextOffset > pMsgBatchInfo->MaximumOffset)           \
        CurrentOffset = glsbAttentionAlt(CurrentOffset);                    \
                                                                            \
    /* Add message to the batch */                                          \
    pMsg = (GLMSG_##MsgStruct *)(((BYTE *)pMsgBatchInfo) + CurrentOffset);  \
    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrv##ProcName);

#define GLCLIENT_END        }

// Large Messages have a variable amount of data associated with them.
// Unlike the non-clientside version, however, we will not attempt to
// copy the message into the buffer.  Instead, we will pass the pointer
// and flush.  Unlike CSR, we will not have to copy data in/out of a
// shared memory section to do this.

#define GLCLIENT_BEGIN_LARGE(bSet,ProcName,MsgStruct,pData,Size,OffData)    \
{                                                                           \
    GLMSGBATCHINFO *pMsgBatchInfo;                                          \
    GLMSG_##MsgStruct *pMsg;                                                \
    ULONG CurrentOffset;                                                    \
                                                                            \
    /* Get shared memory window from the TEB */                             \
    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();                            \
    STATS_INC_CLIENTCALLS();                                                \
                                                                            \
    /* Get and update the offset of the next message */                     \
    CurrentOffset = pMsgBatchInfo->NextOffset;                              \
    pMsgBatchInfo->NextOffset += GLMSG_ALIGN(sizeof(GLMSG_##MsgStruct));    \
                                                                            \
    /* Flush message if shared memory window is full */                     \
    if (pMsgBatchInfo->NextOffset > pMsgBatchInfo->MaximumOffset)           \
        CurrentOffset = glsbAttentionAlt(CurrentOffset);                    \
                                                                            \
    /* Set up message header */                                             \
    pMsg = (GLMSG_##MsgStruct *)(((BYTE *)pMsgBatchInfo) + CurrentOffset);  \
    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrv##ProcName);         \
    pMsg->##OffData = (ULONG_PTR) pData;                                        \
                                                                            \
    DBGLEVEL2(LEVEL_INFO, "GLCLIENT_BEGIN_LARGE %s pdata 0x%x\n",           \
        #ProcName, pData);

#define GLCLIENT_END_LARGE_SET                                              \
    glsbAttention();                                                        \
}

#define GLCLIENT_END_LARGE_GET                                              \
    glsbAttention();                                                        \
}

#define GLCLIENT_BEGIN_LARGE_SET(ProcName,MsgStruct,pData,Size,OffData)     \
        GLCLIENT_BEGIN_LARGE(TRUE,ProcName,MsgStruct,pData,Size,OffData)

#define GLCLIENT_BEGIN_LARGE_GET(ProcName,MsgStruct,pData,Size,OffData)     \
        GLCLIENT_BEGIN_LARGE(FALSE,ProcName,MsgStruct,pData,Size,OffData)

#define GLMSG_MEMCPY(dest,src,size)     memcpy(dest,src,size)

#endif /* !__SUBBATCH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\client\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* MCD debugging macros.
*
* Created: 23-Jan-1996 14:40:34
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

void  DbgBreakPoint();
ULONG DbgPrint(PCH Format, ...);

#if DBG

#define MCDDEBUG_DISABLE_ALLOCBUF   0x00000001
#define MCDDEBUG_DISABLE_GETBUF     0x00000002
#define MCDDEBUG_DISABLE_PROCBATCH  0x00000004
#define MCDDEBUG_DISABLE_CLEAR      0x00000008

// These debug macros are useful for assertions.

#define WARNING(str)             DbgPrint("%s(%d): " str,__FILE__,__LINE__)
#define WARNING1(str,a)          DbgPrint("%s(%d): " str,__FILE__,__LINE__,a)
#define WARNING2(str,a,b)        DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b)
#define WARNING3(str,a,b,c)      DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c)
#define WARNING4(str,a,b,c,d)    DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c,d)
#define RIP(str)                 {WARNING(str); DbgBreakPoint();}
#define RIP1(str,a)              {WARNING1(str,a); DbgBreakPoint();}
#define RIP2(str,a,b)            {WARNING2(str,a,b); DbgBreakPoint();}
#define ASSERTOPENGL(expr,str)            if(!(expr)) RIP(str)
#define ASSERTOPENGL1(expr,str,a)         if(!(expr)) RIP1(str,a)
#define ASSERTOPENGL2(expr,str,a,b)       if(!(expr)) RIP2(str,a,b)

//
// Use DBGPRINT for general purpose debug message.
//

#define DBGPRINT(str)            DbgPrint("MCD: " str)
#define DBGPRINT1(str,a)         DbgPrint("MCD: " str,a)
#define DBGPRINT2(str,a,b)       DbgPrint("MCD: " str,a,b)
#define DBGPRINT3(str,a,b,c)     DbgPrint("MCD: " str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)   DbgPrint("MCD: " str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e) DbgPrint("MCD: " str,a,b,c,d,e)

#else

#define WARNING(str)
#define WARNING1(str,a)
#define WARNING2(str,a,b)
#define WARNING3(str,a,b,c)
#define WARNING4(str,a,b,c,d)
#define RIP(str)
#define RIP1(str,a)
#define RIP2(str,a,b)
#define ASSERTOPENGL(expr,str)
#define ASSERTOPENGL1(expr,str,a)
#define ASSERTOPENGL2(expr,str,a,b)
#define DBGPRINT(str)
#define DBGPRINT1(str,a)
#define DBGPRINT2(str,a,b)
#define DBGPRINT3(str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e)

#endif

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\client\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c
*
* MCD library initialization routine(s).
*
* Created: 02-Apr-1996 21:25:47
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <windows.h>
#include <wtypes.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <mcdesc.h>
#include "mcdrv.h"
#include <mcd2hack.h>
#include "mcd.h"
#include "mcdint.h"
#include "debug.h"

//
// Global flags read from the registry.
//

ULONG McdFlags = 0;
ULONG McdPrivateFlags = MCDPRIVATE_MCD_ENABLED;
#if DBG
ULONG McdDebugFlags = 0;
#endif

long GetMcdRegValue(HKEY hkMcd, REGSAM samAccess, LPSTR lpstrValueName,
                    long lDefaultData);
void GetMcdFlags(void);

#ifdef MCD95
//
// Local driver semaphore.
//

CRITICAL_SECTION gsemMcd;

extern MCDENGESCFILTERFUNC pMCDEngEscFilter;
#endif

/******************************Public*Routine******************************\
* McdDllInitialize
*
* This is the entry point for MCD32.DLL, which is called each time
* a process or thread that is linked to it is created or terminated.
*
\**************************************************************************/

BOOL McdDllInitialize(HMODULE hModule, ULONG Reason, PVOID Reserved)
{
    //
    // Suppress compiler warnings.
    //

    hModule;
    Reserved;

    //
    // Do appropriate attach/detach processing.
    //

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:

#ifdef MCD95
        //
        // Initialize local driver semaphore.
        //

        __try 
        {
            InitializeCriticalSection(&gsemMcd);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }

#endif

        //
        // On process attach, read setup information from registry.
        //

        GetMcdFlags();

#ifdef WINNT
        //
        // Quick hack to work around multimon problems.
        // If there's more than one monitor, completely disable
        // MCD.
        //

        if (GetSystemMetrics(SM_CMONITORS) > 1)
        {
            McdPrivateFlags &= ~MCDPRIVATE_MCD_ENABLED;
        }
#endif
        break;

    case DLL_PROCESS_DETACH:

#ifdef MCD95
        //
        // MCD is now closed!
        //

        pMCDEngEscFilter = (MCDENGESCFILTERFUNC) NULL;

        //
        // Delete local driver sempahore.
        //

        DeleteCriticalSection((LPCRITICAL_SECTION) &gsemMcd);
#endif

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        //
        // Nothing to do yet for thread attach/detach.
        //

        break;

    default:
        break;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* MCDGetMcdCritSect__priv
*
* MCD95 ONLY
*
* Return pointer to local MCD semaphore.  Used to synchronize MCD32.DLL and
* MCDSRV32.DLL.
*
* Returns:
*   Pointer to semaphore.  Returns NULL on non-MCD95 builds.
*
* History:
*  18-Mar-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LPCRITICAL_SECTION APIENTRY MCDGetMcdCritSect__priv()
{
#ifdef MCD95
    return &gsemMcd;
#else
    return (LPCRITICAL_SECTION) NULL;
#endif
}

/******************************Public*Routine******************************\
* GetMcdRegValue
*
* Get the data for the specified value.  If the value cannot be found in
* the specified registry key or is of a type other than REG_DWORD, then
* the value is created (or recreated) with the supplied default data.
*
* History:
*  02-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long GetMcdRegValue(HKEY hkMcd, REGSAM samAccess, LPSTR lpstrValueName,
                    long lDefaultData)
{
    DWORD dwDataType;
    DWORD cjSize;
    long  lData;

    //
    // For specified value, attempt to fetch the data.
    //

    cjSize = sizeof(long);
    if ( (RegQueryValueExA(hkMcd,
                           lpstrValueName,
                           (LPDWORD) NULL,
                           &dwDataType,
                           (LPBYTE) &lData,
                           &cjSize) != ERROR_SUCCESS)
         || (dwDataType != REG_DWORD) )
    {
        //
        // Since we couldn't get the data, create the value using the
        // specified default data.
        //

        if (samAccess & KEY_WRITE)
        {
            cjSize = sizeof(long);
            if ( (RegSetValueExA(hkMcd,
                                 lpstrValueName,
                                 0, // Reserved
                                 REG_DWORD,
                                 (BYTE *) &lDefaultData,
                                 cjSize) != ERROR_SUCCESS) )
            {
                DBGPRINT1("GetMcdRegValue: RegSetValueExA(%s) failed",
                          lpstrValueName);
            }
        }

        //
        // Whether or not the value was created in the registry key, return
        // the default data.
        //

        lData = lDefaultData;
    }

    return lData;
}


/******************************Public*Routine******************************\
* GetMcdFlags
*
* Fetch the MCD flags from the registry.
* If the registry entries do not exist, create them.
*
* History:
*  02-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define STR_MCDKEY      (PCSTR)"Software\\Microsoft\\Windows\\CurrentVersion\\MCD"
#define STR_ENABLE      (LPSTR)"Enable"
#define STR_SWAPSYNC    (LPSTR)"SwapSync"
#define STR_8BPP        (LPSTR)"Palettized Formats"
#define STR_IOPRIORITY  (LPSTR)"IO Priority"
#define STR_GENSTENCIL  (LPSTR)"Use Generic Stencil"
#define STR_EMULATEICD  (LPSTR)"Enumerate as ICD"
#define STR_DEBUG       (LPSTR)"Debug"

void GetMcdFlags()
{
    HKEY hkMcd;
    DWORD dwAction;
    REGSAM samAccess;
    ULONG ulDefMcdFlags;
    ULONG ulDefMcdFlagsPriv;
    long lTmp;

    //
    // Default values for McdFlags and McdPrivateFlags.
    // If you want to change the defaults, change them here!
    //

    ulDefMcdFlags = MCDCONTEXT_SWAPSYNC;
    ulDefMcdFlagsPriv = MCDPRIVATE_MCD_ENABLED |
                        MCDPRIVATE_PALETTEFORMATS |
                        MCDPRIVATE_USEGENERICSTENCIL;

    //
    // Set initial values.
    //

    McdFlags = 0;
#if DBG
    McdDebugFlags = 0;
#endif

    //
    // First try for read/write access.  Create the key
    // if necessary.
    //

    if ( RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                         STR_MCDKEY,
                         0, // Reserved
                         (LPSTR) NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_READ | KEY_WRITE,
                         (LPSECURITY_ATTRIBUTES) NULL,
                         &hkMcd,
                         &dwAction) == ERROR_SUCCESS )
    {
        samAccess = KEY_READ | KEY_WRITE;
    }

    //
    // Next try read-only access.  Do not try to create
    // key.  Write permission is required to create and
    // we do not have that permission.
    //

    else if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                            STR_MCDKEY,
                            0, // Reserved
                            KEY_READ,
                            &hkMcd) == ERROR_SUCCESS )
    {
        samAccess = KEY_READ;
    }

    //
    // Finally, the key does not exist and we do not have
    // write access.  Fall back on the defaults and return.
    //

    else
    {
        McdFlags = ulDefMcdFlags;
        McdPrivateFlags = ulDefMcdFlagsPriv;

        return;
    }

    //
    // "Enable" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_MCD_ENABLED) ? 1:0;
    if (GetMcdRegValue(hkMcd, samAccess, STR_ENABLE, lTmp))
        McdPrivateFlags |= MCDPRIVATE_MCD_ENABLED;
    else
        McdPrivateFlags &= (~MCDPRIVATE_MCD_ENABLED);

    //
    // "SwapSync" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlags & MCDCONTEXT_SWAPSYNC) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_SWAPSYNC, lTmp);
    if (lTmp != 0)
    {
        McdFlags |= MCDCONTEXT_SWAPSYNC;
    }

    //
    // "Palettized Formats" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_PALETTEFORMATS) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_8BPP, lTmp);
    if (lTmp != 0)
    {
        McdPrivateFlags |= MCDPRIVATE_PALETTEFORMATS;
    }

    //
    // "IO Priority" value.  Default is 0 (disabled).
    //

    lTmp = (ulDefMcdFlags & MCDCONTEXT_IO_PRIORITY) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_IOPRIORITY, lTmp);
    if (lTmp != 0)
    {
        McdFlags |= MCDCONTEXT_IO_PRIORITY;
    }

    //
    // "Use Generic Stencil" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_USEGENERICSTENCIL) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_GENSTENCIL, lTmp);
    if (lTmp != 0)
    {
        McdPrivateFlags |= MCDPRIVATE_USEGENERICSTENCIL;
    }

    //
    // "Enumerate as ICD" value.  Default is 0 (disabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_EMULATEICD) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_EMULATEICD, lTmp);
    if (lTmp != 0)
    {
        McdPrivateFlags |= MCDPRIVATE_EMULATEICD;
    }

#if DBG
    //
    // "Debug" value.
    //
    // Unlike the other settings, we do not create the Debug value if
    // it does not exist.
    //

    {
        DWORD dwDataType;
        DWORD cjSize;

        cjSize = sizeof(long);
        if ( (RegQueryValueExA(hkMcd,
                               STR_DEBUG,
                               (LPDWORD) NULL,
                               &dwDataType,
                               (LPBYTE) &lTmp,
                               &cjSize) == ERROR_SUCCESS)
             && (dwDataType == REG_DWORD) )
        {
            McdDebugFlags = lTmp;
        }
    }
#endif

    //
    // We're done, so close the registry key.
    //

    RegCloseKey(hkMcd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\client\mcd.c ===
//******************************Module*Header*******************************
// Module Name: mcd.c
//
// Main module for Mini Client Driver wrapper library.
//
// Copyright (c) 1995 Microsoft Corporation
//**************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdarg.h>
#include <ddrawp.h>
#include <ddrawi.h>
#include <windows.h>
#include <wtypes.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <glp.h>
#include <glgenwin.h>
#include <mcdrv.h>
#include <mcd2hack.h>
#include <mcd.h>
#include <mcdint.h>
#ifdef MCD95
#include "mcdrvint.h"
#endif
#include "debug.h"

ULONG verMajor, verMinor;

// Checks MCD version to see if the driver can accept direct buffer
// access.  Direct access was introduced in 1.1.
#define SUPPORTS_DIRECT() \
    (verMinor >= 0x10 || verMajor > 1)

// Checks for version 2.0 or higher
#define SUPPORTS_20() \
    (verMajor >= 2)

extern ULONG McdFlags;
extern ULONG McdPrivateFlags;
#if DBG
extern ULONG McdDebugFlags;
#endif

#ifdef MCD95
MCDRVINITFUNC       pMCDrvInit       = (MCDRVINITFUNC) NULL;
MCDENGESCFILTERFUNC pMCDEngEscFilter = (MCDENGESCFILTERFUNC) NULL;
MCDENGESCPREPFUNC   pMCDEngEscPrep   = (MCDENGESCPREPFUNC) NULL;
DHPDEV gdhpdev = (DHPDEV) NULL;
#define EXTESCAPE   Mcd95EscapeBypass
#else
#define EXTESCAPE   ExtEscape
#endif

#ifdef MCD95
//
// Local driver semaphore.
//

extern CRITICAL_SECTION gsemMcd;

/******************************Public*Routine******************************\
* Mcd95EscapeBypass
*
* Escape function for MCD95.
*
* Call via the function pointer retrieved via LoadLibrary/GetProcAddress.
* Synchronize to the global
*
* History:
*  09-Feb-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG WINAPI Mcd95EscapeBypass(HDC hdc, int iEscape,
                              int cjIn, PVOID pvIn,
                              int cjOut, PVOID pvOut)
{
    LONG lRet = 0;

    if ((iEscape == RXFUNCS) && pMCDEngEscPrep && pMCDEngEscFilter)
    {
        MCDHDR McdHdr;
        SURFOBJ bogusSurf;

        bogusSurf.dhpdev = gdhpdev;

        EnterCriticalSection(&gsemMcd);

        //
        // Prep the MCDHDR buffer.  Required before invoking
        // MCDEngEscFilter.
        //

        if ((*pMCDEngEscPrep)(sizeof(McdHdr), &McdHdr, cjIn, pvIn))
        {
            //
            // Pass to dispatch function.
            //

            (*pMCDEngEscFilter)(&bogusSurf, iEscape,
                                sizeof(McdHdr), &McdHdr,
                                cjOut, pvOut, (ULONG_PTR *) &lRet);
        }
        else
        {
            DBGPRINT("Mcd95EscapeBypass: MCDEngEscPrep failed\n");
        }

        LeaveCriticalSection(&gsemMcd);
    }

    return lRet;
}

/******************************Public*Routine******************************\
* Mcd95DriverInit
*
* Initialize the MCD driver.
*
* History:
*  14-Apr-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

typedef enum {
    MCDRV_NEEDINIT,
    MCDRV_INITFAIL,
    MCDRV_INITOK
} MCDRVSTATE;

BOOL Mcd95DriverInit(HDC hdc)
{
    HMODULE hmodMCD;
    MCDGETDRIVERNAME mcdDriverNames;
    MCDCMDI mcdCmd;
    static MCDRVSTATE McdInitState = MCDRV_NEEDINIT;

    EnterCriticalSection(&gsemMcd);

    if (McdInitState == MCDRV_NEEDINIT)
    {
        //
        // One shot at init.  Assume failure for now.
        //

        McdInitState = MCDRV_INITFAIL;

        //
        // Call Escape to determine name of MCD driver DLL and the
        // name of its Init entry point.
        //

        mcdCmd.command = MCDCMD_GETDRIVERNAME;
        mcdDriverNames.ulVersion = 1;

        if ((EXTESCAPE(hdc, RXFUNCS, sizeof(mcdCmd), (char *) &mcdCmd,
                       sizeof(mcdDriverNames),
                       (char *) &mcdDriverNames) <= 0) ||
            (!mcdDriverNames.pchDriverName) ||
            (!mcdDriverNames.pchFuncName))
        {
            DBGPRINT("MCDGetDriverInfo: MCDCMD_GETDRIVERNAME failed\n");

            goto Mcd95DriverInit_exit;
        }

        //
        // Load the MCD driver DLL and get entry points.
        //

        if (hmodMCD = LoadLibraryA(mcdDriverNames.pchDriverName))
        {
            HMODULE hmodMCDSRV;

            //
            // Get MCDrvInit entry point first.
            //

            pMCDrvInit = (MCDRVINITFUNC)
                GetProcAddress(hmodMCD, mcdDriverNames.pchFuncName);

            if (pMCDrvInit)
            {
                //
                // Call MCDrvInit to get MCDSRV32.DLL module handle.
                //

                hmodMCDSRV = (*pMCDrvInit)(hdc, &gdhpdev);
                if (hmodMCDSRV)
                {
                    //
                    // Get the MCDEngEscPrep and MCDEngEscFilter entry
                    // points.
                    //

                    pMCDEngEscPrep = (MCDENGESCPREPFUNC)
                        GetProcAddress(hmodMCDSRV, MCDENGESCPREPNAME);
                    pMCDEngEscFilter = (MCDENGESCFILTERFUNC)
                        GetProcAddress(hmodMCDSRV, MCDENGESCFILTERNAME);

                    if (pMCDEngEscPrep && pMCDEngEscFilter)
                    {
                        McdInitState = MCDRV_INITOK;
                    }
                    else
                    {
                        pMCDEngEscPrep = (MCDENGESCPREPFUNC) NULL;
                        pMCDEngEscFilter = (MCDENGESCFILTERFUNC) NULL;

                        DBGPRINT("Mcd95DriverInit: GetProcAddress failed\n");
                    }
                }
            }
            else
            {
                DBGPRINT1("MCDGetDriverInfo: GetProcAddress(%s) failed\n",
                          mcdDriverNames.pchFuncName);
            }
        }
        else
        {
            DBGPRINT1("MCDGetDriverInfo: LoadLibrary(%s) failed\n",
                      mcdDriverNames.pchDriverName);
        }
    }

Mcd95DriverInit_exit:

    LeaveCriticalSection(&gsemMcd);

    return (McdInitState == MCDRV_INITOK);
}
#endif

//*****************************Private*Routine******************************
//
// InitMcdEsc
//
// Initializes an MCDESC_HEADER for filling in
//
//**************************************************************************

// Placeholder in case any generic initialization becomes necessary
#define InitMcdEsc(pmeh) (pmeh)

//*****************************Private*Routine******************************
//
// InitMcdEscEmpty
//
// Initializes an MCDESC_HEADER for filling in
//
//**************************************************************************

#define InitMcdEscEmpty(pmeh) \
    (InitMcdEsc(pmeh), \
     (pmeh)->hRC = NULL, \
     (pmeh)->hSharedMem = NULL, \
     (pmeh)->pSharedMem = NULL, \
     (pmeh)->dwWindow = 0, \
     (pmeh))

//*****************************Private*Routine******************************
//
// InitMcdEscContext
//
// Initializes an MCDESC_HEADER for filling in
//
//**************************************************************************

#define InitMcdEscContext(pmeh, pmctx) \
    (InitMcdEsc(pmeh), \
     (pmeh)->hRC = (pmctx)->hMCDContext, \
     (pmeh)->dwWindow = (pmctx)->dwMcdWindow, \
     (pmeh))

//*****************************Private*Routine******************************
//
// InitMcdEscSurfaces
//
// Fills in some MCDESC_HEADER fields from context information
//
//**************************************************************************

#if DBG
extern ULONG APIENTRY glDebugEntry(int param, void *data);
#endif

MCDESC_HEADER *InitMcdEscSurfaces(MCDESC_HEADER *pmeh, MCDCONTEXT *pmctx)
{
    GENMCDSTATE *pmst;

    InitMcdEscContext(pmeh, pmctx);

    // We're assuming that the context passed in is always the one
    // statically placed in the GENMCDSTATE.  Attempt to verify this
    // by checking that the allocation size for the context is
    // the same as for a GENMCDSTATE.
    ASSERTOPENGL(glDebugEntry(3, pmctx) == sizeof(GENMCDSTATE),
                 "InitMcdEscSurfaces: Bad context\n");

    pmst = (GENMCDSTATE *)pmctx;

    pmeh->msrfColor.hSurf = pmst->hDdColor;
    pmeh->msrfDepth.hSurf = pmst->hDdDepth;

    return pmeh;
}

//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDGetDriverInfo(HDC hdc, MCDDRIVERINFOI *pMCDDriverInfo)
//
// Checks to determine if the device driver reports MCD capabilities.
//
//**************************************************************************

BOOL APIENTRY MCDGetDriverInfo(HDC hdc, MCDDRIVERINFOI *pMCDDriverInfo)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDRIVERINFOCMDI)];
    MCDESC_HEADER *pmeh;
    MCDDRIVERINFOCMDI *pInfoCmd;

    if ( !(McdPrivateFlags & MCDPRIVATE_MCD_ENABLED) )
    {
        return FALSE;
    }

#ifdef MCD95
    if (!Mcd95DriverInit(hdc))
    {
        return FALSE;
    }
#endif

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pInfoCmd = (MCDDRIVERINFOCMDI *)(pmeh + 1);
    pInfoCmd->command = MCD_DRIVERINFO;

    // Force the table to empty
    memset(&pMCDDriverInfo->mcdDriver, 0, sizeof(MCDDRIVER));

    // Force the version to 0

    pMCDDriverInfo->mcdDriverInfo.verMajor = 0;

    if (!(BOOL)EXTESCAPE(hdc, MCDFUNCS,
                         sizeof(cmdBuffer),
                         (char *)pmeh, sizeof(MCDDRIVERINFOI),
                         (char *)pMCDDriverInfo))
        return FALSE;

    // See if the driver filled in a non-null version:

    if (pMCDDriverInfo->mcdDriverInfo.verMajor != 0)
    {
        verMajor = pMCDDriverInfo->mcdDriverInfo.verMajor;
        verMinor = pMCDDriverInfo->mcdDriverInfo.verMinor;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//******************************Public*Routine******************************
//
// LONG APIENTRY MCDDescribeMcdPixelFormat(HDC hdc,
//                                         LONG iPixelFormat,
//                                         MCDPIXELFORMAT *ppfd)
//
// Returns information about the specified hardware-dependent pixel format.
//
//**************************************************************************

LONG APIENTRY MCDDescribeMcdPixelFormat(HDC hdc, LONG iPixelFormat,
                                        MCDPIXELFORMAT *pMcdPixelFmt)
{
    LONG lRet = 0;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDPIXELFORMATCMDI)];
    MCDESC_HEADER *pmeh;
    MCDPIXELFORMATCMDI *pPixelFmtCmd;

    if ( !(McdPrivateFlags & MCDPRIVATE_PALETTEFORMATS) &&
         ((GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES)) == 8) &&
         (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) )
    {
        return lRet;
    }

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pPixelFmtCmd = (MCDPIXELFORMATCMDI *)(pmeh + 1);
    pPixelFmtCmd->command = MCD_DESCRIBEPIXELFORMAT;
    pPixelFmtCmd->iPixelFormat = iPixelFormat;

    lRet = (LONG)EXTESCAPE(hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, sizeof(MCDPIXELFORMAT),
                           (char *)pMcdPixelFmt);

    // Limit overlay/underlay planes to 15 each (as per spec).

    if (pMcdPixelFmt)
    {
        if (pMcdPixelFmt->cOverlayPlanes > 15)
            pMcdPixelFmt->cOverlayPlanes = 15;
        if (pMcdPixelFmt->cUnderlayPlanes > 15)
            pMcdPixelFmt->cUnderlayPlanes = 15;
    }

    return lRet;
}


//******************************Public*Routine******************************
//
// LONG APIENTRY MCDDescribePixelFormat(HDC hdc,
//                                      LONG iPixelFormat,
//                                      LPPIXELFORMATDESCRIPTOR ppfd)
//
// Returns a PIXELFORMATDESCRIPTOR describing the specified hardware-dependent
// pixel format.
//
//**************************************************************************

#define STANDARD_MCD_FLAGS \
    (PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_GENERIC_FORMAT | \
     PFD_GENERIC_ACCELERATED)

LONG APIENTRY MCDDescribePixelFormat(HDC hdc, LONG iPixelFormat,
                                     LPPIXELFORMATDESCRIPTOR ppfd)
{
    LONG lRet = 0;
    MCDPIXELFORMAT mcdPixelFmt;

    lRet = MCDDescribeMcdPixelFormat(hdc, iPixelFormat,
                                     ppfd ? &mcdPixelFmt : NULL);

    if (ppfd && lRet)
    {
        ppfd->nSize    = sizeof(*ppfd);
        ppfd->nVersion = 1;
        ppfd->dwFlags  = mcdPixelFmt.dwFlags | STANDARD_MCD_FLAGS |
                         ((mcdPixelFmt.dwFlags & PFD_DOUBLEBUFFER) ?
                          0 : PFD_SUPPORT_GDI);

        if (McdPrivateFlags & MCDPRIVATE_EMULATEICD)
            ppfd->dwFlags &= ~PFD_GENERIC_FORMAT;

        memcpy(&ppfd->iPixelType, &mcdPixelFmt.iPixelType,
               offsetof(MCDPIXELFORMAT, cDepthBits) -
               offsetof(MCDPIXELFORMAT, iPixelType));

        ppfd->cDepthBits = mcdPixelFmt.cDepthBits;

        if (ppfd->iPixelType == PFD_TYPE_RGBA)
        {
            if (ppfd->cColorBits < 8)
            {
                ppfd->cAccumBits      = 16;
                ppfd->cAccumRedBits   = 5;
                ppfd->cAccumGreenBits = 6;
                ppfd->cAccumBlueBits  = 5;
                ppfd->cAccumAlphaBits = 0;
            }
            else
            {
                if (ppfd->cColorBits <= 16)
                {
                    ppfd->cAccumBits      = 32;
                    ppfd->cAccumRedBits   = 11;
                    ppfd->cAccumGreenBits = 11;
                    ppfd->cAccumBlueBits  = 10;
                    ppfd->cAccumAlphaBits = 0;
                }
                else
                {
                    ppfd->cAccumBits      = 64;
                    ppfd->cAccumRedBits   = 16;
                    ppfd->cAccumGreenBits = 16;
                    ppfd->cAccumBlueBits  = 16;
                    ppfd->cAccumAlphaBits = 0;
                }
            }
        }
        else
        {
            ppfd->cAccumBits      = 0;
            ppfd->cAccumRedBits   = 0;
            ppfd->cAccumGreenBits = 0;
            ppfd->cAccumBlueBits  = 0;
            ppfd->cAccumAlphaBits = 0;
        }
        if (mcdPixelFmt.cStencilBits)
        {
            ppfd->cStencilBits = mcdPixelFmt.cStencilBits;
        }
        else
        {
            if (McdPrivateFlags & MCDPRIVATE_USEGENERICSTENCIL)
                ppfd->cStencilBits = 8;
            else
                ppfd->cStencilBits = 0;
        }
        ppfd->cAuxBuffers     = 0;
        ppfd->iLayerType      = PFD_MAIN_PLANE;
        ppfd->bReserved       = (BYTE) (mcdPixelFmt.cOverlayPlanes |
                                        (mcdPixelFmt.cUnderlayPlanes << 4));
        ppfd->dwLayerMask     = 0;
        ppfd->dwVisibleMask   = mcdPixelFmt.dwTransparentColor;
        ppfd->dwDamageMask    = 0;
    }

    return lRet;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDCreateContext(MCDCONTEXT *pMCDContext,
//                                MCDRCINFO *pRcInfo,
//                                GLSURF *pgsurf,
//                                ULONG flags)
//
// Creates an MCD rendering context for the specified hdc/hwnd according
// to the specified flags.
//
//**************************************************************************

BOOL APIENTRY MCDCreateContext(MCDCONTEXT *pMCDContext,
                               MCDRCINFOPRIV *pRcInfo,
                               GLSURF *pgsurf,
                               int ipfd,
                               ULONG flags)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCREATECONTEXT)];
    MCDESC_HEADER *pmeh;
    MCDCREATECONTEXT *pmcc;

    if (flags & MCDSURFACE_HWND)
    {
        // We don't have surfaces to pass in this case
        pmeh = InitMcdEscContext((MCDESC_HEADER *)cmdBuffer, pMCDContext);
        pmeh->flags = MCDESC_FL_CREATE_CONTEXT;
    }
    else if (SUPPORTS_DIRECT())
    {
        pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
        pmeh->flags = MCDESC_FL_CREATE_CONTEXT | MCDESC_FL_SURFACES;
    }
    else
    {
        return FALSE;
    }

    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;

    pmcc = (MCDCREATECONTEXT *)(pmeh + 1);

    if (flags & MCDSURFACE_HWND)
    {
        pmcc->escCreate.hwnd = pgsurf->hwnd;
    }
    else
    {
        pmcc->escCreate.hwnd = NULL;
    }
    pmcc->escCreate.flags = flags;

    pmcc->ipfd = ipfd;
    pmcc->iLayer = pgsurf->iLayer;
    pmcc->mcdFlags = McdFlags;
    pmcc->pRcInfo = pRcInfo;

    pMCDContext->hMCDContext =
        (MCDHANDLE)IntToPtr( EXTESCAPE(pgsurf->hdc, MCDFUNCS,
                                      sizeof(MCDESC_HEADER) + sizeof(MCDCREATECONTEXT),
                                      (char *)cmdBuffer, sizeof(MCDRCINFOPRIV),
                                      (char *)pRcInfo) );

    pMCDContext->hdc = pgsurf->hdc;
    pMCDContext->dwMcdWindow = pRcInfo->dwMcdWindow;

    return (pMCDContext->hMCDContext != (HANDLE)NULL);
}

#define MCD_MEM_ALIGN 32

//******************************Public*Routine******************************
//
// UCHAR * APIENTRY MCDAlloc(MCDCONTEXT *pMCDContext,
//                           ULONG numBytes,
//                           MCDHANDLE *pMCDHandle,
//                           ULONG flags);
//
// Allocate a chunk of shared memory to use for vertex and pixel data.
//
// The return value is a pointer to a shared memory region which can be
// subsequently used by the caller.  For vertex processing, caller should
// use MCDLockMemory()/MCDUnlockMemory to serialize hardware access to the
// memory.
//
//**************************************************************************

UCHAR * APIENTRY MCDAlloc(MCDCONTEXT *pMCDContext, ULONG numBytes,
                          HANDLE *pMCDHandle, ULONG flags)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDALLOCCMDI)];
    ULONG outBuffer;
    ULONG totalSize = numBytes + MCD_MEM_ALIGN + sizeof(MCDMEMHDRI);
    MCDALLOCCMDI *pCmdAlloc;
    MCDESC_HEADER *pmeh;
    VOID *pResult;
    MCDMEMHDRI *pMCDMemHdr;
    UCHAR *pBase;
    UCHAR *pAlign;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = NULL;
    pmeh->flags = 0;

    pCmdAlloc = (MCDALLOCCMDI *)(pmeh + 1);
    pCmdAlloc->command = MCD_ALLOC;
    pCmdAlloc->sourceProcessID = GetCurrentProcessId();
    pCmdAlloc->numBytes = totalSize;
    pCmdAlloc->flags = flags;

    pBase = (UCHAR *)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                        sizeof(cmdBuffer),
                                        (char *)pmeh, 4, (char *)pMCDHandle) );

    if (!pBase)
        return (VOID *)NULL;

    pAlign = (UCHAR *)(((ULONG_PTR)(pBase + sizeof(MCDMEMHDRI)) +
                        (MCD_MEM_ALIGN - 1)) &
                       ~(MCD_MEM_ALIGN - 1));

    pMCDMemHdr = (MCDMEMHDRI *)(pAlign - sizeof(MCDMEMHDRI));

    pMCDMemHdr->flags = 0;
    pMCDMemHdr->numBytes = numBytes;
    pMCDMemHdr->pMaxMem = (VOID *)((char *)pMCDMemHdr + totalSize);
    pMCDMemHdr->hMCDMem = *pMCDHandle;
    pMCDMemHdr->pBase = pBase;

    return (VOID *)(pAlign);
}



//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDFree(MCDCONTEXT *pMCDContext,
//                       VOID *pMem);
//
// Frees a chunk of driver-allocated shared memory.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDFree(MCDCONTEXT *pMCDContext, VOID *pMCDMem)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDFREECMDI)];
    MCDFREECMDI *pCmdFree;
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;

#ifdef MCD95
    //
    // Driver already shutdown, therefore memory already deleted.
    //

    if (!pMCDEngEscFilter)
        return TRUE;
#endif

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = NULL;
    pmeh->flags = 0;

    pCmdFree = (MCDFREECMDI *)(pmeh + 1);
    pCmdFree->command = MCD_FREE;
    pCmdFree->hMCDMem = pMCDMemHdr->hMCDMem;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// VOID APIENTRY MCDBeginState(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
//
// Begins a batch of state commands to issue to the driver.
//
//**************************************************************************

VOID APIENTRY MCDBeginState(MCDCONTEXT *pMCDContext, VOID *pMCDMem)
{
    MCDMEMHDRI *pMCDMemHdr;
    MCDSTATECMDI *pMCDStateCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    pMCDStateCmd->command = MCD_STATE;
    pMCDStateCmd->numStates = 0;
    pMCDStateCmd->pNextState = (MCDSTATE *)(pMCDStateCmd + 1);
    pMCDStateCmd->pMaxState = (MCDSTATE *)(pMCDMemHdr->pMaxMem);

    pMCDMemHdr->pMCDContext = pMCDContext;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDFlushState(VOID pMCDMem);
//
// Flushes a batch of state commands to the driver.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDFlushState(VOID *pMCDMem)
{
    MCDESC_HEADER meh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDSTATECMDI *pMCDStateCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    InitMcdEscContext(&meh, pMCDMemHdr->pMCDContext);
    meh.hSharedMem = pMCDMemHdr->hMCDMem;
    meh.pSharedMem = (char *)pMCDMem;
    meh.sharedMemSize = (ULONG)((char *)pMCDStateCmd->pNextState -
                          (char *)pMCDStateCmd);
    meh.flags = 0;

    if (!meh.sharedMemSize)
        return TRUE;

    return (BOOL)EXTESCAPE(pMCDMemHdr->pMCDContext->hdc, MCDFUNCS,
                           sizeof(MCDESC_HEADER), (char *)&meh,
                           0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDAddState(VOID *pMCDMem, ULONG stateToChange,
//                           ULONG stateValue);
//
// Adds a state to a state buffer (started with MCDBeginState).  If there
// is no room in the state stream (i.e., the memory buffer), the current
// batch of state commands is automatically flushed.
//
//
// Returns TRUE for success, FALSE for failure.  A FALSE return will occur
// if an automatic flush is performed which fails.
//
//**************************************************************************

BOOL APIENTRY MCDAddState(VOID *pMCDMem, ULONG stateToChange,
                          ULONG stateValue)
{
    MCDSTATECMDI *pMCDStateCmd;
    MCDSTATE *pState;
    BOOL retVal = TRUE;

    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    if (((char *)pMCDStateCmd->pNextState + sizeof(MCDSTATE)) >=
        (char *)pMCDStateCmd->pMaxState) {

        MCDMEMHDRI *pMCDMemHdr = (MCDMEMHDRI *)
            ((char *)pMCDMem - sizeof(MCDMEMHDRI));

        retVal = MCDFlushState(pMCDMem);

        pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;
        pMCDStateCmd->command = MCD_STATE;
        pMCDStateCmd->numStates = 0;
        pMCDStateCmd->pNextState = (MCDSTATE *)(pMCDStateCmd + 1);
        pMCDStateCmd->pMaxState = (MCDSTATE *)(pMCDMemHdr->pMaxMem);
    }

    pMCDStateCmd->numStates++;
    pState = pMCDStateCmd->pNextState;
    pState->size = sizeof(MCDSTATE);
    pState->state = stateToChange;
    pState->stateValue = stateValue;
    pMCDStateCmd->pNextState++;

    return retVal;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDAddStateStruct(VOID *pMCDMem, ULONG stateToChange,
//                                 VOID *pStateValue, ULONG stateValueSize)
//
//
// Adds a state structure to a state buffer (started with MCDBeginState).  If
// there is no room in the state stream (i.e., the memory buffer), the current
// batch of state commands is automatically flushed.
//
//
// Returns TRUE for success, FALSE for failure.  A FALSE return will occur
// if an automatic flush is performed which fails.
//
//**************************************************************************

BOOL APIENTRY MCDAddStateStruct(VOID *pMCDMem, ULONG stateToChange,
                                VOID *pStateValue, ULONG stateValueSize)
{
    MCDSTATECMDI *pMCDStateCmd;
    MCDSTATE *pState;
    BOOL retVal = FALSE;

    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    if (((char *)pMCDStateCmd->pNextState + stateValueSize) >=
        (char *)pMCDStateCmd->pMaxState) {

        MCDMEMHDRI *pMCDMemHdr = (MCDMEMHDRI *)
            ((char *)pMCDMem - sizeof(MCDMEMHDRI));

        retVal = MCDFlushState(pMCDMem);

        pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;
        pMCDStateCmd->command = MCD_STATE;
        pMCDStateCmd->numStates = 0;
        pMCDStateCmd->pNextState = (MCDSTATE *)(pMCDStateCmd + 1);
        pMCDStateCmd->pMaxState = (MCDSTATE *)(pMCDMemHdr->pMaxMem);
    }

    pMCDStateCmd->numStates++;
    pState = pMCDStateCmd->pNextState;
    pState->state = stateToChange;
    pState->size = offsetof(MCDSTATE, stateValue) + stateValueSize;
    memcpy((char *)&pState->stateValue, (char *)pStateValue, stateValueSize);
    pMCDStateCmd->pNextState =
        (MCDSTATE *)(((char *)pMCDStateCmd->pNextState) + pState->size);

    return retVal;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDSetViewport(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                              MCDVIEWPORT pMCDViewport)
//
// Establishes the viewport scaling to convert transformed coordinates to
// screen coordinates.
//
//**************************************************************************

BOOL APIENTRY MCDSetViewport(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                             MCDVIEWPORT *pMCDViewport)
{
    MCDESC_HEADER meh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDVIEWPORTCMDI *pMCDViewportCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    pMCDViewportCmd = (MCDVIEWPORTCMDI *)pMCDMem;

    pMCDViewportCmd->MCDViewport = *pMCDViewport;
    pMCDViewportCmd->command = MCD_VIEWPORT;

    InitMcdEscContext(&meh, pMCDContext);
    meh.hSharedMem = pMCDMemHdr->hMCDMem;
    meh.pSharedMem = (char *)pMCDMem;
    meh.sharedMemSize = sizeof(MCDVIEWPORTCMDI);
    meh.flags = 0;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(MCDESC_HEADER), (char *)&meh,
                           0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDQueryMemStatus((VOID *pMCDMem);
//
// Returns the status of the specified memory block.  Return values are:
//
//      MCD_MEM_READY   - memory is available for client access
//      MCD_MEM_BUSY    - memory is busy due to driver access
//      MCD_MEM_INVALID - queried memory is invalid
//
//**************************************************************************

ULONG APIENTRY MCDQueryMemStatus(VOID *pMCDMem)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDMEMSTATUSCMDI)];
    MCDMEMHDRI *pMCDMemHdr =
        (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    MCDMEMSTATUSCMDI *pCmdMemStatus;
    MCDESC_HEADER *pmeh;

#ifdef MCD95
    //
    // Driver already shutdown, therefore memory already deleted.
    //

    if (!pMCDEngEscFilter)
        return MCD_MEM_INVALID;
#endif

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pCmdMemStatus = (MCDMEMSTATUSCMDI *)(pmeh + 1);
    pCmdMemStatus->command = MCD_QUERYMEMSTATUS;
    pCmdMemStatus->hMCDMem = pMCDMemHdr->hMCDMem;

    return (ULONG)EXTESCAPE(pMCDMemHdr->pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDProcessBatch(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                               ULONG batchSize, VOID *pMCDFirstCmd)
//
// Processes a batch of primitives pointed to by pMCDMem.
//
// Returns TRUE if the batch was processed without error, FALSE otherwise.
//
//**************************************************************************

PVOID APIENTRY MCDProcessBatch(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                               ULONG batchSize, VOID *pMCDFirstCmd,
                               int cExtraSurfaces,
                               LPDIRECTDRAWSURFACE *pdds)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + MCD_MAXMIPMAPLEVEL*sizeof(DWORD)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;
    int i;
    ULONG_PTR *pdwSurf;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_PROCBATCH)
    {
        MCDSync(pMCDContext);
        return pMCDFirstCmd;
    }
#endif

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = pMCDMemHdr->hMCDMem;
    pmeh->pSharedMem = (char *)pMCDFirstCmd;
    pmeh->sharedMemSize = batchSize;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK | MCDESC_FL_BATCH;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES | MCDESC_FL_LOCK_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL ||
             cExtraSurfaces != 0)
    {
        return pMCDFirstCmd;
    }

    // Assert that we won't exceed the kernel's expectations
    ASSERTOPENGL(MCD_MAXMIPMAPLEVEL <= MCDESC_MAX_LOCK_SURFACES,
                 "MCD_MAXMIPMAPLEVEL too large\n");

    pmeh->cLockSurfaces = cExtraSurfaces;
    pdwSurf = (ULONG_PTR *)(pmeh+1);
    for (i = 0; i < cExtraSurfaces; i++)
    {
        *pdwSurf++ = ((LPDDRAWI_DDRAWSURFACE_INT)pdds[i])->lpLcl->hDDSurface;
    }

    return (PVOID)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                      sizeof(cmdBuffer), (char *)pmeh,
                                      0, (char *)NULL) );
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDReadSpan(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                           ULONG x, ULONG y, ULONG numPixels, ULONG type)
//
// Reads a span of pixel data from the buffer requested by "type".
// The pixel values are returned in pMCDMem.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDReadSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                          ULONG x, ULONG y, ULONG numPixels, ULONG type)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSPANCMDI)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDSPANCMDI *pMCDSpanCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->sharedMemSize = 0;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return FALSE;
    }

    pMCDSpanCmd = (MCDSPANCMDI *)(pmeh + 1);

    pMCDSpanCmd->command = MCD_READSPAN;
    pMCDSpanCmd->hMem = pMCDMemHdr->hMCDMem;
    pMCDSpanCmd->MCDSpan.x = x;
    pMCDSpanCmd->MCDSpan.y = y;
    pMCDSpanCmd->MCDSpan.numPixels = numPixels;
    pMCDSpanCmd->MCDSpan.type = type;
    pMCDSpanCmd->MCDSpan.pPixels = (VOID *)((char *)pMCDMem);

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer), (char *)pmeh, 0, (char *)NULL);
}

//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDWriteSpan(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                            ULONG x, ULONG y, ULONG numPixels, ULONG type)
//
// Writes a span of pixel data to the buffer requested by "type".
// The pixel values are given in pMCDMem.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDWriteSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                           ULONG x, ULONG y, ULONG numPixels, ULONG type)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSPANCMDI)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDSPANCMDI *pMCDSpanCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->sharedMemSize = 0;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return FALSE;
    }

    pMCDSpanCmd = (MCDSPANCMDI *)(pmeh + 1);

    pMCDSpanCmd->command = MCD_WRITESPAN;
    pMCDSpanCmd->hMem = pMCDMemHdr->hMCDMem;
    pMCDSpanCmd->MCDSpan.x = x;
    pMCDSpanCmd->MCDSpan.y = y;
    pMCDSpanCmd->MCDSpan.numPixels = numPixels;
    pMCDSpanCmd->MCDSpan.type = type;
    pMCDSpanCmd->MCDSpan.pPixels = (VOID *)((char *)pMCDMem);

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer), (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDClear(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers);
//
// Clears buffers specified for the given rectangle.  The current fill values
// will be used.
//
//**************************************************************************

BOOL APIENTRY MCDClear(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCLEARCMDI)];
    MCDCLEARCMDI *pClearCmd;
    MCDESC_HEADER *pmeh;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_CLEAR)
    {
        MCDSync(pMCDContext);
        return FALSE;
    }
#endif

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return FALSE;
    }

    pClearCmd = (MCDCLEARCMDI *)(pmeh + 1);
    pClearCmd->command = MCD_CLEAR;
    pClearCmd->buffers = buffers;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDSetScissorRect(MCDCONTEXT *pMCDContext, RECTL *pRect,
//                                 BOOL bEnabled);
//
// Sets the scissor rectangle.
//
//**************************************************************************

//!! Need semaphore to remove display lock !!

BOOL APIENTRY MCDSetScissorRect(MCDCONTEXT *pMCDContext, RECTL *pRect,
                                BOOL bEnabled)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSCISSORCMDI)];
    MCDSCISSORCMDI *pScissorCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pScissorCmd = (MCDSCISSORCMDI *)(pmeh + 1);
    pScissorCmd->command = MCD_SCISSOR;
    pScissorCmd->rect = *pRect;
    pScissorCmd->bEnabled = bEnabled;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDSwap(MCDCONTEXT *pMCDContext, ULONG flags);
//
// Swaps the front and back buffers.
//
//**************************************************************************

BOOL APIENTRY MCDSwap(MCDCONTEXT *pMCDContext, ULONG flags)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSWAPCMDI)];
    MCDSWAPCMDI *pSwapCmd;
    MCDESC_HEADER *pmeh;

    // InitMcdEscSurfaces cannot be used because the context given
    // is a temporary one constructed on the fly since SwapBuffers
    // has only surface information.
    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;

    // Swap cannot be called on DirectDraw surfaces because DirectDraw
    // contexts cannot be double-buffered.  These handles can therefore
    // be forced to NULL.
    pmeh->msrfColor.hSurf = NULL;
    pmeh->msrfDepth.hSurf = NULL;

#ifdef MCD95
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK | MCDESC_FL_SWAPBUFFER;
#else
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;
#endif

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }

    pSwapCmd = (MCDSWAPCMDI *)(pmeh + 1);
    pSwapCmd->command = MCD_SWAP;
    pSwapCmd->flags = flags;
#ifdef MCD95
    pSwapCmd->hwnd = WindowFromDC(pMCDContext->hdc);
#endif

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDeleteContext(MCDCONTEXT *pMCDContext);
//
// Deletes the specified context.  This will free the buffers associated with
// the context, but will *not* free memory or textures created with the
// context.
//
//**************************************************************************

BOOL APIENTRY MCDDeleteContext(MCDCONTEXT *pMCDContext)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDELETERCCMDI)];
    MCDDELETERCCMDI *pDeleteRcCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pDeleteRcCmd = (MCDDELETERCCMDI *)(pmeh + 1);
    pDeleteRcCmd->command = MCD_DELETERC;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDAllocBuffers(MCDCONTEXT *pMCDContext)
//
// Allocates the buffers required for the specified context.
//
//**************************************************************************

BOOL APIENTRY MCDAllocBuffers(MCDCONTEXT *pMCDContext, RECTL *pWndRect)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDALLOCBUFFERSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDALLOCBUFFERSCMDI *pAllocBuffersCmd;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_ALLOCBUF)
    {
        return FALSE;
    }
#endif

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pAllocBuffersCmd = (MCDALLOCBUFFERSCMDI *)(pmeh + 1);
    pAllocBuffersCmd->command = MCD_ALLOCBUFFERS;
    pAllocBuffersCmd->WndRect = *pWndRect;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDGetBuffers(MCDCONTEXT *pMCDContext,
//                             MCDRECTBUFFERS *pMCDBuffers);
//
// Returns information about the buffers (front, back, and depth) associated
// with the specified context.
//
//**************************************************************************

BOOL APIENTRY MCDGetBuffers(MCDCONTEXT *pMCDContext,
                            MCDRECTBUFFERS *pMCDBuffers)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDGETBUFFERSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDGETBUFFERSCMDI *pGetBuffersCmd;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_GETBUF)
    {
        if (pMCDBuffers)
        {
            pMCDBuffers->mcdFrontBuf.bufFlags &= ~MCDBUF_ENABLED;
            pMCDBuffers->mcdBackBuf.bufFlags  &= ~MCDBUF_ENABLED;
            pMCDBuffers->mcdDepthBuf.bufFlags &= ~MCDBUF_ENABLED;
        }

        return TRUE;
    }
#endif

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pGetBuffersCmd = (MCDGETBUFFERSCMDI *)(pmeh + 1);
    pGetBuffersCmd->command = MCD_GETBUFFERS;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, sizeof(MCDRECTBUFFERS),
                           (char *)pMCDBuffers);
}


//******************************Public*Routine******************************
//
// ULONG MCDLock();
//
// Grab the MCD synchronization lock.
//
//**************************************************************************

static ULONG __MCDLockRequest(MCDCONTEXT *pMCDContext, ULONG tid)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDLOCKCMDI)];
    MCDLOCKCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDLOCKCMDI *)(pmeh + 1);
    pCmd->command = MCD_LOCK;

    return EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                     sizeof(cmdBuffer),
                     (char *)pmeh, 0, (char *)NULL);
}

ULONG APIENTRY MCDLock(MCDCONTEXT *pMCDContext)
{
    ULONG ulRet;
    ULONG tid;

    tid = GetCurrentThreadId();

    do
    {
        ulRet = __MCDLockRequest(pMCDContext, tid);
        if (ulRet == MCD_LOCK_BUSY)
            Sleep(0);
    }
    while (ulRet == MCD_LOCK_BUSY);

    return ulRet;
}


//******************************Public*Routine******************************
//
// VOID MCDUnlock();
//
// Release the MCD synchronization lock.
//
//**************************************************************************

VOID APIENTRY MCDUnlock(MCDCONTEXT *pMCDContext)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDLOCKCMDI)];
    MCDLOCKCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDLOCKCMDI *)(pmeh + 1);
    pCmd->command = MCD_UNLOCK;

    EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
              sizeof(cmdBuffer),
              (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// VOID MCDBindContext();
//
// Bind a new window to the specified context.
//
//**************************************************************************

BOOL APIENTRY MCDBindContext(MCDCONTEXT *pMCDContext, HDC hdc,
                             GLGENwindow *pwnd)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDBINDCONTEXTCMDI)];
    MCDBINDCONTEXTCMDI *pCmd;
    MCDESC_HEADER *pmeh;
    ULONG_PTR dwMcdWindow;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->dwWindow = pwnd->dwMcdWindow;
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDBINDCONTEXTCMDI *)(pmeh + 1);
    pCmd->command = MCD_BINDCONTEXT;
    pCmd->hWnd = pwnd->gwid.hwnd;

    dwMcdWindow = EXTESCAPE(hdc, MCDFUNCS,
                            sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
    if (dwMcdWindow != 0)
    {
        pMCDContext->hdc = hdc;
        pMCDContext->dwMcdWindow = dwMcdWindow;
        if (pwnd->dwMcdWindow == 0)
        {
            // Save MCD server-side window handle in the GENwindow
            pwnd->dwMcdWindow = dwMcdWindow;
        }
        else
        {
            ASSERTOPENGL(pwnd->dwMcdWindow == dwMcdWindow,
                         "dwMcdWindow mismatch\n");
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//******************************Public*Routine******************************
//
// BOOL MCDSync();
//
// Synchronizes the 3D hardware.
//
//**************************************************************************

BOOL APIENTRY MCDSync(MCDCONTEXT *pMCDContext)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSYNCCMDI)];
    MCDSYNCCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDSYNCCMDI *)(pmeh + 1);
    pCmd->command = MCD_SYNC;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// MCDHANDLE MCDCreateTexture();
//
// Creates and loads a texture on the MCD device.
//
//**************************************************************************

MCDHANDLE APIENTRY MCDCreateTexture(MCDCONTEXT *pMCDContext,
                                    MCDTEXTUREDATA *pTexData,
                                    ULONG flags,
                                    VOID *pSurface)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCREATETEXCMDI)];
    MCDCREATETEXCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDCREATETEXCMDI *)(pmeh + 1);
    pCmd->command = MCD_CREATE_TEXTURE;
    pCmd->pTexData = pTexData;
    pCmd->flags = flags;
    pCmd->pSurface = pSurface;

    return (MCDHANDLE)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                         sizeof(cmdBuffer),
                                         (char *)pmeh, 0, (char *)NULL) );
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDeleteTexture(MCDCONTEXT *pMCDContext,
//                                MCDHANDLE hMCDTexture);
//
// Deletes the specified texture.  This will free the device memory associated
// with the texture.
//
//**************************************************************************

BOOL APIENTRY MCDDeleteTexture(MCDCONTEXT *pMCDContext, MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDELETETEXCMDI)];
    MCDDELETETEXCMDI *pDeleteTexCmd;
    MCDESC_HEADER *pmeh;

#ifdef MCD95
    //
    // Driver already shutdown, therefore memory already deleted.
    //

    if (!pMCDEngEscFilter)
        return MCD_MEM_INVALID;
#endif

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pDeleteTexCmd = (MCDDELETETEXCMDI *)(pmeh + 1);
    pDeleteTexCmd->command = MCD_DELETE_TEXTURE;
    pDeleteTexCmd->hTex = hTex;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateSubTexture();
//
// Updates a texture (or region of a texture).
//
//**************************************************************************

BOOL APIENTRY MCDUpdateSubTexture(MCDCONTEXT *pMCDContext,
                                  MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                  ULONG lod, RECTL *pRect)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATESUBTEXCMDI)];
    MCDUPDATESUBTEXCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATESUBTEXCMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_SUB_TEXTURE;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;
    pCmd->lod = lod;
    pCmd->rect = *pRect;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateTexturePalette();
//
// Updates the palette for the specified texture.
//
//**************************************************************************

BOOL APIENTRY MCDUpdateTexturePalette(MCDCONTEXT *pMCDContext,
                                      MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                      ULONG start, ULONG numEntries)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATETEXPALETTECMDI)];
    MCDUPDATETEXPALETTECMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATETEXPALETTECMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_TEXTURE_PALETTE;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;
    pCmd->start = start;
    pCmd->numEntries = numEntries;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateTexturePriority();
//
// Updates the priority for the specified texture.
//
//**************************************************************************

BOOL APIENTRY MCDUpdateTexturePriority(MCDCONTEXT *pMCDContext,
                                       MCDTEXTUREDATA *pTexData,
                                       MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATETEXPRIORITYCMDI)];
    MCDUPDATETEXPRIORITYCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATETEXPRIORITYCMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_TEXTURE_PRIORITY;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateTextureStata();
//
// Updates the state for the specified texture.
//
//**************************************************************************

BOOL APIENTRY MCDUpdateTextureState(MCDCONTEXT *pMCDContext,
                                    MCDTEXTUREDATA *pTexData,
                                    MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATETEXSTATECMDI)];
    MCDUPDATETEXSTATECMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATETEXSTATECMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_TEXTURE_STATE;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// ULONG MCDTextureStatus();
//
// Returns the status for the specified texture.
//
//**************************************************************************

ULONG APIENTRY MCDTextureStatus(MCDCONTEXT *pMCDContext, MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDTEXSTATUSCMDI)];
    MCDTEXSTATUSCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDTEXSTATUSCMDI *)(pmeh + 1);
    pCmd->command = MCD_TEXTURE_STATUS;
    pCmd->hTex = hTex;

    return (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                            sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// ULONG MCDTextureKey();
//
// Returns the driver-managed "key" for the specified texture.
//
//**************************************************************************

ULONG APIENTRY MCDTextureKey(MCDCONTEXT *pMCDContext, MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDTEXKEYCMDI)];
    MCDTEXKEYCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDTEXKEYCMDI *)(pmeh + 1);
    pCmd->command = MCD_GET_TEXTURE_KEY;
    pCmd->hTex = hTex;

    return (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                            sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDescribeMcdLayerPlane(HDC hdc, LONG iPixelFormat,
//                                        LONG iLayerPlane,
//                                        MCDLAYERPLANE *pMcdPixelFmt)
//
// Returns hardware specific information about the specified layer plane.
//
//**************************************************************************

BOOL APIENTRY MCDDescribeMcdLayerPlane(HDC hdc, LONG iPixelFormat,
                                       LONG iLayerPlane,
                                       MCDLAYERPLANE *pMcdLayer)
{
    BOOL bRet = FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDLAYERPLANECMDI)];
    MCDESC_HEADER *pmeh;
    MCDLAYERPLANECMDI *pLayerPlaneCmd;

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pLayerPlaneCmd = (MCDLAYERPLANECMDI *)(pmeh + 1);
    pLayerPlaneCmd->command = MCD_DESCRIBELAYERPLANE;
    pLayerPlaneCmd->iPixelFormat = iPixelFormat;
    pLayerPlaneCmd->iLayerPlane = iLayerPlane;

    bRet = (BOOL)EXTESCAPE(hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, sizeof(MCDLAYERPLANE),
                           (char *)pMcdLayer);

    return bRet;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDescribeLayerPlane(HDC hdc, LONG iPixelFormat,
//                                     LONG iLayerPlane,
//                                     LPLAYERPLANEDESCRIPTOR ppfd)
//
// Returns LAYERPLANEDESCRIPTOR describing the specified layer plane.
//
//**************************************************************************

BOOL APIENTRY MCDDescribeLayerPlane(HDC hdc, LONG iPixelFormat,
                                    LONG iLayerPlane,
                                    LPLAYERPLANEDESCRIPTOR plpd)
{
    BOOL bRet = FALSE;
    MCDLAYERPLANE McdLayer;

    if (!MCDDescribeMcdLayerPlane(hdc, iPixelFormat, iLayerPlane, &McdLayer))
        return bRet;

    if (plpd)
    {
        plpd->nSize    = sizeof(*plpd);
        memcpy(&plpd->nVersion, &McdLayer.nVersion,
               offsetof(LAYERPLANEDESCRIPTOR, cAccumBits) -
               offsetof(LAYERPLANEDESCRIPTOR, nVersion));
        plpd->cAccumBits      = 0;
        plpd->cAccumRedBits   = 0;
        plpd->cAccumGreenBits = 0;
        plpd->cAccumBlueBits  = 0;
        plpd->cAccumAlphaBits = 0;
        plpd->cDepthBits      = 0;
        plpd->cStencilBits    = 0;
        plpd->cAuxBuffers     = McdLayer.cAuxBuffers;
        plpd->iLayerPlane     = McdLayer.iLayerPlane;
        plpd->bReserved       = 0;
        plpd->crTransparent   = McdLayer.crTransparent;

        bRet = TRUE;
    }

    return bRet;
}


//******************************Public*Routine******************************
//
// LONG APIENTRY MCDSetLayerPalette(HDC hdc, BOOL bRealize,
//                                  LONG cEntries, COLORREF *pcr)
//
// Sets the palette of the specified layer plane.
//
//**************************************************************************

LONG APIENTRY MCDSetLayerPalette(HDC hdc, LONG iLayerPlane, BOOL bRealize,
                                 LONG cEntries, COLORREF *pcr)
{
    LONG lRet = 0;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSETLAYERPALCMDI) +
                   (255 * sizeof(COLORREF))];
    BYTE *pjBuffer = (BYTE *) NULL;
    MCDESC_HEADER *pmeh;
    MCDSETLAYERPALCMDI *pSetLayerPalCmd;

    // Use stack allocation if possible; otherwise, allocate heap memory for
    // the command buffer.

    if (cEntries <= 256)
    {
        pmeh = (MCDESC_HEADER *)(cmdBuffer);
    }
    else
    {
        LONG lBytes;

        lBytes = sizeof(MCDESC_HEADER) + sizeof(MCDSETLAYERPALCMDI) +
                 ((cEntries - 1) * sizeof(COLORREF));

        pjBuffer = (BYTE *) LocalAlloc(LMEM_FIXED, lBytes);
        pmeh = (MCDESC_HEADER *)pjBuffer;
    }

    if (pmeh != (MCDESC_HEADER *) NULL)
    {
        InitMcdEscEmpty(pmeh);
        pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

        pSetLayerPalCmd = (MCDSETLAYERPALCMDI *)(pmeh + 1);
        pSetLayerPalCmd->command = MCD_SETLAYERPALETTE;
        pSetLayerPalCmd->iLayerPlane = iLayerPlane;
        pSetLayerPalCmd->bRealize = bRealize;
        pSetLayerPalCmd->cEntries = cEntries;
        memcpy(&pSetLayerPalCmd->acr[0], pcr, cEntries * sizeof(COLORREF));

        lRet = (BOOL)EXTESCAPE(hdc, MCDFUNCS,
                               sizeof(cmdBuffer),
                               (char *)pmeh, 0, (char *)NULL);
    }

    // Delete the heap memory if it was allocated for the command buffer.

    if (pjBuffer)
    {
        LocalFree(pjBuffer);
    }

    return lRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDDrawPixels(MCDCONTEXT *pMCDContext, ULONG width,
//                              ULONG height, ULONG format, ULONG type,
//                              VOID *pPixels, BOOL packed)
//
// MCD version of glDrawPixels
//
//**************************************************************************

ULONG APIENTRY MCDDrawPixels(MCDCONTEXT *pMCDContext, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels, BOOL packed)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDRAWPIXELSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDDRAWPIXELSCMDI *pPixelsCmd;

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return 0;
    }

    pPixelsCmd = (MCDDRAWPIXELSCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_DRAW_PIXELS;
    pPixelsCmd->width = width;
    pPixelsCmd->height = height;
    pPixelsCmd->format = format;
    pPixelsCmd->type = type;
    pPixelsCmd->packed = packed;
    pPixelsCmd->pPixels = pPixels;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDReadPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
//                              ULONG width, ULONG height, ULONG format,
//                              ULONG type, VOID *pPixels)
//
// MCD version of glReadPixels
//
//**************************************************************************

ULONG APIENTRY MCDReadPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG format,
                             ULONG type, VOID *pPixels)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDREADPIXELSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDREADPIXELSCMDI *pPixelsCmd;

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return 0;
    }

    pPixelsCmd = (MCDREADPIXELSCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_READ_PIXELS;
    pPixelsCmd->x = x;
    pPixelsCmd->y = y;
    pPixelsCmd->width = width;
    pPixelsCmd->height = height;
    pPixelsCmd->format = format;
    pPixelsCmd->type = type;
    pPixelsCmd->pPixels = pPixels;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDCopyPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
//                              ULONG width, ULONG height, ULONG type)
//
// MCD version of glCopyPixels
//
//**************************************************************************

ULONG APIENTRY MCDCopyPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG type)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCOPYPIXELSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDCOPYPIXELSCMDI *pPixelsCmd;

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return 0;
    }

    pPixelsCmd = (MCDCOPYPIXELSCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_COPY_PIXELS;
    pPixelsCmd->x = x;
    pPixelsCmd->y = y;
    pPixelsCmd->width = width;
    pPixelsCmd->height = height;
    pPixelsCmd->type = type;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDPixelMap(MCDCONTEXT *pMCDContext, ULONG mapType,
//                            ULONG mapSize, VOID *pMap)
//
// MCD version of glPixelMap
//
//**************************************************************************

ULONG APIENTRY MCDPixelMap(MCDCONTEXT *pMCDContext, ULONG mapType,
                           ULONG mapSize, VOID *pMap)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDPIXELMAPCMDI)];
    MCDESC_HEADER *pmeh;
    MCDPIXELMAPCMDI *pPixelsCmd;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pPixelsCmd = (MCDPIXELMAPCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_PIXEL_MAP;
    pPixelsCmd->mapType = mapType;
    pPixelsCmd->mapSize = mapSize;
    pPixelsCmd->pMap = pMap;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// MCDDestroyWindow
//
// Forwards user-mode window destruction notification to the server for
// resource cleanup
//
//**************************************************************************

void APIENTRY MCDDestroyWindow(HDC hdc, ULONG_PTR dwMcdWindow)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDPIXELMAPCMDI)];
    MCDESC_HEADER *pmeh;
    MCDDESTROYWINDOWCMDI *pmdwc;

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)cmdBuffer);
    pmeh->dwWindow = dwMcdWindow;
    pmeh->flags = 0;

    pmdwc = (MCDDESTROYWINDOWCMDI *)(pmeh + 1);
    pmdwc->command = MCD_DESTROY_WINDOW;

    EXTESCAPE(hdc, MCDFUNCS,
              sizeof(cmdBuffer), (char *)pmeh,
              0, (char *)NULL);
}

//******************************Public*Routine******************************
//
// MCDGetTextureFormats
//
//**************************************************************************

int APIENTRY MCDGetTextureFormats(MCDCONTEXT *pMCDContext, int nFmts,
                                  struct _DDSURFACEDESC *pddsd)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDGETTEXTUREFORMATSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDGETTEXTUREFORMATSCMDI *pmgtf;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pmgtf = (MCDGETTEXTUREFORMATSCMDI *)(pmeh + 1);
    pmgtf->command = MCD_GET_TEXTURE_FORMATS;
    pmgtf->nFmts = nFmts;

    return (int)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                          sizeof(cmdBuffer), (char *)pmeh,
                          nFmts*sizeof(DDSURFACEDESC), (char *)pddsd);
}

//******************************Public*Routine******************************
//
// MCDSwapMultiple
//
//**************************************************************************

DWORD APIENTRY MCDSwapMultiple(HDC hdc, UINT cBuffers, GENMCDSWAP *pgms)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER)+
                   sizeof(HDC)*MCDESC_MAX_EXTRA_WNDOBJ+
                   sizeof(MCDSWAPMULTIPLECMDI)];
    MCDSWAPMULTIPLECMDI *pSwapMultCmd;
    MCDESC_HEADER *pmeh;
    UINT i;
    HDC *phdc;

    // InitMcdEscSurfaces cannot be used because the context given
    // is a temporary one constructed on the fly since SwapBuffers
    // has only surface information.
    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)cmdBuffer);
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK | MCDESC_FL_EXTRA_WNDOBJ;
    pmeh->cExtraWndobj = cBuffers;

    phdc = (HDC *)(pmeh+1);
    pSwapMultCmd = (MCDSWAPMULTIPLECMDI *)((BYTE *)phdc+cBuffers*sizeof(HDC));
    pSwapMultCmd->command = MCD_SWAP_MULTIPLE;
    pSwapMultCmd->cBuffers = cBuffers;

    for (i = 0; i < cBuffers; i++)
    {
        *phdc++ = pgms->pwswap->hdc;
        pSwapMultCmd->auiFlags[i] = pgms->pwswap->uiFlags;
        pSwapMultCmd->adwMcdWindow[i] = pgms->pwnd->dwMcdWindow;
    }

    return (DWORD)EXTESCAPE(hdc, MCDFUNCS, sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// MCDProcessBatch2
//
// Processes a batch of primitives pointed to by pMCDMem.
// This is the 2.0 front-end processing entry point.
//
// Returns last command processed or NULL if all are processed.
//
//**************************************************************************

PVOID APIENTRY MCDProcessBatch2(MCDCONTEXT *pMCDContext,
                                VOID *pMCDCmdMem,
                                VOID *pMCDPrimMem,
                                MCDCOMMAND *pMCDFirstCmd,
                                int cExtraSurfaces,
                                LPDIRECTDRAWSURFACE *pdds,
                                ULONG cmdFlagsAll,
                                ULONG primFlags,
                                MCDTRANSFORM *pMCDTransform,
                                MCDMATERIALCHANGES *pMCDMatChanges)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER)+
                   MCD_MAXMIPMAPLEVEL*sizeof(DWORD)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDCmdMemHdr, *pMCDPrimMemHdr;
    int i;
    ULONG_PTR *pdwSurf;
    MCDPROCESSCMDI *pProcessCmd;

    // Version is checked in mcdcx.c.
    ASSERTOPENGL(SUPPORTS_20(), "MCDProcessBatch2 requires 2.0\n");
    // This function requires 2.0 so direct support should also exist.
    ASSERTOPENGL(SUPPORTS_DIRECT(), "MCDProcessBatch2 requires direct\n");

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_PROCBATCH)
    {
        MCDSync(pMCDContext);
        return pMCDFirstCmd;
    }
#endif

    pMCDCmdMemHdr = (MCDMEMHDRI *)((char *)pMCDCmdMem - sizeof(MCDMEMHDRI));
    pMCDPrimMemHdr = (MCDMEMHDRI *)((char *)pMCDPrimMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = pMCDCmdMemHdr->hMCDMem;
    pmeh->pSharedMem = (char *)pMCDCmdMem;
    pmeh->sharedMemSize = sizeof(MCDPROCESSCMDI);
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK |
        MCDESC_FL_SURFACES | MCDESC_FL_LOCK_SURFACES;

    // Assert that we won't exceed the kernel's expectations
    ASSERTOPENGL(MCD_MAXMIPMAPLEVEL <= MCDESC_MAX_LOCK_SURFACES,
                 "MCD_MAXMIPMAPLEVEL too large\n");

    pmeh->cLockSurfaces = cExtraSurfaces;
    pdwSurf = (ULONG_PTR *)(pmeh+1);
    for (i = 0; i < cExtraSurfaces; i++)
    {
        *pdwSurf++ = ((LPDDRAWI_DDRAWSURFACE_INT)pdds[i])->lpLcl->hDDSurface;
    }

    pProcessCmd = (MCDPROCESSCMDI *)pMCDCmdMem;
    pProcessCmd->command = MCD_PROCESS;
    pProcessCmd->hMCDPrimMem = pMCDPrimMemHdr->hMCDMem;
    pProcessCmd->pMCDFirstCmd = pMCDFirstCmd;
    pProcessCmd->cmdFlagsAll = cmdFlagsAll;
    pProcessCmd->primFlags = primFlags;
    pProcessCmd->pMCDTransform = pMCDTransform;
    pProcessCmd->pMCDMatChanges = pMCDMatChanges;

    return (PVOID)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                     sizeof(cmdBuffer), (char *)pmeh,
                                     0, (char *)NULL) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\inc\mcd.h ===
/******************************Module*Header*******************************\
* Module Name: mcd.h
*
* Common data structures for MCD driver interface.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCD_H
#define _MCD_H

//
// Maximum MCD scanline size assumed by OpenGL generic implementation.
//
#define MCD_MAX_SCANLINE    4096

#define MCD_MEM_READY   0x0001
#define MCD_MEM_BUSY    0x0002
#define MCD_MEM_INVALID 0x0003

#define MCD_MAXMIPMAPLEVEL 12

typedef struct _MCDCONTEXT {
    HDC hdc;
    MCDHANDLE hMCDContext;
    LONG ipfd;
    LONG iLayer;
    ULONG_PTR dwMcdWindow;
} MCDCONTEXT;

typedef struct _MCDRCINFOPRIV {
    MCDRCINFO mri;
    ULONG_PTR dwMcdWindow;
} MCDRCINFOPRIV;

typedef struct _GENMCDSWAP
{
    struct GLGENwindowRec *pwnd;
    WGLSWAP *pwswap;
} GENMCDSWAP;

typedef struct _GENMCDSTATE_ GENMCDSTATE;

//
// Shared memory allocated/freed via MCDAlloc and MCDFree, respectively.
//

typedef struct _GENMCDBUF_ {
    PVOID pv;
    ULONG size;
    HANDLE hmem;
} GENMCDBUF;

//
// The GENMCDSURFACE retains information about the state of the MCD buffers
// or surface.  It exists per-WNDOBJ (window).
//

typedef struct _GENMCDSURFACE_ {
    GENMCDBUF  McdColorBuf;     // Color and depth span buffers used to
    GENMCDBUF  McdDepthBuf;     // read/write MCD buffers if not directly
                                // accessible.

    ULONG *pDepthSpan;          // Interchange buffer to present z-span in
                                // generic format.  If McdDepthBuf is 32-bit,
                                // then this points to it (reformatted in
                                // place).  If 16-bit, then the interchange
                                // buffer is allocated separately.

    ULONG      depthBitMask;

    struct GLGENwindowRec *pwnd;          // WNDOBJ this surface is bound to.

} GENMCDSURFACE;

//
// The GENMCDSTATE retains information about the state of the MCD context.
// It exists per-context.
//

typedef struct _GENMCDSTATE_ {
    MCDCONTEXT McdContext;      // Created via MCDCreateContext.
                                // NOTE: This must be the first field.

    GENMCDSURFACE *pMcdSurf;    // pointer to MCD surface

    GENMCDBUF  *pMcdPrimBatch;  // Current shared memory window for batching
                                // primitives

    GENMCDBUF  McdCmdBatch;     // Used to pass state to MCD driver.

    ULONG      mcdDirtyState;   // Set of flags that tracks when MCD state
                                // is out of sync (i.e., "dirty") with respect
                                // to generic state.

    ULONG *pDepthSpan;          // Cached copy of the one in GENMCDSURFACE.

                                // Fallback z-test span function.
    void *softZSpanFuncPtr;

    GENMCDBUF  McdBuf1;         // If using DMA, we swap pMcdPrimBatch
    GENMCDBUF  McdBuf2;         // between these two buffers.  Otherwise,
                                // only McdBuf1 is initialized.

    MCDRCINFO McdRcInfo;        // Cache a copy of the MCD RC info structure.

    MCDRECTBUFFERS McdBuffers;  // Describes accessibility of MCD buffers.

    ULONG mcdFlags;             // Misc. other state flags.

    MCDPIXELFORMAT McdPixelFmt; // Cache a copy of the MCD pixel format.

    HANDLE hDdColor;            // Kernel-mode handles for DirectDraw
    HANDLE hDdDepth;
} GENMCDSTATE;

//
// Misc. flags for GENMCDSTATE.mcdFlags:
//

#define MCD_STATE_FORCEPICK     0x00000001
#define MCD_STATE_FORCERESIZE   0x00000002

//
// Dirty state flags for GENMCDSTATE.mcdDirtyState:
//

#define MCD_DIRTY_ENABLES               0x00000001
#define MCD_DIRTY_TEXTURE               0x00000002
#define MCD_DIRTY_FOG                   0x00000004
#define MCD_DIRTY_SHADEMODEL            0x00000008
#define MCD_DIRTY_POINTDRAW             0x00000010
#define MCD_DIRTY_LINEDRAW              0x00000020
#define MCD_DIRTY_POLYDRAW              0x00000040
#define MCD_DIRTY_ALPHATEST             0x00000080
#define MCD_DIRTY_DEPTHTEST             0x00000100
#define MCD_DIRTY_BLEND                 0x00000200
#define MCD_DIRTY_LOGICOP               0x00000400
#define MCD_DIRTY_FBUFCTRL              0x00000800
#define MCD_DIRTY_LIGHTMODEL            0x00001000
#define MCD_DIRTY_HINTS                 0x00002000
#define MCD_DIRTY_VIEWPORT              0x00004000
#define MCD_DIRTY_SCISSOR               0x00008000
#define MCD_DIRTY_CLIPCTRL              0x00010000
#define MCD_DIRTY_STENCILTEST           0x00020000
#define MCD_DIRTY_PIXELSTATE            0x00040000
#define MCD_DIRTY_TEXENV                0x00080000
#define MCD_DIRTY_TEXTRANSFORM          0x00100000
#define MCD_DIRTY_TEXGEN                0x00200000
#define MCD_DIRTY_MATERIAL              0x00400000
#define MCD_DIRTY_LIGHTS                0x00800000
#define MCD_DIRTY_COLORMATERIAL         0x01000000

#define MCD_DIRTY_RENDERSTATE           0x0003ffff
#define MCD_DIRTY_ALL                   0x01ffffff


// Internal driver information structure
typedef struct _MCDDRIVERINFOI {
    MCDDRIVERINFO mcdDriverInfo;
    MCDDRIVER mcdDriver;
} MCDDRIVERINFOI;


//
// Return values for MCDLock.
// Zero must be used for the system error because it may be returned
// from ExtEscape if the system is unable to make the escape call.
//
#define MCD_LOCK_SYSTEM_ERROR   0
#define MCD_LOCK_BUSY           1
#define MCD_LOCK_TAKEN          2

BOOL APIENTRY MCDGetDriverInfo(HDC hdc, struct _MCDDRIVERINFOI *pMCDDriverInfo);
LONG APIENTRY MCDDescribeMcdPixelFormat(HDC hdc, LONG iPixelFormat,
                                        MCDPIXELFORMAT *pMcdPixelFmt);
LONG APIENTRY MCDDescribePixelFormat(HDC hdc, LONG iPixelFormat,
                                     LPPIXELFORMATDESCRIPTOR ppfd);
BOOL APIENTRY MCDCreateContext(MCDCONTEXT *pMCDContext,
                               MCDRCINFOPRIV *pDrvRcInfo,
                               struct _GLSURF *pgsurf,
                               int ipfd,
                               ULONG flags);
BOOL APIENTRY MCDDeleteContext(MCDCONTEXT *pMCDContext);
UCHAR * APIENTRY MCDAlloc(MCDCONTEXT *pMCDContext, ULONG numBytes, MCDHANDLE *pMCDHandle, 
                          ULONG flags);
BOOL APIENTRY MCDFree(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
VOID APIENTRY MCDBeginState(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
BOOL APIENTRY MCDFlushState(VOID *pMCDMem);
BOOL APIENTRY MCDAddState(VOID *pMCDMem, ULONG stateToChange,
                          ULONG stateValue);
BOOL APIENTRY MCDAddStateStruct(VOID *pMCDMem, ULONG stateToChange,
                                VOID *pStateValue, ULONG stateValueSize);
BOOL APIENTRY MCDSetViewport(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                             MCDVIEWPORT *pMCDViewport);
BOOL APIENTRY MCDSetScissorRect(MCDCONTEXT *pMCDContext, RECTL *pRect,
                                BOOL bEnabled);
ULONG APIENTRY MCDQueryMemStatus(VOID *pMCDMem);
PVOID APIENTRY MCDProcessBatch(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                               ULONG batchSize, VOID *pMCDFirstCmd,
                               int cExtraSurfaces,
                               struct IDirectDrawSurface **pddsExtra);
BOOL APIENTRY MCDReadSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                          ULONG x, ULONG y, ULONG numPixels, ULONG type);
BOOL APIENTRY MCDWriteSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                           ULONG x, ULONG y, ULONG numPixels, ULONG type);
BOOL APIENTRY MCDClear(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers);
BOOL APIENTRY MCDSwap(MCDCONTEXT *pMCDContext, ULONG flags);
BOOL APIENTRY MCDGetBuffers(MCDCONTEXT *pMCDContext,
                            MCDRECTBUFFERS *pMCDBuffers);
BOOL APIENTRY MCDAllocBuffers(MCDCONTEXT *pMCDContext, RECTL *pWndRect);
BOOL APIENTRY MCDBindContext(MCDCONTEXT *pMCDContext, HDC hdc,
                             struct GLGENwindowRec *pwnd);
BOOL APIENTRY MCDSync(MCDCONTEXT *pMCDContext);
MCDHANDLE APIENTRY MCDCreateTexture(MCDCONTEXT *pMCDContext, 
                                    MCDTEXTUREDATA *pTexData,
                                    ULONG flags,
                                    VOID *pSurface);
BOOL APIENTRY MCDDeleteTexture(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
BOOL APIENTRY MCDUpdateSubTexture(MCDCONTEXT *pMCDContext,
                                  MCDTEXTUREDATA *pTexData, MCDHANDLE hTex, 
                                  ULONG lod, RECTL *pRect);
BOOL APIENTRY MCDUpdateTexturePalette(MCDCONTEXT *pMCDContext, 
                                      MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                      ULONG start, ULONG numEntries);
BOOL APIENTRY MCDUpdateTexturePriority(MCDCONTEXT *pMCDContext, 
                                       MCDTEXTUREDATA *pTexData,
                                       MCDHANDLE hTex);
BOOL APIENTRY MCDUpdateTextureState(MCDCONTEXT *pMCDContext, 
                                    MCDTEXTUREDATA *pTexData,
                                    MCDHANDLE hTex);
ULONG APIENTRY MCDTextureStatus(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
ULONG APIENTRY MCDTextureKey(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
BOOL APIENTRY MCDDescribeMcdLayerPlane(HDC hdc, LONG iPixelFormat,
                                       LONG iLayerPlane,
                                       MCDLAYERPLANE *pMcdPixelFmt);
BOOL APIENTRY MCDDescribeLayerPlane(HDC hdc, LONG iPixelFormat,
                                    LONG iLayerPlane,
                                    LPLAYERPLANEDESCRIPTOR ppfd);
LONG APIENTRY MCDSetLayerPalette(HDC hdc, LONG iLayerPlane, BOOL bRealize,
                                 LONG cEntries, COLORREF *pcr);
ULONG APIENTRY MCDDrawPixels(MCDCONTEXT *pMCDContext, ULONG width, ULONG height,
                             ULONG format, ULONG type, VOID *pPixels, BOOL packed);
ULONG APIENTRY MCDReadPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width, ULONG height,
                             ULONG format, ULONG type, VOID *pPixels);
ULONG APIENTRY MCDCopyPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width, ULONG height,
                             ULONG type);
ULONG APIENTRY MCDPixelMap(MCDCONTEXT *pMCDContext, ULONG mapType, ULONG mapSize,
                           VOID *pMap);
void APIENTRY MCDDestroyWindow(HDC hdc, ULONG_PTR dwMcdWindow);
int APIENTRY MCDGetTextureFormats(MCDCONTEXT *pMCDContext, int nFmts,
                                  struct _DDSURFACEDESC *pddsd);
ULONG APIENTRY MCDLock(MCDCONTEXT *pMCDContext);
VOID APIENTRY MCDUnlock(MCDCONTEXT *pMCDContext);

#ifdef MCD95
typedef LPCRITICAL_SECTION (APIENTRY *MCDGETMCDCRITSECTFUNC)(void);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\inc\mcd2hack.h ===
/******************************Module*Header*******************************\
* Module Name: mcdrv.h
*
* Server-side data structure for MCD driver interface.  These structures and
* values are used by the MCD driver to process calls made to the driver.
*
* Copyright (c) 1996-1997 Microsoft Corporation
*
* This is a private copy of mcdrv.h with all the 1.0 stuff
* stripped out.  It allows OpenGL to build for MCD 2.0 even though the
* public header file doesn't include the necessary information.
* Some things changed from 1.0 on and these cannot be redefined in
* a safe manner so they are not present here, causing some weirdness in
* the code but much less than ifdefing everything.
*
\**************************************************************************/

#ifndef _MCD2HACK_H
#define _MCD2HACK_H

#define MCD_MAX_LIGHTS              8

// MCDTEXTURE create flags
#define MCDTEXTURE_DIRECTDRAW_SURFACES          0x00000001


//
// Different matrix forms, for optimizing transforms.
// Types go from most general to least general.
//

// No information about matrix type
#define MCDMATRIX_GENERAL       0

// W row is 0 0 0 1
#define MCDMATRIX_W0001         1

// 2D matrix terms only
#define MCDMATRIX_2D            2

// 2D non-rotational matrix
#define MCDMATRIX_2DNR          3

// Identity
#define MCDMATRIX_IDENTITY      4

//
// A 4x4 matrix augmented with additional information about its layout.
//
// matrixType is one of the above matrix types.
// nonScaling is TRUE if the diagonal terms are one.
//

typedef struct _MCDMATRIX {
    MCDFLOAT matrix[4][4];
    ULONG matrixType;
    ULONG reserved[5];
    BOOL nonScaling;    
} MCDMATRIX;    


//
// Texture generation information for a single coordinate.
//

typedef struct _MCDTEXTURECOORDGENERATION {
    ULONG mode;
    MCDCOORD eyePlane;          // Given by program
    MCDCOORD eyePlaneInv;       // eyePlane transformed by modelview inverse
    MCDCOORD objectPlane;
} MCDTEXTURECOORDGENERATION;


//
// Light source description.
//

typedef struct _MCDLIGHT {
    MCDCOLOR ambient;           // Scaled
    MCDCOLOR diffuse;           // Scaled
    MCDCOLOR specular;          // Scaled
    MCDCOORD position;          // Given by program
    MCDCOORD positionEye;       // position transformed by modelview
    MCDCOORD direction;         // Given by program
    MCDCOORD directionInv;      // direction transformed by modelview inverse,
                                // normalized
    MCDFLOAT spotLightExponent;
    MCDFLOAT spotLightCutOffAngle;
    MCDFLOAT constantAttenuation;
    MCDFLOAT linearAttenuation;
    MCDFLOAT quadraticAttenuation;
} MCDLIGHT;


//
// Material description.
//

typedef struct _MCDMATERIAL {
    MCDCOLOR ambient;                   // Unscaled
    MCDCOLOR diffuse;                   // Unscaled
    MCDCOLOR specular;                  // Unscaled
    MCDCOLOR emissive;                  // Scaled
    MCDFLOAT specularExponent; 
    MCDFLOAT ambientColorIndex;
    MCDFLOAT diffuseColorIndex;
    MCDFLOAT specularColorIndex;
} MCDMATERIAL;


#define MCD_TEXTURE_TRANSFORM_STATE     20
#define MCD_TEXTURE_GENERATION_STATE    21
#define MCD_MATERIAL_STATE              22
#define MCD_LIGHT_SOURCE_STATE          23
#define MCD_COLOR_MATERIAL_STATE        24


// Texture transform state.
typedef struct _MCDTEXTURETRANSFORMSTATE {
    MCDMATRIX transform;
} MCDTEXTURETRANSFORMSTATE;

// Texture generation state.
typedef struct _MCDTEXTUREGENERATIONSTATE {
    MCDTEXTURECOORDGENERATION s, t, r, q;
} MCDTEXTUREGENERATIONSTATE;

// Material state.
typedef struct _MCDMATERIALSTATE {
    MCDMATERIAL materials[2];
} MCDMATERIALSTATE;
    
// Light source state.
typedef struct _MCDLIGHTSOURCESTATE {
    ULONG enables;
    ULONG changed;
    // Followed by one MCDLIGHT structure per set bit
    // in changed, starting from bit 0.  changed may be zero
    // if only the enables changed.
} MCDLIGHTSOURCESTATE;

// ColorMaterial state.
typedef struct _MCDCOLORMATERIALSTATE {
    ULONG face;
    ULONG mode;
} MCDCOLORMATERIALSTATE;
        

typedef struct _MCDRECTBUF {
    ULONG bufFlags;
    LONG  bufOffset;        // offset relative to beginning of framebuffer
    LONG  bufStride;
    RECTL bufPos;
} MCDRECTBUF;

typedef struct _MCDRECTBUFFERS {
    MCDRECTBUF mcdFrontBuf;
    MCDRECTBUF mcdBackBuf;
    MCDRECTBUF mcdDepthBuf;
} MCDRECTBUFFERS;


#define MCDSURFACE_DIRECT           0x00000002

// User-defined clip plane bits starting position
#define MCD_CLIP_USER0          0x00000040

#define MCDVERTEX_EDGEFLAG_VALID        0x00000002
#define MCDVERTEX_COLOR_VALID           0x00000004
#define MCDVERTEX_NORMAL_VALID          0x00000008
#define MCDVERTEX_TEXTURE_VALID         0x00000010
#define MCDVERTEX_VERTEX2               0x00000020 // same as MCDCOMMAND
#define MCDVERTEX_VERTEX3               0x00000040 // same as MCDCOMMAND
#define MCDVERTEX_VERTEX4               0x00000080 // same as MCDCOMMAND
#define MCDVERTEX_MATERIAL_FRONT    	0x10000000 // same as MCDCOMMAND
#define MCDVERTEX_MATERIAL_BACK    	0x20000000 // same as MCDCOMMAND

#define MCDCOMMAND_PRIMITIVE_CONTINUED  0x00000008
#define MCDCOMMAND_PRIMITIVE_INCOMPLETE 0x00000010
#define MCDCOMMAND_VERTEX2           	0x00000020 // same as MCDVERTEX
#define MCDCOMMAND_VERTEX3           	0x00000040 // same as MCDVERTEX
#define MCDCOMMAND_VERTEX4           	0x00000080 // same as MCDVERTEX
#define MCDCOMMAND_TEXTURE1          	0x00100000
#define MCDCOMMAND_TEXTURE2          	0x00200000
#define MCDCOMMAND_TEXTURE3          	0x00400000
#define MCDCOMMAND_TEXTURE4          	0x00800000
#define MCDCOMMAND_MATERIAL_FRONT    	0x10000000 // same as MCDVERTEX
#define MCDCOMMAND_MATERIAL_BACK    	0x20000000 // same as MCDVERTEX


//
// Primitive type bits for indicating what kinds of primitives are in
// a command batch:
//

#define MCDPRIM_POINTS_BIT              0x00000001
#define MCDPRIM_LINES_BIT               0x00000002
#define MCDPRIM_LINE_LOOP_BIT           0x00000004
#define MCDPRIM_LINE_STRIP_BIT          0x00000008
#define MCDPRIM_TRIANGLES_BIT           0x00000010
#define MCDPRIM_TRIANGLE_STRIP_BIT      0x00000020
#define MCDPRIM_TRIANGLE_FAN_BIT        0x00000040
#define MCDPRIM_QUADS_BIT               0x00000080
#define MCDPRIM_QUAD_STRIP_BIT          0x00000100
#define MCDPRIM_POLYGON_BIT             0x00000200


//
// Current transform information for MCD 2.0.
// The first matrix is the model-view matrix.
// The second matrix is the MV matrix composed with the current projection
// matrix.
//
// flags indicates whether the mvp matrix has changed since the last
// time it was presented to the driver.
//

#define MCDTRANSFORM_CHANGED    0x00000001

typedef struct _MCDTRANSFORM {
    MCDMATRIX matrix;
    MCDMATRIX mvp;
    ULONG flags;
} MCDTRANSFORM;


//
// Bit values for changes to materials.
//

#define MCDMATERIAL_AMBIENT		0x00000001
#define MCDMATERIAL_DIFFUSE		0x00000002
#define MCDMATERIAL_SPECULAR		0x00000004
#define MCDMATERIAL_EMISSIVE		0x00000008
#define MCDMATERIAL_SPECULAREXPONENT    0x00000010
#define MCDMATERIAL_COLORINDEXES	0x00000020
#define MCDMATERIAL_ALL		        0x0000003f

//
// Material change description.
//

typedef struct _MCDMATERIALCHANGE {
    ULONG dirtyBits;
    MCDCOLOR ambient;
    MCDCOLOR diffuse;
    MCDCOLOR specular;
    MCDCOLOR emissive;
    MCDFLOAT specularExponent; 
    MCDFLOAT ambientColorIndex;
    MCDFLOAT diffuseColorIndex;
    MCDFLOAT specularColorIndex;
} MCDMATERIALCHANGE;

//
// Material changes for both faces.
//

typedef struct _MCDMATERIALCHANGES {
    MCDMATERIALCHANGE *front, *back;
} MCDMATERIALCHANGES;


typedef int      (*MCDRVGETTEXTUREFORMATSFUNC)(MCDSURFACE *pMcdSurface,
                                               int nFmts,
                                               struct _DDSURFACEDESC *pddsd);
typedef ULONG_PTR (*MCDRVSWAPMULTIPLEFUNC)(SURFOBJ *pso,
                                          UINT cBuffers,
                                          MCDWINDOW **pMcdWindows,
                                          UINT *puiFlags);
typedef ULONG_PTR (*MCDRVPROCESSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc,
                                     MCDMEM *pMCDExecMem,
                                     UCHAR *pStart, UCHAR *pEnd,
                                     ULONG cmdFlagsAll, ULONG primFlags,
                                     MCDTRANSFORM *pMCDTransform,
                                     MCDMATERIALCHANGES *pMCDMatChanges);

#define MCDDRIVER_V11_SIZE      (MCDDRIVER_V10_SIZE+2*sizeof(void *))
#define MCDDRIVER_V20_SIZE      (MCDDRIVER_V11_SIZE+1*sizeof(void *))

#endif // _MCD2HACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\inc\mcdint.h ===
/******************************Module*Header*******************************\
* Module Name: mcdint.h
*
* Internal client/server-side data structure for MCD driver interface.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

// Private flags for initialization (registry)

#define MCDPRIVATE_MCD_ENABLED          0x0001
#define MCDPRIVATE_PALETTEFORMATS       0x0002
#define MCDPRIVATE_USEGENERICSTENCIL    0x0004
#define MCDPRIVATE_EMULATEICD           0x0008

#ifdef MCD95
// Cross-process named mutex.

#define MCDMUTEXNAME    TEXT("MCDSRV32 Interprocess Synchronization Object")
#endif

// Internal command codes

#define MCD_DESCRIBEPIXELFORMAT     0x10001
#define MCD_DRIVERINFO              0x10002
#define MCD_ALLOC                   0x10003
#define MCD_FREE                    0x10004
#define MCD_STATE                   0x10005
#define MCD_VIEWPORT                0x10006
#define MCD_QUERYMEMSTATUS          0x10007
#define MCD_READSPAN                0x10008
#define MCD_WRITESPAN               0x10009
#define MCD_CLEAR                   0x1000a
#define MCD_SWAP                    0x1000b
#define MCD_SCISSOR                 0x1000c
#define MCD_DELETERC                0x1000d
#define MCD_GETBUFFERS              0x1000e
#define MCD_ALLOCBUFFERS            0x1000f
#define MCD_LOCK                    0x10010
#define MCD_UNLOCK                  0x10011
#define MCD_BINDCONTEXT		    0x10012
#define MCD_SYNC		    0x10013
#define MCD_CREATE_TEXTURE          0x10014
#define MCD_DELETE_TEXTURE          0x10015
#define MCD_UPDATE_SUB_TEXTURE      0x10016
#define MCD_UPDATE_TEXTURE_PALETTE  0x10017
#define MCD_UPDATE_TEXTURE_PRIORITY 0x10018
#define MCD_UPDATE_TEXTURE_STATE    0x10019
#define MCD_TEXTURE_STATUS          0x1001a
#define MCD_GET_TEXTURE_KEY         0x1001b
#define MCD_DESCRIBELAYERPLANE      0x1001c
#define MCD_SETLAYERPALETTE         0x1001d
#define MCD_DRAW_PIXELS             0x1001e
#define MCD_READ_PIXELS             0x1001f
#define MCD_COPY_PIXELS             0x10020
#define MCD_PIXEL_MAP               0x10021
#define MCD_DESTROY_WINDOW          0x10022
#define MCD_GET_TEXTURE_FORMATS     0x10023
#define MCD_SWAP_MULTIPLE           0x10024
#define MCD_PROCESS                 0x10025

// Internal command structures for calling through client-server layer

typedef struct _MCDCREATECONTEXT {
    // Must be first element for MCDESC compatibility.
    MCDESC_CREATE_CONTEXT escCreate;
    int ipfd;
    int iLayer;
    ULONG mcdFlags;
    MCDRCINFOPRIV *pRcInfo;
} MCDCREATECONTEXT;

typedef struct _MCDCMDI {
    ULONG command;
} MCDCMDI;

typedef struct _MCDDRIVERINFOCMDI {
    ULONG command;
} MCDDRIVERINFOCMDI;

typedef struct _MCDPIXELFORMATCMDI {
    ULONG command;
    LONG iPixelFormat;
} MCDPIXELFORMATCMDI;

typedef struct _MCDALLOCCMDI {
    ULONG command;
    ULONG sourceProcessID;
    ULONG numBytes;
    ULONG flags;
} MCDALLOCCMDI;

typedef struct _MCDFREECMDI {
    ULONG command;
    HANDLE hMCDMem;
} MCDFREECMDI;

typedef struct _MCDSTATECMDI {
    ULONG command;
    ULONG numStates;
    MCDSTATE *pNextState;
    MCDSTATE *pMaxState;
} MCDSTATECMDI;

typedef struct _MCDVIEWPORTCMDI {
    ULONG command;
    MCDVIEWPORT MCDViewport;
} MCDVIEWPORTCMDI;

typedef struct _MCDMEMSTATUSCMDI {
    ULONG command;
    MCDHANDLE hMCDMem;
} MCDMEMSTATUSCMDI;

typedef struct _MCDSPANCMDI {
    ULONG command;
    HANDLE hMem;
    MCDSPAN MCDSpan;
} MCDSPANCMDI;

typedef struct _MCDCLEARCMDI {
    ULONG command;
    ULONG buffers;
} MCDCLEARCMDI;

typedef struct _MCDSCISSORCMDI {
    ULONG command;
    RECTL rect;
    BOOL bEnabled;
} MCDSCISSORCMDI;

typedef struct _MCDSWAPCMDI {
    ULONG command;
    ULONG flags;
} MCDSWAPCMDI;

typedef struct _MCDDELETERCCMDI {
    ULONG command;
} MCDDELETERCCMDI;

typedef struct _MCDGETBUFFERSCMDI {
    ULONG command;
    BOOL getRect;
} MCDGETBUFFERSCMDI;

typedef struct _MCDALLOCBUFFERSCMDI {
    ULONG command;
    RECTL WndRect;
} MCDALLOCBUFFERSCMDI;

typedef struct _MCDLOCKCMDI {
    ULONG command;
} MCDLOCKCMDI;

typedef struct _MCDBINDCONTEXTCMDI {
    ULONG command;
    HWND hWnd;
} MCDBINDCONTEXTCMDI;

typedef struct _MCDSYNCCMDI {
    ULONG command;
} MCDSYNCCMDI;

typedef struct _MCDCREATETEXCMDI {
    ULONG command;
    MCDTEXTUREDATA *pTexData;
    ULONG flags;
    VOID *pSurface;
} MCDCREATETEXCMDI;

typedef struct _MCDDELETETEXCMDI {
    ULONG command;
    MCDHANDLE hTex;
} MCDDELETETEXCMDI;

typedef struct _MCDUPDATESUBTEXCMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
    ULONG lod;
    RECTL rect;
} MCDUPDATESUBTEXCMDI;

typedef struct _MCDUPDATETEXPALETTECMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
    ULONG start;
    ULONG numEntries;
} MCDUPDATETEXPALETTECMDI;
    
typedef struct _MCDUPDATETEXPRIORITYCMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
} MCDUPDATETEXPRIORITYCMDI;
  
typedef struct _MCDUPDATETEXSTATECMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
} MCDUPDATETEXSTATECMDI;
  
typedef struct _MCDTEXSTATUSCMDI {
    ULONG command;
    MCDHANDLE hTex;
} MCDTEXSTATUSCMDI;

typedef struct _MCDTEXKEYCMDI {
    ULONG command;
    MCDHANDLE hTex;
} MCDTEXKEYCMDI;

typedef struct _MCDLAYERPLANECMDI {
    ULONG command;
    LONG iPixelFormat;
    LONG iLayerPlane;
} MCDLAYERPLANECMDI;

typedef struct _MCDSETLAYERPALCMDI {
    ULONG command;
    LONG iLayerPlane;
    BOOL bRealize;
    LONG cEntries;
    COLORREF acr[1];
} MCDSETLAYERPALCMDI;

typedef struct _MCDDRAWPIXELSCMDI {
    ULONG command;
    ULONG width;
    ULONG height;
    ULONG format;
    ULONG type;
    BOOL  packed;
    VOID *pPixels;
} MCDDRAWPIXELSCMDI;

typedef struct _MCDREADPIXELSCMDI {
    ULONG command;
    LONG  x;
    LONG  y;
    ULONG width;
    ULONG height;
    ULONG format;
    ULONG type;
    VOID *pPixels;
} MCDREADPIXELSCMDI;

typedef struct _MCDCOPYPIXELSCMDI {
    ULONG command;
    LONG  x;
    LONG  y;
    ULONG width;
    ULONG height;
    ULONG format;
    ULONG type;
} MCDCOPYPIXELSCMDI;

typedef struct _MCDPIXELMAPCMDI {
    ULONG command;
    ULONG mapType;
    ULONG mapSize;
    VOID *pMap;
} MCDPIXELMAPCMDI;

typedef struct _MCDDESTROYWINDOWCMDI {
    ULONG command;
} MCDDESTROYWINDOWCMDI;

typedef struct _MCDGETTEXTUREFORMATSCMDI {
    ULONG command;
    int nFmts;
} MCDGETTEXTUREFORMATSCMDI;

typedef struct _MCDSWAPMULTIPLECMDI {
    ULONG command;
    UINT cBuffers;
    UINT auiFlags[MCDESC_MAX_EXTRA_WNDOBJ];
    ULONG_PTR adwMcdWindow[MCDESC_MAX_EXTRA_WNDOBJ];
} MCDSWAPMULTIPLECMDI;

typedef struct _MCDPROCESSCMDI {
    ULONG command;
    HANDLE hMCDPrimMem;
    MCDCOMMAND *pMCDFirstCmd;
    ULONG cmdFlagsAll;
    ULONG primFlags;
    MCDTRANSFORM *pMCDTransform;
    MCDMATERIALCHANGES *pMCDMatChanges;
} MCDPROCESSCMDI;

// Internal client-side memory structure

typedef struct _MCDMEMHDRI {
    ULONG flags;
    ULONG numBytes;
    VOID *maxMem;
    HANDLE hMCDMem;
    UCHAR *pMaxMem;
    UCHAR *pBase;
    MCDCONTEXT *pMCDContext;
} MCDMEMHDRI;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\inc\mcdrvint.h ===
/******************************Module*Header*******************************\
* Module Name: mcdrvint.h
*
* Internal server-side data structure for MCD driver interface.  The driver
* never sees these...
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCDRVINT_H
#define _MCDRVINT_H

#define MCD_ALLOC_TAG   'xDCM'
#define MCD_MAX_ALLOC	0x40000

#if DBG

#define PRIVATE

VOID MCDDebugPrint(char *, ...);

#define MCDBG_PRINT             MCDDebugPrint

VOID MCDAssertFailed(char *, char *, int);

#define MCDASSERT(expr, msg) \
    if (!(expr)) MCDAssertFailed(msg, __FILE__, __LINE__); else 0

#else

#define MCDBG_PRINT
#define MCDASSERT(expr, msg)
#define PRIVATE		static

#endif

// Inline function to find the intersection of two rectangles:

_inline void MCDIntersectRect(RECTL *pRectInter, RECTL *pRectA, RECTL *pRectB)
{
    // Get intersection of left, right, top, and bottom edges of the
    // two source rectangles:

    pRectInter->left   = max(pRectA->left, pRectB->left);
    pRectInter->right  = min(pRectA->right, pRectB->right);
    pRectInter->top    = max(pRectA->top, pRectB->top);
    pRectInter->bottom = min(pRectA->bottom, pRectB->bottom);
}

#define CHECK_MEM_RANGE_RETVAL(ptr, pMin, pMax, retval)\
{\
    if (((char *)(ptr) > (char *)(pMax)) ||\
        ((char *)(ptr) < (char *)(pMin)))\
    {\
        MCDBG_PRINT("%s(%d): Buffer pointer out of range (%x [%x] %x).",__FILE__,__LINE__,pMin, ptr, pMax);\
        return retval;\
    }\
}

#define CHECK_SIZE_IN(pExec, structure)\
{\
    if (sizeof(structure) > ((char *)pExec->pCmdEnd - (char *)pExec->pCmd)) {\
        MCDBG_PRINT("%s(%d): Input buffer too small",__FILE__,__LINE__);\
        return FALSE;\
    }\
}

#define CHECK_SIZE_OUT(pExec, structure)\
{\
    if ((sizeof(structure) > pExec->cjOut) || (!pExec->pvOut)) {\
        MCDBG_PRINT("%s(%d): Output buffer too small: ptr[%x], size %d",__FILE__,__LINE__, pExec->pvOut, pExec->cjOut);\
        return FALSE;\
    }\
}

#define CHECK_FOR_RC(pExec)\
    if (!pExec->pRcPriv){ \
        MCDBG_PRINT("%s(%d): Invalid (null) RC",__FILE__,__LINE__);\
        return FALSE;\
    }

#define CHECK_FOR_MEM(pExec)\
    if (!pExec->pMemObj){ \
        MCDBG_PRINT("%s(%d): Invalid or null shared memory",__FILE__,__LINE__);\
        return FALSE;\
    }

#define CHECK_FOR_WND(pExec)\
    if (!pExec->pWndPriv){ \
        MCDBG_PRINT("%s(%d): Invalid window region", __FILE__, __LINE__);\
        return FALSE;\
    }

#define GET_MEMOBJ_RETVAL(pMemObj, hMemObj, retval)                           \
    (pMemObj) = (MCDMEMOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)(hMemObj),     \
                                                    MCDHANDLE_MEM);           \
    if (!(pMemObj))							      \
    {									      \
        MCDBG_PRINT("%s(%d): Invalid handle for shared memory.",	      \
                    __FILE__, __LINE__);				      \
        return retval;							      \
    }									      \
    if ((pMemObj)->lockCount)						      \
    {									      \
        MCDBG_PRINT("%s(%d): memory is locked by driver.",		      \
                    __FILE__, __LINE__);				      \
        return retval;							      \
    }

#define ENTER_MCD_LOCK()    
#define LEAVE_MCD_LOCK()    

// Number of list rectangles we can keep in our default buffer:

#define NUM_DEFAULT_CLIP_BUFFER_RECTS   20

// Size in bytes of default buffer size for storing our list of
// current clip rectangles:

#define SIZE_DEFAULT_CLIP_BUFFER        \
    2 * ((NUM_DEFAULT_CLIP_BUFFER_RECTS * sizeof(RECTL)) + sizeof(ULONG))


//
//
//
// Structures.
//
//
//
//

typedef struct _MCDLOCKINFO
{
    BOOL bLocked;
    struct _MCDWINDOWPRIV *pWndPrivOwner;
} MCDLOCKINFO;

typedef struct _MCDGLOBALINFO
{
    SURFOBJ *pso;
    MCDLOCKINFO lockInfo;
    ULONG verMajor;
    ULONG verMinor;
    MCDDRIVER mcdDriver;
    MCDGLOBALDRIVERFUNCS mcdGlobalFuncs;
} MCDGLOBALINFO;

typedef struct _MCDRCOBJ MCDRCOBJ;

typedef struct _MCDWINDOWPRIV {
    MCDWINDOW MCDWindow;            // Put this first since we'll be deriving
                                    // MCDWINDOWPRIV from MCDWINDOW
    MCDHANDLE handle;               // Driver handle for this window
    HWND hWnd;                      // Window with which this is associated
    MCDRCOBJ *objectList;           // List of objects associated with this
                                    // window 
    BOOL bRegionValid;              // Do we have a valid region?
    MCDGLOBALINFO *pGlobal;         // Driver global information
    MCDENUMRECTS *pClipUnscissored; // List of rectangles describing the
                                    // entire current clip region
    MCDENUMRECTS *pClipScissored;   // List of rectangles describing the
                                    // entire current clip region + scissors
    char defaultClipBuffer[SIZE_DEFAULT_CLIP_BUFFER];
                                    // Used for storing above rectangle lists
                                    //   when they can fit
    char *pAllocatedClipBuffer;     // Points to allocated storage for storing
                                    //   rectangle lists when they don't fit
                                    //   in 'defaultClipBuffer'.  NULL if
                                    //   not allocated.
    ULONG sizeClipBuffer;           // Size of clip storage pointed to by
                                    //   'pClipScissored' taking both
                                    //   lists into account.
    BOOL bBuffersValid;             // Validity of buffer cache.
    MCDRECTBUFFERS mbufCache;       // Cached buffer information.
    WNDOBJ *pwo;                    // WNDOBJ for this window.
} MCDWINDOWPRIV;

typedef struct _MCDRCPRIV {
    MCDRC MCDRc;
    BOOL bValid;
    BOOL bDrvValid;
    HWND hWnd;
    HDEV hDev;
    RECTL scissorsRect;
    BOOL scissorsEnabled;
    LONG reserved[4];
    ULONG surfaceFlags;             // surface flags with which RC was created
    MCDGLOBALINFO *pGlobal;
} MCDRCPRIV;

typedef enum {
    MCDHANDLE_RC,
    MCDHANDLE_MEM,
    MCDHANDLE_TEXTURE,
    MCDHANDLE_WINDOW
} MCDHANDLETYPE;

typedef struct _MCDTEXOBJ {
    MCDHANDLETYPE type;         // Object type
    MCDTEXTURE MCDTexture;
    ULONG_PTR pid;              // creator process ID
    ULONG size;                 // size of this structure
    MCDGLOBALINFO *pGlobal;
} MCDTEXOBJ;

typedef struct _MCDMEMOBJ {
    MCDHANDLETYPE type;         // Object type
    MCDMEM MCDMem;              // meat of the object
    ULONG_PTR pid;              // creator process ID
    ULONG size;                 // size of this structure
    ULONG lockCount;            // number of locks on the memory
    UCHAR *pMemBaseInternal;    // internal pointer to memory
    MCDGLOBALINFO *pGlobal;
} MCDMEMOBJ;

typedef struct _MCDRCOBJ {
    MCDHANDLETYPE type;
    MCDRCPRIV *pRcPriv;         // need this for driver free function
    ULONG_PTR pid;              // creator process ID
    ULONG size;                 // size of the RC-bound object
    MCDHANDLE handle;
    MCDRCOBJ *next;
} MCDRCOBJ;

typedef struct _MCDWINDOWOBJ {
    MCDHANDLETYPE type;
    MCDWINDOWPRIV MCDWindowPriv;
} MCDWINDOWOBJ;

typedef struct _MCDEXEC {
    MCDESC_HEADER *pmeh;        // MCDESC_HEADER for command buffer
    MCDHANDLE hMCDMem;          // handle to command memory
    MCDCMDI *pCmd;              // start of current command
    MCDCMDI *pCmdEnd;           // end of command buffer
    PVOID pvOut;                // output buffer
    LONG cjOut;                 // output buffer size
    LONG inBufferSize;          // input buffer size
    struct _MCDRCPRIV *pRcPriv; // current rendering context
    struct _MCDWINDOWPRIV *pWndPriv;   // window info
    struct _MCDGLOBALINFO *pGlobal;    // global info
    MCDMEMOBJ *pMemObj;         // shared-memory cache for commands/data
    MCDSURFACE MCDSurface;      // device surface
    WNDOBJ **ppwoMulti;         // Array of WNDOBJs for multi-swap
    HDEV hDev;                  // Engine handle (NT only)
} MCDEXEC;

ULONG_PTR MCDSrvProcess(MCDEXEC *pMCDExec);
MCDHANDLE MCDSrvCreateContext(MCDSURFACE *pMCDSurface,
                              MCDRCINFOPRIV *pMcdRcInfo,
                              MCDGLOBALINFO *pGlobal,
                              LONG iPixelFormat, LONG iLayer, HWND hWnd,
                              ULONG surfaceFlags, ULONG contextFlags);
MCDHANDLE MCDSrvCreateTexture(MCDEXEC *pMCDExec, MCDTEXTUREDATA *pTexData, 
                              VOID *pSurface, ULONG flags);
UCHAR * MCDSrvAllocMem(MCDEXEC *pMCDExec, ULONG numBytes,
                       ULONG flags, MCDHANDLE *phMem);
ULONG MCDSrvQueryMemStatus(MCDEXEC *pMCDExec, MCDHANDLE hMCDMem);
BOOL MCDSrvSetScissor(MCDEXEC *pMCDExec, RECTL *pRect, BOOL bEnabled);
MCDWINDOW *MCDSrvNewMCDWindow(MCDSURFACE *pMCDSurface, HWND hWnd,
                              MCDGLOBALINFO *pGlobal, HDEV hdev);


BOOL CALLBACK FreeMemObj(DRIVEROBJ *pDrvObj);
BOOL CALLBACK FreeTexObj(DRIVEROBJ *pDrvObj);
BOOL CALLBACK FreeRCObj(DRIVEROBJ *pDrvObj);
BOOL DestroyMCDObj(MCDHANDLE handle, MCDHANDLETYPE handleType);
VOID GetScissorClip(MCDWINDOWPRIV *pWndPriv, MCDRCPRIV *pRcPriv);

// Internal engine functions:

WNDOBJ *MCDEngGetWndObj(MCDSURFACE *pMCDSurface);
VOID MCDEngUpdateClipList(WNDOBJ *pwo);
DRIVEROBJ *MCDEngLockObject(MCDHANDLE hObj);
VOID MCDEngUnlockObject(MCDHANDLE hObj);
WNDOBJ *MCDEngCreateWndObj(MCDSURFACE *pMCDSurface, HWND hWnd,
                           WNDOBJCHANGEPROC pChangeProc);
MCDHANDLE MCDEngCreateObject(VOID *pOject, FREEOBJPROC pFreeObjFunc,
                             HDEV hDevEng);
BOOL MCDEngDeleteObject(MCDHANDLE hObj);
UCHAR *MCDEngAllocSharedMem(ULONG numBytes);
VOID MCDEngFreeSharedMem(UCHAR *pMem);
VOID *MCDEngGetPtrFromHandle(HANDLE handle, MCDHANDLETYPE type);
ULONG_PTR MCDEngGetProcessID();


// Debugging stuff:


#if DBG
UCHAR *MCDSrvDbgLocalAlloc(UINT, UINT);
VOID MCDSrvDbgLocalFree(UCHAR *);

#define MCDSrvLocalAlloc   MCDSrvDbgLocalAlloc
#define MCDSrvLocalFree    MCDSrvDbgLocalFree

VOID MCDebugPrint(char *, ...);

#define MCDBG_PRINT             MCDDebugPrint

#else

UCHAR *MCDSrvLocalAlloc(UINT, UINT);
VOID MCDSrvLocalFree(UCHAR *);
#define MCDBG_PRINT

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\server\mcdeng.c ===
/******************************Module*Header*******************************\
* Module Name: mcdeng.c
*
* Internal server-side MCD engine functions to perform functions such as
* driver object management, memory allocation, etc.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <windef.h>
#include <wingdi.h>

#include <windows.h>
#include <wtypes.h>

#include <winddi.h>
#include <mcdesc.h>

#include "mcdrv.h"
#include <mcd2hack.h>
#include "mcd.h"
#include "mcdint.h"
#include "mcdrvint.h"


WNDOBJ *MCDEngGetWndObj(MCDSURFACE *pMCDSurface)
{
    return pMCDSurface->pwo;
}


VOID MCDEngUpdateClipList(WNDOBJ *pwo)
{
    return;
}

DRIVEROBJ *MCDEngLockObject(MCDHANDLE hObj)
{
    return (DRIVEROBJ *)EngLockDriverObj((HDRVOBJ)hObj);
}

VOID MCDEngUnlockObject(MCDHANDLE hObj)
{
    EngUnlockDriverObj((HDRVOBJ)hObj);
}

WNDOBJ *MCDEngCreateWndObj(MCDSURFACE *pMCDSurface, HWND hWnd,
                           WNDOBJCHANGEPROC pChangeProc)
{
    return EngCreateWnd(pMCDSurface->pso,
                        hWnd,
                        pChangeProc,
                        (WO_RGN_CLIENT_DELTA     |
                         WO_RGN_CLIENT           |
                         WO_RGN_SURFACE_DELTA    |
                         WO_RGN_SURFACE          |
                         WO_RGN_UPDATE_ALL
                        ), 0);
}

MCDHANDLE MCDEngCreateObject(VOID *pObject, FREEOBJPROC pFreeObjFunc,
                             HDEV hDevEng)
{
    return (MCDHANDLE)EngCreateDriverObj(pObject,
                                         pFreeObjFunc,
                                         hDevEng);
}

BOOL MCDEngDeleteObject(MCDHANDLE hObj)
{
    return (EngDeleteDriverObj((HDRVOBJ)hObj, TRUE, FALSE) != 0);
}

UCHAR *MCDEngAllocSharedMem(ULONG numBytes)
{
    return (UCHAR *)EngAllocUserMem(min(numBytes, MCD_MAX_ALLOC),
                                    MCD_ALLOC_TAG);
}

VOID MCDEngFreeSharedMem(UCHAR *pMem)
{
    EngFreeUserMem((VOID *)pMem);
}

//****************************************************************************
// MCDEngGetPtrFromHandle()
//
// Converts a driver handle to a pointer.  Note that we lock and unlock
// the object, and do not hold the lock during use of the pointer.  This
// simplifies much of the other logic in the driver, especially in
// early- or error-return cases, and is safe since we as single-threaded
// inside the driver.
//****************************************************************************

VOID *MCDEngGetPtrFromHandle(MCDHANDLE handle, MCDHANDLETYPE type)
{
    MCDRCOBJ *pRcObject;
    DRIVEROBJ *pDrvObj;

    pDrvObj = (DRIVEROBJ *)EngLockDriverObj((HDRVOBJ)handle);

    if (!pDrvObj)
    {
        MCDBG_PRINT("GetPtrFromHandle: Couldn't unlock driver object.");
        return (PVOID)NULL;
    }
    else
    {
        pRcObject = (MCDRCOBJ *)pDrvObj->pvObj;
        EngUnlockDriverObj((HDRVOBJ)handle);

        if (pRcObject->type != type)
        {
            MCDBG_PRINT("MCDSrvGetPtrFromHandle: Wrong type: got %d, expected %d.",
                        pRcObject->type, type);
            return (PVOID)NULL;
        }
        else
            return pRcObject;
    }
}

ULONG_PTR MCDEngGetProcessID()
{
    return (ULONG_PTR)EngGetProcessHandle();
}


#if DBG

ULONG MCDLocalMemSize = 0;

UCHAR *MCDSrvDbgLocalAlloc(UINT flags, UINT size)
{
    UCHAR *pRet;

    if (pRet = (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size + sizeof(ULONG),
                                    MCD_ALLOC_TAG)) {
        MCDLocalMemSize += size;
        *((ULONG *)pRet) = size;
        return (pRet + sizeof(ULONG));
    } else
        return (UCHAR *)NULL;
}


VOID MCDSrvDbgLocalFree(UCHAR *pMem)
{
    if (!pMem) {
        MCDBG_PRINT("MCDSrvDbgLocalFree: Attempt to free NULL pointer.");
        return;
    }

    pMem -= sizeof(ULONG);

    MCDLocalMemSize -= *((ULONG *)pMem);

    EngFreeMem((VOID *)pMem);
}

VOID MCDDebugPrint(char *pMessage, ...)
{
    char buffer[256];
    int len;
    va_list ap;

    va_start(ap, pMessage);

    EngDebugPrint("[MCD] ", pMessage, ap);
    EngDebugPrint("", "\n", ap);

    va_end(ap);
}

VOID MCDAssertFailed(char *pMessage, char *pFile, int line)
{
    MCDDebugPrint("%s(%d): %s", pFile, line, pMessage);
    EngDebugBreak();
}

#else


UCHAR *MCDSrvLocalAlloc(UINT flags, UINT size)
{

    return (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size, MCD_ALLOC_TAG);
}


VOID MCDSrvLocalFree(UCHAR *pMem)
{
    EngFreeMem((VOID *)pMem);
}


#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\mcd\server\mcdsrv.c ===
/******************************Module*Header*******************************\
* Module Name: mcdsrv.c
*
* This module contains the trusted component of the MCD server-side engine.
* This module performs handle management and parameter-checking and validation
* to the extent possible.  This module also makes the calls to the device
* driver, and provides callbacks to the driver for things such as handle
* referencing.
*
* Goals
* -----
*
* Pervasive throughout this implementation is the influence of the
* following goals:
*
* 1. Robustness
*
*    Windows NT is first and foremost a robust operating system.  There
*    is a simple measure for this: a robust system should never crash.
*    Because the display driver is a trusted component of the operating
*    system, and because the MCD is directly callable from OpenGL from
*    the client side of the OS (and thus untrusted), this has a significant
*    impact on the way we must do things.
*
* 2. Performance
*
*    Performance is the 'raison d'etre' of the MCD; we have tried to
*    have as thin a layer above the rendering code as we could.
*
* 3. Portability
*
*    This implementation is intended portable to different processor types,
*    and to the Windows 95 operating system.
*
* Obviously, Windows 95 implementations may choose to have a different
* order of priority for these goals, and so some of the robustness
* code may be eliminated.  But it is still recommended that it be kept;
* the overhead is reasonably minimal, and people really don't like it
* when their systems crash...
*
* The Rules of Robustness
* -----------------------
*
* 1. Nothing given by the caller can be trusted.
*
*    For example, handles cannot be trusted to be valid.  Handles passed
*    in may actually be for objects not owned by the caller.  Pointers
*    and offsets may not be correctly aligned.  Pointers, offsets, and
*    coordinates may be out of bounds.
*
* 2. Parameters can be asynchronously modified at any time.
*
*    Many commands come from shared memory sections, and any data therein
*    may be asynchronously modified by other threads in the calling
*    application.  As such, parameters may never be validated in-place
*    in the shared section, because the application may corrupt the data
*    after validation but before its use.  Instead, parameters must always
*    be first copied out of the window, and then validated on the safe
*    copy.
*
* 3. We must clean up.
*
*    Applications may die at any time before calling the appropriate
*    clean up functions.  As such, we have to be prepared to clean up
*    any resources ourselves when the application dies.
*
* Copyright (c) 1994, 1995, 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <windows.h>

#include <wtypes.h>

#include <winddi.h>
#include <mcdesc.h>

#include "mcdrv.h"
#include <mcd2hack.h>
#include "mcd.h"
#include "mcdint.h"
#include "mcdrvint.h"


// Checks MCD version to see if the driver can accept direct buffer
// access.  Direct access was introduced in 1.1.
#define SUPPORTS_DIRECT(pGlobal) \
    ((pGlobal)->verMinor >= 0x10 || (pGlobal)->verMajor > 1)


////////////////////////////////////////////////////////////////////////////
//
//
// Declarations for internal support functions for an MCD locking mechanism
// that can be used to synchronize multiple processes/thread that use MCD.
//
//
////////////////////////////////////////////////////////////////////////////

ULONG MCDSrvLock(MCDWINDOWPRIV *);
VOID MCDSrvUnlock(MCDWINDOWPRIV *);


////////////////////////////////////////////////////////////////////////////
//
// Declarations for internal per-driver-instance list that all global
// data is kept in.  The list is indexed by pso.
//
////////////////////////////////////////////////////////////////////////////

// Space for one old-style driver to hold its information statically.
MCDGLOBALINFO gStaticGlobalInfo;

BOOL           MCDSrvInitGlobalInfo(void);
void           MCDSrvUninitGlobalInfo(void);
MCDGLOBALINFO *MCDSrvAddGlobalInfo(SURFOBJ *pso);
MCDGLOBALINFO *MCDSrvGetGlobalInfo(SURFOBJ *pso);


////////////////////////////////////////////////////////////////////////////
//
//
// Server subsystem entry points.
//
//
////////////////////////////////////////////////////////////////////////////

//****************************************************************************
//
// MCD initialization functions.
//
// NT 4.0 MCD support exported MCDEngInit which display drivers call
// to initialize the MCD server-side code.  MCDEngInit only allowed
// one driver instance to initialize and never uninitialized.
//
// This doesn't work very well with mode changes or multimon so for
// NT 5.0 MCDEngInitEx was added.  MCDEngInitEx has two differences
// from MCDEngInit:
// 1. MCDEngInitEx takes a table of global driver functions instead of
//    just the MCDrvGetEntryPoints function.  Currently the table only
//    has one entry for MCDrvGetEntryPoints but it allows for future
//    expansion.
// 2. Calling MCDEngInitEx implies that the driver will call MCDEngUninit
//    so that per-driver-instance state can be cleaned up.
//
//****************************************************************************

BOOL MCDEngInternalInit(SURFOBJ *pso,
                        MCDGLOBALDRIVERFUNCS *pMCDGlobalDriverFuncs,
                        BOOL bAddPso)
{
    MCDSURFACE mcdSurface;
    MCDDRIVER mcdDriver;
    MCDGLOBALINFO *pGlobal;

    mcdSurface.pWnd = NULL;
    mcdSurface.pwo = NULL;
    mcdSurface.surfaceFlags = 0;
    mcdSurface.pso = pso;

    memset(&mcdDriver, 0, sizeof(MCDDRIVER));
    mcdDriver.ulSize = sizeof(MCDDRIVER);

    if (pMCDGlobalDriverFuncs->pMCDrvGetEntryPoints == NULL ||
        !pMCDGlobalDriverFuncs->pMCDrvGetEntryPoints(&mcdSurface, &mcdDriver))
    {
        MCDBG_PRINT("MCDEngInit: Could not get driver entry points.");
        return FALSE;
    }

    if (bAddPso)
    {
        if (!MCDSrvInitGlobalInfo())
        {
            return FALSE;
        }

        pGlobal = MCDSrvAddGlobalInfo(pso);
        if (pGlobal == NULL)
        {
            MCDSrvUninitGlobalInfo();
            return FALSE;
        }
    }
    else
    {
        pGlobal = &gStaticGlobalInfo;
    }
    
    // Guaranteed to be zero-filled and pso set so only fill in interesting
    // fields.
    // verMajor and verMinor can not be filled out yet so they are
    // left at zero to indicate the most conservative possible version
    // number.  They are filled in with correct information when DRIVERINFO
    // is processed.
    pGlobal->mcdDriver = mcdDriver;
    pGlobal->mcdGlobalFuncs = *pMCDGlobalDriverFuncs;
    
    return TRUE;
}

#define MGDF_SIZE (sizeof(ULONG)+sizeof(void *))

BOOL WINAPI MCDEngInitEx(SURFOBJ *pso,
                         MCDGLOBALDRIVERFUNCS *pMCDGlobalDriverFuncs,
                         void *pReserved)
{
    if (pso == NULL ||
        pMCDGlobalDriverFuncs->ulSize != MGDF_SIZE ||
        pReserved != NULL)
    {
        return FALSE;
    }
    
    return MCDEngInternalInit(pso, pMCDGlobalDriverFuncs, TRUE);
}

BOOL WINAPI MCDEngInit(SURFOBJ *pso,
                       MCDRVGETENTRYPOINTSFUNC pGetDriverEntryFunc)
{
    MCDGLOBALDRIVERFUNCS mgdf;

    // The old-style initialization function is being called so
    // we must assume that the uninit function will not be called.
    // This means that we cannot allocate resources for the global
    // info list since we won't be able to clean them up.  Without
    // a global info list we are restricted to using global variables
    // and thus only one old-style init is allowed per load.
    
    if (pso == NULL ||
        pGetDriverEntryFunc == NULL ||
        gStaticGlobalInfo.pso != NULL)
    {
        return FALSE;
    }

    gStaticGlobalInfo.pso = pso;
    
    memset(&mgdf, 0, sizeof(mgdf));
    mgdf.ulSize = sizeof(ULONG)+sizeof(void *);
    mgdf.pMCDrvGetEntryPoints = pGetDriverEntryFunc;
    
    return MCDEngInternalInit(pso, &mgdf, FALSE);
}


//****************************************************************************
// BOOL MCDEngEscFilter(SURFOBJ *, ULONG, ULONG, VOID *, ULONG cjOut,
//                      VOID *pvOut)
//
// MCD escape filter.  This function should return TRUE for any
// escapes functions which this filter processed, FALSE otherwise (in which
// case the caller should continue to process the escape).
//****************************************************************************

BOOL WINAPI MCDEngEscFilter(SURFOBJ *pso, ULONG iEsc,
                            ULONG cjIn, VOID *pvIn,
                            ULONG cjOut, VOID *pvOut, ULONG_PTR *pRetVal)
{
    MCDEXEC MCDExec;
    MCDESC_HEADER *pmeh;
    MCDESC_HEADER_NTPRIVATE *pmehPriv;

    switch (iEsc)
    {
        case QUERYESCSUPPORT:

            // Note:  we don't need to check cjIn for this case since
            // NT's GDI validates this for use.

            return (BOOL)(*pRetVal = (*(ULONG *) pvIn == MCDFUNCS));

        case MCDFUNCS:

            MCDExec.pmeh = pmeh = (MCDESC_HEADER *)pvIn;

            // This is an MCD function.  Under Windows NT, we've
            // got an MCDESC_HEADER_NTPRIVATE structure which we may need
            // to use if the escape does not use driver-created
            // memory.

            // Package the things we need into the MCDEXEC structure:

            pmehPriv = (MCDESC_HEADER_NTPRIVATE *)(pmeh + 1);

            MCDExec.ppwoMulti = (WNDOBJ **)pmehPriv->pExtraWndobj;
            MCDExec.MCDSurface.pwo = pmehPriv->pwo;

            if (pmeh->dwWindow != 0)
            {
                MCDWINDOWOBJ *pmwo;

                // The client side code has given us back the handle
                // to the MCDWINDOW structure as an identifier.  Since it
                // came from user-mode it is suspect and must be validated
                // before continuing.
                pmwo = (MCDWINDOWOBJ *)
                    MCDEngGetPtrFromHandle((MCDHANDLE)pmeh->dwWindow,
                                           MCDHANDLE_WINDOW);
                if (pmwo == NULL)
                {
                    return FALSE;
                }
                MCDExec.pWndPriv = &pmwo->MCDWindowPriv;
            }
            else
            {
                MCDExec.pWndPriv = NULL;
            }

            MCDExec.MCDSurface.pso = pso;
            MCDExec.MCDSurface.pWnd = (MCDWINDOW *)MCDExec.pWndPriv;
            MCDExec.MCDSurface.surfaceFlags = 0;

            MCDExec.pvOut = pvOut;
            MCDExec.cjOut = cjOut;

            if (!pmeh->hSharedMem) {

                *pRetVal = (ULONG)FALSE;

                if (!pmehPriv->pBuffer)
                    return (ULONG)TRUE;

                if (pmehPriv->bufferSize < sizeof(MCDCMDI))
                    return (ULONG)TRUE;

                MCDExec.pCmd = (MCDCMDI *)(pmehPriv->pBuffer);
                MCDExec.pCmdEnd = (MCDCMDI *)((char *)MCDExec.pCmd +
                                             pmehPriv->bufferSize);
                MCDExec.inBufferSize = pmehPriv->bufferSize;
                MCDExec.hMCDMem = (MCDHANDLE)NULL;
            } else
                MCDExec.hMCDMem = pmeh->hSharedMem;

            ENTER_MCD_LOCK();

            *pRetVal = MCDSrvProcess(&MCDExec);

            LEAVE_MCD_LOCK();

            return TRUE;

        default:
            return (ULONG)FALSE;
            break;
    }

    return (ULONG)FALSE;    // Should never get here...
}


//****************************************************************************
// BOOL MCDEngSetMemStatus(MCDMEM *pMCDMem, ULONG status);
//
// Sets the memory status to the desired value.  This is called by the
// driver to set and reset the busy flags for a chunk of memory to allow
// DMA.
//****************************************************************************


BOOL WINAPI MCDEngSetMemStatus(MCDMEM *pMCDMem, ULONG status)
{
    MCDMEMOBJ *pMemObj;
    ULONG retVal;

    pMemObj = (MCDMEMOBJ *)((char *)pMCDMem - sizeof(MCDHANDLETYPE));

    if (pMemObj->type != MCDHANDLE_MEM) {
        return FALSE;
    }

    switch (status) {
        case MCDRV_MEM_BUSY:
            pMemObj->lockCount++;
            break;
        case MCDRV_MEM_NOT_BUSY:
            pMemObj->lockCount--;
            break;
        default:
            return (ULONG)FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//
// Private server-side funtions.
//
//
////////////////////////////////////////////////////////////////////////////

//****************************************************************************
// CallGetBuffers
//
// Wrapper for MCDrvGetBuffers that does appropriate checks, setup,
// cache management and data translation.
//****************************************************************************

PRIVATE
ULONG CallGetBuffers(MCDEXEC *pMCDExec, MCDRC *pRc, MCDRECTBUFFERS *pBuf)
{
    ULONG ulRet;
    
    if (!pMCDExec->pGlobal->mcdDriver.pMCDrvGetBuffers)
    {
        MCDBG_PRINT("MCDrvGetBuffers: missing entry point.");
        return FALSE;
    }

    // Clip lists need to be valid so drivers can do different
    // things based on whether the surface is trivially visible or not.
    GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);
    
    // Should be casting to MCDRECTBUFFERS with correct
    // 1.1 header.
    ulRet = (ULONG)(*pMCDExec->pGlobal->mcdDriver.pMCDrvGetBuffers)
        (&pMCDExec->MCDSurface, pRc, (MCDBUFFERS *)pBuf);
            
    // Update cached buffers information on success.
    if (ulRet)
    {
        if (SUPPORTS_DIRECT(pMCDExec->pGlobal))
        {
            // This is a 1.1 or greater driver and has returned
            // full MCDRECTBUFFERS information.  Cache it
            // for possible later use.
                    
            pMCDExec->pWndPriv->bBuffersValid = TRUE;
            pMCDExec->pWndPriv->mbufCache = *pBuf;
        }
        else
        {
            MCDBUFFERS mbuf;
            MCDRECTBUFFERS *mrbuf;
                    
            // This is a 1.0 driver and has only returned
            // MCDBUFFERS information.  Expand it into
            // an MCDRECTBUFFERS.  The rectangles don't
            // really matter to software so they can
            // be zeroed.
                    
            mbuf = *(MCDBUFFERS *)pBuf;
            mrbuf = pBuf;
            *(MCDBUF *)&mrbuf->mcdFrontBuf = mbuf.mcdFrontBuf;
            memset(&mrbuf->mcdFrontBuf.bufPos, 0, sizeof(RECTL));
            *(MCDBUF *)&mrbuf->mcdBackBuf = mbuf.mcdBackBuf;
            memset(&mrbuf->mcdBackBuf.bufPos, 0, sizeof(RECTL));
            *(MCDBUF *)&mrbuf->mcdDepthBuf = mbuf.mcdDepthBuf;
            memset(&mrbuf->mcdDepthBuf.bufPos, 0, sizeof(RECTL));
        }
    }

    return ulRet;
}

//****************************************************************************
// ULONG_PTR MCDSrvProcess(MCDEXEC *pMCDExec)
//
// This is the main MCD function handler.  At this point, there should
// be no platform-specific code since these should have been resolved by
// the entry function.
//****************************************************************************

PRIVATE
ULONG_PTR MCDSrvProcess(MCDEXEC *pMCDExec)
{
    UCHAR *pMaxMem;
    UCHAR *pMinMem;
    MCDESC_HEADER *pmeh = pMCDExec->pmeh;
    MCDRC *pRc;
    MCDMEM *pMCDMem;
    MCDMEMOBJ *pMemObj;
    MCDRCPRIV *pRcPriv;
    ULONG_PTR ulRet;

    // If the command buffer is in shared memory, dereference the memory
    // from the handle and check the bounds.

    if (pMCDExec->hMCDMem)
    {
        GET_MEMOBJ_RETVAL(pMemObj, pmeh->hSharedMem, FALSE);

        pMinMem = pMemObj->MCDMem.pMemBase;

        // Note: we ignore the memory size in the header since it doesn't
        // really help us...
	
        pMaxMem = pMinMem + pMemObj->MCDMem.memSize;

        pMCDExec->pCmd = (MCDCMDI *)((char *)pmeh->pSharedMem);
        pMCDExec->pCmdEnd = (MCDCMDI *)pMaxMem;

        CHECK_MEM_RANGE_RETVAL(pMCDExec->pCmd, pMinMem, pMaxMem, FALSE);

        pMCDExec->inBufferSize = pmeh->sharedMemSize;

        pMCDExec->pMemObj = pMemObj;
    } else
        pMCDExec->pMemObj = (MCDMEMOBJ *)NULL;


    // Get the rendering context if we have one, and process the command:

    if (pmeh->hRC)
    {
        MCDRCOBJ *pRcObj;

        pRcObj = (MCDRCOBJ *)MCDEngGetPtrFromHandle(pmeh->hRC, MCDHANDLE_RC);

        if (!pRcObj)
        {
            MCDBG_PRINT("MCDSrvProcess: Invalid rendering context handle %x.",
                        pmeh->hRC);
            return FALSE;
        }

        pMCDExec->pRcPriv = pRcPriv = pRcObj->pRcPriv;

        if (!pRcPriv->bValid)
        {
            MCDBG_PRINT("MCDSrvProcess: RC has been invalidated for this window.");
            return FALSE;
        }

        if ((!pMCDExec->pWndPriv)) {
            if (pMCDExec->pCmd->command != MCD_BINDCONTEXT) {
                MCDBG_PRINT("MCDSrvProcess: NULL WndObj with RC.");
                return FALSE;
            }
        } else {
            // Validate the window in the RC with the window for this escape:

            if ((pRcPriv->hWnd != pMCDExec->pWndPriv->hWnd) &&
                (pMCDExec->pCmd->command != MCD_BINDCONTEXT))
            {
                MCDBG_PRINT("MCDSrvProcess: Invalid RC for this window.");
                return FALSE;
            }
        }

        // For Win95, we need to poll for the clip region:
        // Clipping needs to be un-broken
        if (pMCDExec->MCDSurface.pwo != NULL)
        {
            MCDEngUpdateClipList(pMCDExec->MCDSurface.pwo);
        }

        pMCDExec->MCDSurface.surfaceFlags |= pRcPriv->surfaceFlags;

    } else {
        pMCDExec->pRcPriv = (MCDRCPRIV *)NULL;
    }

    // Get global driver information.
    if (pMCDExec->pWndPriv != NULL)
    {
        pMCDExec->pGlobal = pMCDExec->pWndPriv->pGlobal;
    }
    else if (pMCDExec->pRcPriv != NULL)
    {
        pMCDExec->pGlobal = pMCDExec->pRcPriv->pGlobal;
    }
    else
    {
        pMCDExec->pGlobal =
            MCDSrvGetGlobalInfo(pMCDExec->MCDSurface.pso);
        if (pMCDExec->pGlobal == NULL)
        {
            MCDBG_PRINT("Unable to find global information");
            return FALSE;
        }
    }

    // If direct surface information was included then
    // fill out the extra surface information in the MCDSURFACE
    // NOCLIP setting?

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
    pMCDExec->MCDSurface.direct.mcdFrontBuf.bufFlags = 0;
    pMCDExec->MCDSurface.direct.mcdBackBuf.bufFlags = 0;
    pMCDExec->MCDSurface.direct.mcdDepthBuf.bufFlags = 0;

    pMCDExec->MCDSurface.frontId = 0;
    pMCDExec->MCDSurface.backId = 0;
    pMCDExec->MCDSurface.depthId = 0;

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        pMCDExec->MCDSurface.surfaceFlags |= MCDSURFACE_DIRECT;

        // Refresh cached buffer information if it's invalid
        // and we need it
        if (pmeh->msrfColor.hSurf == NULL &&
            pmeh->msrfDepth.hSurf == NULL)
        {
            if (pMCDExec->pWndPriv == NULL)
            {
                return FALSE;
            }

            if (!pMCDExec->pWndPriv->bBuffersValid)
            {
                MCDRECTBUFFERS mbuf;

                if (!CallGetBuffers(pMCDExec, NULL, &mbuf))
                {
                    return FALSE;
                }
            }

            pMCDExec->MCDSurface.direct = pMCDExec->pWndPriv->mbufCache;
        }
        else
        {
            if (pmeh->msrfColor.hSurf != NULL)
            {
                pMCDExec->MCDSurface.frontId = (DWORD)
                    pmeh->msrfColor.hSurf;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufFlags =
                    MCDBUF_ENABLED;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufOffset =
                    pmeh->msrfColor.lOffset;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufStride =
                    pmeh->msrfColor.lStride;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufPos =
                    pmeh->msrfColor.rclPos;
            }

            if (pmeh->msrfDepth.hSurf != NULL)
            {
                pMCDExec->MCDSurface.depthId = (DWORD)
                    pmeh->msrfDepth.hSurf;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufFlags =
                    MCDBUF_ENABLED;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufOffset =
                    pmeh->msrfDepth.lOffset;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufStride =
                    pmeh->msrfDepth.lStride;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufPos =
                    pmeh->msrfDepth.rclPos;
            }
        }
    }
#endif // 1.1


    /////////////////////////////////////////////////////////////////
    // If the drawing-batch flag is set, call the main driver drawing
    // routine:
    /////////////////////////////////////////////////////////////////

    if (pmeh->flags & MCDESC_FL_BATCH)
    {
        CHECK_FOR_RC(pMCDExec);
        CHECK_FOR_MEM(pMCDExec);
        GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);
        if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDraw)
        {
            if (pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
            {
                (*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)(&pMCDExec->MCDSurface,
                  &pMCDExec->pRcPriv->MCDRc);
            }
            return (ULONG_PTR)pMCDExec->pCmd;
        }
        return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvDraw)(&pMCDExec->MCDSurface,
                        &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem,
                        (UCHAR *)pMCDExec->pCmd, (UCHAR *)pMCDExec->pCmdEnd);
    }

    if (pmeh->flags & MCDESC_FL_CREATE_CONTEXT)
    {
        MCDCREATECONTEXT *pmcc = (MCDCREATECONTEXT *)pMCDExec->pCmd;
        MCDRCINFOPRIV *pMcdRcInfo = pmcc->pRcInfo;
        
        CHECK_SIZE_IN(pMCDExec, MCDCREATECONTEXT);
        CHECK_SIZE_OUT(pMCDExec, MCDRCINFOPRIV);

        try {
            EngProbeForRead(pMcdRcInfo, sizeof(MCDRCINFOPRIV),
                            sizeof(ULONG));
            RtlCopyMemory(pMCDExec->pvOut, pMcdRcInfo,
                          sizeof(MCDRCINFOPRIV));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MCDBG_PRINT("MCDrvCreateContext: Invalid memory for MCDRCINFO.");
            return FALSE;
        }

        pMcdRcInfo = (MCDRCINFOPRIV *)pMCDExec->pvOut;
        pMcdRcInfo->mri.requestFlags = 0;

        return (ULONG_PTR)MCDSrvCreateContext(&pMCDExec->MCDSurface,
                                          pMcdRcInfo, pMCDExec->pGlobal,
                                          pmcc->ipfd, pmcc->iLayer,
                                          pmcc->escCreate.hwnd,
                                          pmcc->escCreate.flags,
                                          pmcc->mcdFlags);
    }
    
    ////////////////////////////////////////////////////////////////////
    // Now, process all of the non-batched drawing and utility commands:
    ////////////////////////////////////////////////////////////////////

    switch (pMCDExec->pCmd->command) {

        case MCD_DESCRIBEPIXELFORMAT:

            CHECK_SIZE_IN(pMCDExec, MCDPIXELFORMATCMDI);

            if (pMCDExec->pvOut) {
                CHECK_SIZE_OUT(pMCDExec, MCDPIXELFORMAT);
            }

            {
                MCDPIXELFORMATCMDI *pMCDPixelFormat =
                    (MCDPIXELFORMATCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDescribePixelFormat)
                    return 0;

                return (*pMCDExec->pGlobal->mcdDriver.pMCDrvDescribePixelFormat)
                    (&pMCDExec->MCDSurface,
                     pMCDPixelFormat->iPixelFormat,
                     pMCDExec->cjOut,
                     pMCDExec->pvOut, 0);
            }

        case MCD_DRIVERINFO:

            CHECK_SIZE_OUT(pMCDExec, MCDDRIVERINFOI);

            if (!pMCDExec->pGlobal->mcdDriver.pMCDrvInfo)
                return FALSE;

            ulRet = (*pMCDExec->pGlobal->mcdDriver.pMCDrvInfo)
                (&pMCDExec->MCDSurface,
                 (MCDDRIVERINFO *)pMCDExec->pvOut);
            
            if (ulRet)
            {
                // Copy driver function information so that the client
                // side can optimize calls by checking for functions on the
                // client side.

                memcpy(&((MCDDRIVERINFOI *)pMCDExec->pvOut)->mcdDriver,
                       &pMCDExec->pGlobal->mcdDriver, sizeof(MCDDRIVER));

                // Save version information in global info.

                pMCDExec->pGlobal->verMajor =
                    ((MCDDRIVERINFO *)pMCDExec->pvOut)->verMajor;
                pMCDExec->pGlobal->verMinor =
                    ((MCDDRIVERINFO *)pMCDExec->pvOut)->verMinor;
            }

            return ulRet;

        case MCD_DELETERC:

            CHECK_FOR_RC(pMCDExec);

            return (ULONG_PTR)DestroyMCDObj(pmeh->hRC, MCDHANDLE_RC);

        case MCD_ALLOC:

            CHECK_SIZE_IN(pMCDExec, MCDALLOCCMDI);
            CHECK_SIZE_OUT(pMCDExec, MCDHANDLE *);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDALLOCCMDI *pAllocCmd =
                    (MCDALLOCCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)MCDSrvAllocMem(pMCDExec, pAllocCmd->numBytes,
                                          pAllocCmd->flags,
                                          (MCDHANDLE *)pMCDExec->pvOut);
            }

        case MCD_FREE:

            CHECK_SIZE_IN(pMCDExec, MCDFREECMDI);

            {
                MCDFREECMDI *pFreeCmd =
                    (MCDFREECMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)DestroyMCDObj(pFreeCmd->hMCDMem, MCDHANDLE_MEM);
            }

        case MCD_STATE:

            CHECK_SIZE_IN(pMCDExec, MCDSTATECMDI);
            CHECK_FOR_RC(pMCDExec);
            CHECK_FOR_MEM(pMCDExec);

            {
                MCDSTATECMDI *pStateCmd =
                    (MCDSTATECMDI *)pMCDExec->pCmd;
                UCHAR *pStart = (UCHAR *)(pStateCmd + 1);
                LONG totalBytes = pMCDExec->inBufferSize -
                                  sizeof(MCDSTATECMDI);

                if (totalBytes < 0) {
                    MCDBG_PRINT("MCDState: state buffer too small ( < 0).");
                    return FALSE;
                }

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvState) {
                    MCDBG_PRINT("MCDrvState: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvState)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem, pStart,
                               totalBytes, pStateCmd->numStates);
            }

        case MCD_VIEWPORT:

            CHECK_SIZE_IN(pMCDExec, MCDVIEWPORTCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDVIEWPORTCMDI *pViewportCmd =
                    (MCDVIEWPORTCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvViewport) {
                    MCDBG_PRINT("MCDrvViewport: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvViewport)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc, &pViewportCmd->MCDViewport);
            }

        case MCD_QUERYMEMSTATUS:

            CHECK_SIZE_IN(pMCDExec, MCDMEMSTATUSCMDI);

            {
                MCDMEMSTATUSCMDI *pQueryMemCmd =
                    (MCDMEMSTATUSCMDI *)pMCDExec->pCmd;

                return MCDSrvQueryMemStatus(pMCDExec, pQueryMemCmd->hMCDMem);
            }


        case MCD_READSPAN:
        case MCD_WRITESPAN:

            CHECK_SIZE_IN(pMCDExec, MCDSPANCMDI);
            CHECK_FOR_RC(pMCDExec);
            GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);

            {
                MCDSPANCMDI *pSpanCmd =
                    (MCDSPANCMDI *)pMCDExec->pCmd;

                GET_MEMOBJ_RETVAL(pMemObj, pSpanCmd->hMem, FALSE);

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSpan) {
                    MCDBG_PRINT("MCDrvSpan: missing entry point.");
                    return FALSE;
                }

                pMinMem = pMemObj->MCDMem.pMemBase;
                pMaxMem = pMinMem + pMemObj->MCDMem.memSize;

                // At least check that the first pixel is in range.  The driver
                // must validate the end pixel...

                CHECK_MEM_RANGE_RETVAL(pSpanCmd->MCDSpan.pPixels, pMinMem, pMaxMem, FALSE);

                if (pMCDExec->pCmd->command == MCD_READSPAN)
                    return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSpan)(&pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem, &pSpanCmd->MCDSpan, TRUE);
                else
                    return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSpan)(&pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem, &pSpanCmd->MCDSpan, FALSE);
            }


        case MCD_CLEAR:

            CHECK_SIZE_IN(pMCDExec, MCDCLEARCMDI);
            CHECK_FOR_RC(pMCDExec);
            GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);

            {
                MCDCLEARCMDI *pClearCmd =
                    (MCDCLEARCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvClear) {
                    MCDBG_PRINT("MCDrvClear: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvClear)(&pMCDExec->MCDSurface,
                            &pMCDExec->pRcPriv->MCDRc, pClearCmd->buffers);
            }

        case MCD_SWAP:

            CHECK_SIZE_IN(pMCDExec, MCDSWAPCMDI);
    	    CHECK_FOR_WND(pMCDExec);
            GetScissorClip(pMCDExec->pWndPriv, NULL);

            {
                MCDSWAPCMDI *pSwapCmd =
                    (MCDSWAPCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSwap) {
                    MCDBG_PRINT("MCDrvSwap: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSwap)
                    (&pMCDExec->MCDSurface,
                     pSwapCmd->flags);
            }

        case MCD_SCISSOR:

            CHECK_SIZE_IN(pMCDExec, MCDSCISSORCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDSCISSORCMDI *pMCDScissor = (MCDSCISSORCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)MCDSrvSetScissor(pMCDExec, &pMCDScissor->rect,
                                               pMCDScissor->bEnabled);
            }
            break;

        case MCD_ALLOCBUFFERS:

            CHECK_SIZE_IN(pMCDExec, MCDALLOCBUFFERSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDALLOCBUFFERSCMDI *pMCDAllocBuffersCmd = (MCDALLOCBUFFERSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pWndPriv->bRegionValid)
                    pMCDExec->pWndPriv->MCDWindow.clientRect =
                        pMCDAllocBuffersCmd->WndRect;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvAllocBuffers) {
                    MCDBG_PRINT("MCDrvAllocBuffers: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvAllocBuffers)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc);
            }

            break;

        case MCD_GETBUFFERS:

            CHECK_SIZE_IN(pMCDExec, MCDGETBUFFERSCMDI);
            CHECK_SIZE_OUT(pMCDExec, MCDRECTBUFFERS);
            CHECK_FOR_RC(pMCDExec);

            return CallGetBuffers(pMCDExec, &pMCDExec->pRcPriv->MCDRc,
                                  (MCDRECTBUFFERS *)pMCDExec->pvOut);

        case MCD_LOCK:

            CHECK_SIZE_IN(pMCDExec, MCDLOCKCMDI);
            CHECK_FOR_RC(pMCDExec);

            return MCDSrvLock(pMCDExec->pWndPriv);

            break;

        case MCD_UNLOCK:
            CHECK_SIZE_IN(pMCDExec, MCDLOCKCMDI);
            CHECK_FOR_RC(pMCDExec);

            MCDSrvUnlock(pMCDExec->pWndPriv);

            return TRUE;

            break;

        case MCD_BINDCONTEXT:

            CHECK_SIZE_IN(pMCDExec, MCDBINDCONTEXTCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                ULONG_PTR retVal;
                MCDBINDCONTEXTCMDI *pMCDBindContext = (MCDBINDCONTEXTCMDI *)pMCDExec->pCmd;
                MCDWINDOW *pWndRes;

                if ((!pMCDExec->pWndPriv)) {
		    pWndRes = MCDSrvNewMCDWindow(&pMCDExec->MCDSurface,
                                            pMCDBindContext->hWnd,
                                            pMCDExec->pGlobal,
                                            pMCDExec->pRcPriv->hDev);
                    if (!pWndRes)
                    {
                        MCDBG_PRINT("MCDBindContext: Creation of window object failed.");
                        return 0;
                    }

                    pMCDExec->pWndPriv = (MCDWINDOWPRIV *)pWndRes;

                }

                if (!pMCDExec->MCDSurface.pWnd) {
                    MCDBG_PRINT("MCDrvBindContext: NULL surface.");
                    return 0;
                }

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvBindContext) {
                    MCDBG_PRINT("MCDrvBindContext: missing entry point.");
                    return 0;
                }

                retVal = (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvBindContext)(&pMCDExec->MCDSurface,
                                 &pMCDExec->pRcPriv->MCDRc);

                if (retVal)
                {
                    pRcPriv->hWnd = pMCDBindContext->hWnd;
                    retVal = (ULONG_PTR)pMCDExec->pWndPriv->handle;
                }

                return retVal;

            }

            break;

        case MCD_SYNC:
            CHECK_SIZE_IN(pMCDExec, MCDSYNCCMDI);
            CHECK_FOR_RC(pMCDExec);

            if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSync) {
                MCDBG_PRINT("MCDrvSync: missing entry point.");
                return FALSE;
            }

            return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)(&pMCDExec->MCDSurface,
                           &pMCDExec->pRcPriv->MCDRc);

            break;

        case MCD_CREATE_TEXTURE:
            CHECK_SIZE_IN(pMCDExec, MCDCREATETEXCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDCREATETEXCMDI *pMCDCreateTex =
                    (MCDCREATETEXCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)MCDSrvCreateTexture(pMCDExec,
                                                  pMCDCreateTex->pTexData,
                                                  pMCDCreateTex->pSurface,
                                                  pMCDCreateTex->flags);
            }

            break;

        case MCD_DELETE_TEXTURE:
            CHECK_SIZE_IN(pMCDExec, MCDDELETETEXCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDDELETETEXCMDI *pMCDDeleteTex =
                    (MCDDELETETEXCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)DestroyMCDObj(pMCDDeleteTex->hTex,
                                            MCDHANDLE_TEXTURE);
            }

            break;

        case MCD_UPDATE_SUB_TEXTURE:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATESUBTEXCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATESUBTEXCMDI *pMCDUpdateSubTex =
                    (MCDUPDATESUBTEXCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateSubTex->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateSubTexture)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateSubTex->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateSubTexture)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture,
                               pMCDUpdateSubTex->lod,
                               &pMCDUpdateSubTex->rect);
            }

            break;

        case MCD_UPDATE_TEXTURE_PALETTE:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATETEXPALETTECMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATETEXPALETTECMDI *pMCDUpdateTexPalette =
                    (MCDUPDATETEXPALETTECMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateTexPalette->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePalette)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateTexPalette->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePalette)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture,
                               pMCDUpdateTexPalette->start,
                               pMCDUpdateTexPalette->numEntries);
            }

            break;

        case MCD_UPDATE_TEXTURE_PRIORITY:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATETEXPRIORITYCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATETEXPRIORITYCMDI *pMCDUpdateTexPriority =
                    (MCDUPDATETEXPRIORITYCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateTexPriority->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePriority)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateTexPriority->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePriority)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture);

            }

            break;

        case MCD_UPDATE_TEXTURE_STATE:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATETEXSTATECMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATETEXSTATECMDI *pMCDUpdateTexState =
                    (MCDUPDATETEXSTATECMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateTexState->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTextureState)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateTexState->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTextureState)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture);

            }

            break;

        case MCD_TEXTURE_STATUS:
            CHECK_SIZE_IN(pMCDExec, MCDTEXSTATUSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDTEXSTATUSCMDI *pMCDTexStatus =
                    (MCDTEXSTATUSCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDTexStatus->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvTextureStatus)
                    return FALSE;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvTextureStatus)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture);
            }

            break;


        case MCD_GET_TEXTURE_KEY:
            CHECK_SIZE_IN(pMCDExec, MCDTEXKEYCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDTEXKEYCMDI *pMCDTexKey =
                    (MCDTEXKEYCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDTexKey->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj)
                    return FALSE;

                return pTexObj->MCDTexture.textureKey;
            }

            break;

        case MCD_DESCRIBELAYERPLANE:
            CHECK_SIZE_IN(pMCDExec, MCDLAYERPLANECMDI);

            if (pMCDExec->pvOut) {
                CHECK_SIZE_OUT(pMCDExec, MCDLAYERPLANE);
            }

            {
                MCDLAYERPLANECMDI *pMCDLayerPlane =
                    (MCDLAYERPLANECMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDescribeLayerPlane)
                    return 0;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvDescribeLayerPlane)
                    (&pMCDExec->MCDSurface,
                     pMCDLayerPlane->iPixelFormat,
                     pMCDLayerPlane->iLayerPlane,
                     pMCDExec->cjOut,
                     pMCDExec->pvOut, 0);
            }

            break;

        case MCD_SETLAYERPALETTE:
            CHECK_SIZE_IN(pMCDExec, MCDSETLAYERPALCMDI);

            {
                MCDSETLAYERPALCMDI *pMCDSetLayerPal =
                    (MCDSETLAYERPALCMDI *)pMCDExec->pCmd;

                // Check to see if palette array is big enough.

                CHECK_MEM_RANGE_RETVAL(&pMCDSetLayerPal->acr[pMCDSetLayerPal->cEntries-1],
                                       pMCDExec->pCmd, pMCDExec->pCmdEnd, FALSE);

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSetLayerPalette) {
                    MCDBG_PRINT("MCDrvSetLayerPalette: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSetLayerPalette)
                    (&pMCDExec->MCDSurface,
                     pMCDSetLayerPal->iLayerPlane,
                     pMCDSetLayerPal->bRealize,
                     pMCDSetLayerPal->cEntries,
                     &pMCDSetLayerPal->acr[0]);
            }

            break;

        case MCD_DRAW_PIXELS:
            CHECK_SIZE_IN(pMCDExec, MCDDRAWPIXELSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDDRAWPIXELSCMDI *pMCDPix =
                    (MCDDRAWPIXELSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDrawPixels) {
                    MCDBG_PRINT("MCDrvDrawPixels: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvDrawPixels)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->width,
                                pMCDPix->height,
                                pMCDPix->format,
                                pMCDPix->type,
                                pMCDPix->pPixels,
                                pMCDPix->packed);
            }

            break;

        case MCD_READ_PIXELS:
            CHECK_SIZE_IN(pMCDExec, MCDREADPIXELSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDREADPIXELSCMDI *pMCDPix =
                    (MCDREADPIXELSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvReadPixels) {
                    MCDBG_PRINT("MCDrvReadPixels: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvReadPixels)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->x,
                                pMCDPix->y,
                                pMCDPix->width,
                                pMCDPix->height,
                                pMCDPix->format,
                                pMCDPix->type,
                                pMCDPix->pPixels);
            }

            break;

        case MCD_COPY_PIXELS:
            CHECK_SIZE_IN(pMCDExec, MCDCOPYPIXELSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDCOPYPIXELSCMDI *pMCDPix =
                    (MCDCOPYPIXELSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvCopyPixels) {
                    MCDBG_PRINT("MCDrvCopyPixels: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvCopyPixels)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->x,
                                pMCDPix->y,
                                pMCDPix->width,
                                pMCDPix->height,
                                pMCDPix->type);
            }

            break;

        case MCD_PIXEL_MAP:
            CHECK_SIZE_IN(pMCDExec, MCDPIXELMAPCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDPIXELMAPCMDI *pMCDPix =
                    (MCDPIXELMAPCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvPixelMap) {
                    MCDBG_PRINT("MCDrvPixelMap: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvPixelMap)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->mapType,
                                pMCDPix->mapSize,
                                pMCDPix->pMap);
            }

            break;

        case MCD_DESTROY_WINDOW:
            CHECK_SIZE_IN(pMCDExec, MCDDESTROYWINDOWCMDI);
            {
                if (pMCDExec->pWndPriv == NULL)
                {
                    MCDBG_PRINT("MCDrvDestroyWindow: NULL window\n");
                    return FALSE;
                }

                MCDEngDeleteObject(pMCDExec->pWndPriv->handle);
                return TRUE;
            }
            break;

        case MCD_GET_TEXTURE_FORMATS:
            CHECK_SIZE_IN(pMCDExec, MCDGETTEXTUREFORMATSCMDI);
            {
                MCDGETTEXTUREFORMATSCMDI *pmgtf =
                    (MCDGETTEXTUREFORMATSCMDI *)pMCDExec->pCmd;

                if (pMCDExec->pvOut)
                {
                    CHECK_SIZE_OUT(pMCDExec,
                                   pmgtf->nFmts*sizeof(DDSURFACEDESC));
                }

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvGetTextureFormats)
                {
                    MCDBG_PRINT("MCDrvGetTextureFormats: "
                                "missing entry point.");
                    return 0;
                }

                return (pMCDExec->pGlobal->mcdDriver.pMCDrvGetTextureFormats)(
                        &pMCDExec->MCDSurface,
                        pmgtf->nFmts,
                        (DDSURFACEDESC *)pMCDExec->pvOut);
#else
                return 0;
#endif // 1.1
            }
            break;

        case MCD_SWAP_MULTIPLE:
            CHECK_SIZE_IN(pMCDExec, MCDSWAPMULTIPLECMDI);

            {
                MCDSWAPMULTIPLECMDI *pSwapCmd =
                    (MCDSWAPMULTIPLECMDI *)pMCDExec->pCmd;
                MCDWINDOWPRIV *apWndPriv[MCDESC_MAX_EXTRA_WNDOBJ];
                UINT i;
                MCDWINDOWOBJ *pmwo;
                MCDRVSWAPMULTIPLEFUNC pSwapMultFunc;
                ULONG_PTR dwRet;

                pSwapMultFunc = NULL;
                for (i = 0; i < pSwapCmd->cBuffers; i++)
                {
                    if (pMCDExec->ppwoMulti[i] != NULL)
                    {
                        pmwo = (MCDWINDOWOBJ *)
                            MCDEngGetPtrFromHandle((MCDHANDLE)
                                                   pSwapCmd->adwMcdWindow[i],
                                                   MCDHANDLE_WINDOW);
                    }
                    else
                    {
                        pmwo = NULL;
                    }

                    if (pmwo == NULL)
                    {
                        apWndPriv[i] = NULL;
                    }
                    else
                    {
                        apWndPriv[i] = &pmwo->MCDWindowPriv;
                        GetScissorClip(apWndPriv[i], NULL);

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
                        if (pSwapMultFunc == NULL)
                        {
                            pSwapMultFunc = apWndPriv[i]->pGlobal->mcdDriver.
                                pMCDrvSwapMultiple;
                        }
                        else if (pSwapMultFunc !=
                                 apWndPriv[i]->pGlobal->mcdDriver.
                                 pMCDrvSwapMultiple)
                        {
                            MCDBG_PRINT("MCDrvSwapMultiple: "
                                        "Mismatched SwapMultiple");
                            return FALSE;
                        }
#endif // 1.1
                    }
                }

                if (pSwapMultFunc != NULL)
                {
                    dwRet = pSwapMultFunc(pMCDExec->MCDSurface.pwo->psoOwner,
                                          pSwapCmd->cBuffers,
                                          (MCDWINDOW **)apWndPriv,
                                          (UINT *)pSwapCmd->auiFlags);
                }
                else
                {
                    MCDSURFACE *pms;

                    dwRet = 0;
                    pms = &pMCDExec->MCDSurface;
                    for (i = 0; i < pSwapCmd->cBuffers; i++)
                    {
                        if (apWndPriv[i] == NULL)
                        {
                            continue;
                        }

                        if (apWndPriv[i]->pGlobal->mcdDriver.
                            pMCDrvSwap == NULL)
                        {
                            MCDBG_PRINT("MCDrvSwapMultiple: Missing Swap");
                        }
                        else
                        {
                            pms->pWnd = (MCDWINDOW *)apWndPriv[i];
                            pms->pso = pMCDExec->ppwoMulti[i]->psoOwner;
                            pms->pwo = pMCDExec->ppwoMulti[i];
                            pms->surfaceFlags = 0;

                            if (apWndPriv[i]->pGlobal->mcdDriver.
                                pMCDrvSwap(pms, pSwapCmd->auiFlags[i]))
                            {
                                dwRet |= 1 << i;
                            }
                        }
                    }
                }

                return dwRet;
            }
            break;

        case MCD_PROCESS:
            CHECK_SIZE_IN(pMCDExec, MCDPROCESSCMDI);
            CHECK_FOR_RC(pMCDExec);
            CHECK_FOR_MEM(pMCDExec);
            {
                MCDPROCESSCMDI *pmp = (MCDPROCESSCMDI *)pMCDExec->pCmd;

                // Validate command buffer
                GET_MEMOBJ_RETVAL(pMemObj, pmp->hMCDPrimMem,
                                  (ULONG_PTR)pmp->pMCDFirstCmd);

                pMinMem = pMemObj->MCDMem.pMemBase;

                // Note: we ignore the memory size in the header since it
                // doesn't really help us...
	
                pMaxMem = pMinMem + pMemObj->MCDMem.memSize;

                CHECK_MEM_RANGE_RETVAL(pmp->pMCDFirstCmd, pMinMem,
                                       pMaxMem, (ULONG_PTR)pmp->pMCDFirstCmd);

                // Validate user-mode pointers passed down.
                __try
                {
                    EngProbeForRead(pmp->pMCDTransform, sizeof(MCDTRANSFORM),
                                    sizeof(DWORD));
                    // No meaningful check of the material changes can be
                    // done.  The driver is responsible for probing
                    // addresses used.
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return (ULONG_PTR)pmp->pMCDFirstCmd;
                }
                
                GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);

#if MCD_VER_MAJOR >= 2
                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvProcess)
                {
                    if (pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                    {
                        (*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                            (&pMCDExec->MCDSurface,
                             &pMCDExec->pRcPriv->MCDRc);
                    }
                    return (ULONG_PTR)pmp->pMCDFirstCmd;
                }

                return (pMCDExec->pGlobal->mcdDriver.pMCDrvProcess)(
                        &pMCDExec->MCDSurface, &pMCDExec->pRcPriv->MCDRc,
                        &pMemObj->MCDMem, (UCHAR *)pmp->pMCDFirstCmd, pMaxMem,
                        pmp->cmdFlagsAll, pmp->primFlags, pmp->pMCDTransform,
                        pmp->pMCDMatChanges);
#else
                if (pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                {
                    (*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                        (&pMCDExec->MCDSurface,
                         &pMCDExec->pRcPriv->MCDRc);
                }
                return (ULONG_PTR)pmp->pMCDFirstCmd;
#endif // 2.0
            }
            break;
            
        default:
            MCDBG_PRINT("MCDSrvProcess: "
                        "Null rendering context invalid for command %d.",
                        pMCDExec->pCmd->command);
            return FALSE;
    }

    return FALSE;       // should never get here...
}



//****************************************************************************
// FreeRCObj()
//
// Engine callback for freeing the memory used for rendering-context
// handles.
//****************************************************************************

BOOL CALLBACK FreeRCObj(DRIVEROBJ *pDrvObj)
{
    MCDRCOBJ *pRcObj = (MCDRCOBJ *)pDrvObj->pvObj;
    MCDRCPRIV *pRcPriv = pRcObj->pRcPriv;

    if ((pRcPriv->bDrvValid) &&
        (pRcPriv->pGlobal->mcdDriver.pMCDrvDeleteContext))
    {
        (*pRcPriv->pGlobal->mcdDriver.pMCDrvDeleteContext)
            (&pRcPriv->MCDRc, pDrvObj->dhpdev);
    }

    MCDSrvLocalFree((UCHAR *)pRcPriv);
    MCDSrvLocalFree((UCHAR *)pRcObj);

    return TRUE;
}


//****************************************************************************
// MCDSrvCreateContext()
//
// Create a rendering context (RGBA or color-indexed) for the current
// hardware mode.  This call will also initialize window-tracking for
// the context (which is associated with the specified window).
//****************************************************************************

PRIVATE
MCDHANDLE MCDSrvCreateContext(MCDSURFACE *pMCDSurface,
                              MCDRCINFOPRIV *pMcdRcInfo,
                              MCDGLOBALINFO *pGlobal,
                              LONG iPixelFormat,
                              LONG iLayer,
                              HWND hWnd,
                              ULONG surfaceFlags,
                              ULONG contextFlags)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    MCDRCPRIV *pRcPriv;
    MCDHANDLE retVal;
    HWND hwnd;
    MCDRCOBJ *newRcObject;
    MCDRVTRACKWINDOWFUNC pTrackFunc = NULL;

    if (pGlobal->mcdDriver.pMCDrvCreateContext == NULL)
    {
        MCDBG_PRINT("MCDSrvCreateContext: No MCDrvCreateContext.");
        return NULL;
    }
    
    pRcPriv = (MCDRCPRIV *)MCDSrvLocalAlloc(0,sizeof(MCDRCPRIV));

    if (!pRcPriv) {
        MCDBG_PRINT("MCDSrvCreateContext: Could not allocate new context.");
        return (MCDHANDLE)NULL;
    }

    pRcPriv->pGlobal = pGlobal;
    
    // Cache the engine handle provided by the driver:

    pRcPriv->hDev = (*pGlobal->mcdDriver.pMCDrvGetHdev)(pMCDSurface);

    if (surfaceFlags & MCDSURFACE_HWND)
    {
        pMCDSurface->surfaceFlags |= MCDSURFACE_HWND;
    }
    if (surfaceFlags & MCDSURFACE_DIRECT)
    {
        pMCDSurface->surfaceFlags |= MCDSURFACE_DIRECT;
    }

    // cache the surface flags away in the private RC:

    pRcPriv->surfaceFlags = pMCDSurface->surfaceFlags;

    // Initialize tracking of this window with a MCDWINDOW
    // (via and WNDOBJ on NT) if we are not already tracking the
    // window:

    pWnd = MCDSrvNewMCDWindow(pMCDSurface, hWnd, pGlobal,
                              pRcPriv->hDev);
    if (pWnd == NULL)
    {
        MCDSrvLocalFree((HLOCAL)pRcPriv);
        return (MCDHANDLE)NULL;
    }
    pWndPriv = (MCDWINDOWPRIV *)pWnd;

    pRcPriv->hWnd = hWnd;

    newRcObject = (MCDRCOBJ *)MCDSrvLocalAlloc(0,sizeof(MCDRCOBJ));
    if (!newRcObject) {
        MCDSrvLocalFree((HLOCAL)pRcPriv);
        return (MCDHANDLE)NULL;
    }

    retVal = MCDEngCreateObject(newRcObject, FreeRCObj, pRcPriv->hDev);

    if (retVal) {
        newRcObject->pid = MCDEngGetProcessID();
        newRcObject->type = MCDHANDLE_RC;
        newRcObject->size = sizeof(MCDRCPRIV);
        newRcObject->pRcPriv = pRcPriv;
        newRcObject->handle = (MCDHANDLE)retVal;

        // Add the object to the list in the MCDWINDOW

        newRcObject->next = pWndPriv->objectList;
        pWndPriv->objectList = newRcObject;
    } else {
        MCDBG_PRINT("MCDSrvCreateContext: Could not create new handle.");

        MCDSrvLocalFree((HLOCAL)pRcPriv);
        MCDSrvLocalFree((HLOCAL)newRcObject);
        return (MCDHANDLE)NULL;
    }

    pRcPriv->bValid = TRUE;
    pRcPriv->scissorsEnabled = FALSE;
    pRcPriv->scissorsRect.left = 0;
    pRcPriv->scissorsRect.top = 0;
    pRcPriv->scissorsRect.right = 0;
    pRcPriv->scissorsRect.bottom = 0;
    pRcPriv->MCDRc.createFlags = contextFlags;
    pRcPriv->MCDRc.iPixelFormat = iPixelFormat;
    pRcPriv->MCDRc.iLayerPlane = iLayer;

    if (!(*pGlobal->mcdDriver.pMCDrvCreateContext)(pMCDSurface,
                                                   &pRcPriv->MCDRc,
                                                   &pMcdRcInfo->mri)) {
        DestroyMCDObj((HANDLE)retVal, MCDHANDLE_RC);
        return (MCDHANDLE)NULL;
    }

    // Return window private handle
    pMcdRcInfo->dwMcdWindow = (ULONG_PTR)pWndPriv->handle;

    // Now valid to call driver for deletion...

    pRcPriv->bDrvValid = TRUE;

    return (MCDHANDLE)retVal;
}


//****************************************************************************
// FreeTexObj()
//
// Engine callback for freeing the memory used for a texture.
//****************************************************************************

BOOL CALLBACK FreeTexObj(DRIVEROBJ *pDrvObj)
{
    MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)pDrvObj->pvObj;

    // We should never get called if the driver is missing this entry point,
    // but the extra check can't hurt!
    //
    // pGlobal can be NULL for partially constructed objects.  It
    // is only NULL prior to calling the driver for creation, so if
    // it's NULL there's no reason to call the driver for cleanup.

    if (pTexObj->pGlobal != NULL &&
        pTexObj->pGlobal->mcdDriver.pMCDrvDeleteTexture != NULL)
    {
        (*pTexObj->pGlobal->mcdDriver.pMCDrvDeleteTexture)
            (&pTexObj->MCDTexture, pDrvObj->dhpdev);
    }

    MCDSrvLocalFree((HLOCAL)pTexObj);

    return TRUE;
}


//****************************************************************************
// MCDSrvCreateTexture()
//
// Creates an MCD texture.
//****************************************************************************

PRIVATE
MCDHANDLE MCDSrvCreateTexture(MCDEXEC *pMCDExec, MCDTEXTUREDATA *pTexData,
                              VOID *pSurface, ULONG flags)
{
    MCDRCPRIV *pRcPriv;
    MCDHANDLE hTex;
    MCDTEXOBJ *pTexObj;

    pRcPriv = pMCDExec->pRcPriv;

    if ((!pMCDExec->pGlobal->mcdDriver.pMCDrvDeleteTexture) ||
        (!pMCDExec->pGlobal->mcdDriver.pMCDrvCreateTexture)) {
        return (MCDHANDLE)NULL;
    }

    pTexObj = (MCDTEXOBJ *) MCDSrvLocalAlloc(0,sizeof(MCDTEXOBJ));
    if (!pTexObj) {
        MCDBG_PRINT("MCDCreateTexture: Could not allocate texture object.");
        return (MCDHANDLE)NULL;
    }

    hTex = MCDEngCreateObject(pTexObj, FreeTexObj, pRcPriv->hDev);

    if (!hTex) {
        MCDBG_PRINT("MCDSrvCreateTexture: Could not create texture object.");
        MCDSrvLocalFree((HLOCAL)pTexObj);
        return (MCDHANDLE)NULL;
    }

    // Initialize driver public information for driver call, but not
    // the private information.  The private information is not filled out
    // until after the driver call succeeds so that FreeTexObj knows
    // whether to call the driver or not when destroying a texture object.
    pTexObj->MCDTexture.pSurface = pSurface;
    pTexObj->MCDTexture.pMCDTextureData = pTexData;
    pTexObj->MCDTexture.createFlags = flags;

    // Call the driver if everything has gone well...

    if (!(*pMCDExec->pGlobal->mcdDriver.pMCDrvCreateTexture)
        (&pMCDExec->MCDSurface,
         &pRcPriv->MCDRc,
         &pTexObj->MCDTexture)) {
        //MCDBG_PRINT("MCDSrvCreateTexture: Driver could not create texture.");
        MCDEngDeleteObject(hTex);
        return (MCDHANDLE)NULL;
    }

    if (!pTexObj->MCDTexture.textureKey) {
        MCDBG_PRINT("MCDSrvCreateTexture: Driver returned null key.");
        MCDEngDeleteObject(hTex);
        return (MCDHANDLE)NULL;
    }

    pTexObj->pid = MCDEngGetProcessID();
    pTexObj->type = MCDHANDLE_TEXTURE;
    pTexObj->size = sizeof(MCDTEXOBJ);
    pTexObj->pGlobal = pMCDExec->pGlobal;

    return (MCDHANDLE)hTex;
}


//****************************************************************************
// FreeMemObj()
//
// Engine callback for freeing memory used by shared-memory handles.
//****************************************************************************

BOOL CALLBACK FreeMemObj(DRIVEROBJ *pDrvObj)
{
    MCDMEMOBJ *pMemObj = (MCDMEMOBJ *)pDrvObj->pvObj;

    // Free the memory using our engine ONLY if it is the same memory
    // we allocated in the first place.

    if (pMemObj->pMemBaseInternal)
        MCDEngFreeSharedMem(pMemObj->pMemBaseInternal);

    // pGlobal can be NULL for partially constructed objects.  It
    // is only NULL prior to calling the driver for creation, so if
    // it's NULL there's no reason to call the driver for cleanup.
    if (pMemObj->pGlobal != NULL &&
        pMemObj->pGlobal->mcdDriver.pMCDrvDeleteMem != NULL)
    {
        (*pMemObj->pGlobal->mcdDriver.pMCDrvDeleteMem)
            (&pMemObj->MCDMem, pDrvObj->dhpdev);
    }

    MCDSrvLocalFree((HLOCAL)pMemObj);

    return TRUE;
}


//****************************************************************************
// MCDSrvAllocMem()
//
// Creates a handle associated with the specified memory.
//****************************************************************************

PRIVATE
UCHAR * MCDSrvAllocMem(MCDEXEC *pMCDExec, ULONG numBytes,
                       ULONG flags, MCDHANDLE *phMem)
{
    MCDRCPRIV *pRcPriv;
    MCDHANDLE hMem;
    MCDMEMOBJ *pMemObj;

    pRcPriv = pMCDExec->pRcPriv;

    *phMem = (MCDHANDLE)FALSE;

    pMemObj = (MCDMEMOBJ *) MCDSrvLocalAlloc(0,sizeof(MCDMEMOBJ));

    if (!pMemObj) {
        MCDBG_PRINT("MCDSrvAllocMem: Could not allocate memory object.");
        return (MCDHANDLE)NULL;
    }

    hMem = MCDEngCreateObject(pMemObj, FreeMemObj, pRcPriv->hDev);

    if (!hMem) {
        MCDBG_PRINT("MCDSrvAllocMem: Could not create memory object.");
        MCDSrvLocalFree((HLOCAL)pMemObj);
        return (UCHAR *)NULL;
    }

    pMemObj->MCDMem.pMemBase = pMemObj->pMemBaseInternal =
        MCDEngAllocSharedMem(numBytes);

    if (!pMemObj->MCDMem.pMemBase) {
        MCDBG_PRINT("MCDSrvAllocMem: Could not allocate memory.");
        MCDEngDeleteObject(hMem);
        return (UCHAR *)NULL;
    }

    // Call the driver if everything has gone well, and the driver
    // entry points exist...

    if ((pMCDExec->pGlobal->mcdDriver.pMCDrvCreateMem) &&
        (pMCDExec->pGlobal->mcdDriver.pMCDrvDeleteMem)) {

        if (!(*pMCDExec->pGlobal->mcdDriver.pMCDrvCreateMem)
            (&pMCDExec->MCDSurface,
             &pMemObj->MCDMem)) {
            MCDBG_PRINT("MCDSrvAllocMem: "
                        "Driver not create memory type %x.", flags);
            MCDEngDeleteObject(hMem);
            return (UCHAR *)NULL;
        }
    }

    // Free the memory allocated with our engine if the driver has substituted
    // its own allocation...

    if (pMemObj->MCDMem.pMemBase != pMemObj->pMemBaseInternal) {
        MCDEngFreeSharedMem(pMemObj->pMemBaseInternal);
        pMemObj->pMemBaseInternal = (UCHAR *)NULL;
    }

    // Set up the private portion of memory object:

    pMemObj->pid = MCDEngGetProcessID();
    pMemObj->type = MCDHANDLE_MEM;
    pMemObj->size = sizeof(MCDMEMOBJ);
    pMemObj->pGlobal = pMCDExec->pGlobal;
    pMemObj->MCDMem.memSize = numBytes;
    pMemObj->MCDMem.createFlags = flags;

    *phMem = hMem;

    return pMemObj->MCDMem.pMemBase;
}


PRIVATE
ULONG MCDSrvQueryMemStatus(MCDEXEC *pMCDExec, MCDHANDLE hMCDMem)
{
    MCDMEMOBJ *pMemObj;

    pMemObj = (MCDMEMOBJ *)MCDEngGetPtrFromHandle(hMCDMem, MCDHANDLE_MEM);

    if (!pMemObj)
        return MCD_MEM_INVALID;

    if (pMemObj->lockCount)
        return MCD_MEM_BUSY;
    else
        return MCD_MEM_READY;
}


PRIVATE
BOOL MCDSrvSetScissor(MCDEXEC *pMCDExec, RECTL *pRect, BOOL bEnabled)
{
    MCDRCPRIV *pRcPriv;
    MCDRCOBJ *pRcObj;
    HWND hWnd;
    ULONG retVal = FALSE;

    pRcPriv = pMCDExec->pRcPriv;

    pRcPriv->scissorsEnabled = bEnabled;
    pRcPriv->scissorsRect = *pRect;

    return TRUE;
}


//****************************************************************************
// DestroyMCDObj()
//
// Deletes the specified object.  This can be memory, textures, or rendering
// contexts.
//
//****************************************************************************

PRIVATE
BOOL DestroyMCDObj(MCDHANDLE handle, MCDHANDLETYPE handleType)
{
    CHAR *pObject;

    pObject = (CHAR *)MCDEngGetPtrFromHandle(handle, handleType);

    if (!pObject)
        return FALSE;

//!!! Check for PID here...

    return (MCDEngDeleteObject(handle) != 0);
}


//****************************************************************************
// DecoupleMCDWindowObj()
//
// Breaks any existing links between an MCDWINDOW and its WNDOBJ
//****************************************************************************

PRIVATE
VOID DecoupleMCDWindow(MCDWINDOWPRIV *pWndPriv)
{
    // Clean up any outstanding lock
    MCDSrvUnlock(pWndPriv);

    // Delete reference in WNDOBJ.  WNDOBJ itself will be cleaned
    // up through normal window cleanup.
    if (pWndPriv->pwo != NULL)
    {
	if (pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
	{
	    (*pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
                (pWndPriv->pwo, (MCDWINDOW *)pWndPriv, WOC_DELETE);
	}

        WNDOBJ_vSetConsumer(pWndPriv->pwo, NULL);

	pWndPriv->pwo = NULL;
    }
}


//****************************************************************************
// DestroyMCDWindowObj()
//
// Destroy the specified MCDWINDOW and any associated handles (such rendering
// contexts).
//****************************************************************************

PRIVATE
VOID DestroyMCDWindowObj(MCDWINDOWOBJ *pmwo)
{
    MCDWINDOWPRIV *pWndPriv = &pmwo->MCDWindowPriv;
    MCDRCOBJ *nextObject;

    DecoupleMCDWindow(pWndPriv);

    // Delete all of the rendering contexts associated with the window:

#if _WIN95_
    while (pWndPriv->objectList)
    {
        nextObject = pWndPriv->objectList->next;
        MCDEngDeleteObject(pWndPriv->objectList->handle);
        pWndPriv->objectList = nextObject;
    }
#endif

    if (pWndPriv->pAllocatedClipBuffer)
        MCDSrvLocalFree(pWndPriv->pAllocatedClipBuffer);

    // Free the memory

    MCDSrvLocalFree((HLOCAL)pmwo);
}


//****************************************************************************
// GetScissorClip()
//
// Generate a new clip list based on the current list of clip rectanges
// for the window, and the specified scissor rectangle.
//****************************************************************************

PRIVATE
VOID GetScissorClip(MCDWINDOWPRIV *pWndPriv, MCDRCPRIV *pRcPriv)
{
    MCDWINDOW *pWnd;
    MCDENUMRECTS *pClipUnscissored;
    MCDENUMRECTS *pClipScissored;
    RECTL *pRectUnscissored;
    RECTL *pRectScissored;
    RECTL rectScissor;
    ULONG numUnscissoredRects;
    ULONG numScissoredRects;

    pWnd = (MCDWINDOW *)pWndPriv;

    if (!pRcPriv || !pRcPriv->scissorsEnabled)
    {
        // Scissors aren't enabled, so the unscissored and scissored
        // clip lists are identical:

        pWnd->pClip = pWnd->pClipUnscissored = pWndPriv->pClipUnscissored;
    }
    else
    {
        // The scissored list will go in the second half of our clip
        // buffer:

        pClipUnscissored
            = pWndPriv->pClipUnscissored;

        pClipScissored
            = (MCDENUMRECTS*) ((BYTE*) pClipUnscissored + pWndPriv->sizeClipBuffer / 2);

        pWnd->pClip = pWndPriv->pClipScissored = pClipScissored;
	pWnd->pClipUnscissored = pClipUnscissored;

        // Convert scissor to screen coordinates:

        rectScissor.left   = pRcPriv->scissorsRect.left   + pWndPriv->MCDWindow.clientRect.left;
        rectScissor.right  = pRcPriv->scissorsRect.right  + pWndPriv->MCDWindow.clientRect.left;
        rectScissor.top    = pRcPriv->scissorsRect.top    + pWndPriv->MCDWindow.clientRect.top;
        rectScissor.bottom = pRcPriv->scissorsRect.bottom + pWndPriv->MCDWindow.clientRect.top;

        pRectUnscissored = &pClipUnscissored->arcl[0];
        pRectScissored = &pClipScissored->arcl[0];
        numScissoredRects = 0;

        for (numUnscissoredRects = pClipUnscissored->c;
             numUnscissoredRects != 0;
             numUnscissoredRects--, pRectUnscissored++)
        {
            // Since our clipping rectangles are ordered from top to
            // bottom, we can early-out if the tops of the remaining
            // rectangles are not in the scissor rectangle

            if (rectScissor.bottom <= pRectUnscissored->top)
                break;

            // Continue without updating new clip list is there is
            // no overlap.

            if ((rectScissor.left  >= pRectUnscissored->right)  ||
                (rectScissor.top   >= pRectUnscissored->bottom) ||
                (rectScissor.right <= pRectUnscissored->left))
               continue;

            // If we reach this point, we must intersect the given rectangle
            // with the scissor.

            MCDIntersectRect(pRectScissored, pRectUnscissored, &rectScissor);

            numScissoredRects++;
            pRectScissored++;
        }

        pClipScissored->c = numScissoredRects;
    }
}

//****************************************************************************
// GetClipLists()
//
// Updates the clip list for the specified window.  Space is also allocated
// the scissored clip list.
//
//****************************************************************************

PRIVATE
VOID GetClipLists(WNDOBJ *pwo, MCDWINDOWPRIV *pWndPriv)
{
    MCDENUMRECTS *pDefault;
    ULONG numClipRects;
    char *pClipBuffer;
    ULONG sizeClipBuffer;

    pDefault = (MCDENUMRECTS*) &pWndPriv->defaultClipBuffer[0];

#if 1
    if (pwo->coClient.iDComplexity == DC_TRIVIAL)
    {
        if ((pwo->rclClient.left >= pwo->rclClient.right) ||
            (pwo->rclClient.top  >= pwo->rclClient.bottom))
        {
            pDefault->c = 0;
        }
        else
        {
            pDefault->c = 1;
            pDefault->arcl[0] = pwo->rclClient;
        }
    }
    else if (pwo->coClient.iDComplexity == DC_RECT)
#else
    if (pwo->coClient.iDComplexity == DC_RECT)
#endif
    {
        if (pWndPriv->pAllocatedClipBuffer)
            MCDSrvLocalFree(pWndPriv->pAllocatedClipBuffer);
        pWndPriv->pAllocatedClipBuffer = NULL;
        pWndPriv->pClipUnscissored = pDefault;
        pWndPriv->pClipScissored = pDefault;
        pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;

        if ((pwo->coClient.rclBounds.left >= pwo->coClient.rclBounds.right) ||
            (pwo->coClient.rclBounds.top  >= pwo->coClient.rclBounds.bottom))
        {
            // Full-screen VGA mode is represented by a DC_RECT clip object
            // with an empty bounding rectangle.  We'll denote it by
            // setting the rectangle count to zero:

            pDefault->c = 0;
        }
        else
        {
            pDefault->c = 1;
            pDefault->arcl[0] = pwo->coClient.rclBounds;
        }
    }
    else
    {
        WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Note that this is divide-by-2 for the buffer size because we
        // need room for two copies of the rectangle list:

        if (WNDOBJ_bEnum(pwo, SIZE_DEFAULT_CLIP_BUFFER / 2, (ULONG*) pDefault))
        {
            // Okay, the list of rectangles won't fit in our default buffer.
            // Unfortunately, there is no way to obtain the total count of clip
            // rectangles other than by enumerating them all, as cEnumStart
            // will occasionally give numbers that are far too large (because
            // GDI itself doesn't feel like counting them all).
            //
            // Note that we can use the full default buffer here for this
            // enumeration loop:

            numClipRects = pDefault->c;
            while (WNDOBJ_bEnum(pwo, SIZE_DEFAULT_CLIP_BUFFER, (ULONG*) pDefault))
                numClipRects += pDefault->c;

            // Don't forget that we are given a valid output buffer even
            // when 'bEnum' returns FALSE:

            numClipRects += pDefault->c;

            pClipBuffer = pWndPriv->pAllocatedClipBuffer;
            sizeClipBuffer = 2 * (numClipRects * sizeof(RECTL) + sizeof(ULONG));

            if ((pClipBuffer == NULL) || (sizeClipBuffer > pWndPriv->sizeClipBuffer))
            {
                // Our allocated buffer is too small; we have to free it and
                // allocate a new one.  Take the opportunity to add some
                // growing room to our allocation:

                sizeClipBuffer += 8 * sizeof(RECTL);    // Arbitrary growing room

                if (pClipBuffer)
                    MCDSrvLocalFree(pClipBuffer);

                pClipBuffer = (char *) MCDSrvLocalAlloc(LMEM_FIXED, sizeClipBuffer);

                if (pClipBuffer == NULL)
                {
                    // Oh no: we couldn't allocate enough room for the clip list.
                    // So pretend we have no visible area at all:

                    pWndPriv->pAllocatedClipBuffer = NULL;
                    pWndPriv->pClipUnscissored = pDefault;
                    pWndPriv->pClipScissored = pDefault;
                    pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
                    pDefault->c = 0;
                    return;
                }

                pWndPriv->pAllocatedClipBuffer = pClipBuffer;
                pWndPriv->pClipUnscissored = (MCDENUMRECTS*) pClipBuffer;
                pWndPriv->pClipScissored = (MCDENUMRECTS*) pClipBuffer;
                pWndPriv->sizeClipBuffer = sizeClipBuffer;
            }

            // Now actually get all the clip rectangles:

            WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, 0);
            WNDOBJ_bEnum(pwo, sizeClipBuffer, (ULONG*) pClipBuffer);
        }
        else
        {
            // How nice, there are no more clip rectangles, which meant that
            // the entire list fits in our default clip buffer, with room
            // for the scissored version of the list:

            if (pWndPriv->pAllocatedClipBuffer)
                MCDSrvLocalFree(pWndPriv->pAllocatedClipBuffer);
            pWndPriv->pAllocatedClipBuffer = NULL;
            pWndPriv->pClipUnscissored = pDefault;
            pWndPriv->pClipScissored = pDefault;
            pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
        }
    }
}


//****************************************************************************
// WndObjChangeProc()
//
// This is the callback function for window-change notification.  We update
// our clip list, and also allow the hardware to respond to the client
// and surface deltas, as well as the client message itself.
//****************************************************************************

VOID CALLBACK WndObjChangeProc(WNDOBJ *pwo, FLONG fl)
{
    MCDGLOBALINFO *pGlobal;
    
    if (pwo)
    {
        MCDWINDOWPRIV *pWndPriv = (MCDWINDOWPRIV *)pwo->pvConsumer;

        //MCDBG_PRINT("WndObjChangeProc: %s, pWndPriv = 0x%08lx\n",
        //    fl == WOC_RGN_CLIENT        ? "WOC_RGN_CLIENT       " :
        //    fl == WOC_RGN_CLIENT_DELTA  ? "WOC_RGN_CLIENT_DELTA " :
        //    fl == WOC_RGN_SURFACE       ? "WOC_RGN_SURFACE      " :
        //    fl == WOC_RGN_SURFACE_DELTA ? "WOC_RGN_SURFACE_DELTA" :
        //    fl == WOC_DELETE            ? "WOC_DELETE           " :
        //                                  "unknown",
        //    pWndPriv);

    //!!!HACK -- surface region tracking doesn't have an MCDWINDOWPRIV (yet...)

    // Client region tracking and deletion requires a valid MCDWINDOWPRIV.

        if (((fl == WOC_RGN_CLIENT) || (fl == WOC_RGN_CLIENT_DELTA) ||
             (fl == WOC_DELETE)))
        {
            if (!pWndPriv)
            {
                return;
            }

            // Invalidate cache because buffers may have moved
            pWndPriv->bBuffersValid = FALSE;
        }

        switch (fl)
        {
            case WOC_RGN_CLIENT:        // Capture the clip list

                GetClipLists(pwo, pWndPriv);

                pWndPriv->MCDWindow.clientRect = pwo->rclClient;
                pWndPriv->MCDWindow.clipBoundsRect = pwo->coClient.rclBounds;
		pWndPriv->bRegionValid = TRUE;
                if (pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow != NULL)
                {
                    (*pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
                        (pwo, (MCDWINDOW *)pWndPriv, fl);
                }
                break;

            case WOC_RGN_CLIENT_DELTA:
                if (pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow != NULL)
                {
                    (*pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
                        (pwo, (MCDWINDOW *)pWndPriv, fl);
                }
                break;

            case WOC_RGN_SURFACE:
            case WOC_RGN_SURFACE_DELTA:

            //!!!HACK -- use NULL for pWndPriv; we didn't set it, so we can't
            //!!!        trust it

                pGlobal = MCDSrvGetGlobalInfo(pwo->psoOwner);
                if (pGlobal != NULL &&
                    pGlobal->mcdDriver.pMCDrvTrackWindow != NULL)
                {
                    (pGlobal->mcdDriver.pMCDrvTrackWindow)
                        (pwo, (MCDWINDOW *)NULL, fl);
                }
                break;

            case WOC_DELETE:
            //MCDBG_PRINT("WndObjChangeProc: WOC_DELETE.");

            // Window is being deleted, so destroy our private window data,
            // and set the consumer field of the WNDOBJ to NULL:

                if (pWndPriv)
                {
		    DecoupleMCDWindow(pWndPriv);
                }
                break;

            default:
                break;
         }
    }
}

//****************************************************************************
// FreeMCDWindowObj()
//
// Callback to clean up MCDWINDOWs
//****************************************************************************

BOOL CALLBACK FreeMCDWindowObj(DRIVEROBJ *pDrvObj)
{
    MCDWINDOWOBJ *pmwo = (MCDWINDOWOBJ *)pDrvObj->pvObj;

    DestroyMCDWindowObj(pmwo);

    return TRUE;
}

//****************************************************************************
// NewMCDWindowObj()
//
// Creates and initializes a new MCDWINDOW and initializes tracking of the
// associated window through callback notification.
//****************************************************************************

PRIVATE
MCDWINDOWOBJ *NewMCDWindowObj(MCDSURFACE *pMCDSurface,
                              MCDGLOBALINFO *pGlobal,
                              HDEV hdev)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    MCDWINDOWOBJ *pmwo;
    MCDENUMRECTS *pDefault;
    MCDHANDLE handle;

    pmwo = (MCDWINDOWOBJ *)MCDSrvLocalAlloc(0, sizeof(MCDWINDOWOBJ));
    if (!pmwo)
    {
        return NULL;
    }

    // Create a driver object for this window
    handle = MCDEngCreateObject(pmwo, FreeMCDWindowObj, hdev);
    if (handle == 0)
    {
        MCDBG_PRINT("NewMCDWindow: Could not create new handle.");
        MCDSrvLocalFree((UCHAR *)pmwo);
        return NULL;
    }

    pWndPriv = &pmwo->MCDWindowPriv;
    pWnd = &pWndPriv->MCDWindow;

    // Initialize the structure members:

    pmwo->type = MCDHANDLE_WINDOW;
    pWndPriv->objectList = NULL;
    pWndPriv->handle = handle;
    pWndPriv->bBuffersValid = FALSE;
    pWndPriv->pGlobal = pGlobal;

    // Initialize the clipping:

    pDefault = (MCDENUMRECTS*) &pWndPriv->defaultClipBuffer[0];
    pDefault->c = 0;
    pWndPriv->pAllocatedClipBuffer = NULL;
    pWndPriv->pClipUnscissored = pDefault;
    pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
    pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
    pWnd->pClip = pDefault;

    return pmwo;
}


//****************************************************************************
// MCDSrvNewWndObj()
//
// Creates a new WNDOBJ for window tracking.
//****************************************************************************

PRIVATE
WNDOBJ *MCDSrvNewWndObj(MCDSURFACE *pMCDSurface, HWND hWnd, WNDOBJ *pwoIn,
                        MCDGLOBALINFO *pGlobal, HDEV hdev)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    WNDOBJ *pwo;
    MCDWINDOWOBJ *pmwo;

    pmwo = NewMCDWindowObj(pMCDSurface, pGlobal, hdev);
    if (!pmwo)
    {
        return NULL;
    }

    pWndPriv = &pmwo->MCDWindowPriv;
    pWnd = &pWndPriv->MCDWindow;

    pWndPriv->hWnd = hWnd;

    // Handle the case where a WNDOBJ already exists but hasn't been
    // initialized for MCD usage in addition to the new creation case.
    if (pwoIn == NULL)
    {
        pwo = MCDEngCreateWndObj(pMCDSurface, hWnd, WndObjChangeProc);

        if (!pwo || ((LONG_PTR)pwo == -1))
        {
            MCDBG_PRINT("NewMCDWindowTrack: could not create WNDOBJ.");
            MCDEngDeleteObject(pmwo->MCDWindowPriv.handle);
            return NULL;
        }
    }
    else
    {
        pwo = pwoIn;
    }

    // Set the consumer field in the WNDOBJ:

    WNDOBJ_vSetConsumer(pwo, (PVOID)pWndPriv);

    // Point back to the WNDOBJ
    pWndPriv->pwo = pwo;

    return pwo;
}

//****************************************************************************
// MCDSrvNewMcdWindow()
//
// Creates a new MCDWINDOW for window tracking.
//****************************************************************************

PRIVATE
MCDWINDOW *MCDSrvNewMCDWindow(MCDSURFACE *pMCDSurface, HWND hWnd,
                              MCDGLOBALINFO *pGlobal, HDEV hdev)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    MCDWINDOWOBJ *pmwo;

    // Initialize tracking of this window with a MCDWINDOW
    // (via a WNDOBJ on NT) if we are not already tracking the
    // window:

    if (pMCDSurface->surfaceFlags & MCDSURFACE_HWND)
    {
        WNDOBJ *pwo;

        pwo = MCDEngGetWndObj(pMCDSurface);

        // Sometimes a WNDOBJ has been used and the MCD state destroyed so
	// the consumer is NULL but the WNDOBJ exists.  In that case
	// we need to create a new MCDWINDOW for it.
        if (!pwo || !pwo->pvConsumer)
        {
	    pwo = MCDSrvNewWndObj(pMCDSurface, hWnd, pwo, pGlobal, hdev);

            if (!pwo)
            {
                MCDBG_PRINT("MCDSrvNewMcdWindow: "
                            "Creation of window object failed.");
                return NULL;
            }

            ((MCDWINDOW *)pwo->pvConsumer)->pvUser = NULL;
        }

        pWnd = (MCDWINDOW *)pwo->pvConsumer;
    }
    else
    {
#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
        MCDENUMRECTS *pDefault;
        PDD_SURFACE_GLOBAL pGbl;

        pmwo = NewMCDWindowObj(pMCDSurface, pGlobal, hdev);
        if (!pmwo)
        {
            MCDBG_PRINT("MCDSrvNewMcdWindow: "
                        "Creation of window object failed.");
            return NULL;
        }

        pWnd = &pmwo->MCDWindowPriv.MCDWindow;

        // Real clipping info
        pWndPriv = (MCDWINDOWPRIV *)pWnd;

        pGbl = ((PDD_SURFACE_LOCAL)pMCDSurface->frontId)->lpGbl;
        pWndPriv->MCDWindow.clientRect.left = pGbl->xHint;
        pWndPriv->MCDWindow.clientRect.top = pGbl->yHint;
        pWndPriv->MCDWindow.clientRect.right = pGbl->xHint+pGbl->wWidth;
        pWndPriv->MCDWindow.clientRect.bottom = pGbl->yHint+pGbl->wHeight;
        pWndPriv->MCDWindow.clipBoundsRect = pWndPriv->MCDWindow.clientRect;
        pWndPriv->bRegionValid = TRUE;

        pDefault = (MCDENUMRECTS*) &pWndPriv->defaultClipBuffer[0];
        pDefault->c = 1;
        pDefault->arcl[0] = pWndPriv->MCDWindow.clientRect;
#else
        return NULL;
#endif // 1.1
    }

    pMCDSurface->pWnd = pWnd;
    pWndPriv = (MCDWINDOWPRIV *)pWnd;
    pWndPriv->hWnd = hWnd;

    return pWnd;
}

////////////////////////////////////////////////////////////////////////////
//
//
// MCD locking support.
//
//
////////////////////////////////////////////////////////////////////////////


//****************************************************************************
// ULONG MCDSrvLock(MCDWINDOWPRIV *pWndPriv);
//
// Lock the MCD driver for the specified window.  Fails if lock is already
// held by another window.
//****************************************************************************

ULONG MCDSrvLock(MCDWINDOWPRIV *pWndPriv)
{
    ULONG ulRet = MCD_LOCK_BUSY;
    MCDLOCKINFO *pLockInfo;

    pLockInfo = &pWndPriv->pGlobal->lockInfo;
    if (!pLockInfo->bLocked || pLockInfo->pWndPrivOwner == pWndPriv)
    {
        pLockInfo->bLocked = TRUE;
        pLockInfo->pWndPrivOwner = pWndPriv;
        ulRet = MCD_LOCK_TAKEN;
    }

    return ulRet;
}


//****************************************************************************
// VOID MCDSrvUnlock(MCDWINDOWPRIV *pWndPriv);
//
// Releases the MCD driver lock if held by the specified window.
//****************************************************************************

VOID MCDSrvUnlock(MCDWINDOWPRIV *pWndPriv)
{
    MCDLOCKINFO *pLockInfo;

    //!!!dbug -- could add a lock count, but not really needed right now

    pLockInfo = &pWndPriv->pGlobal->lockInfo;
    if (pLockInfo->pWndPrivOwner == pWndPriv)
    {
        pLockInfo->bLocked = FALSE;
        pLockInfo->pWndPrivOwner = 0;
    }
}


//****************************************************************************
// 
// Per-driver-instance information list handling.
//
//****************************************************************************

#define GLOBAL_INFO_BLOCK 8

ENGSAFESEMAPHORE ssemGlobalInfo;
MCDGLOBALINFO *pGlobalInfo;
int iGlobalInfoAllocated = 0;
int iGlobalInfoUsed = 0;

BOOL MCDSrvInitGlobalInfo(void)
{
    return EngInitializeSafeSemaphore(&ssemGlobalInfo);
}

MCDGLOBALINFO *MCDSrvAddGlobalInfo(SURFOBJ *pso)
{
    MCDGLOBALINFO *pGlobal;
    
    EngAcquireSemaphore(ssemGlobalInfo.hsem);

    // Ensure space for new entry
    if (iGlobalInfoUsed >= iGlobalInfoAllocated)
    {
        pGlobal = (MCDGLOBALINFO *)
            MCDSrvLocalAlloc(0, (iGlobalInfoAllocated+GLOBAL_INFO_BLOCK)*
                             sizeof(MCDGLOBALINFO));
        if (pGlobal != NULL)
        {
            // Copy old data if necessary
            if (iGlobalInfoAllocated > 0)
            {
                memcpy(pGlobal, pGlobalInfo, iGlobalInfoAllocated*
                       sizeof(MCDGLOBALINFO));
                MCDSrvLocalFree((UCHAR *)pGlobalInfo);
            }

            // Set new information
            pGlobalInfo = pGlobal;
            iGlobalInfoAllocated += GLOBAL_INFO_BLOCK;
            iGlobalInfoUsed++;

            // pGlobal is guaranteed zero-filled because of MCDSrvLocalAlloc's
            // behavior, so just fill in the pso.
            pGlobal += iGlobalInfoAllocated;
            pGlobal->pso = pso;
        }
        else
        {
            // Falls out and returns NULL
        }
    }
    else
    {
        MCDGLOBALINFO *pGlobal;
        int i;

        pGlobal = pGlobalInfo;
        for (i = 0; i < iGlobalInfoAllocated; i++)
        {
            if (pGlobal->pso == pso)
            {
                // This should never happen.
                MCDBG_PRINT("MCDSrvAddGlobalInfo: duplicate pso");
                pGlobal = NULL;
                break;
            }
                      
            if (pGlobal->pso == NULL)
            {
                iGlobalInfoUsed++;
                
                // Initialize pso for use.
                memset(pGlobal, 0, sizeof(*pGlobal));
                pGlobal->pso = pso;
                break;
            }

            pGlobal++;
        }
    }

    EngReleaseSemaphore(ssemGlobalInfo.hsem);

    return pGlobal;
}

MCDGLOBALINFO *MCDSrvGetGlobalInfo(SURFOBJ *pso)
{
    MCDGLOBALINFO *pGlobal;
    int i;

    // For backwards compatibility we handle one instance
    // using global data.  If the incoming pso matches the
    // pso in the static data then just return it.
    // It is important to check this before entering the semaphore
    // since the semaphore is not created if only legacy drivers
    // have attached.
    if (pso == gStaticGlobalInfo.pso)
    {
        return &gStaticGlobalInfo;
    }

    // Technically we shouldn't have to check this, since MCD processing
    // should not occur unless:
    // 1. It's an old style driver and hits the static case above.
    // 2. It's a new style driver and the semaphore has been created.
    // Unfortunately not all drivers are well-behaved, plus there's a
    // potentialy legacy driver bug where drivers don't check for init
    // failure and try to call MCD anyway.
    if (ssemGlobalInfo.hsem == NULL)
    {
        MCDBG_PRINT("MCDSrvGetGlobalInfo: no hsem");
        return NULL;
    }
    
    EngAcquireSemaphore(ssemGlobalInfo.hsem);

    pGlobal = pGlobalInfo;
    for (i = 0; i < iGlobalInfoAllocated; i++)
    {
        if (pGlobal->pso == pso)
        {
            break;
        }

        pGlobal++;
    }

    // Technically we shouldn't have to check this, because if
    // we made it into the non-static code path a matching pso should
    // be registered.  As with the above check, though, it's better
    // safe than sorry.
    if (i >= iGlobalInfoAllocated)
    {
        MCDBG_PRINT("MCDSrvGetGlobalInfo: no pso match");
        pGlobal = NULL;
    }
    
    EngReleaseSemaphore(ssemGlobalInfo.hsem);

    return pGlobal;
}

void MCDSrvUninitGlobalInfo(void)
{
    EngDeleteSafeSemaphore(&ssemGlobalInfo);
}

void WINAPI MCDEngUninit(SURFOBJ *pso)
{
    MCDGLOBALINFO *pGlobal;
    int i;

    // This should never happen.
    if (ssemGlobalInfo.hsem == NULL)
    {
        MCDBG_PRINT("MCDEngUninit: no hsem");
        return;
    }
    
    EngAcquireSemaphore(ssemGlobalInfo.hsem);

    pGlobal = pGlobalInfo;
    for (i = 0; i < iGlobalInfoAllocated; i++)
    {
        if (pGlobal->pso == pso)
        {
            break;
        }

        pGlobal++;
    }

    if (i >= iGlobalInfoAllocated)
    {
        // This should never happen.
        MCDBG_PRINT("MCDEngUninit: No pso match");
    }
    else if (--iGlobalInfoUsed == 0)
    {
        MCDSrvLocalFree((UCHAR *)pGlobalInfo);
        iGlobalInfoAllocated = 0;
    }
    else
    {
        pGlobal->pso = NULL;
    }
    
    EngReleaseSemaphore(ssemGlobalInfo.hsem);
    MCDSrvUninitGlobalInfo();
}

//****************************************************************************
// BOOL HalInitSystem(ULONG a, ULONG b)
//
// This is a dummy function needed to use the standard makefile.def since
// we're pretending we're an NT HAL.
//****************************************************************************

BOOL HalInitSystem(ULONG a, ULONG b)
{
    return TRUE;
}


//******************************Public*Routine******************************
//
// BOOL WINAPI DllEntry(HINSTANCE hDLLInst, DWORD fdwReason,
//                      LPVOID lpvReserved);
//
// DLL entry point invoked for each process and thread that attaches to
// this DLL.
//
//**************************************************************************

BOOL WINAPI DllEntry(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            // The DLL is being loaded for the first time by a given process.
            // Perform per-process initialization here.  If the initialization
            // is successful, return TRUE; if unsuccessful, return FALSE.
            break;

        case DLL_PROCESS_DETACH:
            // The DLL is being unloaded by a given process.  Do any
            // per-process clean up here, such as undoing what was done in
            // DLL_PROCESS_ATTACH.  The return value is ignored.

            break;

        case DLL_THREAD_ATTACH:
            // A thread is being created in a process that has already loaded
            // this DLL.  Perform any per-thread initialization here.  The
            // return value is ignored.

            break;

        case DLL_THREAD_DETACH:
            // A thread is exiting cleanly in a process that has already
            // loaded this DLL.  Perform any per-thread clean up here.  The
            // return value is ignored.

            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\aglmesh.cxx ===
/**     
 **       File       : aglmesh.cxx
 **       Description: Implementations of CAugGlMesh class
 **/
#include "precomp.h"
#pragma hdrstop

#include "array.h"
#include "aglmesh.h"
#include "pmerrors.h"
#include <math.h>

void interp(GLwedgeAttrib& a, const GLwedgeAttrib& a1,
            const GLwedgeAttrib& a2, float f1, float f2);


/**************************************************************************/

/*
 *  CAugGlMesh: Constructor
 */
CAugGlMesh::CAugGlMesh() : CSimpGlMesh ()
{
    //Dynamically allocated arrays
    m_fnei = NULL;
    m_facemap = NULL;
}


/*
 *  CAugGlMesh: Destructor
 */
CAugGlMesh::~CAugGlMesh()
{
    delete [] m_fnei;
    delete [] m_facemap;
}


PHASHENTRY* hashtable;
PHASHENTRY hashentries;
int freeptr, maxptr;

void CAugGlMesh::HashAdd(WORD va, WORD vb, WORD f)
{
#ifdef _DEBUG
    if (va > m_numWedges || va < 0)
        throw CHashOvrflw();
#endif
    for (PHASHENTRY* t = &(hashtable[va]); *t; t = &((*t)->next));
    PHASHENTRY p = &(hashentries[freeptr++]);
    p->f = f;
    p->v2 = vb;
    p->next = NULL;
    *t=p;
}

WORD CAugGlMesh::HashFind(WORD va, WORD vb)
{
#ifdef _DEBUG
    if (va > m_baseWedges || va < 0)
        throw CHashOvrflw();
#endif
    for (PHASHENTRY* t = &(hashtable[va]); *t; t = &((*t)->next))
    {
        if ((*t)->v2 == vb)
        {
            return (*t)->f;
        }
    }
    return USHRT_MAX;
}


void CAugGlMesh::ComputeAdjacency(void)
{
    freeptr = 0;
    maxptr = m_numFaces*3;
    hashtable = new PHASHENTRY[m_numWedges];

    // An entry for each 3 edges of each face in base mesh
    hashentries = new hashentry[maxptr];
    if (!hashtable)
        throw CExNewFailed();
    memset(hashtable, 0, sizeof(PHASHENTRY)*m_numWedges);

    /*
     * For each group of faces
     */
    for(int i=0; i < (int)m_numMaterials; ++i)
    { 
        /* 
         * For each face in the group
         */
        for (int k=m_matpos[i]; k<(m_matpos[i]+m_matcnt[i]); ++k)
        { 
            int v1 = FindVertexIndex((m_farray[k]).w[0]);
            int v2 = FindVertexIndex((m_farray[k]).w[1]);
            int v3 = FindVertexIndex((m_farray[k]).w[2]);
            
            HashAdd(v1,v2,k);
            HashAdd(v2,v3,k);
            HashAdd(v3,v1,k);
        }
    }

#ifdef _DEBUG
    if (freeptr > maxptr)
        throw CHashOvrflw();
#endif
    /*
     * For each group of faces
     */
    for(i=0; i < (int)m_numMaterials; ++i)
    { 
        /* 
         * For each face in the group
         */
        for (int k=m_matpos[i]; k<(m_matpos[i]+m_matcnt[i]); ++k)
        { 
            int v1 = FindVertexIndex((m_farray[k]).w[0]);
            int v2 = FindVertexIndex((m_farray[k]).w[1]);
            int v3 = FindVertexIndex((m_farray[k]).w[2]);

            m_fnei[k][0] = HashFind(v3,v2);
            m_fnei[k][1] = HashFind(v1,v3);
            m_fnei[k][2] = HashFind(v2,v1);
        }
    }
    delete [] hashtable;
    delete [] hashentries;
}


//  note: vspl is modified!
void CAugGlMesh::apply_vsplit(Vsplit& vspl)
{
    const BOOL isl = TRUE; 
    BOOL isr = vspl.vlr_offset1 > 1;
    HRESULT hr;
    
    /*
     * Get vertices, faces, and wedges in the neigbhorhood of the split.
     * Look at the diagram in mesh.vld for more information about the 
     * meanings of various variables.
     */

    WORD vs;
    WORD code=vspl.code;
    int ii=(code&Vsplit::II_MASK)>>Vsplit::II_SHIFT;
    WORD flccw, flclw;           // either (not both) may be UNDEF
    WORD frccw, frclw;           // either (or both) may be UNDEF
    WORD wlccw, wlclw, wrccw, wrclw; // ==UNDEF if faces do not exist
    int jlccw, jlclw, jrccw, jrclw;  // only defined if faces exist
    int jlclw2;
    WORD flmatid, frmatid;
    GLvertex glvs, glvt;             // vertices vs and vt
    PArray<WORD*,10> ar_pwedges;

    /* 
     * 1) Gather all the wedges surrounding Vs into ar_pwedges array
     * -------------------------------------------------------------
     */

    if (vspl.vlr_offset1 == 0) 
    {
        /* 
         * Extremely rare case when flclw does not exist.
         */
        flclw = UNDEF;
        wlclw = UNDEF;
        if (vspl.modified)
        {
            flccw = vspl.flclw;
        }
        else
        {
            flccw = WORD(m_facemap[WORD(vspl.flclw)]);
            vspl.flclw = flccw;
            vspl.modified = TRUE;
        }
        
        int vs_index = (code & Vsplit::VSINDEX_MASK)>>Vsplit::VSINDEX_SHIFT;
        jlccw = vs_index;
        wlccw = m_farray[flccw].w[jlccw];
        vs = FindVertexIndex(wlccw);
        frccw = frclw = wrccw = wrclw = UNDEF;
    } 
    else 
    {
        if (vspl.modified)
        {
            flclw = vspl.flclw;
        }
        else
        {
            flclw = WORD(m_facemap[WORD(vspl.flclw)]);
            vspl.flclw = flclw;
            vspl.modified = TRUE;
        }
        
        //flclw = WORD(m_facemap[WORD(vspl.flclw)]);
        int vs_index = (code&Vsplit::VSINDEX_MASK)>>Vsplit::VSINDEX_SHIFT;
        
        jlclw = vs_index;       //The vs's index
        jlclw2 = (jlclw + 2)%3; //The vl's index

        WORD* pwlclw = &(m_farray[flclw].w[jlclw]);
        wlclw = *pwlclw;
        vs = FindVertexIndex (wlclw);
        flccw = m_fnei[flclw][(jlclw+1)%3];
        if (flccw == UNDEF) 
        {
            wlccw = UNDEF;
        } 
        else 
        {
            gather_vf_jw(vs, flccw, jlccw, wlccw);
        }

        if (!isr) 
        {
            frccw = frclw = wrccw = wrclw = UNDEF;
            ar_pwedges += pwlclw;

            /*
             *  Rotate around and record all wedges CLW from wlclw.
             */
            int j0 = jlclw, j2 = jlclw2;
            WORD f = flclw;
            for (;;) 
            {
                f = m_fnei[f][j2];
                if (f == UNDEF) break;
                WORD* pw;
                gather_vf_j0j2pw (vs, f, j0, j2, pw);
                ar_pwedges += pw;
            }
        } 
        else 
        {
            ar_pwedges.init (vspl.vlr_offset1 - 1);
            ar_pwedges[0] = pwlclw;

            /* 
             * Rotate around the first vlr_offset-1 faces.
             */
            int j0 = jlclw, j2 = jlclw2;
            WORD f = flclw;
            for(int count=0; count < vspl.vlr_offset1-2; ++count) 
            {
                f = m_fnei[f][j2];
                WORD* pw;
                gather_vf_j0j2pw (vs, f, j0, j2, pw);
                ar_pwedges[count+1] = pw;
            }
            frccw=f;

            /* 
             * On the last face, find adjacent faces.
             */
            jrccw = j0;
            wrccw = m_farray[frccw].w[jrccw];
            frclw = m_fnei[frccw][j2];
            if (frclw==UNDEF) 
            {
                wrclw=UNDEF;
            } 
            else 
            {
                gather_vf_jw(vs,frclw,jrclw,wrclw);
            }
        }
    }


    /*
     * 2) Obtain the matIDs of the two new faces generated by applying vsplit.
     * -----------------------------------------------------------------------
     *    ?? could use L_MASK instead of ii for prediction instead.
     *    face_prediction() is the shady part.
     */

    if (code & Vsplit::FLN_MASK)
    {
        flmatid = vspl.fl_matid;
    }
    else
    {
        flmatid = MatidOfFace(face_prediction(flclw,flccw,ii));
        // save computed value for undo_vsplit and future vsplits
        vspl.fl_matid = flmatid;
        vspl.code |= Vsplit::FLN_MASK;
    }

    if (isr)
    {
        if (code&Vsplit::FRN_MASK)
            frmatid = vspl.fr_matid;
        else
        {
            frmatid = MatidOfFace(face_prediction(frccw,frclw,ii));
            // save computed value for undo_vsplit and future vsplits
            vspl.fr_matid = frmatid;
            vspl.code|=Vsplit::FRN_MASK;
        }
    }

    /*
     * 3) Compute new coordinates of vt and vs (calc coordinates).
     * -----------------------------------------------------------
     */
    
    switch (ii) 
    {
    case 2:
        glvt.x = m_varray[vs].x + vspl.vad_large[0];
        glvt.y = m_varray[vs].y + vspl.vad_large[1];
        glvt.z = m_varray[vs].z + vspl.vad_large[2];

        glvs.x = m_varray[vs].x + vspl.vad_small[0];
        glvs.y = m_varray[vs].y + vspl.vad_small[1];
        glvs.z = m_varray[vs].z + vspl.vad_small[2];
        break;
    case 0:
        glvt.x = m_varray[vs].x + vspl.vad_small[0];
        glvt.y = m_varray[vs].y + vspl.vad_small[1];
        glvt.z = m_varray[vs].z + vspl.vad_small[2];

        glvs.x = m_varray[vs].x + vspl.vad_large[0];
        glvs.y = m_varray[vs].y + vspl.vad_large[1];
        glvs.z = m_varray[vs].z + vspl.vad_large[2];
        break;
    case 1:
        glvt.x = m_varray[vs].x + vspl.vad_small[0];
        glvt.y = m_varray[vs].y + vspl.vad_small[1];
        glvt.z = m_varray[vs].z + vspl.vad_small[2];

        glvs.x = glvt.x - vspl.vad_large[0];
        glvs.y = glvt.y - vspl.vad_large[1];
        glvs.z = glvt.z - vspl.vad_large[2];

        glvt.x = glvt.x + vspl.vad_large[0];
        glvt.y = glvt.y + vspl.vad_large[1];
        glvt.z = glvt.z + vspl.vad_large[2];
        break;
    default:
        throw CBadVsplitCode();
    }
    
    /*
     * 4) un-share wedges around vt (?) Add 2 wedges around Vs 
     * -------------------------------------------------------
     *  (may be gap on top). may modify wlclw and wrccw!
     */

    WORD wnl = UNDEF, wnr = UNDEF;
    int iil = 0, iir = ar_pwedges.num()-1;
    if (isl && (wlclw == wlccw)) 
    {  
        /*
         * first go clw. Add new wedge.
         */

        wnl = m_numWedges++;

        /*
         * Add wnl to the list of wedges sharing Vs
         */
        m_wedgelist[wnl] = m_wedgelist[vs];
        m_wedgelist[vs] = wnl;

        /* 
         * Copy wedge attributes
         */
        m_narray[wnl] = m_narray[wlccw];
        m_tarray[wnl] = m_tarray[wlccw];
        wlclw = wnl;              // has been changed

        for (;;) 
        {
            *ar_pwedges[iil] = wnl;
            iil++;
            if (iil > iir) 
            {
                wrccw = wnl;      // has been changed
                break;
            }
            if (*ar_pwedges[iil] != wlccw) 
                break;
        }
    }

    if (isr && (wrccw == wrclw)) 
    {  
        /*
         * now go ccw from other side.
         */

        if ((wrclw == wlccw) && (wnl != UNDEF)) 
        {
            wnr = wnl;
        } 
        else 
        {
            // Add new wedge
            wnr = m_numWedges++;

            // Add wnr to the list of wedges sharing vs
            m_wedgelist[wnr] = m_wedgelist[vs];
            m_wedgelist[vs] = wnr;
            
            // Copy wedge attributes
            m_narray[wnr] = m_narray[wrclw];
            m_tarray[wnr] = m_tarray[wrclw];
        }
        wrccw=wnr;              // has been changed

        for (;;) 
        {
            *ar_pwedges[iir] = wnr;
            iir--;
            if (iir < iil) 
            {
                if (iir < 0) wlclw=wnr; // has been changed
                break;
            }
            if (*ar_pwedges[iir] != wrclw) 
                break;
        }
    }

    /*
     * 5) Add other new wedges around Vt and record wedge ancestries
     * -------------------------------------------------------------
     */

    WORD wvtfl, wvtfr, vt = UNDEF;
    if (!isr) 
    {
        wvtfr=UNDEF;
        switch (code&Vsplit::T_MASK) 
        {
        case Vsplit::T_LSAME|Vsplit::T_RSAME:
            wvtfl=wlclw;
            break;
        case Vsplit::T_RSAME:
            // Add new wedge.
            wvtfl = m_numWedges++;
            m_wedgelist[wvtfl] = wvtfl;
            m_varray[wvtfl] = glvt;
            vt = wvtfl;
            break;
        default:
            throw CBadVsplitCode();
        }
    } 
    else 
    {
        switch (code&Vsplit::T_MASK) 
        {
        case Vsplit::T_LSAME|Vsplit::T_RSAME|Vsplit::T_CSAME:
        case Vsplit::T_LSAME|Vsplit::T_RSAME:
            wvtfl=wlclw;
            wvtfr=wrccw;
            break;
        case Vsplit::T_LSAME|Vsplit::T_CSAME:
            wvtfl=wlclw;
            wvtfr=wvtfl;
            break;
        case Vsplit::T_RSAME|Vsplit::T_CSAME:
            wvtfl=wrccw;
            wvtfr=wvtfl;
            break;
        case Vsplit::T_LSAME:
            wvtfl=wlclw;
            // Add new wedge.
            wvtfr = m_numWedges++;
            m_wedgelist[wvtfr] = wvtfr;
            m_varray[wvtfr] = glvt;
            vt = wvtfr;
            break;
        case Vsplit::T_RSAME:
            // Add new wedge.
            wvtfl = m_numWedges++;
            m_wedgelist[wvtfl] = wvtfl;
            m_varray[wvtfl] = glvt;
            vt = wvtfl;
            wvtfr=wrccw;
            break;
        case Vsplit::T_CSAME:
            // Add new wedge.
            wvtfl = m_numWedges++;
            m_wedgelist[wvtfl] = wvtfl;
            m_varray[wvtfl] = glvt;
            vt = wvtfl;
            wvtfr=wvtfl;
            break;
        case 0:
            // Add new wedge.
            wvtfl = m_numWedges++;
            m_varray[wvtfl] = glvt;
            vt = wvtfl;

            // Add new wedge.
            wvtfr = m_numWedges++;
            m_varray[wvtfr] = glvt;

            // Add wvtfr and wvtfl to list of wedges sharing vt
            m_wedgelist[wvtfl] = wvtfr;
            m_wedgelist[wvtfr] = wvtfl;
            break;
        default:
            throw CBadVsplitCode();
        }
    }

    /*
     * 6) Add other new wedges around Vs.
     * ----------------------------------
     * Do we really need to find vertex index ? Optimize
     */

    WORD wvsfl, wvsfr;
    if (!isr) 
    {
        wvsfr = UNDEF;
        switch (code&Vsplit::S_MASK) 
        {
        case Vsplit::S_LSAME|Vsplit::S_RSAME:
            wvsfl=wlccw;
            break;
        case Vsplit::S_RSAME:
            // Add new wedge.
            wvsfl = m_numWedges++;
            m_varray[wvsfl] = glvs;

            // Add wvsfl to the list wedges sharing vs
            m_wedgelist[wvsfl] = m_wedgelist[vs];
            m_wedgelist[vs] = wvsfl;
            break;
        default:
            throw CBadVsplitCode();
        }
    } 
    else 
    {
        switch (code&Vsplit::S_MASK) 
        {
        case Vsplit::S_LSAME|Vsplit::S_RSAME|Vsplit::S_CSAME:
        case Vsplit::S_LSAME|Vsplit::S_RSAME:
            wvsfl=wlccw;
            wvsfr=wrclw;
            break;
        case Vsplit::S_LSAME|Vsplit::S_CSAME:
            wvsfl=wlccw;
            wvsfr=wvsfl;
            break;
        case Vsplit::S_RSAME|Vsplit::S_CSAME:
            wvsfl=wrclw;
            wvsfr=wvsfl;
            break;
        case Vsplit::S_LSAME:
            wvsfl=wlccw;
            // Add new wedge.
            wvsfr = m_numWedges++;
            m_wedgelist[wvsfr] = m_wedgelist[vs];
            m_wedgelist[vs] = wvsfr;
            m_varray[wvsfr] = glvs;
            break;
        case Vsplit::S_RSAME:
            // Add new wedge.
            wvsfl = m_numWedges++;
            m_wedgelist[wvsfl] = m_wedgelist[vs];
            m_wedgelist[vs] = wvsfl;
            m_varray[wvsfl] = glvs;
            wvsfr=wrclw;
            break;
        case Vsplit::S_CSAME:
            // Add new wedge.
            wvsfl = m_numWedges++;
            m_wedgelist[wvsfl] = m_wedgelist[vs];
            m_wedgelist[vs] = wvsfl;
            m_varray[wvsfl] = glvs;
            wvsfr = wvsfl;
            break;
        case 0:
            // Add new wedge.
            wvsfl = m_numWedges++;
            m_varray[wvsfl] = glvs;

            // Add new wedge.
            wvsfr = m_numWedges++;
            m_varray[wvsfr] = glvs;

            // Add wvsfr and wvsfl to list of wedges sharing vt
            m_wedgelist[wvsfl] = m_wedgelist[vs];
            m_wedgelist[wvsfr] =wvsfl;
            m_wedgelist[vs] = wvsfr;
            break;
        default:
            throw CBadVsplitCode();
        }
    }

    /*
     * 7) Add outside wedges wvlfl and wvrfr
     * -------------------------------------
     */

    WORD wvlfl, wvrfr;
    if (isl) 
    {
        switch (code&Vsplit::L_MASK) 
        {
        case Vsplit::L_ABOVE:
            wvlfl = m_farray[flclw].w[jlclw2];
            break;
        case Vsplit::L_BELOW:
            wvlfl = m_farray[flccw].w[(jlccw+1)%3];
            break;
        case Vsplit::L_NEW:
        {
            wvlfl = m_numWedges++;

            WORD vl = (flclw != UNDEF) ? m_farray[flclw].w[jlclw2] :
                                         m_farray[flccw].w[(jlccw+1)%3];
            m_wedgelist[wvlfl] = m_wedgelist[vl];
            m_wedgelist[vl] = wvlfl;

            m_varray[wvlfl] = m_varray[vl];
        }
        break;
        default:
            throw CBadVsplitCode();
        }
    }

    if (!isr) 
    {
        wvrfr = UNDEF;
    } 
    else 
    {
        switch (code&Vsplit::R_MASK) 
        {
        case Vsplit::R_ABOVE:
            wvrfr = m_farray[frccw].w[(jrccw+1)%3];
            break;
        case Vsplit::R_BELOW:
            wvrfr = m_farray[frclw].w[(jrclw+2)%3];
            break;
        case Vsplit::R_NEW:
        {
            wvrfr = m_numWedges++;
            WORD vr = m_farray[frccw].w[(jrccw+1)%3];

            m_wedgelist[wvrfr] = m_wedgelist[vr];
            m_wedgelist[vr] = wvrfr;

            m_varray[wvrfr] = m_varray[vr];
        }
        break;
        default:
            throw CBadVsplitCode();
        }
    }

    /*
     * 8) Add 1 or 2 faces, and update adjacency information.
     * ------------------------------------------------------
     */

    WORD fl, fr;
    m_matcnt [flmatid]++;
    fl = m_matpos[flmatid] + m_matcnt[flmatid] - 1;
    m_facemap [m_numFaces] = fl;
    
    if (isr) 
    {
        m_matcnt [frmatid]++;
        fr = m_matpos[frmatid] + m_matcnt[frmatid] - 1;
        m_facemap [m_numFaces+1] = fr;
        m_numFaces += 2;
    }
    else 
    {
        fr = UNDEF;
        m_numFaces ++;
    }

    if (isl) 
    {
        m_farray[fl].w[0] = wvsfl;
        m_farray[fl].w[1] = wvtfl;
        m_farray[fl].w[2] = wvlfl;

        if (flccw != UNDEF) m_fnei[flccw][(jlccw+2)%3] = fl;
        if (flclw != UNDEF) m_fnei[flclw][(jlclw+1)%3] = fl;

        m_fnei[fl][0] = flclw;
        m_fnei[fl][1] = flccw;
        m_fnei[fl][2] = fr;
    }

    if (isr) 
    {
        m_farray[fr].w[0] = wvsfr;
        m_farray[fr].w[1] = wvrfr;
        m_farray[fr].w[2] = wvtfr;

        if (frccw != UNDEF) m_fnei[frccw][(jrccw+2)%3] = fr;
        if (frclw != UNDEF) m_fnei[frclw][(jrclw+1)%3] = fr;

        m_fnei[fr][0] = frccw;
        m_fnei[fr][1] = fl;
        m_fnei[fr][2] = frclw;
    }

    /*
     * 9) Update wedge vertices.
     * -------------------------
     */

    if (wnl != UNDEF)
    {
        WedgeListDelete(wnl);
        m_varray[wnl] = glvt;

        if (vt == UNDEF)
        {
            m_wedgelist[wnl] = wnl;
            vt = wnl;
        }
        else
        {
            m_wedgelist[wnl] = m_wedgelist[vt];
            m_wedgelist[vt] = wnl;
        }
    }

    if (wnr != UNDEF)
    {
        WedgeListDelete(wnr);
        m_varray[wnr] = glvt;

        if (vt==UNDEF)
        {
            m_wedgelist[wnr] = wnr;
            vt = wnr;
        }
        else
        {
            m_wedgelist[wnr] = m_wedgelist[vt];
            m_wedgelist[vt] = wnr;
        }
    }

    WORD prev = UNDEF;
    for (; iil <= iir; iil++) 
    {
        WORD w = *ar_pwedges[iil];
        if (w != prev)
        {
            WedgeListDelete(w);
            m_varray[w] = glvt;
            if (vt==UNDEF)
            {
                m_wedgelist[w] = w;
                vt = w;
            }
            else
            {
                m_wedgelist[w] = m_wedgelist[vt];
                m_wedgelist[vt] = w;
            }
        }
        prev = w;
    }

    /*
     * 10) Update all wedges sharing Vs to it's new coordinates.
     * ---------------------------------------------------------
     * Note the prev loop in ar_pwedges could have modified wedge pointed by 
     * vs to be part of vt now.
     * wvsfl is the only sure way of a wedge pointing to vs
     */

    WORD p = wvsfl;
    do
    {
        m_varray[p] = glvs;
        p = m_wedgelist[p];
    }
    while (p != wvsfl);

    /*
     * 11) Update wedge attributes.
     * ----------------------------
     */

    GLwedgeAttrib  awvtfr, awvsfr;
    if (isr) 
    {
        // backup for isr
        //awvtfrV = m_varray[wvtfr]; 
        awvtfr.n = m_narray[wvtfr]; 
        awvtfr.t = m_tarray[wvtfr]; 

        // backup for isr
        //awvsfrV = m_varray[wvsfr]; 
        awvsfr.n = m_narray[wvsfr]; 
        awvsfr.t = m_tarray[wvsfr]; 
    }

    int lnum = 0;
    if (isl) 
    {
        int nt = !(code&Vsplit::T_LSAME);
        int ns = !(code&Vsplit::S_LSAME);
        if (nt && ns) 
        {
            add_zero(wvtfl, vspl.ar_wad[lnum++]);
            add_zero(wvsfl, vspl.ar_wad[lnum++]);
        } 
        else 
        {
            switch (ii) 
            {
            case 2:
            {
                GLwedgeAttrib wa;
                if (ns)
                {
                    m_narray[wvsfl] = m_narray[wvtfl];
                    m_tarray[wvsfl] = m_tarray[wvtfl];
                }
                if (!ns) {wa.n = m_narray[wvsfl]; wa.t = m_tarray[wvsfl];}
                else {wa.n = m_narray[wvtfl]; wa.t = m_tarray[wvtfl];}       
                add(wvtfl, wa, vspl.ar_wad[lnum++]);
                break;
            }
            case 0:
            {
                GLwedgeAttrib wa;
                if (nt)
                {
                    m_narray[wvtfl] = m_narray[wvsfl];
                    m_tarray[wvtfl] = m_tarray[wvsfl];
                }
                if (!nt) {wa.n = m_narray[wvtfl]; wa.t = m_tarray[wvtfl];}
                else {wa.n = m_narray[wvsfl]; wa.t = m_tarray[wvsfl];}       
                add(wvsfl, wa, vspl.ar_wad[lnum++]);
                break;
            }
            case 1:
            {
                const WEDGEATTRD& wad = vspl.ar_wad[lnum];
                if (!ns) 
                {
                    GLwedgeAttrib wabase;
                    wabase.n = m_narray[wvsfl];
                    wabase.t = m_tarray[wvsfl];
                    add(wvtfl, wabase, wad);
                    sub_reflect(wvsfl, wabase, wad);
                } 
                else 
                {
                    GLwedgeAttrib wabase;
                    wabase.n = m_narray[wvtfl];
                    wabase.t = m_tarray[wvtfl];
                    sub_reflect(wvsfl, wabase, wad);
                    add(wvtfl, wabase, wad);
                }
                lnum++;
            }
                break;
            default:
                throw CBadVsplitCode();
            }
        }
    }

    if (isr) 
    {
        int nt = !(code&Vsplit::T_RSAME);
        int ns = !(code&Vsplit::S_RSAME);
        int ut = !(code&Vsplit::T_CSAME);
        int us = !(code&Vsplit::S_CSAME);
        if (nt && ns) 
        {
            if (ut)
                add_zero(wvtfr, vspl.ar_wad[lnum++]);
            if (us)
                add_zero(wvsfr, vspl.ar_wad[lnum++]);
        } 
        else 
        {
            switch (ii) 
            {
            case 2:
                if (us && ns)
                {
                    m_narray[wvsfr] = awvtfr.n;
                    m_tarray[wvsfr] = awvtfr.t;
                }
                if (ut)
                    add(wvtfr, (!ns?awvsfr:awvtfr), vspl.ar_wad[lnum++]);
                break;
            case 0:
                if (ut && nt)
                {
                    m_narray[wvtfr] = awvsfr.n;
                    m_tarray[wvtfr] = awvsfr.t;
                }
                if (us)
                    add(wvsfr, (!nt?awvtfr:awvsfr), vspl.ar_wad[lnum++]);
                break;
            case 1:
            {
                const WEDGEATTRD& wad = vspl.ar_wad[lnum];
                if (!ns) 
                {
                    const GLwedgeAttrib& wabase = awvsfr;
                    if (ut)
                        add(wvtfr, wabase, wad);
                    if (us)
                        sub_reflect(wvsfr, wabase, wad);
                } 
                else 
                {
                    const GLwedgeAttrib& wabase=awvtfr;
                    if (us)
                        sub_reflect(wvsfr, wabase, wad);
                    if (ut)
                        add(wvtfr, wabase, wad);
                }
                if (ut || us)
                    lnum++;
            }
                break;
            default:
                throw CBadVsplitCode();
            }
        }
    }
    if (code&Vsplit::L_NEW) 
    {
        add_zero(wvlfl, vspl.ar_wad[lnum++]);
    }
    if (code&Vsplit::R_NEW)
    {
        add_zero(wvrfr, vspl.ar_wad[lnum++]);
    }
}



void CAugGlMesh::undo_vsplit(const Vsplit& vspl)
{
    unsigned int code=vspl.code;
    int ii=(code&Vsplit::II_MASK)>>Vsplit::II_SHIFT;
    const int isl=1; int isr;
    WORD fl, fr;
    GLvertex glvs, glvt;
    
    /*
     * 1) Remove the faces
     * -------------------
     */

    if (vspl.vlr_offset1 > 1) 
    {
        WORD frmid = vspl.fr_matid, flmid = vspl.fl_matid;
      
        isr = 1;
        
        // remove fr
        m_matcnt[frmid]--;
        fr = m_matpos[frmid] + m_matcnt[frmid]; 

        // remove fl
        m_matcnt[flmid]--;
        fl = m_matpos[flmid] + m_matcnt[flmid]; 

        m_numFaces -= 2;
    } 
    else 
    {
        WORD frmid = vspl.fr_matid, flmid = vspl.fl_matid;

        isr = 0;

        // remove fl
        m_matcnt[flmid]--;
        fl = m_matpos[flmid] + m_matcnt[flmid]; 
        fr = UNDEF;
        --m_numFaces;
    }

    /*
     * 2) Get wedges in neighborhood.
     * ------------------------------
     */

    WORD wvsfl, wvtfl, wvlfl;
    WORD wvsfr, wvtfr, wvrfr;

    wvsfl = m_farray[fl].w[0];
    wvtfl = m_farray[fl].w[1];
    wvlfl = m_farray[fl].w[2];

    if (!isr) 
    {
        wvsfr=UNDEF; 
        wvtfr=UNDEF; 
        wvrfr=UNDEF;
    } 
    else 
    {
        wvsfr = m_farray[fr].w[0];
        wvtfr = m_farray[fr].w[2];
        wvrfr = m_farray[fr].w[1];
    }

    /*
     * 3) Obtain the vertices Vs and Vt and save them.
     * -----------------------------------------------
     */

    WORD vs = FindVertexIndex (wvsfl);
    WORD vt = FindVertexIndex (wvtfl);

    glvt.x = m_varray[vt].x;
    glvt.y = m_varray[vt].y;
    glvt.z = m_varray[vt].z;

    /* 
     * 4) Get adjacent faces and wedges on left and right.
     * ---------------------------------------------------
     * (really needed??)
     */

    WORD flccw, flclw;           // either (not both) may be UNDEF
    WORD frccw, frclw;           // either (or both) may be UNDEF

    /*
     * Also find index of vs within those adjacent faces
     */
    int jlccw2, jlclw0, jlclw2, jrccw, jrclw1; // only defined if faces exist
    WORD* pwlclw;
    WORD wlccw, wlclw, wrccw, wrclw; // UNDEF if faces does not exist

    /* 
     * Left side
     */

    if (isl) 
    {
        flccw = m_fnei[fl][1];
        flclw = m_fnei[fl][0];

        if (flccw == UNDEF) 
        {
            wlccw=UNDEF;
        } 
        else 
        {
            gather_vf_j2w (vs, flccw, jlccw2, wlccw);
        }

        if (flclw==UNDEF) 
        {
            wlclw = UNDEF;
        } 
        else 
        {
            gather_vf_j0j2pw (vt, flclw, jlclw0, jlclw2, pwlclw);
            wlclw = *pwlclw;
        }
    }

    /* 
     * Right side
     */

    if (!isr) 
    {
        frccw = frclw = wrccw = wrclw = UNDEF;
    } 
    else 
    {
        frccw = m_fnei[fr][0];
        frclw = m_fnei[fr][2];

        if (frccw == UNDEF) 
        {
            wrccw = UNDEF;
        } 
        else 
        {
            gather_vf_jw(vt, frccw, jrccw, wrccw);
        }

        if (frclw == UNDEF) 
        {
            wrclw = UNDEF;
        } 
        else 
        {
            gather_vf_j1w (vs, frclw, jrclw1, wrclw);
        }
    }

    int thru_l = ((wlccw == wvsfl) && (wlclw == wvtfl));
    int thru_r = ((wrclw == wvsfr) && (wrccw == wvtfr));

    /*
     * 5) Update adjacency information.
     * --------------------------------
     */

    if (flccw != UNDEF) m_fnei[flccw][jlccw2] = flclw;
    if (flclw != UNDEF) m_fnei[flclw][(jlclw0+1)%3] = flccw;
    if (frccw != UNDEF) m_fnei[frccw][(jrccw+2)%3] = frclw;
    if (frclw != UNDEF) m_fnei[frclw][jrclw1] = frccw;

    /*
     * 6) Propagate wedges id's across collapsed faces if can go thru.
     * ---------------------------------------------------------------
     */

    WORD ffl = flclw, ffr = frccw;
    int jjl0 = jlclw0, jjl2 = jlclw2, jjr = jrccw;
    WORD* pwwl=pwlclw;
    
    /*
     * first go clw
     */
    if (thru_l) 
    {            
        for (;;) 
        {
            *pwwl = wlccw;
            if (ffl == ffr) 
            {
                ffl = ffr = UNDEF;  // all wedges seen
                break;
            }
            ffl = m_fnei[ffl][jjl2];
            if (ffl == UNDEF) break;
            gather_vf_j0j2pw(vt, ffl, jjl0, jjl2, pwwl);
            if (*pwwl != wlclw) break;
        }
    }

    /*
     * now go ccw from other side
     */
    if ((ffr != UNDEF) && thru_r) 
    {     
        WORD* pw = &(m_farray[ffr].w[jjr]);
        for (;;) 
        {
            *pw = wrclw;
            if (ffr == ffl) 
            {
                ffl = ffr = UNDEF;  // all wedges seen
                break;
            }
            ffr = m_fnei[ffr][(jjr+1)%3];
            if (ffr == UNDEF) break;
            gather_vf_jpw (vt, ffr, jjr, pw);
            if (*pw != wrccw) break;
        }
    }

    /*
     * 7) Identify those wedges that will need to be updated to vs.
     * ------------------------------------------------------------
     * (wmodif may contain some duplicates)
     */

    PArray<WORD,10> ar_wmodif;
    if (ffl!=UNDEF) 
    {
        for (;;) 
        {
            int w = *pwwl;
            ar_wmodif += w;
            if (ffl == ffr) 
            { 
                ffl = ffr = UNDEF; 
                break; 
            }

            ffl = m_fnei[ffl][jjl2];
            if (ffl == UNDEF) break;
            gather_vf_j0j2pw (vt, ffl, jjl0, jjl2, pwwl);
        }
    }

    /*
     * 8) Update wedge vertices to vs.
     * -------------------------------
     */

    for (int i=0; i<ar_wmodif.num(); ++i)
    {
        // _wedges[w].vertex=vs;
        WORD w = ar_wmodif[i];
        WedgeListDelete(w);
        m_varray[w] = m_varray[vs];
        m_wedgelist[w] = m_wedgelist[vs];
        m_wedgelist[vs] = w;
    }

    /*
     * 9) Update vertex attributes.
     * ----------------------------
     */

    float vsx, vsy, vsz;
    switch (ii) 
    {
    case 2:
        glvs.x = m_varray[vs].x - vspl.vad_small[0];
        glvs.y = m_varray[vs].y - vspl.vad_small[1];
        glvs.z = m_varray[vs].z - vspl.vad_small[2];
        break;
    case 0:
        glvs.x = glvt.x - vspl.vad_small[0];
        glvs.y = glvt.y - vspl.vad_small[1];
        glvs.z = glvt.z - vspl.vad_small[2];
        break;
    case 1:
        glvs.x = glvt.x - vspl.vad_large[0] - vspl.vad_small[0];
        glvs.y = glvt.y - vspl.vad_large[1] - vspl.vad_small[1];
        glvs.z = glvt.z - vspl.vad_large[2] - vspl.vad_small[2];
        break;
    default:
        throw CBadVsplitCode();
    }

    /*
     * 10) update all wedges sharing vs with it's coordinates
     * ------------------------------------------------------
     */

    WORD p = vs;
    do
    {
        m_varray[p] = glvs;
        p = m_wedgelist[p];
    }
    while (p!=vs);

    /*
     * 11) Udpate wedge attributes. they are currently predicted exactly.
     * ------------------------------------------------------------------
     */

    GLwedgeAttrib awvtfr, awvsfr;
    //GLvertex awvtfrV, awvsfrV;

    if (isr) 
    {
      //awvtfrV = m_varray[wvtfr];
        awvtfr.n = m_narray[wvtfr];
        awvtfr.t = m_tarray[wvtfr];

        //awvsfrV = m_varray[wvsfr];
        awvsfr.n = m_narray[wvsfr];
        awvsfr.t = m_tarray[wvsfr];
    }

    int problem = 0;
    if (isl) 
    {
        int nt = !(code&Vsplit::T_LSAME);
        int ns = !(code&Vsplit::S_LSAME);
        if (nt && ns) 
        {
            problem = 1;
        } 
        else 
        {
            switch (ii) 
            {
            case 2:
                if (!thru_l)
                {
                    m_narray[wvtfl] = m_narray[wvsfl];
                    m_tarray[wvtfl] = m_tarray[wvsfl];
                }
                break;
            case 0:
                m_narray[wvsfl] = m_narray[wvtfl];
                m_tarray[wvsfl] = m_tarray[wvtfl];
                break;
            case 1:
                sub_noreflect (wvsfl, wvtfl, vspl.ar_wad[0]);
                if (!thru_l)
                {
                    m_narray[wvtfl] = m_narray[wvsfl];
                    m_tarray[wvtfl] = m_tarray[wvsfl];
                }
                break;
            default:
                throw CBadVsplitCode();
            }
        }
    }

    if (isr) 
    {
        int nt = !(code&Vsplit::T_RSAME);
        int ns = !(code&Vsplit::S_RSAME);
        int ut = !(code&Vsplit::T_CSAME);
        int us = !(code&Vsplit::S_CSAME);

        if (problem || us || ut) 
        {
            switch (ii) {
            case 2:
                /*
                 * If thru_r, then wvtfr & wrccw no longer exist.
                 * This may be duplicating some work already done for isl.
                 */
                if (!nt && !thru_r)
                {
                    m_narray[wvtfr] = awvsfr.n;
                    m_tarray[wvtfr] = awvsfr.t;
                }
                break;
            case 0:
                // This may be duplicating some work already done for isl.
                if (!ns)
                {
                    m_narray[wvsfr] = awvtfr.n;
                    m_tarray[wvsfr] = awvtfr.t;
                }
                break;
            case 1:
            {
                GLwedgeAttrib wa;
                interp(wa, awvsfr, awvtfr, 0.5f, 0.5f);
                if (!ns) 
                {
                    m_narray[wvsfr] = wa.n;
                    m_tarray[wvsfr] = wa.t;
                }
                if (!nt && !thru_r)
                {
                    m_narray[wvtfr] = wa.n;
                    m_tarray[wvtfr] = wa.t;
                }
            }
            break;
            default:
                throw CBadVsplitCode();
            }
        }
    }

    /*
     * 12) Remove wedges.
     * ------------------
     */

    if (isr && (code&Vsplit::R_NEW))
    {
        WORD w = --m_numWedges; // wvrfr
        WedgeListDelete(w);
    }

    if (code&Vsplit::L_NEW)
    {
        WORD w = --m_numWedges; // wvlfl
        WedgeListDelete(w);
    }

    if (isr && (!(code&Vsplit::S_CSAME) && !(code&Vsplit::S_RSAME)))
    {
        WORD w = --m_numWedges; // wvsfr
        WedgeListDelete(w);
    }

    if ((!(code&Vsplit::S_LSAME) && (!(code&Vsplit::S_CSAME) || 
                                     !(code&Vsplit::S_RSAME))))
    {
        WORD w = --m_numWedges; // wvsfl
        WedgeListDelete(w);
    }

    if (isr && (!(code&Vsplit::T_CSAME) && !(code&Vsplit::T_RSAME)))
    {
        WORD w = --m_numWedges; // wvtfr
        WedgeListDelete(w);
    }

    if ((!(code&Vsplit::T_LSAME) && (!(code&Vsplit::T_CSAME) || 
                                     !(code&Vsplit::T_RSAME))))
    {
        WORD w = --m_numWedges; // wvtfl
        WedgeListDelete(w);
    }

    int was_wnl = isl && (code&Vsplit::T_LSAME) && (code&Vsplit::S_LSAME);
    if (isr && (code&Vsplit::T_RSAME) && (code&Vsplit::S_RSAME) &&
        !(was_wnl && (code&Vsplit::T_CSAME)))
    {
        WORD w = --m_numWedges; // wrccw
        WedgeListDelete(w);
    }

    if (was_wnl)
    {
        WORD w = --m_numWedges; // wlclw
        WedgeListDelete(w);
    }
}

void CAugGlMesh::sub_reflect(WORD a, const GLwedgeAttrib& abase, 
                           const WEDGEATTRD& ad)
{
    /*
     * note: may have abase==a -> not really const
     * dr == -d +2*(d.n)n
     * an = n + dr
     * optimized: a.normal=-d+((2.f)*dot(d,n)+1.f)*n;
     */

    register float vdot = ad[0]*abase.n.x + ad[1]*abase.n.y + ad[2]*abase.n.z;
    register float vdot2p1 = vdot * 2.0f + 1.0f;

    m_narray[a].x = -ad[0] + vdot2p1*abase.n.x;
    m_narray[a].y = -ad[1] + vdot2p1*abase.n.y;
    m_narray[a].z = -ad[2] + vdot2p1*abase.n.z;

    m_tarray[a].s = abase.t.s - ad[3];
    m_tarray[a].t = abase.t.t - ad[4];
}


void CAugGlMesh::sub_noreflect(WORD a, WORD abase, const WEDGEATTRD& ad)
{
    m_narray[a].x = m_narray[abase].x - ad[0];
    m_narray[a].y = m_narray[abase].y - ad[1];
    m_narray[a].z = m_narray[abase].z - ad[2];

    m_tarray[a].s = m_tarray[abase].s - ad[3];
    m_tarray[a].t = m_tarray[abase].t - ad[4];
}


void interp(GLwedgeAttrib& a, const GLwedgeAttrib& a1,
            const GLwedgeAttrib& a2, float f1, float f2)
{
    if (a1.n.x==a2.n.x && a1.n.y==a2.n.y && a1.n.z==a2.n.z)
    {
        a.n = a1.n;
    }
    else
    {
        a.n.x = f1*a1.n.x + f2*a2.n.x;
        a.n.y = f1*a1.n.y + f2*a2.n.y;
        a.n.z = f1*a1.n.z + f2*a2.n.z;
        float denom = (float) sqrt ((double)(a.n.x*a.n.x + a.n.y*a.n.y + 
                                             a.n.z*a.n.z));
        if (denom!=0) 
        {
            a.n.x/=denom;
            a.n.y/=denom;
            a.n.z/=denom;
        }
    }
    a.t.s = f1*a1.t.s + f2*a2.t.s;
    a.t.t = f1*a1.t.t + f2*a2.t.t;
}

void CAugGlMesh::gather_vf_jw (WORD v, WORD f, int& j, WORD& w) const
{
    j = get_jvf (v,f);
    w = (m_farray[f]).w[j];
}

void CAugGlMesh::gather_vf_j0j2pw(WORD v, WORD f, int& j0, int& j2, WORD*& pw)
{
    j0 = get_jvf (v,f);
    pw = &(m_farray[f]).w[j0];
    j2 = (j0 + 2) % 3;
}

void CAugGlMesh::gather_vf_j2w(WORD v, WORD f, int& j2, WORD& w) const
{
    WORD j = get_jvf (v,f);
    w = (m_farray[f]).w[j];
    j2 = (j + 2) % 3;
}

void CAugGlMesh::gather_vf_j1w (WORD v, WORD f, int& j1, WORD& w) const
{
    WORD j = get_jvf(v,f);
    w = (m_farray[f]).w[j];
    j1 = (j + 1) % 3;
}

void CAugGlMesh::gather_vf_jpw(WORD v, WORD f, int& j, WORD*& pw)
{
    j = get_jvf(v,f);
    pw = &(m_farray[f]).w[j];
}

WORD CAugGlMesh::MatidOfFace(WORD f)
{
    //Binary search helps if there are a lot of materials
    for (WORD i=1; i<m_numMaterials; ++i)
        if (f < m_matpos[i])
            return i-1;
    return m_numMaterials-1;
    
    //throw CBadFace();
    //return 0; // never
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\cpmesh.cxx ===
/**     
 **       File       : cpmesh.cxx
 **       Description: Implementations of CPMeshGL class
 **/
#include "precomp.h"
#pragma hdrstop

#include <objbase.h>
#include <initguid.h>
#include "cpmesh.h"
#include "pmerrors.h"

/*
 *  CPMeshGL: Constructor
 */
CPMeshGL::CPMeshGL() : CAugGlMesh()
{
    m_cRef = 1;
    m_vsarr = NULL;
    m_baseVertices =
    m_baseWedges =
    m_baseFaces =
    m_currPos =
    m_maxVertices =
    m_maxWedges =
    m_maxFaces =
    m_maxMaterials =
    m_maxTextures = 0;
}


/**************************************************************************/
/*
 *  CPMeshGL: Destructor
 */
CPMeshGL::~CPMeshGL()
{
    unsigned i;

    delete m_vsarr;
}

/**************************************************************************/
/*
 * IUnknown methods
 */

STDMETHODIMP_(ULONG) CPMeshGL::AddRef(void)
{
    return m_cRef++;
}

STDMETHODIMP_(ULONG) CPMeshGL::Release(void)
{
    if (--m_cRef != 0)
        return m_cRef;
    delete this;
    return 0;
}

STDMETHODIMP CPMeshGL::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;
    if (riid == IID_IUnknown)
        *ppv=(IUnknown*)(IPMesh*)this;
    else if (riid == IID_IPMesh)
        *ppv=(IPMesh*)this;
    else if (riid == IID_IPMeshGL)
        *ppv=(IPMeshGL*)this;
    else
        return E_NOINTERFACE;
    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}

/**************************************************************************/
/*
 * IPMeshGL methods
 */

STDMETHODIMP CPMeshGL::Initialize(void)
{
    return S_OK;
}

STDMETHODIMP CPMeshGL::Render(void)
{
    RenderMesh (GLPM_SOLID);
    return S_OK;
}

/**************************************************************************/
/*
 * IPMesh methods
 */

// Gets

STDMETHODIMP CPMeshGL::GetNumFaces(DWORD* const nfaces)
{
    *nfaces = GetMeshNumFaces();
    return S_OK;
}

STDMETHODIMP CPMeshGL::GetMaxFaces(DWORD* const maxfaces)
{
    *maxfaces = m_maxFaces;
    return S_OK;
}

STDMETHODIMP CPMeshGL::GetNumVertices(DWORD* const nverts)
{
    *nverts = GetMeshNumVerts();
    return S_OK;
}

STDMETHODIMP CPMeshGL::GetMaxVertices(DWORD* const maxverts)
{
    *maxverts = m_maxVertices;
    return S_OK;
}


// Sets
STDMETHODIMP CPMeshGL::SetNumFaces(DWORD f) 
{ 
    return E_NOTIMPL; 
}

STDMETHODIMP CPMeshGL::SetNumVertices(DWORD nv) 
{ 
    DWORD v = nv;
  
    if (v > m_maxVertices)
        v = m_maxVertices;
    if (v < m_baseVertices)
        v = m_baseVertices;

    if (v > m_baseVertices + m_currPos)
    {
        while (m_currPos < v - m_baseVertices)
        {
            apply_vsplit (m_vsarr->elem(m_currPos++));
        }
    }
    else if (v < m_baseVertices + m_currPos)
    {
        while (m_currPos > v - m_baseVertices)
        {
            --m_currPos;
            undo_vsplit (m_vsarr->elem(m_currPos));
        }
    }
    else
    {
        return S_OK;
    }
    
    return S_OK;
}


/**************************************************************************\
*  FUNCTION:    CreatePMeshGL. This function is exported                   *
*                                                                          *
*  ARGS:        iid -> IID of the interface desired.                       *
*               ppV -> pointer to pointer to the interface.                *
*               pUnkOuter -> Not needed yet. Dunno what for!!              *
*               bReserved -> Shd be NULL. To be used later.                *
*                                                                          *
*  DESCRIPTION: Helper function to initialize the Object.                  *
*               Use it in place of CoCreateInstance.                       *
\**************************************************************************/
HRESULT CreatePMeshGL(REFIID iid, 
                      LPVOID FAR* ppV, 
                      IUnknown* pUnkOuter, 
                      DWORD bReserved)
{
    HRESULT hr;

    if (bReserved)
        return E_INVALIDARG;
    CPMeshGL* pPMGL = new CPMeshGL;
    if (!pPMGL)
        return E_OUTOFMEMORY;
    hr = pPMGL->QueryInterface(iid, ppV);
    if (SUCCEEDED(hr))
        hr = pPMGL->Initialize();
    if (FAILED(hr))
    {
        ppV = NULL;
        delete pPMGL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\fileio.cxx ===
#include "precomp.h"
#pragma hdrstop

#include "fileio.h"
#include <string.h>

void read_float(istream& is, float& v)
{
    is.read((char*)&v,sizeof(float));
}

void read_DWORD(istream& is, DWORD& v)
{
    is.read((char*)&v,sizeof(DWORD));
}

void read_WORD(istream& is, WORD& v)
{
    is.read((char*)&v,sizeof(WORD));
}

void skip_bytes(istream&is, DWORD i)
{
	is.seekg(i,ios::cur);
}

#ifndef __DUMP_DATA
void write_string(ostream& os, char *str)
{
    int n = strlen(str);
  
    os << str;
    
    //os.write((char*)&str,sizeof(unsigned));
}

#endif //__DUMP_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\excptn.h ===
/**     
 **       File       : excptn.h
 **       Description: Exception classes
 **/

#ifndef _excptn_h
#define _excptn_h

class CExNewFailed { }; 
class CBadVsplit { };
class CBadFace { };
class CVertexNotFound { };
class CBadWedge { };
class CBadVsplitCode { };


#endif //_excptn_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\aglmesh.h ===
/**     
 **       File       : aglmesh.h
 **       Description: Augmented Mesh definition
 **                    mesh augmented with adjacency data.
 **/

#ifndef _aglmesh_h_  
#define _aglmesh_h_                    

#include "global.h"
#include "sglmesh.h"
#include "vsplit.h"
#include "hash.h"

class CAugGlMesh : public CSimpGlMesh
{
protected:
public:
    WORD* m_facemap;      // Array remapping the face numbers
	WORD (*m_fnei)[3];    // face neightbour information table
	void HashAdd(WORD va, WORD vb, WORD f);
	WORD HashFind(WORD va, WORD vb);
    void apply_vsplit(Vsplit& vspl);
    void undo_vsplit(const Vsplit& vspl);

    /*
     * get index of vertex v in face f
     */
    inline WORD get_jvf(WORD v, WORD f) const; 

    /*
     * gather functions
     */
    void gather_vf_jw (WORD v, WORD f, int& j, WORD& w) const;
    void gather_vf_j0j2pw (WORD v, WORD f, int& j0, int& j2, WORD*& w);
    void gather_vf_j2w (WORD v, WORD f, int& j2, WORD& w) const;
    void gather_vf_j1w (WORD v, WORD f, int& j1, WORD& w) const;
    void gather_vf_jpw (WORD v, WORD f, int& j, WORD*& pw);
  

    WORD MatidOfFace (WORD f);
    inline WORD face_prediction (WORD fa, WORD fb, WORD ii);
    inline void WedgeListDelete (WORD w);
    inline void add_zero (WORD a, const WEDGEATTRD& ad);
    inline void add (WORD a, const GLwedgeAttrib& a1, const WEDGEATTRD& ad);
    void sub_reflect (WORD a, const GLwedgeAttrib& abase, 
                      const WEDGEATTRD& ad);
    void sub_noreflect (WORD a, WORD abase, const WEDGEATTRD& ad);
  
  
public:
    CAugGlMesh();
    virtual ~CAugGlMesh();
    void ComputeAdjacency(void);
};

/*************************************************************************
  Inlines
*************************************************************************/
inline WORD CAugGlMesh::get_jvf (WORD v, WORD f) const
{
    WORD *w = m_farray[f].w;
    if (FindVertexIndex(w[0]) == v)
        return 0;
    else if (FindVertexIndex(w[1]) == v)
        return 1;
    else if (FindVertexIndex(w[2]) == v)
        return 2;
    else
        throw CVertexNotFound();
    return 0; // Never! To make compiler happy
}

inline WORD CAugGlMesh::face_prediction(WORD fa, WORD fb, WORD ii)
{
    return (ii == 0 ? (fb != UNDEF ? fb : fa) : (fa != UNDEF ? fa : fb));
}

inline void CAugGlMesh::WedgeListDelete(WORD w)
{
    for (WORD p = w; m_wedgelist[p] != w; 
         p = m_wedgelist[p]);
    m_wedgelist[p] = m_wedgelist[m_wedgelist[p]];
}

inline void CAugGlMesh::add_zero(WORD a, const WEDGEATTRD& ad)
{
    m_narray[a].x = ad[0];
    m_narray[a].y = ad[1];
    m_narray[a].z = ad[2];

    m_tarray[a].s = ad[3];
    m_tarray[a].t = ad[4];
}

inline void CAugGlMesh::add(WORD a, const GLwedgeAttrib&  a1, 
                          const WEDGEATTRD& ad)
{
    m_narray[a].x = a1.n.x + ad[0];
    m_narray[a].y = a1.n.y + ad[1];
    m_narray[a].z = a1.n.z + ad[2];

    m_tarray[a].s = a1.t.s + ad[3];
    m_tarray[a].t = a1.t.t + ad[4];
}

#endif //_aglmesh_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\fileio.h ===
#include <fstream.h>

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN

void read_float(istream& is, float& v);
void read_DWORD(istream& is, DWORD& v);
void read_WORD(istream& is, WORD& v);
void skip_bytes(istream&is, DWORD i);

#ifndef __DUMP_DATA
void write_string(ostream& os, char *str);
#endif //__DUMP_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\array.h ===
/**     
 **       File       : array.h
 **       Description: Array template declaration 
 **/

#ifndef Array_h
#define Array_h

#define ForIndex(i,n) for(int i=0; i<(n); ++i)
#define EndFor

// for PArray<T>, like Array<T>, T must have a public operator=()
template<class T, int psize>
class PArray {
private:
    int size;                   // must come before a
    T* a;
    int n;
    T pa[psize];

private:
    void resize(int nsize);
    void resize_aux(int ne);

public:
    inline PArray(int ne=0) 
    {
        if (ne <= psize) 
        {
            size = psize; 
            a = pa;
        } 
        else 
        {
            size = ne; 
            a = new T[ne];
        }
        n=ne;
    }

    PArray<T,psize>& operator=(const PArray<T,psize>& ar);
    PArray(const PArray<T,psize>& ar);
    inline ~PArray()                    { if (size!=psize) delete[] a; }
    inline int num() const              { return n; }
    inline void clearcompletely() 
    {
        if (size != psize) 
        { 
            delete[] a; 
            size = psize; 
            a = pa; 
        }
        n=0;
    }

    /*
     * allocate ne, CLEAR if too small
     */
    inline void init(int ne)  
    {  
        if (ne > size) 
        {
            if (size!=psize) delete[] a;
            size=ne;
            a=new T[ne];
        }
        n=ne;
    }

    /*
     * allocate at least e+1, COPY if too small
     */
    inline void access(int e) 
    { 
        int ne=e+1;
        if (ne>size) resize_aux(ne);
        if (ne>n) n=ne;
    }

    /*
     * allocate ne, COPY if too small
     */
    inline void need(int ne)  
    {   
        if (ne>size) resize_aux(ne);
        n=ne;
    }

    /*
     * ret: previous num()
     */
    inline int add(int ne)
    {    
        int cn=n; need(n+ne); return cn;
    }

    inline void sub(int ne) 
    {
        n-=ne;
    }

    /*
     * do not use a+=a[..]!!
     * add() may allocate a[]!!
     */
    inline PArray<T,psize>& operator+=(const T& e) 
    { 
        int i=add(1); 
        a[i]=e; 
        return *this; 
    }
    inline void squeeze()               { if (n<size) resize(n); }
    inline operator const T*() const    { return a; }
    inline operator T*()                { return a; }

    inline const T& operator[](int i) const     { ok(i); return a[i]; }
    inline T& operator[](int i)         { ok(i); return a[i]; }
    inline const T& last() const        { return operator[](n-1); }
    inline T& last()                    { return operator[](n-1); }
#if 0
    inline void reverse() 
    {
        for(int i=0; i<n/2; ++i) 
        { 
            swap(&a[i],&a[n-1-i]); 
        }
    }
#endif

#ifdef __TIGHTER_ASSERTS
    inline void ok(int i) const      { assertx(i>=0 && i<n); }
#else
    inline void ok(int) const           { } 
#endif

    int contains(const T& e) const;
    int index(const T& e) const;
};


// was 'const T&', but with 'Cut*', expanded to 'const Cut*&' (bad)
#define ForPArray(A,T,V) ForIndex(zzz,(A).num()) T const& V=(A)[zzz];

template<class T, int psize>
PArray<T,psize>& PArray<T,psize>::operator=(const PArray<T,psize>& ar)
{
    if (&ar==this) return *this;
    init(ar.num());
    ForIndex(i,n) { a[i]=ar[i]; } EndFor;
    return *this;
}

template<class T, int psize>
PARRAY_INLINE
PArray<T,psize>::PArray(const PArray<T,psize>& ar) : size(psize), a(pa), n(0)
{
    *this=ar;
}

template<class T, int psize>
void PArray<T,psize>::resize(int nsize)
{
    T* na;
    if (nsize<=psize) {
        if (size==psize) return;
        na=pa;
    } else {
        na=new T[nsize];
    }
    ForIndex(i,n) { na[i]=a[i]; } EndFor;
    if (size!=psize) delete[] a;
    a=na;
    size=nsize<=psize?psize:nsize;
}

template<class T, int psize>
void PArray<T,psize>::resize_aux(int ne)
{
    resize(max(int(n*1.5f)+3,ne));
}

template<class T, int psize>
PARRAY_INLINE
int PArray<T,psize>::contains(const T& e) const
{
    ForIndex(i,n) { if (a[i]==e) return 1; } EndFor;
    return 0;
}

template<class T, int psize>
PARRAY_INLINE
int PArray<T,psize>::index(const T& e) const
{
    ForIndex(i,n) { if (a[i]==e) return i; } EndFor;
    assertnever(""); return 0;
}

#endif //Array_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\cpmesh.h ===
/**     
 **       File       : cpmesh.h
 **       Description: Interface implementations
 **/

#ifndef _cpmesh_h_  
#define _cpmesh_h_                    

#include "global.h"
#include "interface.h"
#include "aglmesh.h"
#include "excptn.h"
#include "vsplit.h"
#include "aglmesh.h"

/*************************************************************************
  Defines
*************************************************************************/

#define DLLEXPORT __declspec(dllexport)

/*************************************************************************
  Structs and Classes
*************************************************************************/


class CPMeshGL: public IPMesh, public IPMeshGL, public CAugGlMesh
{
private:

    /*
     * Enums used for compression
     */
    enum 
    {
        NORM_EXPLICIT,     // All normal explicitly stored
        NORM_NONE,         // No normals stored. Generate from faces
        NORM_PARTIAL,
        NORM_MASK = 3
    }; 

    // Texture coordinates stored or not. 
    // This is or'ed with normal flags 
    enum 
    {
        TEX_EXPLICIT = 4, 
        TEX_NONE,
        TEX_MASK = 1<<2
    };

    enum 
    {
        INTC_MAX,  // Fixed integer size to fit the largest possible value
        INTC_MUL8, // Integer size based on the range. 
                   // Clamped to multiple of 8 bits
        INTC_VAR   // Integer size based on range: ceil(log(maxval)/log(2))
    }; 

    /*
     * COM overhead
     */
    DWORD m_cRef;    // Reference count

    /*
     * BaseMesh data
     */
    DWORD m_baseVertices;  // # of vertices.
    DWORD m_baseWedges;    // # of wedges.
    DWORD m_baseFaces;     // # of faces.

    /*
     * Current position in the Vsplit array
     */
    DWORD m_currPos;    

    /*
     * Max data obtained from the PMesh header.
     * Parameters for the fully detailed mesh.
     */
    DWORD m_maxVertices;   // # of vertices.
    DWORD m_maxWedges;     // # of wedges.
    DWORD m_maxFaces;      // # of faces.
    DWORD m_maxMaterials;  // # of materials.
    DWORD m_maxTextures;   // # of textures.

    /* 
     * Array of Vsplit record, possibly shared
     */
    VsplitArray* m_vsarr; 

    /*
     * No idea what this is for
     */
    HRESULT LoadStream(IStream* is, DWORD*, DWORD*);

public:
    /* 
     * Constructor-Destructor
     */
    CPMeshGL();
    ~CPMeshGL();

    /* 
     * IUnknown Methods
     */
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR*);

    /* 
     * IPMesh Methods
     */

    //Loads
    STDMETHODIMP Load(const char* const, const char* const, DWORD* const, 
                      DWORD* const, LPPMESHLOADCB);
    STDMETHODIMP LoadStat(const char* const, const char* const, DWORD* const,
                          DWORD* const) { return E_NOTIMPL; };

    // Gets
    STDMETHODIMP GetNumFaces(DWORD* const);
    STDMETHODIMP GetNumVertices(DWORD* const);
    STDMETHODIMP GetMaxVertices(DWORD* const);
    STDMETHODIMP GetMaxFaces(DWORD* const);

    //Sets
    STDMETHODIMP SetNumFaces(DWORD);
    STDMETHODIMP SetNumVertices(DWORD);

    //Geomorph stuff
    STDMETHODIMP GeomorphToVertices(LPPMGEOMORPH, DWORD* const) 
                                          { return E_NOTIMPL; };
    STDMETHODIMP GeomorphToFaces(LPPMGEOMORPH, DWORD* const) 
                                          { return E_NOTIMPL; };
    STDMETHODIMP ClonePM(IPMesh* const) { return E_NOTIMPL; };

    // IPMeshGL Methods
    STDMETHODIMP Initialize (void);
    STDMETHODIMP Render (void);
};

DLLEXPORT HRESULT CreatePMeshGL (REFIID, 
                                 LPVOID FAR *, //dunno what this is for
                                 IUnknown *, 
                                 DWORD);



#endif //_cpmesh_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\global.h ===
/**     
 **       File       : global.h
 **       Description: Augmented Mesh definition
 **                    mesh augmented with adjacency data.
 **/

#ifndef _global_h_  
#define _global_h_                    

#include <limits.h>
/*
 * Defines
 */
#define UNDEF USHRT_MAX

#endif //_global_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\glmesh.h ===
/**     
 **       File       : glmesh.h
 **       Description: Mesh definition
 **/

#ifndef _glmesh_h_  
#define _glmesh_h_                    

#include <objidl.h>
#include <fstream.h>
#include <limits.h>
#include "glstructs.h"
#include "excptn.h"


/*************************************************************************
  Defines
*************************************************************************/
#define UNDEF USHRT_MAX

/*************************************************************************
  Typedefs, structs and classes
*************************************************************************/

typedef enum {
  GLPM_SOLID=0x0001,
  GLPM_WIRE=0x0002,
} RenderType;


struct hashentry
{
	WORD v2; 
	WORD f, m; // face and it's matid
	hashentry* next;
};
typedef hashentry* PHASHENTRY;


class CGlMesh
{
friend class CPMesh;
private:
public:
    GLmaterial* m_matArray;   // Array of Materials

    /*
     * Vertex-Array data 
     */
    GLvertex* m_varray;   // Vertex Array to store Wedges/Vertices
    GLnormal* m_narray;   // Normal Array to store Normals
    GLtexCoord* m_tarray; // Texture Array 
    GLface* m_farray;     // Face Array
    WORD* m_facemap;      // Array remapping the face numbers

    WORD* m_wedgelist; // circular linked lists of wedges sharing the same
                       // vertex
	WORD (*m_fnei)[3]; // face neightbour information table

	WORD* m_matcnt;    // table of face counts per material
#ifdef __MATPOS_IS_A_PTR
    GLface** m_matpos;    // pointers to where next face of a given material 
                          // is inserted in the m_farray
#else
    WORD* m_matpos;       // pointers to where next face of a given material 
                          // is inserted in the m_farray
#endif  
    DWORD m_numFaces;
    DWORD m_numWedges;
    DWORD m_numVerts;
    DWORD m_numMaterials;
    DWORD m_numTextures;

public:
    //Constructor-Destructor
    CGlMesh();
    ~CGlMesh();

    STDMETHODIMP Print (ostream& os);
	STDMETHODIMP Render (RenderType);

#if 0
	STDMETHODIMP AddWedge (WORD vertex_id, GLnormal& n, GLtexCoord& t, 
                           DWORD* const wedge_id);
    STDMETHODIMP AddWedge (WORD vertex_id, WORD old_wedge_id, 
                           DWORD* const wedge_id);
	STDMETHODIMP AddFace (WORD matid, GLface& f);
#endif

    inline DWORD GetNumFaces (void) const {return m_numFaces;};
    inline DWORD GetNumWedges (void) const {return m_numWedges;};
    inline DWORD GetNumVerts (void) const {return m_numVerts;};
    void ComputeAdjacency(void);
    //inline LPGLMaterial GetMaterial (int i) {return &(m_matArray[i]);}
	inline WORD FindVertexIndex(WORD w) const;

private:
#ifdef __MATPOS_IS_A_PTR
    inline WORD GetFaceIndex(int m, int f) const;
#endif  
	void HashAdd(WORD va, WORD vb, WORD f);
	WORD HashFind(WORD va, WORD vb);
};


/*************************************************************************
  Inlines
*************************************************************************/
inline WORD CGlMesh::FindVertexIndex(WORD w) const
{
	WORD v = USHRT_MAX;
	WORD p = w;
	do
	{
		v = min(p,v);
		p = m_wedgelist[p];
	}
	while (p != w);
	return v;
}

#ifdef __MATPOS_IS_A_PTR
inline WORD CGlMesh::GetFaceIndex(int m, int f) const
{
    return (WORD) (&(m_matpos[m][f].w[0]) - 
                   &(m_matpos[0][0].w[0]))/(sizeof(GLface));
}
#endif    


#endif //_glmesh_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\glpmguids.cxx ===
/**     
 **       File       : glpmguids.cxx
 **       Description: GUIDS (IIDS and CLSIDS) used in the program.
 **/

#include <objbase.h>
#include <initguid.h>
                   
//IID_IPMesh {0C154611-3C2C-11d0-A459-00AA00BDD621}
__declspec(dllexport) DEFINE_GUID(IID_IPMesh, 
0xc154611, 0x3c2c, 0x11d0, 0xa4, 0x59, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x21);

//IID_IPMeshGL {0C154612-3C2C-11d0-A459-00AA00BDD621}
__declspec(dllexport) DEFINE_GUID(IID_IPMeshGL, 
0xc154612, 0x3c2c, 0x11d0, 0xa4, 0x59, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x21);

//IID_IPMGeomorph {0C154613-3C2C-11d0-A459-00AA00BDD621}
__declspec(dllexport) DEFINE_GUID(IID_IPMGeomorph, 
0xc154613, 0x3c2c, 0x11d0, 0xa4, 0x59, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x21);

//IID_IPMeshLoadCB {0C154614-3C2C-11d0-A459-00AA00BDD621}
__declspec(dllexport) DEFINE_GUID(IID_IPMeshLoadCB, 
0xc154614, 0x3c2c, 0x11d0, 0xa4, 0x59, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x21);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\glmesh.cxx ===
/**     
 **       File       : glmesh.cxx
 **       Description: Implementations of CGlMesh class
 **/
#include "precomp.h"
#pragma hdrstop


#include "glmesh.h"
#include "pmerrors.h"


/**************************************************************************/

/*
 *  CGlMesh: Constructor
 */
CGlMesh::CGlMesh()
{
    //Dynamically allocated arrays
    m_matArray = NULL;
    m_varray = NULL;
    m_narray = NULL;
    m_tarray = NULL;
    m_wedgelist = NULL;
    m_fnei = NULL;
    m_facemap = NULL;

    m_numFaces =
    m_numWedges =
    m_numVerts = 
    m_numMaterials = 
    m_numTextures = 0;
}


/*
 *  CGlMesh: Destructor
 */
CGlMesh::~CGlMesh()
{
    delete [] m_matArray;
    delete [] m_varray;
    delete [] m_narray;
    delete [] m_tarray;
    delete [] m_wedgelist;
    delete [] m_fnei;
    delete [] m_facemap;
}

/*
 *  CGlMesh: Print
 */
STDMETHODIMP CGlMesh::Print(ostream& os)
{

    os << "\n\nMaterials:";
    for (int i=0; i<m_numMaterials; ++i)
    {
        LPGLmaterial lpglm = &m_matArray[i];
      
        os << "\n\nMaterial [" << i << "] :";
        os << "\nShininess : " << lpglm->shininess;
        os << "\nDiffuse  : (" << lpglm->diffuse.r << ", "
           << lpglm->diffuse.g << ", "
           << lpglm->diffuse.b << ", "
           << lpglm->diffuse.a << ")";
        os << "\nSpecular : (" << lpglm->specular.r << ", "
           << lpglm->specular.g << ", "
           << lpglm->specular.b << ", "
           << lpglm->specular.a << ")";
        os << "\nEmissive : (" << lpglm->emissive.r << ", "
           << lpglm->emissive.g << ", "
           << lpglm->emissive.b << ", "
           << lpglm->emissive.a << ")";
        os << "\nNumber of faces: " << m_matcnt[i];
        for (int j=0; j< m_matcnt[i]; j++)
        {
#ifdef __MATPOS_IS_A_PTR
            os << "\n(" << m_matpos[i][j].w[0]   << ","
               << (m_matpos[i][j]).w[1] << ","
               << (m_matpos[i][j]).w[2] << ")";
#else
            os << "\n(" << (m_farray[m_matpos[i] + j]).w[0]   << ","
               << (m_farray[m_matpos[i] + j]).w[0]  << ","
               << (m_farray[m_matpos[i] + j]).w[0]  << ")";
#endif
        }
    }

    os << "\n\nWedge connectivity:";
    for (i=0; i<m_numWedges; ++i)
    {
        os << "\n" << m_wedgelist[i];
    }
    
    os << "\n\nWedge data:";
    for (i=0; i<m_numWedges; ++i)
    {
        os   << "\n(" << m_varray[i].x << ", "
                      << m_varray[i].y << ", "
                      << m_varray[i].z << ") "
             << "  (" << m_narray[i].x << ", "
                      << m_narray[i].y << ", "
                      << m_narray[i].z << ") "
             << "  (" << m_tarray[i].s << ", "
                      << m_tarray[i].t << ") ";
    }
    return S_OK;
}

/*
 *  CGlMesh: Render
 */
STDMETHODIMP CGlMesh::Render(RenderType rt)
{
    if (rt == GLPM_SOLID)
    {
        glVertexPointer(3, GL_FLOAT, 0, (void *)&(m_varray[0].x));
        glNormalPointer (GL_FLOAT, 0, (void *)&(m_narray[0].x));
        glTexCoordPointer (2, GL_FLOAT, 0, (void *)&(m_tarray[0].s));
        
        glEnableClientState (GL_VERTEX_ARRAY);
        glEnableClientState (GL_NORMAL_ARRAY);
        
        for (int i=0; i<m_numMaterials; i++)
        {
            LPGLmaterial lpglm = &(m_matArray[i]);
            
            if (m_matcnt[i] == (WORD) 0) continue;
            
            glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, lpglm->shininess);
            glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, 
                         (GLfloat *) &(lpglm->specular));
            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,  
                         (GLfloat *) &(lpglm->diffuse));
            glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, 
                     (GLfloat *) &(lpglm->emissive));
            glDrawElements (GL_TRIANGLES, (GLuint) m_matcnt[i]*3, 
                            GL_UNSIGNED_SHORT, 
#ifdef __MATPOS_IS_A_PTR
                            (void *) m_matpos[i]);
#else
                            (void *) &(m_farray[m_matpos[i]]));
#endif
        }
        return S_OK;
    }
    else
    {
        return E_NOTIMPL;
    }
}

PHASHENTRY* hashtable;
PHASHENTRY hashentries;
int freeptr, maxptr;

void CGlMesh::HashAdd(WORD va, WORD vb, WORD f)
{
#ifdef _DEBUG
    if (va > m_numWedges || va < 0)
        throw CHashOvrflw();
#endif
    for (PHASHENTRY* t = &(hashtable[va]); *t; t = &((*t)->next));
    PHASHENTRY p = &(hashentries[freeptr++]);
    p->f = f;
    p->v2 = vb;
    p->next = NULL;
    *t=p;
}

WORD CGlMesh::HashFind(WORD va, WORD vb)
{
#ifdef _DEBUG
    if (va > m_baseWedges || va < 0)
        throw CHashOvrflw();
#endif
    for (PHASHENTRY* t = &(hashtable[va]); *t; t = &((*t)->next))
    {
        if ((*t)->v2 == vb)
        {
            return (*t)->f;
        }
    }
    return USHRT_MAX;
}


void CGlMesh::ComputeAdjacency(void)
{
    freeptr = 0;
    maxptr = m_numFaces*3;
    hashtable = new PHASHENTRY[m_numWedges];

    // An entry for each 3 edges of each face in base mesh
    hashentries = new hashentry[maxptr];
    if (!hashtable)
        throw CExNewFailed();
    memset(hashtable, 0, sizeof(PHASHENTRY)*m_numWedges);

    /*
     * For each group of faces
     */
    for(int i=0; i<m_numMaterials; ++i)
    { 
        /* 
         * For each face in the group
         */
#ifdef __MATPOS_IS_A_PTR
        for (int k=0; k<m_matcnt[i]; ++k)
        { 
            int v1 = FindVertexIndex((m_matpos[i][k]).w[0]);
            int v2 = FindVertexIndex((m_matpos[i][k]).w[1]);
            int v3 = FindVertexIndex((m_matpos[i][k]).w[2]);
            
            int fi = GetFaceIndex(i,k);
            HashAdd(v1,v2,fi);
            HashAdd(v2,v3,fi);
            HashAdd(v3,v1,fi);
        }
#else
        for (int k=m_matpos[i]; k<(m_matpos[i]+m_matcnt[i]); ++k)
        { 
            int v1 = FindVertexIndex((m_farray[k]).w[0]);
            int v2 = FindVertexIndex((m_farray[k]).w[1]);
            int v3 = FindVertexIndex((m_farray[k]).w[2]);
            
            HashAdd(v1,v2,k);
            HashAdd(v2,v3,k);
            HashAdd(v3,v1,k);
        }
#endif
    }

#ifdef _DEBUG
    if (freeptr > maxptr)
        throw CHashOvrflw();
#endif
    /*
     * For each group of faces
     */
    for(i=0; i<m_numMaterials; ++i)
    { 
        /* 
         * For each face in the group
         */
#ifdef __MATPOS_IS_A_PTR
        for (int k=0; k<m_matcnt[i]; ++k)
        { 
            int v1 = FindVertexIndex((m_matpos[i][k]).w[0]);
            int v2 = FindVertexIndex((m_matpos[i][k]).w[1]);
            int v3 = FindVertexIndex((m_matpos[i][k]).w[2]);

            int fi = GetFaceIndex(i,k);
            m_fnei[fi][0] = HashFind(v3,v2);
            m_fnei[fi][1] = HashFind(v1,v3);
            m_fnei[fi][2] = HashFind(v2,v1);
        }
#else
        for (int k=m_matpos[i]; k<(m_matpos[i]+m_matcnt[i]); ++k)
        { 
            int v1 = FindVertexIndex((m_farray[k]).w[0]);
            int v2 = FindVertexIndex((m_farray[k]).w[1]);
            int v3 = FindVertexIndex((m_farray[k]).w[2]);

            m_fnei[k][0] = HashFind(v3,v2);
            m_fnei[k][1] = HashFind(v1,v3);
            m_fnei[k][2] = HashFind(v2,v1);
        }
#endif
    }
    delete [] hashtable;
    delete [] hashentries;
}

#if 0
STDMETHODIMP AddWedge (WORD vertex_id, GLnormal& n, 
                       GLtexCoord& t,  DWORD* const wedge_id)
{
    WORD w;
  
    w = m_numWedges++;
    m_wedgelist[w] = m_wedgelist[vertex_id];
    m_wedgelist[vertex_id] = w;
    
    m_varray[w] = m_varray[vertex_id];
    m_narray[w] = n;
    m_tarray[w] = t;
    
    *wedge_id = w;
    return S_OK;
}

STDMETHODIMP AddWedge (Glvertex &v, GLnormal& n, GLtexCoord& t, 
                       DWORD* const wedge_id)
{
    WORD w;
  
    w = m_numWedges++;
    m_wedgelist[w] = w;
    
    m_varray[w] = v;
    m_narray[w] = n;
    m_tarray[w] = t;
    
    *wedge_id = w;
    return S_OK;
}



STDMETHODIMP AddWedge (Glvertex &v)
{
    WORD w;
  
    w = m_numWedges++;
    m_wedgelist[w] = w;
    
    m_varray[w] = v;
    //m_narray[w] = n;
    //m_tarray[w] = t;
    
    *wedge_id = w;
    return S_OK;
}



STDMETHODIMP AddWedge (WORD vertex_id, WORD old_wedge_id, 
                       DWORD* const wedge_id)
{
    WORD w;
  
    w = m_numWedges++;

    /*
     * Add wnl to the list of wedges sharing vertex_id
     */
    m_wedgelist[w] = m_wedgelist[vertex_id];
    m_wedgelist[vertex_id] = w;
    
    /*
     * Copy wedge attributes
     */
    m_varray[w] = m_varray[vertex_id];
    m_narray[w] = m_narray[old_wedge_id];
    m_tarray[w] = m_tarray[old_wedge_id];
    
    *wedge_id = w;
    return S_OK;
}



STDMETHODIMP AddFace (WORD matid, GLface& f)
{
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\glstructs.h ===
/**     
 **       File       : glstructs.h
 **       Description: GL specific structs
 **/

#ifndef _glstructs_h_  
#define _glstructs_h_                    

#include <gl/gl.h>


typedef struct __GLcolorRec 
{
    GLfloat r, g, b, a;
} __GLcolor;

typedef struct GLmaterialRec
{
  __GLcolor emissive;
  __GLcolor ambient;
  __GLcolor diffuse;
  __GLcolor specular;
  __GLcolor ci;
  GLfloat shininess;
  GLuint texObj;
} GLmaterial, *LPGLmaterial;

typedef struct __GLvert
{
    GLfloat x, y, z;
} GLvertex;
typedef GLvertex* LPGLvertex;

typedef struct __GLnorm
{
    GLfloat x, y, z;
} GLnormal;
typedef GLnormal* LPGLnormal;

typedef struct __GLtexCoord
{
    GLfloat s, t;
} GLtexCoord;
typedef GLtexCoord* LPGLtexCoord;

typedef struct __GLface
{
    WORD w[3];
} GLface;
typedef GLface* LPGLface;

typedef struct __GLwedgeAttrib
{
  GLnormal n;
  GLtexCoord t;
} GLwedgeAttrib;
typedef GLwedgeAttrib* LPGLwedgeAttrib;

#endif //_glstructs_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\hash.h ===
/**     
 **       File       : hash.h
 **       Description: Hash table definition
 **/

#ifndef _hash_h_  
#define _hash_h_                    

struct hashentry
{
	WORD v2; 
	WORD f, m; // face and it's matid
	hashentry* next;
};
typedef hashentry* PHASHENTRY;

#endif //_hash_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\interface.h ===
/**     
 **       File       : interface.h
 **       Description: Interface definitions
 **/

#ifndef _interface_h_	
#define _interface_h_                    

#include <unknwn.h>

#define interface struct

EXTERN_C const GUID CDECL FAR IID_IPMesh;
EXTERN_C const GUID CDECL FAR IID_IPMeshGL;
EXTERN_C const GUID CDECL FAR IID_IPMGeomorph;
EXTERN_C const GUID CDECL FAR IID_IPMeshLoadCB;

interface IPMeshLoadCB:IUnknown
{
	STDMETHOD(OnDataAvailable)(DWORD, DWORD)=0;
};

typedef IPMeshLoadCB* LPPMESHLOADCB;

/*
 * IPMGeomorph Interface
 */

interface IPMGeomorph:IUnknown
{
	STDMETHOD(SetBlend)(float)=0;
	STDMETHOD(GetBlend)(float*)=0;
};

typedef IPMGeomorph* LPPMGEOMORPH;

/*
 * IPMesh Interface
 */

interface IPMesh: public IUnknown
{
	STDMETHOD (Load)(const char* const, const char* const, DWORD* const, 
                     DWORD* const, LPPMESHLOADCB)=0;
	STDMETHOD (LoadStat)(const char* const, const char* const, DWORD* const, 
                         DWORD* const)=0;
	STDMETHOD (GetNumFaces)(DWORD* const)=0;
	STDMETHOD (SetNumFaces)(DWORD)=0;
	STDMETHOD (GetNumVertices)(DWORD* const)=0;
	STDMETHOD (SetNumVertices)(DWORD)=0;
	STDMETHOD (GetMaxVertices)(DWORD* const)=0;
	STDMETHOD (GetMaxFaces)(DWORD* const)=0;
	STDMETHOD (GeomorphToVertices)(LPPMGEOMORPH, DWORD* const)=0;
	STDMETHOD (GeomorphToFaces)(LPPMGEOMORPH, DWORD* const)=0;
	STDMETHOD (ClonePM)(IPMesh* const)=0;
};

typedef IPMesh* LPPMESH;

/*
 * IPMeshGL Interface
 */

interface IPMeshGL: public IUnknown
{
	STDMETHOD (Initialize)(void)=0;
	STDMETHOD (Render)(void)=0;
};

typedef IPMeshGL* LPPMESHGL;


#endif //_interface_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\pmerrors.h ===
/**     
 **       File       : pmerror.h
 **       Description: Macros for reporting error
 **/

#ifndef _pmerror_h_	
#define _pmerror_h_ 
                   
#include <winerror.h>

#define PM_E_FOPENERROR MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)
#define PM_E_BADVALENCE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)
#define PM_E_BADWEDGEDATA MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)
#define PM_E_BADINTCODE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)
#define PM_E_MATCNT_MISMATCH MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)
#define PM_E_MATCREATEFAILED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)
#define PM_E_PMESHNOTLOADED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)
#define PM_E_BADMATERIALID  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)

#endif //_pmerror_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\precomp.h ===
#include <windows.h>
#include <fstream.h>
#include <gl\gl.h>
#include <objidl.h>
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\pmesh.h ===
/**     
 **       File       : pmesh.h
 **       Description: Main include file
 **/

#ifndef _pmesh_h_	
#define _pmesh_h_                    

#include "interface.h"

HRESULT CreatePMeshGL(REFIID, LPVOID FAR *, IUnknown *, DWORD);

#endif //_pmesh_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\load.cxx ===
#include "precomp.h"
#pragma hdrstop

#include "cpmesh.h"
#include "pmerrors.h"
#include "fileio.h"


float (* vdata)[3];

static GLuint LoadTexture (char* file)
{
    return 0;
}


const short PM_MAX_TEX_STRING_LEN = 1024; // Enforced by the spec.

/*
 * This function currently only works on external files, not on URLs.
 * It can only load .pmx files and not PM records embedded in X files.
 * Hence the "pmname" argument is ignored.
 * It only supports synchronous loads so pPMeshLoadCB is ignored
 * !!Currently no memory cleanup occurs on error. Must add code to do so.
 * Could use a local win32 heap!!
 * See \\anujg\docs\"Progressive Mesh file format.doc" for details on the
 * file format
 */


/*
 * The concept of Materials:
 *             1) Materials can be "looked up", i.e. textures
 *             2) Computed using a API specific lighting equation. (pure mat)
 *             3) Both of above combined. (Modulated/Lit textures)
 */

STDMETHODIMP CPMeshGL::Load(const TCHAR* const url, 
                            const TCHAR* const pmname, 
                            DWORD* const minvert, 
                            DWORD* const maxvert, 
                            LPPMESHLOADCB pPMeshLoadCB)
{
    DWORD i, k;
    WORD j, ftCurveSize, fmCurveSize;
    DWORD vAttr, wAttr, fAttr, mAttr, sAttr;
    DWORD mOffset, vOffset, wOffset, fOffset;
    DWORD& maxVert = *maxvert;
    DWORD& minVert = *minvert;
    HRESULT hr;
    DWORD vsplit_offset, bmesh_offset;

    // Estimated number of faces and wedges in the mesh with maxvert vertices
    DWORD nFacePredict=0, nWedgePredict=0;

    // A curve is approximated by an array of pairs {(x,y), (x,y),...}
    typedef struct crvpnt{
        DWORD x;
        float y;
    } *CURVE; 
    CURVE *ftcurves, *fmcurves; // An array of curves

    ifstream is(url);
    if (!is)
        return PM_E_FOPENERROR;
    is.setmode(filebuf::binary);

#ifdef __DUMP_DATA
    ofstream dump("dump.pmx");
    if (!dump)
        return PM_E_FOPENERROR;
    dump.setmode(filebuf::text);
#endif //__DUMP_DATA
    
    /*
     * Read PMesh Header
     */
    read_DWORD(is, m_maxVertices);
#ifdef __MAT_PREALLOC_OPTIMIZATION
    maxVert = min(maxVert, m_maxVertices);
#else  
    maxVert = m_maxVertices;
#endif //__MAT_PREALLOC_OPTIMIZATION
    *maxvert = maxVert;
    
    read_DWORD(is, m_maxWedges);
    read_DWORD(is, m_maxFaces);
    read_DWORD(is, m_maxMaterials);
    read_DWORD(is, m_maxTextures);

#ifdef __DUMP_DATA
    dump << "\nMaxVert   = " << m_maxVertices;
    dump << "\nMaxWedges = " << m_maxWedges;
    dump << "\nMaxFaces  = " << m_maxFaces;
    dump << "\nMaxMat    = " << m_maxMaterials;
    dump << "\nMaxTex    = " << m_maxTextures;
#endif //__DUMP_DATA
    
    /*
     * Max Valence
     */
    read_DWORD(is, i); 
    if (i > 65535)
        return PM_E_BADVALENCE;
#ifdef __DUMP_DATA
    dump << "\nMaxValence = " << i;
#endif //__DUMP_DATA

    /*
     * Normal Encoding
     */
    read_WORD(is, j); 
    if (((j & NORM_MASK) != NORM_EXPLICIT) || ((j & TEX_MASK) != TEX_EXPLICIT))
        return PM_E_BADWEDGEDATA;
#ifdef __DUMP_DATA
    dump << "\nNormal Encoding = " << j;
#endif //__DUMP_DATA

    /*
     * Integer Encoding
     */
    read_WORD(is, j); // integer encoding type
    if (j != INTC_MAX)
        return PM_E_BADINTCODE;
#ifdef __DUMP_DATA
    dump << "\nInteger Encoding = " << j;
#endif //__DUMP_DATA

    /*
     * Sizes of various user defined attributes
     */
    read_DWORD(is, vAttr); // Vertex attributes
    read_DWORD(is, wAttr); // Wedge attributes
    read_DWORD(is, fAttr); // Face attributes
    read_DWORD(is, mAttr); // Material attributes
    read_DWORD(is, sAttr); // VSplit attributes
#ifdef __DUMP_DATA
    dump << "\n\nUser defined attribute sizes:";
    dump << "\nVertex: "   << vAttr;
    dump << "\nWedge: "    << wAttr;
    dump << "\nFace: "     << fAttr;
    dump << "\nMaterial: " << mAttr;
    dump << "\nVSplit: "   << sAttr;
#endif //__DUMP_DATA

    /*
     * Allocate material and texture related tables
     */
    WORD *matcnt = new WORD [m_maxMaterials];
#ifdef __MATPOS_IS_A_PTR
    GLface **matpos = new GLface* [m_maxMaterials];
#else
    WORD *matpos = new WORD [m_maxMaterials];
#endif
    GLmaterial *matArray = new GLmaterial [m_maxMaterials]; 
    if (!matArray || !matcnt || !matpos)
    {
        return E_OUTOFMEMORY;
    }
    else 
    {
        m_matArray = matArray;
        m_matcnt = matcnt;
        m_matpos = matpos;
    }
    
#ifdef __MATPOS_IS_A_PTR
    /* 
     * Allocate the vertex and normal arrays.
     */

    GLvertex *varray = new GLvertex  [m_maxWedges];
    GLnormal *narray = new GLnormal  [m_maxWedges];
    GLtexCoord *tarray = new GLtexCoord [m_maxWedges];
    WORD *wedgelist = new WORD [m_maxWedges];
    WORD (*fnei)[3] = new WORD [m_maxFaces][3];
    GLface *farray    = new GLface [m_maxFaces];
     
    if (!farray || !varray || !narray || !tarray || !wedgelist || !fnei)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        m_varray = varray;
        m_narray = narray;
        m_tarray = tarray;
        m_farray = farray;
        m_wedgelist = wedgelist;
        m_fnei      = fnei;
    }
#endif

    /*
     * Read face-texture curve
     */
    read_WORD(is, ftCurveSize); // Size of face-texture curve
#ifdef __DUMP_DATA
    dump << "\n\nFace-texture curve:";
    dump << "\nFT-curve size: "   << ftCurveSize;
#endif //__DUMP_DATA
    ftcurves = new CURVE[m_maxTextures]; // A curve for each texture
    DWORD* ftmax = new DWORD[m_maxTextures];
    if (!ftcurves || !ftmax)
        return E_OUTOFMEMORY;
    for (k=0; k<m_maxTextures; ++k)
    {
        ftcurves[k] = new crvpnt[ftCurveSize];
        if (!ftcurves[k])
            return E_OUTOFMEMORY;
        
        read_DWORD(is,ftmax[k]); // Total faces of tex k in fully detailed 
                                 // mesh
#ifdef __DUMP_DATA
        dump << "\n\nTotal faces of tex " << k << " in fully detailed mesh: ";
        dump << ftmax[k];
#endif //__DUMP_DATA
        for (i=0; i<ftCurveSize; ++i)
        {
          
            read_DWORD(is, ftcurves[k][i].x); // vertex(i) of ftcurve of 
                                              // texture k.
            read_float(is, ftcurves[k][i].y); // faces of tex k when total 
                                              // vert in mesh = vertex(i).
#ifdef __DUMP_DATA
        dump << "\n (" << ftcurves[k][i].x << ", " << ftcurves[k][i].y << ")";
#endif //__DUMP_DATA
        }
    }

#ifdef __TEX_PREALLOC_OPTIMIZATION
    for (k=0; k<m_maxTextures; ++k)
    {
        for (i=0; i<ftCurveSize; ++i)
        {
            if (ftcurves[k][i].x == maxVert)
            {
                m_texcnt[k] = WORD(ftcurves[k][i].y + 0.5);
                m_texcnt[k] = WORD(min(m_texcnt[k], ftmax[k]));
                break;
            }
            else if (ftcurves[k][i].x > maxVert)
            {
                m_texcnt[k] = WORD(ftcurves[k][i-1].y + 
                                   (maxVert - ftcurves[k][i-1].x) *
                                   (ftcurves[k][i].y - ftcurves[k][i-1].y) / 
                                   (ftcurves[k][i].x - ftcurves[k][i-1].x));
                m_texcnt[k] = WORD(min(m_texcnt[k], ftmax[k]));
                break;
            }
        }
        nFacePredict += m_texcnt[k];
        delete [] ftcurves[k];
    }
    delete [] ftcurves;
    delete [] ftmax;
    
    /* 
     * Convert m_texcnt to array of offsets into the prim buf where faces of 
     * that texture need to be stored.
     */
    m_texpos[0] = 0; 
    for (i=1; i<m_maxTextures; ++i)
        m_texpos[i] = WORD(m_texpos[i-1] + m_texcnt[i-1] + 
                                           TEXTUREGAP/sizeof(D3DTRIANGLE));
#else
    delete [] ftcurves;
    delete [] ftmax;
#endif __TEX_PREALLOC_OPTIMIZATION

    /*
     * Read face-material curve
     */

    read_WORD(is,fmCurveSize); // Size of face-material curve
#ifdef __DUMP_DATA
    dump << "\n\nFace-material curve:";
    dump << "\nFM-curve size: "   << fmCurveSize;
#endif //__DUMP_DATA
    fmcurves = new CURVE[m_maxMaterials];
    DWORD* fmmax = new DWORD[m_maxMaterials];
    if (!fmcurves || !fmmax)
        return E_OUTOFMEMORY;

    for (k=0; k<m_maxMaterials; ++k)
    {
        fmcurves[k] = new crvpnt [fmCurveSize];
        if (!fmcurves[k])
            return E_OUTOFMEMORY;

        read_DWORD(is,fmmax[k]); // Total faces of material k in fully 
                                 // detailed mesh
#ifdef __DUMP_DATA
        dump << "\n\nTotal faces of mat " << k << " in fully detailed mesh: ";
        dump << fmmax[k];
#endif //__DUMP_DATA
        for (i=0; i<fmCurveSize; ++i)
        {
            read_DWORD(is,fmcurves[k][i].x); // vertex(i) of fmcurve of 
                                             // material k
            read_float(is,fmcurves[k][i].y); // faces of mat k when total 
                                             // vert in mesh = vertex(i)
#ifdef __DUMP_DATA
        dump << "\n (" << fmcurves[k][i].x << ", " << fmcurves[k][i].y << ")";
#endif //__DUMP_DATA
        }
    }

#ifdef __MAT_PREALLOC_OPTIMIZATION
    for (k=0; k<m_maxMaterials; ++k)
    {
        for (i=0; i<fmCurveSize; ++i)
        {
            if (fmcurves[k][i].x == maxVert)
            {
                matcnt[k] = WORD(fmcurves[k][i].y + 0.5);
                matcnt[k] = WORD(min(matcnt[k], fmmax[k]));
                break;
            }
            else if (fmcurves[k][i].x > maxVert)
            {
                matcnt[k] = WORD(fmcurves[k][i-1].y + (maxVert - 
                                                       fmcurves[k][i-1].x) *
                               (fmcurves[k][i].y - fmcurves[k][i-1].y) / 
                               (fmcurves[k][i].x - fmcurves[k][i-1].x));
                matcnt[k] = WORD(min(matcnt[k], fmmax[k]));
                break;
            }
        }
        nFacePredict += matcnt[k];
        delete [] fmcurves[k];
    }
    delete [] fmcurves;
    delete [] fmmax;

#else //__MAT_PREALLOC_OPTIMIZATION
    /* 
     * Convert m_matcnt to array of offsets into the face buf where faces of 
     * that material need to be stored.
     */
#ifdef __MATPOS_IS_A_PTR
    matpos[0] = farray; 
    int cnt = 0;
    for (i=1; i<m_maxMaterials; ++i)
    {
        matpos[i] = &(farray[cnt + fmmax[i-1]]);
        cnt += fmmax[i-1];
    }
#else
    matpos[0] = 0;
    for (i=1; i<m_maxMaterials; ++i)
    {
        matpos[i] = matpos[i-1] + fmmax[i-1];
    }
#endif
    
    delete [] fmcurves;
    delete [] fmmax;
#endif //__MAT_PREALLOC_OPTIMIZATION

    read_DWORD(is,vsplit_offset);   // offset to vsplit array from end of 
                                    // the Base mesh
    read_DWORD(is,bmesh_offset);    // offset from here to start of base mesh

#ifdef __DUMP_DATA
        dump << "\n\nVSplit offset from BaseMesh: " << vsplit_offset; 
        dump << "\n\nBaseMesh offset from here: "   << bmesh_offset;
#endif //__DUMP_DATA

#ifndef __MATPOS_IS_A_PTR
    /* 
     * Allocate the vertex and normal arrays.
     */

    GLvertex *varray = new GLvertex  [m_maxWedges];
    GLnormal *narray = new GLnormal  [m_maxWedges];
    GLtexCoord *tarray = new GLtexCoord [m_maxWedges];
    WORD *wedgelist = new WORD [m_maxWedges];
    WORD (*fnei)[3] = new WORD [m_maxFaces][3];
    GLface *farray    = new GLface [m_maxFaces];
    WORD *facemap    = new WORD [m_maxFaces];
     
    if (!farray || !varray || !narray || !tarray || !wedgelist || !fnei
        || !facemap)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        m_varray = varray;
        m_narray = narray;
        m_tarray = tarray;
        m_farray = farray;
        m_wedgelist = wedgelist;
        m_fnei      = fnei;
        m_facemap   = facemap;
    }
#endif    
    /*
     * Read Base Mesh Header
     */

    if (bmesh_offset)
        skip_bytes(is,bmesh_offset); // jump to start of base mesh.

    read_DWORD(is,m_baseVertices);
#ifdef __MAT_PREALLOC_OPTIMIZATION
    minVert = max(minVert, m_baseVertices);
#else
    minVert = m_baseVertices;
#endif //__MAT_PREALLOC_OPTIMIZATION
    *minvert = minVert;
    m_numVerts = m_baseVertices;
    
    read_DWORD(is,m_baseWedges);
    m_numWedges = m_baseWedges;

    read_DWORD(is,m_baseFaces);
    m_numFaces = m_baseFaces;

    read_DWORD(is,i); // max materials
    if (i != m_maxMaterials)
        return PM_E_MATCNT_MISMATCH;
    else
        m_numMaterials = i;

    read_DWORD(is,mOffset); // Offset to mat array
    read_DWORD(is,vOffset); // Offset to vertex array
    read_DWORD(is,wOffset); // Offset to wedge array
    read_DWORD(is,fOffset); // Offset to face array
    
#ifdef __DUMP_DATA
        dump << "\n\n# of baseVerts: " << m_baseVertices; 
        dump << "\n# of baseWedges: "  << m_baseWedges; 
        dump << "\n# of baseFaces: "   << m_baseFaces; 

        dump << "\n\nOffset to MatArray: "   << mOffset; 
        dump << "\nOffset to Vertex Array: " << vOffset; 
        dump << "\nOffset to Wedge Array: "  << wOffset; 
        dump << "\nOffset to Face Array: "   << fOffset; 
#endif //__DUMP_DATA

    /*
     * Read Materials
     */
    j = 0; // texture count
    if (mOffset)
        skip_bytes(is, mOffset);

    for (i=0; i<m_maxMaterials; ++i)
    {
        char texname[PM_MAX_TEX_STRING_LEN];

        matArray[i].ambient.r = 
        matArray[i].ambient.g = 
        matArray[i].ambient.b = 
        matArray[i].ambient.a = 0.0f;
        
        matcnt[i] = (WORD) 0;
        
        read_float(is, matArray[i].diffuse.r);
        read_float(is, matArray[i].diffuse.g);
        read_float(is, matArray[i].diffuse.b);
        read_float(is, matArray[i].diffuse.a);

        read_float(is, matArray[i].shininess);

        read_float(is, matArray[i].specular.r);
        read_float(is, matArray[i].specular.g);
        read_float(is, matArray[i].specular.b);
        read_float(is, matArray[i].specular.a);

        read_float(is, matArray[i].emissive.r);
        read_float(is, matArray[i].emissive.g);
        read_float(is, matArray[i].emissive.b);
        read_float(is, matArray[i].emissive.a);

        is.getline(texname, 1024, '\0');
        if (texname[0])
        {
            j++;
            matArray[i].texObj = LoadTexture (texname);
        }
        else
        {
            matArray[i].texObj = 0;
        }
    }

    /*
     * Read base-mesh faces
     */

    if (fOffset)
        skip_bytes(is, fOffset);

    for (i=0; i<m_baseFaces; ++i)
    { 
        DWORD w;
        WORD matid;

        read_WORD(is, matid);
        for (int j=0; j<3; ++j)
        {
            read_DWORD(is, w);
#ifdef __MATPOS_IS_A_PTR
            (matpos[matid][matcnt[matid]]).w[j] = (WORD)w;
#else
            (farray[matpos[matid] + matcnt[matid]]).w[j] = (WORD)w;
#endif
            facemap[i] = matpos[matid] + matcnt[matid];
        }
        matcnt[matid]++;
    }
    
    /*
     * Read base-mesh wedges
     */
    if (wOffset)
        skip_bytes(is, wOffset);
    long* vidx_arr = new long[m_baseVertices];
    if (!vidx_arr)
        return E_OUTOFMEMORY;
    memset(vidx_arr, -1, sizeof(long) * m_baseVertices);

	for (i=0; i<m_baseWedges; ++i)
	{
		DWORD vidx;
		read_DWORD(is, vidx);
#ifdef _DEBUG
		if (vidx >= m_baseVertices)
			return -1;
#endif
		if (vidx_arr[vidx] < 0)
		{   
            /*
             * New vertex, create entry and initialize the wedge list
             */

            vidx_arr[vidx] = i;
            wedgelist[i] = WORD(i); // create circular list with one entry
		}
		else
		{ 
            /* 
             * Another wedge uses existing vertex, add new wedge to the 
             * existing wedge list.
             */

			wedgelist[i] = wedgelist[vidx_arr[vidx]];
			wedgelist[vidx_arr[vidx]] = WORD(i);
		}
		read_float(is, narray[i].x);
		read_float(is, narray[i].y);
		read_float(is, narray[i].z);

		read_float(is, tarray[i].s);
		read_float(is, tarray[i].t);
    }
     
    /*
     * Read base-mesh vertices
     */

	if (vOffset)
		skip_bytes(is, vOffset);
	for (i=0; i<m_baseVertices; ++i)
	{
		float x, y, z;
		read_float(is, x);
		read_float(is, y);
		read_float(is, z);

		/*
         * Loop thru all wedges that share the vertex 
         * and fill in coordinates.
         */
        WORD start = j = WORD(vidx_arr[i]);
		do
		{
			varray[j].x = x;
			varray[j].y = y;
			varray[j].z = z;
		}
		while ((j=wedgelist[j]) != start);
    }
	delete [] vidx_arr;


#ifdef __DUMP_DATA
    Print (dump);
#endif //__DUMP_DATA

	/*
     * Compute adjacency before we apply any vsplits
     */
	ComputeAdjacency();

	/*
	 * Read Vsplit records
     */
    m_vsarr = new VsplitArray(maxVert - minVert);
	for (i=0; i<maxVert-m_baseVertices; ++i)
	{
        /*
         * Keep applying vsplits till base mesh is refined to have 
         * minVert vertices.
         */
	
        if (i + m_baseVertices < minVert)
		{ 
			Vsplit vs;
			vs.read(is);
			apply_vsplit(vs);
			// Update m_base* members
		}
		else // Read the rest in the Vsplit array
		{
			m_vsarr->elem(i + m_baseVertices - minVert).read(is);
		}
	}

#ifdef __DUMP_DATA
    m_vsarr->write(dump);
#endif //__DUMP_DATA
	m_currPos = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\sglmesh.cxx ===
/**     
 **       File       : sglmesh.cxx
 **       Description: Implementations of CSGlMesh class
 **/
#include "precomp.h"
#pragma hdrstop


#include "sglmesh.h"
#include "pmerrors.h"


/**************************************************************************/

/*
 *  CSimpGlMesh: Constructor
 */
CSimpGlMesh::CSimpGlMesh()
{
    m_varray = NULL;
    m_narray = NULL;
    m_tarray = NULL;
    m_farray = NULL;
    m_wedgelist = NULL;
    
    m_matArray = NULL;
    m_matcnt = NULL;
    m_matpos = NULL;

    m_userWedgeSize = 0;
    m_userWedge = NULL;

    m_userVertexSize = 0;
    m_userVertex = NULL;

    m_userFaceSize = 0;
    m_userFace = NULL;
    m_numFaces = 0;
    m_numWedges = 0;
    m_numVerts = 0;
    m_numMaterials = 0;
    m_numTextures = 0;
}


/*
 *  CSimpGlMesh: Destructor
 */
CSimpGlMesh::~CSimpGlMesh()
{
    delete [] m_varray;
    delete [] m_narray;
    delete [] m_tarray;
    delete [] m_matArray;
    delete [] m_wedgelist;
    
    delete [] m_userWedge;
    delete [] m_userVertex;
    delete [] m_userFace;

    delete [] m_matArray;
    delete [] m_matcnt;
    delete [] m_matpos;
}

/*
 *  CSimpGlMesh: Print
 */
HRESULT CSimpGlMesh::Print(ostream& os)
{

    os << "\n\nMaterials:";
    for (int i=0; i<m_numMaterials; ++i)
    {
        LPGLmaterial lpglm = &m_matArray[i];
      
        os << "\n\nMaterial [" << i << "] :";
        os << "\nShininess : " << lpglm->shininess;
        os << "\nDiffuse  : (" << lpglm->diffuse.r << ", "
           << lpglm->diffuse.g << ", "
           << lpglm->diffuse.b << ", "
           << lpglm->diffuse.a << ")";
        os << "\nSpecular : (" << lpglm->specular.r << ", "
           << lpglm->specular.g << ", "
           << lpglm->specular.b << ", "
           << lpglm->specular.a << ")";
        os << "\nEmissive : (" << lpglm->emissive.r << ", "
           << lpglm->emissive.g << ", "
           << lpglm->emissive.b << ", "
           << lpglm->emissive.a << ")";
        os << "\nNumber of faces: " << m_matcnt[i];
        for (int j=0; j< m_matcnt[i]; j++)
        {
#ifdef __MATPOS_IS_A_PTR
            os << "\n(" << m_matpos[i][j].w[0]   << ","
               << (m_matpos[i][j]).w[1] << ","
               << (m_matpos[i][j]).w[2] << ")";
#else
            os << "\n(" << (m_farray[m_matpos[i] + j]).w[0]   << ","
               << (m_farray[m_matpos[i] + j]).w[0]  << ","
               << (m_farray[m_matpos[i] + j]).w[0]  << ")";
#endif
        }
    }

    os << "\n\nWedge connectivity:";
    for (i=0; i<m_numWedges; ++i)
    {
        os << "\n" << m_wedgelist[i];
    }
    
    os << "\n\nWedge data:";
    for (i=0; i<m_numWedges; ++i)
    {
        os   << "\n(" << m_varray[i].x << ", "
                      << m_varray[i].y << ", "
                      << m_varray[i].z << ") "
             << "  (" << m_narray[i].x << ", "
                      << m_narray[i].y << ", "
                      << m_narray[i].z << ") "
             << "  (" << m_tarray[i].s << ", "
                      << m_tarray[i].t << ") ";
    }
    return S_OK;
}

/*
 *  CSimpGlMesh: RenderMesh
 */
HRESULT CSimpGlMesh::RenderMesh(RenderType rt)
{
    if (rt == GLPM_SOLID)
    {
        glVertexPointer(3, GL_FLOAT, 0, (void *)&(m_varray[0].x));
        glNormalPointer (GL_FLOAT, 0, (void *)&(m_narray[0].x));
        glTexCoordPointer (2, GL_FLOAT, 0, (void *)&(m_tarray[0].s));
        
        glEnableClientState (GL_VERTEX_ARRAY);
        glEnableClientState (GL_NORMAL_ARRAY);
        
        for (int i=0; i<m_numMaterials; i++)
        {
            LPGLmaterial lpglm = &(m_matArray[i]);
            
            if (m_matcnt[i] == (WORD) 0) continue;
            
            glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, lpglm->shininess);
            glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, 
                         (GLfloat *) &(lpglm->specular));
            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,  
                         (GLfloat *) &(lpglm->diffuse));
            glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, 
                     (GLfloat *) &(lpglm->emissive));
            glDrawElements (GL_TRIANGLES, (GLuint) m_matcnt[i]*3, 
                            GL_UNSIGNED_SHORT, 
                            (void *) &(m_farray[m_matpos[i]]));
        }
        return S_OK;
    }
    else
    {
        return E_NOTIMPL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\sglmesh.h ===
/**     
 **       File       : sglmesh.h
 **       Description: Simple gl mesh definition
 **/

#ifndef _sglmesh_h_  
#define _sglmesh_h_                    

#include "global.h"
#include "glstructs.h"
#include "excptn.h"

/*************************************************************************
  Typedefs, structs and classes
*************************************************************************/

typedef enum 
{
    GLPM_SOLID = 0x0001,
    GLPM_WIRE  = 0x0002,
} RenderType;


class CSimpGlMesh
{
protected:
public:
    /*
     * Vertex-Array data 
     */
    GLvertex* m_varray;   // Vertex Array to store Wedges/Vertices
    GLnormal* m_narray;   // Normal Array to store Normals
    GLtexCoord* m_tarray; // Texture Array 
    GLface* m_farray;     // Face Array
    WORD* m_wedgelist;    // circular linked lists of wedges sharing the same
                          // vertex

    /*
     * Material/Texture related info
     */
    GLmaterial*  m_matArray;   // Array of Materials
	WORD* m_matcnt;       // table of face counts per material
#ifdef __MATPOS_IS_A_PTR
    GLface** m_matpos;    // pointers to where next face of a given material 
                          // is inserted in the m_farray
#else
    WORD* m_matpos;       // pointers to where next face of a given material 
                          // is inserted in the m_farray
#endif  

    /*
     * Various counts
     */
    DWORD m_numFaces;
    DWORD m_numWedges;
    DWORD m_numVerts;
    DWORD m_numMaterials;
    DWORD m_numTextures;

    /*
     * User-defined data 
     */
    DWORD   m_userWedgeSize;   // Size of user defined wedge-data
    LPVOID  m_userWedge;       // User defined data per wedge
  
    DWORD   m_userVertexSize; // Size of user defined vertex-data
    LPVOID  m_userVertex;     // User defined data per vertex

    DWORD   m_userFaceSize;   // Size of user defined face-data
    LPVOID  m_userFace;       // User defined data per face

public:
    //Constructor-Destructor
    CSimpGlMesh();
    virtual ~CSimpGlMesh();

    virtual HRESULT Print (ostream& os);
	virtual HRESULT RenderMesh (RenderType);

    inline DWORD GetMeshNumFaces (void) const {return m_numFaces;}
    inline DWORD GetMeshNumWedges (void) const {return m_numWedges;}
    inline DWORD GetMeshNumVerts (void) const {return m_numVerts;}
    inline DWORD GetMeshNumMaterials (void) const {return m_numMaterials;}
    inline DWORD GetMeshNumTextures (void) const {return m_numTextures;}
    inline LPGLmaterial GetMeshMaterial (int i) const 
    {
        return &(m_matArray[i]);
    }
	inline WORD FindVertexIndex(WORD w) const;
    inline LPVOID GetMeshUserFaceData (void) const {return m_userFace;}
    inline LPVOID GetMeshUserWedgeData (void) const {return m_userWedge;} 
    inline LPVOID GetMeshUserVertexData (void) const {return m_userVertex;}
};

/*
 * Inlines
 */
inline WORD CSimpGlMesh::FindVertexIndex(WORD w) const
{
	WORD v = USHRT_MAX;
	WORD p = w;
	do
	{
		v = min(p,v);
		p = m_wedgelist[p];
	}
	while (p != w);
	return v;
}

#endif //_sglmesh_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\vsplit.h ===
/**     
 **       File       : vsplit.h
 **       Description: vsplit implementations
 **/

#ifndef _vsplit_h_  
#define _vsplit_h_                    

#include "excptn.h"

typedef float WEDGEATTRD[5]; // wedge attribute delta

/*
 * Vertex split record.
 * Records the information necessary to split a vertex of the mesh,
 * in order to add to the mesh 1 new vertex and 1 or 2 new faces.
 */

class Vsplit {
public:   
    /* 
     * Default operator=() and copy_constructor are safe.
     */

    void read(istream& is);
    void write(ostream& os) const;
    void OK() const { };
    int adds_two_faces() const { return 0; };

    /* 
     * This format provides these limits:
     * - maximum number of faces: 1<<32
     * - maximum vertex valence:  1<<16
     * - maximum number of materials: 1<<16
     *
     * Encoding of vertices vs, vl, vr.
     * Face flclw is the face just CLW of vl from vs.
     *  vs is the vs_index\'th vertex of flclw
     *  (vl is the (vs_index+2)%3\'th vertex of face flclw)
     *  vr is the (vlr_offset1-1)\'th vertex when rotating CLW about vs 
     * from vl
     *
     * Special cases:
     * - vlr_offset1==1 : no_vr and no_fr
     * - vlr_offest1==0: no flclw! vspl.flclw is actually flccw.
     */

    DWORD flclw;         // 0..(mesh.numFaces()-1)
    WORD vlr_offset1;    // 0..(max_vertex_valence) (prob < valence/2)
    WORD code;           // (vs_index(2),ii(2),ws(3),wt(3),wl(2),wr(2),
                         //  fl_matid>=0(1),fr_matid>=0(1))
    enum {
        B_STMASK=0x0007,
        B_LSAME=0x0001,
        B_RSAME=0x0002,
        B_CSAME=0x0004,
        //
        B_LRMASK=0x0003,
        B_ABOVE=0x0000,
        B_BELOW=0x0001,
        B_NEW  =0x0002,         // must be on separate bit.
    };
    enum {
        VSINDEX_SHIFT=0,
        VSINDEX_MASK=(0x0003<<VSINDEX_SHIFT),
        //
        II_SHIFT=2,
        II_MASK=(0x0003<<II_SHIFT),
        //
        S_SHIFT=4,
        S_MASK=(B_STMASK<<S_SHIFT),
        S_LSAME=(B_LSAME<<S_SHIFT),
        S_RSAME=(B_RSAME<<S_SHIFT),
        S_CSAME=(B_CSAME<<S_SHIFT),
        //
        T_SHIFT=7,
        T_MASK=(B_STMASK<<T_SHIFT),
        T_LSAME=(B_LSAME<<T_SHIFT),
        T_RSAME=(B_RSAME<<T_SHIFT),
        T_CSAME=(B_CSAME<<T_SHIFT),
        //
        L_SHIFT=10,
        L_MASK=(B_LRMASK<<L_SHIFT),
        L_ABOVE=(B_ABOVE<<L_SHIFT),
        L_BELOW=(B_BELOW<<L_SHIFT),
        L_NEW  =(B_NEW<<L_SHIFT),
        //
        R_SHIFT=12,
        R_MASK=(B_LRMASK<<R_SHIFT),
        R_ABOVE=(B_ABOVE<<R_SHIFT),
        R_BELOW=(B_BELOW<<R_SHIFT),
        R_NEW  =(B_NEW<<R_SHIFT),
        //
        FLN_SHIFT=14,
        FLN_MASK=(1<<FLN_SHIFT),
        //
        FRN_SHIFT=15,
        FRN_MASK=(1<<FRN_SHIFT),
    };

    /*
     * Documentation:
     * -------------
     * vs_index: 0..2: index of vs within flace flclw
     * ii: 0..2: == alpha(1.0, 0.5, 0.0)
     *   ii=2: a=0.0 (old_vs=~new_vs)
     *   ii=1: a=0.5
     *   ii=0: a=1.0 (old_vs=~new_vt)
     * Inside wedges
     *  {S,T}{LSAME}: if exists outside left wedge and if same
     *  {S,T}{RSAME}: if exists outside right wedge and if same
     *  {S,T}{CSAME}: if inside left and right wedges are same
     *  (when no_vr, {S,T}RSAME==1, {S,T}CSAME==0)
     * Outside wedges
     *  (when no_vr, RABOVE==1)
     * New face material identifiers
     *  {L,R}NF: if 1, face matids not predicted correctly using ii,
     *     so included in f{l,r}_matid
     *  (when no_vr, RNF==0 obviously)
     *
     * Probabilities:
     *  vs_index: 0..2 (prob. uniform)
     *  ii: ii==2 prob. low/med   (med if 'MeshSimplify -nominii1')
     *      ii==0 prob. low/med
     *      ii==1 prob. high/zero (zero if 'MeshSimplify -monminii1')
     *  {S,T}LSAME: prob. high
     *  {S,T}RSAME: prob. high
     *  {S,T}CSAME: prob. low
     *  {L,R}ABOVE: prob. high
     *  {L,R}BELOW: prob. low
     *  {L,R}NEW:   prob. low
     * Note: wl, wr, ws, wt are correlated since scalar half-edge
     *  discontinuities usually match up at both ends of edges.
     * -> do entropy coding on (ii,wl,wr,ws,wt) symbol as a whole.
     *
     * Face attribute values (usually predicted correctly)
     * these are defined only if {L,R}NF respectively
     *  otherwise for now they are set to 0
     */

    WORD fl_matid;
    WORD fr_matid;

    /*
     * Vertex attribute deltas:
     * -----------------------
     * for ii==2: vad_large=new_vt-old_vs, vad_small=new_vs-old_vs
     * for ii==0: vad_large=new_vs-old_vs, vad_small=new_vt-old_vs
     * for ii==1: vad_large=new_vt-new_i,  vad_small=new_i-old_vs
     *    where new_i=interp(new_vt,new_vs)
     */

    float vad_large[3];
    float vad_small[3]; // is zero if "MeshSimplify -nofitgeom"

    /* 
     * Wedge attribute deltas (size 1--6) 
     * Order: [(wvtfl, wvsfl), [(wvtfr, wvsfr)], wvlfl, [wvrfr]]
     * [nx, ny, nz, s, t]
     */

    float ar_wad[6][5];

    /*
     * Indicates if the Vsplit has been modified or not
     */

    BOOL modified;
private:
    int expected_wad_num() const;
};


class VsplitArray
{
private:
	DWORD m_cRef;
	Vsplit* m_vsarr;
    DWORD numVS;

public:
    void write(ostream& os) const;
	ULONG AddRef(void);
	ULONG Release(void);
	Vsplit& elem(DWORD i) { return m_vsarr[i]; };
	VsplitArray(DWORD i);
};



#endif _vsplit_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\resolutn.cxx ===
/**     
 **       File       : resolutn.cxx
 **       Description: Implementations of CPMeshGL methods that change the 
 **                    pmesh resolution.
 **/
#include "precomp.h"
#pragma hdrstop

#include "cpmesh.h"
#include "array.h"
#include "pmerrors.h"
#include <math.h>

void CPMeshGL::sub_reflect(WORD a, const GLwedgeAttrib& abase, 
                           const WEDGEATTRD& ad)
{
    /*
     * note: may have abase==a -> not really const
     * dr == -d +2*(d.n)n
     * an = n + dr
     * optimized: a.normal=-d+((2.f)*dot(d,n)+1.f)*n;
     */

    register float vdot = ad[0]*abase.n.x + ad[1]*abase.n.y + ad[2]*abase.n.z;
    register float vdot2p1 = vdot * 2.0f + 1.0f;

    m_glmesh.m_narray[a].x = -ad[0] + vdot2p1*abase.n.x;
    m_glmesh.m_narray[a].y = -ad[1] + vdot2p1*abase.n.y;
    m_glmesh.m_narray[a].z = -ad[2] + vdot2p1*abase.n.z;

    m_glmesh.m_tarray[a].s = abase.t.s - ad[3];
    m_glmesh.m_tarray[a].t = abase.t.t - ad[4];
}


void CPMeshGL::sub_noreflect(WORD a, WORD abase, const WEDGEATTRD& ad)
{
    m_glmesh.m_narray[a].x = m_glmesh.m_narray[abase].x - ad[0];
    m_glmesh.m_narray[a].y = m_glmesh.m_narray[abase].y - ad[1];
    m_glmesh.m_narray[a].z = m_glmesh.m_narray[abase].z - ad[2];

    m_glmesh.m_tarray[a].s = m_glmesh.m_tarray[abase].s - ad[3];
    m_glmesh.m_tarray[a].t = m_glmesh.m_tarray[abase].t - ad[4];
}


void interp(GLwedgeAttrib& a, const GLwedgeAttrib& a1,
            const GLwedgeAttrib& a2, float f1, float f2)
{
    if (a1.n.x==a2.n.x && a1.n.y==a2.n.y && a1.n.z==a2.n.z)
    {
        a.n = a1.n;
    }
    else
    {
        a.n.x = f1*a1.n.x + f2*a2.n.x;
        a.n.y = f1*a1.n.y + f2*a2.n.y;
        a.n.z = f1*a1.n.z + f2*a2.n.z;
        float denom = (float) sqrt ((double)(a.n.x*a.n.x + a.n.y*a.n.y + 
                                             a.n.z*a.n.z));
        if (denom!=0) 
        {
            a.n.x/=denom;
            a.n.y/=denom;
            a.n.z/=denom;
        }
    }
    a.t.s = f1*a1.t.s + f2*a2.t.s;
    a.t.t = f1*a1.t.t + f2*a2.t.t;
}

void CPMeshGL::gather_vf_jw (WORD v, WORD f, int& j, WORD& w) const
{
    j = get_jvf (v,f);
    w = (m_glmesh.m_farray[f]).w[j];
}

void CPMeshGL::gather_vf_j0j2pw(WORD v, WORD f, int& j0, int& j2, WORD*& pw)
{
    j0 = get_jvf (v,f);
    pw = &(m_glmesh.m_farray[f]).w[j0];
    j2 = (j0 + 2) % 3;
}

void CPMeshGL::gather_vf_j2w(WORD v, WORD f, int& j2, WORD& w) const
{
    WORD j = get_jvf (v,f);
    w = (m_glmesh.m_farray[f]).w[j];
    j2 = (j + 2) % 3;
}

void CPMeshGL::gather_vf_j1w (WORD v, WORD f, int& j1, WORD& w) const
{
    WORD j = get_jvf(v,f);
    w = (m_glmesh.m_farray[f]).w[j];
    j1 = (j + 1) % 3;
}

void CPMeshGL::gather_vf_jpw(WORD v, WORD f, int& j, WORD*& pw)
{
    j = get_jvf(v,f);
    pw = &(m_glmesh.m_farray[f]).w[j];
}

WORD CPMeshGL::MatidOfFace(WORD f)
{
    //Binary search helps if there are a lot of materials
    for (WORD i=1; i<m_maxMaterials; ++i)
        if (f < m_glmesh.m_matpos[i])
            return i-1;
    return m_maxMaterials-1;
    
    //throw CBadFace();
    //return 0; // never
}


//  note: vspl is modified!
void CPMeshGL::apply_vsplit(Vsplit& vspl)
{
    const BOOL isl = TRUE; 
    BOOL isr = vspl.vlr_offset1 > 1;
    HRESULT hr;
    
    /*
     * Get vertices, faces, and wedges in the neigbhorhood of the split.
     * Look at the diagram in mesh.vld for more information about the 
     * meanings of various variables.
     */

    WORD vs;
    WORD code=vspl.code;
    int ii=(code&Vsplit::II_MASK)>>Vsplit::II_SHIFT;
    WORD flccw, flclw;           // either (not both) may be UNDEF
    WORD frccw, frclw;           // either (or both) may be UNDEF
    WORD wlccw, wlclw, wrccw, wrclw; // ==UNDEF if faces do not exist
    int jlccw, jlclw, jrccw, jrclw;  // only defined if faces exist
    int jlclw2;
    WORD flmatid, frmatid;
    GLvertex glvs, glvt;             // vertices vs and vt
    PArray<WORD*,10> ar_pwedges;
    LPGLface farray = m_glmesh.m_farray;
    LPGLvertex varray = m_glmesh.m_varray;
    LPGLnormal narray = m_glmesh.m_narray;
    LPGLtexCoord tarray = m_glmesh.m_tarray;
    WORD (*fnei)[3] = m_glmesh.m_fnei;    
    WORD* wedgelist = m_glmesh.m_wedgelist;    
    WORD* matcnt = m_glmesh.m_matcnt;    
    WORD* matpos = m_glmesh.m_matpos;    
    WORD* facemap = m_glmesh.m_facemap;    

    /* 
     * 1) Gather all the wedges surrounding Vs into ar_pwedges array
     * -------------------------------------------------------------
     */

    if (vspl.vlr_offset1 == 0) 
    {
        /* 
         * Extremely rare case when flclw does not exist.
         */
        flclw = UNDEF;
        wlclw = UNDEF;
        if (vspl.modified)
        {
            flccw = vspl.flclw;
        }
        else
        {
            flccw = WORD(facemap[WORD(vspl.flclw)]);
            vspl.flclw = flccw;
            vspl.modified = TRUE;
        }
        
        int vs_index = (code & Vsplit::VSINDEX_MASK)>>Vsplit::VSINDEX_SHIFT;
        jlccw = vs_index;
        wlccw = farray[flccw].w[jlccw];
        vs = m_glmesh.FindVertexIndex(wlccw);
        frccw = frclw = wrccw = wrclw = UNDEF;
    } 
    else 
    {
        if (vspl.modified)
        {
            flclw = vspl.flclw;
        }
        else
        {
            flclw = WORD(facemap[WORD(vspl.flclw)]);
            vspl.flclw = flclw;
            vspl.modified = TRUE;
        }
        
        //flclw = WORD(facemap[WORD(vspl.flclw)]);
        int vs_index = (code&Vsplit::VSINDEX_MASK)>>Vsplit::VSINDEX_SHIFT;
        
        jlclw = vs_index;       //The vs's index
        jlclw2 = (jlclw + 2)%3; //The vl's index

        WORD* pwlclw = &(farray[flclw].w[jlclw]);
        wlclw = *pwlclw;
        vs = m_glmesh.FindVertexIndex (wlclw);
        flccw = fnei[flclw][(jlclw+1)%3];
        if (flccw == UNDEF) 
        {
            wlccw = UNDEF;
        } 
        else 
        {
            gather_vf_jw(vs, flccw, jlccw, wlccw);
        }

        if (!isr) 
        {
            frccw = frclw = wrccw = wrclw = UNDEF;
            ar_pwedges += pwlclw;

            /*
             *  Rotate around and record all wedges CLW from wlclw.
             */
            int j0 = jlclw, j2 = jlclw2;
            WORD f = flclw;
            for (;;) 
            {
                f = fnei[f][j2];
                if (f == UNDEF) break;
                WORD* pw;
                gather_vf_j0j2pw (vs, f, j0, j2, pw);
                ar_pwedges += pw;
            }
        } 
        else 
        {
            ar_pwedges.init (vspl.vlr_offset1 - 1);
            ar_pwedges[0] = pwlclw;

            /* 
             * Rotate around the first vlr_offset-1 faces.
             */
            int j0 = jlclw, j2 = jlclw2;
            WORD f = flclw;
            for(int count=0; count < vspl.vlr_offset1-2; ++count) 
            {
                f = fnei[f][j2];
                WORD* pw;
                gather_vf_j0j2pw (vs, f, j0, j2, pw);
                ar_pwedges[count+1] = pw;
            }
            frccw=f;

            /* 
             * On the last face, find adjacent faces.
             */
            jrccw = j0;
            wrccw = farray[frccw].w[jrccw];
            frclw = fnei[frccw][j2];
            if (frclw==UNDEF) 
            {
                wrclw=UNDEF;
            } 
            else 
            {
                gather_vf_jw(vs,frclw,jrclw,wrclw);
            }
        }
    }


    /*
     * 2) Obtain the matIDs of the two new faces generated by applying vsplit.
     * -----------------------------------------------------------------------
     *    ?? could use L_MASK instead of ii for prediction instead.
     *    face_prediction() is the shady part.
     */

    if (code & Vsplit::FLN_MASK)
    {
        flmatid = vspl.fl_matid;
    }
    else
    {
        flmatid = MatidOfFace(face_prediction(flclw,flccw,ii));
        // save computed value for undo_vsplit and future vsplits
        vspl.fl_matid = flmatid;
        vspl.code |= Vsplit::FLN_MASK;
    }

    if (isr)
    {
        if (code&Vsplit::FRN_MASK)
            frmatid = vspl.fr_matid;
        else
        {
            frmatid = MatidOfFace(face_prediction(frccw,frclw,ii));
            // save computed value for undo_vsplit and future vsplits
            vspl.fr_matid = frmatid;
            vspl.code|=Vsplit::FRN_MASK;
        }
    }

    /*
     * 3) Compute new coordinates of vt and vs (calc coordinates).
     * -----------------------------------------------------------
     */
    
    switch (ii) 
    {
    case 2:
        glvt.x = varray[vs].x + vspl.vad_large[0];
        glvt.y = varray[vs].y + vspl.vad_large[1];
        glvt.z = varray[vs].z + vspl.vad_large[2];

        glvs.x = varray[vs].x + vspl.vad_small[0];
        glvs.y = varray[vs].y + vspl.vad_small[1];
        glvs.z = varray[vs].z + vspl.vad_small[2];
        break;
    case 0:
        glvt.x = varray[vs].x + vspl.vad_small[0];
        glvt.y = varray[vs].y + vspl.vad_small[1];
        glvt.z = varray[vs].z + vspl.vad_small[2];

        glvs.x = varray[vs].x + vspl.vad_large[0];
        glvs.y = varray[vs].y + vspl.vad_large[1];
        glvs.z = varray[vs].z + vspl.vad_large[2];
        break;
    case 1:
        glvt.x = varray[vs].x + vspl.vad_small[0];
        glvt.y = varray[vs].y + vspl.vad_small[1];
        glvt.z = varray[vs].z + vspl.vad_small[2];

        glvs.x = glvt.x - vspl.vad_large[0];
        glvs.y = glvt.y - vspl.vad_large[1];
        glvs.z = glvt.z - vspl.vad_large[2];

        glvt.x = glvt.x + vspl.vad_large[0];
        glvt.y = glvt.y + vspl.vad_large[1];
        glvt.z = glvt.z + vspl.vad_large[2];
        break;
    default:
        throw CBadVsplitCode();
    }
    
    /*
     * 4) un-share wedges around vt (?) Add 2 wedges around Vs 
     * -------------------------------------------------------
     *  (may be gap on top). may modify wlclw and wrccw!
     */

    WORD wnl = UNDEF, wnr = UNDEF;
    int iil = 0, iir = ar_pwedges.num()-1;
    if (isl && (wlclw == wlccw)) 
    {  
        /*
         * first go clw. Add new wedge.
         */

        wnl = m_glmesh.m_numWedges++;

        /*
         * Add wnl to the list of wedges sharing Vs
         */
        wedgelist[wnl] = wedgelist[vs];
        wedgelist[vs] = wnl;

        /* 
         * Copy wedge attributes
         */
        narray[wnl] = narray[wlccw];
        tarray[wnl] = tarray[wlccw];
        wlclw = wnl;              // has been changed

        for (;;) 
        {
            *ar_pwedges[iil] = wnl;
            iil++;
            if (iil > iir) 
            {
                wrccw = wnl;      // has been changed
                break;
            }
            if (*ar_pwedges[iil] != wlccw) 
                break;
        }
    }

    if (isr && (wrccw == wrclw)) 
    {  
        /*
         * now go ccw from other side.
         */

        if ((wrclw == wlccw) && (wnl != UNDEF)) 
        {
            wnr = wnl;
        } 
        else 
        {
            // Add new wedge
            wnr = m_glmesh.m_numWedges++;

            // Add wnr to the list of wedges sharing vs
            wedgelist[wnr] = wedgelist[vs];
            wedgelist[vs] = wnr;
            
            // Copy wedge attributes
            narray[wnr] = narray[wrclw];
            tarray[wnr] = tarray[wrclw];
        }
        wrccw=wnr;              // has been changed

        for (;;) 
        {
            *ar_pwedges[iir] = wnr;
            iir--;
            if (iir < iil) 
            {
                if (iir < 0) wlclw=wnr; // has been changed
                break;
            }
            if (*ar_pwedges[iir] != wrclw) 
                break;
        }
    }

    /*
     * 5) Add other new wedges around Vt and record wedge ancestries
     * -------------------------------------------------------------
     */

    WORD wvtfl, wvtfr, vt = UNDEF;
    if (!isr) 
    {
        wvtfr=UNDEF;
        switch (code&Vsplit::T_MASK) 
        {
        case Vsplit::T_LSAME|Vsplit::T_RSAME:
            wvtfl=wlclw;
            break;
        case Vsplit::T_RSAME:
            // Add new wedge.
            wvtfl = m_glmesh.m_numWedges++;
            wedgelist[wvtfl] = wvtfl;
            varray[wvtfl] = glvt;
            vt = wvtfl;
            break;
        default:
            throw CBadVsplitCode();
        }
    } 
    else 
    {
        switch (code&Vsplit::T_MASK) 
        {
        case Vsplit::T_LSAME|Vsplit::T_RSAME|Vsplit::T_CSAME:
        case Vsplit::T_LSAME|Vsplit::T_RSAME:
            wvtfl=wlclw;
            wvtfr=wrccw;
            break;
        case Vsplit::T_LSAME|Vsplit::T_CSAME:
            wvtfl=wlclw;
            wvtfr=wvtfl;
            break;
        case Vsplit::T_RSAME|Vsplit::T_CSAME:
            wvtfl=wrccw;
            wvtfr=wvtfl;
            break;
        case Vsplit::T_LSAME:
            wvtfl=wlclw;
            // Add new wedge.
            wvtfr = m_glmesh.m_numWedges++;
            wedgelist[wvtfr] = wvtfr;
            varray[wvtfr] = glvt;
            vt = wvtfr;
            break;
        case Vsplit::T_RSAME:
            // Add new wedge.
            wvtfl = m_glmesh.m_numWedges++;
            wedgelist[wvtfl] = wvtfl;
            varray[wvtfl] = glvt;
            vt = wvtfl;
            wvtfr=wrccw;
            break;
        case Vsplit::T_CSAME:
            // Add new wedge.
            wvtfl = m_glmesh.m_numWedges++;
            wedgelist[wvtfl] = wvtfl;
            varray[wvtfl] = glvt;
            vt = wvtfl;
            wvtfr=wvtfl;
            break;
        case 0:
            // Add new wedge.
            wvtfl = m_glmesh.m_numWedges++;
            varray[wvtfl] = glvt;
            vt = wvtfl;

            // Add new wedge.
            wvtfr = m_glmesh.m_numWedges++;
            varray[wvtfr] = glvt;

            // Add wvtfr and wvtfl to list of wedges sharing vt
            wedgelist[wvtfl] = wvtfr;
            wedgelist[wvtfr] = wvtfl;
            break;
        default:
            throw CBadVsplitCode();
        }
    }

    /*
     * 6) Add other new wedges around Vs.
     * ----------------------------------
     * Do we really need to find vertex index ? Optimize
     */

    WORD wvsfl, wvsfr;
    if (!isr) 
    {
        wvsfr = UNDEF;
        switch (code&Vsplit::S_MASK) 
        {
        case Vsplit::S_LSAME|Vsplit::S_RSAME:
            wvsfl=wlccw;
            break;
        case Vsplit::S_RSAME:
            // Add new wedge.
            wvsfl = m_glmesh.m_numWedges++;
            varray[wvsfl] = glvs;

            // Add wvsfl to the list wedges sharing vs
            wedgelist[wvsfl] = wedgelist[vs];
            wedgelist[vs] = wvsfl;
            break;
        default:
            throw CBadVsplitCode();
        }
    } 
    else 
    {
        switch (code&Vsplit::S_MASK) 
        {
        case Vsplit::S_LSAME|Vsplit::S_RSAME|Vsplit::S_CSAME:
        case Vsplit::S_LSAME|Vsplit::S_RSAME:
            wvsfl=wlccw;
            wvsfr=wrclw;
            break;
        case Vsplit::S_LSAME|Vsplit::S_CSAME:
            wvsfl=wlccw;
            wvsfr=wvsfl;
            break;
        case Vsplit::S_RSAME|Vsplit::S_CSAME:
            wvsfl=wrclw;
            wvsfr=wvsfl;
            break;
        case Vsplit::S_LSAME:
            wvsfl=wlccw;
            // Add new wedge.
            wvsfr = m_glmesh.m_numWedges++;
            wedgelist[wvsfr] = wedgelist[vs];
            wedgelist[vs] = wvsfr;
            varray[wvsfr] = glvs;
            break;
        case Vsplit::S_RSAME:
            // Add new wedge.
            wvsfl = m_glmesh.m_numWedges++;
            wedgelist[wvsfl] = wedgelist[vs];
            wedgelist[vs] = wvsfl;
            varray[wvsfl] = glvs;
            wvsfr=wrclw;
            break;
        case Vsplit::S_CSAME:
            // Add new wedge.
            wvsfl = m_glmesh.m_numWedges++;
            wedgelist[wvsfl] = wedgelist[vs];
            wedgelist[vs] = wvsfl;
            varray[wvsfl] = glvs;
            wvsfr = wvsfl;
            break;
        case 0:
            // Add new wedge.
            wvsfl = m_glmesh.m_numWedges++;
            varray[wvsfl] = glvs;

            // Add new wedge.
            wvsfr = m_glmesh.m_numWedges++;
            varray[wvsfr] = glvs;

            // Add wvsfr and wvsfl to list of wedges sharing vt
            wedgelist[wvsfl] = wedgelist[vs];
            wedgelist[wvsfr] =wvsfl;
            wedgelist[vs] = wvsfr;
            break;
        default:
            throw CBadVsplitCode();
        }
    }

    /*
     * 7) Add outside wedges wvlfl and wvrfr
     * -------------------------------------
     */

    WORD wvlfl, wvrfr;
    if (isl) 
    {
        switch (code&Vsplit::L_MASK) 
        {
        case Vsplit::L_ABOVE:
            wvlfl = farray[flclw].w[jlclw2];
            break;
        case Vsplit::L_BELOW:
            wvlfl = farray[flccw].w[(jlccw+1)%3];
            break;
        case Vsplit::L_NEW:
        {
            wvlfl = m_glmesh.m_numWedges++;

            WORD vl = (flclw != UNDEF) ? farray[flclw].w[jlclw2] :
                                         farray[flccw].w[(jlccw+1)%3];
            wedgelist[wvlfl] = wedgelist[vl];
            wedgelist[vl] = wvlfl;

            varray[wvlfl] = varray[vl];
        }
        break;
        default:
            throw CBadVsplitCode();
        }
    }

    if (!isr) 
    {
        wvrfr = UNDEF;
    } 
    else 
    {
        switch (code&Vsplit::R_MASK) 
        {
        case Vsplit::R_ABOVE:
            wvrfr = farray[frccw].w[(jrccw+1)%3];
            break;
        case Vsplit::R_BELOW:
            wvrfr = farray[frclw].w[(jrclw+2)%3];
            break;
        case Vsplit::R_NEW:
        {
            wvrfr = m_glmesh.m_numWedges++;
            WORD vr = farray[frccw].w[(jrccw+1)%3];

            wedgelist[wvrfr] = wedgelist[vr];
            wedgelist[vr] = wvrfr;

            varray[wvrfr] = varray[vr];
        }
        break;
        default:
            throw CBadVsplitCode();
        }
    }

    /*
     * 8) Add 1 or 2 faces, and update adjacency information.
     * ------------------------------------------------------
     */

    WORD fl, fr;
    matcnt [flmatid]++;
    fl = matpos[flmatid] + matcnt[flmatid] - 1;
    facemap [m_glmesh.m_numFaces] = fl;
    
    if (isr) 
    {
        matcnt [frmatid]++;
        fr = matpos[frmatid] + matcnt[frmatid] - 1;
        facemap [m_glmesh.m_numFaces+1] = fr;
        m_glmesh.m_numFaces += 2;
    }
    else 
    {
        fr = UNDEF;
        m_glmesh.m_numFaces ++;
    }

    if (isl) 
    {
        farray[fl].w[0] = wvsfl;
        farray[fl].w[1] = wvtfl;
        farray[fl].w[2] = wvlfl;

        if (flccw != UNDEF) fnei[flccw][(jlccw+2)%3] = fl;
        if (flclw != UNDEF) fnei[flclw][(jlclw+1)%3] = fl;

        fnei[fl][0] = flclw;
        fnei[fl][1] = flccw;
        fnei[fl][2] = fr;
    }

    if (isr) 
    {
        farray[fr].w[0] = wvsfr;
        farray[fr].w[1] = wvrfr;
        farray[fr].w[2] = wvtfr;

        if (frccw != UNDEF) fnei[frccw][(jrccw+2)%3] = fr;
        if (frclw != UNDEF) fnei[frclw][(jrclw+1)%3] = fr;

        fnei[fr][0] = frccw;
        fnei[fr][1] = fl;
        fnei[fr][2] = frclw;
    }

    /*
     * 9) Update wedge vertices.
     * -------------------------
     */

    if (wnl != UNDEF)
    {
        WedgeListDelete(wnl);
        varray[wnl] = glvt;

        if (vt == UNDEF)
        {
            wedgelist[wnl] = wnl;
            vt = wnl;
        }
        else
        {
            wedgelist[wnl] = wedgelist[vt];
            wedgelist[vt] = wnl;
        }
    }

    if (wnr != UNDEF)
    {
        WedgeListDelete(wnr);
        varray[wnr] = glvt;

        if (vt==UNDEF)
        {
            wedgelist[wnr] = wnr;
            vt = wnr;
        }
        else
        {
            wedgelist[wnr] = wedgelist[vt];
            wedgelist[vt] = wnr;
        }
    }

    WORD prev = UNDEF;
    for (; iil <= iir; iil++) 
    {
        WORD w = *ar_pwedges[iil];
        if (w != prev)
        {
            WedgeListDelete(w);
            varray[w] = glvt;
            if (vt==UNDEF)
            {
                wedgelist[w] = w;
                vt = w;
            }
            else
            {
                wedgelist[w] = wedgelist[vt];
                wedgelist[vt] = w;
            }
        }
        prev = w;
    }

    /*
     * 10) Update all wedges sharing Vs to it's new coordinates.
     * ---------------------------------------------------------
     * Note the prev loop in ar_pwedges could have modified wedge pointed by 
     * vs to be part of vt now.
     * wvsfl is the only sure way of a wedge pointing to vs
     */

    WORD p = wvsfl;
    do
    {
        varray[p] = glvs;
        p = wedgelist[p];
    }
    while (p != wvsfl);

    /*
     * 11) Update wedge attributes.
     * ----------------------------
     */

    GLwedgeAttrib  awvtfr, awvsfr;
    if (isr) 
    {
        // backup for isr
        //awvtfrV = varray[wvtfr]; 
        awvtfr.n = narray[wvtfr]; 
        awvtfr.t = tarray[wvtfr]; 

        // backup for isr
        //awvsfrV = varray[wvsfr]; 
        awvsfr.n = narray[wvsfr]; 
        awvsfr.t = tarray[wvsfr]; 
    }

    int lnum = 0;
    if (isl) 
    {
        int nt = !(code&Vsplit::T_LSAME);
        int ns = !(code&Vsplit::S_LSAME);
        if (nt && ns) 
        {
            add_zero(wvtfl, vspl.ar_wad[lnum++]);
            add_zero(wvsfl, vspl.ar_wad[lnum++]);
        } 
        else 
        {
            switch (ii) 
            {
            case 2:
            {
                GLwedgeAttrib wa;
                if (ns)
                {
                    narray[wvsfl] = narray[wvtfl];
                    tarray[wvsfl] = tarray[wvtfl];
                }
                if (!ns) {wa.n = narray[wvsfl]; wa.t = tarray[wvsfl];}
                else {wa.n = narray[wvtfl]; wa.t = tarray[wvtfl];}       
                add(wvtfl, wa, vspl.ar_wad[lnum++]);
                break;
            }
            case 0:
            {
                GLwedgeAttrib wa;
                if (nt)
                {
                    narray[wvtfl] = narray[wvsfl];
                    tarray[wvtfl] = tarray[wvsfl];
                }
                if (!nt) {wa.n = narray[wvtfl]; wa.t = tarray[wvtfl];}
                else {wa.n = narray[wvsfl]; wa.t = tarray[wvsfl];}       
                add(wvsfl, wa, vspl.ar_wad[lnum++]);
                break;
            }
            case 1:
            {
                const WEDGEATTRD& wad = vspl.ar_wad[lnum];
                if (!ns) 
                {
                    GLwedgeAttrib wabase;
                    wabase.n = narray[wvsfl];
                    wabase.t = tarray[wvsfl];
                    add(wvtfl, wabase, wad);
                    sub_reflect(wvsfl, wabase, wad);
                } 
                else 
                {
                    GLwedgeAttrib wabase;
                    wabase.n = narray[wvtfl];
                    wabase.t = tarray[wvtfl];
                    sub_reflect(wvsfl, wabase, wad);
                    add(wvtfl, wabase, wad);
                }
                lnum++;
            }
                break;
            default:
                throw CBadVsplitCode();
            }
        }
    }

    if (isr) 
    {
        int nt = !(code&Vsplit::T_RSAME);
        int ns = !(code&Vsplit::S_RSAME);
        int ut = !(code&Vsplit::T_CSAME);
        int us = !(code&Vsplit::S_CSAME);
        if (nt && ns) 
        {
            if (ut)
                add_zero(wvtfr, vspl.ar_wad[lnum++]);
            if (us)
                add_zero(wvsfr, vspl.ar_wad[lnum++]);
        } 
        else 
        {
            switch (ii) 
            {
            case 2:
                if (us && ns)
                {
                    narray[wvsfr] = awvtfr.n;
                    tarray[wvsfr] = awvtfr.t;
                }
                if (ut)
                    add(wvtfr, (!ns?awvsfr:awvtfr), vspl.ar_wad[lnum++]);
                break;
            case 0:
                if (ut && nt)
                {
                    narray[wvtfr] = awvsfr.n;
                    tarray[wvtfr] = awvsfr.t;
                }
                if (us)
                    add(wvsfr, (!nt?awvtfr:awvsfr), vspl.ar_wad[lnum++]);
                break;
            case 1:
            {
                const WEDGEATTRD& wad = vspl.ar_wad[lnum];
                if (!ns) 
                {
                    const GLwedgeAttrib& wabase = awvsfr;
                    if (ut)
                        add(wvtfr, wabase, wad);
                    if (us)
                        sub_reflect(wvsfr, wabase, wad);
                } 
                else 
                {
                    const GLwedgeAttrib& wabase=awvtfr;
                    if (us)
                        sub_reflect(wvsfr, wabase, wad);
                    if (ut)
                        add(wvtfr, wabase, wad);
                }
                if (ut || us)
                    lnum++;
            }
                break;
            default:
                throw CBadVsplitCode();
            }
        }
    }
    if (code&Vsplit::L_NEW) 
    {
        add_zero(wvlfl, vspl.ar_wad[lnum++]);
    }
    if (code&Vsplit::R_NEW)
    {
        add_zero(wvrfr, vspl.ar_wad[lnum++]);
    }
}


void CPMeshGL::undo_vsplit(const Vsplit& vspl)
{
    unsigned int code=vspl.code;
    int ii=(code&Vsplit::II_MASK)>>Vsplit::II_SHIFT;
    const int isl=1; int isr;
    WORD fl, fr;
    LPGLface farray = m_glmesh.m_farray;
    LPGLvertex varray = m_glmesh.m_varray;
    LPGLnormal narray = m_glmesh.m_narray;
    LPGLtexCoord tarray = m_glmesh.m_tarray;
    WORD (*fnei)[3] = m_glmesh.m_fnei;    
    WORD* wedgelist = m_glmesh.m_wedgelist;    
    WORD* matcnt = m_glmesh.m_matcnt;    
    WORD* matpos = m_glmesh.m_matpos;    
    WORD* facemap = m_glmesh.m_facemap;    
    GLvertex glvs, glvt;
    
    /*
     * 1) Remove the faces
     * -------------------
     */

    if (vspl.vlr_offset1 > 1) 
    {
        WORD frmid = vspl.fr_matid, flmid = vspl.fl_matid;
      
        isr = 1;
        
        // remove fr
        matcnt[frmid]--;
        fr = matpos[frmid] + matcnt[frmid]; 

        // remove fl
        matcnt[flmid]--;
        fl = matpos[flmid] + matcnt[flmid]; 

        m_glmesh.m_numFaces -= 2;
    } 
    else 
    {
        WORD frmid = vspl.fr_matid, flmid = vspl.fl_matid;

        isr = 0;

        // remove fl
        matcnt[flmid]--;
        fl = matpos[flmid] + matcnt[flmid]; 
        fr = UNDEF;
        --m_glmesh.m_numFaces;
    }

    /*
     * 2) Get wedges in neighborhood.
     * ------------------------------
     */

    WORD wvsfl, wvtfl, wvlfl;
    WORD wvsfr, wvtfr, wvrfr;

    wvsfl = farray[fl].w[0];
    wvtfl = farray[fl].w[1];
    wvlfl = farray[fl].w[2];

    if (!isr) 
    {
        wvsfr=UNDEF; 
        wvtfr=UNDEF; 
        wvrfr=UNDEF;
    } 
    else 
    {
        wvsfr = farray[fr].w[0];
        wvtfr = farray[fr].w[2];
        wvrfr = farray[fr].w[1];
    }

    /*
     * 3) Obtain the vertices Vs and Vt and save them.
     * -----------------------------------------------
     */

    WORD vs = m_glmesh.FindVertexIndex (wvsfl);
    WORD vt = m_glmesh.FindVertexIndex (wvtfl);

    glvt.x = varray[vt].x;
    glvt.y = varray[vt].y;
    glvt.z = varray[vt].z;

    /* 
     * 4) Get adjacent faces and wedges on left and right.
     * ---------------------------------------------------
     * (really needed??)
     */

    WORD flccw, flclw;           // either (not both) may be UNDEF
    WORD frccw, frclw;           // either (or both) may be UNDEF

    /*
     * Also find index of vs within those adjacent faces
     */
    int jlccw2, jlclw0, jlclw2, jrccw, jrclw1; // only defined if faces exist
    WORD* pwlclw;
    WORD wlccw, wlclw, wrccw, wrclw; // UNDEF if faces does not exist

    /* 
     * Left side
     */

    if (isl) 
    {
        flccw = fnei[fl][1];
        flclw = fnei[fl][0];

        if (flccw == UNDEF) 
        {
            wlccw=UNDEF;
        } 
        else 
        {
            gather_vf_j2w (vs, flccw, jlccw2, wlccw);
        }

        if (flclw==UNDEF) 
        {
            wlclw = UNDEF;
        } 
        else 
        {
            gather_vf_j0j2pw (vt, flclw, jlclw0, jlclw2, pwlclw);
            wlclw = *pwlclw;
        }
    }

    /* 
     * Right side
     */

    if (!isr) 
    {
        frccw = frclw = wrccw = wrclw = UNDEF;
    } 
    else 
    {
        frccw = fnei[fr][0];
        frclw = fnei[fr][2];

        if (frccw == UNDEF) 
        {
            wrccw = UNDEF;
        } 
        else 
        {
            gather_vf_jw(vt, frccw, jrccw, wrccw);
        }

        if (frclw == UNDEF) 
        {
            wrclw = UNDEF;
        } 
        else 
        {
            gather_vf_j1w (vs, frclw, jrclw1, wrclw);
        }
    }

    int thru_l = ((wlccw == wvsfl) && (wlclw == wvtfl));
    int thru_r = ((wrclw == wvsfr) && (wrccw == wvtfr));

    /*
     * 5) Update adjacency information.
     * --------------------------------
     */

    if (flccw != UNDEF) fnei[flccw][jlccw2] = flclw;
    if (flclw != UNDEF) fnei[flclw][(jlclw0+1)%3] = flccw;
    if (frccw != UNDEF) fnei[frccw][(jrccw+2)%3] = frclw;
    if (frclw != UNDEF) fnei[frclw][jrclw1] = frccw;

    /*
     * 6) Propagate wedges id's across collapsed faces if can go thru.
     * ---------------------------------------------------------------
     */

    WORD ffl = flclw, ffr = frccw;
    int jjl0 = jlclw0, jjl2 = jlclw2, jjr = jrccw;
    WORD* pwwl=pwlclw;
    
    /*
     * first go clw
     */
    if (thru_l) 
    {            
        for (;;) 
        {
            *pwwl = wlccw;
            if (ffl == ffr) 
            {
                ffl = ffr = UNDEF;  // all wedges seen
                break;
            }
            ffl = fnei[ffl][jjl2];
            if (ffl == UNDEF) break;
            gather_vf_j0j2pw(vt, ffl, jjl0, jjl2, pwwl);
            if (*pwwl != wlclw) break;
        }
    }

    /*
     * now go ccw from other side
     */
    if ((ffr != UNDEF) && thru_r) 
    {     
        WORD* pw = &(farray[ffr].w[jjr]);
        for (;;) 
        {
            *pw = wrclw;
            if (ffr == ffl) 
            {
                ffl = ffr = UNDEF;  // all wedges seen
                break;
            }
            ffr = fnei[ffr][(jjr+1)%3];
            if (ffr == UNDEF) break;
            gather_vf_jpw (vt, ffr, jjr, pw);
            if (*pw != wrccw) break;
        }
    }

    /*
     * 7) Identify those wedges that will need to be updated to vs.
     * ------------------------------------------------------------
     * (wmodif may contain some duplicates)
     */

    PArray<WORD,10> ar_wmodif;
    if (ffl!=UNDEF) 
    {
        for (;;) 
        {
            int w = *pwwl;
            ar_wmodif += w;
            if (ffl == ffr) 
            { 
                ffl = ffr = UNDEF; 
                break; 
            }

            ffl = fnei[ffl][jjl2];
            if (ffl == UNDEF) break;
            gather_vf_j0j2pw (vt, ffl, jjl0, jjl2, pwwl);
        }
    }

    /*
     * 8) Update wedge vertices to vs.
     * -------------------------------
     */

    for (int i=0; i<ar_wmodif.num(); ++i)
    {
        // _wedges[w].vertex=vs;
        WORD w = ar_wmodif[i];
        WedgeListDelete(w);
        varray[w] = varray[vs];
        wedgelist[w] = wedgelist[vs];
        wedgelist[vs] = w;
    }

    /*
     * 9) Update vertex attributes.
     * ----------------------------
     */

    float vsx, vsy, vsz;
    switch (ii) 
    {
    case 2:
        glvs.x = varray[vs].x - vspl.vad_small[0];
        glvs.y = varray[vs].y - vspl.vad_small[1];
        glvs.z = varray[vs].z - vspl.vad_small[2];
        break;
    case 0:
        glvs.x = glvt.x - vspl.vad_small[0];
        glvs.y = glvt.y - vspl.vad_small[1];
        glvs.z = glvt.z - vspl.vad_small[2];
        break;
    case 1:
        glvs.x = glvt.x - vspl.vad_large[0] - vspl.vad_small[0];
        glvs.y = glvt.y - vspl.vad_large[1] - vspl.vad_small[1];
        glvs.z = glvt.z - vspl.vad_large[2] - vspl.vad_small[2];
        break;
    default:
        throw CBadVsplitCode();
    }

    /*
     * 10) update all wedges sharing vs with it's coordinates
     * ------------------------------------------------------
     */

    WORD p = vs;
    do
    {
        varray[p] = glvs;
        p = wedgelist[p];
    }
    while (p!=vs);

    /*
     * 11) Udpate wedge attributes. they are currently predicted exactly.
     * ------------------------------------------------------------------
     */

    GLwedgeAttrib awvtfr, awvsfr;
    //GLvertex awvtfrV, awvsfrV;

    if (isr) 
    {
      //awvtfrV = varray[wvtfr];
        awvtfr.n = narray[wvtfr];
        awvtfr.t = tarray[wvtfr];

        //awvsfrV = varray[wvsfr];
        awvsfr.n = narray[wvsfr];
        awvsfr.t = tarray[wvsfr];
    }

    int problem = 0;
    if (isl) 
    {
        int nt = !(code&Vsplit::T_LSAME);
        int ns = !(code&Vsplit::S_LSAME);
        if (nt && ns) 
        {
            problem = 1;
        } 
        else 
        {
            switch (ii) 
            {
            case 2:
                if (!thru_l)
                {
                    narray[wvtfl] = narray[wvsfl];
                    tarray[wvtfl] = tarray[wvsfl];
                }
                break;
            case 0:
                narray[wvsfl] = narray[wvtfl];
                tarray[wvsfl] = tarray[wvtfl];
                break;
            case 1:
                sub_noreflect (wvsfl, wvtfl, vspl.ar_wad[0]);
                if (!thru_l)
                {
                    narray[wvtfl] = narray[wvsfl];
                    tarray[wvtfl] = tarray[wvsfl];
                }
                break;
            default:
                throw CBadVsplitCode();
            }
        }
    }

    if (isr) 
    {
        int nt = !(code&Vsplit::T_RSAME);
        int ns = !(code&Vsplit::S_RSAME);
        int ut = !(code&Vsplit::T_CSAME);
        int us = !(code&Vsplit::S_CSAME);

        if (problem || us || ut) 
        {
            switch (ii) {
            case 2:
                /*
                 * If thru_r, then wvtfr & wrccw no longer exist.
                 * This may be duplicating some work already done for isl.
                 */
                if (!nt && !thru_r)
                {
                    narray[wvtfr] = awvsfr.n;
                    tarray[wvtfr] = awvsfr.t;
                }
                break;
            case 0:
                // This may be duplicating some work already done for isl.
                if (!ns)
                {
                    narray[wvsfr] = awvtfr.n;
                    tarray[wvsfr] = awvtfr.t;
                }
                break;
            case 1:
            {
                GLwedgeAttrib wa;
                interp(wa, awvsfr, awvtfr, 0.5f, 0.5f);
                if (!ns) 
                {
                    narray[wvsfr] = wa.n;
                    tarray[wvsfr] = wa.t;
                }
                if (!nt && !thru_r)
                {
                    narray[wvtfr] = wa.n;
                    tarray[wvtfr] = wa.t;
                }
            }
            break;
            default:
                throw CBadVsplitCode();
            }
        }
    }

    /*
     * 12) Remove wedges.
     * ------------------
     */

    if (isr && (code&Vsplit::R_NEW))
    {
        WORD w = --m_glmesh.m_numWedges; // wvrfr
        WedgeListDelete(w);
    }

    if (code&Vsplit::L_NEW)
    {
        WORD w = --m_glmesh.m_numWedges; // wvlfl
        WedgeListDelete(w);
    }

    if (isr && (!(code&Vsplit::S_CSAME) && !(code&Vsplit::S_RSAME)))
    {
        WORD w = --m_glmesh.m_numWedges; // wvsfr
        WedgeListDelete(w);
    }

    if ((!(code&Vsplit::S_LSAME) && (!(code&Vsplit::S_CSAME) || 
                                     !(code&Vsplit::S_RSAME))))
    {
        WORD w = --m_glmesh.m_numWedges; // wvsfl
        WedgeListDelete(w);
    }

    if (isr && (!(code&Vsplit::T_CSAME) && !(code&Vsplit::T_RSAME)))
    {
        WORD w = --m_glmesh.m_numWedges; // wvtfr
        WedgeListDelete(w);
    }

    if ((!(code&Vsplit::T_LSAME) && (!(code&Vsplit::T_CSAME) || 
                                     !(code&Vsplit::T_RSAME))))
    {
        WORD w = --m_glmesh.m_numWedges; // wvtfl
        WedgeListDelete(w);
    }

    int was_wnl = isl && (code&Vsplit::T_LSAME) && (code&Vsplit::S_LSAME);
    if (isr && (code&Vsplit::T_RSAME) && (code&Vsplit::S_RSAME) &&
        !(was_wnl && (code&Vsplit::T_CSAME)))
    {
        WORD w = --m_glmesh.m_numWedges; // wrccw
        WedgeListDelete(w);
    }

    if (was_wnl)
    {
        WORD w = --m_glmesh.m_numWedges; // wlclw
        WedgeListDelete(w);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\glstuff.cxx ===
#include "viewer.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "trackbal.h"

#define Z_DELTA 1.0
#define Y_DELTA 1.0
#define X_DELTA 1.0
/************************************************************************/
/******************* Function Prototypes ********************************/
/************************************************************************/
void Reshape (GLsizei, GLsizei);
void InitGL(void);
void DoGlStuff(void);
void spin(void);

void InitMatrix (void);
void InitLighting(int, int, GLfloat, BOOL, int, int, int, BOOL);
void InitTexture (void);
void InitDrawing(void);
static void SetViewing(GLsizei, GLsizei, BOOL);
void SetViewWrap(GLsizei, GLsizei);

void initlights(void);
void EnableLighting (void);
void DisableLighting (void);
void PrintStuff (void);
void SetDistance( void );
void Key_up (void);
void Key_down (void);

void Key_i (void);
void Key_x (void);
void Key_X (void);
void Key_y (void);
void Key_Y (void);
void Key_z (void);
void Key_Z (void);
/************************************************************************/
/******************* Globals ********************************************/
/************************************************************************/
static unsigned int    stipple[32] = {
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555,
  0xAAAAAAAA,
  0x55555555
};

GLfloat zTrans = 0.0;

/************************************************************************/
/******************* Code ***********************************************/
/************************************************************************/
void InitGL(void)
{
    /* Initialize the State */
    if (linesmooth_enable) 
    {
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_BLEND);
        glEnable(GL_LINE_SMOOTH);
    }
    if (polysmooth_enable) 
    {
        glClearColor(0.0F, 0.0F, 0.0F, 0.0F);
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
        glBlendFunc(sblendfunc, dblendfunc);
        glEnable(GL_BLEND);
        glEnable(GL_POLYGON_SMOOTH);
    }
    if (blend_enable) 
    {
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        glColor4f(1.0F, 1.0F, 1.0F, 0.5F);
        glBlendFunc(sblendfunc, dblendfunc);
        glEnable(GL_BLEND);
    } 
    else 
    {
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_FALSE);
        glColor3f(1.0F, 1.0F, 1.0F);
    }
    if (dither_enable) 
    {
        glEnable(GL_DITHER);
    } 
    else 
    {
        glDisable(GL_DITHER);
    }

    glPolygonMode(GL_FRONT, polymodefront);
    glPolygonMode(GL_BACK, polymodeback);

    if (linestipple_enable) 
    {
        glLineStipple(1, 0xf0f0);
        glEnable(GL_LINE_STIPPLE);
    }

    if (polystipple_enable) 
    {
        glPolygonStipple((const GLubyte *) stipple);
        glEnable(GL_POLYGON_STIPPLE);
    }
    glShadeModel(shade_model);
#if 1
    if (depth_mode) 
    {
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);
        glDepthMask(GL_TRUE);
    }
    else 
    {
        glDisable(GL_DEPTH_TEST);
        glDepthMask(GL_FALSE);
    }
#endif

    glCullFace(cull_face);
    if (cull_enable) 
        glEnable(GL_CULL_FACE);

    if (fog_enable) 
    {
        glFogf(GL_FOG_START, 0);
        glFogf(GL_FOG_END, 1);
        glFogf(GL_FOG_MODE, GL_LINEAR);
        glEnable(GL_FOG);
    }

    InitMatrix ();
    
    if (light_enable)
        InitLighting (numInfLights, numLocalLights, localviewmode, 
                      lighttwoside, cmenable, cmface, cmmode, blend_enable);
    glFrontFace(front_face);

    glDrawBuffer(GL_BACK);
    glClearColor ((GLfloat)0.0, (GLfloat)0.3, (GLfloat)0.5, (GLfloat)0.0);
    //glClearColor ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0);

    if (tex_enable)
        InitTexture ();

    InitDrawing();
    SetViewing(g_wi.wSize.cx, g_wi.wSize.cy, TRUE);
}


void SetViewWrap(GLsizei w, GLsizei h)
{
    if (!h) return;
    SetViewing( w, h, TRUE);
}

void SetViewing(GLsizei w, GLsizei h, BOOL resize)
{
    GLfloat l_zoom[3];


    if (resize)
    {
        g_wi.wSize.cx = (int) w;
        g_wi.wSize.cy = (int) h;

        g_wi.wCenter.x = (int) w/2;
        g_wi.wCenter.y = (int) h/2;
        
        g_s.aspect_ratio = g_wi.wSize.cx / g_wi.wSize.cy;
    }
    
    for (int i=0; i<3; i++)
        l_zoom[i] = (g_s.from[i] - g_s.to[i]) * g_s.zoom + g_s.to[i];

    glViewport(0, 0, g_wi.wSize.cx, g_wi.wSize.cy);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(g_s.fov, g_s.aspect_ratio,
                   g_s.hither, g_s.yon * g_s.zoom);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(l_zoom[0], l_zoom[1], l_zoom[2],
              g_s.to[0], g_s.to[1], g_s.to[2],
              g_s.up[0], g_s.up[1], g_s.up[2]);
}


void InitDrawing(void)
{
    initlights();
    if (light_enable) EnableLighting ();
    else DisableLighting();
    //glClearColor ((GLfloat)0.0, (GLfloat)0.3, (GLfloat)0.5, (GLfloat)0.0);
    glClearColor ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0);
    glColor3f(0.2, 0.5, 0.8); 
}


void CALLBACK InitMatrix (void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}


void CALLBACK InitTexture (void)
{
}

void PrintStuff (void)
{
}


static void ComputeLatestMVMatrix ()
{
    POINT  pt;
    static GLfloat del_x = 0.0, del_y = 0.0;
    float matRot[4][4];
    
    if (g_wi.rmouse_down)
    {
        if (GetCursorPos(&pt))
        {
            // Subtract current window center to convert to 
            // window coordinates.

            pt.x -= (g_wi.wPosition.x);
            pt.y -= (g_wi.wPosition.y);
            
            if (pt.x != (int)g_wi.rmouseX || pt.y != (int)g_wi.rmouseY)
            {
               del_x = (float) (X_DELTA * (pt.x - (int)g_wi.rmouseX) / 
                                (float) g_wi.wSize.cx);
               del_y = (float) (Y_DELTA * (pt.y - (int)g_wi.rmouseY) / 
                                (float) g_wi.wSize.cy);
            }

            g_s.trans[0] += del_x;
            g_s.trans[1] -= del_y;
        }
    }

    if (g_wi.lmouse_down)
    {
        // Convert to window coordinates.
      
        pt.x -= (g_wi.wPosition.x);
        pt.y -= (g_wi.wPosition.y);
            
        if (GetCursorPos(&pt))
        {
            if (pt.x != (int)g_wi.lmouseX || pt.y != (int)g_wi.lmouseY)
            {
                trackball(curquat,
                          2.0*(g_wi.lmouseX)/g_wi.wSize.cx-1.0,
                          2.0*(g_wi.lmouseY)/g_wi.wSize.cy-1.0,
                          2.0*(pt.x)/g_wi.wSize.cx-1.0,
                          2.0*(g_wi.wSize.cy-pt.y)/g_wi.wSize.cy-1.0);

            }
        }
    }

    glTranslatef (g_s.trans[0], g_s.trans[1], g_s.trans[2]);
    build_rotmatrix(matRot, curquat);
    glMultMatrixf(&(matRot[0][0]));

    //glRotatef(g_s.angle, (GLfloat)0.0, (GLfloat)1.0, (GLfloat)0.0); 
    //trackball_CalcRotMatrix( matRot );
    //glMultMatrixf( &(matRot[0][0]) );
    // This defines how far away we're looking from
    //glRotatef(g_s.angle, (GLfloat)1.0, (GLfloat)1.0, (GLfloat)1.0); 
}




void
DoGlStuff( void )
{
    HRESULT hr;
  
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    ComputeLatestMVMatrix ();
    
    if (!pm_ready)
    {
        if (filled_mode)
            auxSolidTeapot (1.0);
        if (edge_mode)
            auxWireTeapot (1.01);
    }
    else
    {
      hr = pPMeshGL->Render ();
      if (hr != S_OK)
          MessageBox (NULL, "Render failed", "Error", 
                      MB_OK);
    }

    glPopMatrix ();
    glFlush ();
    auxSwapBuffers();
    PrintStuff ();
}


void CALLBACK Reshape(GLsizei w, GLsizei h)
{
  //trackball_Resize( w, h );
  trackball (curquat, 0.0, 0.0, 0.0, 0.0);
  
#if 1
    glViewport(0, 0, (GLint)w, (GLint)h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1, 1, -1, 1, -1, 1000);
    //    glOrtho(-1, 1, -1, 1, -1, 1000);

#else
    if (!h) return;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
    glOrtho(-5.0, 5.0, -5.0*(GLfloat)h/(GLfloat)w,
        5.0*(GLfloat)h/(GLfloat)w, -5.0, 5.0);
    else
    glOrtho(-5.0*(GLfloat)w/(GLfloat)h,
        5.0*(GLfloat)w/(GLfloat)h, -5.0, 5.0, -5.0, 5.0);
#endif

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    g_wi.wSize.cx = (int) w;
    g_wi.wSize.cy = (int) h;
}

void spin(void)
{
    DoGlStuff();
}



void 
InitLighting(int infiniteLights, int localLights, 
             GLfloat localViewer, BOOL twoSidedLighting, 
             int cmenable, int cmface, int cmmode, BOOL blendOn)
{
    int i;
    GLfloat normFactor;

    /* Material settings */
    GLfloat materialAmbientColor[4] = {
        0.5F, 0.5F, 0.5F, 1.0F
    };

    GLfloat materialDiffuseColor[4] = {
        0.7F, 0.7F, 0.7F, 1.0F
    };

    GLfloat materialSpecularColor[4] = {
        1.0F, 1.0F, 1.0F, 1.0F
    };

    GLfloat materialShininess[1] = {
        128
    };

    /* Lighting settings */
    GLfloat lightPosition[8][4] = {
        {  1.0F,  1.0F,  1.0F, 1.0F },
        {  1.0F,  0.0F,  1.0F, 1.0F },
        {  1.0F, -1.0F,  1.0F, 1.0F },
        {  0.0F, -1.0F,  1.0F, 1.0F },
        { -1.0F, -1.0F,  1.0F, 1.0F },
        { -1.0F,  0.0F,  1.0F, 1.0F },
        { -1.0F,  1.0F,  1.0F, 1.0F },
        {  0.0F,  1.0F,  1.0F, 1.0F }
    };

    GLfloat lightDiffuseColor[8][4] = {
        { 1.0F, 1.0F, 1.0F, 1.0F },
        { 0.0F, 1.0F, 1.0F, 1.0F },
        { 1.0F, 0.0F, 1.0F, 1.0F },
        { 1.0F, 1.0F, 0.0F, 1.0F },
        { 1.0F, 0.0F, 0.0F, 1.0F },
        { 0.0F, 1.0F, 0.0F, 1.0F },
        { 0.0F, 0.0F, 1.0F, 1.0F },
        { 1.0F, 1.0F, 1.0F, 1.0F }
    };

    GLfloat lightAmbientColor[4] = {
        0.1F, 0.1F, 0.1F, 1.0F
    };

    GLfloat lightSpecularColor[4] = {
        1.0F, 1.0F, 1.0F, 1.0F
    };

    GLfloat lightModelAmbient[4] = {
        0.5F, 0.5F, 0.5F, 1.0F
    };

    GLfloat alpha = blendOn ? 0.5F : 1.0F;

    if (infiniteLights + localLights == 0)
        return;

    normFactor = 1.0F / (GLfloat)(infiniteLights + localLights);

    materialDiffuseColor[3] = alpha;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, materialDiffuseColor);
    materialAmbientColor[3] = alpha;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, materialAmbientColor);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, materialSpecularColor);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, materialShininess);

    lightAmbientColor[0] *= normFactor;
    lightAmbientColor[1] *= normFactor;
    lightAmbientColor[2] *= normFactor;

    for (i = 0; i < localLights + infiniteLights; i++) {
        lightPosition[i][3] = (GLfloat)(i < localLights);
        lightDiffuseColor[i][0] *= normFactor;
        lightDiffuseColor[i][1] *= normFactor;
        lightDiffuseColor[i][2] *= normFactor;
        glLightfv(GL_LIGHT0 + i, GL_POSITION, lightPosition[i]);
        glLightfv(GL_LIGHT0 + i, GL_DIFFUSE,  lightDiffuseColor[i]);
        glLightfv(GL_LIGHT0 + i, GL_AMBIENT,  lightAmbientColor);
        glLightfv(GL_LIGHT0 + i, GL_SPECULAR, lightSpecularColor);
        glEnable(GL_LIGHT0 + i);
    }

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lightModelAmbient);
    glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, localViewer);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, twoSidedLighting);

    if (cmenable) {
        glColorMaterial(cmface, cmmode);
        glEnable(GL_COLOR_MATERIAL);
    }

    glEnable(GL_LIGHTING);
}

void EnableLighting (void)
{
    glEnable(GL_AUTO_NORMAL);
	glEnable(GL_NORMALIZE);
    // glShadeModel(shade_model);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
}

void DisableLighting (void)
{
    glDisable(GL_AUTO_NORMAL);
	glDisable(GL_NORMALIZE);
    // glShadeModel(shade_model);

    glDisable(GL_LIGHTING);
    glDisable(GL_LIGHT0);
}


void initlights(void)
{
    GLfloat ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat position[] = { 0.0, 0.0, 2.0, 0.0 };
    GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
    GLfloat mat_diffuse1[] = { 0.8, 0.5, 0.2, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 30.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_POSITION, position);

    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_BACK, GL_DIFFUSE, mat_diffuse1);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}



void CALLBACK Key_i (void)
{
    g_s.trans[0] = 0.0;
    g_s.trans[1] = 0.0;
    g_s.trans[2] = 0.0;

    g_s.zoom = 1.0;
    SetViewing( g_wi.wSize.cx,  g_wi.wSize.cy, FALSE);
    DoGlStuff ();
}

void CALLBACK Key_z (void)
{
    g_s.trans[2] += Z_DELTA;
    DoGlStuff ();
}

void CALLBACK Key_Z (void)
{
    g_s.trans[2] -= Z_DELTA;
    DoGlStuff ();
}

void CALLBACK Key_y (void)
{
    g_s.trans[1] += Y_DELTA;
    DoGlStuff ();
}

void CALLBACK Key_Y (void)
{
    g_s.trans[1] -= Y_DELTA;
    DoGlStuff ();
}

void CALLBACK Key_x (void)
{
    g_s.trans[0] += X_DELTA;
    DoGlStuff ();
}

void CALLBACK Key_X (void)
{
    g_s.trans[0] -= X_DELTA;
    DoGlStuff ();
}

void CALLBACK Key_up (void)
{
  //zTrans += Z_DELTA;
    g_s.zoom *= .8f;
    if (g_s.zoom < 1.0f && g_s.zoom > .8f)
        g_s.zoom = 1.0f;

    SetViewing( g_wi.wSize.cx,  g_wi.wSize.cy, FALSE);
    DoGlStuff ();
}

void CALLBACK Key_down (void)
{
  //zTrans -= Z_DELTA;

    g_s.zoom *= 1.25f;
    if (g_s.zoom > 1.0f && g_s.zoom < 1.25f)
        g_s.zoom = 1.0f;

    SetViewing( g_wi.wSize.cx,  g_wi.wSize.cy, FALSE);
    DoGlStuff ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\vsplit.cxx ===
/**     
 **       File       : vsplit.cxx
 **       Description: vsplit implementations
 **/

#include "precomp.h"
#pragma hdrstop

#include "vsplit.h"
#include "fileio.h"

/*
 *  VsplitArray: Constructor
 */
VsplitArray::VsplitArray(DWORD i)
{
	m_vsarr = new Vsplit[i];
    numVS = i;
    
	if (m_vsarr)
		m_cRef=1;
	else
		throw CExNewFailed();
}

void VsplitArray::write(ostream& os) const
{
    os << "\n\nVSplits: (total = " << numVS << ")";
    for (int i=0; i<numVS; i++)
    {
        os << "\nVsplit[" << i << "] = \n{\n";
        m_vsarr[i].write (os);
        os << "\n}";
    }
}

void Vsplit::read(istream& is)
{
	read_DWORD(is,flclw);
	read_WORD(is,vlr_offset1);
	read_WORD(is,code);
	if (code&(FLN_MASK|FRN_MASK)) 
	{
		read_WORD(is,fl_matid);
		read_WORD(is,fr_matid);
	} 
	else 
	{
		fl_matid=0; 
		fr_matid=0;
	}
	for (int c=0; c<3; ++c)
		read_float(is,vad_large[c]);
	for (c=0; c<3; ++c)
		read_float(is,vad_small[c]);
    int nwa=expected_wad_num();
    for(int i=0; i<nwa; ++i) 
        for(c=0; c<5; ++c)
			read_float(is, ar_wad[i][c]);
    modified = FALSE;
}

void Vsplit::write(ostream& os) const
{
    os << "\nflclw: " << flclw;
    os << "\nvlr_offset1: " << vlr_offset1;
    os << "\ncode: " << code;

	if (code&(FLN_MASK|FRN_MASK)) 
	{
        os << "\nfl_matid: " << fl_matid;
        os << "\nfr_matid: " << fr_matid;
	} 
	else 
	{
        os << "\nfl_matid: " << (WORD) 0;
        os << "\nfr_matid: " << (WORD) 0;
	}

    os << "\nvad_large: (" << vad_large[0] << ", " << vad_large[1] << ", " 
       << vad_large[2] << ") ";
    os << "\nvad_small: (" << vad_small[0] << ", " << vad_small[1] << ", " 
       << vad_small[2] << ") ";

    int nwa = expected_wad_num();
    for(int i=0; i<nwa; ++i) 
    {
        os << "\nar_wad[" << i << "] : {" ;
        for(int c=0; c<5; ++c)
            os << ar_wad[i][c] << "   ";
        os << "}" ;
    }
}

int Vsplit::expected_wad_num() const
{
    // optimize: construct static const lookup table on (S_MASK|T_MASK).
    int nwa=0;
    int nt=!(code&T_LSAME);
    int ns=!(code&S_LSAME);
    nwa+=nt&&ns?2:1;
    if (vlr_offset1>1) 
	{
        int nt=!(code&T_RSAME);
        int ns=!(code&S_RSAME);
        if (nt && ns) 
		{
            if (!(code&T_CSAME)) 
				nwa++;
            if (!(code&S_CSAME)) 
				nwa++;
        } 
		else 
		{
            int ii=(code&II_MASK)>>II_SHIFT;
            switch (ii) 
			{
             case 2:
                if (!(code&T_CSAME)) nwa++;
				break;
             case 0:
                if (!(code&S_CSAME)) nwa++;
				break;
             case 1:
                if (!(code&T_CSAME) || !(code&S_CSAME)) nwa++;
				break;
             default:
                throw CBadVsplit();
            }
        }
    }
    if (code&L_NEW) 
		nwa++;
    if (code&R_NEW) 
		nwa++;
    return nwa;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\file.cxx ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 *  File: file.cpp
 *
 ***************************************************************************/
#include <windows.h>
#include <commdlg.h>
#include <stdio.h>
#include <string.h>
#include <fstream.h>

char* OpenPMFile( HWND hwnd, const char *wndTitle, int must_exist)
{
    static char file[256];
    static char fileTitle[256];
    static char filter[] = "PM files (*.pmx)\0*.pmx\0"
                           "All Files (*.*)\0*.*\0";
    OPENFILENAME ofn;

    lstrcpy( file, "");
    lstrcpy( fileTitle, "");

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.hInstance         = (HINSTANCE) GetWindowLong(hwnd, GWL_HINSTANCE);
    ofn.lpstrFilter       = filter;
    ofn.lpstrCustomFilter = (LPSTR) NULL;
    ofn.nMaxCustFilter    = 0L;
    ofn.nFilterIndex      = 1L;
    ofn.lpstrFile         = file;
    ofn.nMaxFile          = sizeof(file);
    ofn.lpstrFileTitle    = fileTitle;
    ofn.nMaxFileTitle     = sizeof(fileTitle);
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = wndTitle;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = "*.pm";
    ofn.lCustData         = 0;

    ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST;
	if (must_exist) ofn.Flags |= OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&ofn))
        return (char*)ofn.lpstrFile;
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\trackbal.cxx ===
/*
 * Trackball code:
 *
 * Implementation of a virtual trackball.
 * Implemented by Gavin Bell, lots of ideas from Thant Tessman and
 *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.
 *
 * Vector manip code:
 *
 * Original code from:
 * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli
 *
 * Much mucking with by:
 * Gavin Bell
 */
#include <math.h>
#include "trackbal.h"

/*
 * This size should really be based on the distance from the center of
 * rotation to the point on the object underneath the mouse.  That
 * point would then track the mouse as closely as possible.  This is a
 * simple example, though, so that is left as an Exercise for the
 * Programmer.
 */
#define TRACKBALLSIZE  (0.8)

/*
 * Local function prototypes (not defined in trackball.h)
 */
static float tb_project_to_sphere(float, float, float);
static void normalize_quat(float [4]);

void
vzero(float *v)
{
    v[0] = 0.0;
    v[1] = 0.0;
    v[2] = 0.0;
}

void
vset(float *v, float x, float y, float z)
{
    v[0] = x;
    v[1] = y;
    v[2] = z;
}

void
vsub(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] - src2[0];
    dst[1] = src1[1] - src2[1];
    dst[2] = src1[2] - src2[2];
}

void
vcopy(const float *v1, float *v2)
{
    register int i;
    for (i = 0 ; i < 3 ; i++)
        v2[i] = v1[i];
}

void
vcross(const float *v1, const float *v2, float *cross)
{
    float temp[3];

    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    vcopy(temp, cross);
}

float
vlength(const float *v)
{
    return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void
vscale(float *v, float div)
{
    v[0] *= div;
    v[1] *= div;
    v[2] *= div;
}

void
vnormal(float *v)
{
    vscale(v,1.0/vlength(v));
}

float
vdot(const float *v1, const float *v2)
{
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void
vadd(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
}

/*
 * Ok, simulate a track-ball.  Project the points onto the virtual
 * trackball, then figure out the axis of rotation, which is the cross
 * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
 * Note:  This is a deformed trackball-- is a trackball in the center,
 * but is deformed into a hyperbolic sheet of rotation away from the
 * center.  This particular function was chosen after trying out
 * several variations.
 * 
 * It is assumed that the arguments to this routine are in the range
 * (-1.0 ... 1.0)
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y)
{
    float a[3]; /* Axis of rotation */
    float phi;  /* how much to rotate about axis */
    float p1[3], p2[3], d[3];
    float t;

    if (p1x == p2x && p1y == p2y) {
	/* Zero rotation */
        vzero(q); 
	q[3] = 1.0; 
        return;
    }

    /*
     * First, figure out z-coordinates for projection of P1 and P2 to
     * deformed sphere
     */
    vset(p1,p1x,p1y,tb_project_to_sphere(TRACKBALLSIZE,p1x,p1y));
    vset(p2,p2x,p2y,tb_project_to_sphere(TRACKBALLSIZE,p2x,p2y));

    /*
     *  Now, we want the cross product of P1 and P2
     */
    vcross(p2,p1,a);

    /*
     *  Figure out how much to rotate around that axis.
     */
    vsub(p1,p2,d);
    t = vlength(d) / (2.0*TRACKBALLSIZE);

    /*
     * Avoid problems with out-of-control values...
     */
    if (t > 1.0) t = 1.0;
    if (t < -1.0) t = -1.0;
    phi = 2.0 * asin(t);

    axis_to_quat(a,phi,q);
}

/*
 *  Given an axis and angle, compute quaternion.
 */
void
axis_to_quat(float a[3], float phi, float q[4])
{
    vnormal(a);
    vcopy(a,q);
    vscale(q,sin(phi/2.0));
    q[3] = cos(phi/2.0);
}

/*
 * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
 * if we are away from the center of the sphere.
 */
static float
tb_project_to_sphere(float r, float x, float y)
{
    float d, t, z;

    d = sqrt(x*x + y*y);
    if (d < r * 0.70710678118654752440) {    /* Inside sphere */
	z = sqrt(r*r - d*d);
    } else {           /* On hyperbola */
        t = r / 1.41421356237309504880;
        z = t*t / d;
    }
    return z;
}

/*
 * Given two rotations, e1 and e2, expressed as quaternion rotations,
 * figure out the equivalent single rotation and stuff it into dest.
 * 
 * This routine also normalizes the result every RENORMCOUNT times it is
 * called, to keep error from creeping in.
 *
 * NOTE: This routine is written so that q1 or q2 may be the same
 * as dest (or each other).
 */

#define RENORMCOUNT 97

void
add_quats(float q1[4], float q2[4], float dest[4])
{
    static int count=0;
    int i;
    float t1[4], t2[4], t3[4];
    float tf[4];

    vcopy(q1,t1); 
    vscale(t1,q2[3]);

    vcopy(q2,t2); 
    vscale(t2,q1[3]);

    vcross(q2,q1,t3);
    vadd(t1,t2,tf);
    vadd(t3,tf,tf);
    tf[3] = q1[3] * q2[3] - vdot(q1,q2);

    dest[0] = tf[0];
    dest[1] = tf[1];
    dest[2] = tf[2];
    dest[3] = tf[3];

    if (++count > RENORMCOUNT) {
        count = 0;
        normalize_quat(dest);
    }
}

/*
 * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
 * If they don't add up to 1.0, dividing by their magnitued will
 * renormalize them.
 *
 * Note: See the following for more information on quaternions:
 * 
 * - Shoemake, K., Animating rotation with quaternion curves, Computer
 *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
 * - Pletinckx, D., Quaternion calculus as a basic tool in computer
 *   graphics, The Visual Computer 5, 2-13, 1989.
 */
static void
normalize_quat(float q[4])
{
    int i;
    float mag;

    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
    for (i = 0; i < 4; i++) q[i] /= mag;
}

/*
 * Build a rotation matrix, given a quaternion rotation.
 *
 */
void
build_rotmatrix(float m[4][4], float q[4])
{
    m[0][0] = 1.0 - 2.0 * (q[1] * q[1] + q[2] * q[2]);
    m[0][1] = 2.0 * (q[0] * q[1] - q[2] * q[3]);
    m[0][2] = 2.0 * (q[2] * q[0] + q[1] * q[3]);
    m[0][3] = 0.0;

    m[1][0] = 2.0 * (q[0] * q[1] + q[2] * q[3]);
    m[1][1]= 1.0 - 2.0 * (q[2] * q[2] + q[0] * q[0]);
    m[1][2] = 2.0 * (q[1] * q[2] - q[0] * q[3]);
    m[1][3] = 0.0;

    m[2][0] = 2.0 * (q[2] * q[0] - q[1] * q[3]);
    m[2][1] = 2.0 * (q[1] * q[2] + q[0] * q[3]);
    m[2][2] = 1.0 - 2.0 * (q[1] * q[1] + q[0] * q[0]);
    m[2][3] = 0.0;

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = 0.0;
    m[3][3] = 1.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\pm.cxx ===
#include "viewer.h"
#include "FileIO.h" // StreamSetFMode()
#include "gmesh.h"
#include "a3dstream.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define GL_COLOR4(c)  glColor4ub(((c)>>24)&0xff,((c)>>16)&0xff,((c)>>8)&0xff,((c)>>0)&0xff)
/************************************************************************/
/******************* Constants ******************************************/
/************************************************************************/
const int MAXOBJECT=250;        // should be >= GLuint::MAXNUM
const DWORD colorinvalid=0xffffff00;

/************************************************************************/
/******************* Globals ********************************************/
/************************************************************************/
static BOOL  c_mat_set;
BOOL pm_ready = FALSE;

static int thickboundary = 2;
static int thicksharp = 2;
static int thicknormal = 1;
static int thicka3d = 1;

static BOOL perspec = TRUE;
static int cullbackedges=1;

static GLfloat ambient;
static GLfloat backfacec[4];

static float fdisplacepolygon = 1.0;
static float sphereradius=.005;
static float zoom = 1.0;
static Frame tcam;
static int nxpix,nypix;         // window dimensions
static float tzp1, tzp2;
static float edgeoffset;
static Frame tcami;
static Point eyeinobframe;
static int cob;

static BOOL lcullface = FALSE;

static BOOL haveconcave = FALSE;

static DWORD edgecolor = 0x000000FF;      // black
static DWORD sharpedgecolor = 0xFF40FFFF; // bright yellow
static float xpointerold, ypointerold;

static DWORD curcol;               // current color (for lines and points)
static MatColor matcol;            // material color (for polygons)
static MatColor cuspcolor;
static MatColor meshcolor;

// default color for polygons
const A3dVertexColor DEFAULTCOL(A3dColor(0.9, 0.6, 0.4),
                                A3dColor(0.5, 0.5, 0.5),
                                A3dColor(5, 0, 0));

// default color for polylines and points
const A3dVertexColor WHITECOL(A3dColor(1, 1, 1),
                              A3dColor(0, 0, 0),
                              A3dColor(1, 0, 0));

static Array<DWORD> pm_ar_colors;

PMesh *pmesh;  // Global pointer to the (one and only) PM object
PMeshRStream* pmrs=0;
PMeshIter* pmi=0;
float pm_lod_level = 0.0;
float old_lod = 0.0;

float   curquat[4], lastquat[4];
/************************************************************************/
/******************* Function Prototypes ********************************/
/************************************************************************/
BOOL InitPMDrawState(void);
BOOL read_pm (char *);
void draw_pm (void);
static void glinit(void);
static int setupob(void);
void pm_update_lod (void);

/************************************************************************/
/******************* Code ***********************************************/
/************************************************************************/

static DWORD packcolor(const A3dColor& col)
{
    return (DWORD(col[0]*255.99)<<24)+(DWORD(col[1]*255.99)<<16)+
        (DWORD(col[2]*255.99)<<8)+(DWORD(255)<<0);
}

static void creatematcolor(const A3dVertexColor& vc, MatColor& col)
{
    col.diffuse   = packcolor(vc.d);
    col.specular  = packcolor(vc.s);
    col.shininess = vc.g[0];
}

BOOL InitPMDrawState(char *fname)
{
    perspec = TRUE;
    backfacec[0] = 0.15, backfacec[1]= 0.5, backfacec[2]= 0.15;
    backfacec[3] = 1.0;
    
    nxpix = g_wi.wSize.cx;
    nypix = g_wi.wSize.cy;
    float cuspcol[3]= {1.0, 0.2, 0.2};
    float meshcd[3]={0.8, 0.5, 0.4};
    float meshcs[3]={0.5, 0.5, 0.5};
    float meshcp[3]={5, 0, 0};

    int cuspbright = (cuspcol[0] + cuspcol[1] + cuspcol[2]>2.);
    A3dVertexColor CUSPCOL(A3dColor(cuspcol[0],cuspcol[1],cuspcol[2]),
                           A3dColor(cuspcol[0],cuspcol[1],cuspcol[2]),
                           A3dColor(cuspbright?1:7,0,0));

    creatematcolor(CUSPCOL, cuspcolor);
    creatematcolor(A3dVertexColor(A3dColor(meshcd[0],meshcd[1],meshcd[2]),
                                  A3dColor(meshcs[0],meshcs[1],meshcs[2]),
                                  A3dColor(meshcp[0],meshcp[1],meshcp[2])),
                   meshcolor);
    if (fname) 
        if (read_pm( fname ))
        {
            glinit();
            setupob ();
            return TRUE;
        }

    return FALSE;
}


static int pthick;

static void resetthickness()
{
    pthick=-1;
}


static void setthickness2(int vthick)
{
    pthick=vthick;
    if (vthick > 1) 
        glLineWidth((GLfloat)(vthick));
}

inline void InitViewing (void)
{
    float a = 1.0f / min(nxpix, nypix);
    tzp1 = 0.5f / (zoom*nxpix*a);
    tzp2 = 0.5f / (zoom*nypix*a);

  //if (g_s.yon <= g_s.hither*1.0001) g_s.yon = g_s.hither*1.0001;
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    //Reshape (nxpix, nypix);
#if 1
    if (perspec) 
    {
        glFrustum (-nxpix*a*zoom*g_s.hither, nxpix*a*zoom*g_s.hither,
                   -nypix*a*zoom*g_s.hither, nypix*a*zoom*g_s.hither,
                   g_s.hither, g_s.yon);
    } 
    else 
    {
        glOrtho(-nxpix*a*zoom, nxpix*a*zoom,
                -nypix*a*zoom, nypix*a*zoom,
                g_s.hither, g_s.yon);
    }
#endif

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    trackball(curquat, 0.0, 0.0, 0.0, 0.0);
}

inline void setthickness(int vthick)
{
    if (vthick!=pthick) setthickness2(vthick);
}


// must be followed by setupob()!
static void glinit(void)
{

    const float cedgeoffset=4.2e-3f;
    edgeoffset = cedgeoffset*zoom*fdisplacepolygon;

    InitViewing ();
    
    NEST 
    {                      // front material
       float material[] = {0.0, 0.0, 0.0, 1.0};
       glMaterialfv (GL_FRONT, GL_AMBIENT_AND_DIFFUSE, material); 
    }
    NEST 
    {                      // back material
        float amb[]  = {0.0, 0.0, 0.0, 1.0};
        float diff[] = {0.15, 0.15, 0.15, 1.0};
        glMaterialfv(GL_BACK, GL_AMBIENT, amb); 
        glMaterialfv(GL_BACK, GL_DIFFUSE, diff); 
        glMaterialfv(GL_BACK, GL_EMISSION, backfacec); 
    }
    NEST 
    {                      // lighting model
        GLfloat ambient[] = { 0.2, 0.2, 0.2, 1.0 };
        GLfloat diffuse[] = { 0.7, 0.7, 0.7, 1.0 };
        GLfloat position[] = { 0.0, 0.0, 2.0, 0.0 };
        
        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, ambient);
        glLightfv(GL_LIGHT0, GL_POSITION, position);
    }

    resetthickness();
    setthickness(thicka3d);
    glDepthRange(0x0, 0x7FFFFF);
    c_mat_set = FALSE;
    glDisable (GL_COLOR_MATERIAL);
    
    curcol   = colorinvalid;
    matcol.diffuse   = colorinvalid;
    matcol.specular  = colorinvalid;
    matcol.shininess = -1;                
}


static int setupob(void)
{
    char buf[200];
  
    NEST 
    {
        GLfloat ambient[] = {0.25, 0.25, 0.25, 1.0};
      
        glLightModelfv (GL_LIGHT_MODEL_AMBIENT, ambient);
        glLightModeli (GL_LIGHT_MODEL_LOCAL_VIEWER, 0);
        glLightModeli (GL_LIGHT_MODEL_TWO_SIDE, 0);
    }
    glFrontFace (front_face);
    
    glCullFace(cull_face);
    if (cull_enable) 
        glEnable(GL_CULL_FACE);
    else
        glDisable(GL_CULL_FACE);

    glPolygonMode(GL_FRONT_AND_BACK, filled_mode?GL_FILL:GL_LINE);
    //if (edge_mode) displacepolygon(fdisplacepolygon);

    // Compute the model bounding box
    g_s.max_vert[0] = g_s.max_vert[1] = g_s.max_vert[2] = -1e30f;
    g_s.min_vert[0] = g_s.min_vert[1] = g_s.min_vert[2] = 1e30f;
    int nv0=pmesh->_base_mesh._vertices.num();
    //int nvsplits=pmesh->_vsplits.num();
    //int nv=nv0+int((nvsplits+1)*0.999999f); //max LOD
    pmi->goto_nvertices(nv0);

    const AWMesh& wmesh=*pmi;
    int num_v = wmesh._vertices.num();
    //S_Vertex* svp  = wmesh._vertices;

    for (int i=0; i<num_v; i++)
    {
#if 0
        const float* p1 = &wmesh._vertices[i].attrib.point[0];
        for (int j=0; j<3; j)
        {
            if (p1[j] > g_s.max_vert[j]) g_s.max_vert[j] = p1[j];
            if (p1[j] < g_s.min_vert[j]) g_s.min_vert[j] = p1[j];
        }
#endif    
    }
    sprintf (buf, "NumVert = %d\r\n", num_v);
    
    MessageBox (NULL, buf, "Info", MB_OK);
    //pmi->goto_nvertices(nv0);
    
    return 1;
}


static void updatecurcolor2(DWORD col)
{
    if (c_mat_set) c_mat_set = 0, glDisable(GL_COLOR_MATERIAL);
    curcol = col;
    glColor4ub ( (col>>24) & 0xff,
                 (col>>16) & 0xff,
                 (col>>8) & 0xff,
                 (col>>0) & 0xff);
    matcol.diffuse   = colorinvalid;
    matcol.specular  = colorinvalid;
    matcol.shininess = -1;
}

inline void updatecurcolor (DWORD col)
{
    if (col != curcol) updatecurcolor2 (col);
}

static void updatematcolor2(const MatColor& col)
{
    if (!c_mat_set)
    {
        c_mat_set = TRUE;
        glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
    }
    glEnable(GL_COLOR_MATERIAL);

    if (col.shininess != matcol.shininess) 
    {
        matcol.shininess = col.shininess;
        glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, matcol.shininess);
    }

    if (col.specular != matcol.specular) 
    {
        matcol.specular = col.specular;
        glColorMaterial(GL_FRONT_AND_BACK, GL_SPECULAR);
        GL_COLOR4(matcol.specular);
        glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
    }

    if (col.diffuse != matcol.diffuse) 
    { 
        matcol.diffuse =  col.diffuse;
        GL_COLOR4(col.diffuse);
    }
    curcol=colorinvalid;
}


inline void updatematcolor(const MatColor& col)
{
    if (col.diffuse   != matcol.diffuse  || 
        col.specular  != matcol.specular || 
        col.shininess != matcol.shininess)
      updatematcolor2(col);
}

inline void updatematdiffuse(DWORD cd)
{
    if (cd != matcol.diffuse) 
    {
        if (!c_mat_set) 
        {
            c_mat_set = TRUE;
            glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
        }
        glEnable(GL_COLOR_MATERIAL);
        matcol.diffuse = cd;
        GL_COLOR4(cd);
        curcol=colorinvalid;
    }
}



inline void pm_draw_segment(int fn, int v0, int v1,
                            const Point& p0, const Point& p1)
{
    if (fn >= 0 && v0 > v1) return;
    glBegin(GL_LINES);
      glVertex3fv(&p0[0]);
      glVertex3fv(&p1[0]);
    glEnd();
}

void draw_pm (void)
{
    updatematcolor(meshcolor);
    const AWMesh& wmesh=*pmi;
    if (!edge_mode || filled_mode) 
    {
        const S_Vertex* svp  = wmesh._vertices;
        const S_Wedge* swp   = wmesh._wedges;
        const S_Face* sfp    = wmesh._faces;
        const DWORD * matp = pm_ar_colors;
        ForIndex(f, wmesh._faces.num()) 
        {
            int matid = sfp[f].attrib.matid;
            updatematdiffuse(matp[matid]);

            glBegin(GL_TRIANGLES);
              const int* wp = sfp[f].wedges;
              int w0 = wp[0];
              int w1 = wp[1];
              int w2 = wp[2];

              int v0 = swp[w0].vertex;
              int v1 = swp[w1].vertex;
              int v2 = swp[w2].vertex;

              const float* n0 = &swp[w0].attrib.normal[0];
              const float* p0 = &svp[v0].attrib.point[0];

              const float* n1 = &swp[w1].attrib.normal[0];
              const float* p1 = &svp[v1].attrib.point[0];

              const float* n2=&swp[w2].attrib.normal[0];
              const float* p2=&svp[v2].attrib.point[0];

              glNormal3fv(n0); glVertex3fv(p0);
              glNormal3fv(n1); glVertex3fv(p1);
              glNormal3fv(n2); glVertex3fv(p2);
            glEnd();
        } EndFor;
    }
    if (edge_mode) 
    {
        // Options cullbackedges, lquickmode not handled.
        setthickness (thicknormal);
        updatecurcolor (edgecolor);
        const S_Vertex* svp        = wmesh._vertices;
        const S_Wedge* swp         = wmesh._wedges;
        const S_Face* sfp          = wmesh._faces;
        const S_FaceNeighbors* snp = wmesh._fnei;
        ForIndex(f, wmesh._faces.num()) 
        {
            const int* wp = sfp[f].wedges;
            const int* np = snp[f].faces;

            int w0 = wp[0];
            int w1 = wp[1];

            int v0 = swp[w0].vertex;
            int v1 = swp[w1].vertex;

            const Point& p0 = svp[v0].attrib.point;
            const Point& p1 = svp[v1].attrib.point;

            int fn2 = np[2];
            int fn0 = np[0];

            pm_draw_segment (fn2, v0, v1, p0, p1);

            int w2 = wp[2];
            int v2 = swp[w2].vertex;

            const Point& p2 = svp[v2].attrib.point;
            int fn1 = np[1];

            pm_draw_segment (fn0, v1, v2, p1, p2);
            pm_draw_segment (fn1, v2, v0, p2, p0);
        } EndFor;
        setthickness (thicka3d);
    }
}


#define ForStringKeyValue(S,KS,KL,VS,VL) \
{ StringKeyIter zz(S); \
  const char* KS; const char* VS; \
  int KL; int VL; \
  while (zz.next(KS,KL,VS,VL)) {

const char* string_key(const char* str, const char* key)
{
    int keyl=strlen(key);
    ForStringKeyValue(str,kb,kl,vb,vl) {
        int found=!strncmp(kb,key,kl) && kl==keyl;
        if (!found) continue;
        char* sret=(char*)hform(""); // un-const
        strncat(sret,vb,vl);
        return sret;
    } EndFor;
    return 0;
}

BOOL read_pm (char *fname)
{
    BOOL retVal = TRUE;

    if (pmesh)
        delete pmesh;
    pmesh=new PMesh;
    {
        ifstream fi(fname);
        StreamSetFMode((fstream&)fi,1);
        pmesh->read(fi);
    }
    pmrs=new PMeshRStream(*pmesh);
    pmi=new PMeshIter(*pmrs);
    // When pmrs is created, it automatically reads in pmesh._base_mesh
    const AWMesh& base_mesh=pmesh->_base_mesh;
    const Materials& materials=base_mesh._materials;

    ForIndex(matid,materials.num()) {
        DWORD pcolor;
        const char* str=materials.get(matid);
        const char* s=string_key(str,"rgb");
        if (s) 
        {
            A3dColor co;
            if (sscanf(s,"( %g %g %g )",&co[0],&co[1],&co[2])!=3)
                MessageBox (NULL, "viewer.cxx", "Error", MB_OK);
            //assertx(sscanf(s,"( %g %g %g )",&co[0],&co[1],&co[2])==3);
            pcolor=packcolor(co);
        } 
        else 
        {
            pcolor = meshcolor.diffuse;
        }
        pm_ar_colors+=pcolor;
    } EndFor;
    pm_lod_level = 0.0f;
    auxSetScrollPos (AUX_HSCROLL, auxGetScrollMin(AUX_HSCROLL));
    pm_ready = TRUE;
    return retVal;
}


void pm_update_lod (void)
{
  //float flevel=min(pm_lod_level,1.f);
    int nv0=pmesh->_base_mesh._vertices.num();
    int nvsplits=pmesh->_vsplits.num();
    int nv=nv0+int((nvsplits+1)*pm_lod_level*.999999f);
    pmi->goto_nvertices(nv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\trackbal.h ===
/*
 * trackball.h
 * A virtual trackball implementation
 * Written by Gavin Bell for Silicon Graphics, November 1988.
 */

/*
 * Pass the x and y coordinates of the last and current positions of
 * the mouse, scaled so they are from (-1.0 ... 1.0).
 *
 * if ox,oy is the window's center and sizex,sizey is its size, then
 * the proper transformation from screen coordinates (sc) to world
 * coordinates (wc) is:
 * wcx = (2.0 * (scx-ox)) / (float)sizex - 1.0
 * wcy = (2.0 * (scy-oy)) / (float)sizey - 1.0
 *
 * The resulting rotation is returned as a quaternion rotation in the
 * first paramater.
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y);

/*
 * Given two quaternions, add them together to get a third quaternion.
 * Adding quaternions to get a compound rotation is analagous to adding
 * translations to get a compound translation.  When incrementally
 * adding rotations, the first argument here should be the new
 * rotation, the second and third the total rotation (which will be
 * over-written with the resulting new total rotation).
 */
void
add_quats(float *q1, float *q2, float *dest);

/*
 * A useful function, builds a rotation matrix in Matrix based on
 * given quaternion.
 */
void
build_rotmatrix(float m[4][4], float q[4]);

/*
 * This function computes a quaternion based on an axis (defined by
 * the given vector) and an angle about which to rotate.  The angle is
 * expressed in radians.  The result is put into the third argument.
 */
void
axis_to_quat(float a[3], float phi, float q[4]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\viewer.h ===
#include <windows.h>
#include <GL\gl.h>
#include <GL\glu.h>
#include <GL\glaux.h>
#include "viewerres.h"
#include "trackbal.h"
#include "pmesh.h"
#include <objbase.h>
#include <initguid.h>

/************************************************************************/
/******************* Macros *********************************************/
/************************************************************************/
#define SCROLLBAR_PAGE 100
#define SCROLLBAR_MIN 0 
#define SCROLLBAR_MAX 1000+(SCROLLBAR_PAGE-1)

#define WIN_WIDTH 500
#define WIN_HEIGHT 500
#define WIN_X 10
#define WIN_Y 10

#define DEFHITHER  1  //0.1
#define DEFYONDER  10 //1e30;

#ifdef DEBUGGING
    char    szDebugBuffer[80];
    #define DEBUG(parm1,parm2)\
        {\
            wsprintf(szDebugBuffer,parm1,parm2);\
            OutputDebugString(szDebugBuffer);\
        }
#else
    #define DEBUG(parm1,parm2)
#endif


/************************************************************************/
/******************* Enums **********************************************/
/************************************************************************/
/**** Enums ****/
enum NormalMode {PER_VERTEX, PER_FACET, PER_OBJECT};
enum TransformType {ORTHO_PROJECTION, PERSP_PROJECTION};

/************************************************************************/
/******************* Structs ********************************************/
/************************************************************************/
/**** Structs ****/

typedef struct _ostate 
{
} GLSTATE, *LPGLSTATE;

typedef struct _Scene 
{
    GLfloat hither;
    GLfloat yon;

    GLfloat scale;
    GLfloat angle;
    int scroll_pos;
    GLfloat trans[3];
  
    GLfloat from[3];
    GLfloat to[3];
    GLfloat up[3];
    GLfloat aspect_ratio;
    GLfloat fov;
    GLfloat zoom;

    GLfloat max_vert[3];
    GLfloat min_vert[3];
} SCENE, *LPSCENE;

typedef struct _WInf 
{
    HWND         hWnd;
    HMENU        hMenu;
    POINT        wPosition;
    POINT        wCenter;
    SIZE         wSize;
    HPALETTE     hPalette;
    HPALETTE     hOldPalette;
    HGLRC        hRc;

    LONG         rmouseX;
    LONG         rmouseY;
    BOOL         rmouse_down;
  
    LONG         lmouseX;
    LONG         lmouseY;
    BOOL         lmouse_down;
  
} WININFO, *LPWININFO;


/************************************************************************/
/******************* Windows Globals ************************************/
/************************************************************************/
/**** Externs ****/
extern WININFO g_wi;
extern SCENE g_s;

/************************************************************************/
/******************* Function Prototypes ********************************/
/************************************************************************/
/******** viewer.cxx *************/
extern void CleanUpAndQuit (void);
extern BOOL InitMainWindow (HINSTANCE, HINSTANCE, LPSTR, int);
extern LONG APIENTRY GLWndProc(HWND, UINT, UINT, LONG);

/******** glstuff.cxx ************/
extern void Reshape (GLsizei, GLsizei);
extern void SetViewWrap (GLsizei, GLsizei);
extern void InitGL(void);
extern void InitDrawing ();
extern void CALLBACK DoGlStuff(void);
extern void spin( HWND, HDC );
extern void CleanupGL(HGLRC);
extern void UpdateWinTitle (HWND);
extern void spin(void);
extern void ForceRedraw(HWND);
extern char* OpenPMFile(HWND, const char *, int);
extern void EnableLighting (void);
extern void DisableLighting (void);

extern void Key_up (void);
extern void Key_down (void);
extern void Key_i (void);
extern void Key_z (void);
extern void Key_Z (void);
extern void Key_y (void);
extern void Key_Y (void);
extern void Key_x (void);
extern void Key_X (void);

extern BOOL FindPixelFormat(HDC);
extern HPALETTE CreateRGBPalette( HDC hdc );

/******** pm.cxx *****************/
extern long RealizePaletteNow( HDC, HPALETTE, BOOL);
extern int PixelFormatDescriptorFromDc( HDC, PIXELFORMATDESCRIPTOR * );

/************************************************************************/
/******************* OpenGL State ***************************************/
/************************************************************************/
/********** OpenGL State *************/
extern BOOL renderDoubleBuffer;
extern int colormode;
extern enum NormalMode normal_mode;

extern BOOL linesmooth_enable;
extern BOOL polysmooth_enable;

extern GLenum cull_face;
extern GLenum front_face;
extern BOOL cull_enable;

extern BOOL depth_mode;
extern BOOL fog_enable;
extern BOOL clip_enable;
extern GLenum shade_model;

extern BOOL polystipple_enable;
extern BOOL linestipple_enable;

extern int matrixmode;
extern enum TransformType tx_type;

extern BOOL dither_enable;

extern BOOL blend_enable;
extern GLenum sblendfunc;
extern GLenum dblendfunc;

extern BOOL filled_mode;
extern BOOL edge_mode;
extern BOOL displaylist_mode;
extern GLfloat linewidth;

extern GLfloat hither;
extern GLfloat yon;

extern GLenum polymodefront;
extern GLenum polymodeback;

extern BOOL mblur_enable;
extern GLfloat blur_amount;
extern int fsantimode;
extern int fsaredraw;
extern GLfloat fsajitter;

extern int cmface;
extern int cmmode;
extern int cmenable;

extern BOOL tex_enable;
extern BOOL texgen_enable;
extern GLenum texenvmode;

extern long tex_pack;
extern int tex_row;
extern int tex_col;
extern int tex_index;
extern int tex_xpix;
extern int tex_ypix;
extern int tex_numpix;
extern int tex_numcomp;
extern GLfloat tex_minfilter;
extern GLfloat tex_magfilter;
extern unsigned char *Image;
extern unsigned char *TextureImage;

extern BOOL light_enable;
extern int numInfLights;
extern int numLocalLights;
extern BOOL lighttwoside;
extern GLfloat localviewmode;

extern float curquat[4];
extern float lastquat[4];

/************** PM related stuff **********/
extern float pm_lod_level;
extern float old_lod;
extern BOOL pm_ready;
extern LPPMESH pPMesh;
extern LPPMESHGL pPMeshGL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\viewerres.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 ***************************************************************************/

#define MENU_STATS                      1
#define MENU_EXIT                       2
#define MENU_TEXTURE_TOGGLE             3
#define MENU_TEXTURE_SWAP               4
#define MENU_FULLSCREEN                 7
#define MENU_NEXT_MODE                  8
#define MENU_PREVIOUS_MODE              9
#define MENU_STATS                      10
#define MENU_FLAT                       12
#define MENU_GOURAUD                    13
#define MENU_PHONG                      14
#define MENU_ZBUFFER                    15
#define MENU_PERSPCORRECT               16
#define MENU_POINT_FILTER               17
#define MENU_LINEAR_FILTER              18
#define MENU_CLEARS                     19
#define MENU_POINT                      20
#define MENU_WIREFRAME                  21
#define MENU_SOLID                      22
#define MENU_SPECULAR                   23
#define MENU_LIGHTING                   31
#define MENU_DITHERING                  24
#define MENU_FOG                        25
#define MENU_ANTIALIAS                  26
#define MENU_DEPTH                      28
#define MENU_FIRST_FORMAT               40
#define MENU_FIRST_DRIVER               100
#define MENU_FIRST_MODE                 200
#define MENU_FILE_OPEN_PMESH            40001
#define IDR_MYACCELERATOR1              40002
#define APPMENU                         40003

#define MENU_CULL                       27
#define MENU_BACKFACE                   47
#define MENU_FRONTFACE                  42
#define MENU_CCW                        43
#define MENU_CW                         44

#define IDC_STATIC                     -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\pmesh\demo\viewer.cxx ===
/************************************************************************/
/******************** Includes ******************************************/
/************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "viewer.h"

//IID_IPMesh {0C154611-3C2C-11d0-A459-00AA00BDD621}
__declspec(dllexport) DEFINE_GUID(IID_IPMesh, 
0xc154611, 0x3c2c, 0x11d0, 0xa4, 0x59, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x21);

//IID_IPMeshGL {0C154612-3C2C-11d0-A459-00AA00BDD621}
__declspec(dllexport) DEFINE_GUID(IID_IPMeshGL, 
0xc154612, 0x3c2c, 0x11d0, 0xa4, 0x59, 0x0, 0xaa, 0x0, 0xbd, 0xd6, 0x21);

/************************************************************************/
/******************** Globals *******************************************/
/************************************************************************/
LPPMESH pPMesh;
LPPMESHGL pPMeshGL;
DWORD minV=0, maxV=0;
BOOL pm_ready = FALSE;
float pm_lod_level;
float old_lod;
float   curquat[4], lastquat[4];

WININFO g_wi;
SCENE g_s;
int OldScrollPos;

/** OpenGL state **/
BOOL renderDoubleBuffer = TRUE;
int colormode = TRUE;
enum NormalMode normal_mode = PER_VERTEX;

BOOL linesmooth_enable = FALSE;
BOOL polysmooth_enable = FALSE;

GLenum cull_face = GL_FRONT; 
GLenum front_face = GL_CCW; 
BOOL cull_enable = FALSE;    

BOOL depth_mode = TRUE;
BOOL fog_enable = FALSE;
BOOL clip_enable = FALSE;
GLenum shade_model = GL_FLAT;

BOOL polystipple_enable = FALSE;
BOOL linestipple_enable = FALSE;

int matrixmode;
enum TransformType tx_type = ORTHO_PROJECTION;

BOOL dither_enable = TRUE;   

BOOL blend_enable = FALSE;
GLenum sblendfunc = GL_SRC_ALPHA;
GLenum dblendfunc = GL_ONE_MINUS_SRC_ALPHA;

BOOL filled_mode = TRUE;  
BOOL edge_mode = FALSE;
  
BOOL displaylist_mode = FALSE;
GLfloat linewidth = 1.0;

GLenum polymodefront = GL_FILL;
GLenum polymodeback = GL_FILL;

BOOL mblur_enable = FALSE;
GLfloat blur_amount = 0.0;
BOOL fsantimode = FALSE;
BOOL fsaredraw = 0;
GLfloat fsajitter = 0.0F;

int cmface = GL_FRONT;
int cmmode = GL_AMBIENT_AND_DIFFUSE;
int cmenable = FALSE;

BOOL tex_enable = FALSE;          //************
BOOL texgen_enable = FALSE;
GLenum texenvmode = GL_DECAL;

long tex_pack = 0;
int tex_row = 0;
int tex_col = 0;
int tex_index = 0;
int tex_xpix = 0;
int tex_ypix = 0;
int tex_numpix = 0;
int tex_numcomp = 0;
GLfloat tex_minfilter = GL_NEAREST;
GLfloat tex_magfilter = GL_NEAREST;
unsigned char *Image = NULL;
unsigned char *TextureImage = NULL;

BOOL light_enable = TRUE;
int numInfLights = 0;
int numLocalLights = 0;
BOOL lighttwoside = FALSE;
GLfloat localviewmode = 0.0F;

/************************************************************************/
/******************* Function Prototypes ********************************/
/************************************************************************/
void CustomizeWnd (HINSTANCE, LPWININFO);
LONG APIENTRY MyWndProc(HWND, UINT, UINT, LONG);
void SubclassWindow (HWND, WNDPROC);
void UpdateWinTitle (HWND);
void myHScrollFunc (int);
BOOL  read_pm(char *);
void InitScene (LPSCENE);

/************************************************************************/
/******************* Code ***********************************************/
/************************************************************************/

void myHScrollFunc (int i)
{
    OldScrollPos = g_s.scroll_pos;
    g_s.scroll_pos = i;
    if (g_s.scroll_pos != OldScrollPos) 
    {
        if (pm_ready)
        {
            HRESULT hr;

            old_lod = pm_lod_level;
            pm_lod_level = (float) (g_s.scroll_pos/1000.0);
            DWORD nv = minV + DWORD((maxV - minV + 1) * pm_lod_level * 
                                    0.999999f);
            hr = pPMesh->SetNumVertices(nv);
            if (hr != S_OK)
                MessageBox (NULL, "SetNumVertices failed", "Error", MB_OK);
            DoGlStuff ();
        }
        UpdateWinTitle (g_wi.hWnd);
    }
}

void InitScene (LPSCENE lps)
{
    lps->hither = DEFHITHER;
    lps->yon = DEFYONDER;
    lps->scale = 1.0;
    lps->angle = 0.0;
    lps->scroll_pos = 0; //auxGetScrollPos (AUX_HSCROLL);

    lps->from[0] /*X*/ = 0.0;
    lps->from[1] /*Y*/ = 0.0;
    lps->from[2] /*Z*/ = 5.0;
    
    lps->to[0] /*X*/ = 0.0;
    lps->to[1] /*Y*/ = 0.0;
    lps->to[2] /*Z*/ = 0.0;

    lps->up[0] /*X*/ = 0.0;
    lps->up[1] /*Y*/ = 1.0;
    lps->up[2] /*Z*/ = 0.0;
    
    lps->trans[0] /*X*/ = 0.0;
    lps->trans[1] /*Y*/ = 0.0;
    lps->trans[2] /*Z*/ = 0.0;

    lps->fov = 45.0;
    lps->aspect_ratio = 1.0;
    lps->zoom = 1.0;
}

void InitPM (void)
{
    HRESULT hr;

    hr = CreatePMeshGL(IID_IPMesh, (void**)&pPMesh, NULL, 0);
    if (hr == S_OK) 
    {
        hr = pPMesh->QueryInterface(IID_IPMeshGL, (LPVOID*)&pPMeshGL);
        if (hr != S_OK)
            MessageBox (NULL, "QI for IID_IPMeshGL failed", "Error", 
                        MB_OK);
    }
    else
    {
        MessageBox (NULL, "CreatePMeshGL failed", "Error", MB_OK);
    }
    
}

//*------------------------------------------------------------------------
//| WinMain:
//|     Parameters:
//|         hInstance     - Handle to current Data Segment
//|         hPrevInstance - Always NULL in Win32
//|         lpszCmdLine   - Pointer to command line info
//|         nCmdShow      - Integer value specifying how to start app.,
//|                            (Iconic [7] or Normal [1,5])
//*------------------------------------------------------------------------
int WINAPI WinMain (HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     lpszCmdLine,
                    int       nCmdShow)
{
    int nReturn = 0;

    g_wi.wSize.cx = WIN_WIDTH; 
    g_wi.wSize.cy = WIN_HEIGHT;
    
    auxInitDisplayMode (AUX_DEPTH | AUX_DOUBLE | AUX_RGB | AUX_HSCROLL);
    auxInitPosition (0, 0, WIN_WIDTH, WIN_HEIGHT);
    auxInitWindow ("Test");

    CustomizeWnd(hInstance, &g_wi);

    InitScene (&g_s);

    InitPM ();
    
    InitGL();
    
    auxReshapeFunc(SetViewWrap);

    auxIdleFunc(spin);

    auxHScrollFunc(myHScrollFunc);
    auxSetScrollPos (AUX_HSCROLL, auxGetScrollMin(AUX_HSCROLL));
    
    auxKeyFunc( AUX_UP, Key_up );
    auxKeyFunc( AUX_DOWN, Key_down );

    auxKeyFunc( AUX_i, Key_i );  //Initial Position

    auxKeyFunc( AUX_x, Key_x );  
    auxKeyFunc( AUX_X, Key_X );  

    auxKeyFunc( AUX_y, Key_y );  
    auxKeyFunc( AUX_Y, Key_Y );  

    auxKeyFunc( AUX_z, Key_z );  
    auxKeyFunc( AUX_Z, Key_Z );  

    //auxMouseFunc( AUX_LEFTBUTTON, AUX_MOUSEDOWN, trackball_MouseDown );
    //auxMouseFunc( AUX_LEFTBUTTON, AUX_MOUSEUP, trackball_MouseUp );

    //trackball_Init( g_wi.wSize.cx, g_wi.wSize.cy );

    auxMainLoop(DoGlStuff);
    
    return(0);
}


void CustomizeWnd(HINSTANCE hInstance, LPWININFO lpWI)
{
    HWND    hWnd;
    
    if ((hWnd = auxGetHWND()) == NULL) 
    {
        OutputDebugString("auxGetHWND() failed\n");
        return;
    }
    lpWI->hWnd = hWnd;
    
    SubclassWindow (hWnd, (WNDPROC) MyWndProc);
    SendMessage(hWnd, WM_USER, 0L, 0L);
    lpWI->hMenu = LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(APPMENU));
    SetMenu(hWnd, lpWI->hMenu);
    DrawMenuBar(hWnd);
    UpdateWinTitle (hWnd);
    
    lpWI->rmouse_down = FALSE;
    lpWI->rmouseX = 0;
    lpWI->rmouseY = 0;
    
    lpWI->lmouse_down = FALSE;
    lpWI->lmouseX = 0;
    lpWI->lmouseY = 0;
    
    lpWI->wPosition.x = (int) 0;
    lpWI->wPosition.y = (int) 0;

    return;
}

/**************************************************************************\
*  function:  SubclassWindow
*
*  input parameters:
*   hwnd            - window handle to be subclassed,
*   SubclassWndProc - the new window procedure.
*
\**************************************************************************/
VOID SubclassWindow (HWND hwnd, WNDPROC SubclassWndProc)
{
  LONG pfnOldProc;

  pfnOldProc = GetWindowLong (hwnd, GWL_WNDPROC);

  SetWindowLong (hwnd, GWL_USERDATA, (LONG) pfnOldProc);
  SetWindowLong (hwnd, GWL_WNDPROC,  (LONG) SubclassWndProc);
  UpdateWinTitle (hwnd);
}


/**************************************************************************\
*
*  function:  MyWndProc
*
*  input parameters:  normal window procedure parameters.
*
\**************************************************************************/
LONG APIENTRY MyWndProc(HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
  WNDPROC     pfnOldProc;
  static UINT uiTmID = 0;
  
  pfnOldProc = (WNDPROC) GetWindowLong (hwnd, GWL_USERDATA);
  switch (message) {
    case WM_INITMENUPOPUP: 
      EnableMenuItem (g_wi.hMenu, MENU_POINT, MF_GRAYED);
      CheckMenuItem (g_wi.hMenu, MENU_WIREFRAME, 
                     ((edge_mode) ? MF_CHECKED : MF_UNCHECKED));
      CheckMenuItem (g_wi.hMenu, MENU_SOLID, 
                     ((filled_mode) ? MF_CHECKED : MF_UNCHECKED));
      CheckMenuItem (g_wi.hMenu, MENU_FLAT, 
                     ((shade_model == GL_FLAT)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_wi.hMenu, MENU_GOURAUD, 
                     ((shade_model == GL_SMOOTH)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_wi.hMenu, MENU_LIGHTING,
                     ((light_enable)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_wi.hMenu, MENU_DEPTH,
                     ((depth_mode)? MF_CHECKED:MF_UNCHECKED));
      if (!cull_enable)
      {
          EnableMenuItem (g_wi.hMenu, MENU_FRONTFACE, MF_GRAYED);
          EnableMenuItem (g_wi.hMenu, MENU_BACKFACE, MF_GRAYED);
          CheckMenuItem (g_wi.hMenu, MENU_CULL, MF_UNCHECKED);
      }
      else
      {
          EnableMenuItem (g_wi.hMenu, MENU_FRONTFACE, MF_ENABLED);
          EnableMenuItem (g_wi.hMenu, MENU_BACKFACE, MF_ENABLED);
          CheckMenuItem (g_wi.hMenu, MENU_CULL, MF_CHECKED);
      }
      
      CheckMenuItem (g_wi.hMenu, MENU_BACKFACE,
                     ((cull_face==GL_BACK)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_wi.hMenu, MENU_FRONTFACE,
                     ((cull_face==GL_FRONT)? MF_CHECKED:MF_UNCHECKED));
      
      CheckMenuItem (g_wi.hMenu, MENU_CCW,
                     ((front_face==GL_CCW)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_wi.hMenu, MENU_CW,
                     ((front_face==GL_CW)? MF_CHECKED:MF_UNCHECKED));
      break;
      
    case WM_COMMAND: 

      switch (LOWORD(wParam))
      {
        case MENU_STATS:
          if (pm_ready)
          {
              DWORD nv, nf, mv, mf;
              char str[100];
              HRESULT hr;
              
              hr = pPMesh->GetNumFaces (&nf);
              if (hr != S_OK)
                  MessageBox (NULL, "GetNumFaces failed", "Error", MB_OK);
              hr = pPMesh->GetNumVertices (&nv);
              if (hr != S_OK)
                  MessageBox (NULL, "GetNumVertices failed", "Error", MB_OK);
              hr = pPMesh->GetMaxFaces (&mf);
              if (hr != S_OK)
                  MessageBox (NULL, "GetMaxFaces failed", "Error", MB_OK);
              hr = pPMesh->GetMaxVertices (&mv);
              if (hr != S_OK)
                  MessageBox (NULL, "GetMaxVertices failed", "Error", MB_OK);

              sprintf (str, "NumVerts = %d, NumFaces = %d\nMaxVerts = %d, MaxFaces = %d", nv, nf, mv, mf);
              MessageBox (NULL, str, "Stats", MB_OK);
          }
          
          break;  // Not Implemented
        case MENU_FILE_OPEN_PMESH:
          {
              HRESULT hr;
            
              char* file = OpenPMFile(hwnd, "Open a PMesh file", 1);
              if (!file) break;
              hr = pPMesh->Load(file, NULL, &minV, &maxV, NULL);
              if (hr != S_OK)
              {
                  pm_ready = FALSE;
                  MessageBox (NULL, "Load failed", "Error", MB_OK);
              }
              else
              {
                  char str[100];
                  pm_ready = TRUE;
                  sprintf (str, "Max = %d; Min = %d", maxV, minV);
                  MessageBox (NULL, str, "Info", MB_OK);
              }
              break;
          }
            
          break;  // Not Implemented
        case MENU_EXIT:
          PostMessage (hwnd, WM_CLOSE, 0, 0);
          break;  
        case MENU_POINT:
          break;  
        case MENU_CULL:
          cull_enable = !cull_enable;
          if (cull_enable)
              glEnable (GL_CULL_FACE);
          else
              glDisable (GL_CULL_FACE);
          break;  
        case MENU_BACKFACE:
          cull_face = GL_BACK;
          if (cull_enable) glCullFace (cull_face);
          break;  
        case MENU_FRONTFACE:
          cull_face = GL_FRONT;
          if (cull_enable) glCullFace (cull_face);
          break;  
        case MENU_CCW:
          front_face = GL_CCW;
          glFrontFace (front_face);
          break;  
        case MENU_CW:
          front_face = GL_CW;
          glFrontFace (front_face);
          break;  
        case MENU_WIREFRAME:
          edge_mode = !edge_mode;
          break;
        case MENU_DEPTH:
          depth_mode = !depth_mode;
          if (depth_mode) 
          {
              glEnable(GL_DEPTH_TEST);
              glDepthFunc(GL_LESS);
              glDepthMask(GL_TRUE);
          }
          else 
          {
              glDisable(GL_DEPTH_TEST);
              glDepthMask(GL_FALSE);
          }
          break;
        case MENU_SOLID:
          filled_mode = !filled_mode;
          break;
        case MENU_FLAT:
          shade_model = GL_FLAT;
          glShadeModel (GL_FLAT);
          break;
        case MENU_GOURAUD:
          shade_model = GL_SMOOTH;
          glShadeModel (GL_SMOOTH);
          break;
        case MENU_LIGHTING:
          light_enable = !light_enable;
          if (light_enable)
              EnableLighting ();
          else
              DisableLighting ();
          
          break;
        default:
          MessageBox (NULL, "Not yet implemented\r\n", "Warning", MB_OK);
          return 0;
      }
      break;

    case WM_RBUTTONDOWN:
        SetCapture(hwnd);
        g_wi.rmouseX = LOWORD (lParam);
        g_wi.rmouseY = HIWORD (lParam);
        g_wi.rmouse_down = TRUE;

        DoGlStuff ();
        break;

    case WM_RBUTTONUP:
        ReleaseCapture();
        g_wi.rmouse_down = FALSE;

        DoGlStuff ();
        break;

    case WM_LBUTTONDOWN:
        SetCapture(hwnd);
        g_wi.lmouseX = LOWORD (lParam);
        g_wi.lmouseY = HIWORD (lParam);
        g_wi.lmouse_down = TRUE;

        DoGlStuff ();
        break;

    case WM_LBUTTONUP:
        ReleaseCapture();
        g_wi.lmouse_down = FALSE;

        DoGlStuff ();
        break;

    case WM_MOVE:
        g_wi.wPosition.x = (int) LOWORD(lParam);
        g_wi.wPosition.y = (int) HIWORD(lParam);

        break;

    case WM_USER:
    case WM_DESTROY:
    default:
        return (pfnOldProc)(hwnd, message, wParam, lParam);

  } /* end switch */
  //DoGlStuff ();
  
  return 0;        
}
  
void UpdateWinTitle (HWND hwnd)
{
    char str[100];

    sprintf (str, "LOD=%f", pm_lod_level);
    SetWindowText (hwnd, str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\genexpld.c ===
/******************************Module*Header*******************************\
* Module Name: genexpld.c
*
* The Explode style of the 3D Flying Objects screen saver.
*
* Simulation of a sphere that occasionally explodes.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <GL\gl.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "ss3dfo.h"

#define RADIUS         	0.3
#define STEPS    	30
#define MAXPREC		20

static MATRIX *faceMat;
static float *xstep;
static float *ystep;
static float *zstep;
static float *xrot;
static float *yrot;
static float *zrot;
static MESH explodeMesh;
static int iPrec = 10;

static BOOL bOpenGL11;

// Data type accepted by glInterleavedArrays
typedef struct _POINT_N3F_V3F {
    POINT3D normal;
    POINT3D vertex;
} POINT_N3F_V3F;

static POINT_N3F_V3F *pN3V3;

static GLfloat matl1Diffuse[] = {1.0f, 0.8f, 0.0f, 1.0f};
static GLfloat matl2Diffuse[] = {0.8f, 0.8f, 0.8f, 1.0f};
static GLfloat matlSpecular[] = {1.0f, 1.0f, 1.0f, 1.0f};
static GLfloat light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f};

void genExplode()
{
    int i;
    POINT3D circle[MAXPREC+1];
    double angle;
    double step = -PI / (float)(iPrec - 1);
    double start = PI / 2.0;
    
    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        circle[i].x = (float) (RADIUS * cos(angle));
        circle[i].y = (float) (RADIUS * sin(angle));
        circle[i].z = 0.0f;
    }

    revolveSurface(&explodeMesh, circle, iPrec);

    for (i = 0; i < explodeMesh.numFaces; i++) {
        ss_matrixIdent(&faceMat[i]);
        xstep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        ystep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        zstep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        xrot[i] = 0.0f;
        yrot[i] = 0.0f;
        zrot[i] = 0.0f;
    }
}

void initExplodeScene()
{
    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 5)
        iPrec = 5;
    if (iPrec > MAXPREC)
        iPrec = MAXPREC;

    faceMat = (MATRIX *)SaverAlloc((iPrec * iPrec) * 
    				 (4 * 4 * sizeof(float)));
    xstep = SaverAlloc(iPrec * iPrec * sizeof(float));
    ystep = SaverAlloc(iPrec * iPrec * sizeof(float));
    zstep = SaverAlloc(iPrec * iPrec * sizeof(float));
    xrot = SaverAlloc(iPrec * iPrec * sizeof(float));
    yrot = SaverAlloc(iPrec * iPrec * sizeof(float));
    zrot = SaverAlloc(iPrec * iPrec * sizeof(float));
    
    genExplode();

    // Find out the OpenGL version that we are running on.
    bOpenGL11 = ss_fOnGL11();

    // Setup the data arrays.
    pN3V3 = SaverAlloc(explodeMesh.numFaces * 4 * sizeof(POINT_N3F_V3F));

    // If we are running on OpenGL 1.1, use the new vertex array functions.
    if (bOpenGL11) {
        glInterleavedArrays(GL_N3F_V3F, 0, pN3V3);
    }

    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, matl1Diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, matlSpecular);
    glMaterialf(GL_FRONT, GL_SHININESS, 100.0f);

    glMaterialfv(GL_BACK, GL_AMBIENT_AND_DIFFUSE, matl2Diffuse);
    glMaterialfv(GL_BACK, GL_SPECULAR, matlSpecular);
    glMaterialf(GL_BACK, GL_SHININESS, 60.0f);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-0.33, 0.33, -0.33, 0.33, 0.3, 3.0);

    glTranslatef(0.0f, 0.0f, -1.5f);
}


void delExplodeScene()
{
    delMesh(&explodeMesh);
    
    SaverFree(faceMat);
    SaverFree(xstep);
    SaverFree(ystep);
    SaverFree(zstep);
    SaverFree(xrot);
    SaverFree(yrot);
    SaverFree(zrot);
    SaverFree(pN3V3);
}

void updateExplodeScene(int flags)
{
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double mzrotInc = 0.0;
    static float maxR;
    static float r = 0.0f;
    static float rotZ = 0.0f;
    static int count = 0;
    static int direction = 1;
    static int restCount = 0;
    static float lightSpin = 0.0f;
    static float spinDelta = 5.0f;
    static int h = 0;
    static RGBA color;
    int i;
    MFACE *faces;
    POINT_N3F_V3F *pn3v3;


    if( gbBounce ) {
        // floating window bounced off an edge
        if (mxrotInc) {
            mxrotInc = 0.0;
            myrotInc = 0.1;
        } else if (myrotInc) {
            myrotInc = 0.0;
            mzrotInc = 0.1;
        } else if (mzrotInc) {
            mzrotInc = 0.0;
            mxrotInc = 0.1;
        }
        gbBounce = FALSE;
    }

    mxrot += mxrotInc;
    myrot += myrotInc;
    mzrot += mzrotInc;

    if (bColorCycle || h == 0) {
        ss_HsvToRgb((float)h, 1.0f, 1.0f, &color);

        glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &color);

        h++;
        h %= 360;
    }

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glRotatef(-lightSpin, 0.0f, 1.0f, 0.0f);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
    lightSpin += spinDelta;
    if ((lightSpin > 90.0) || (lightSpin < 0.0))
        spinDelta = -spinDelta;
    glPopMatrix();

    if (!bOpenGL11) {
        glBegin(GL_QUADS);
    }

    for(
        i = 0, faces = explodeMesh.faces, pn3v3 = pN3V3;
        i < explodeMesh.numFaces;
	i++, faces++, pn3v3 += 4
       ) {
        int a, b, c, d;
        int j;
        POINT3D vector;
        
        ss_matrixIdent(&faceMat[i]);
        ss_matrixRotate(&faceMat[i], xrot[i], yrot[i], zrot[i]);

        if (restCount)
            ;
        else {
            xrot[i] += (xstep[i]);
            yrot[i] += (ystep[i]);
            zrot[i] += (zstep[i]);
        } 

        a = faces->p[0];
        b = faces->p[1];
        c = faces->p[3];
        d = faces->p[2];
        
        memcpy(&pn3v3[0].vertex, (explodeMesh.pts + a), sizeof(POINT3D));
        memcpy(&pn3v3[1].vertex, (explodeMesh.pts + b), sizeof(POINT3D));
        memcpy(&pn3v3[2].vertex, (explodeMesh.pts + c), sizeof(POINT3D));
        memcpy(&pn3v3[3].vertex, (explodeMesh.pts + d), sizeof(POINT3D));

        vector.x = pn3v3[0].vertex.x;
        vector.y = pn3v3[0].vertex.y;
        vector.z = pn3v3[0].vertex.z;

        for (j = 0; j < 4; j++) {
            pn3v3[j].vertex.x -= vector.x;
            pn3v3[j].vertex.y -= vector.y;
            pn3v3[j].vertex.z -= vector.z;
            ss_xformPoint((POINT3D *)&pn3v3[j].vertex, (POINT3D *)&pn3v3[j].vertex, &faceMat[i]);
            pn3v3[j].vertex.x += vector.x + (vector.x * r);
            pn3v3[j].vertex.y += vector.y + (vector.y * r);
            pn3v3[j].vertex.z += vector.z + (vector.z * r);
        }
        if (bSmoothShading) {
            memcpy(&pn3v3[0].normal, (explodeMesh.norms + a), sizeof(POINT3D));
            memcpy(&pn3v3[1].normal, (explodeMesh.norms + b), sizeof(POINT3D));
            memcpy(&pn3v3[2].normal, (explodeMesh.norms + c), sizeof(POINT3D));
            memcpy(&pn3v3[3].normal, (explodeMesh.norms + d), sizeof(POINT3D));
           
            for (j = 0; j < 4; j++)
                ss_xformNorm((POINT3D *)&pn3v3[j].normal, (POINT3D *)&pn3v3[j].normal, &faceMat[i]);
        } else {            
            memcpy(&pn3v3[0].normal, &faces->norm, sizeof(POINT3D));
            ss_xformNorm((POINT3D *)&pn3v3[0].normal, (POINT3D *)&pn3v3[0].normal, &faceMat[i]);
            memcpy(&pn3v3[1].normal, &pn3v3[0].normal, sizeof(POINT3D));
            memcpy(&pn3v3[2].normal, &pn3v3[0].normal, sizeof(POINT3D));
            memcpy(&pn3v3[3].normal, &pn3v3[0].normal, sizeof(POINT3D));
        }

        if (!bOpenGL11) {
            if (bSmoothShading) {
                glNormal3fv((GLfloat *)&pn3v3[0].normal);
                glVertex3fv((GLfloat *)&pn3v3[0].vertex);
                glNormal3fv((GLfloat *)&pn3v3[1].normal);
                glVertex3fv((GLfloat *)&pn3v3[1].vertex);
                glNormal3fv((GLfloat *)&pn3v3[2].normal);
                glVertex3fv((GLfloat *)&pn3v3[2].vertex);
                glNormal3fv((GLfloat *)&pn3v3[3].normal);
                glVertex3fv((GLfloat *)&pn3v3[3].vertex);
            } else {
                glNormal3fv((GLfloat *)&pn3v3[0].normal);
                glVertex3fv((GLfloat *)&pn3v3[0].vertex);
                glVertex3fv((GLfloat *)&pn3v3[1].vertex);
                glVertex3fv((GLfloat *)&pn3v3[2].vertex);
                glVertex3fv((GLfloat *)&pn3v3[3].vertex);
            }
        }
    }

    if (bOpenGL11) {
        glDrawArrays(GL_QUADS, 0, explodeMesh.numFaces * 4);
    } else {
        glEnd();
    }

    if (restCount) {
        restCount--;
        goto resting;
    }

    if (direction) {
        maxR = r;
        r += (float) (0.3 * pow((double)(STEPS - count) / (double)STEPS, 4.0));
    } else {
        r -= (float) (maxR / (double)(STEPS));
    }

    count++;
    if (count > STEPS) {
        direction ^= 1;
        count = 0;

        if (direction == 1) {
            restCount = 10;
            r = 0.0f;

            for (i = 0; i < explodeMesh.numFaces; i++) {
                ss_matrixIdent(&faceMat[i]);
                xstep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                ystep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                zstep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                
                xrot[i] = 0.0f;
                yrot[i] = 0.0f;
                zrot[i] = 0.0f;
            }
        }
    }

resting:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\genlem.c ===
/******************************Module*Header*******************************\
* Module Name: genlem.c
*
* The Twist style of the 3D Flying Objects screen saver.
*
* Solid model of a 3D lemniscate.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <GL\gl.h>
#include <string.h>
#include <math.h>
#include "ss3dfo.h"
#include "mesh.h"

#define ROT_PREC    10
#define NORMS(x, y) lemMesh.norms[((x) * iPrec) + y]
#define GRID(x, y)  lemMesh.pts[((x) * iPrec) + y]

static MESH lemMesh;
static POINT3D basis[ROT_PREC];
static double zrot = 0.2;
static int iPrec = 32;
static double *lemX;
static double *lemY;
static double *lemXT;
static double *lemYT;


static void getLem(double index, double max, double *angle, double *r)
{    
    double a, sina;

    a = (index * PI) / (max - 1.0);
    if (a >= PI)
        a -= PI;
    if (a > PI / 2.0) {
        *angle = (2.0 * PI) - a;
        sina = sin( 2.0 * *angle );
        if( sina < 0.0 )
            sina = 0.0; // protect against sqrt fpe
        *r = 0.5 * sqrt(sina);
    } else {
        *angle = a;
        sina = sin( 2.0 * *angle );
        if( sina < 0.0 )
            sina = 0.0;
        *r = 0.5 * sqrt(sina);
    }
}            


static void initLemCoords(int iMax)
{
    int i;
    double max = (double)iMax;
    double angle;
    double r;

    for (i = 0; i < iMax; i++) {
        getLem((double)i, (double)iPrec, &angle, &r);        
        lemX[i] = r * cos(angle);
        lemY[i] = r * sin(angle);
        
        getLem((double)i + 0.00001, (double)iPrec, &angle, &r);        
        lemXT[i] = r * cos(angle);
        lemYT[i] = r * sin(angle);

    }
}


void genLemniscate(void)
{
    int i;
    int j;
    double posInc = 2.0 / (float)iPrec;
    int facecount = 0;
    int ptcount = 0;
    POINT3D norm;
    static float twistFact = 0.0f;
    static float twistFactAdd = 0.05f;
    POINT3D a[ROT_PREC];
    POINT3D b[ROT_PREC];
    MATRIX matrix;
    MESH *mesh = &lemMesh;

    mesh->numPoints = 0;   
    mesh->numFaces = 0;   
    for (i = 0; i < (iPrec - 1) * (ROT_PREC - 1); i++)
        mesh->norms[i] = ss_ptZero;

    for (i = 0; i < (iPrec - 1); i++) {
        double x1, y1, x2, y2;
        double len;
        double sinAngle;
        double rotZ;
        int id[4];

        x1 = lemX[i];
        y1 = lemY[i];
        x2 = lemXT[i];
        y2 = lemYT[i];

        x2 -= x1;
        y2 -= y1;

        len = sqrt(x2 * x2 + y2 * y2);
        if (len > 0.0)
            sinAngle = y2 / len;
        else
            sinAngle = 0.0;
        if (y2 < 0.0)
            sinAngle = -sinAngle;
        rotZ = asin(sinAngle);
        if (x2 < 0.0)
            rotZ = PI - rotZ;
        if (y2 < 0.0)
            rotZ = -rotZ;
        if (rotZ < 0.0)
            rotZ = 2.0 * PI + rotZ;

        ss_matrixIdent(&matrix);
        ss_matrixRotate(&matrix, 0.0, 0.0, -rotZ);
        ss_matrixTranslate(&matrix, x1, y1, 
                         twistFact * cos((2.0 * PI * (float)i) / ((float)iPrec - 1)));
        
        for (j = 0; j < ROT_PREC; j++)
            ss_xformPoint(&a[j], &basis[j], &matrix);

        x1 = lemX[i+1];
        y1 = lemY[i+1];

        x2 = lemXT[i+1];
        y2 = lemYT[i+1];

        x2 -= x1;
        y2 -= y1;

        len = sqrt(x2 * x2 + y2 * y2);

        if (len > 0.0)
            sinAngle = y2 / len;
        else
            sinAngle = 0.0;
        if (y2 < 0.0)
            sinAngle = -sinAngle;
        rotZ = asin(sinAngle);
        if (x2 < 0.0)
            rotZ = PI - rotZ;
        if (y2 < 0.0)
            rotZ = -rotZ;
        if (rotZ < 0.0)
            rotZ = 2.0 * PI + rotZ;

        ss_matrixIdent(&matrix);
        ss_matrixRotate(&matrix, 0.0, 0.0, -rotZ);        
        ss_matrixTranslate(&matrix, x1, y1, 
                         twistFact * cos((2.0 * PI * ((float)i + 1.0)) / ((float)iPrec - 1)));

        for (j = 0; j < ROT_PREC; j++)
            ss_xformPoint(&b[j], &basis[j], &matrix);
            
        memcpy(&mesh->pts[ptcount], &a, sizeof(POINT3D) * (ROT_PREC - 1));
        ptcount += (ROT_PREC - 1);
        mesh->numPoints += (ROT_PREC - 1);
        
            
        for (j = 0; j < (ROT_PREC - 1); j++) {
            int k;
            int jj;
            
            if (j == (ROT_PREC - 2))
                jj = 0;
            else
                jj = j + 1;

            ss_calcNorm(&norm, &b[j + 1], &b[j], &a[j]);
            
            mesh->faces[facecount].material = 3;
            mesh->faces[facecount].norm = norm;
            if (i == iPrec - 2) {
                id[0] = mesh->faces[facecount].p[0] = j;
                id[1] = mesh->faces[facecount].p[1] = jj;
            } else {
                id[0] = mesh->faces[facecount].p[0] = ptcount + j;
                id[1] = mesh->faces[facecount].p[1] = ptcount + jj;
            }
            id[2] = mesh->faces[facecount].p[2] = ptcount - (ROT_PREC - 1) + j;
            id[3] = mesh->faces[facecount].p[3] = ptcount - (ROT_PREC - 1) + jj;
            
            for (k = 0; k < 4; k++) {
                POINT3D *pn = &mesh->norms[id[k]];
                
                pn->x += norm.x;
                pn->y += norm.y;
                pn->z += norm.z;
            }
            mesh->numFaces++;
            facecount++;
        }
    }

    ss_normalizeNorms(lemMesh.norms, lemMesh.numPoints);
        
    if (twistFact >= 1.0f)
        twistFactAdd = -0.01f;
    else if (twistFact <= -1.0f)
        twistFactAdd = 0.01f;
    twistFact += twistFactAdd;
        
}

void initLemScene()
{
    int i;
    RGBA lightAmbient = {0.0f, 0.0f, 0.0f, 1.0f};

    iPrec = (int)(fTesselFact * 32.5);
    if (iPrec < 5)
        iPrec = 5;

    lemX = SaverAlloc(sizeof(double) * iPrec);
    lemY = SaverAlloc(sizeof(double) * iPrec);
    lemXT = SaverAlloc(sizeof(double) * iPrec);
    lemYT = SaverAlloc(sizeof(double) * iPrec);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);

    newMesh(&lemMesh, (ROT_PREC - 1) * (iPrec - 1) , 
            (ROT_PREC - 1) * (iPrec - 1));
    for (i = 0; i < ROT_PREC; i++) {
        basis[i].x = 0.0f;
        basis[i].y = (float) (0.15 * cos((i * 2.0 * PI) / (ROT_PREC - 1.0)));
        basis[i].z = (float) (0.15 * sin((i * 2.0 * PI) / (ROT_PREC - 1.0)));
    }

    initLemCoords(iPrec);

    glFrontFace(GL_CW);
    glEnable(GL_CULL_FACE);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (GLfloat *) &lightAmbient);

    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                 (GLfloat *) &Material[3].kd);
}

void delLemScene()
{
    delMesh(&lemMesh);

    SaverFree(lemX);
    SaverFree(lemY);
    SaverFree(lemXT);
    SaverFree(lemYT);
}

void updateLemScene(int flags)
{
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double zrotInc = 0.1;
    static double mzrotInc = 0.0;
    static int h = 0;
    RGBA color;
    MATRIX model;
    
    mxrot += mxrotInc;
    myrot += myrotInc;
    mzrot += mzrotInc;

    if( gbBounce ) {
        // floating window bounced off an edge
        if (mxrotInc) {
            mxrotInc = 0.0;
            myrotInc = 0.1;
        } else if (myrotInc) {
            myrotInc = 0.0;
            mzrotInc = 0.1;
        } else if (mzrotInc) {
            mzrotInc = 0.0;
            mxrotInc = 0.1;
        }
        gbBounce = FALSE;
    }

    zrot += zrotInc;
    if (zrot >= PI / 4.0) {
        zrot = PI / 4.0;
        zrotInc = -0.03;
    } else if (zrot <= -PI / 4.0) {
        zrot = -PI / 4.0;
        zrotInc = 0.03;
    }

    genLemniscate();

    if (bColorCycle) {
        ss_HsvToRgb((float)h, 1.0f, 1.0f, &color );

        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &color);

        h++;
        h %= 360;
    }

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);
    glRotatef((GLfloat) (zrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
    glRotatef(50.0f, 1.0f, 0.0f, 0.0f);
    glRotatef(50.0f, 0.0f, 0.0f, 1.0f);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0f, -0.5f, 0.0f);
    glRotatef((GLfloat) (mxrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f);
    glRotatef((GLfloat) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
    glRotatef((GLfloat) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f);

    ss_matrixIdent(&model);
    ss_matrixRotate(&model, mxrot, myrot, mzrot);
    ss_matrixTranslate(&model, 0.0, -0.5, 0.0);

    updateObject(&lemMesh, bSmoothShading);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\gendrop.c ===
/******************************Module*Header*******************************\
* Module Name: gendrop.c
*
* The Splash style of the 3D Flying Objects screen saver.
*
* Simulation of a drop of water falling into a pool of water.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <GL\gl.h>
#include <string.h>
#include <math.h>
#include "ss3dfo.h"
#include "mesh.h"

#define FLOAT_SMALL (1e-6)

#define DROPPREC   10

// Remember from pre-calc:
//      x = r cos th
//      y = r sin th
// to convert from polar to rect, and that
//      x = x' cos th - y' sin th
//      y = x' sin th + y' cos th
// to rotate axes.
//
// Also, note that the equation for a lemniscate is:
//      r = sqrt(sin 2*th)
//

static POINT3D *circle;
static POINT3D *drop;
static POINT3D *curves;
static MESH waterMesh;
static MESH waterInmesh;
static MESH waterOutmesh;
static MESH waterBorderMesh;
static MESH *drops;
static int iPrec;
static float fRadiusFact = 0.35f;

static GLfloat light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f};
static dropList[DROPPREC];

void genCurves()
{
    int i;
    double angle;
    double step = -PI / (float)(iPrec - 1);
    double start = PI / 2.0;
    double rotSin = sin(PI / 4.0);
    double rotCos = cos(PI / 4.0);
    double aFract = 0.0;
    double bFract = 1.0;
    double fractInc = 1.0 / (double)(iPrec - 1);
    POINT3D *pt = curves;

    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        circle[i].x = (float) (0.5 * cos(angle));
        circle[i].y = (float) (0.5 * sin(angle));
    }

    step = (-PI / 4.0) / (float)(iPrec - 1);
    start = PI / 4.0;

    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        double x, y, r;
        double xrot, yrot;
        double sinVal;

        sinVal = sin(2.0 * angle);
        if (sinVal < 0.0)
            sinVal = -sinVal;

        r = 1.5 * sqrt(sinVal);
        x = r * cos(angle);
        y = r * sin(angle);

        xrot = x * rotCos - y * rotSin;
        yrot = x * rotSin + y * rotCos - 1.0;

        drop[i].x = (float) xrot;
        drop[i].y = (float) yrot;
    }


    for (i = 0; i < DROPPREC; i++) {
        int j;

        for (j = 0; j < iPrec; j++, pt++) {
            pt->x = (float) (aFract * circle[j].x +
                             bFract * drop[j].x);

            pt->y = (float) (aFract * circle[j].y +
                             bFract * drop[j].y);

            pt->z = 0.0f;
        }
        aFract += fractInc;
        bFract -= fractInc;
    }
}

#define NORMS(x, y) waterMesh.norms[((x) * iPrec) + y]
#define BNORMS(x, y) waterBorderMesh.norms[((x) * iPrec) + y]
#define INGRID(x, y)  waterInmesh.pts[((x) * iPrec) + y]
#define OUTGRID(x, y)  waterOutmesh.pts[((x) * iPrec) + y]
#define GRID(x, y)  waterMesh.pts[((x) * iPrec) + y]
#define BGRID(x, y)  waterBorderMesh.pts[((x) * iPrec) + y]

void genWater(double freq, double damp, double mag, double w, double minr)
{
    int i;
    int j;
    double r;
    double theta;
    double thetaInc = (2.0 * PI) / (float)iPrec;
    double posInc = 1.0 / (float)iPrec;
    int facecount;
    double xCenter = 0.0;
    double zCenter = 0.0;
    POINT3D norm;
    static BOOL first = TRUE;

    if (first) {
        for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
            for (j = 0, theta = 0.0; j < iPrec; j++, theta += thetaInc) {
                float x, z;
                float dx, dz;
                float rr;

                x = (float) cos(theta);
                z = (float) sin(theta);

                dx = x - (float) xCenter;
                dz = z - (float) zCenter;

                rr = (float) sqrt((dx * dx) + (dz * dz));
                dx /= rr;
                dz /= rr;
                dx *= i / (float)(iPrec - 1);
                dz *= i / (float)(iPrec - 1);
                GRID(i, j).x = dx + (float) xCenter;
                GRID(i, j).z = dz + (float) zCenter;

                INGRID(i, j).y = 0.0f;
                OUTGRID(i, j).y = 0.0f;
            }
        }
    }


    for (i = (iPrec - 1), r = 1.0; i >= 0; i--, r -= posInc) {
        float val;

        if (i == 0) {
            if (minr != 0.0)
                val = (float) (-mag * cos(w + (r * freq)) * exp((-damp * r)/2.0));
            else
                val =  INGRID(0, 0).y * 0.95f;
        } else
            val = OUTGRID(i - 1, 0).y * 0.95f;

        for (j = 0; j < iPrec; j++)
            OUTGRID(i, j).y = val;
    }


    for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
        for (j = 0; j < iPrec; j++) {
            if (i == iPrec-1)
                INGRID(i, j).y = -OUTGRID(i, j).y;
            else
                INGRID(i, j).y = INGRID(i + 1, j).y * 0.95f;
        }
    }


    waterMesh.numFaces = 0;
    waterBorderMesh.numFaces = 0;

    for (i = 0; i < iPrec; i++) {
        for (j = 0; j < iPrec; j++) {
            NORMS(i, j).x = 0.0f;
            NORMS(i, j).y = 0.0f;
            NORMS(i, j).z = 0.0f;
        }
    }

    for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
        for (j = 0, theta = 0.0; j < iPrec; j++, theta += thetaInc) {
            GRID(i, j).y = OUTGRID(i, j).y + INGRID(i, j).y;


            if (i == (iPrec - 1)) {
                GRID(i, j).y = 0.0f;

                BGRID(0, j).x = GRID(i, j).x;
                BGRID(0, j).z = GRID(i, j).z;
                BGRID(0, j).y = GRID(i, j).y;

                BGRID(1, j).x = GRID(i, j).x;
                BGRID(1, j).z = GRID(i, j).z;
                BGRID(1, j).y = -0.5f;
            }
        }
    }

    for (i = 0; i < 2; i++) {
        for (j = 0; j < iPrec; j++) {
            BNORMS(i, j).x = 0.0f;
            BNORMS(i, j).y = 0.0f;
            BNORMS(i, j).z = 0.0f;
        }
    }

    for (facecount = 0, i = 0; i < (iPrec - 1); i++) {
        for (j = 0; j < iPrec; j++) {
            int k, l;

            k = i + 1;

            if (j == (iPrec - 1))
                l = 0;
            else
                l = j + 1;

            ss_calcNorm(&norm, &GRID(k, j), &GRID(i, j), &GRID(i, l));

            if (norm.x > -FLOAT_SMALL && norm.x < FLOAT_SMALL &&
                norm.y > -FLOAT_SMALL && norm.y < FLOAT_SMALL &&
                norm.z > -FLOAT_SMALL && norm.z < FLOAT_SMALL)
                ss_calcNorm(&norm, &GRID(i, l), &GRID(k, l), &GRID(k, j));


            waterMesh.faces[facecount].material = 0;
            waterMesh.faces[facecount].norm = norm;

            NORMS(i, j).x += norm.x;
            NORMS(i, j).y += norm.y;
            NORMS(i, j).z += norm.z;

            NORMS(k, j).x += norm.x;
            NORMS(k, j).y += norm.y;
            NORMS(k, j).z += norm.z;

            NORMS(i, l).x += norm.x;
            NORMS(i, l).y += norm.y;
            NORMS(i, l).z += norm.z;

            NORMS(k, l).x += norm.x;
            NORMS(k, l).y += norm.y;
            NORMS(k, l).z += norm.z;

            waterMesh.faces[facecount].p[0] = (k * iPrec) + j;
            waterMesh.faces[facecount].p[1] = (i * iPrec) + j;
            waterMesh.faces[facecount].p[2] = (k * iPrec) + l;
            waterMesh.faces[facecount].p[3] = (i * iPrec) + l;
            waterMesh.numFaces++;
            facecount++;
        }
    }

    waterMesh.numPoints = iPrec * iPrec;

    for (facecount = 0, i = 0; i < 1; i++) {
        for (j = 0; j < iPrec; j++) {
            int k, l;

            k = i + 1;

            if (j == (iPrec - 1))
                l = 0;
            else
                l = j + 1;

            ss_calcNorm(&norm, &BGRID(k, j), &BGRID(i, j), &BGRID(i, l));

            waterBorderMesh.faces[facecount].material = 0;
            waterBorderMesh.faces[facecount].norm = norm;

// Setting SMOOTH_BORDER will render the border (the sides of the "pool")
// with smooth shading.  This effect is good at higher tesselations, but
// doesn't really look that good for low tesselations.
//
// A possible enhancement for later: use smooth shading if tesselation
// exceeds some threshold.  Should we just pick some arbitrary threshold?
// Make it a setup option?  Things look pretty good now, so don't bother?

#if SMOOTH_BORDER
            BNORMS(i, j).x += norm.x;
            BNORMS(i, j).y += norm.y;
            BNORMS(i, j).z += norm.z;

            if (i) {
                BNORMS(i-1, j).x += norm.x;
                BNORMS(i-1, j).y += norm.y;
                BNORMS(i-1, j).z += norm.z;
            }
            if (j) {
                BNORMS(i, j-1).x += norm.x;
                BNORMS(i, j-1).y += norm.y;
                BNORMS(i, j-1).z += norm.z;
            }

            BNORMS(k, j).x += norm.x;
            BNORMS(k, j).y += norm.y;
            BNORMS(k, j).z += norm.z;

            BNORMS(i, l).x += norm.x;
            BNORMS(i, l).y += norm.y;
            BNORMS(i, l).z += norm.z;
#else
            BNORMS(i, j) = norm;

            if (i)
                BNORMS(i-1, j) = norm;
            if (j)
                BNORMS(i, j-1) = norm;

            BNORMS(k, j) = norm;
            BNORMS(i, l) = norm;
#endif

            waterBorderMesh.faces[facecount].p[0] = (k * iPrec) + j;
            waterBorderMesh.faces[facecount].p[1] = (i * iPrec) + j;
            waterBorderMesh.faces[facecount].p[2] = (k * iPrec) + l;
            waterBorderMesh.faces[facecount].p[3] = (i * iPrec) + l;
            waterBorderMesh.numFaces++;
            facecount++;
        }
    }
    waterBorderMesh.numPoints = 2 * iPrec;

    ss_normalizeNorms(waterBorderMesh.norms, waterBorderMesh.numPoints);
    ss_normalizeNorms(waterMesh.norms, waterMesh.numPoints);

    first = FALSE;
}


void initDropScene()
{
    int i;

    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 4)
        iPrec = 4;

    if (fTesselFact > fRadiusFact)
        fRadiusFact = fTesselFact;

    circle = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D));
    drop = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D));
    curves = (POINT3D *)SaverAlloc(DROPPREC * iPrec * sizeof(POINT3D));
    drops = (MESH *)SaverAlloc(DROPPREC * sizeof(MESH));

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glTranslatef(0.0f, 0.0f, -1.5f);

    glDisable(GL_CULL_FACE);

    newMesh(&waterInmesh, iPrec * iPrec, iPrec * iPrec + iPrec);
    newMesh(&waterOutmesh, iPrec * iPrec, iPrec * iPrec + iPrec);
    newMesh(&waterMesh, iPrec * iPrec, iPrec * iPrec + iPrec);
    newMesh(&waterBorderMesh, iPrec, 2 * iPrec);
    genCurves();

    for (i = 0; i < DROPPREC; i++)
        revolveSurface(&drops[i], &curves[i * iPrec], iPrec);
    for (i = 0; i < DROPPREC; i++) {
        GLuint id = 0x10 + i;
        dropList[i] = id;
        MakeList(id, &drops[i]);
    }
    for (i = 0; i < DROPPREC; i++) {
        delMesh(&drops[i]);
    }

    SaverFree(circle);
    SaverFree(drop);
    SaverFree(curves);
    SaverFree(drops);
}

void delDropScene()
{
    delMesh(&waterMesh);
    delMesh(&waterInmesh);
    delMesh(&waterOutmesh);
    delMesh(&waterBorderMesh);
}

void updateDropScene(int flags)
{
    static double zrot = 0.0;
    static double yrot = 0.0;
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double zrotInc = 3.0;
    static double yrotInc = 1.5;
    static double mzrotInc = 0.0;
    static double ypos = 1.0;
    static int dropnum = 0;
    static double radius = 0.3;
    static double damp = 1.0;
    static double mag = 0.0;
    static double w = 1.0;
    static double freq = 1.0;
    static double dist;
    static double minr = 0.0;
    static int h = 0;
    RGBA color;

    glPushMatrix();

    zrot += zrotInc;
    if (zrot >= 45.0) {
        zrot = 45.0;
        zrotInc = -(2.0 + ((float)rand() / (float)RAND_MAX) * 3.0);
    } else if (zrot <= -45.0) {
        zrot = -45.0;
        zrotInc = 2.0 + ((float)rand() / (float)RAND_MAX) * 3.0;
    }

    yrot += yrotInc;
    if (yrot >= 10.0) {
        yrot = 10.0;
        yrotInc = -(1.0 + ((float)rand() / (float)RAND_MAX) * 2.0);
    } else if (zrot <= -10.0) {
        yrot = -10.0;
        yrotInc = 1.0 + ((float)rand() / (float)RAND_MAX) * 2.0;
    }

    if ((ypos + 0.5 < -radius) && (mag < 0.05)) {
        radius = (float)rand() / (6.0 * (float)RAND_MAX) + 0.1;
        ypos = 1.0;
        dropnum = 0;
    }

    dist = (ypos + 0.5);

    if ((dist > -radius / 2.0) && (dist < radius / 2.0)) {
        if (dist <= 0.0)
            dist = radius / 2.0;
        else
            dist = (radius / 2.0) - dist;
        freq = (0.25 * PI) / dist;
        if (freq < 0.2)
            freq = 0.2;

        minr = radius;

        damp = 20.0;
        mag = (0.35 / fRadiusFact) + 0.2 * dist;

        w = 0;
    } else {
        minr -= 0.05;
        if (minr < 0.0)
            minr = 0.0;

        mag = mag * 0.95;
        if (minr == 0.0) {
            w -= (PI / 6.0);
            mag *= 0.75;
        }
        if (damp > 0.0)
            damp -= 1.0;
    }

    genWater(freq, damp, mag, w, minr);

    glRotatef((GLfloat) zrot, 0.0f, 0.0f, 1.0f);
    glRotatef(30.0f, 1.0f, 0.0f, 0.0f);

    glPushMatrix();
    glTranslatef(0.0f, -0.5f, 0.0f);
    glRotatef((GLfloat) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);

    if (bColorCycle) {
        ss_HsvToRgb((float)h, 1.0f, 1.0f, &color );

        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (GLfloat *) &color);
        h++;
        h %= 360;
    } else {
        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (GLfloat *) &Material[6].kd);
    }

    updateObject(&waterMesh, bSmoothShading);

    if (bSmoothShading)
        glShadeModel(GL_FLAT);

    if (!bColorCycle)
        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (GLfloat *) &Material[2].kd);

    updateObject2(&waterBorderMesh, FALSE);
    glPopMatrix();

    if (bSmoothShading)
        glShadeModel(GL_SMOOTH);

    if (dist > -radius) {

        if (!bColorCycle)
            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                         (GLfloat *) &Material[6].kd);
        glTranslatef(0.0f, (GLfloat) ypos, 0.0f);
        glScalef((GLfloat) radius, (GLfloat) radius, (GLfloat) radius);
        glRotatef(180.0f, 1.0f, 0.0f, 0.0f);
        glEnable(GL_NORMALIZE);
        glCallList(dropList[dropnum]);
        glDisable(GL_NORMALIZE);

    }

    myrot += myrotInc;

    ypos -= 0.08;
    dropnum = (int) ((DROPPREC - 1) - (ypos * (DROPPREC - 1)));
    if (dropnum > (DROPPREC - 1))
        dropnum = DROPPREC - 1;

    glPopMatrix();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\gentex.c ===
/******************************Module*Header*******************************\
* Module Name: gentex.c
*
* The Textured Flag style of the 3D Flying Objects screen saver.
*
* Texture maps .BMP files onto a simulation of a flag waving in the breeze.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <GL\gl.h>
#include <GL\glu.h>
#include <string.h>
#include <math.h>
#include "ss3dfo.h"

static float winTotalwidth = (float)0.75;
static float winTotalheight = (float)0.75 * (float)0.75;

#define MAX_FRAMES 20

// IPREC is the number of faces in the mesh that models the flag.

#define IPREC   15

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static float sinAngle = (float)0.0;
static float xTrans = (float)0.0;
static int curMatl = 0;

// Material properties.

static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};
static RGBA matlDimSpecular    = {0.5f, 0.5f, 0.5f, 1.0f};
static RGBA matlNoSpecular     = {0.0f, 0.0f, 0.0f, 0.0f};

// Lighting properties.

static GLfloat light0Pos[] = {20.0f, 5.0f, 20.0f, 0.0f};
static GLfloat light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f};
static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f};
static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f};
static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f};

static RGBA flagColors[] = {{1.0f, 1.0f, 1.0f, 1.0f},
                            {0.94f, 0.37f, 0.13f, 1.0f},    // red
                           };

// Default texture resource

static TEX_RES gTexRes = { TEX_BMP, IDB_DEFTEX };

static TEXTURE gTex = {0}; // One global texture

/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/

static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }

    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}

/******************************Public*Routine******************************\
* getZpos
*
* Get the z-position (depth) of the "wavy" flag component at the given x.
*
* The function used to model the wave is:
*
*        1/2
*   z = x    * sin((2*PI*x + sinAngle) / 4)
*
* The shape of the wave varies from frame to frame by changing the
* phase, sinAngle.
*
\**************************************************************************/

float getZpos(float x)
{
    float xAbs = x - xTrans;
    float angle = sinAngle + ((float) (2.0 * PI) * (xAbs / winTotalwidth));

    xAbs = winTotalwidth - xAbs;
//    xAbs += (winTotalwidth / 2.0);

    return (float)((sin((double)angle) / 4.0) *
                   sqrt((double)(xAbs / winTotalwidth )));
}

/******************************Public*Routine******************************\
* genTex
*
* Generate a mesh representing a frame of the flag.  The phase, sinAngle,
* is a global variable.
*
\**************************************************************************/

void genTex(MESH *winMesh)
{
    POINT3D pos;
    POINT3D pts[4];
    float w, h;
    int i;

    newMesh(winMesh, IPREC * IPREC, IPREC * IPREC);

// Width and height of each face

    w = (winTotalwidth) / (float)(IPREC + 1);
    h = winTotalheight;

// Generate the mesh data.  At equally spaced intervals along the x-axis,
// we compute the z-position of the flag surface.

    pos.y = (float) 0.0;
    pos.z = (float) 0.0;

    for (i = 0, pos.x = xTrans; i < IPREC; i++, pos.x += w) {
        int faceCount = winMesh->numFaces;

        pts[0].x = (float)pos.x; 
        pts[0].y = (float)(pos.y);   
        pts[0].z = getZpos(pos.x);

        pts[1].x = (float)pos.x;
        pts[1].y = (float)(pos.y + h);  
        pts[1].z = getZpos(pos.x);

        pts[2].x = (float)(pos.x + w);  
        pts[2].y = (float)(pos.y);  
        pts[2].z = getZpos(pos.x + w);

        pts[3].x = (float)(pos.x + w);
        pts[3].y = (float)(pos.y + h);
        pts[3].z = getZpos(pos.x + w);

    // Compute the face normal.

        ss_calcNorm(&winMesh->faces[faceCount].norm, pts + 2, pts + 1, pts);

    // Add the face to the mesh.

        winMesh->faces[faceCount].material = 0;
        winMesh->faces[faceCount].p[0] = iPtInList(winMesh, 0, pts,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[1] = iPtInList(winMesh, 0, pts + 1,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[2] = iPtInList(winMesh, 0, pts + 2,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[3] = iPtInList(winMesh, 0, pts + 3,
            &winMesh->faces[faceCount].norm, TRUE);

        winMesh->numFaces++;
    }

// Normalize the vertex normals in the mesh.

    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);
}

/******************************Public*Routine******************************\
* initTexScene
*
* Initialize the screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/

void initTexScene()
{
    int i;
    float angleDelta;
    float aspectRatio;

    // Initialize the transform.

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-0.25, 1.0, -0.25, 1.0, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);

    // Initialize and turn on lighting.

    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);

    glLightfv(GL_LIGHT1, GL_AMBIENT, (GLfloat *) &light1Ambient);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, (GLfloat *) &light1Diffuse);
    glLightfv(GL_LIGHT1, GL_SPECULAR, (GLfloat *) &light1Specular);
    glLightfv(GL_LIGHT1, GL_POSITION, light1Pos);
    glEnable(GL_LIGHT1);
    glDisable(GL_DEPTH_TEST);

    // Leave OpenGL in a state ready to accept the model view transform (we
    // are going to have the flag vary its orientation from frame to frame).

    glMatrixMode(GL_MODELVIEW);

    // Define orientation of polygon faces.

    glFrontFace(GL_CW);
    //    glEnable(GL_CULL_FACE);

    Frames = (int)((float)(MAX_FRAMES / 2) * fTesselFact);

    // Load user texture - if that fails load default texture resource

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    if( ss_LoadTextureFile( &gTexFile, &gTex ) ||
        ss_LoadTextureResource( &gTexRes, &gTex) )
    {
        glEnable(GL_TEXTURE_2D);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

        ss_SetTexture( &gTex );

    // Correct aspect ratio of flag to match image.
    //
    // The 1.4 is a correction factor to account for the length of the
    // curve that models the surface ripple of the waving flag.  This
    // factor is the length of the curve at zero phase.  It would be
    // more accurate to determine the length of the curve at each phase,
    // but this is a sufficient approximation for our purposes.

        aspectRatio = ((float) gTex.height / (float) gTex.width)
                      * (float) 1.4;

        if (aspectRatio < (float) 1.0) {
            winTotalwidth  = (float)0.75;
            winTotalheight = winTotalwidth * aspectRatio;
        } else {
            winTotalheight = (float) 0.75;
            winTotalwidth  = winTotalheight / aspectRatio;
        };
    }

    if (Frames < 5)
        Frames = 5;
    if (Frames > MAX_FRAMES)
        Frames = MAX_FRAMES;

    // Generate the geometry data (stored in the array of mesh structures),
    // for each frame of the animation.  The shape of the flag is varied by
    // changing the global variable sinAngle.

    angleDelta = (float)(2.0 * PI) / (float)Frames;
    sinAngle = (float) 0.0;

    for (i = 0; i < Frames; i++) {
        genTex(&winMesh[i]);
        sinAngle += angleDelta;
    }
}

/******************************Public*Routine******************************\
* delTexScene
*
* Cleanup the data associated with this screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/

void delTexScene()
{
    int i;

    for (i = 0; i < Frames; i++)
        delMesh(&winMesh[i]);

    // Delete the texture
    ss_DeleteTexture( &gTex );
}

/******************************Public*Routine******************************\
* updateTexScene
*
* Generate a scene by taking one of the meshes and rendering it with
* OpenGL.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/

void updateTexScene(int flags)
{
    MESH *mesh;
    MFACE *faces;
    int i;
    static double mxrot = 23.0;
    static double myrot = 23.0;
    static double mzrot = 5.7;
    static double mxrotInc = 0.0;
    static double myrotInc = 3.0;
    static double mzrotInc = 0.0;
    static int h = 0;
    static int frameNum = 0;
    POINT3D *pp;
    POINT3D *pn;
    int lastC, lastD;
    int aOffs, bOffs, cOffs, dOffs;
    int a, b;
    GLfloat s = (GLfloat) 0.0;
    GLfloat ds;

// In addition to having the flag wave (an effect acheived by switching
// meshes from frame to frame), the flag changes its orientation from
// frame to frame.  This is done by applying a model view transform.

    glLoadIdentity();
    glRotatef((float)mxrot, 1.0f, 0.0f, 0.0f);
    glRotatef((float)myrot, 0.0f, 1.0f, 0.0f);
    glRotatef((float)mzrot, 0.0f, 0.0f, 1.0f);
    
// Divide the texture into IPREC slices.  ds is the texture coordinate
// delta we apply as we move along the x-axis.

    ds = (GLfloat)1.0 / (GLfloat)IPREC;

// Setup the material property of the flag.  The material property, light
// properties, and polygon orientation will interact with the texture.

    curMatl = 0;
//    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, &flagColors[0]);
//    glMaterialfv(GL_FRONT, GL_SPECULAR, &matlBrightSpecular);
//    glMaterialf(GL_FRONT, GL_SHININESS, 60.0);
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &flagColors[0]);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (GLfloat *) &matlBrightSpecular);
    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, (float) 60.0);

// Pick the mesh for the current frame.

    mesh = &winMesh[frameNum];

// Take the geometry data is the mesh and convert it to a single OpenGL
// quad strip.  If smooth shading is required, use the vertex normals stored
// in the mesh.  Otherwise, use the face normals.
//
// As we define each vertex, we also define a corresponding vertex and
// texture coordinate.

    glBegin(GL_QUAD_STRIP);

    pp = mesh->pts;
    pn = mesh->norms;

    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmoothShading) {
            // Since flag is a single quad strip, this isn't needed.
            // But lets keep it in case we ever change to a more
            // complex model (ie., one that uses more than one quad
            // strip).
            #if 0
            if ((a != lastC) || (b != lastD)) {
                glNormal3fv((GLfloat *)&(faces - 1)->norm);

                glTexCoord2f(s, (float) 0.0);
                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastC << 3) + (lastC << 2)));
                glTexCoord2f(s, (float) 1.0);
                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastD << 3) + (lastD << 2)));
                s += ds;
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }
            #endif

            if (faces->material != curMatl) {
                curMatl = faces->material;
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (GLfloat *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (GLfloat *) &flagColors[curMatl]);
            }

            glNormal3fv((GLfloat *)&faces->norm);
            glTexCoord2f(s, (float) 0.0);
            glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
            glTexCoord2f(s, (float) 1.0);
            glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
            s += ds;
        } else {
            // Since flag is a single quad strip, this isn't needed.
            // But lets keep it in case we ever change to a more
            // complex model (ie., one that uses more than one quad
            // strip).
            #if 0
            if ((a != lastC) || (b != lastD)) {
                cOffs = (lastC << 3) + (lastC << 2);
                dOffs = (lastD << 3) + (lastD << 2);

                glTexCoord2f(s, (float) 0.0);
                glNormal3fv((GLfloat *)((char *)pn + cOffs));
                glVertex3fv((GLfloat *)((char *)pp + cOffs));
                glTexCoord2f(s, (float) 1.0);
                glNormal3fv((GLfloat *)((char *)pn + dOffs));
                glVertex3fv((GLfloat *)((char *)pp + dOffs));
                s += ds;
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }
            #endif

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            if (faces->material != curMatl) {
                curMatl = faces->material;
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (GLfloat *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (GLfloat *) &flagColors[curMatl]);
            }

            glTexCoord2f(s, (float) 0.0);
            glNormal3fv((GLfloat *)((char *)pn + aOffs));
            glVertex3fv((GLfloat *)((char *)pp + aOffs));
            glTexCoord2f(s, (float) 1.0);
            glNormal3fv((GLfloat *)((char *)pn + bOffs));
            glVertex3fv((GLfloat *)((char *)pp + bOffs));
            s += ds;
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmoothShading) {
        glNormal3fv((GLfloat *)&(faces - 1)->norm);
        glTexCoord2f(s, (float) 0.0);
        glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glTexCoord2f(s, (float) 1.0);
        glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);

        glTexCoord2f(s, (float) 0.0);
        glNormal3fv((GLfloat *)((char *)pn + cOffs));
        glVertex3fv((GLfloat *)((char *)pp + cOffs));
        glTexCoord2f(s, (float) 1.0);
        glNormal3fv((GLfloat *)((char *)pn + dOffs));
        glVertex3fv((GLfloat *)((char *)pp + dOffs));
    }

    glEnd();

// Transfer the image to the floating OpenGL window.

// Determine the flag orientation for the next frame.
// What we are doing is an oscillating rotation about the y-axis
// (mxrotInc and mzrotInc are currently 0).

    mxrot += mxrotInc;
    myrot += myrotInc;
    mzrot += mzrotInc;

    if ((myrot < -65.0) || (myrot > 25.0))
        myrotInc = -myrotInc;

    frameNum++;
    if (frameNum >= Frames)
        frameNum = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\genstrip.c ===
/******************************Module*Header*******************************\
* Module Name: genstrip.c
*
* The Ribbon and 2 Ribbon styles of the 3D Flying Objects screen saver.
*
* Animation of 1 or 2 quad strips floating about.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <GL\gl.h>
#include <string.h>
#include <math.h>
#include "ss3dfo.h"
#include "mesh.h"

static MESH stripMesh;
static int iPrec = 40;

void genStrip()
{
    static int counter = 0;
    int i;
    int facecount;
    // Use Hermite basis, pg 488, FVD
    static float M[4][4] = {{2.0f, -2.0f, 1.0f, 1.0f},
                            {-3.0f, 3.0f, -2.0f, -1.0f},
                            {0.0f, 0.0f, 1.0f, 0.0f},
                            {1.0f, 0.0f, 0.0f, 0.0f}};
    float xx[4], yy[4], zz[4];
    float cx[4], cy[4], cz[4];
    float d = 1.0f / (float) iPrec;
    float t = 0.0f;
    float t2, t3;
    POINT3D p1 = {-0.5f, 0.0f, 0.0f};
    POINT3D p2 = {0.5f, 0.0f, 0.0f};
    POINT3D v1 = {1.5f, 1.5f, 0.0f};
    POINT3D v2 = {0.0f, 3.0f, 0.0f};
    POINT3D norm;
    float sinVal;
    float angle;
    float angleStep = (float) (PI / iPrec);
    static float rotA = 0.0f;
    static float rotB = (float) (PI / 2.0);
    static float sideSin = 0.0f;
    float rotStepA = (float) (PI / (2.0 * iPrec));
    float rotStepB = (float) (PI / (4.0 * iPrec));
    MESH *mesh = &stripMesh;

#define NORMS(x, y) stripMesh.norms[((x) * iPrec) + y]
#define GRID(x, y)  stripMesh.pts[((x) * iPrec) + y]
    
    v1.x = (float) (4.0 * cos(rotA));
    v1.y = (float) (4.0 * sin(rotA));

    p2.x = (float) (0.5 * sin(rotB));
//    p2.y = (float) (0.5 * sin(rotB));
    
    rotA += rotStepA;
    rotB += rotStepB;
    counter++;
    if (counter >= (2 * iPrec)) {
        rotStepA = -rotStepA;
        counter = 0;
    }

    angle = sideSin;
    sideSin += (float) (PI / 80.0);
    
    xx[0] = p1.x;
    xx[1] = p2.x;
    xx[2] = v1.x;
    xx[3] = v2.x;

    yy[0] = p1.y;
    yy[1] = p2.y;
    yy[2] = v1.y;
    yy[3] = v2.y;

    zz[0] = p1.z;
    zz[1] = p2.z;
    zz[2] = v1.z;
    zz[3] = v2.z;
    
    for (i = 0; i < 4; i++) {
        cx[i] = xx[0] * M[i][0] + xx[1] * M[i][1] +
                xx[2] * M[i][2] + xx[3] * M[i][3];
        cy[i] = yy[0] * M[i][0] + yy[1] * M[i][1] +
                yy[2] * M[i][2] + yy[3] * M[i][3];
        cz[i] = zz[0] * M[i][0] + zz[1] * M[i][1] +
                zz[2] * M[i][2] + zz[3] * M[i][3];
    }

    for (i = 0; i < iPrec; i++) {
        float x, y;
            
        t += d;
        t2 = t * t;
        t3 = t2 * t;
        
        x = cx[0] * t3 + cx[1] * t2 + cx[2] * t + cx[3];
        y = cy[0] * t3 + cy[1] * t2 + cy[2] * t + cy[3];
        
        sinVal = (float) (sin(angle) / 5.0);
        if (sinVal < 0.0)
            sinVal = -sinVal;
        angle += angleStep;
       
        GRID(0, i).x = x;
        GRID(0, i).z = y;
        GRID(0, i).y = 0.25f;    // extrusion // + sinVal;
        GRID(1, i).x = x;
        GRID(1, i).z = y;
        GRID(1, i).y = -0.25f;   // - sinVal;
    }

    stripMesh.numFaces = 0;
    
    for (i = 0; i < 2 * iPrec; i++)
        mesh->norms[i] = ss_ptZero;

    for (facecount = 0, i = 0; i < (iPrec - 1); i++) {
        
        ss_calcNorm(&norm, &GRID(0, i + 1), &GRID(0, i), &GRID(1, i));
        stripMesh.faces[facecount].material = 0;
        stripMesh.faces[facecount].norm = norm;
            
        NORMS(0, i).x += norm.x;
        NORMS(0, i).y += norm.y;
        NORMS(0, i).z += norm.z;
        NORMS(1, i).x += norm.x;
        NORMS(1, i).y += norm.y;
        NORMS(1, i).z += norm.z;

        if (i != (iPrec - 1)) {
            NORMS(0, i+1).x += norm.x;
            NORMS(0, i+1).y += norm.y;
            NORMS(0, i+1).z += norm.z;
            NORMS(1, i+1).x += norm.x;
            NORMS(1, i+1).y += norm.y;
            NORMS(1, i+1).z += norm.z;
        }

        stripMesh.faces[facecount].p[0] = i;
        stripMesh.faces[facecount].p[1] = iPrec + i;
        stripMesh.faces[facecount].p[2] = i + 1;
        stripMesh.faces[facecount].p[3] = iPrec + i + 1;
        stripMesh.numFaces++;
        facecount++;
    }

    stripMesh.numPoints = 2 * iPrec;

    ss_normalizeNorms(stripMesh.norms, stripMesh.numPoints);
}

void initStripScene()
{
    iPrec = (int)(fTesselFact * 40.5);
    if (iPrec < 4)
        iPrec = 4;

    newMesh(&stripMesh, iPrec, 2 * iPrec);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.1, 1.1, -1.1, 1.1, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);
    glRotatef(50.0f, 1.0f, 0.0f, 0.0f);
    glRotatef(50.0f, 0.0f, 1.0f, 0.0f);
    glRotatef(12.0f, 0.0f, 0.0f, 1.0f);
    glMatrixMode(GL_MODELVIEW);
}

void delStripScene()
{
    delMesh(&stripMesh);
}

void updateStripScene(int flags)
{
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double mzrotInc = 0.0;
    static int h = 0;
    RGBA color;

    if( gbBounce ) {
        // floating window bounced off an edge
        if (mxrotInc) {
            mxrotInc = 0.0;
            myrotInc = 0.1;
        } else if (myrotInc) {
            myrotInc = 0.0;
            mzrotInc = 0.1;
        } else if (mzrotInc) {
            mzrotInc = 0.0;
            mxrotInc = 0.1;
        }
        gbBounce = FALSE;
    }

    glLoadIdentity();
    glRotatef((GLfloat) (mxrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f);
    glRotatef((GLfloat) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
    glRotatef((GLfloat) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f);
    
    genStrip();

    if (bColorCycle) {
        ss_HsvToRgb((float)h, 1.0f, 1.0f, &color );

        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (GLfloat *) &color);
    
        h++;
        h %= 360;
    } else {
        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, 
                     (GLfloat *) &Material[1].kd);
    }

    updateObject(&stripMesh, bSmoothShading);

    if (flags & 0x4) {
        glLoadIdentity();
        glTranslatef(0.05f, 0.0f, 0.0f);
        glRotatef((GLfloat) (myrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f);
        glRotatef((GLfloat) (mxrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
        glRotatef((GLfloat) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f);

        if (bColorCycle) {
            color.r = 1.0f - color.r;
            color.g = 1.0f - color.g;
            color.b = 1.0f - color.b;

            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                         (GLfloat *) &color);
        } else {
            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, 
                         (GLfloat *) &Material[2].kd);
        }

        updateObject(&stripMesh, bSmoothShading);
    }

    mxrot += mxrotInc;
    myrot += myrotInc;
    mzrot += mzrotInc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\mesh.c ===
/******************************Module*Header*******************************\
* Module Name: mesh.c
*
* Routines to create a mesh representation of a 3D object and to turn it
* into an OpenGL description.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <GL\gl.h>
#include <string.h>
#include <math.h>
#include "ss3dfo.h"
#include "mesh.h"

#define ZERO_EPS    0.00000001

/******************************Public*Routine******************************\
* newMesh
*
* Allocate memory for the mesh structure to accomodate the specified number
* of points and faces.
*
\**************************************************************************/

void newMesh(MESH *mesh, int numFaces, int numPts)
{
    mesh->numFaces = 0;
    mesh->numPoints = 0;

    if (numPts) {
        mesh->pts = SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D));
        mesh->norms = SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D));
    }
    mesh->faces = SaverAlloc((LONG)numFaces * (LONG)sizeof(MFACE));
}

/******************************Public*Routine******************************\
* delMesh
*
* Delete the allocated portions of the MESH structure.
*
\**************************************************************************/

void delMesh(MESH *mesh)
{    
    SaverFree(mesh->pts);
    SaverFree(mesh->norms);
    SaverFree(mesh->faces);
}

/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/

static int iPtInList(MESH *mesh, POINT3D *p, POINT3D *norm, int start)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    for (i = start; i < mesh->numPoints; i++, pts++)
    {
    // If the vertices are within ZERO_EPS of each other, then its the same
    // vertex.

        if ( fabs(pts->x - p->x) < ZERO_EPS &&
             fabs(pts->y - p->y) < ZERO_EPS &&
             fabs(pts->z - p->z) < ZERO_EPS )
        {
            mesh->norms[i].x += norm->x;
            mesh->norms[i].y += norm->y;
            mesh->norms[i].z += norm->z;
            return i;
        }
    }
    
    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}


/******************************Public*Routine******************************\
* revolveSurface
*
* Takes the set of points in curve and fills the mesh structure with a
* surface of revolution.  The surface consists of quads made up of the
* points in curve rotated about the y-axis.  The number of increments
* in the revolution is determined by the steps parameter.
*
\**************************************************************************/

#define MAXPREC 40

void revolveSurface(MESH *mesh, POINT3D *curve, int steps)
{
    int i;
    int j;
    int facecount = 0;
    double rotation = 0.0;
    double rotInc;
    double cosVal;
    double sinVal;
    int stepsSqr;
    POINT3D norm;
    POINT3D a[MAXPREC + 1];
    POINT3D b[MAXPREC + 1];
    
    if (steps > MAXPREC)
        steps = MAXPREC;
    rotInc = (2.0 * PI) / (double)(steps - 1);
    stepsSqr = steps * steps;
    newMesh(mesh, stepsSqr, 4 * stepsSqr);

    for (j = 0; j < steps; j++, rotation += rotInc) {
        cosVal = cos(rotation);
        sinVal = sin(rotation);
        for (i = 0; i < steps; i++) {
            a[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal);
            a[i].y = (float) (curve[i].y);
            a[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal);
        }

        cosVal = cos(rotation + rotInc);
        sinVal = sin(rotation + rotInc);
        for (i = 0; i < steps; i++) {
            b[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal);
            b[i].y = (float) (curve[i].y);
            b[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal);
        }

        for (i = 0; i < (steps - 1); i++) {
            ss_calcNorm(&norm, &b[i + 1], &b[i], &a[i]);
            if ((norm.x * norm.x) + (norm.y * norm.y) + (norm.z * norm.z) < 0.9)
                ss_calcNorm(&norm, &a[i], &a[i+1], &b[i + 1]);
            mesh->faces[facecount].material = j & 7;
            mesh->faces[facecount].norm = norm;
            mesh->faces[facecount].p[0] = iPtInList(mesh, &b[i], &norm, 0);
            mesh->faces[facecount].p[1] = iPtInList(mesh, &a[i], &norm, 0);
            mesh->faces[facecount].p[2] = iPtInList(mesh, &b[i + 1], &norm, 0);
            mesh->faces[facecount].p[3] = iPtInList(mesh, &a[i + 1], &norm, 0); 
            mesh->numFaces++;
            facecount++;
        }
    }

    ss_normalizeNorms(mesh->norms, mesh->numPoints);
}


/******************************Public*Routine******************************\
* updateObject
*
* Takes the mesh structure and converts the data into OpenGL immediate
* mode commands.
*
\**************************************************************************/

void updateObject(MESH *mesh, BOOL bSmooth)
{
    int i;
    int a, b;
    int aOffs, bOffs, cOffs, dOffs;
    MFACE *faces;
    POINT3D *pp;
    POINT3D *pn;
    int lastC, lastD;

    pp = mesh->pts;
    pn = mesh->norms;

    glBegin(GL_QUAD_STRIP);
    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmooth) {
            if ((a != lastC) || (b != lastD)) {
                glNormal3fv((GLfloat *)&(faces - 1)->norm);

                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastC << 3) + (lastC << 2)));
                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastD << 3) + (lastD << 2)));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            glNormal3fv((GLfloat *)&faces->norm);
            glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
            glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
        } else {
            if ((a != lastC) || (b != lastD)) {
                cOffs = (lastC << 3) + (lastC << 2);
                dOffs = (lastD << 3) + (lastD << 2);

                glNormal3fv((GLfloat *)((char *)pn + cOffs));
                glVertex3fv((GLfloat *)((char *)pp + cOffs));
                glNormal3fv((GLfloat *)((char *)pn + dOffs));
                glVertex3fv((GLfloat *)((char *)pp + dOffs));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            glNormal3fv((GLfloat *)((char *)pn + aOffs));
            glVertex3fv((GLfloat *)((char *)pp + aOffs));
            glNormal3fv((GLfloat *)((char *)pn + bOffs));
            glVertex3fv((GLfloat *)((char *)pp + bOffs));
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmooth) {
        glNormal3fv((GLfloat *)&(faces - 1)->norm);
        glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);

        glNormal3fv((GLfloat *)((char *)pn + cOffs));
        glVertex3fv((GLfloat *)((char *)pp + cOffs));
        glNormal3fv((GLfloat *)((char *)pn + dOffs));
        glVertex3fv((GLfloat *)((char *)pp + dOffs));
    }

    glEnd();
}


/******************************Public*Routine******************************\
* updateObject
*
* This is a special case that handles a mesh structure that represents
* a strip that is a 1 high loop.
*
* Takes the mesh structure and converts the data into OpenGL immediate
* mode commands.
*
\**************************************************************************/

void updateObject2(MESH *mesh, BOOL bSmooth)
{
    int i;
    int a, b;
    int aOffs, bOffs, cOffs, dOffs;
    MFACE *faces;
    POINT3D *pp;
    POINT3D *pn;
    int lastC, lastD;

    pp = mesh->pts;
    pn = mesh->norms;

    glBegin(GL_QUAD_STRIP);
    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmooth) {
            glNormal3fv((GLfloat *)&faces->norm);
            glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
            glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
        } else {
            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            glNormal3fv((GLfloat *)((char *)pn + aOffs));
            glVertex3fv((GLfloat *)((char *)pp + aOffs));
            glNormal3fv((GLfloat *)((char *)pn + bOffs));
            glVertex3fv((GLfloat *)((char *)pp + bOffs));
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmooth) {
        glNormal3fv((GLfloat *)&(mesh->faces)->norm);
        glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);

        glNormal3fv((GLfloat *)((char *)pn + cOffs));
        glVertex3fv((GLfloat *)((char *)pp + cOffs));
        glNormal3fv((GLfloat *)((char *)pn + dOffs));
        glVertex3fv((GLfloat *)((char *)pp + dOffs));
    }

    glEnd();
}


/******************************Public*Routine******************************\
* MakeList
*
* Takes the mesh structure and converts the data into OpenGL display
* list.
*
\**************************************************************************/

void MakeList(GLuint listID, MESH *mesh)
{
    int i;
    int a, b;
    int aOffs, bOffs, cOffs, dOffs;
    MFACE *faces;
    BOOL bSmooth;
    POINT3D *pp;
    POINT3D *pn;
    GLint shadeModel;
    int lastC, lastD;

    glGetIntegerv(GL_SHADE_MODEL, &shadeModel);

    bSmooth = (shadeModel == GL_SMOOTH);

    glNewList(listID, GL_COMPILE);

    pp = mesh->pts;
    pn = mesh->norms;

    glBegin(GL_QUAD_STRIP);
    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmooth) {

            if ((a != lastC) || (b != lastD)) {
                glNormal3fv((GLfloat *)&((faces - 1)->norm));

                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastC << 3) + (lastC << 2)));
                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastD << 3) + (lastD << 2)));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            glNormal3fv((GLfloat *)&faces->norm);
            glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
            glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
        } else {
            if ((a != lastC) || (b != lastD)) {
                cOffs = (lastC << 3) + (lastC << 2);
                dOffs = (lastD << 3) + (lastD << 2);

                glNormal3fv((GLfloat *)((char *)pn + cOffs));
                glVertex3fv((GLfloat *)((char *)pp + cOffs));
                glNormal3fv((GLfloat *)((char *)pn + dOffs));
                glVertex3fv((GLfloat *)((char *)pp + dOffs));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            glNormal3fv((GLfloat *)((char *)pn + aOffs));
            glVertex3fv((GLfloat *)((char *)pp + aOffs));
            glNormal3fv((GLfloat *)((char *)pn + bOffs));
            glVertex3fv((GLfloat *)((char *)pp + bOffs));
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmooth) {
        glNormal3fv((GLfloat *)&((faces - 1)->norm));
        glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);

        glNormal3fv((GLfloat *)((char *)pn + cOffs));
        glVertex3fv((GLfloat *)((char *)pp + cOffs));
        glNormal3fv((GLfloat *)((char *)pn + dOffs));
        glVertex3fv((GLfloat *)((char *)pp + dOffs));
    }

    glEnd();

    glEndList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\genwin.c ===
/******************************Module*Header*******************************\
* Module Name: genwin.c
*
* The Windows Logo style of the 3D Flying Objects screen saver.
*
* Animated 3D model of the Microsoft (R) Windows NT (TM) flag logo.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <GL\gl.h>
#include <string.h>
#include <math.h>
#include "ss3dfo.h"

#define WIN_TOP_BORDER      (float)0.1
#define WIN_RIGHT_BORDER    WIN_TOP_BORDER
#define WIN_CROSSBAR        (0.6522f * WIN_TOP_BORDER)
#define WIN_NUMPIECES       7
#define WIN_NUMCOLUMNS      6
#define WIN_GAP             (WIN_TOP_BORDER / 8.0f)
#define WIN_GAP_X           (2.0f * WIN_GAP)
#define WIN_HEIGHT          ((WIN_GAP * 6.0f) + \
                                (WIN_NUMPIECES * WIN_TOP_BORDER))
#define WIN_WIDTH           (0.7024f * WIN_HEIGHT)
#define WIN_THICKNESS       WIN_CROSSBAR

#define WIN_TOTALWIDTH      (WIN_TOP_BORDER * 1.1f * (float)WIN_NUMCOLUMNS + \
                             WIN_WIDTH)

#define BLOCK_TOP            0x0001
#define BLOCK_BOTTOM         0x0002
#define BLOCK_LEFT           0x0004
#define BLOCK_RIGHT          0x0008
#define BLOCK_FRONT          0x0010
#define BLOCK_BACK           0x0020
#define BLOCK_ALL            0x003f
#define DELTA_BLEND          0x2000
#define NO_BLEND             0x1000

#define CUBE_FACES          6
#define CUBE_POINTS         8

#define MAX_FRAMES 20

#define MAXPREC 15
#define S_IPREC 3

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static MESH winStreamer[MAX_FRAMES];
static float sinAngle = 0.0f;
static float xTrans = 0.2f;
static int curMatl = 0;
static int iPrec = 10;

static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};
static RGBA matlDimSpecular = {0.5f, 0.5f, 0.5f, 1.0f};
static RGBA matlNoSpecular = {0.0f, 0.0f, 0.0f, 0.0f};
static GLfloat light0Pos[] = {20.0f, -10.0f, 20.0f, 0.0f};

static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f};
static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f};
static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f};
static GLfloat light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f};

static RGBA winColors[] = {{0.3f, 0.3f, 0.3f, 1.0f},
                           {0.94f, 0.37f, 0.13f, 1.0f},    // red
                           {0.22f, 0.42f, 0.78f, 1.0f},    // blue
                           {0.35f, 0.71f, 0.35f, 1.0f},    // green
                           {0.95f, 0.82f, 0.12f, 1.0f}};   // yellow

static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }
    
    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}

float getZPos(float x)
{
    float xAbs = x - xTrans;
    float angle = (float) (sinAngle + ((2.0 * PI) * (xAbs / WIN_TOTALWIDTH)));

    xAbs += (WIN_TOTALWIDTH / 2.0f);
    xAbs = WIN_TOTALWIDTH - xAbs;

    return (float)((sin((double)angle) / 4.0) * 
                   sqrt((double)(xAbs / WIN_TOTALWIDTH )));
}

void AddFace(MESH *mesh, int startBlend, POINT3D *pos, float w, float h)
{
#define FACE_VERTEX(i) \
    iPtInList(mesh, startBlend, pts + i, &mesh->faces[faceCount].norm, TRUE)

    int faceCount = mesh->numFaces;     
    int numPts = mesh->numPoints;
    POINT3D *pts = mesh->pts + numPts;
    float zLeft = getZPos(pos->x);
    float zRight = getZPos(pos->x + w);


    pts->x = (float)pos->x; 
    pts->y = (float)pos->y;   
    pts->z = zLeft; 
    pts++;

    pts->x = (float)pos->x;
    pts->y = (float)(pos->y + h);  
    pts->z = zLeft;  
    pts++;

    pts->x = (float)(pos->x + w);  
    pts->y = (float)(pos->y + h);  
    pts->z = zRight;  
    pts++;

    pts->x = (float)(pos->x + w);
    pts->y = (float)pos->y;  
    pts->z = zRight;

    pts -= 3;

    mesh->faces[faceCount].material = curMatl;
    ss_calcNorm(&mesh->faces[faceCount].norm, pts + 2, pts + 1, pts);
    mesh->faces[faceCount].p[3] = FACE_VERTEX(0);
    mesh->faces[faceCount].p[2] = FACE_VERTEX(1);
    mesh->faces[faceCount].p[1] = FACE_VERTEX(2);
    mesh->faces[faceCount].p[0] = FACE_VERTEX(3);
    mesh->numFaces++;
}

#define BLOCK_VERTEX(face, i)\
{\
    if (flags & DELTA_BLEND) {\
        mesh->faces[faceCount].p[face] = \
            iPtInList(mesh, blendStart, &pts[i], &norms[((i & 0x2) >> 1)],\
                      bBlend);\
    } else\
        mesh->faces[faceCount].p[face] = \
            iPtInList(mesh, blendStart, &pts[i],\
                      &mesh->faces[faceCount].norm, bBlend);\
}

#define DELTA_FACT  (float)10.0

void AddBlock(MESH *mesh, int blendStart, POINT3D *pos, 
              float w, float h, float d, ULONG flags)
{

    POINT3D pts[8];
    POINT3D ptsL[8];
    POINT3D ptsR[8];
    POINT3D norms[2];
    POINT3D posPrev;
    float zLeft = getZPos(pos->x);
    float zRight = getZPos(pos->x + w);
    int faceCount = mesh->numFaces;     
    BOOL bBlend = ((flags & NO_BLEND) == 0);

    flags |= DELTA_BLEND;

    pts[0].x = (float)pos->x; 
    pts[0].y = (float)(pos->y + h);   
    pts[0].z = zLeft;

    pts[1].x = (float)pos->x;
    pts[1].y = (float)(pos->y + h);  
    pts[1].z = zLeft + d;  

    pts[2].x = (float)(pos->x + w);  
    pts[2].y = (float)(pos->y + h);  
    pts[2].z = zRight + d;  

    pts[3].x = (float)(pos->x + w);
    pts[3].y = (float)(pos->y + h);
    pts[3].z = zRight;

    pts[4].x = (float)pos->x;
    pts[4].y = (float)pos->y;
    pts[4].z = zLeft;

    pts[5].x = (float)pos->x;
    pts[5].y = (float)pos->y;
    pts[5].z = zLeft + d;  

    pts[6].x = (float)(pos->x + w);  
    pts[6].y = (float)pos->y;
    pts[6].z = zRight + d;  

    pts[7].x = (float)(pos->x + w);  
    pts[7].y = (float)pos->y;
    pts[7].z = zRight;

    if (flags & DELTA_BLEND) {
	float prevW = w;
        posPrev = *pos;

        w /= DELTA_FACT;
        zRight = getZPos(pos->x + w);

        ptsL[0].x = (float)pos->x; 
        ptsL[0].y = (float)(pos->y + h);   
        ptsL[0].z = zLeft;

        ptsL[1].x = (float)pos->x;
        ptsL[1].y = (float)(pos->y + h);  
        ptsL[1].z = zLeft + d;  

        ptsL[2].x = (float)(pos->x + w);  
        ptsL[2].y = (float)(pos->y + h);  
        ptsL[2].z = zRight + d;  

        ptsL[3].x = (float)(pos->x + w);
        ptsL[3].y = (float)(pos->y + h);
        ptsL[3].z = zRight;

        ptsL[4].x = (float)pos->x;
        ptsL[4].y = (float)pos->y;
        ptsL[4].z = zLeft;

        ptsL[5].x = (float)pos->x;
        ptsL[5].y = (float)pos->y;
        ptsL[5].z = zLeft + d;  

        ptsL[6].x = (float)(pos->x + w);  
        ptsL[6].y = (float)pos->y;
        ptsL[6].z = zRight + d;  

        ptsL[7].x = (float)(pos->x + w);  
        ptsL[7].y = (float)pos->y;
        ptsL[7].z = zRight;

        pos->x += (prevW - w);
        zLeft = getZPos(pos->x);
        zRight = getZPos(pos->x + w);

        ptsR[0].x = (float)pos->x; 
        ptsR[0].y = (float)(pos->y + h);   
        ptsR[0].z = zLeft;

        ptsR[1].x = (float)pos->x;
        ptsR[1].y = (float)(pos->y + h);  
        ptsR[1].z = zLeft + d;  

        ptsR[2].x = (float)(pos->x + w);  
        ptsR[2].y = (float)(pos->y + h);  
        ptsR[2].z = zRight + d;  

        ptsR[3].x = (float)(pos->x + w);
        ptsR[3].y = (float)(pos->y + h);
        ptsR[3].z = zRight;

        ptsR[4].x = (float)pos->x;
        ptsR[4].y = (float)pos->y;
        ptsR[4].z = zLeft;

        ptsR[5].x = (float)pos->x;
        ptsR[5].y = (float)pos->y;
        ptsR[5].z = zLeft + d;  

        ptsR[6].x = (float)(pos->x + w);  
        ptsR[6].y = (float)pos->y;
        ptsR[6].z = zRight + d;  

        ptsR[7].x = (float)(pos->x + w);  
        ptsR[7].y = (float)pos->y;
        ptsR[7].z = zRight;

        *pos = posPrev;

    }

    if (flags & BLOCK_TOP) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[0], &pts[1], &pts[2]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[0], &ptsL[1], &ptsL[2]);
            ss_calcNorm(&norms[1], &ptsR[0], &ptsR[1], &ptsR[2]);
        }
        BLOCK_VERTEX(0, 0);
        BLOCK_VERTEX(1, 1);
        BLOCK_VERTEX(2, 2);
        BLOCK_VERTEX(3, 3);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_BOTTOM) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[4], &pts[7], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[4], &ptsL[7], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[4], &ptsR[7], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 4);
        BLOCK_VERTEX(1, 7);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 5);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_LEFT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[1], &pts[0], &pts[4]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[1], &ptsL[0], &ptsL[4]);
            ss_calcNorm(&norms[1], &ptsR[1], &ptsR[0], &ptsR[4]);
        }
        BLOCK_VERTEX(0, 1);
        BLOCK_VERTEX(1, 0);
        BLOCK_VERTEX(2, 4);
        BLOCK_VERTEX(3, 5);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_RIGHT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[3], &pts[2], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[3], &ptsL[2], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[3], &ptsR[2], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 3);
        BLOCK_VERTEX(1, 2);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 7);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_FRONT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[0], &pts[3], &pts[7]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[0], &ptsL[3], &ptsL[7]);
            ss_calcNorm(&norms[1], &ptsR[0], &ptsR[3], &ptsR[7]);
        }
        BLOCK_VERTEX(0, 0);
        BLOCK_VERTEX(1, 3);
        BLOCK_VERTEX(2, 7);
        BLOCK_VERTEX(3, 4);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_BACK) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[1], &pts[5], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[1], &ptsL[5], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[1], &ptsR[5], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 1);
        BLOCK_VERTEX(1, 5);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 2);
        mesh->numFaces++;
    }

}

void genWin(MESH *winMesh, MESH *winStreamer)
{
    POINT3D pos, posCenter;
    float w, h, d;
    float wMax, hMax;
    float xpos;
    int i, j, prec;
    int startBlend;

    newMesh(winMesh, CUBE_FACES * iPrec * 20, CUBE_POINTS * iPrec * 20);

    //
    // create window frame
    //

    w = (WIN_WIDTH - WIN_TOP_BORDER) / (float)iPrec;
    h = (float)WIN_TOP_BORDER;
    d = (float)WIN_THICKNESS;

    // draw top and bottom portions

    pos.y = 0.0f;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints; 
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);

    pos.y = WIN_HEIGHT - WIN_TOP_BORDER;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);
    
    // draw middle horizontal portions

    prec = (iPrec / 2);
    w = (WIN_WIDTH - WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f;
    w /= (float)prec;
    h = WIN_CROSSBAR;
    pos.y = (WIN_HEIGHT - WIN_CROSSBAR) / 2.0f;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);

    xpos = pos.x + WIN_CROSSBAR;

    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);

    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);


    // Draw thick right-hand edge of frame

    pos.x = xpos = xTrans + WIN_WIDTH - WIN_RIGHT_BORDER;
    pos.y = 0.0f;
    pos.z = 0.0f;
    w = WIN_RIGHT_BORDER / (float)S_IPREC;
    h = WIN_HEIGHT;

    AddBlock(winMesh, winMesh->numPoints, &pos, w, h, d, BLOCK_LEFT);

    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    pos.y = WIN_HEIGHT;
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);

    pos.y = 0.0f;
    pos.x = xTrans + WIN_WIDTH - w;
    AddBlock(winMesh, winMesh->numPoints, &pos, w, h, d, BLOCK_RIGHT);

    // draw middle-vertical portion of frame

    pos.x = xTrans + (WIN_WIDTH - WIN_RIGHT_BORDER) / 2.0f - (WIN_CROSSBAR / 2.0f);
    pos.y = WIN_TOP_BORDER;
    pos.z = 0.0f;
    w = WIN_CROSSBAR;
    h = WIN_HEIGHT - 2.0f * WIN_TOP_BORDER;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_ALL | NO_BLEND);

    //
    // add the panels
    //

    w = (WIN_WIDTH - WIN_RIGHT_BORDER - WIN_CROSSBAR) / 2.0f;
    h = (WIN_HEIGHT - 2.0f * WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f;

    w /= (float)(iPrec / 2);

    curMatl = 2;
    pos.x = xTrans;
    pos.y = WIN_TOP_BORDER;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }
    curMatl = 4;
    pos.x += WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }

    curMatl = 1;
    pos.x = xTrans;
    pos.y = WIN_TOP_BORDER + h + WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }
    curMatl = 3;
    pos.x += WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }

    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);

    newMesh(winStreamer, CUBE_FACES * WIN_NUMPIECES * WIN_NUMCOLUMNS,
            CUBE_POINTS * WIN_NUMPIECES * WIN_NUMCOLUMNS);

    h = hMax = WIN_TOP_BORDER;
    w = wMax = WIN_TOP_BORDER * 1.1f;

    posCenter.x = pos.x = xTrans - wMax - WIN_GAP_X;
    posCenter.y = pos.y = 0.0f;

    for (i = 0; i < WIN_NUMCOLUMNS; i++) {
        for (j = 0; j < WIN_NUMPIECES; j++) {
            if (((j % 3) == 0) || (i == 0))
                curMatl = 0;
            else if (j < 3)
                curMatl = 2;
            else
                curMatl = 1;
            AddBlock(winStreamer, 0, &pos, w, h, d, BLOCK_ALL);
            pos.y += (hMax + WIN_GAP);
        }

        posCenter.x -= (wMax + WIN_GAP_X);
        posCenter.y = 0.0f;

        h = h * 0.8f;
        w = w * 0.8f;

        pos.x = posCenter.x;
        pos.y = posCenter.y;

        pos.x += (wMax - w) / 2.0f;
        pos.y += (hMax - h) / 2.0f;
    }    
    ss_normalizeNorms(winStreamer->norms, winStreamer->numPoints);
}

void initWinScene()
{
    int i;
    float angleDelta;

    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 5)
        iPrec = 5;
    if (iPrec > MAXPREC)
        iPrec = MAXPREC;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0, 1.0, -0.75, 1.25, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);

    glLightfv(GL_LIGHT1, GL_AMBIENT, (GLfloat *) &light1Ambient);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, (GLfloat *) &light1Diffuse);
    glLightfv(GL_LIGHT1, GL_SPECULAR, (GLfloat *) &light1Specular);
    glLightfv(GL_LIGHT1, GL_POSITION, light1Pos);
    glEnable(GL_LIGHT1);

    glMatrixMode(GL_MODELVIEW);

    glFrontFace(GL_CCW);
    glEnable(GL_CULL_FACE);

    Frames = (int)((float)(MAX_FRAMES / 2) * fTesselFact);

    if (Frames < 5)
        Frames = 5;
    if (Frames > MAX_FRAMES)
        Frames = MAX_FRAMES;

    angleDelta = (float) ((2.0 * PI) / Frames);
    sinAngle = 0.0f;

    for (i = 0; i < Frames; i++) {
        genWin(&winMesh[i], &winStreamer[i]);
        sinAngle += angleDelta;
    }
}

void delWinScene()
{
    int i;

    for (i = 0; i < Frames; i++) {
        delMesh(&winMesh[i]);
        delMesh(&winStreamer[i]);
    }
}

void updateWinScene(int flags)
{
    MESH *mesh;
    MFACE *faces;
    int i;
    static double mxrot = 23.0;
    static double myrot = 23.0;
    static double mzrot = 5.7;
    static double mxrotInc = 0.0;
    static double myrotInc = 3.0;
    static double mzrotInc = 0.0;
    static int h = 0;
    static int frameNum = 0;
    POINT3D *pp;
    POINT3D *pn;
    int lastC, lastD;
    int aOffs, bOffs, cOffs, dOffs;
    int a, b;

    if (bColorCycle) {
        ss_HsvToRgb((float)h, 1.0f, 1.0f, &winColors[0] );

        h++;
        h %= 360;
    }

    glLoadIdentity();
    glRotatef((GLfloat) mxrot, 1.0f, 0.0f, 0.0f);
    glRotatef((GLfloat) myrot, 0.0f, 1.0f, 0.0f);
    glRotatef((GLfloat) mzrot, 0.0f, 0.0f, 1.0f);

    curMatl = 0;
    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &winColors[0]);
    glMaterialfv(GL_FRONT, GL_SPECULAR, (GLfloat *) &matlBrightSpecular);
    glMaterialf(GL_FRONT, GL_SHININESS, 60.0f);

    mesh = &winMesh[frameNum];

    glBegin(GL_QUAD_STRIP);

    pp = mesh->pts;
    pn = mesh->norms;

    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

	if (!bSmoothShading) {
            if ((a != lastC) || (b != lastD)) {
                glNormal3fv((GLfloat *)&(faces - 1)->norm);

                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastC << 3) + (lastC << 2)));
                glVertex3fv((GLfloat *)((char *)pp + 
                            (lastD << 3) + (lastD << 2)));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            if (faces->material != curMatl) {
                curMatl = faces->material;
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (GLfloat *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (GLfloat *) &winColors[curMatl]);
            }

            glNormal3fv((GLfloat *)&faces->norm);
            glVertex3fv((GLfloat *)((char *)pp + (a << 3) + (a << 2)));
            glVertex3fv((GLfloat *)((char *)pp + (b << 3) + (b << 2)));
        } else {
            if ((a != lastC) || (b != lastD)) {
                cOffs = (lastC << 3) + (lastC << 2);
                dOffs = (lastD << 3) + (lastD << 2);

                glNormal3fv((GLfloat *)((char *)pn + cOffs));
                glVertex3fv((GLfloat *)((char *)pp + cOffs));
                glNormal3fv((GLfloat *)((char *)pn + dOffs));
                glVertex3fv((GLfloat *)((char *)pp + dOffs));
                glEnd();
                glBegin(GL_QUAD_STRIP);
            }

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            if (faces->material != curMatl) {
                curMatl = faces->material;
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (GLfloat *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (GLfloat *) &winColors[curMatl]);
            }

            glNormal3fv((GLfloat *)((char *)pn + aOffs));
            glVertex3fv((GLfloat *)((char *)pp + aOffs));
            glNormal3fv((GLfloat *)((char *)pn + bOffs));
            glVertex3fv((GLfloat *)((char *)pp + bOffs));
        }

        lastC = faces->p[3];
        lastD = faces->p[2];
    }

    if (!bSmoothShading) {
        glNormal3fv((GLfloat *)&(faces - 1)->norm);
        glVertex3fv((GLfloat *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glVertex3fv((GLfloat *)((char *)pp + (lastD << 3) + (lastD << 2)));
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);

        glNormal3fv((GLfloat *)((char *)pn + cOffs));
        glVertex3fv((GLfloat *)((char *)pp + cOffs));
        glNormal3fv((GLfloat *)((char *)pn + dOffs));
        glVertex3fv((GLfloat *)((char *)pp + dOffs));
    }

    glEnd();

    glMaterialfv(GL_FRONT, GL_SPECULAR, (GLfloat *) &matlDimSpecular);

    glBegin(GL_QUADS);

    mesh = &winStreamer[frameNum];

    for (i = 0, faces = mesh->faces; 
         i < mesh->numFaces; i++, faces++) {
        int a, b, c, d;

        a = faces->p[0];
        b = faces->p[1];
        c = faces->p[2];
        d = faces->p[3];

        if (faces->material != curMatl) {
            curMatl = faces->material;
            glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                         (GLfloat *)&winColors[curMatl]);
        }

        glNormal3fv((GLfloat *)&faces->norm);
        glVertex3fv((GLfloat *)(mesh->pts + a));
        glVertex3fv((GLfloat *)(mesh->pts + b));
        glVertex3fv((GLfloat *)(mesh->pts + c));
        glVertex3fv((GLfloat *)(mesh->pts + d));
    }

    glEnd();

    mxrot += mxrotInc;
    myrot += myrotInc;
    mzrot += mzrotInc;

    if ((myrot < -45.0) || (myrot > 45.0))
        myrotInc = -myrotInc;

    frameNum++;
    if (frameNum >= Frames)
        frameNum = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\clear.cxx ===
/******************************Module*Header*******************************\
* Module Name: clear.cxx
*
* Window clearing functions
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <sys/timeb.h>
#include <GL/gl.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <math.h>
#include "ssintrnl.hxx"
#include "util.hxx"
#include "clear.hxx"

#define SS_CLEAR_BASE_DIV 32
#define SS_CLEAR_BASE_SIZE 16


/******************************Public*Routine******************************\
* ss_RectWipeClear
*
* Clears by drawing top, bottom, left, right rectangles that shrink in size
* towards the center.
*
* Calibration is used to try to maintain an ideal clear time.
*
\**************************************************************************/

int
ss_RectWipeClear( int width, int height, int repCount )
{
    int i, j, xinc, yinc, numDivs;
    int xmin, xmax, ymin, ymax;
    int w, h;
    BOOL bCalibrate = FALSE;
    double elapsed;
    static double idealTime = 0.7;
    SS_TIMER timer;

    xinc = 1;
    yinc = 1;
    numDivs = height; // assumes height <= width

    xmin = ymin = 0;
    xmax = width-1;
    ymax = height-1;

    glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

    glEnable( GL_SCISSOR_TEST );

    if( repCount == 0 ) {
        bCalibrate = TRUE;
        repCount = 1;
        timer.Start();
    }

    for( i = 0; i < (numDivs/2); i ++ ) {
      w = xmax - xmin + 1;
      h = ymax - ymin + 1;

      for( j = 0; j < repCount; j ++ ) {
        // bottom
        glScissor( xmin, ymin, w, 1 );
        glClear( GL_COLOR_BUFFER_BIT );

        // left
        glScissor( xmin, ymin, 1, h );
        glClear( GL_COLOR_BUFFER_BIT );

        // right
        glScissor( xmax, ymin, 1, h );
        glClear( GL_COLOR_BUFFER_BIT );

        // top
        glScissor( xmin, ymax, w, 1 );
        glClear( GL_COLOR_BUFFER_BIT );

        glFlush(); // to eliminate 'bursts'
      }

      xmin += xinc;
      xmax -= xinc;
      ymin += yinc;
      ymax -= yinc;
    }

    if( bCalibrate ) {
        elapsed = timer.Stop();

        // try to maintain ideal clear time
        if( elapsed < idealTime ) {
            // increase repCount to slow down the clear
            if( elapsed == 0.0 )
                repCount = 10;  // just in case
            else
                repCount = (int) ((idealTime / elapsed) + 0.5);
        }
    }

    glDisable( GL_SCISSOR_TEST );

    return repCount;
}

#define SS_CLEAR_BASE_DIV 32

/******************************Public*Routine******************************\
*
* SS_DIGITAL_DISSOLVE_CLEAR constructor
*
\**************************************************************************/

SS_DIGITAL_DISSOLVE_CLEAR::
SS_DIGITAL_DISSOLVE_CLEAR()
{
    rectBuf = NULL;
    rectBufSize = 0;
    rectSize = SS_CLEAR_BASE_SIZE;
}

/******************************Public*Routine******************************\
*
* SS_DIGITAL_DISSOLVE_CLEAR destructor
*
\**************************************************************************/

SS_DIGITAL_DISSOLVE_CLEAR::
~SS_DIGITAL_DISSOLVE_CLEAR()
{
    if( rectBuf )
        LocalFree( rectBuf );
}

/******************************Public*Routine******************************\
* CalibrateClear
*
* Try to calibrate the clear so it takes the specified time
\**************************************************************************/

//#define AUTO_CALIBRATE 1

int SS_DIGITAL_DISSOLVE_CLEAR::
CalibrateClear( int width, int height, float fClearTime )
{
    float factor;
    int idealNRects;
    int nRects;
    int baseSize;
    SS_TIMER timer;
    float elapsed;

    baseSize = (width < height ? width : height) / SS_CLEAR_BASE_DIV;
    if( baseSize == 0 )
        baseSize = 1;

    timer.Start();

#ifdef AUTO_CALIBRATE
    // Clear a small region (quarter-screen) and extrapolate
    Clear( width >> 1, height >> 1, baseSize );
#else
    Clear( width, height, baseSize );
#endif

    elapsed = timer.Stop();
#ifdef AUTO_CALIBRATE
    // extrapolate to full screen time
    // mf: this approximation resulted in clears being somewhat less than ideal
    //  I guess this means more time than I thought was spent in scanning up
    //  or down for uncleared rects
    elapsed *= 4.0f;
#endif

    // Adjust size of rects for ideal clear time

    if( elapsed <= 0.0f ) {
        rectSize = 1;
        return rectSize;
    }

    nRects = RectangleCount( width, height, baseSize );
    factor = fClearTime / elapsed;
    idealNRects = (int) (factor * (float)nRects);
    rectSize = (int) (sqrt( (double)(width*height) / (double)idealNRects ) + 0.5);
    if( rectSize == 0 )
        rectSize = 1;

    return rectSize;
}

/******************************Public*Routine******************************\
* 
* SS_DIGITAL_DISSOLVE_CLEAR::Clear
*
* Clears by drawing random rectangles
*
\**************************************************************************/


BOOL SS_DIGITAL_DISSOLVE_CLEAR::
Clear( int width, int height )
{
    return Clear( width, height, rectSize );
}

BOOL SS_DIGITAL_DISSOLVE_CLEAR::
Clear( int width, int height, int size )
{
    BOOL *pRect;
    BOOL bCalibrate = FALSE;
    int count, nRects;
    int i, xdim, ydim;
    static float idealTime = 2.0f;

    if( (size <= 0) || !width || !height )
        return FALSE;

    // determine xdim, ydim from size
    xdim = SS_ROUND_UP( (float)width / (float)size );
    ydim = SS_ROUND_UP( (float)height / (float) size );

    // figure out how many rects needed
    count = nRects = xdim * ydim;

    // make sure enough room
    if( !ValidateBufSize( nRects ) )
        return FALSE;

    // reset the rect array to uncleared

    pRect = rectBuf;
    for( i = 0; i < count; i ++, pRect++ )
        *pRect = FALSE;

    // Clear random rectangles

    glEnable( GL_SCISSOR_TEST );

    while( count ) {
        // pick a random rect
        i = ss_iRand( nRects );

        if( rectBuf[i] ) {
            // This rect has already been cleared - find an empty one
            // Scan up and down from x,y, looking at the array linearly

            int up, down;
            BOOL searchUp = FALSE;

            up = down = i;

            pRect = rectBuf;
            while( *(pRect + i) ) {
                if( searchUp ) {
                    // search up side
                    if( up < (nRects-1) ) {
                        up++;
                    }
                    i = up;
                } else {
                    // search down side
                    if( down > 0 ) {
                        down--;
                    }
                    i = down;
                }
                searchUp = !searchUp;
            }
        }

        // clear the x,y rect
        glScissor( (i % xdim)*size, (i / xdim)*size, size, size );
        glClear( GL_COLOR_BUFFER_BIT );
        glFlush();

        rectBuf[i] = TRUE; // mark as taken
        count--;
    }

    glDisable( GL_SCISSOR_TEST );

    return TRUE;
}

/******************************Public*Routine******************************\
* RectangleCount
*
\**************************************************************************/

int SS_DIGITAL_DISSOLVE_CLEAR::
RectangleCount( int width, int height, int size )
{
    return  SS_ROUND_UP( (float)width / (float)size ) *
            SS_ROUND_UP( (float)height / (float) size );
}

/******************************Public*Routine******************************\
* ValidateBufSize
*
\**************************************************************************/

BOOL SS_DIGITAL_DISSOLVE_CLEAR::
ValidateBufSize( int nRects )
{
    if( nRects > rectBufSize ) {
        // need a bigger rect buf
        BOOL *r = (BOOL *) LocalAlloc( LMEM_FIXED, sizeof(BOOL) * nRects );
        if( !r )
            return FALSE;
        if( rectBuf )
            LocalFree( rectBuf );
        rectBuf = r;
        rectBufSize = nRects;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
* DrawGdiRect
*
* Clears the rect with the brush
\**************************************************************************/

void
DrawGdiRect( HDC hdc, HBRUSH hbr, RECT *pRect ) 
{
    if( pRect == NULL )
        return;

    FillRect( hdc, pRect, hbr );
    GdiFlush();
}

#ifdef SS_INITIAL_CLEAR
/*-----------------------------------------------------------------------
|                                                                       
|    RectWipeClear(width, height):  
|       - Does a rectangular wipe (or clear) by drawing in a sequence   
|         of rectangles using Gdi                                       
|       MOD: add calibrator capability to adjust speed for different
|            architectures
|       MOD: this can be further optimized by caching the brush
|
-----------------------------------------------------------------------*/
void 
ss_GdiRectWipeClear( HWND hwnd, int width, int height )
{
    HDC hdc;
    HBRUSH hbr;
    RECT rect;
    int i, j, xinc, yinc, numDivs = 500;
    int xmin, xmax, ymin, ymax;
    int repCount = 10;

    xinc = 1;
    yinc = 1;
    numDivs = height;
    xmin = ymin = 0;
    xmax = width;
    ymax = height;

    hdc = GetDC( hwnd );

    hbr = CreateSolidBrush( RGB( 0, 0, 0 ) );

    for( i = 0; i < (numDivs/2 - 1); i ++ ) {
      for( j = 0; j < repCount; j ++ ) {
        rect.left = xmin; rect.top = ymin;
        rect.right = xmax; rect.bottom = ymin + yinc;
        FillRect( hdc, &rect, hbr );
        rect.top = ymax - yinc;
        rect.bottom = ymax;
        FillRect( hdc, &rect, hbr );
        rect.top = ymin + yinc;
        rect.right = xmin + xinc; rect.bottom = ymax - yinc;
        FillRect( hdc, &rect, hbr );
        rect.left = xmax - xinc; rect.top = ymin + yinc;
        rect.right = xmax; rect.bottom = ymax - yinc;
        FillRect( hdc, &rect, hbr );
      }

      xmin += xinc;
      xmax -= xinc;
      ymin += yinc;
      ymax -= yinc;
    }

    // clear last square in middle

    rect.left = xmin; rect.top = ymin;
    rect.right = xmax; rect.bottom = ymax;
    FillRect( hdc, &rect, hbr );

    DeleteObject( hbr );

    ReleaseDC( hwnd, hdc );

    GdiFlush();
}
#endif // SS_INITIAL_CLEAR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\ss3dfo.h ===
/******************************Module*Header*******************************\
* Module Name: ssopengl.h
*
* Global header for the 3D Flying Objects screen saver.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include "sscommon.h"

// redefine PI as a double for all 3dfo code
#undef PI
#define PI PI_D

#define PALETTE_PER_MATL    32
#define PALETTE_PER_DIFF    26
#define PALETTE_PER_SPEC    6
#define MATL_MAX            7

typedef struct strFACE {
    POINT3D p[4];
    POINT3D n[4];
    POINT3D fn;
    int idMatl;
} FACE;

typedef struct strMFACE {
    int p[4];
    int material;
    POINT3D norm;
} MFACE;

typedef struct strMESH {
    int numFaces;
    int numPoints;
    POINT3D *pts;
    POINT3D *norms;
    MFACE *faces;
    GLint listID;
} MESH;

extern BOOL bSmoothShading;
extern BOOL bFalseColor;
extern BOOL bColorCycle;
extern float fTesselFact;
extern TEXFILE gTexFile;
extern BOOL gbBounce;

extern MATERIAL Material[];
extern int NumLights;

extern void newMesh(MESH *, int numFaces, int numPts);
extern void delMesh(MESH *);
extern void revolveSurface(MESH *, POINT3D *curve, int steps);

extern void *SaverAlloc(ULONG);
extern void SaverFree(void *);

// Resource constants

#define IDS_SAVERNAME           1002
#define IDS_FALSECOLOR          1004
#define IDS_SMOOTHSHADING       1005
#define IDS_OPTIONS             1007
#define IDS_OBJTYPE             1008
#define IDS_SCREENSAVERTITLE    1020

#define IDS_LOGO                1100
#define IDS_EXPLODE             1101
#define IDS_RIBBON              1102
#define IDS_2RIBBON             1103
#define IDS_SPLASH              1104
#define IDS_TWIST               1105
#define IDS_FLAG                1106

#define DLG_SETUP_HELP          2001
#define DLG_SETUP_TYPES         2002
#define DLG_SETUP_BITMAP        2003
#define DLG_SETUP_FCOLOR        2004
#define DLG_SETUP_SMOOTH        2005
#define DLG_SETUP_CYCLE         2006
#define DLG_SETUP_ABOUT         2007
#define DLG_SETUP_TESSEL        2008
#define DLG_SETUP_SIZE          2009
#define DLG_SETUP_TEXTURE       2010
#define IDC_STATIC_TESS         2011
#define IDC_STATIC_TESS_MIN     2012
#define IDC_STATIC_TESS_MAX     2013
#define IDC_STATIC_SIZE         2014
#define IDC_STATIC_SIZE_MIN     2015
#define IDC_STATIC_SIZE_MAX     2016

#define IDB_DEFTEX              3000

#define SHELP_CONTENTS          01
#define SHELP_SHAPES            02
#define SHELP_PASSWORD          03
#define SHELP_COLOR             04
#define SHELP_MISC              05
#define SHELP_OVERVIEW          06
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\color.c ===
#include <windows.h>
#include <math.h>
#include <GL/gl.h>
#include "sscommon.h"


/******************************Public*Routine******************************\
* HsvToRgb
*
* HSV to RGB color space conversion.  From pg. 593 of Foley & van Dam.
*
\**************************************************************************/

void 
ss_HsvToRgb(float h, float s, float v, RGBA *color )
{
    float i, f, p, q, t;

    // set alpha value, so caller doesn't have to worry about undefined value
    color->a = 1.0f;

    if (s == 0.0f)     // assume h is undefined
        color->r = color->g = color->b = v;
    else {
        if (h >= 360.0f)
            h = 0.0f;
        h = h / 60.0f;
        i = (float) floor(h);
        f = h - i;
        p = v * (1.0f - s);
        q = v * (1.0f - (s * f));
        t = v * (1.0f - (s * (1.0f - f)));
        switch ((int)i) {
        case 0:
            color->r = v;
            color->g = t;
            color->b = p;
            break;
        case 1:
            color->r = q;
            color->g = v;
            color->b = p;
            break;
        case 2:
            color->r = p;
            color->g = v;
            color->b = t;
            break;
        case 3:
            color->r = p;
            color->g = q;
            color->b = v;
            break;
        case 4:
            color->r = t;
            color->g = p;
            color->b = v;
            break;
        case 5:
            color->r = v;
            color->g = p;
            color->b = q;
            break;
        default:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\ss3dfo.c ===
/******************************Module*Header*******************************\
* Module Name: ss3dfo.c
*
* Dispatcher and dialog box for the OpenGL-based 3D Flying Objects screen
* saver.
*
* Created: 18-May-1994 14:54:59
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#include <windows.h>
#include <scrnsave.h>
#include <GL\gl.h>
#include <math.h>
#include <memory.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys\timeb.h>
#include <time.h>
#include <commdlg.h>
#include <commctrl.h>
#include "ss3dfo.h"

//#define SS_DEBUG 1

// Global strings.
#define GEN_STRING_SIZE 64

static SSContext gssc;
BOOL gbBounce = FALSE; // floating window bounce off side

// Global message loop variables.
MATERIAL Material[16];
#ifdef MEMDEBUG
ULONG totalMem = 0;
#endif

// Global screen saver settings.

void (*updateSceneFunc)(int); // current screen saver update function
void (*delSceneFunc)(void);         // current screen saver deletion function
BOOL bColorCycle = FALSE;           // color cycling flag
BOOL bSmoothShading = TRUE;         // smooth shading flag
UINT uSize = 100;                   // object size
float fTesselFact = 1.0f;           // object tessalation
int UpdateFlags = 0;                // extra data sent to update function
int Type = 0;                       // screen saver index (into function arrays)

// Texture file information
TEXFILE gTexFile = {0};

// Lighting properties.

static const RGBA lightAmbient   = {0.21f, 0.21f, 0.21f, 1.0f};
static const RGBA light0Ambient  = {0.0f, 0.0f, 0.0f, 1.0f};
static const RGBA light0Diffuse  = {0.7f, 0.7f, 0.7f, 1.0f};
static const RGBA light0Specular = {1.0f, 1.0f, 1.0f, 1.0f};
static const GLfloat light0Pos[]      = {100.0f, 100.0f, 100.0f, 0.0f};

// Material properties.

static RGBA matlColors[7] = {{1.0f, 0.0f, 0.0f, 1.0f},
                             {0.0f, 1.0f, 0.0f, 1.0f},
                             {0.0f, 0.0f, 1.0f, 1.0f},
                             {1.0f, 1.0f, 0.0f, 1.0f},
                             {0.0f, 1.0f, 1.0f, 1.0f},
                             {1.0f, 0.0f, 1.0f, 1.0f},
                             {0.235f, 0.0f, 0.78f, 1.0f},
                            };

extern void updateStripScene(int);
extern void updateDropScene(int);
extern void updateLemScene(int);
extern void updateExplodeScene(int);
extern void updateWinScene(int);
extern void updateTexScene(int);
extern void initStripScene(void);
extern void initDropScene(void);
extern void initLemScene(void);
extern void initExplodeScene(void);
extern void initWinScene(void);
extern void initTexScene(void);
extern void delStripScene(void);
extern void delDropScene(void);
extern void delLemScene(void);
extern void delExplodeScene(void);
extern void delWinScene(void);
extern void delTexScene(void);

typedef void (*PTRUPDATE)(int);
typedef void (*ptrdel)();
typedef void (*ptrinit)();

// Each screen saver style puts its hook functions into the function
// arrays below.  A consistent ordering of the functions is required.

static PTRUPDATE updateFuncs[] =
    {updateWinScene, updateExplodeScene,updateStripScene, updateStripScene,
     updateDropScene, updateLemScene, updateTexScene};
static ptrdel delFuncs[] =
    {delWinScene, delExplodeScene, delStripScene, delStripScene,
     delDropScene, delLemScene, delTexScene};
static ptrinit initFuncs[] =
    {initWinScene, initExplodeScene, initStripScene, initStripScene,
     initDropScene, initLemScene, initTexScene};
static int idsStyles[] =
    {IDS_LOGO, IDS_EXPLODE, IDS_RIBBON, IDS_2RIBBON,
     IDS_SPLASH, IDS_TWIST, IDS_FLAG};

#define MAX_TYPE    ( sizeof(initFuncs) / sizeof(ptrinit) - 1 )

// Each screen saver style can choose which dialog box controls it wants
// to use.  These flags enable each of the controls.  Controls not choosen
// will be disabled.

#define OPT_COLOR_CYCLE     0x00000001
#define OPT_SMOOTH_SHADE    0x00000002
#define OPT_TESSEL          0x00000008
#define OPT_SIZE            0x00000010
#define OPT_TEXTURE         0x00000020
#define OPT_STD             ( OPT_COLOR_CYCLE | OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE )

static ULONG gflConfigOpt[] = {
     OPT_STD,               // Windows logo
     OPT_STD,               // Explode
     OPT_STD,               // Strip
     OPT_STD,               // Strip
     OPT_STD,               // Drop
     OPT_STD,               // Twist (lemniscate)
     OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE | OPT_TEXTURE  // Texture mapped flag
};

static void updateDialogControls(HWND hDlg);

#ifdef MEMDEBUG
void xprintf(char *str, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, str);
    vsprintf(buffer, str, ap);

    OutputDebugString(buffer);
    va_end(ap);
}
#endif

void *SaverAlloc(ULONG size)
{
    void *mPtr;

    mPtr = malloc(size);
#ifdef MEMDEBUG
    totalMem += size;
    xprintf("malloc'd %x, size %d\n", mPtr, size);
#endif
    return mPtr;
}

void SaverFree(void *pMem)
{
#ifdef MEMDEBUG
    totalMem -= _msize(pMem);
    xprintf("free %x, size = %d, total = %d\n", pMem, _msize(pMem), totalMem);
#endif
    free(pMem);
}

/******************************Public*Routine******************************\
* getIniSettings
*
* Get the screen saver configuration options from .INI file/registry.
*
* History:
*  10-May-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static void getIniSettings()
{
    int    options;
    int    optMask = 1;
    TCHAR  szDefaultBitmap[MAX_PATH];
    int    tessel=0;
    LPTSTR  psz;

    LoadString(hMainInstance, IDS_GENNAME, szScreenSaver, sizeof(szScreenSaver) / sizeof(TCHAR));

    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        options = ss_GetRegistryInt( IDS_OPTIONS, -1 );
        if (options >= 0)
        {
            bSmoothShading = ((options & optMask) != 0);
            optMask <<= 1;
            bColorCycle = ((options & optMask) != 0);
            UpdateFlags = (bColorCycle << 1);
        }

        Type = ss_GetRegistryInt( IDS_OBJTYPE, 0 );

        // Sanity check Type.  Don't want to index into function arrays
        // with a bad index!
        Type = min(Type, MAX_TYPE);

        // Set flag so that updateStripScene will do two strips instead
        // of one.

        if (Type == 3)
            UpdateFlags |= 0x4;

        tessel = ss_GetRegistryInt( IDS_TESSELATION, 100 );
        SS_CLAMP_TO_RANGE2( tessel, 0, 200 );

        if (tessel <= 100)
            fTesselFact  = (float)tessel / 100.0f;
        else
            fTesselFact = 1.0f + (((float)tessel - 100.0f) / 100.0f);

        uSize = ss_GetRegistryInt( IDS_SIZE, 50 );
        if (uSize > 100)
            uSize = 100;
        // SS_CLAMP_TO_RANGE2( uSize, 0, 100 );  /* can't be less than zero since it is a UINT */

        // Determine the default .bmp file

        ss_GetDefaultBmpFile( szDefaultBitmap );

        // Is there a texture specified in the registry that overrides the
        // default?


        ss_GetRegistryString( IDS_TEXTURE, szDefaultBitmap, gTexFile.szPathName,
                              MAX_PATH);

        gTexFile.nOffset = ss_GetRegistryInt( IDS_TEXTURE_FILE_OFFSET, 0 );
    }
}

/******************************Public*Routine******************************\
* saveIniSettings
*
* Save the screen saver configuration option to the .INI file/registry.
*
* History:
*  10-May-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static void saveIniSettings(HWND hDlg)
{
    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        int pos, options;
        int optMask = 1;

        bSmoothShading = IsDlgButtonChecked(hDlg, DLG_SETUP_SMOOTH);
        bColorCycle = IsDlgButtonChecked(hDlg, DLG_SETUP_CYCLE);
        options = bColorCycle;
        options <<= 1;
        options |= bSmoothShading;
        ss_WriteRegistryInt( IDS_OPTIONS, options );

        Type = (int)SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_GETCURSEL,
                                       0, 0);
        ss_WriteRegistryInt( IDS_OBJTYPE, Type );

        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_TESSEL );
        ss_WriteRegistryInt( IDS_TESSELATION, pos );

        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_SIZE );
        ss_WriteRegistryInt( IDS_SIZE, pos );

        ss_WriteRegistryString( IDS_TEXTURE, gTexFile.szPathName );
        ss_WriteRegistryInt( IDS_TEXTURE_FILE_OFFSET, gTexFile.nOffset );
    }
}

/******************************Public*Routine******************************\
* setupDialogControls
*
* Setup the dialog controls initially.
*
\**************************************************************************/

static void
setupDialogControls(HWND hDlg)
{
    int pos;

    InitCommonControls();

    if ( gflConfigOpt[Type] & OPT_TESSEL )
    {
        if (fTesselFact <= 1.0f)
            pos = (int)(fTesselFact * 100.0f);
        else
            pos = 100 + (int) ((fTesselFact - 1.0f) * 100.0f);

        ss_SetupTrackbar( hDlg, DLG_SETUP_TESSEL, 0, 200, 1, 10, pos );
    }

    if ( gflConfigOpt[Type] & OPT_SIZE )
    {
        ss_SetupTrackbar( hDlg, DLG_SETUP_SIZE, 0, 100, 1, 10, uSize );
    }

    updateDialogControls( hDlg );
}

/******************************Public*Routine******************************\
* updateDialogControls
*
* Update the dialog controls based on the current global state.
*
\**************************************************************************/

static void
updateDialogControls(HWND hDlg)
{
    CheckDlgButton(hDlg, DLG_SETUP_SMOOTH, bSmoothShading);
    CheckDlgButton(hDlg, DLG_SETUP_CYCLE, bColorCycle);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SMOOTH),
                 gflConfigOpt[Type] & OPT_SMOOTH_SHADE );
    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_CYCLE),
                 gflConfigOpt[Type] & OPT_COLOR_CYCLE );

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TESSEL),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MIN),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MAX),
                 gflConfigOpt[Type] & OPT_TESSEL);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SIZE),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MIN),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MAX),
                 gflConfigOpt[Type] & OPT_SIZE);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TEXTURE),
                 gflConfigOpt[Type] & OPT_TEXTURE);
}

BOOL WINAPI RegisterDialogClasses(HANDLE hinst)
{
    return TRUE;
}

/******************************Public*Routine******************************\
* ScreenSaverConfigureDialog
*
* Processes messages for the configuration dialog box.
*
\**************************************************************************/

BOOL ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                WPARAM wParam, LPARAM lParam)
{
    int wTmp;
    TCHAR szString[GEN_STRING_SIZE];

    switch (message) {
        case WM_INITDIALOG:
            getIniSettings();

            setupDialogControls(hDlg);

            for (wTmp = 0; wTmp <= MAX_TYPE; wTmp++) {
                LoadString(hMainInstance, idsStyles[wTmp], szString, GEN_STRING_SIZE);
                SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_ADDSTRING, 0,
                                   (LPARAM) szString);
            }
            SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_SETCURSEL, Type, 0);

            return TRUE;


        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case DLG_SETUP_TYPES:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        case CBN_SELCHANGE:
                            Type = (int)SendDlgItemMessage(hDlg, DLG_SETUP_TYPES,
                                                           CB_GETCURSEL, 0, 0);
                            updateDialogControls(hDlg);
                            break;
                        default:
                            break;
                    }
                    return FALSE;

                case DLG_SETUP_TEXTURE:
                    ss_SelectTextureFile( hDlg, &gTexFile );
                    break;

                case IDOK:
                    saveIniSettings(hDlg);
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case DLG_SETUP_SMOOTH:
                case DLG_SETUP_CYCLE:
                default:
                    break;
            }
            return TRUE;
            break;

        default:
            return 0;
    }
    return 0;
}

/******************************Public*Routine******************************\
* SetFloaterInfo
*
* Set the size and motion of the floating window
* It stays square in shape
*
\**************************************************************************/

static void
SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild )
{
    float sizeFact;
    float sizeScale;
    int size;
    ISIZE *pChildSize = &pChild->size;
    MOTION_INFO *pMotion = &pChild->motionInfo;

    sizeScale = (float)uSize / 100.0f; // 0..1
    sizeFact = 0.25f + (0.30f * sizeScale);
    size = (int) (sizeFact * ( ((float)(pParentSize->width + pParentSize->height)) / 2.0f ));
    SS_CLAMP_TO_RANGE2( size, 0, pParentSize->width );
    SS_CLAMP_TO_RANGE2( size, 0, pParentSize->height );

    pChildSize->width = pChildSize->height = size;

    // Floater motion
    pMotion->posInc.x = .01f * (float) size;
    if( pMotion->posInc.x < 1.0f )
        pMotion->posInc.x = 1.0f;
    pMotion->posInc.y = pMotion->posInc.x;
    pMotion->posIncVary.x = .4f * pMotion->posInc.x;
    pMotion->posIncVary.y = pMotion->posIncVary.x;
}

/******************************Public*Routine******************************\
* initMaterial
*
* Initialize the material properties.
*
\**************************************************************************/

void initMaterial(int id, float r, float g, float b, float a)
{
    Material[id].ka.r = r;
    Material[id].ka.g = g;
    Material[id].ka.b = b;
    Material[id].ka.a = a;

    Material[id].kd.r = r;
    Material[id].kd.g = g;
    Material[id].kd.b = b;
    Material[id].kd.a = a;

    Material[id].ks.r = 1.0f;
    Material[id].ks.g = 1.0f;
    Material[id].ks.b = 1.0f;
    Material[id].ks.a = 1.0f;

    Material[id].specExp = 128.0f;
}

/******************************Public*Routine******************************\
* _3dfo_Init
*
\**************************************************************************/

static void
_3dfo_Init(void *data)
{
    int i;

    for (i = 0; i < 7; i++)
        initMaterial(i, matlColors[i].r, matlColors[i].g,
                     matlColors[i].b, matlColors[i].a);


    // Set the OpenGL clear color to black.

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
#ifdef SS_DEBUG
    glClearColor(0.2f, 0.2f, 0.2f, 0.0f);
#endif

    // Enable the z-buffer.

    glEnable(GL_DEPTH_TEST);

    // Select the shading model.

    if (bSmoothShading)
        glShadeModel(GL_SMOOTH);
    else
        glShadeModel(GL_FLAT);

    // Setup the OpenGL matrices.

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // Setup the lighting.

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (GLfloat *) &lightAmbient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);
    glLightfv(GL_LIGHT0, GL_AMBIENT, (GLfloat *) &light0Ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, (GLfloat *) &light0Diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, (GLfloat *) &light0Specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    // Setup the material properties.

    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (GLfloat *) &Material[0].ks);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, (GLfloat *) &Material[0].specExp);

    // call specific objects init func
    (*initFuncs[Type])();
    updateSceneFunc = updateFuncs[Type];
}

/******************************Public*Routine******************************\
* _3dfo_Draw
*
\**************************************************************************/

static void
_3dfo_Draw(void *data)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    (*updateSceneFunc)(UpdateFlags);
}

/******************************Public*Routine******************************\
* _3dfo_FloaterBounce
*
\**************************************************************************/

static void
_3dfo_FloaterBounce(void *data)
{
    gbBounce = TRUE;
}

/******************************Public*Routine******************************\
* ss_Init
*
* Screen saver entry point.  Pre-GL initialization
*
\**************************************************************************/

SSContext *
ss_Init(void)
{
    getIniSettings();

    // Make sure the selected texture file is OK.

    if ( gflConfigOpt[Type] & OPT_TEXTURE )
    {
        // Verify texture file
        ss_DisableTextureErrorMsgs();
        ss_VerifyTextureFile( &gTexFile );
    }

    // set callbacks

    ss_InitFunc( _3dfo_Init );
    ss_UpdateFunc( _3dfo_Draw );

    // set configuration info to return

    gssc.bDoubleBuf = TRUE;
    gssc.depthType = SS_DEPTH16;

    gssc.bFloater = TRUE;
    gssc.floaterInfo.bMotion = TRUE;
    gssc.floaterInfo.ChildSizeFunc = SetFloaterInfo;
    ss_FloaterBounceFunc( _3dfo_FloaterBounce );

    return &gssc;
}

/**************************************************************************\
* ConfigInit
*
* Dialog box version of ss_Init.  Used for setting up any gl drawing on the
* dialog.
*
\**************************************************************************/
BOOL
ss_ConfigInit( HWND hDlg )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\mesh.h ===
/******************************Module*Header*******************************\
* Module Name: mesh.h
*
* Declaration of the mesh routines.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

extern void newMesh(MESH *mesh, int numFaces, int numPts);
extern void delMesh(MESH *mesh);
extern void revolveSurface(MESH *mesh, POINT3D *curve, int steps);
extern void updateObject(MESH *mesh, BOOL bSmooth);
extern void updateObject2(MESH *mesh, BOOL bSmooth);
extern void MakeList(GLuint listID, MESH *mesh);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\3dfo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ss3dfo.rc
//
#define IDI_ICON1                       103
#define IDI_ICON2                       104
#define IDC_SLIDER1                     1013
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#include "commctrl.h"
#include "ss3dfo.h"
#include "sscommon.h"
#include "sscommon.rc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\dlgdraw.cxx ===
/******************************Module*Header*******************************\
* Module Name: dlgdraw.c
*
* For gl drawing in dialog boxes
*
* Created: 12-06-95 -by- Marc Fortier [marcfo]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include <windows.h>
#include <commdlg.h>
#include <scrnsave.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include "ssintrnl.hxx"
#include "dlgdraw.hxx"

// Define this if want each TEX_BUTTON to be a separate window.  This is
// necessary if the main dialog window has WS_CLIP_CHILDREN, but so far this
// doesn't seem to be the case.
//#define SS_MULTIWINDOW 1

static void CalcGLViewport( HWND hwndParent, HWND hwndChild, IPOINT2D *pOrigin, ISIZE *pSize );

//materials for varying intensities

enum{
    MAT_INTENSITY_LOW = 0,
    MAT_INTENSITY_MID,
    MAT_INTENSITY_HIGH,
    MAT_COUNT
};

MATERIAL gMat[MAT_COUNT] = {
    {{0.3f, 0.3f, 0.3f}, {0.6f, 0.6f, 0.6f}, {0.2f, 0.2f, 0.2f}, 0.3f },
    {{0.2f, 0.2f, 0.2f}, {0.8f, 0.8f, 0.8f}, {0.2f, 0.2f, 0.2f}, 0.3f },
    {{0.2f, 0.2f, 0.2f}, {1.0f, 1.0f, 1.0f}, {0.2f, 0.2f, 0.2f}, 0.3f }
};

float colorBlack[3] = {0.0f, 0.0f, 0.0f};

/**************************************************************************\
* SS_TEX_BUTTON constructor
*
* This allows drawing GL textures on a button
*
* For optimum performance, GL is configured on the main dialog window, and
* 'viewported' to the button.
* Defining SS_MULTIWINDOW results in the texture being drawn in the actual
* button window.
*
* Note: this only works for buttons on the main dialog window for now.
\**************************************************************************/

SS_TEX_BUTTON::SS_TEX_BUTTON( HWND hDlg, HWND hDlgBtn )
{
    PSSW psswParent = gpss->sswTable.PsswFromHwnd( hDlg );
    SS_ASSERT( psswParent, "SS_TEX_BUTTON constructor: NULL psswParent\n" );

    // The parent needs to have an hrc context, since we will be using it
    // for drawing.

    SS_GL_CONFIG GLc = { 0, 0, NULL };
    if( !psswParent->ConfigureForGL( &GLc ) ) {
        SS_WARNING( "SS_TEX_BUTTON constructor: ConfigureForGL failed\n" );
        return;
    }

#ifdef SS_MULTIWINDOW
    // Each button is a separate GL window, using its parents hrc
    pssw = new SSW( psswParent, hDlgBtn );

    SS_ASSERT( pssw, "SS_TEX_BUTTON constructor: pssw alloc failure\n" );

    // Configure the pssw for GL

    GLc.pfFlags = 0;
    GLc.hrc = psswParent->GetHRC();
    GLc.pStretch = NULL;

    if( ! pssw->ConfigureForGL( &GLc ) ) {
        SS_WARNING( "SS_TEX_BUTTON constructor: ConfigureForGL failed\n" );
        return;
    }
#else
    // Make the button a 'subwindow' of the parent
    pssw = NULL;

    // Calculate the viewport to draw to

    CalcGLViewport( hDlg, hDlgBtn, &origin, &size );
#endif

    // Init various GL stuff
    InitGL();

    pCurTex = NULL;
    bEnabled = TRUE;
}

/**************************************************************************\
* SS_TEX_BUTTON destructor
*
\**************************************************************************/

SS_TEX_BUTTON::~SS_TEX_BUTTON()
{
    if( pssw )
        delete pssw;
}

/**************************************************************************\
* InitGL
*
\**************************************************************************/

void
SS_TEX_BUTTON::InitGL()
{
    float ambient[] = {0.2f, 0.2f, 0.2f, 1.0f};
    float diffuse[] = {0.7f, 0.7f, 0.7f, 1.0f};
    float position[] = {0.0f, 0.0f, -150.0f, 1.0f};
    float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f};
    MATERIAL *pMat;

    // lighting, for intensity levels

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glEnable(GL_LIGHT0);

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);

    glCullFace( GL_BACK );
    glEnable(GL_CULL_FACE);
    glFrontFace( GL_CW );
    glShadeModel( GL_FLAT );

    glColor3f( 1.0f, 1.0f, 1.0f );
    gluOrtho2D( -1.0, 1.0, -1.0, 1.0 );

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
}

/**************************************************************************\
* SetTexture
*
* Set a current texture for the button
*
* Note this is a pointer to a texture, so any texture memory management is
* done by the caller.
\**************************************************************************/

void
SS_TEX_BUTTON::SetTexture( TEXTURE *pTex )
{
    pCurTex = pTex;
}

/**************************************************************************\
* Draw
*
\**************************************************************************/

void
SS_TEX_BUTTON::Draw( TEXTURE *pTex )
{
    if( pTex != NULL ) {
        glEnable(GL_TEXTURE_2D);

        ss_SetTexture( pTex ); // doesn't look at iPalRot yet
        // Set the texture palette if it exists
        if( pTex->pal && pTex->iPalRot )
            ss_SetTexturePalette( pTex, pTex->iPalRot );
    }
    // else white rectangle will be drawn

    if( bEnabled )
        intensity = DLG_INTENSITY_HIGH;
    else
        intensity = DLG_INTENSITY_LOW;

    switch( intensity ) {
        case DLG_INTENSITY_LOW:
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
            glEnable(GL_LIGHTING);
            glColor3f( 0.5f, 0.5f, 0.5f );
            break;
        case DLG_INTENSITY_MID:
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
            glEnable(GL_LIGHTING);
            glColor3f( 0.7f, 0.7f, 0.7f );
            break;
        case DLG_INTENSITY_HIGH:
        default:
            glColor3f( 1.0f, 1.0f, 1.0f );
            glDisable(GL_LIGHTING);
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    }

    // Set the viewport
#ifdef SS_MULTIWINDOW
    glViewport( 0, 0, pssw->size.width, pssw->size.height );
#else
    glViewport( origin.x, origin.y, size.width, size.height );
#endif

    glBegin( GL_QUADS );
        glTexCoord2f( 0.0f, 1.0f );
        glVertex2f( -1.0f, 1.0f );
        glTexCoord2f( 1.0f, 1.0f );
        glVertex2f(  1.0f,  1.0f );
        glTexCoord2f( 1.0f, 0.0f );
        glVertex2f(  1.0f, -1.0f );
        glTexCoord2f( 0.0f, 0.0f );
        glVertex2f(  -1.0f, -1.0f );
    glEnd();

    glDisable( GL_TEXTURE_2D);

    glFlush();
}

void
SS_TEX_BUTTON::Draw()
{
    Draw( pCurTex );
}

/**************************************************************************\
* CalcGLViewport
*
* Calculate viewport for the child window
*
\**************************************************************************/

static void 
CalcGLViewport( HWND hwndParent, HWND hwndChild, IPOINT2D *pOrigin, ISIZE *pSize )
{
    RECT childRect, parentRect;

    // Get size of the child window

    GetClientRect( hwndChild, &childRect );
    pSize->width = childRect.right;
    pSize->height = childRect.bottom;

    // Calc origin of the child window wrt its parents client area
    // Note that the y-coord must be inverted for GL

    // Map the child client rect to the parent client coords
    MapWindowPoints( hwndChild, hwndParent, (POINT *) &childRect, 2 );
    pOrigin->x = childRect.left;
    // invert y coord
    GetClientRect( hwndParent, &parentRect );
    pOrigin->y = parentRect.bottom - childRect.bottom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\dialog.c ===
/******************************Module*Header*******************************\
* Module Name: dialog.c
*
* Dialog helper functions
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <commdlg.h>
#include <commctrl.h>
#include "sscommon.h"

#define BUF_SIZE 30
static TCHAR  szSectName[BUF_SIZE];
static TCHAR  szItemName[BUF_SIZE];
static TCHAR  szFname[BUF_SIZE];
static TCHAR  szTmp[BUF_SIZE];
static HINSTANCE hInstance = 0;

/******************************Public*Routine******************************\
* ss_RegistrySetup
*
* Setup for registry access
*
\**************************************************************************/

BOOL ss_RegistrySetup( HINSTANCE hinst, int section, int file )
{
    if( LoadString(hInstance, section, szSectName, BUF_SIZE) &&
        LoadString(hInstance, file, szFname, BUF_SIZE) ) 
    {
        hInstance = hinst;
        return TRUE;
    }
    return FALSE;
}


/******************************Public*Routine******************************\
* ss_GetRegistryInt
*
* Retrieve integer value from registry
*
\**************************************************************************/

int  ss_GetRegistryInt( int name, int iDefault )
{
    if( LoadString( hInstance, name, szItemName, BUF_SIZE ) ) {
        return GetPrivateProfileInt(szSectName, szItemName, iDefault, szFname);
    }
    return 0;
}

/******************************Public*Routine******************************\
* ss_GetRegistryString
*
* Retrieve string from registry
*
\**************************************************************************/

void ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, 
                           int bufSize )
{
    if( LoadString( hInstance, name, szItemName, BUF_SIZE ) ) {
        GetPrivateProfileString(szSectName, szItemName, lpDefault, lpDest,
                                bufSize, szFname);
    }
}

/******************************Public*Routine******************************\
* ss_WriteRegistryInt
*
* Write integer value to registry
*
\**************************************************************************/

void ss_WriteRegistryInt( int name, int iVal )
{
    if( LoadString(hInstance, name, szItemName, BUF_SIZE) ) {
        wsprintf(szTmp, TEXT("%ld"), iVal);
        WritePrivateProfileString(szSectName, szItemName, szTmp, szFname);
    }
}

/******************************Public*Routine******************************\
* ss_WriteRegistryString
*
* Write string value to registry
*
\**************************************************************************/

void ss_WriteRegistryString( int name, LPTSTR lpString )
{
    if( LoadString(hInstance, name, szItemName, BUF_SIZE) ) {
        WritePrivateProfileString(szSectName, szItemName, lpString, szFname);
    }
}

/******************************Public*Routine******************************\
* GetTrackbarPos
*
* Get the current position of a common control trackbar
\**************************************************************************/

int
ss_GetTrackbarPos( HWND hDlg, int item )
{
    return 
       (int)SendDlgItemMessage( 
            hDlg, 
            item,
            TBM_GETPOS, 
            0,
            0
        );
}

/******************************Public*Routine******************************\
* SetupTrackbar
*
* Setup a common control trackbar
\**************************************************************************/

void
ss_SetupTrackbar( HWND hDlg, int item, int lo, int hi, int lineSize, 
                  int pageSize, int pos )
{
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETRANGE, 
        (WPARAM) TRUE, 
        (LPARAM) MAKELONG( lo, hi )
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPOS, 
        (WPARAM) TRUE, 
        (LPARAM) pos
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPAGESIZE, 
        (WPARAM) 0,
        (LPARAM) pageSize 
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETLINESIZE, 
        (WPARAM) 0,
        (LPARAM) lineSize
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\glscrnsv.h ===
/******************************Module*Header*******************************\
* Module Name: glscrnsv.h
*
* Include for modified scrnsave.c
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef __glscrnsv_h__
#define __glscrnsv_h__

#include "sscommon.hxx"
#include "sswproc.hxx"

#ifdef __cplusplus
extern "C" {
#endif

extern INT_PTR DoScreenSave( HWND hwndParent );
extern INT_PTR DoWindowedScreenSave( LPCTSTR szArgs );
extern INT_PTR DoConfigBox( HWND hwndParent );

#ifdef __cplusplus
}
#endif

#endif // __glscrnsv_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\matname.h ===
/******** materials ********************************/

// 24 tea materials (from teapots app)

#define NUM_TEA_MATERIALS 24

enum {
    EMERALD = 0,
    JADE,
    OBSIDIAN,
    PEARL,
    RUBY,
    TURQUOISE,
    BRASS,
    BRONZE,
    CHROME,
    COPPER,
    GOLD,
    SILVER,
    BLACK_PLASTIC,
    CYAN_PLASTIC,
    GREEN_PLASTIC,
    RED_PLASTIC,
    WHITE_PLASTIC,
    YELLOW_PLASTIC,
    BLACK_RUBBER,
    CYAN_RUBBER,
    GREEN_RUBBER,
    RED_RUBBER,
    WHITE_RUBBER,
    YELLOW_RUBBER
};

// 'white' materials, for texturing

#define NUM_TEX_MATERIALS 4

enum {
    BRIGHT_WHITE = NUM_TEA_MATERIALS,
    WHITE,
    WARM_WHITE,
    COOL_WHITE
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\material.c ===
/******************************Module*Header*******************************\
* Module Name: material.c
*
* Material selection functions.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>
#include <GL/gl.h>

#include "sscommon.h"

//#define NUM_TEA_MATERIALS 24

#define NUM_GOOD_MATERIALS 16  // 'good' ones among the 24 tea materials

//#define NUM_TEX_MATERIALS 4  // materials for texture

int goodMaterials[NUM_GOOD_MATERIALS] = {
        EMERALD, JADE, PEARL, RUBY, TURQUOISE, BRASS, BRONZE,
        COPPER, GOLD, SILVER, CYAN_PLASTIC, WHITE_PLASTIC, YELLOW_PLASTIC,
        CYAN_RUBBER, GREEN_RUBBER, WHITE_RUBBER };

/*  materials:  emerald, jade, obsidian, pearl, ruby, turquoise
 *              brass, bronze, chrome, copper, gold, silver
 *              black, cyan, green, red, white, yellow plastic
 *              black, cyan, green, red, white, yellow rubber

    description: ambient(RGB), diffuse(RGB), specular(RGB), shininess
 *
 */
// 'tea' materials, from aux teapots program
static GLfloat teaMaterialData[NUM_TEA_MATERIALS][10] = 
{
     0.0215f, 0.1745f, 0.0215f,
        0.07568f, 0.61424f, 0.07568f, 0.633f, 0.727811f, 0.633f, 0.6f,
     0.135f, 0.2225f, 0.1575f,
        0.54f, 0.89f, 0.63f, 0.316228f, 0.316228f, 0.316228f, 0.1f,
     0.05375f, 0.05f, 0.06625f, // XX
        0.18275f, 0.17f, 0.22525f, 0.332741f, 0.328634f, 0.346435f, 0.3f,
     0.25f, 0.20725f, 0.20725f,
        1.0f, 0.829f, 0.829f, 0.296648f, 0.296648f, 0.296648f, 0.088f,
     0.1745f, 0.01175f, 0.01175f,
        0.61424f, 0.04136f, 0.04136f, 0.727811f, 0.626959f, 0.626959f, 0.6f,
     0.1f, 0.18725f, 0.1745f,
        0.396f, 0.74151f, 0.69102f, 0.297254f, 0.30829f, 0.306678f, 0.1f,
     0.329412f, 0.223529f, 0.027451f,
        0.780392f, 0.568627f, 0.113725f, 0.992157f, 0.941176f, 0.807843f,
        0.21794872f,
     0.2125f, 0.1275f, 0.054f,
        0.714f, 0.4284f, 0.18144f, 0.393548f, 0.271906f, 0.166721f, 0.2f,
     0.25f, 0.25f, 0.25f,  // XX
        0.4f, 0.4f, 0.4f, 0.774597f, 0.774597f, 0.774597f, 0.6f,
     0.19125f, 0.0735f, 0.0225f,
        0.7038f, 0.27048f, 0.0828f, 0.256777f, 0.137622f, 0.086014f, 0.1f,
     0.24725f, 0.1995f, 0.0745f,
        0.75164f, 0.60648f, 0.22648f, 0.628281f, 0.555802f, 0.366065f, 0.4f,
     0.19225f, 0.19225f, 0.19225f,
        0.50754f, 0.50754f, 0.50754f, 0.508273f, 0.508273f, 0.508273f, 0.4f,
     0.0f, 0.0f, 0.0f, 0.01f, 0.01f, 0.01f,
        0.50f, 0.50f, 0.50f, .25f,
     0.0f, 0.1f, 0.06f, 0.0f, 0.50980392f, 0.50980392f,
        0.50196078f, 0.50196078f, 0.50196078f, .25f,
     0.0f, 0.0f, 0.0f,
        0.1f, 0.35f, 0.1f, 0.45f, 0.55f, 0.45f, .25f,
     0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, // XX
        0.7f, 0.6f, 0.6f, .25f,
     0.0f, 0.0f, 0.0f, 0.55f, 0.55f, 0.55f,
        0.70f, 0.70f, 0.70f, .25f,
     0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f,
        0.60f, 0.60f, 0.50f, .25f,
     0.02f, 0.02f, 0.02f, 0.01f, 0.01f, 0.01f, // XX
        0.4f, 0.4f, 0.4f, .078125f,
     0.0f, 0.05f, 0.05f, 0.4f, 0.5f, 0.5f,
        0.04f, 0.7f, 0.7f, .078125f,
     0.0f, 0.05f, 0.0f, 0.4f, 0.5f, 0.4f,
        0.04f, 0.7f, 0.04f, .078125f,
     0.05f, 0.0f, 0.0f, 0.5f, 0.4f, 0.4f,
        0.7f, 0.04f, 0.04f, .078125f,
     0.05f, 0.05f, 0.05f, 0.5f, 0.5f, 0.5f,
        0.7f, 0.7f, 0.7f, .078125f,
     0.05f, 0.05f, 0.0f, 0.5f, 0.5f, 0.4f,
        0.7f, 0.7f, 0.04f, .078125f 
};

// generally white materials for texturing

static GLfloat texMaterialData[NUM_TEX_MATERIALS][10] = {
// bright white
     0.2f, 0.2f, 0.2f,
        1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.5f,
// less bright white
     0.2f, 0.2f, 0.2f,
        0.9f, 0.9f, 0.9f, 0.9f, 0.9f, 0.9f, 0.5f,
// warmish white
     0.3f, 0.2f, 0.2f,
        1.0f, 0.9f, 0.8f, 1.0f, 0.9f, 0.8f, 0.5f,
// coolish white
     0.2f, 0.2f, 0.3f,
        0.8f, 0.9f, 1.0f, 0.8f, 0.9f, 1.0f, 0.5f
};

MATERIAL Material[NUM_TEA_MATERIALS + NUM_TEX_MATERIALS];

// pure black material

MATERIAL ss_BlackMat = {0.0f};

/**************************************************************************\
* InitMaterials
*
* Initialize MATERIAL structures with data
* - Set alpha to 0.5 for all materials
*
\**************************************************************************/

static void
InitMaterials( MATERIAL *pm, float *pd, int count )
{
    int i;

    for( i = 0; i < count; i++, pm++ ) {
        pm->ka.r = *pd++;
        pm->ka.g = *pd++;
        pm->ka.b = *pd++;
        pm->ka.a = 0.5f;
        pm->kd.r = *pd++;
        pm->kd.g = *pd++;
        pm->kd.b = *pd++;
        pm->kd.a = 0.5f;
        pm->ks.r = *pd++;
        pm->ks.g = *pd++;
        pm->ks.b = *pd++;
        pm->ks.a = 0.5f;
        pm->specExp = *pd++;
    }
}

/**************************************************************************\
* ss_InitMaterials
*
* Initialize all materials
*
\**************************************************************************/

void ss_InitMaterials()
{
    ss_InitTeaMaterials();
    ss_InitTexMaterials();
}

/**************************************************************************\
* ss_InitTeaMaterials
*
* Initialize Material structure with data in TeaMaterialData
*
\**************************************************************************/

void ss_InitTeaMaterials()
{
    InitMaterials( Material, teaMaterialData[0], NUM_TEA_MATERIALS );
}


/**************************************************************************\
* ss_InitTexMaterials
*
* Initialize Material structure with data in TexMaterialData (tex materials
* follow the tea materials in Material)
*
\**************************************************************************/

void ss_InitTexMaterials()
{
    InitMaterials( Material+NUM_TEA_MATERIALS, texMaterialData[0], 
                   NUM_TEX_MATERIALS );
}

/**************************************************************************\
* ss_SetMaterial
*
* Set specified material with MATERIAL structure
*
\**************************************************************************/

void ss_SetMaterial( MATERIAL *pMat )
{
    glMaterialfv( GL_FRONT, GL_AMBIENT, (GLfloat*) &pMat->ka );
    glMaterialfv( GL_BACK, GL_AMBIENT, (GLfloat*) &pMat->ka );
    glMaterialfv( GL_FRONT, GL_DIFFUSE, (GLfloat *) &pMat->kd );
    glMaterialfv( GL_BACK, GL_DIFFUSE, (GLfloat *) &pMat->kd );
    glMaterialfv( GL_FRONT, GL_SPECULAR, (GLfloat *) &pMat->ks );
    glMaterialfv( GL_BACK, GL_SPECULAR, (GLfloat *) &pMat->ks );
    glMaterialf ( GL_FRONT, GL_SHININESS, pMat->specExp*128.0f);
    glMaterialf ( GL_BACK, GL_SHININESS, pMat->specExp*128.0f);
}

/**************************************************************************\
* ss_SetMaterialIndex
*
* Set material using its index name
*
\**************************************************************************/

void ss_SetMaterialIndex( int index )
{
    if( (index < 0) || (index >= (NUM_TEA_MATERIALS+NUM_TEX_MATERIALS)) )
        return;
    ss_SetMaterial( &Material[index] );
}

/**************************************************************************\
* ss_CreateMaterialGradient
*
* Given 2 materials and a count, create an incremental material, such
* that adding it 'count' times to the first material will generate the
* 2nd material.
*
\**************************************************************************/
void 
ss_CreateMaterialGradient( MATERIAL *matInc, MATERIAL *startMat,
                        MATERIAL *endMat, int transCount ) 
{
    FLOAT fTransCount;

    if( !transCount ) {
        *matInc = *endMat;
        return;
    }

    /*
     * Add fudge factor to avoid round-off error, which could result in
     * invalid material values.
     */
#define FMAT_GRAD_FUDGE 1.0001f
    fTransCount = (FLOAT) transCount * FMAT_GRAD_FUDGE;

    matInc->ka.r = (endMat->ka.r - startMat->ka.r) / fTransCount;
    matInc->ka.g = (endMat->ka.g - startMat->ka.g) / fTransCount;
    matInc->ka.b = (endMat->ka.b - startMat->ka.b) / fTransCount;
    matInc->ks.r = (endMat->ks.r - startMat->ks.r) / fTransCount;
    matInc->ks.g = (endMat->ks.g - startMat->ks.g) / fTransCount;
    matInc->ks.b = (endMat->ks.b - startMat->ks.b) / fTransCount;
    matInc->kd.r = (endMat->kd.r - startMat->kd.r) / fTransCount;
    matInc->kd.g = (endMat->kd.g - startMat->kd.g) / fTransCount;
    matInc->kd.b = (endMat->kd.b - startMat->kd.b) / fTransCount;
    matInc->specExp = (endMat->specExp - startMat->specExp) / fTransCount;
}

/**************************************************************************\
* ss_TransitionMaterial
*
* Given a material, add to it the incremental material, and set the
* result as the current material
*
\**************************************************************************/
void
ss_TransitionMaterial( MATERIAL *transMat, MATERIAL *transMatInc )
{
    transMat->ka.r += transMatInc->ka.r;
    transMat->ka.g += transMatInc->ka.g;
    transMat->ka.b += transMatInc->ka.b;
    transMat->kd.r += transMatInc->kd.r;
    transMat->kd.g += transMatInc->kd.g;
    transMat->kd.b += transMatInc->kd.b;
    transMat->ks.r += transMatInc->ks.r;
    transMat->ks.g += transMatInc->ks.g;
    transMat->ks.b += transMatInc->ks.b;
    transMat->specExp += transMatInc->specExp;

    ss_SetMaterial( transMat );
}

/**************************************************************************\
* ss_RandomTeaMaterial
*
* Select a random TeaMaterial
* Return ptr to material
*
\**************************************************************************/
MATERIAL *ss_RandomTeaMaterial( BOOL bSet )
{
    int index;
    MATERIAL *pMat;

    index =  goodMaterials[ ss_iRand(NUM_GOOD_MATERIALS) ];
    pMat = &Material[ index ];
    if( bSet )
        ss_SetMaterial( pMat );
    return pMat;
}

/**************************************************************************\
* ss_RandomTeaMaterialIndex
*
* Select a random TeaMaterial
* Return material index
*
\**************************************************************************/
int ss_RandomTeaMaterialIndex( BOOL bSet )
{
    int index;

    index =  goodMaterials[ ss_iRand(NUM_GOOD_MATERIALS) ];
    if( bSet )
        ss_SetMaterial( &Material[ index ] );
    return index;
}

/**************************************************************************\
* ss_RandomTexMaterial
*
* Select a random TexMaterial
* Return ptr to material
*
\**************************************************************************/
MATERIAL *ss_RandomTexMaterial( BOOL bSet )
{
    int index;
    MATERIAL *pMat;

    index =  NUM_TEA_MATERIALS + ss_iRand(NUM_TEX_MATERIALS);
    pMat = &Material[ index ];
    if( bSet )
        ss_SetMaterial( pMat );
    return pMat;
}

/**************************************************************************\
* ss_RandomTexMaterialIndex
*
* Select a random TexMaterial
*
\**************************************************************************/
int ss_RandomTexMaterialIndex( BOOL bSet )
{
    int index;

    index =  NUM_TEA_MATERIALS + ss_iRand(NUM_TEX_MATERIALS);
    if( bSet )
        ss_SetMaterial( &Material[ index ] );
    return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\math.c ===
/******************************Module*Header*******************************\
* Module Name: math.c
*
* Misc. useful math utility functions.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <GL\gl.h>
#include <math.h>
#include "sscommon.h"

#define ZERO_EPS    0.00000001

POINT3D ss_ptZero = {0.0f, 0.0f, 0.0f};


void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]) + mat->M[0][3];

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]) + mat->M[1][3];

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]) + mat->M[2][3];

    ptOut->x = (float) x;
    ptOut->y = (float) y;
    ptOut->z = (float) z;
}

void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;
    double len;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]);

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]);

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]);

    len = (x * x) + (y * y) + (z * z);
    if (len >= ZERO_EPS)
        len = 1.0 / sqrt(len);
    else
        len = 1.0;

    ptOut->x = (float) (x * len);
    ptOut->y = (float) (y * len);
    ptOut->z = (float) (z * len);
    return;
}

void ss_matrixIdent(MATRIX *mat)
{
    mat->M[0][0] = 1.0f; mat->M[0][1] = 0.0f;
    mat->M[0][2] = 0.0f; mat->M[0][3] = 0.0f;

    mat->M[1][0] = 0.0f; mat->M[1][1] = 1.0f;
    mat->M[1][2] = 0.0f; mat->M[1][3] = 0.0f;

    mat->M[2][0] = 0.0f; mat->M[2][1] = 0.0f;
    mat->M[2][2] = 1.0f; mat->M[2][3] = 0.0f;

    mat->M[3][0] = 0.0f; mat->M[3][1] = 0.0f;
    mat->M[3][2] = 0.0f; mat->M[3][3] = 1.0f;
}

void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta)
{
    float xScale, yScale, zScale;
    float sinX, cosX;
    float sinY, cosY;
    float sinZ, cosZ;

    xScale = m->M[0][0];
    yScale = m->M[1][1];
    zScale = m->M[2][2];
    sinX = (float) sin(xTheta);
    cosX = (float) cos(xTheta);
    sinY = (float) sin(yTheta);
    cosY = (float) cos(yTheta);
    sinZ = (float) sin(zTheta);
    cosZ = (float) cos(zTheta);

    m->M[0][0] = (float) ((cosZ * cosY) * xScale);
    m->M[0][1] = (float) ((cosZ * -sinY * -sinX + sinZ * cosX) * yScale);
    m->M[0][2] = (float) ((cosZ * -sinY * cosX + sinZ * sinX) * zScale);

    m->M[1][0] = (float) (-sinZ * cosY * xScale);
    m->M[1][1] = (float) ((-sinZ * -sinY * -sinX + cosZ * cosX) * yScale);
    m->M[1][2] = (float) ((-sinZ * -sinY * cosX + cosZ * sinX) * zScale);

    m->M[2][0] = (float) (sinY * xScale);
    m->M[2][1] = (float) (cosY * -sinX * yScale);
    m->M[2][2] = (float) (cosY * cosX * zScale);
}

void ss_matrixTranslate(MATRIX *m, double xTrans, double yTrans,
                     double zTrans)
{
    m->M[0][3] = (float) xTrans;
    m->M[1][3] = (float) yTrans;
    m->M[2][3] = (float) zTrans;
}


void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 )
{
    int i, j;

    for( j = 0; j < 4; j ++ ) {
    	for( i = 0; i < 4; i ++ ) {
	    m1->M[j][i] = m2->M[j][0] * m3->M[0][i] +
			  m2->M[j][1] * m3->M[1][i] +
			  m2->M[j][2] * m3->M[2][i] +
			  m2->M[j][3] * m3->M[3][i];
	}
    }
}

void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3)
{
    float crossX, crossY, crossZ;
    float abX, abY, abZ;
    float acX, acY, acZ;
    float sqrLength;
    float invLength;

    abX = p2->x - p1->x;       // calculate p2 - p1
    abY = p2->y - p1->y;
    abZ = p2->z - p1->z;

    acX = p3->x - p1->x;       // calculate p3 - p1
    acY = p3->y - p1->y;
    acZ = p3->z - p1->z;

    crossX = (abY * acZ) - (abZ * acY);    // get cross product
    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1)
    crossZ = (abX * acY) - (abY * acX);

    sqrLength = (crossX * crossX) + (crossY * crossY) +
                 (crossZ * crossZ);

    if (sqrLength > ZERO_EPS)
        invLength = (float) (1.0 / sqrt(sqrLength));
    else
        invLength = 1.0f;

    norm->x = crossX * invLength;
    norm->y = crossY * invLength;
    norm->z = crossZ * invLength;
}


void ss_normalizeNorm( POINT3D *n ) 
{
    float len;

    len = (n->x * n->x) + (n->y * n->y) + (n->z * n->z);
    if (len > ZERO_EPS)
        len = (float) (1.0 / sqrt(len));
    else
        len = 1.0f;

    n->x *= len;
    n->y *= len;
    n->z *= len;
}

void ss_normalizeNorms(POINT3D *p, ULONG cPts)
{
    float len;
    ULONG i;

    for (i = 0; i < cPts; i++, p++) {
        len = (p->x * p->x) + (p->y * p->y) + (p->z * p->z);
        if (len > ZERO_EPS)
            len = (float) (1.0 / sqrt(len));
        else
            len = 1.0f;

        p->x *= len;
        p->y *= len;
        p->z *= len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\fastdib.c ===
/******************************Module*Header*******************************\
* Module Name: fastdib.c
*
* CreateCompatibleDIB implementation.
*
* Created: 23-Jan-1996 21:08:18
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

#include "sscommon.h"

BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector);
static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi);
static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                                      LPPALETTEENTRY lppe);
static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal,
                                        BYTE *pajVector);

/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//HBITMAP APIENTRY
HBITMAP
SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        SS_DBGPRINT("CreateCompatibleDIB: not OBJ_DC\n");
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));
    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);
        GdiFlush();

        if ( !hbmRet )
        {
            SS_DBGPRINT("CreateCompatibleDIB: CreateDIBSection failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("CreateCompatibleDIB: bFillBitmapInfo failed\n");
    }

    return hbmRet;
}

/******************************Public*Routine******************************\
* UpdateDIBColorTable
*
* Synchronize the DIB color table to the specified palette hpal.
* If hpal is NULL, then use the system palette.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;
    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256);
    ULONG i, cColors;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_DC\n");
        return bRet;
    }
    if ( GetObjectType(hdcMem) != OBJ_MEMDC )
    {
        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_MEMDC\n");
        return bRet;
    }

    //
    // Get the bitmap handle out of the memdc.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);

    //
    // Validate bitmap (must be DIB section).
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds)) &&
         ds.dsBm.bmBits )
    {
        //
        // Get palette entries from specified palette or system palette.
        //

        cColors = 1 << ds.dsBmih.biBitCount;


        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe)
           )
        {
            UINT i;

            //
            // Convert to RGBQUAD.
            //

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            //
            // Set the DIB color table.
            //

            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb);

            if (!bRet)
            {
                SS_DBGPRINT("UpdateDIBColorTable: SetDIBColorTable failed\n");
            }
        }
        else
        {
            SS_DBGPRINT("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("UpdateDIBColorTable: GetObject failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        // For backwards compatibility with Get/SetBitmapBits, GDI does
        // not accurately report the bitmap pitch in bmWidthBytes.  It
        // always computes bmWidthBytes assuming WORD-aligned scanlines
        // regardless of the platform.
        //
        // Therefore, if the platform is WinNT, which uses DWORD-aligned
        // scanlines, adjust the bmWidthBytes value.

        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                SS_DBGPRINT1("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError());
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((INT_PTR) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        SS_DBGPRINT("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GetDIBTranslationVector
*
* Copies the translation vector that maps colors in the specified palette,
* hpal, to the DIB selected into the specified DC, hdcMem.
*
* Effects:
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector)
{
    BOOL bRet = FALSE;
    HBITMAP hbm;
    DIBSECTION ds;

    //
    // Validate parameters.
    //

    if ( GetObjectType(hdcMem) != OBJ_MEMDC ||
         GetObjectType(hpal) != OBJ_PAL ||
         !pbVector )
    {
        SS_DBGPRINT("GetDIBTranslationVector: bad parameter\n");
        return bRet;
    }

    //
    // The function bComputeLogicalToSurfaceMap cannot handle palettes
    // greater than 256 entries.
    //

    if ( GetPaletteEntries(hpal, 0, 1, NULL) > 256 )
    {
        SS_DBGPRINT("GetDIBTranslationVector: palette too big\n");
        return bRet;
    }

    //
    // The DIB must have a color table.
    //

    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP);
    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && (ds.dsBmih.biBitCount <= 8) )
    {
        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector);
    }
    else
    {
        SS_DBGPRINT("GetDIBTranslationVector: not a DIB section\n");
        return bRet;
    }

    return bRet;
}

//////////////////// Below here are internal-only routines ////////////////////

/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if ( pbmi->bmiHeader.biBitCount <= 8 )
        {
            bRet = bFillColorTable(hdc, hpal, pbmi);
        }
        else
        {
            if ( pbmi->bmiHeader.biCompression == BI_BITFIELDS )
            {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }
    else
    {
        SS_DBGPRINT("bFillBitmapInfo: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG i, cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            SS_DBGPRINT("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = GetObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

    //
    // Determine number of colors in each palette.
    //

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if ( dwDcType == OBJ_DC )
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

    //
    // Get the logical palette entries.
    //

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

    //
    // Get the surface palette entries.
    //

    if ( dwDcType == OBJ_DC )
    {
        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

        //
        // First get RGBQUADs from DIB color table...
        //

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

        //
        // ...then convert RGBQUADs into PALETTEENTRIES.
        //

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while ( lppeTmp < lppeEnd )
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

    //
    // Construct a translation vector by using GetNearestPaletteIndex to
    // map each entry in the logical palette to the surface palette.
    //

    if ( cEntries && cSysEntries )
    {
        //
        // Create a temporary logical palette that matches the surface
        // palette retrieved above.
        //

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ( hpalSurf = CreatePalette(ppal) )
        {
            //
            // Translate each logical palette entry into a surface palette
            // index.
            //

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            SS_DBGPRINT("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        SS_DBGPRINT("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\glscrnsv.cxx ===
/******************************Module*Header*******************************\
* Module Name: glscrnsv.c
*
* Companion file to scrnsave.c.  Hooks out any changes in functionality
* defined as GL_SCRNSAVE in scrnsave.c, and does general intialization.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include "scrnsave.h"

#include "glscrnsv.h"
#include "ssintrnl.hxx"
#include "sswindow.hxx"
#include "glscrnsv.hxx"
#include "sswproc.hxx"

static UINT (*KeyDownFunc)(int)        = NULL;

// Global ptr to screen saver instance
SCRNSAVE *gpss = NULL;

// Global strings.
#define GEN_STRING_SIZE 64
TCHAR szScreenSaverTitle[GEN_STRING_SIZE];
LPCTSTR pszWindowClass = TEXT("WindowsScreenSaverClass");  // main class name
LPCTSTR pszChildWindowClass = TEXT("ScreenSaverClass"); // child class name

// forward declarations of internal fns
static BOOL RegisterMainClass( WNDPROC wndProc, HBRUSH hbrBg, HCURSOR hCursor );
static BOOL RegisterChildClass();
static BOOL AttemptResolutionSwitch( int width, int height, ISIZE *pNewSize );

// externs
extern void InitRealScreenSave(); // scrnsave.cxx
extern LRESULT WINAPI
    RealScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
extern VOID UnloadPwdDLL(VOID); 
extern BOOL GLScreenSaverConfigureDialog( HWND hDlg, UINT msg, WPARAM wParam,
                              LPARAM lParam ); // sswproc.cxx

#ifdef SS_INITIAL_CLEAR
static void InitialClear( PSSW *pssw );
#endif

/**************************************************************************\
* GLDoScreenSave
*
* Runs the screen saver in the specified mode
*
* GL version of DoScreenSave in scrnsave.c
*
* Does basic init, creates initial set of windows, and starts the message
* loop, which runs until terminated by some event.
*
\**************************************************************************/

static INT_PTR
GLDoScreenSave( int winType, LPARAM lParam )
{
    MSG msg;

    // Create screen saver instance - this calls ss_Init()
    SCRNSAVE ss( winType, lParam );

    // Setup all the windows and start the message loop

    if( ss.SetupInitialWindows() )
    {
        // Send message to main window to start the drawing timer
#ifdef SS_DELAYED_START_KLUGE
        // Kluge to work around 'window-not-ready' problem in child
        // preview mode - trigger off of WM_PAINT instead
        if( ! SS_DELAY_START(winType) )
            SendMessage( ss.psswMain->hwnd, SS_WM_START, 0, 0 );
#else
        SendMessage( ss.psswMain->hwnd, SS_WM_START, 0, 0 );
#endif // SS_DELAYED_START_KLUGE

        while( GetMessage( &msg, NULL, 0, 0 ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }

    // We're done - screen saver exiting.

    // free password-handling DLL if loaded
    UnloadPwdDLL();

    return msg.wParam;
}

/**************************************************************************\
* SCRNSAVE constructors
*
\**************************************************************************/

SCRNSAVE::SCRNSAVE( int typeArg, LPARAM lParam )
: type( typeArg ), initParam( lParam )
{
    Init();
}

SCRNSAVE::SCRNSAVE( int typeArg )
: type(typeArg)
{
    initParam = 0;
    Init();
}

void
SCRNSAVE::Init()
{
    psswMain    = NULL;
    psswGL      = NULL;
    bResSwitch  = FALSE;
    pssc        = NULL;
    pssPal      = NULL;
    flags       = 0;
#ifdef SS_DEBUG
    bDoTiming   = type == SS_TYPE_NORMAL ? TRUE : FALSE;
#endif

    // Global ptr to the screen saver instance
    gpss = this;

    // Platform detections

    ss_QueryOSVersion();

    // Initialize randomizer

    ss_RandInit();

    // Disable message boxes in GLAUX

    tkErrorPopups(FALSE);

    // Create multi-purpose black bg brush

    hbrBg = (HBRUSH) GetStockObject( BLACK_BRUSH );

    // Call client ss's init function, to get ptr to its configuration
    // request

    if( type == SS_TYPE_CONFIG ) {
        // This case handled differently
        return;
    }

    pssc = ss_Init();
    SS_ASSERT( pssc, "SCRNSAVE constructor failure\n" );

    // Set GL config structure from pssc
    
    GLc.pfFlags = 0;
    GLc.hrc = 0;
    GLc.pStretch = NULL;
    switch( pssc->depthType ) {
        case SS_DEPTH16 :
            GLc.pfFlags |= SS_DEPTH16_BIT;
            break;
        case SS_DEPTH32 :
            GLc.pfFlags |= SS_DEPTH32_BIT;
            break;
    }
    if( pssc->bDoubleBuf )
        GLc.pfFlags |= SS_DOUBLEBUF_BIT;
    if( pssc->bStretch )
        GLc.pStretch = &pssc->stretchInfo;

}

/**************************************************************************\
* SetupInitialWindows
*
* Create / Configure all required windows.
*
\**************************************************************************/

BOOL 
SCRNSAVE::SetupInitialWindows()
{
    // Create the windows

    if( ! CreateInitialWindows() ) {
        SS_WARNING( "SCRNSAVE:: Couldn't create windows\n" );
        return FALSE;
    }

    // Initial window clear

//mf: doesn't seem to be necessary now...
//#define SS_INITIAL_MAIN_WINDOW_CLEAR 1
#ifdef SS_INITIAL_MAIN_WINDOW_CLEAR
    if( type == SS_TYPE_PREVIEW ) {
    // Make sure the screen is cleared to black before we start drawing
    // anything, as sometimes the background WM_PAINT doesn't get to us right
    // away.  This is only a problem in preview mode
       psswMain->GdiClear();
    }
#endif

    // Configure and Init the windows, if applicable

#ifdef SS_DELAYED_START_KLUGE
    // delay start for some configurations
    if( ! SS_DELAY_START(type) ) {
        SendMessage( psswMain->hwnd, SS_WM_INITGL, 0, 0 );
    }
#else
    SendMessage( psswMain->hwnd, SS_WM_INITGL, 0, 0 );
#endif // SS_DELAYED_START_KLUGE

    return TRUE;
}



/**************************************************************************\
* CreateInitialWindows
*
* Create the intitial set of windows.
*
\**************************************************************************/

BOOL 
SCRNSAVE::CreateInitialWindows()
{
    PSSW    pssw;
    UINT    uStyle;
    UINT    uExStyle;
    LPCTSTR pszWindowTitle;

    if( !pssc )
        return FALSE;

    // Handle any request for resolution change

#define SS_RESOLUTION_SWITCH 1
#ifdef SS_RESOLUTION_SWITCH
    if( pssc->bStretch && 
        (type == SS_TYPE_FULLSCREEN) &&
        (GetSystemMetrics(SM_CMONITORS) == 1) )
    {

        STRETCH_INFO *pStretch = &pssc->stretchInfo;
        ISIZE newSize;

        // Try and change screen resolution to match stretch size
        bResSwitch = AttemptResolutionSwitch( pStretch->baseWidth, 
                                               pStretch->baseHeight, &newSize ); 
        // Is stretching still necessary if resolution changed ?
        if( bResSwitch ) {
            if( (newSize.width == pStretch->baseWidth) &&
                (newSize.height == pStretch->baseHeight) ) 
                // exact match, no stretching now necessary
                pssc->bStretch = FALSE;
        }
    }
#endif

    // Currently the bitmaps used in stretch mode don't support palette
    // messages, so disable any stretching when in PREVIEW mode (where we
    // need to support palette interaction).
    // mf: actually this is only a consideration in 8-bit mode...

    if( (type == SS_TYPE_PREVIEW) && pssc->bStretch )
        pssc->bStretch = FALSE;

    // Create the main ss window

    if( ! CreateMainWindow() )
        return FALSE;

#ifdef SS_INITIAL_CLEAR
    // If main window is transparent, can do an initial clear here before
    // any other windows are created or palettes modified
    // This is bogus on NT, as system switches to secure desktop when screen
    // saver kicks in automatically.
    InitialClear( pssw );
#endif

    // For now, simple window environment is described by pssc, so things
    // like bFloater and bStretch are mutually exclusive.

    SS_GL_CONFIG *pGLc = &gpss->GLc;

    if( pssc->bFloater ) {

        if( !(pssw = CreateChildWindow( &pssc->floaterInfo )) )
            return FALSE;

        pssw->pGLc = pGLc;
        psswGL = pssw; // support old-style
    } else {
        psswMain->pGLc = pGLc;
        psswGL = psswMain; // support old-style
    }

    return TRUE;
}

/**************************************************************************\
* NormalWindowScreenSaverProc
*
* Highest level window proc, used only in normal window (/w) mode.
*
\**************************************************************************/

LRESULT WINAPI
NormalWindowScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
   switch( uMsg )
   {
      case WM_SETTEXT:
         // RealScreenSaverProc won't allow this - bypass it
         return ScreenSaverProc( hWnd, uMsg, wParam, lParam );

      case WM_CHAR:
            if( KeyDownFunc ) {
                int key = (int)wParam;
                (*KeyDownFunc)(key);
            }
            break;
                    
      case WM_KEYDOWN:
            if( wParam == VK_ESCAPE ) {
                PostMessage( hWnd, WM_CLOSE, 0, 0l );
                break;
            } else if( KeyDownFunc ) {
                (*KeyDownFunc)((int)wParam);
                return 0;
            }
            return 0; // ??

      default:
         break;
   }

   return RealScreenSaverProc( hWnd, uMsg, wParam, lParam );
}

/**************************************************************************\
* DoScreenSave
*
* Hooked out version of DoScreenSave in standard scrnsave.c
*
\**************************************************************************/

INT_PTR
DoScreenSave( HWND hwndParent )
{
    return GLDoScreenSave( hwndParent ? SS_TYPE_PREVIEW : SS_TYPE_FULLSCREEN, 
                           (LPARAM) hwndParent );
}

/**************************************************************************\
* DoWindowedScreenSave
*
* Called when screen saver invoked with /w (window mode) parameter
*
\**************************************************************************/

INT_PTR
DoWindowedScreenSave( LPCTSTR szArgs )
{
    return GLDoScreenSave( SS_TYPE_NORMAL, (LPARAM) szArgs );
}

/**************************************************************************\
* DoConfigBox
*
* Hooked out version of DoConfigBox in standard scrnsave.c
*
\**************************************************************************/

INT_PTR
DoConfigBox( HWND hwndParent )
{
    // let the consumer register any special controls for the dialog
    if( !RegisterDialogClasses( hMainInstance ) )
        return FALSE;

    // Create screen saver instance
    SCRNSAVE ss( SS_TYPE_CONFIG );

    int retVal = (int)DialogBox( hMainInstance, 
                           MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
                           hwndParent, (DLGPROC)GLScreenSaverConfigureDialog );

    return retVal;
}

/**************************************************************************\
* CreateMainWindow
*
* Creates main screen saver window based on the window type
*
\**************************************************************************/

BOOL
SCRNSAVE::CreateMainWindow()
{
    WNDPROC  wndProc;
    ISIZE    size;
    UINT     uStyle = 0;
    UINT     uExStyle = 0;
    IPOINT2D pos;
    LPCTSTR  pszWindowTitle;
    HCURSOR  hCursor = NULL;
    HBRUSH   hbrBgMain;
    PSSW     pssw;
    BOOL     bFailed;
    HWND    hwndParent = NULL;
    int nx, ny;  // window origin
    int ncx, ncy; // window size
   
    wndProc = RealScreenSaverProc;

    switch( type ) {
        case SS_TYPE_FULLSCREEN:
          {
            HWND hOther;

            // Get origin and size of virtual desktop
            nx  = GetSystemMetrics( SM_XVIRTUALSCREEN );
            ny  = GetSystemMetrics( SM_YVIRTUALSCREEN );
            ncx = GetSystemMetrics( SM_CXVIRTUALSCREEN );
            ncy = GetSystemMetrics( SM_CYVIRTUALSCREEN );
        
//#define SS_FULLSCREEN_DEBUG 1
#ifdef SS_FULLSCREEN_DEBUG
            // Reduce window size so we can see debugger
            ncx >>= 1;
            ncy >>= 1;
#endif
            uStyle = WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
            uExStyle = WS_EX_TOPMOST;

            pszWindowTitle = TEXT("Screen Saver"); // MUST differ from preview

            // if there is another NORMAL screen save instance, switch to it
            hOther = FindWindow( pszWindowClass, pszWindowTitle );

            if( hOther && IsWindow( hOther ) )
            {
               SS_DBGINFO( "SCRNSAVE::CreateMainWindow : Switching to other ss instance\n" );
               SetForegroundWindow( hOther );
               return FALSE;
            }

            InitRealScreenSave();
          }
          break;

        case SS_TYPE_PREVIEW:
          {
            RECT rcParent;

            hwndParent = (HWND) initParam;

            GetClientRect( hwndParent, &rcParent );
    
            fChildPreview = TRUE;
            ncx = rcParent.right;
            ncy = rcParent.bottom;
            nx = 0;
            ny = 0;
            uStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN;

            pszWindowTitle = TEXT("Preview");   // MUST differ from full screen
          }
          break;

        case SS_TYPE_NORMAL:

          {
            // We set fChildPreview even when we're running in a normal window,
            // as this flag is used in scrnsave.c to differentiate from full
            // screen.
            fChildPreview = TRUE;

            // init size to half of (primary) screen by default
            ncx = GetSystemMetrics( SM_CXSCREEN ) >> 1;
            ncy = GetSystemMetrics( SM_CYSCREEN ) >> 1;
            nx = 0;
            ny = 0;

            if( initParam ) {
                // get size of window from args
                LPCTSTR szArgs = (LPCTSTR) initParam;
                //mf: not yet implemented
            }
                
            LoadString(hMainInstance, IDS_DESCRIPTION, szScreenSaverTitle, 
               sizeof(szScreenSaverTitle) / sizeof(TCHAR));
            pszWindowTitle = szScreenSaverTitle; // MUST differ from preview

            uStyle = WS_VISIBLE | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | 
                   WS_CLIPSIBLINGS;

            hCursor = LoadCursor( NULL, IDC_ARROW );

            // Wrap RealScreenSaverProc
            wndProc = NormalWindowScreenSaverProc;
          }
          break;

        default:
          break;
    }

    size.width = ncx;
    size.height = ncy;
    pos.x = nx;
    pos.y = ny;

    // Create SSW window wrapper

    pssw = new SSW( NULL,       // parent
                    &size, 
                    &pos, 
                    FALSE,      // bMotion
                    NULL       // ChildSizeFunc
                  );
    if( !pssw )
        return FALSE;

    // Initialize the window class and create the window

#ifdef SS_INITIAL_CLEAR
    hbrBgMain = NULL;
#else
    hbrBgMain = hbrBg;
#endif

    if( !RegisterMainClass
        (
            wndProc, 
            hbrBgMain, 
            hCursor
        ) ||

        !pssw->CreateSSWindow
        (   
            hMainInstance, 
            uStyle, 
            uExStyle, 
            pszWindowTitle,
            wndProc,
            pszWindowClass,
            hwndParent     // mf: ! hwndParentOverride
        ) )
    {
        delete pssw;
        return FALSE;
    }

    if( type != SS_TYPE_PREVIEW )
#ifndef SS_DEBUG
        SetForegroundWindow( pssw->hwnd );
#else
    {
        if( !SetForegroundWindow( pssw->hwnd ) )
            SS_DBGPRINT( "Main_Proc: SetForegroundWindow failed\n" );
    }
#endif

    // Always configure the main window for gdi
    pssw->ConfigureForGdi();

    psswMain = pssw;
    return TRUE;
}

/**************************************************************************\
* CreateChildWindow
*
* Creates a child window of the parent window
*
* This is a kind of wrapper-constructor
\**************************************************************************/

PSSW
SCRNSAVE::CreateChildWindow( FLOATER_INFO *pFloater )
{
    pFloater->bSubWindow = FALSE; // default is no logical subwin's

    // Register child window class
    // This only has to be done once, since so far, all child window
    // classes are the same
    if( !pFloater->bSubWindow && !RegisterChildClass() )
        return NULL;

    return CreateChildWindow( psswMain, pFloater );
}

PSSW
SCRNSAVE::CreateChildWindow( PSSW psswParent, FLOATER_INFO *pFloater )
{
    UINT     uStyle = 0;
    UINT     uExStyle = 0;
    PSSW     pssw;

    uStyle = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    // Size and position are NULL here, as the SSW will call the size
    // function callback in pFloater to get these and other values

    // Create the SSW window wrapper

    pssw = new SSW( psswParent,      // parent
                    NULL,            // size
                    NULL,            // position
                    pFloater->bMotion,
                    pFloater->ChildSizeFunc
                  );
    if( !pssw )
        return NULL;

    if( pFloater->bSubWindow )
        // Don't need to create win32 window
        return pssw;

    // Create a window

    if( !pssw->CreateSSWindow
        (
            hMainInstance, 
            uStyle,
            0,                      // uExStyle 
            szScreenSaverTitle ,
            SS_ScreenSaverProc,
            pszChildWindowClass,
            NULL                    // hwndParentOverride
        ) )
    {
        delete pssw;
        return NULL;
    }

    return pssw;
}


/**************************************************************************\
* RegisterMainClass
*
* Registers class of the main SS window
\**************************************************************************/

static BOOL 
RegisterMainClass( WNDPROC wndProc, HBRUSH hbrBg, HCURSOR hCursor )
{
    WNDCLASS cls;

    cls.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC;
    cls.lpfnWndProc = wndProc;
    cls.cbClsExtra = 0;
    cls.cbWndExtra = 0;
    cls.hInstance = hMainInstance;
    cls.hIcon = LoadIcon( hMainInstance, MAKEINTATOM( ID_APP ) );
    cls.hCursor = hCursor;
    cls.hbrBackground = hbrBg;
    cls.lpszMenuName = (LPTSTR)NULL;
    cls.lpszClassName = (LPTSTR)pszWindowClass;
    return RegisterClass(&cls);
}

/**************************************************************************\
* RegisterChildClass
*
* Registers class of a standard child window
\**************************************************************************/

static BOOL 
RegisterChildClass()
{
    static BOOL bRegistered = FALSE;

    if( bRegistered )
        return TRUE;

    WNDCLASS cls;

    cls.style = CS_VREDRAW | CS_HREDRAW;
    cls.lpfnWndProc = SS_ScreenSaverProc;
    cls.cbClsExtra = 0;
    cls.cbWndExtra = 0;
    cls.hInstance = hMainInstance;
    cls.hIcon = NULL;
    cls.hCursor = NULL;
    cls.hbrBackground = NULL;
    cls.lpszMenuName = (LPTSTR)NULL;
    cls.lpszClassName = pszChildWindowClass;

    if( !RegisterClass(&cls) )
        return FALSE;

    // success
    bRegistered = TRUE;
    return TRUE;
}

/******************************Public*Routine******************************\
* AttemptResolutionSwitch
*
* Try doing resolution switching to match or get close to the desired size.
*
\**************************************************************************/

static BOOL
AttemptResolutionSwitch( int width, int height, ISIZE *pNewSize ) 
{
    BOOL bChanged = FALSE;

    // Try doing resolution switching to match or get close to the
    // desired width and height

    // Try switching to requested size
#if 0
    //mf: not ready for prime time
    if( ss_ChangeDisplaySettings( width, height, 0 ) ) {
#else
    if( 0 ) {
        // for now force failure of user request and try standard 640x480
#endif
        bChanged = TRUE;
    } else {
        // Can't switch to requested size, try for best match
        // mf: !!! for now, let's play it safe and just try 640x480.
        width = 640; 
        height = 480;
        // If screen already this size or less, leave be
        if( (GetSystemMetrics( SM_CXSCREEN ) <= width) &&
            (GetSystemMetrics( SM_CYSCREEN ) <= height) )
            return FALSE;

        //mf: use this when trying for best match
        // ss_QueryDisplaySettings();

        if( ss_ChangeDisplaySettings( width, height, 0 ) )
            bChanged = TRUE;
    }

    if( bChanged ) {
        pNewSize->width = width;
        pNewSize->height = height;
    }
    return bChanged;
}

#ifdef SS_INITIAL_CLEAR
static void
InitialClear( PSSW *pssw )
{
    ss_GdiRectWipeClear( pssw->hwnd, pssw->size.width, pssw->size.height );
}
#endif // SS_INITIAL_CLEAR

/**************************************************************************\
* CloseWindows
*
* Close down any open windows.
*
* This sends a WM_CLOSE message to the top-level window if it is still open.  If
* the window has any children, they are also closed.  For each window, the
* SSW destructor is called.
\**************************************************************************/

void
SCRNSAVE::CloseWindows()
{
    if( psswMain ) {
        if( psswMain->bOwnWindow )
            DestroyWindow( psswMain->hwnd );
        else
            delete psswMain;
    }
}

/**************************************************************************\
* SCRNSAVE destructor
*
\**************************************************************************/

SCRNSAVE::~SCRNSAVE()
{
    // Close any open windows (there might be some open if errors occurred)
    CloseWindows();

    if( bResSwitch ) {
        // Restore previous display settings
        ChangeDisplaySettings(NULL, CDS_FULLSCREEN);
    }

    gpss = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\palette.cxx ===
/******************************Module*Header*******************************\
* Module Name: palette.cxx
*
* Palette processing functions
*
* Adapted from tk.c
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <GL/gl.h>
#include "ssintrnl.hxx"
#include "palette.hxx"

#if(WINVER < 0x0400)
// Ordinarily not defined for versions before 4.00.
#define COLOR_3DDKSHADOW        21
#define COLOR_3DLIGHT           22
#define COLOR_INFOTEXT          23
#define COLOR_INFOBK            24
#endif

#define TKASSERT(x) SS_ASSERT( x, "palette processing failure\n" )

/******************************************************************************/

// Fixed palette support.

#define BLACK   PALETTERGB(0,0,0)
#define WHITE   PALETTERGB(255,255,255)
#define MAX_STATIC_COLORS   (COLOR_INFOBK - COLOR_SCROLLBAR + 1)
static int gNumStaticColors = MAX_STATIC_COLORS;

// TRUE if static system color settings have been replaced with B&W settings.

// TRUE if original static colors saved
static BOOL tkStaticColorsSaved = FALSE;

// saved system static colors (initialize with default colors)
static COLORREF gacrSave[MAX_STATIC_COLORS];

// new B&W system static colors
static COLORREF gacrBlackAndWhite[] = {
    WHITE,  // COLOR_SCROLLBAR
    BLACK,  // COLOR_BACKGROUND
    BLACK,  // COLOR_ACTIVECAPTION
    WHITE,  // COLOR_INACTIVECAPTION
    WHITE,  // COLOR_MENU
    WHITE,  // COLOR_WINDOW
    BLACK,  // COLOR_WINDOWFRAME
    BLACK,  // COLOR_MENUTEXT
    BLACK,  // COLOR_WINDOWTEXT
    WHITE,  // COLOR_CAPTIONTEXT
    WHITE,  // COLOR_ACTIVEBORDER
    WHITE,  // COLOR_INACTIVEBORDER
    WHITE,  // COLOR_APPWORKSPACE
    BLACK,  // COLOR_HIGHLIGHT
    WHITE,  // COLOR_HIGHLIGHTTEXT
    WHITE,  // COLOR_BTNFACE
    BLACK,  // COLOR_BTNSHADOW
    BLACK,  // COLOR_GRAYTEXT
    BLACK,  // COLOR_BTNTEXT
    BLACK,  // COLOR_INACTIVECAPTIONTEXT
    BLACK,  // COLOR_BTNHIGHLIGHT
    BLACK,  // COLOR_3DDKSHADOW
    WHITE,  // COLOR_3DLIGHT
    BLACK,  // COLOR_INFOTEXT
    WHITE   // COLOR_INFOBK
    };
static INT gaiStaticIndex[] = {
    COLOR_SCROLLBAR          ,
    COLOR_BACKGROUND         ,
    COLOR_ACTIVECAPTION      ,
    COLOR_INACTIVECAPTION    ,
    COLOR_MENU               ,
    COLOR_WINDOW             ,
    COLOR_WINDOWFRAME        ,
    COLOR_MENUTEXT           ,
    COLOR_WINDOWTEXT         ,
    COLOR_CAPTIONTEXT        ,
    COLOR_ACTIVEBORDER       ,
    COLOR_INACTIVEBORDER     ,
    COLOR_APPWORKSPACE       ,
    COLOR_HIGHLIGHT          ,
    COLOR_HIGHLIGHTTEXT      ,
    COLOR_BTNFACE            ,
    COLOR_BTNSHADOW          ,
    COLOR_GRAYTEXT           ,
    COLOR_BTNTEXT            ,
    COLOR_INACTIVECAPTIONTEXT,
    COLOR_BTNHIGHLIGHT       ,
    COLOR_3DDKSHADOW         ,
    COLOR_3DLIGHT            ,
    COLOR_INFOTEXT           ,
    COLOR_INFOBK
    };

#define RESTORE_FROM_REGISTRY   1
#if RESTORE_FROM_REGISTRY
// Registry names for the system colors.
static CHAR *gaszSysClrNames[] = {
    "Scrollbar",      // COLOR_SCROLLBAR              0
    "Background",     // COLOR_BACKGROUND             1   (also COLOR_DESKTOP)
    "ActiveTitle",    // COLOR_ACTIVECAPTION          2
    "InactiveTitle",  // COLOR_INACTIVECAPTION        3
    "Menu",           // COLOR_MENU                   4
    "Window",         // COLOR_WINDOW                 5
    "WindowFrame",    // COLOR_WINDOWFRAME            6
    "MenuText",       // COLOR_MENUTEXT               7
    "WindowText",     // COLOR_WINDOWTEXT             8
    "TitleText",      // COLOR_CAPTIONTEXT            9
    "ActiveBorder",   // COLOR_ACTIVEBORDER          10
    "InactiveBorder", // COLOR_INACTIVEBORDER        11
    "AppWorkspace",   // COLOR_APPWORKSPACE          12
    "Hilight",        // COLOR_HIGHLIGHT             13
    "HilightText",    // COLOR_HIGHLIGHTTEXT         14
    "ButtonFace",     // COLOR_BTNFACE               15   (also COLOR_3DFACE)
    "ButtonShadow",   // COLOR_BTNSHADOW             16   (also COLOR_3DSHADOW)
    "GrayText",       // COLOR_GRAYTEXT              17
    "ButtonText",     // COLOR_BTNTEXT               18
    "InactiveTitleText", // COLOR_INACTIVECAPTIONTEXT   19
    "ButtonHilight",  // COLOR_BTNHIGHLIGHT          20   (also COLOR_3DHILIGHT)
    "ButtonDkShadow", // COLOR_3DDKSHADOW            21
    "ButtonLight",    // COLOR_3DLIGHT               22
    "InfoText",       // COLOR_INFOTEXT              23
    "InfoWindow"      // COLOR_INFOBK                24
};

static BOOL GetRegistrySysColors(COLORREF *, int);
#endif

unsigned char ss_ComponentFromIndex(int i, int nbits, int shift );
static int ss_PixelFormatDescriptorFromDc( HDC hdc, PIXELFORMATDESCRIPTOR *Pfd );

/******************************************************************************/

#if RESTORE_FROM_REGISTRY
/******************************Public*Routine******************************\
* GetRegistrySysColors
*
* Reads the Control Panel's color settings from the registry and stores
* those values in pcr.  If we fail to get any value, then the corresponding
* entry in pcr is not modified.
*
* History:
*  12-Apr-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL GetRegistrySysColors(COLORREF *pcr, int nColors)
{
    BOOL bRet = FALSE;
    long lRet;
    HKEY hkSysColors = (HKEY) NULL;
    int i;
    DWORD dwDataType;
    char achColor[64];
    DWORD cjColor;

    TKASSERT(nColors <= gNumStaticColors);

// Open the key for the system color settings.

    lRet = RegOpenKeyExA(HKEY_CURRENT_USER,
                         "Control Panel\\Colors",
                         0,
                         KEY_QUERY_VALUE,
                         &hkSysColors);

    if ( lRet != ERROR_SUCCESS )
    {
        goto GetRegistrySysColors_exit;
    }

// Read each system color value.  The names are stored in the global
// array of char *, gaszSysClrNames.

    for (i = 0; i < nColors; i++)
    {
        cjColor = sizeof(achColor);
        lRet = RegQueryValueExA(hkSysColors,
                                (LPSTR) gaszSysClrNames[i],
                                (LPDWORD) NULL,
                                &dwDataType,
                                (LPBYTE) achColor,
                                &cjColor);

        TKASSERT(lRet != ERROR_MORE_DATA);

        if ( lRet == ERROR_SUCCESS && dwDataType == REG_SZ )
        {
            DWORD r, g, b;

            sscanf(achColor, "%ld %ld %ld", &r, &g, &b);
            pcr[i] = RGB(r, g, b);
        }
    }

    bRet = TRUE;

GetRegistrySysColors_exit:
    if (hkSysColors)
        RegCloseKey(hkSysColors);

    return bRet;
}
#endif

/******************************Public*Routine******************************\
* GrabStaticEntries
*
* Support routine for Realize to manage the static system color
* usage.
*
* This function will save the current static system color usage state.
* It will fail if:
*
*   1.  TK is not in "sys color in use state but system palette is in
*       SYSPAL_NOSTATIC mode.  This means that another app still possesses
*       the static system colors.  If this happens <TBD>
*
* Side effect:
*   If system colors are changed, then WM_SYSCOLORCHANGE message is
*   broadcast to all top level windows.
*
* Returns:
*   TRUE if successful, FALSE otherwise (see above).
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL 
SS_PAL::GrabStaticEntries()
{
    int i;
    BOOL bRet = FALSE;

    // Do nothing if sys colors already in use.

    if ( !bSystemColorsInUse )
    {
    // Take possession only if no other app has the static colors.
    // How can we tell?  If the return from SetSystemPaletteUse is
    // SYSPAL_STATIC, then no other app has the statics.  If it is
    // SYSPAL_NOSTATIC, someone else has them and we must fail.
    //
    // SetSystemPaletteUse is properly synchronized internally
    // so that it is atomic.
    //
    // Because we are relying on SetSystemPaletteUse to synchronize TK,
    // it is important to observe the following order for grabbing and
    // releasing:
    //
    //      Grab        call SetSystemPaletteUse and check for SYSPAL_STATIC
    //                  save sys color settings
    //                  set new sys color settings
    //
    //      Release     restore sys color settings
    //                  call SetSystemPaletteUse

//mf: ! potential pitfall here, if a 'bad' app has not released the static
// colors on deactivation.
        if ( SetSystemPaletteUse( hdc, SYSPAL_NOSTATIC ) == SYSPAL_STATIC )
        {
        // Save current sys color settings.

            for (i = COLOR_SCROLLBAR; i <= COLOR_BTNHIGHLIGHT; i++)
                gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i);

            bSystemColorsInUse = TRUE;

            // Set b&w sys color settings.

            SetSysColors(gNumStaticColors, gaiStaticIndex, gacrBlackAndWhite);

            // Inform all other top-level windows of the system color change.

            PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

            bRet = TRUE;
        } else {
            // handle case where can't get sys colors
        }
    }
    else
        bRet = TRUE;

    return bRet;
}

/******************************Public*Routine******************************\
* ReleaseStaticEntries
*
* Support routine for Realize to manage the static system color
* usage.
*
* This function will reset the current static system color usage state.
* It will fail if:
*
*   1.  TK is not in a "sys colors in use" state.  If we are in this case,
*       then the static system colors do not need to be released.
*
* Side effect:
*   If system colors are changed, then WM_SYSCOLORCHANGE message is
*   broadcast to all top level windows.
*
* Returns:
*   TRUE if successful, FALSE otherwise (see above).
*
* History:
*  21-Jul-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL 
SS_PAL::ReleaseStaticEntries()
{
    BOOL bRet = FALSE;

    // Do nothing if sys colors not in use.

    if ( bSystemColorsInUse )
    {
#if RESTORE_FROM_REGISTRY
    // Replace saved system colors with registry values.  We do it now
    // rather than earlier because someone may have changed registry while
    // TK app was running in the foreground (very unlikely, but it could
    // happen).
    //
    // Also, we still try to save current setting in GrabStaticEntries so
    // that if for some reason we fail to grab one or more of the colors
    // from the registry, we can still fall back on what we grabbed via
    // GetSysColors (even though there is a chance its the wrong color).

        GetRegistrySysColors(gacrSave, gNumStaticColors);
#endif

        // Do this now, since SetSysColors() generates WM_SYSCOLORCHANGE,
        // which can cause this routine to be re-entered
        // back to here.
        bSystemColorsInUse = FALSE;

        // Return the system palette to SYSPAL_STATIC.

        SetSystemPaletteUse( hdc, SYSPAL_STATIC );

        // Restore the saved system color settings.

        SetSysColors(gNumStaticColors, gaiStaticIndex, gacrSave);

        // Inform all other top-level windows of the system color change.

        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

        // Reset the "sys colors in use" state and return success.

        bSystemColorsInUse = FALSE;
        bRet = TRUE;
    }

    return bRet;
}

// Gamma correction factor * 10
#define GAMMA_CORRECTION 14

// Maximum color distance with 8-bit components
#define MAX_COL_DIST (3*256*256L)

// Number of static colors
#define STATIC_COLORS 20

// Flags used when matching colors
#define EXACT_MATCH 1
#define COLOR_USED 1

// Conversion tables for n bits to eight bits

#if GAMMA_CORRECTION == 10
// These tables are corrected for a gamma of 1.0
static unsigned char abThreeToEight[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};
static unsigned char abTwoToEight[4] =
{
    0, 0x55, 0xaa, 0xff
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#else
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#endif

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
#if GAMMA_CORRECTION == 10
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 4, 32, 36, 128, 132, 160, 173, 181, 245,
    247, 164, 156, 7, 56, 63, 192, 199, 248, 255
};
#else
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};
#endif

unsigned char
ss_ComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    TKASSERT(nbits >= 1 && nbits <= 3);
    
    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return abOneToEight[val & 1];

    case 2:
        return abTwoToEight[val & 3];

    case 3:
        return abThreeToEight[val & 7];
    }
    return 0;
}

// System default colors
static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/******************************Public*Routine******************************\
*
* UpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static void
UpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = (HPALETTE) GetStockObject(DEFAULT_PALETTE);

    // The system should always have one of these
    TKASSERT(hpalStock != NULL);
    // Make sure there's the correct number of entries
    TKASSERT(GetPaletteEntries(hpalStock, 0, 0, NULL) == STATIC_COLORS);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                TKASSERT(pe332->peFlags != COLOR_USED);
                
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;
                
                break;
            }

            pe332++;
        }

        peStatic++;
    }
    
    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }
        
        iMinDist = MAX_COL_DIST+1;
#if DBG
        iMinEntry = -1;
#endif

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }
            
            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        TKASSERT(iMinEntry != -1);

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;
        
        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have set them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PC_NOCOLLAPSE;
        pe332++;
    }
}

/******************************Public*Routine******************************\
* FlushPalette
*
* Because of Win 3.1 compatibility, GDI palette mapping always starts
* at zero and stops at the first exact match.  So if there are duplicates,
* the higher colors aren't mapped to--which is often a problem if we
* are trying to make to any of the upper 10 static colors.  To work around
* this, we flush the palette to all black.
*
\**************************************************************************/

void
SS_PAL::Flush()
{
    LOGPALETTE *pPal;
    HPALETTE hpalBlack, hpalOld;
    int i;

    if( nEntries == 256 )
    {
        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                         sizeof(LOGPALETTE) + nEntries * sizeof(PALETTEENTRY));

        if (pPal)
        {
    	    pPal->palVersion = 0x300;
	        pPal->palNumEntries = (WORD)nEntries;

            // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every 
            // thing into the palette.  Colors are already black because 
            // we zero initialized during memory allocation.

            for (i = 0; i < nEntries; i++)
            {
                pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
            }

            hpalBlack = CreatePalette(pPal);
            LocalFree(pPal);

            hpalOld = SelectPalette(hdc, hpalBlack, FALSE);
            RealizePalette(hdc);

            SelectPalette(hdc, hpalOld, FALSE);
            DeleteObject(hpalBlack);
        }
    }
}

/******************************Public*Routine******************************\
* Realize
*
* Select the given palette in background or foreground mode (as specified
* by the bForceBackground flag), and realize the palette.
*
* If static system color usage is set, the system colors are replaced.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//mf: ! this grabbing of colors n stuff should only be done by the top
// level window - ? but what if it's not a GL window ?

long
SS_PAL::Realize( HWND hwndArg, HDC hdcArg, BOOL bForceBackground )
{
    // cache:
    hwnd = hwndArg;
    hdc = hdcArg;

    if( bTakeOver ) {
        // Easy case
        SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
        SelectPalette(hdc, hPal, bForceBackground );
        RealizePalette(hdc);
        return 1;
    }

    // Else general purpose 'tk' method

    if( bFlush ) {
        Flush();
        bFlush = FALSE;
    }

    return Realize( bForceBackground );
}

long
SS_PAL::Realize( BOOL bForceBackground )
{
    long Result = -1;
    BOOL bHaveSysPal = TRUE;

    SS_DBGLEVEL2( SS_LEVEL_INFO, "SS_PAL::Realize: %d for %d\n", bForceBackground, hwnd );

    // If static system color usage is set, prepare to take over the
    // system palette.

    if( bUseStatic )
    {
        // If foreground, take over the static colors.  If background, release
        // the static colors.

        if ( !bForceBackground )
        {
            // If GrabStaticEntries succeeds, then it is OK to take over the
            // static colors.  If not <mf:TBD>

            bHaveSysPal = GrabStaticEntries();
        }
        else
        {
            // If we are currently using the system colors (bSystemColorsInUse)
            // and Realize was called with bForceBackground set, we
            // are being deactivated and must release the static system colors.

            ReleaseStaticEntries();
        }

        // Rerealize the palette.
        //
        // If set to TRUE, bForceBackground will force the palette to be 
        // realized as a background palette, regardless of focus.  This 
        // will happen anyway if the TK window does not have the keyboard focus.

        if ( (bForceBackground || bHaveSysPal) &&
             UnrealizeObject( hPal ) &&
             NULL != SelectPalette( hdc, hPal, bForceBackground ) )
        {
            Result = RealizePalette( hdc );
        }
//mf: ?? klugey fix for rude apps
        // If some rude app still has the system colors and we're in the
        // foreground, make the best of it.
        if( !bForceBackground && !bHaveSysPal ) {
            if( UnrealizeObject( hPal ) &&
                NULL != SelectPalette( hdc, hPal, TRUE ) )
            {
                Result = RealizePalette( hdc );
            }
        }
    }
    else
    {
        if ( NULL != SelectPalette( hdc, hPal, FALSE ) )
        {
            Result = RealizePalette( hdc );
        }
    }

    return( Result );
}

/******************************Public*Routine******************************\
* SS_PAL constructor
*
* This creates the palette, but does not select or realize it
*
\**************************************************************************/

SS_PAL::SS_PAL( HDC hdcArg, PIXELFORMATDESCRIPTOR *ppfd, BOOL bTakeOverPalette )
{
    hwnd = 0;
    hPal = 0;
    bUseStatic = FALSE;
    bSystemColorsInUse = FALSE;
    pfd = *ppfd;  // this is for palette purposes only (other fields may not apply)
    hdc = hdcArg;
    bTakeOver = bTakeOverPalette;  // mf: for now, when this is set, it means
        // the screen saver is running in full screen mode - implying that
        // interaction with other apps not necessary

    if( bTakeOver ) {
//mf: !!! bFlush should be per-window, not per SS_PAL !!
//mf: hmmm, not so sure about that...
        bFlush = FALSE;
        bUseStatic = TRUE;
    } else {
        bFlush = TRUE;
        bUseStatic = ppfd->dwFlags & PFD_NEED_SYSTEM_PALETTE;
    }

    if( bUseStatic )
        // save current static palette usage so we can restore it
        uiOldStaticUse = GetSystemPaletteUse( hdc );

    paletteManageProc = NullPaletteManageProc;

    // Now create the palette and return
    hPal = MakeRGBPalette();
    SS_ASSERT( hPal, "SS_PAL constructor failure\n" );
}

/******************************Public*Routine******************************\
* SS_PAL destructor

\**************************************************************************/

SS_PAL::~SS_PAL()
{
    if( bUseStatic )
    {
        if( uiOldStaticUse )
            //mf: ! make sure hdc is valid !!!
            SetSystemPaletteUse(hdc, uiOldStaticUse);

        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);
    }
    if( hPal ) {
        SelectPalette( hdc, (HPALETTE) GetStockObject(DEFAULT_PALETTE), TRUE );
        DeleteObject( hPal );
    }
}

/******************************Public*Routine******************************\
* ReCreateRGBPalette
* 
*
\**************************************************************************/

void
SS_PAL::ReCreateRGBPalette()
{
    if( bTakeOver )
        return;

    HPALETTE hPalTmp = hPal;
    hPal = MakeRGBPalette();
    if( hPal ) {
        DeleteObject( hPalTmp );
        bFlush = TRUE;
    }
}

/******************************Public*Routine******************************\
* MakeRGBPalette
*
* Creates an HPALETTE with values required for a logical rgb palette.
* If bUseStatic is TRUE, the static system
* colors will be overridden.  Otherwise, the PALETTEENTRY array will be
* fixed up to contain the default static system colors.
*
\**************************************************************************/

HPALETTE
SS_PAL::MakeRGBPalette()
{
    LOGPALETTE *pPal;
    HPALETTE hpal;
    int count, i;
    PIXELFORMATDESCRIPTOR *ppfd = &pfd;

    count = 1 << ppfd->cColorBits;
    nEntries = count;
    pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
            count * sizeof(PALETTEENTRY));
    if( !pPal )
        return (HPALETTE) 0;

    pPal->palVersion = 0x300;
    pPal->palNumEntries = (WORD)count;

    PALETTEENTRY *pEntry = pPal->palPalEntry;

    for ( i = 0; i < count ; i++, pEntry++ )
    {
        pEntry->peRed   = ss_ComponentFromIndex(i, ppfd->cRedBits,
                                ppfd->cRedShift);
        pEntry->peGreen = ss_ComponentFromIndex(i, ppfd->cGreenBits,
                                ppfd->cGreenShift);
        pEntry->peBlue  = ss_ComponentFromIndex(i, ppfd->cBlueBits,
                                ppfd->cBlueShift);
        pEntry->peFlags = PC_NOCOLLAPSE;
    }

    if( count == 256 )
    {
    // If app set static system color usage for fixed palette support,
    // setup to take over the static colors.  Otherwise, fixup the
    // static system colors.

        if ( bUseStatic )
        {
        // Black and white already exist as the only remaining static
        // colors.  Let those remap.  All others should be put into
        // the palette (i.e., set PC_NOCOLLAPSE).

            pPal->palPalEntry[0].peFlags = 0;
            pPal->palPalEntry[255].peFlags = 0;
        }
        else
        {
        // The defaultOverride array is computed assuming a 332
        // palette where red has zero shift, etc.

            if ( (3 == ppfd->cRedBits)   && (0 == ppfd->cRedShift)   &&
                 (3 == ppfd->cGreenBits) && (3 == ppfd->cGreenShift) &&
                 (2 == ppfd->cBlueBits)  && (6 == ppfd->cBlueShift) )
            {
                pEntry = pPal->palPalEntry;
                UpdateStaticMapping( pEntry );
                
                for ( i = 0 ; i < STATIC_COLORS ; i++)
                {
                    pEntry[aiDefaultOverride[i]] = apeDefaultPalEntry[i];
                }
            }
        }
    }

    hpal = CreatePalette(pPal);
    LocalFree(pPal);
    return hpal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\scrnsave.cxx ===
//----------------------------------------------------------------------------
//
// SCRNSAVE.C      --    skeleton for screen saver application
//
//    4/5/94 francish   merged NT and Win4 saver code, folded in SCRNSAVE.SCR
//
//  - 3/14/96: marcfo   Pulled this file in from shell\control\scrnsave\common.
//             All changes marked with GL_SCRNSAVE.
//----------------------------------------------------------------------------

#define GL_SCRNSAVE 1

#define WIN31
#include <windows.h>
#include <windowsx.h>
#include "scrnsave.h"
#include <regstr.h>
#include    <imm.h>
#ifdef GL_SCRNSAVE
#include "glscrnsv.h"
#endif

#define DBG_MSGS    0

const TCHAR szScreenSaverKey[] = REGSTR_PATH_SCREENSAVE;
TCHAR szPasswordActiveValue[] = REGSTR_VALUE_USESCRPASSWORD;
const TCHAR szPasswordValue[] = REGSTR_VALUE_SCRPASSWORD;
TCHAR szPwdDLL[] = TEXT("PASSWORD.CPL");
CHAR szFnName[] = "VerifyScreenSavePwd";        // Proc name, must be ANSI
TCHAR szImmDLL[] = TEXT("IMM32.DLL");
CHAR szImmFnc[] = "ImmAssociateContext";        // Proc name, must be ANSI
#if 0
TCHAR szCoolSaverHacks[] = REGSTR_PATH_SETUP TEXT("\\Screen Savers");
TCHAR szMouseThreshold[] = TEXT("Mouse Threshold");
TCHAR szPasswordDelay[] = TEXT("Password Delay");
#endif

typedef BOOL (FAR PASCAL * VERIFYPWDPROC) (HWND);
typedef HIMC (FAR PASCAL * IMMASSOCPROC) (HWND,HIMC);


//----------------------------------------------------------------------------
// variables declared in SCRNSAVE.H
HINSTANCE hMainInstance = 0;
HWND hMainWindow = 0;
BOOL fChildPreview = FALSE;



//----------------------------------------------------------------------------
// other globals
POINT ptMouse;
BOOL fClosing = FALSE;
BOOL fCheckingPassword = FALSE;
HINSTANCE hInstPwdDLL = NULL;
VERIFYPWDPROC VerifyPassword = NULL;
static BOOL preview_like_fullscreen = FALSE;
static UINT uShellAutoPlayQueryMessage = 0;
HINSTANCE hInstImm = NULL;
IMMASSOCPROC ImmFnc = NULL;
HIMC hPrevImc = (HIMC)0L;


static BOOL fOnWin95 = FALSE;  //TRUE if on Chicago, FALSE if on Cairo

//----------------------------------------------------------------------------
// random junk
DWORD dwWakeThreshold = 4;  //default to slight movement
DWORD dwPasswordDelay = 0;
DWORD dwBlankTime = 0;
#define MAX_PASSWORD_DELAY_IN_SECONDS (60)

//----------------------------------------------------------------------------
// forward declarations of internal fns
#ifndef GL_SCRNSAVE
// These are hooked out to glscrnsv.cxx
static INT_PTR DoScreenSave( HWND hParent );
static INT_PTR DoConfigBox( HWND hParent );
#endif
static INT_PTR DoSaverPreview( LPCTSTR szUINTHandle );
static INT_PTR DoChangePw( LPCTSTR szUINTHandle );
static BOOL DoPasswordCheck( HWND hParent );
VOID LoadPwdDLL(VOID);
VOID UnloadPwdDLL(VOID);


//----------------------------------------------------------------------------
// helper for time
static DWORD
GetElapsedTime(DWORD from, DWORD to)
{
    return (to >= from)? (to - from) : (1 + to + (((DWORD)-1) - from));
}

//----------------------------------------------------------------------------
// helper to convert text to unsigned int
static UINT_PTR
atoui( LPCTSTR szUINT )
{
   UINT_PTR uValue = 0;

   while( ( *szUINT >= TEXT('0') ) && ( *szUINT <= TEXT('9') ) )
      uValue = ( ( uValue * 10 ) + ( *szUINT++ - TEXT('0') ) );

   return uValue;
}


//----------------------------------------------------------------------------
// Local reboot and hotkey control (on Win95)
static void
HogMachine( BOOL value )
{
    BOOL dummy;

    //
    // NT is always secure, therefore we don't need to call this on Cairo/NT
    //
    if (fOnWin95) {
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, value, &dummy, 0 );
    }
}


//----------------------------------------------------------------------------
// entry point (duh)
INT_PTR PASCAL
WinMainN( HINSTANCE hInst, HINSTANCE hPrev, LPTSTR szCmdLine, int nCmdShow )
{
   LPCTSTR pch = szCmdLine;
   HWND hParent = 0;
   OSVERSIONINFO osvi;

   hMainInstance = hInst;

   osvi.dwOSVersionInfoSize = sizeof(osvi);
   fOnWin95 = (GetVersionEx(&osvi) &&
                osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

#ifdef GL_SCRNSAVE
   //
   // the shell sends this message to the foreground window before running an
   // AutoPlay app. we return 1 to cancel autoplay if we are password protected
   //
   if (fOnWin95) {
        uShellAutoPlayQueryMessage = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
   } else {
        uShellAutoPlayQueryMessage = 0;
   }
#endif

   _try
   {
      for(;;) switch( *pch )
      {
          case TEXT('S'):
          case TEXT('s'):
              return DoScreenSave( NULL );

#ifdef GL_SCRNSAVE
          case TEXT('W'):
          case TEXT('w'):
              do pch++; while( *pch == TEXT(' ') );  // size parameters
              return DoWindowedScreenSave( pch );
#endif

          case TEXT('L'):
          case TEXT('l'):
              // special switch for tests such as WinBench
              // this is NOT a hack to make bechmarks look good
              // it's a hack to allow you to benchmark a screen saver
              // many bechmarking apps require the whole screen in foreground
              // which makes it hard to measure how a screensaver adds CPU load
              // you must provide a parent window (just like preview mode)
              preview_like_fullscreen = TRUE;
          case TEXT('P'):
          case TEXT('p'):
              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff
              return DoSaverPreview( pch );

          case TEXT('A'):
          case TEXT('a'):
              if (!fOnWin95)
                  return -1;
              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff
              return DoChangePw( pch );

          case TEXT('C'):
          case TEXT('c'): {
              HWND hwndParent = NULL
              ;
              // Look for optional parent window after the "C",
              // syntax is "C:hwnd_value"
              if (*(++pch) == TEXT(':')) {
                   hwndParent = (HWND)atoui( ++pch );
              }

              if (hwndParent == NULL || !IsWindow(hwndParent))
                   hwndParent = GetForegroundWindow();

              return DoConfigBox( hwndParent );
          }

          case TEXT('\0'):
              return DoConfigBox( NULL );

          case TEXT(' '):
          case TEXT('-'):
          case TEXT('/'):
              pch++;   // skip spaces and common switch prefixes
              break;

          default:
              return -1;
      }
   }
   _except(UnhandledExceptionFilter(GetExceptionInformation()))
   {
      // don't leave local reboot and hotkeys disabled on Win95
      HogMachine( FALSE );
   }
   return -1;
}


//----------------------------------------------------------------------------
// default screen-saver proc, declared in SCRNSAVE.H
// intended to be called by the consumer's ScreenSaverProc where
// DefWindowProc would normally be called
LRESULT WINAPI
DefScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
#if DBG_MSGS
    TCHAR szBuff[80];

    wsprintf( szBuff, TEXT("*** DefSSP received:\t0x%04lx 0x%08lx 0x%08lx\n"), uMsg, wParam, lParam );
    OutputDebugString(szBuff);
#endif

   if( !fChildPreview && !fClosing )
   {
      switch( uMsg )
      {
         case WM_CLOSE:
            //
            // Only do password check if on Windows 95.  WinNT (Cairo) has
            // the password check built into the security desktop for
            // C2 compliance.
            //
            if (fOnWin95) {
                if( !DoPasswordCheck( hWnd ) )
                {
                    GetCursorPos( &ptMouse );  // re-establish
                    return FALSE;
                }
            }
#ifdef GL_SCRNSAVE
            // We need to know when we're being terminated, so we can do
            // various clean-up stuff
            SendMessage( hWnd, SS_WM_CLOSING, 0, 0 );
#endif
            break;

         case SCRM_VERIFYPW:
            if (fOnWin95)
                return ( VerifyPassword? (LRESULT)VerifyPassword( hWnd ) : 1L );
            break;

         default:
         {
            POINT ptMove, ptCheck;

            if( fCheckingPassword )
                break;

            switch( uMsg )
            {
                case WM_SHOWWINDOW:
                    if( (BOOL)wParam )
                    SetCursor( NULL );
                    break;

                case WM_SETCURSOR:
                    SetCursor( NULL );
                    return TRUE;

                case WM_MOUSEMOVE:
                    GetCursorPos( &ptCheck );
                    if( ( ptMove.x = ptCheck.x - ptMouse.x ) && ( ptMove.x < 0 ) )
                        ptMove.x *= -1;
                    if( ( ptMove.y = ptCheck.y - ptMouse.y ) && ( ptMove.y < 0 ) )
                        ptMove.y *= -1;
                    if( ((DWORD)ptMove.x + (DWORD)ptMove.y) > dwWakeThreshold )
                    {
                        PostMessage( hWnd, WM_CLOSE, 0, 0l );
                        ptMouse = ptCheck;
                    }
                    break;

                case WM_POWERBROADCAST:
                    switch (wParam)
                    {
                    case PBT_APMRESUMECRITICAL:
                    case PBT_APMRESUMESUSPEND:
                    case PBT_APMRESUMESTANDBY:
                    case PBT_APMRESUMEAUTOMATIC:
                        // If the system is resuming from a real suspend
                        // (as opposed to a failed suspend) deactivate
                        // the screensaver.
                        if ((lParam & PBTF_APMRESUMEFROMFAILURE) == 0)
                            goto PostClose;
                        break;
		    default:
			// The standard screensaver code shuts down on
			// all power broadcast messages.  This doesn't
			// make much sense, but match the behavior so
			// that all screensavers operate the same way.
			goto PostClose;
                    }
                    break;

                case WM_POWER:
                    //
                    // a critical resume does not generate a WM_POWERBROADCAST
                    // to windows for some reason, but it does generate an old
                    // WM_POWER message.
                    //
                    if (wParam == PWR_CRITICALRESUME)
                        goto PostClose;
                    break;

                case WM_ACTIVATEAPP:
                    if( wParam ) break;
                case WM_LBUTTONDOWN:
                case WM_MBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_KEYDOWN:
                case WM_SYSKEYDOWN:
PostClose:
                    PostMessage( hWnd, WM_CLOSE, 0, 0l );
                    break;
            }
         }
      }
   }

   //
   // the shell sends this message to the foreground window before running an
   // AutoPlay app. On Win95, we return 1 to cancel autoplay if we are password protected
   //
   // On WinNT, secure screen savers run on a secure separate desktop, and will never see
   // this message, therefore, this code will never get executed.
   //
   //
   // 
   // On NT we don't want to take down the screen saver unless it is running
   // on the same desktop as the autoplay shell.  There is code in the
   // NT autoplay shell that looks for this and does not run the app if
   // that is the case; however, I not positive that the uShellAutoPlayQueryMessage
   // will not go between desktops.  (BradG assures me that it will not, but you
   // never know.)  If secure screensavers on NT randomly close when you put
   // an autoplay cd in the drive, then this code should be examined closely.
   //
   if ((uMsg == uShellAutoPlayQueryMessage) && uMsg)
   {
      PostMessage(hWnd, WM_CLOSE, 0, 0L);
      return (VerifyPassword != NULL);
   }

   return DefWindowProc( hWnd, uMsg, wParam, lParam );
}

//----------------------------------------------------------------------------
// This window procedure takes care of important stuff before calling the
// consumer's ScreenSaverProc.  This helps to prevent us from getting hosed
// by wacky consumer code.
LRESULT WINAPI
RealScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
    case WM_CREATE:
        // screen saver does not need the IME
        if ((hInstImm = GetModuleHandle(szImmDLL)) &&
            (ImmFnc = (IMMASSOCPROC)GetProcAddress(hInstImm,szImmFnc)))
             hPrevImc = ImmFnc(hWnd, (HIMC)0);

        // establish the mouse position
        GetCursorPos( &ptMouse );

        if( !fChildPreview )
            SetCursor( NULL );
        
        break;

    case WM_DESTROY:
        // screen saver does not need the IME
        if( hInstImm && ImmFnc && hPrevImc )
            ImmFnc(hWnd, hPrevImc);

        PostQuitMessage( 0 );
        break;

    case WM_SETTEXT:
        // don't let some fool change our title
        // we need to be able to use FindWindow() to find running instances
        // of full-screen windows screen savers
        // NOTE: USER slams our title in during WM_NCCREATE by calling the
        // defproc for WM_SETTEXT directly, so the initial title will get
        // there.  If this ever changes, we can simply set a bypass flag
        // during WM_NCCREATE processing.
        return FALSE;

    case WM_SYSCOMMAND:
        if (!fChildPreview)
        {
            switch (wParam)
            {
            case SC_NEXTWINDOW:       // no Alt-tabs
            case SC_PREVWINDOW:       // no shift-alt-tabs
            case SC_SCREENSAVE:       // no more screensavers
                return FALSE;
            }
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if( fChildPreview )
        {
            // if we're in preview mode, pump the help stuff to our owner
            HWND hParent = GetParent( hWnd );

            if( hParent && IsWindow( hParent ) )
                PostMessage( hParent, uMsg, (WPARAM)hParent, lParam );
            return TRUE;
        }
        break;

    case WM_TIMER:
        if( fClosing )
            return FALSE;
        Sleep( 0 );
        break;
       
    case WM_IME_NOTIFY:
        // Eat IMN_OPENSTATUSWINDOW so that the status window
        // isn't displayed.
        if (wParam == IMN_OPENSTATUSWINDOW)
        {
            return 0;
        }
        break;
       
    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        if( fClosing )
            return DefWindowProc( hWnd, uMsg, wParam, lParam );
        break;

    case WM_PAINT:
        if( fClosing )
            return DefWindowProc( hWnd, uMsg, wParam, lParam );
        if( !fChildPreview )
            SetCursor( NULL );
        break;
    }

    return ScreenSaverProc( hWnd, uMsg, wParam, lParam );
}

#ifdef GL_SCRNSAVE
void
#else
static void
#endif
InitRealScreenSave()
{
#if 0
   HKEY hkey;

   if (RegOpenKey(HKEY_CURRENT_USER, szCoolSaverHacks, &hkey) ==
      ERROR_SUCCESS)
   {
      DWORD data, len, type;

      len = sizeof(data);
      if ((RegQueryValueEx(hkey, szMouseThreshold, NULL, &type,
         (LPBYTE)&data, &len) == ERROR_SUCCESS) && (type == REG_DWORD))
      {
         dwWakeThreshold = max(dwWakeThreshold, data);
      }

      len = sizeof(data);
      if ((RegQueryValueEx(hkey, szPasswordDelay, NULL, &type,
         (LPBYTE)&data, &len) == ERROR_SUCCESS) && (type == REG_DWORD) && data)
      {
         data = min(MAX_PASSWORD_DELAY_IN_SECONDS, data);
         dwPasswordDelay = data * 1000;
         dwBlankTime = GetTickCount();
      }
   }
#endif

   LoadPwdDLL();
}

//----------------------------------------------------------------------------

#ifndef GL_SCRNSAVE

static INT_PTR
DoScreenSave( HWND hParent )
{
   LPCTSTR pszWindowClass = TEXT("WindowsScreenSaverClass");
   LPCTSTR pszWindowTitle;

   WNDCLASS cls;
   MSG      msg;
   UINT     uStyle;
   UINT     uExStyle;
   int      ncx, ncy;
   int      nx, ny;

   cls.hCursor        = NULL;
   cls.hIcon          = LoadIcon( hMainInstance, MAKEINTATOM( ID_APP ) );
   cls.lpszMenuName   = NULL;
   cls.lpszClassName  = pszWindowClass;
   cls.hbrBackground  = GetStockObject( BLACK_BRUSH );
   cls.hInstance      = hMainInstance;
   cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC;
   cls.lpfnWndProc    = RealScreenSaverProc;
   cls.cbWndExtra     = 0;
   cls.cbClsExtra     = 0;

   if( hParent )
   {
      RECT rcParent;
      GetClientRect( hParent, &rcParent );
      ncx = rcParent.right;
      ncy = rcParent.bottom;
      nx  = 0;
      ny  = 0;
      uStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN;
      uExStyle = 0;

      fChildPreview = TRUE;
      pszWindowTitle = TEXT("Preview");      // MUST differ from full screen
   }
   else
   {
      HWND hOther;

#ifdef SM_CXVIRTUALSCREEN
      nx  = GetSystemMetrics( SM_XVIRTUALSCREEN );
      ny  = GetSystemMetrics( SM_YVIRTUALSCREEN );
      ncx = GetSystemMetrics( SM_CXVIRTUALSCREEN );
      ncy = GetSystemMetrics( SM_CYVIRTUALSCREEN );

      if (ncx == 0 || ncy == 0)
#endif
      {
        RECT rc;
        HDC hdc = GetDC(NULL);
        GetClipBox(hdc, &rc);
        ReleaseDC(NULL, hdc);
        nx = rc.left;
        ny = rc.top;
        ncx = rc.right  - rc.left;
        ncy = rc.bottom - rc.top;
      }

      uStyle = WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
      uExStyle = WS_EX_TOPMOST;

      pszWindowTitle = TEXT("Screen Saver"); // MUST differ from preview

      // if there is another NORMAL screen save instance, switch to it
      hOther = FindWindow( pszWindowClass, pszWindowTitle );

      if( hOther && IsWindow( hOther ) )
      {
         SetForegroundWindow( hOther );
         return 0;
      }

      InitRealScreenSave();
   }

   //
   // the shell sends this message to the foreground window before running an
   // AutoPlay app. we return 1 to cancel autoplay if we are password protected
   //
   if (fOnWin95) {
        uShellAutoPlayQueryMessage = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
   } else {
        uShellAutoPlayQueryMessage = 0;
   }

   if( RegisterClass( &cls ) )
   {
      hMainWindow = CreateWindowEx( uExStyle, pszWindowClass, pszWindowTitle,
                        uStyle, nx, ny, ncx, ncy, hParent, (HMENU)NULL,
                        hMainInstance, (LPVOID)NULL );
   }

   if( hMainWindow )
   {
      if( !fChildPreview )
         SetForegroundWindow( hMainWindow );

      while( GetMessage( &msg, NULL, 0, 0 ) )
      {
         TranslateMessage( &msg );
         DispatchMessage( &msg );
      }
   }

   // free password-handling DLL if loaded
   UnloadPwdDLL();

   return msg.wParam;
}
#endif


//----------------------------------------------------------------------------

static INT_PTR
DoSaverPreview( LPCTSTR szUINTHandle )
{
   // get parent handle from string
   HWND hParent = (HWND)atoui( szUINTHandle );

   // only preview on a valid parent window (NOT full screen)
   return ( (hParent && IsWindow( hParent ))? DoScreenSave( hParent ) : -1 );
}


//----------------------------------------------------------------------------

#ifndef GL_SCRNSAVE

static INT_PTR
DoConfigBox( HWND hParent )
{
   // let the consumer register any special controls for the dialog
   if( !RegisterDialogClasses( hMainInstance ) )
      return FALSE;

   return DialogBox( hMainInstance, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
                     hParent, (DLGPROC)ScreenSaverConfigureDialog );
}
#endif


//----------------------------------------------------------------------------

static INT_PTR
DoChangePw( LPCTSTR szUINTHandle )
{
   // get parent handle from string
   HWND hParent = (HWND)atoui( szUINTHandle );

   if( !hParent || !IsWindow( hParent ) )
      hParent = GetForegroundWindow();

   // allow the library to be hooked
   ScreenSaverChangePassword( hParent );
   return 0;
}

static const TCHAR szMprDll[] = TEXT("MPR.DLL");       // not to be localized
static const TCHAR szProviderName[] = TEXT("SCRSAVE"); // not to be localized

#ifdef UNICODE
static const CHAR szPwdChangePW[] = "PwdChangePasswordW"; // not to be localized
#else
static const CHAR szPwdChangePW[] = "PwdChangePasswordA"; // not to be localized
#endif

// bogus prototype
typedef DWORD (FAR PASCAL *PWCHGPROC)( LPCTSTR, HWND, DWORD, LPVOID );

void WINAPI
ScreenSaverChangePassword( HWND hParent )
{
   HINSTANCE mpr = LoadLibrary( szMprDll );

   if( mpr )
   {
      // netland hasn't cracked MNRENTRY yet
      PWCHGPROC pwd = (PWCHGPROC)GetProcAddress( mpr, szPwdChangePW );

      if( pwd )
         pwd( szProviderName, hParent, 0, NULL );

      FreeLibrary( mpr );
   }
}


//----------------------------------------------------------------------------

static BOOL
DoPasswordCheck( HWND hParent )
{
   // don't reenter and don't check when we've already decided
   if( fCheckingPassword || fClosing )
      return FALSE;

   if( VerifyPassword )
   {
      static DWORD lastcheck = (DWORD)-1;
      DWORD curtime = GetTickCount();
      MSG msg;

      if (dwPasswordDelay &&
         (GetElapsedTime(dwBlankTime, curtime) < dwPasswordDelay))
      {
         fClosing = TRUE;
         goto _didcheck;
      }

      // no rapid checking...
      if ((lastcheck != (DWORD)-1) &&
         (GetElapsedTime(lastcheck, curtime) < 200))
      {
         goto _didcheck;
      }

      // do the check
      fCheckingPassword = TRUE;

#ifdef GL_SCRNSAVE
      // Put ss in idle mode during password dialog processing
      SendMessage( hParent, SS_WM_IDLE, SS_IDLE_ON, 0L );
#endif

      // flush WM_TIMER messages before putting up the dialog
      PeekMessage( &msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD );
      PeekMessage( &msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD );

      // call the password verify proc
      fClosing = (BOOL)SendMessage( hParent, SCRM_VERIFYPW, 0, 0L );

      fCheckingPassword = FALSE;

#ifdef GL_SCRNSAVE
      // Restore normal display mode
      SendMessage( hParent, SS_WM_IDLE, SS_IDLE_OFF, 0L );
#endif

      if (!fClosing)
         SetCursor(NULL);

      // curtime may be outdated by now
      lastcheck = GetTickCount();
   }
   else
   {
      // passwords disabled or unable to load handler DLL, always allow exit
      fClosing = TRUE;
   }

_didcheck:
   return fClosing;
}

//----------------------------------------------------------------------------
// stolen from the CRT, used to shirink our code

int _stdcall
DummyEntry( void )
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"')) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while (*(pszCmdLine = CharNext(pszCmdLine)) &&
              (*pszCmdLine != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while ((UINT)*pszCmdLine > (UINT)TEXT(' '))
            pszCmdLine = CharNext(pszCmdLine);
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && ((UINT)*pszCmdLine <= (UINT)TEXT(' '))) {
        pszCmdLine = CharNext(pszCmdLine);
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = (int)WinMainN(GetModuleHandle(NULL), NULL, pszCmdLine,
        si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;   // We never comes here.
}

//----------------------------------------------------------------------------
// main() entry point to satisfy old NT screen savers
void _cdecl main( int argc, char *argv[] ) {
    DummyEntry();
}

//----------------------------------------------------------------------------
// WinMain() entry point to satisfy old NT screen savers
int PASCAL WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int nCmdShow ) {
    DummyEntry();
    return 0;

    // reference unreferenced parameters
    (void)hInst;
    (void)hPrev;
    (void)szCmdLine;
    (void)nCmdShow;
}


VOID LoadPwdDLL(VOID)
{
    HKEY hKey;

    if (!fOnWin95)
        return;

    if (hInstPwdDLL)
        UnloadPwdDLL();

    // look in registry to see if password turned on, otherwise don't
    // bother to load password handler DLL
    if (RegOpenKey(HKEY_CURRENT_USER,szScreenSaverKey,&hKey) ==
        ERROR_SUCCESS)
    {
        DWORD dwVal,dwSize=sizeof(dwVal);

        if ((RegQueryValueEx(hKey,szPasswordActiveValue,
            NULL,NULL,(BYTE *) &dwVal,&dwSize) == ERROR_SUCCESS)
            && dwVal)
        {

            // try to load the DLL that contains password proc.
            hInstPwdDLL = LoadLibrary(szPwdDLL);
            if (hInstPwdDLL)
            {
                VerifyPassword = (VERIFYPWDPROC) GetProcAddress(hInstPwdDLL,
                    szFnName);

                if( VerifyPassword )
                    HogMachine( TRUE );
                else
                    UnloadPwdDLL();
            }
        }

        RegCloseKey(hKey);
    }

}

VOID UnloadPwdDLL(VOID)
{
    if (!fOnWin95)
        return;

    if (hInstPwdDLL)
    {
        FreeLibrary(hInstPwdDLL);
        hInstPwdDLL = NULL;

        if( VerifyPassword )
        {
            VerifyPassword = NULL;
            HogMachine( FALSE );
        }
    }
}

//----------------------------------------------------------------------------
// compatbility stuff  (to make porting easier)
TCHAR szAppName[ APPNAMEBUFFERLEN ];
TCHAR szName[ TITLEBARNAMELEN ];
TCHAR szIniFile[ MAXFILELEN ];
TCHAR szScreenSaver[ 22 ];
TCHAR szHelpFile[ MAXFILELEN ];
TCHAR szNoHelpMemory[ BUFFLEN ];

// Quick fix for old screen savers that don't know about context
// sensitive help
UINT  MyHelpMessage = WM_HELP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\ssdib.c ===
/******************************Module*Header*******************************\
* Module Name: ssdib.c
*
* Operations on .bmp files
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> 
#include "tk.h"
#include "sscommon.h"

#define BFT_BITMAP  0x4d42  // 'BM' -- indicates structure is BITMAPFILEHEADER

// struct BITMAPFILEHEADER {
//      WORD  bfType
//      DWORD bfSize
//      WORD  bfReserved1
//      WORD  bfReserved2
//      DWORD bfOffBits
// }
#define OFFSET_bfType       0
#define OFFSET_bfSize       2
#define OFFSET_bfReserved1  6
#define OFFSET_bfReserved2  8
#define OFFSET_bfOffBits    10
#define SIZEOF_BITMAPFILEHEADER 14

// Read a WORD-aligned DWORD.  Needed because BITMAPFILEHEADER has
// WORD-alignment.
#define READDWORD(pv)   ( (DWORD)((PWORD)(pv))[0]               \
                          | ((DWORD)((PWORD)(pv))[1] << 16) )   \

// Computes the number of BYTES needed to contain n number of bits.
#define BITS2BYTES(n)   ( ((n) + 7) >> 3 )

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DibNumColors(VOID FAR * pv)                                *
 *                                                                          *
 *  PURPOSE    : Determines the number of colors in the DIB by looking at   *
 *               the BitCount filed in the info block.                      *
 *                                                                          *
 *  RETURNS    : The number of colors in the DIB.                           *
 *                                                                          *
 * Stolen from SDK ShowDIB example.                                         *
 ****************************************************************************/

static WORD DibNumColors(VOID FAR * pv)
{
    WORD                bits;
    BITMAPINFOHEADER UNALIGNED *lpbi;
    BITMAPCOREHEADER UNALIGNED *lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     *
     *  Because of the way we use this call, BITMAPINFOHEADER may be out
     *  of alignment if it follows a BITMAPFILEHEADER.  So use the macro
     *  to safely access DWORD fields.
     */
    if (READDWORD(&lpbi->biSize) != sizeof(BITMAPCOREHEADER)){
        if (READDWORD(&lpbi->biClrUsed) != 0)
        {
            return (WORD) READDWORD(&lpbi->biClrUsed);
        }
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits){
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            return 256;
        default:
            /* A 24 bitcount DIB has no color table */
            return 0;
    }
}

/******************************Public*Routine******************************\
* ss_DIBImageLoad
*
* Hacked form of tk_DIBImageLoad(), for reading a .bmp file from a resource
*
* Loads a DIB file (specified as either an ANSI or Unicode filename,
* depending on the bUnicode flag) and converts it into a TK image format.
*
* The technique used is based on CreateDIBSection and SetDIBits.
* CreateDIBSection is used to create a DIB with a format easily converted
* into the TK image format (packed 24BPP RGB).  The only conversion 
* required is swapping R and B in each RGB triplet (see history below)
* The resulting bitmap is selected into a memory DC.
*
* The DIB file is mapped into memory and SetDIBits called to initialize
* the memory DC bitmap.  It is during this step that GDI converts the
* arbitrary DIB file format to RGB format.
*
* Finally, the RGB data in the DIB section is read out and repacked
* as 24BPP 'BGR'.
*
* Returns:
*   BOOL.  If an error occurs, a diagnostic error
*   message is put into the error stream and tkQuit() is called,
*   terminating the app.
*
* History:
*   - 11/30/95: [marcfo]
*     Modified from tkDIBImageLoad, to work on resource bmp file.
*     At first I tried accessing the bitmap resource as an RT_BITMAP, where
*     the resource compiler strips out file information, and leaves you simple
*     bitmap data.  But this only worked on the Alpha architecture, x86
*     produced a resource with corrupted image data (?palette :)).  So I ended
*     up just slamming the entire .bmp file in as a resource.
*
\**************************************************************************/

BOOL ss_DIBImageLoad(PVOID pv, TEXTURE *ptex)
{
    BOOL             fSuccess = FALSE;
    WORD             wNumColors;    // Number of colors in color table
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER UNALIGNED *pbmihFile;
    BITMAPCOREHEADER UNALIGNED *pbmchFile; // Ptr to file's core header (if it exists)
    PVOID            pvBits;    // Ptr to bitmap bits in file
    PBYTE            pjBitsRGB;     // Ptr to 24BPP RGB image in DIB section
    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits
    PBYTE            pjSrc;         // Ptr to image file used for conversion
    PBYTE            pjDst;         // Ptr to TK image used for conversion

    // These need to be cleaned up when we exit:
    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC
    HBITMAP    hbmRGB = (HBITMAP) NULL;             // 24BPP RGB bitmap
    BITMAPINFO *pbmiSource = (BITMAPINFO *) NULL;   // Ptr to source BITMAPINFO
    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO

    int i, j;
    int padBytes;

// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pv;

    if ( pbmf->bfType == BFT_BITMAP )
    {
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);

    // BITMAPFILEHEADER is WORD aligned, so use safe macro to read DWORD
    // bfOffBits field.

        pvBits = (PVOID *) ((PBYTE) pbmf
                                + READDWORD((PBYTE) pbmf + OFFSET_bfOffBits));
    }
    else
    {
        pbmihFile = (BITMAPINFOHEADER *) pv;

    // Determination of where the bitmaps bits are needs to wait until we
    // know for sure whether we have a BITMAPINFOHEADER or a BITMAPCOREHEADER.
    }

// Determine the number of colors in the DIB palette.  This is non-zero
// only for 8BPP or less.

    wNumColors = DibNumColors(pbmihFile);

// Create a BITMAPINFO (with color table) for the DIB file.  Because the
// file may not have one (BITMAPCORE case) and potential alignment problems,
// we will create a new one in memory we allocate.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    pbmiSource = (BITMAPINFO *)
        LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFO)
                               + wNumColors * sizeof(RGBQUAD));
    if (!pbmiSource)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

    // Convert WORD-aligned BITMAPINFOHEADER to aligned BITMAPINFO.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = READDWORD(&pbmihFile->biWidth);
        pbmiSource->bmiHeader.biHeight        = READDWORD(&pbmihFile->biHeight);
        pbmiSource->bmiHeader.biPlanes        = pbmihFile->biPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmihFile->biBitCount;
        pbmiSource->bmiHeader.biCompression   = 
                                        READDWORD(&pbmihFile->biCompression);
        pbmiSource->bmiHeader.biSizeImage     = 
                                        READDWORD(&pbmihFile->biSizeImage);
        pbmiSource->bmiHeader.biXPelsPerMeter = 
                                        READDWORD(&pbmihFile->biXPelsPerMeter);
        pbmiSource->bmiHeader.biYPelsPerMeter = 
                                        READDWORD(&pbmihFile->biYPelsPerMeter);
        pbmiSource->bmiHeader.biClrUsed       = 
                                        READDWORD(&pbmihFile->biClrUsed);
        pbmiSource->bmiHeader.biClrImportant  = 
                                        READDWORD(&pbmihFile->biClrImportant);

    // Copy color table.  It immediately follows the BITMAPINFOHEADER.

        memcpy((PVOID) &pbmiSource->bmiColors[0], (PVOID) (pbmihFile + 1),
               wNumColors * sizeof(RGBQUAD));

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBits)
            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBQUAD));
        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        pbmiSource->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmiSource->bmiHeader.biWidth         = (DWORD) pbmchFile->bcWidth;
        pbmiSource->bmiHeader.biHeight        = (DWORD) pbmchFile->bcHeight;
        pbmiSource->bmiHeader.biPlanes        = pbmchFile->bcPlanes;
        pbmiSource->bmiHeader.biBitCount      = pbmchFile->bcBitCount;
        pbmiSource->bmiHeader.biCompression   = BI_RGB;
        pbmiSource->bmiHeader.biSizeImage     = 0;
        pbmiSource->bmiHeader.biXPelsPerMeter = 0;
        pbmiSource->bmiHeader.biYPelsPerMeter = 0;
        pbmiSource->bmiHeader.biClrUsed       = wNumColors;
        pbmiSource->bmiHeader.biClrImportant  = wNumColors;

    // Convert RGBTRIPLE color table into RGBQUAD color table.

        {
            RGBQUAD *rgb4 = pbmiSource->bmiColors;
            RGBTRIPLE *rgb3 = (RGBTRIPLE *) (pbmchFile + 1);

            for (i = 0; i < wNumColors; i++)
            {
                rgb4->rgbRed   = rgb3->rgbtRed  ;
                rgb4->rgbGreen = rgb3->rgbtGreen;
                rgb4->rgbBlue  = rgb3->rgbtBlue ;
                rgb4->rgbReserved = 0;

                rgb4++;
                rgb3++;
            }
        }

    // If we haven't already determined the position of the image bits,
    // we may now assume that they immediately follow the color table.

        if (!pvBits)
            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1)
                         + wNumColors * sizeof(RGBTRIPLE));
        break;

    default:
        MESSAGEBOX(GetFocus(), "Unknown DIB file format.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Fill in default values (for fields that can have defaults).

    if (pbmiSource->bmiHeader.biSizeImage == 0)
        pbmiSource->bmiHeader.biSizeImage = 
            BITS2BYTES( (DWORD) pbmiSource->bmiHeader.biWidth * 
                                pbmiSource->bmiHeader.biBitCount ) * 
                                pbmiSource->bmiHeader.biHeight;
    if (pbmiSource->bmiHeader.biClrUsed == 0)
        pbmiSource->bmiHeader.biClrUsed = wNumColors;

// Create memory DC.

    hdcMem = CreateCompatibleDC(NULL);
    if (!hdcMem) {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Create a 24BPP RGB DIB section and select it into the memory DC.

    pbmiRGB = (BITMAPINFO *)
              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) );
    if (!pbmiRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pbmiRGB->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmiRGB->bmiHeader.biWidth         = pbmiSource->bmiHeader.biWidth;
    pbmiRGB->bmiHeader.biHeight        = pbmiSource->bmiHeader.biHeight;
    pbmiRGB->bmiHeader.biPlanes        = 1;
    pbmiRGB->bmiHeader.biBitCount      = 24;
    pbmiRGB->bmiHeader.biCompression   = BI_RGB;
    pbmiRGB->bmiHeader.biSizeImage     = pbmiRGB->bmiHeader.biWidth
                                         * abs(pbmiRGB->bmiHeader.biHeight) * 3;

    hbmRGB = CreateDIBSection(hdcMem, pbmiRGB, DIB_RGB_COLORS, 
                              (PVOID *) &pjBitsRGB, NULL, 0);

    if (!hbmRGB)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); 
        goto tkDIBLoadImage_cleanup;
    }

    if (!SelectObject(hdcMem, hbmRGB))
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

// Slam the DIB file image into the memory DC.  GDI will do the work of
// translating whatever format the DIB file has into RGB format.

    if (!SetDIBits(hdcMem, hbmRGB, 0, pbmiSource->bmiHeader.biHeight, 
                   pvBits, pbmiSource, DIB_RGB_COLORS))
    {
        MESSAGEBOX(GetFocus(), "Image file conversion error.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }
    GdiFlush();     // make sure that SetDIBits executes

// Convert to TK image format (packed RGB format).
// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app
// can deallocate with free()).

    pjTKBits = (PBYTE) malloc(pbmiRGB->bmiHeader.biSizeImage);
    if (!pjTKBits)
    {
        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);
        goto tkDIBLoadImage_cleanup;
    }

    pjSrc = pjBitsRGB;
    pjDst = pjTKBits;
    // src lines end on LONG boundary - so need to skip over any padding bytes
    padBytes = pbmiSource->bmiHeader.biWidth % sizeof(LONG);
    for (i = 0; i < pbmiSource->bmiHeader.biHeight; i++)
    {
        for (j = 0; j < pbmiSource->bmiHeader.biWidth; j++)
        {
            // swap R and B
            *pjDst++ = pjSrc[2];
            *pjDst++ = pjSrc[1];
            *pjDst++ = pjSrc[0];
            pjSrc += 3;
        }
        pjSrc += padBytes;
    }

// Initialize the texture structure

    // If we get to here, we have suceeded!
    ptex->width = pbmiSource->bmiHeader.biWidth;
    ptex->height = pbmiSource->bmiHeader.biHeight;
    ptex->format = GL_RGB;
    ptex->components = 3;
    ptex->data = pjTKBits;
    ptex->pal_size = 0;
    ptex->pal = NULL;

    fSuccess = TRUE;
    
// Cleanup objects.

tkDIBLoadImage_cleanup:
    {
        if (hdcMem)
            DeleteDC(hdcMem);

        if (hbmRGB)
            DeleteObject(hbmRGB);

        if (pbmiRGB)
            LocalFree(pbmiRGB);

        if (pbmiSource)
            LocalFree(pbmiSource);
    }

// Check for error.

    if (!fSuccess)
    {
        if (pjTKBits)
            free(pjTKBits);
    }

    return fSuccess;
}

/******************************Public*Routine******************************\
*
* bVerifyDIB
*
* Stripped down version of tkDIBImageLoadAW that verifies that a bitmap
* file is valid and, if so, returns the bitmap dimensions.
*
* Returns:
*   TRUE if valid bitmap file; otherwise, FALSE.
*
\**************************************************************************/

BOOL 
bVerifyDIB(LPTSTR pszFileName, ISIZE *pSize )
{
    BOOL bRet = FALSE;
    BITMAPFILEHEADER *pbmf;         // Ptr to file header
    BITMAPINFOHEADER *pbmihFile;    // Ptr to file's info header (if it exists)
    BITMAPCOREHEADER *pbmchFile;    // Ptr to file's core header (if it exists)

    // These need to be cleaned up when we exit:
    HANDLE     hFile = INVALID_HANDLE_VALUE;        // File handle
    HANDLE     hMap = (HANDLE) NULL;                // Mapping object handle
    PVOID      pvFile = (PVOID) NULL;               // Ptr to mapped file

// Map the DIB file into memory.

    hFile = CreateFile((LPTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (hFile == INVALID_HANDLE_VALUE)
        goto bVerifyDIB_cleanup;

    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!hMap)
        goto bVerifyDIB_cleanup;

    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
    if (!pvFile)
        goto bVerifyDIB_cleanup;

// Check the file header.  If the BFT_BITMAP magic number is there,
// then the file format is a BITMAPFILEHEADER followed immediately
// by either a BITMAPINFOHEADER or a BITMAPCOREHEADER.  The bitmap
// bits, in this case, are located at the offset bfOffBits from the
// BITMAPFILEHEADER.
//
// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER
// followed immediately with the color table and the bitmap bits.

    pbmf = (BITMAPFILEHEADER *) pvFile;

    if ( pbmf->bfType == BFT_BITMAP )
        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER);
    else
        pbmihFile = (BITMAPINFOHEADER *) pvFile;

// Get the width and height from whatever header we have.
//
// We distinguish between BITMAPINFO and BITMAPCORE cases based upon
// BITMAPINFOHEADER.biSize.

    // Note: need to use safe READDWORD macro because pbmihFile may
    // have only WORD alignment if it follows a BITMAPFILEHEADER.

    switch (READDWORD(&pbmihFile->biSize))
    {
    case sizeof(BITMAPINFOHEADER):

        if( pSize != NULL ) {
            pSize->width  = READDWORD(&pbmihFile->biWidth);
            pSize->height = READDWORD(&pbmihFile->biHeight);
        }
        bRet = TRUE;

        break;

    case sizeof(BITMAPCOREHEADER):
        pbmchFile = (BITMAPCOREHEADER *) pbmihFile;

    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER.

        if( pSize != NULL ) {
            pSize->width  = (DWORD) pbmchFile->bcWidth;
            pSize->height = (DWORD) pbmchFile->bcHeight;
        }
        bRet = TRUE;

        break;

    default:
        break;
    }

bVerifyDIB_cleanup:

    if (pvFile)
        UnmapViewOfFile(pvFile);

    if (hMap)
        CloseHandle(hMap);

    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\ssimage.c ===
/******************************Module*Header*******************************\
* Module Name: ssimage.c
*
* Operations on .rgb files
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"
#include "sscommon.h"

#define IMAGIC      0x01da
#define IMAGIC_SWAP 0xda01

#define SWAP_SHORT_BYTES(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
#define SWAP_LONG_BYTES(x) (((((x) & 0xff) << 24) | (((x) & 0xff00) << 8)) | \
                            ((((x) & 0xff0000) >> 8) | (((x) & 0xff000000) >> 24)))

typedef struct _rawImageRec {
    unsigned short imagic;
    unsigned short type;
    unsigned short dim;
    unsigned short sizeX, sizeY, sizeZ;
    unsigned long min, max;
    unsigned long wasteBytes;
    char name[80];
    unsigned long colorMap;
    HANDLE file;
    unsigned char *tmp, *tmpR, *tmpG, *tmpB;
    unsigned long rleEnd;
    unsigned long *rowStart;
    long *rowSize;
    // !!! Hack to stick in a pointer to the resource data - shouldn't be
    // a problem, since rgb files always have 512 byte header
    unsigned char *data;
} rawImageRec;

static void RawImageClose(rawImageRec *raw);

/**************************************************************************\
*
* Hacked form of tk_RGBImageLoad(), for reading a .rgb file from a resource
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
static rawImageRec *RawImageOpen( PVOID pv )
{
    rawImageRec *raw;
    unsigned long *rowStart, *rowSize, ulTmp;
    int x;
    DWORD dwBytesRead;

    raw = (rawImageRec *)malloc(sizeof(rawImageRec));
    if (raw == NULL) {
        return 0;
    }

    // Make a copy of the resource header, since we may be doing some byte
    // swapping, and resources are read-only
    *raw = *((rawImageRec *) pv);

    if (raw->imagic == IMAGIC_SWAP) {
        raw->type = SWAP_SHORT_BYTES(raw->type);
        raw->dim = SWAP_SHORT_BYTES(raw->dim);
        raw->sizeX = SWAP_SHORT_BYTES(raw->sizeX);
        raw->sizeY = SWAP_SHORT_BYTES(raw->sizeY);
        raw->sizeZ = SWAP_SHORT_BYTES(raw->sizeZ);
    }

    raw->tmp = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpR = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpG = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpB = (unsigned char *)malloc(raw->sizeX*256);
    if (raw->tmp == NULL || raw->tmpR == NULL || raw->tmpG == NULL ||
        raw->tmpB == NULL) {
        RawImageClose(raw);
        return 0;
    }

    if ((raw->type & 0xFF00) == 0x0100) {
        x = raw->sizeY * raw->sizeZ * sizeof(long);
        raw->rowStart = (unsigned long *)malloc(x);
        raw->rowSize = (long *)malloc(x);
        if (raw->rowStart == NULL || raw->rowSize == NULL) {
            RawImageClose(raw);
            return 0;
        }
//mf: not used (?)
        raw->rleEnd = 512 + (2 * x);

        //mf: hack to point to resource data
        raw->data = ((unsigned char *) pv);
        RtlCopyMemory( raw->rowStart, raw->data + 512, x );
        RtlCopyMemory( raw->rowSize, raw->data + 512 + x, x );

        if (raw->imagic == IMAGIC_SWAP) {
            x /= sizeof(long);
            rowStart = raw->rowStart;
            rowSize = (unsigned long *) raw->rowSize;
            while (x--) {
                ulTmp = *rowStart;
                *rowStart++ = SWAP_LONG_BYTES(ulTmp);
                ulTmp = *rowSize;
                *rowSize++ = SWAP_LONG_BYTES(ulTmp);
            }
        }
    }
    return raw;
}

static void RawImageClose(rawImageRec *raw)
{
    if( !raw )
        return;
    if( raw->tmp ) free(raw->tmp);
    if( raw->tmpR ) free(raw->tmpR);
    if( raw->tmpG ) free(raw->tmpG);
    if( raw->tmpB ) free(raw->tmpB);
    free(raw);
}

static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
{
    unsigned char *iPtr, *oPtr, pixel;
    int count;
    DWORD dwBytesRead;

    if ((raw->type & 0xFF00) == 0x0100) {
        RtlCopyMemory(raw->tmp, raw->data + raw->rowStart[y+z*raw->sizeY],
                 (unsigned int)raw->rowSize[y+z*raw->sizeY] );
        iPtr = raw->tmp;
        oPtr = buf;
        while (1) {
            pixel = *iPtr++;
            count = (int)(pixel & 0x7F);
            if (!count) {
                return;
            }
            if (pixel & 0x80) {
                while (count--) {
                    *oPtr++ = *iPtr++;
                }
            } else {
                pixel = *iPtr++;
                while (count--) {
                    *oPtr++ = pixel;
                }
            }
        }
    } else {
        iPtr = raw->data + 512 + (y*raw->sizeX)+(z*raw->sizeX*raw->sizeY);
        RtlCopyMemory( buf, iPtr, raw->sizeX );
    }
}

static void RawImageGetData(rawImageRec *raw, TEXTURE *ptex)
{
    unsigned char *ptr;
    int i, j;

    ptex->data = (unsigned char *)malloc((raw->sizeX+1)*(raw->sizeY+1)*4);
    if (ptex->data == NULL) {
        return;
    }

    ptr = ptex->data;
    for (i = 0; i < raw->sizeY; i++) {
        RawImageGetRow(raw, raw->tmpR, i, 0);
        RawImageGetRow(raw, raw->tmpG, i, 1);
        RawImageGetRow(raw, raw->tmpB, i, 2);
        for (j = 0; j < raw->sizeX; j++) {
            *ptr++ = *(raw->tmpR + j);
            *ptr++ = *(raw->tmpG + j);
            *ptr++ = *(raw->tmpB + j);
        }
    }
}

BOOL ss_RGBImageLoad( PVOID pv, TEXTURE *ptex )
{
    rawImageRec *raw;

    if( !(raw = RawImageOpen( pv )) )
        return FALSE;
    
    ptex->width = raw->sizeX;
    ptex->height = raw->sizeY;
    ptex->format = GL_RGB;
    ptex->components = 3;
    ptex->pal_size = 0;
    ptex->pal = NULL;
    RawImageGetData(raw, ptex);
    RawImageClose(raw);
    return TRUE;
}

/******************************Public*Routine******************************\
*
* bVerifyRGB
*
* Stripped down version of tkRGBImageLoadAW that verifies that an rgb
* file is valid and, if so, returns the bitmap dimensions.
*
* Returns:
*   TRUE if valid rgb file; otherwise, FALSE.
*
\**************************************************************************/

BOOL 
bVerifyRGB(LPTSTR pszFileName, ISIZE *pSize )
{
    rawImageRec *raw;
    DWORD dwBytesRead;
    BOOL bRet = FALSE;

    raw = (rawImageRec *) 
          LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof(rawImageRec) );

    if (raw == NULL) {
        return FALSE;
    }

    raw->file = CreateFile((LPTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, 0, 0);

    if (raw->file == INVALID_HANDLE_VALUE) {
        goto bVerifyRGB_cleanup;
    }

    ReadFile(raw->file, (LPVOID) raw, 12, &dwBytesRead, (LPOVERLAPPED) NULL);

    if( raw->imagic == IMAGIC_SWAP ) {
        raw->sizeX = SWAP_SHORT_BYTES(raw->sizeX);
        raw->sizeY = SWAP_SHORT_BYTES(raw->sizeY);
        bRet = TRUE;
    } else if( raw->imagic == IMAGIC)
        bRet = TRUE;

bVerifyRGB_cleanup:

    if( bRet && pSize ) {
        pSize->width = raw->sizeX;
        pSize->height = raw->sizeY;
    }
        
    if( raw->file != INVALID_HANDLE_VALUE )
        CloseHandle( raw->file );

    LocalFree( raw );

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\ssdebug.h ===
/******************************Module*Header*******************************\
* Module Name: ssdebug.h
*
* Debugging stuff
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef __ssdebug_h__
#define __ssdebug_h__

ULONG DbgPrint(PCH Format, ...);

#define SS_LEVEL_ERROR 1L
#define SS_LEVEL_INFO  2L
#define SS_LEVEL_ENTRY 8L

#if DBG

extern long ssDebugMsg;
extern long ssDebugLevel;

#define SS_DBGPRINT( str )          DbgPrint("SS: " str )
#define SS_DBGPRINT1( str, a )      DbgPrint("SS: " str, a )
#define SS_DBGPRINT2( str, a, b )   DbgPrint("SS: " str, a, b )

#define SS_WARNING(str)             DbgPrint("SS: " str )
#define SS_WARNING1(str,a)          DbgPrint("SS: " str,a)
#define SS_WARNING2(str,a,b)        DbgPrint("SS: " str,a,b)

#define SS_RIP(str)                 {SS_WARNING(str); DebugBreak();}
#define SS_RIP1(str,a)              {SS_WARNING1(str,a); DebugBreak();}
#define SS_RIP2(str,a,b)            {SS_WARNING2(str,a,b); DebugBreak();}

#define SS_ASSERT(expr,str)            if(!(expr)) SS_RIP(str)
#define SS_ASSERT1(expr,str,a)         if(!(expr)) SS_RIP1(str,a)
#define SS_ASSERT2(expr,str,a,b)       if(!(expr)) SS_RIP2(str,a,b)

#define SS_ALLOC_FAILURE(str) \
    DbgPrint( "%s : Memory allocation failure\n", str );

#define SS_DBGMSG( str )         if( ssDebugMsg ) SS_DBGPRINT( str )
#define SS_DBGMSG1( str, a )     if( ssDebugMsg ) SS_DBGPRINT1( str, a )
#define SS_DBGMSG2( str, a, b )  if( ssDebugMsg ) SS_DBGPRINT2( str, a, b )

//
// Use SS_DBGLEVEL for general purpose debug messages gated by an
// arbitrary warning level.
//
#define SS_DBGLEVEL(n,str)         if (ssDebugLevel >= (n)) SS_DBGPRINT(str)
#define SS_DBGLEVEL1(n,str,a)      if (ssDebugLevel >= (n)) SS_DBGPRINT1(str,a)
#define SS_DBGLEVEL2(n,str,a,b)    if (ssDebugLevel >= (n)) SS_DBGPRINT2(str,a,b)    

#define SS_ERROR(str)              SS_DBGLEVEL( SS_LEVEL_ERROR, str ) 
#define SS_ERROR1(str,a)           SS_DBGLEVEL1( SS_LEVEL_ERROR, str, a ) 
#define SS_ERROR2(str,a)           SS_DBGLEVEL2( SS_LEVEL_ERROR, str, a, b ) 

#define SS_DBGINFO(str)            SS_DBGLEVEL( SS_LEVEL_INFO, str ) 
#define SS_DBGINFO1(str,a)         SS_DBGLEVEL1( SS_LEVEL_INFO, str, a ) 
#define SS_DBGINFO2(str,a,b)       SS_DBGLEVEL2( SS_LEVEL_INFO, str, a, b ) 

#else

#define SS_DBGPRINT( str )
#define SS_DBGPRINT1( str, a )
#define SS_DBGPRINT2( str, a, b )

#define SS_WARNING(str)
#define SS_WARNING1(str,a)
#define SS_WARNING2(str,a,b)

#define SS_RIP(str)
#define SS_RIP1(str,a)
#define SS_RIP2(str,a,b)

#define SS_ASSERT(expr,str)         assert( expr )
#define SS_ASSERT1(expr,str,a)      assert( expr )
#define SS_ASSERT2(expr,str,a,b)    assert( expr )

#define SS_ALLOC_FAILURE(str)

#define SS_DBGMSG( str )
#define SS_DBGMSG1( str, a )
#define SS_DBGMSG2( str, a, b )

#define SS_DBGLEVEL(n,str)
#define SS_DBGLEVEL1(n,str,a)
#define SS_DBGLEVEL2(n,str,a,b)

#define SS_ERROR(str)
#define SS_ERROR1(str,a)
#define SS_ERROR2(str,a,b)

#define SS_DBGINFO(str)
#define SS_DBGINFO1(str,a)
#define SS_DBGINFO2(str,a,b)

#endif // DBG

#endif // __ssdebug_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\ssa8.c ===
/******************************Module*Header*******************************\
* Module Name: ssa8.c
*
* Operations on .a8 files
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "tk.h"
#include "sscommon.h"

#define ESCAPE 0
#define ESC_ENDLINE 0
#define ESC_ENDBITMAP 1
#define ESC_DELTA 2
#define ESC_RANDOM 3
#define RANDOM_COUNT(c) ((c)-(ESC_RANDOM-1))

#define COUNT_SIZE 256
#define MAXRUN (COUNT_SIZE-1)
#define MAXRND (RANDOM_COUNT(COUNT_SIZE)-1)

typedef unsigned char *HwMem;
typedef unsigned long HwMemSize;
#define HW_UNALIGNED UNALIGNED

static HwMemSize HwuRld(HwMem src, HwMem dest, HwMemSize stride)
{
    unsigned short code;
    unsigned char run, esc;
    size_t len;
    HwMem s;
    HwMem f;

    s = src;
    f = dest;
    for (;;)
    {
        code = *((unsigned short HW_UNALIGNED *)s)++;
        run = code & 0xff;
        esc = code >> 8;
        if (run == ESCAPE)
        {
            if (esc == ESC_ENDBITMAP)
            {
                break;
            }
            else if (esc == ESC_DELTA)
            {
                len = *((unsigned short HW_UNALIGNED *)s)++;
                while (len-- > 0)
                {
                    *f = 0;
                    f += stride;
                }
            }
            else if (esc >= ESC_RANDOM)
            {
                len = RANDOM_COUNT(esc);
                while (len-- > 0)
                {
                    *f = *s++;
                    f += stride;
                }
            }
        }
        else
        {
            while (run-- > 0)
            {
                *f = esc;
                f += stride;
            }
        }
    }
    
    return (HwMemSize)((ULONG_PTR)(s-src));
}

static HwMemSize HwuRldTo32(HwMem src, HwMem dest, HwMemSize stride,
                            DWORD *translate)
{
    unsigned short code;
    unsigned char run, esc;
    size_t len;
    HwMem s;
    DWORD *f, tran;

    s = src;
    f = (DWORD *)dest;
    for (;;)
    {
        code = *((unsigned short HW_UNALIGNED *)s)++;
        run = code & 0xff;
        esc = code >> 8;
        if (run == ESCAPE)
        {
            if (esc == ESC_ENDBITMAP)
            {
                break;
            }
            else if (esc == ESC_DELTA)
            {
                len = *((unsigned short HW_UNALIGNED *)s)++;
                while (len-- > 0)
                {
                    *f = translate[0];
                    f += stride;
                }
            }
            else if (esc >= ESC_RANDOM)
            {
                len = RANDOM_COUNT(esc);
                while (len-- > 0)
                {
                    *f = translate[*s++];
                    f += stride;
                }
            }
        }
        else
        {
            tran = translate[esc];
            while (run-- > 0)
            {
                *f = tran;
                f += stride;
            }
        }
    }
    
    return (HwMemSize)((ULONG_PTR)(s-src));
}

#define ALPHA_SIGNATURE 0xa0a1a2a3
#define COMPRESS_NONE 0
#define COMPRESS_RLE  1

BOOL ss_A8ImageLoad(void *pvResource, TEXTURE *ptex)
{
    DWORD compress;
    DWORD size;
    DWORD *pal;
    BYTE *buf;
    DWORD *pdwA8;

    pdwA8 = (DWORD *)pvResource;

    // Check data signature for alpha texture format
    if (*pdwA8 != ALPHA_SIGNATURE)
    {
        return FALSE;
    }
    pdwA8++;

    ptex->width = *pdwA8++;
    ptex->height = *pdwA8++;

    // Make sure depth is 8bpp
    if (*pdwA8 != 8)
    {
        return FALSE;
    }
    pdwA8++;
    
    size = ptex->width*ptex->height;

    // Compression type
    compress = *pdwA8++;
    // Compressed data size only if compressed, not used
    pdwA8++;

    // Remember pointer to palette data
    pal = pdwA8;
    pdwA8 += 256;

    if (ss_PalettedTextureEnabled())
    {
        // Allocate data for final image
        ptex->data = malloc(size);
        if (ptex->data == NULL)
        {
            return FALSE;
        }
    
        ptex->pal_size = 256;
        ptex->pal = malloc(ptex->pal_size*sizeof(RGBQUAD));
        if (ptex->pal == NULL)
        {
            free(ptex->data);
            return FALSE;
        }
        memcpy(ptex->pal, pal, ptex->pal_size*sizeof(RGBQUAD));

        // Unpack 8bpp data into final image
        if (compress == COMPRESS_NONE)
        {
            memcpy(ptex->data, pdwA8, size);
        }
        else
        {
            HwuRld((HwMem)pdwA8, ptex->data, 1);
        }

        ptex->format = GL_COLOR_INDEX;
        ptex->components = GL_COLOR_INDEX8_EXT;
    }
    else
    {
        // Allocate data for final image
        ptex->data = malloc(size*sizeof(DWORD));
        if (ptex->data == NULL)
        {
            return FALSE;
        }
    
        ptex->pal_size = 0;
        ptex->pal = NULL;

        // Unpack 8bpp data into final image
        if (compress == COMPRESS_NONE)
        {
            DWORD i;
            BYTE *src;
            DWORD *dst;

            src = (BYTE *)pdwA8;
            dst = (DWORD *)ptex->data;
            for (i = 0; i < size; i++)
            {
                *dst++ = pal[*src++];
            }
        }
        else
        {
            HwuRldTo32((HwMem)pdwA8, ptex->data, 1, pal);
        }

        ptex->format = GL_BGRA_EXT;
        ptex->components = 4;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\ssinit.cxx ===
/******************************Module*Header*******************************\
* Module Name: ssinit.cxx
*
* Main code for common screen saver functions.
*
* Created: 12-24-94 -by- Marc Fortier [marcfo]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#include <windows.h>
#include <commdlg.h>
#include <scrnsave.h>
#include <GL\gl.h>
#include "tk.h"
#include <math.h>
#include <memory.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include "ssintrnl.hxx"

void     *gDataPtr = NULL; // data ptr used with callbacks

// function protos
void (*gReshapeFunc)(int, int, void *)      = NULL;
void (*gRepaintFunc)(LPRECT, void *)      = NULL;
void (*gUpdateFunc)( void *)           = NULL;
void (*gInitFunc)( void *)             = NULL;
void (*gFinishFunc)( void *)           = NULL;
void (*gFloaterBounceFunc)( void *)      = NULL;

// Debug stuff
#if DBG
#ifdef SS_DEBUG
long ssDebugMsg = 1;
long ssDebugLevel = SS_LEVEL_INFO;
#else
long ssDebugMsg = 0;
long ssDebugLevel = SS_LEVEL_ERROR;
#endif
#endif

// Callback functions:

/******************************Public*Routine******************************\
* ss_InitFunc
*
\**************************************************************************/

void 
ss_InitFunc(SSINITPROC Func)
{
    gInitFunc = Func;
}

/******************************Public*Routine******************************\
* ss_ReshapeFunc
*
\**************************************************************************/

void 
ss_ReshapeFunc(SSRESHAPEPROC Func)
{
    gReshapeFunc = Func;
    if( gpss->psswGL )
        gpss->psswGL->ReshapeFunc = gReshapeFunc;
}

/******************************Public*Routine******************************\
* ss_RepaintFunc
*
\**************************************************************************/

void 
ss_RepaintFunc(SSREPAINTPROC Func)
{
    gRepaintFunc = Func;
    if( gpss->psswGL )
        gpss->psswGL->RepaintFunc = gRepaintFunc;
}

/******************************Public*Routine******************************\
* ss_UpdateFunc
*
\**************************************************************************/

void 
ss_UpdateFunc(SSUPDATEPROC Func)
{
    gUpdateFunc = Func;
    if( gpss->psswGL )
        gpss->psswGL->UpdateFunc = gUpdateFunc;
}

/******************************Public*Routine******************************\
* ss_FinishFunc
*
\**************************************************************************/

void 
ss_FinishFunc(SSFINISHPROC Func)
{
    gFinishFunc = Func;
    if( gpss->psswGL )
        gpss->psswGL->FinishFunc = gFinishFunc;
}

/******************************Public*Routine******************************\
* ss_FloaterBounceFunc
*
\**************************************************************************/

void 
ss_FloaterBounceFunc(SSFLOATERBOUNCEPROC Func)
{
    gFloaterBounceFunc = Func;
    if( gpss->psswGL )
        gpss->psswGL->FloaterBounceFunc = gFloaterBounceFunc;
}

/******************************Public*Routine******************************\
* ss_DataPtr
*
* Sets data ptr to be sent with callbacks
*
\**************************************************************************/

void 
ss_DataPtr( void *data )
{
    gDataPtr = data;
    if( gpss->psswGL )
        gpss->psswGL->DataPtr = gDataPtr;
}

/******************************Public*Routine******************************\
* RandomWindowPos
*
* Sets a new random window position and direction.
*
\**************************************************************************/

void 
ss_RandomWindowPos()
{
    if( gpss->psswGL )
        gpss->psswGL->RandomWindowPos();
}

/******************************Public*Routine******************************\
* ss_SetWindowAspectRatio
*
* Resize the window to conform to the supplied aspect ratio.  We do this by
* maintaining the existing width, and adjusting the height.
*
* Window resize seems to be executed synchronously, so gl should be able to
* immediately validate its buffer dimensions (we count on it).
*
* Returns TRUE if new height is different from last, else FALSE.
\**************************************************************************/

BOOL 
ss_SetWindowAspectRatio( FLOAT aspect )
{
    if( gpss->psswGL )
        return gpss->psswGL->SetAspectRatio( aspect );
    return FALSE;
}

/******************************Public*Routine******************************\
* ss_GetScreenSize
*
* Returns size of screen saver window
*
\**************************************************************************/

void
ss_GetScreenSize( ISIZE *size )
{
    if( gpss->psswMain )
        *size = gpss->psswMain->size;
}

/******************************Public*Routine******************************\
* ss_GetHWND
*
* Return HWND of the main window
\**************************************************************************/

HWND 
ss_GetHWND()
{
    if( gpss->psswMain )
        return gpss->psswMain->hwnd;
    return NULL;
}

/******************************Public*Routine******************************\
* ss_GetGLHWND
*
* Return HWND of the GL window
\**************************************************************************/

HWND 
ss_GetGLHWND()
{
    if( gpss->psswGL )
        return gpss->psswGL->hwnd;
    return NULL;
}

/******************************Public*Routine******************************\
* ss_GetMainPSSW
*
* Return PSSW of top level window
\**************************************************************************/

PSSW
ss_GetMainPSSW()
{
    if( gpss->psswMain )
        return gpss->psswMain;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\sscommon.h ===
/******************************Module*Header*******************************\
* Module Name: sscommon.h
*
* Defines and externals for screen saver common shell
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef __sscommon_h__
#define __sscommon_h__

#include <GL\gl.h>
#include <assert.h>
#include "tk.h"
#include "matname.h"  // material names

#ifdef __cplusplus
extern "C" {
#endif

#include "ssdebug.h"

#define FAILURE             0
#define SUCCESS             1

// Maximum texture bitmap dimensions.

#define TEX_WIDTH_MAX   1280
#define TEX_HEIGHT_MAX  1024

#define PI 3.14159265358979323846f
// double version of PI
#define PI_D 3.14159265358979323846264338327950288419716939937510
#define ONE_OVER_PI (1.0f / PI)
#define ROOT_TWO 1.414213562373f

#define GEN_STRING_SIZE 64

// texture quality level
enum {
    TEXQUAL_DEFAULT = 0,
    TEXQUAL_HIGH
};

typedef struct _point2d {
    GLfloat x;
    GLfloat y;
} POINT2D;

typedef struct _ipoint2d {
    int x;
    int y;
} IPOINT2D;

typedef struct _point3d {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} POINT3D;

typedef struct _ipoint3d {
    int x;
    int y;
    int z;
} IPOINT3D;

typedef struct _texpoint2d {
    GLfloat s;
    GLfloat t;
} TEX_POINT2D;

typedef struct _isize {
    int width;
    int height;
} ISIZE;

typedef struct _fsize {
    GLfloat width;
    GLfloat height;
} FSIZE;

typedef struct _glrect {
    int x, y;
    int width, height;
} GLRECT;

// texture data
typedef struct {
    int     width;
    int     height;
    GLenum  format;
    GLsizei components;
    float   origAspectRatio; // original width/height aspect ratio
    unsigned char *data;
    GLuint  texObj;          // texture object
    int     pal_size;
    int     iPalRot;         // current palette rotation (not used yet)
    RGBQUAD *pal;
} TEXTURE, *HTEXTURE;

#ifndef GL_EXT_paletted_texture
#define GL_COLOR_INDEX1_EXT                   0x80E2
#define GL_COLOR_INDEX2_EXT                   0x80E3
#define GL_COLOR_INDEX4_EXT                   0x80E4
#define GL_COLOR_INDEX8_EXT                   0x80E5
#define GL_COLOR_INDEX12_EXT                  0x80E6
#define GL_COLOR_INDEX16_EXT                  0x80E7
typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, GLvoid *data);
#endif

// texture resource

#define RT_RGB          99
#define RT_MYBMP        100
#define RT_A8           101

// texture resource types
enum {
    TEX_UNKNOWN = 0,
    TEX_RGB,
    TEX_BMP,
    TEX_A8
};

typedef struct {
    int     type;
    int     name;
} TEX_RES;

typedef struct _MATRIX {
    GLfloat M[4][4];
} MATRIX;

typedef struct strRGBA {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
} RGBA;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
} RGB8;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
    BYTE a;
} RGBA8;

// DlgDraw

enum {
    DLG_INTENSITY_LOW = 0,
    DLG_INTENSITY_MID,
    DLG_INTENSITY_HIGH,
};

// Callback function defines
typedef void (CALLBACK* SSINITPROC)( void *);
typedef void (CALLBACK* SSRESHAPEPROC)(int, int, void *);
typedef void (CALLBACK* SSREPAINTPROC)( LPRECT, void *);
typedef void (CALLBACK* SSUPDATEPROC)( void *);
typedef void (CALLBACK* SSFINISHPROC)( void *);
typedef void (CALLBACK* SSFLOATERFAILPROC)(void *);
typedef void (CALLBACK* SSFLOATERBOUNCEPROC)( void *);

// Defines for pixel format (internal use)
#define SS_DOUBLEBUF_BIT    (1 << 0)
#define SS_DEPTH16_BIT      (1 << 1)
#define SS_DEPTH32_BIT      (1 << 2)
#define SS_ALPHA_BIT        (1 << 3)
#define SS_BITMAP_BIT       (1 << 4)
#define SS_NO_SYSTEM_PALETTE_BIT       (1 << 5)
#define SS_GENERIC_UNACCELERATED_BIT   (1 << 6)

#define SS_HAS_DOUBLEBUF(x) ((x) & SS_DOUBLEBUF_BIT)
#define SS_HAS_DEPTH16(x)	((x) & SS_DEPTH16_BIT)
#define SS_HAS_DEPTH32(x)	((x) & SS_DEPTH32_BIT)
#define SS_HAS_ALPHA(x)     ((x) & SS_ALPHA_BIT)
#define SS_HAS_BITMAP(x)    ((x) & SS_BITMAP_BIT)

// Depth types
enum {
    SS_DEPTH_NONE = 0,
    SS_DEPTH16,
    SS_DEPTH32,
};

// ss context structures

// Note: all *_INFO structures are requests between common and client ss

typedef struct {
    POINT2D    posInc;          // base position increment
    POINT2D    posIncVary;      // +/- variation for posInc on bounce
} MOTION_INFO;

// internal motion structure
typedef struct {
    POINT2D    pos;             // position
    POINT2D    posInc;          // base position increment
    POINT2D    posIncVary;      // +/- variation for posInc on bounce
    POINT2D    posIncCur;       // Current position increment
} MOTION;

// Size and motion attributes of the OpenGL window that floats around.
typedef struct {
    ISIZE      size;
    IPOINT2D    pos;             // position
    MOTION_INFO     motionInfo;
} CHILD_INFO;

typedef void (CALLBACK* SSCHILDSIZEPROC)( ISIZE *, CHILD_INFO * );

// Size and motion attributes of the OpenGL window that floats around.
typedef struct {
    BOOL       bMotion;         // if floater should move or not
    BOOL       bSubWindow;      // If floater is logical sub-window
    SSCHILDSIZEPROC   ChildSizeFunc; // Callback to set size based on parent
} FLOATER_INFO;


// SS_BITMAP already defined in winuser.h
#if defined( SS_BITMAP )
#undef SS_BITMAP
#endif

typedef struct {
    HDC     hdc;
    ISIZE   size;
    HBITMAP hbm;
    HBITMAP hbmOld; // ? necessary ?
} SS_BITMAP;


// Attributes for StretchBlt mode
typedef struct {
    BOOL       bRatioMode;      // use ratio or base width
    float      widthRatio;      // e.g. 2 means use base of (window width / 2)
    float      heightRatio;
    int        baseWidth;
    int        baseHeight;
    SS_BITMAP  ssbm;
} STRETCH_INFO;


typedef struct {
    BOOL bFloater;
    FLOATER_INFO floaterInfo;
    BOOL bStretch;
    STRETCH_INFO stretchInfo;
    BOOL bDoubleBuf;
    int  depthType;
} SSContext, SSC, *PSSC;

typedef struct _MATERIAL {
    RGBA ka;
    RGBA kd;
    RGBA ks;
    GLfloat specExp;
} MATERIAL;

// texture file info

typedef struct {
    int     nOffset;  // filename offset into pathname
    TCHAR   szPathName[MAX_PATH];  // texture pathname
} TEXFILE;

// texture file processing messages

typedef struct {
    TCHAR   szWarningMsg[MAX_PATH];
    TCHAR   szBitmapSizeMsg[MAX_PATH];
    TCHAR   szBitmapInvalidMsg[MAX_PATH];
    TCHAR   szSelectAnotherBitmapMsg[MAX_PATH];
    TCHAR   szTextureDialogTitle[GEN_STRING_SIZE];
    TCHAR   szTextureFilter[2*GEN_STRING_SIZE];
    TCHAR   szBmp[GEN_STRING_SIZE];
    TCHAR   szDotBmp[GEN_STRING_SIZE];
} TEX_STRINGS;

// Resource constants common to all screen savers

#define IDS_COPYRIGHT           9001
#define IDS_GENNAME             9003
#define IDS_INIFILE             9006
#define IDS_HELPFILE            9009
#define IDS_WARNING             9014
#define IDS_ERROR               9015
#define IDS_BITMAP_SIZE         9016
#define IDS_BITMAP_INVALID      9017
#define IDS_SELECT_ANOTHER_BITMAP 9018
#define IDS_START_FAILED        9019
#define IDS_TEXTUREFILTER       9021
#define IDS_TEXTUREDIALOGTITLE  9022
#define IDS_BMP                 9023
#define IDS_DOTBMP              9024
#define IDS_STARDOTBMP          9025
#define IDS_RGB                 9030
#define IDS_DOTRGB              9031
#define IDS_STARDOTRGB          9032
#define IDS_TEXTURE             9126
#define IDS_TEXTURE_FILE_OFFSET 9127
#define IDS_SIZE                9129
#define IDS_TESSELATION         9130

// Useful macros

#define SS_MAX( a, b ) \
    ( a > b ? a : b )

#define SS_MIN( a, b ) \
    ( a < b ? a : b )

// macro to round up floating values
#define SS_ROUND_UP( fval ) \
    ( (((fval) - (FLOAT)(int)(fval)) > 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) )

// macros to clamp a value within a range
#define SS_CLAMP_TO_RANGE( a, lo, hi ) ( (a < lo) ? lo : ((a > hi) ? hi : a) )
#define SS_CLAMP_TO_RANGE2( a, lo, hi ) \
    ( a = (a < lo) ? lo : ((a > hi) ? hi : a) )

// degree<->radian macros
#define ONE_OVER_180 (1.0f / 180.0f)
#define SS_DEG_TO_RAD( a ) ( (a*PI) * ONE_OVER_180 )
#define SS_RAD_TO_DEG( a ) ( (a*180.0f) * ONE_OVER_PI )

extern MATERIAL TeaMaterial[], TexMaterial[], ss_BlackMat;

// window handling

extern void ss_InitFunc(SSINITPROC);
extern void ss_ReshapeFunc(SSRESHAPEPROC);
extern void ss_RepaintFunc(SSREPAINTPROC);
extern void ss_UpdateFunc(SSUPDATEPROC);
extern void ss_FinishFunc(SSFINISHPROC);
extern void ss_FloaterBounceFunc(SSFLOATERBOUNCEPROC);

// This function *must* be defined by the screen saver
extern SSContext* ss_Init(void);
extern BOOL ss_ConfigInit( HWND hDlg );

extern void ss_DataPtr( void * );

extern BOOL ss_SetWindowAspectRatio( FLOAT aspect );
extern void ss_RandomWindowPos( void );

extern HWND ss_GetHWND();
extern HWND ss_GetGLHWND();
extern void ss_GetScreenSize( ISIZE *size );

extern HBITMAP
SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits);
extern BOOL APIENTRY SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal);

// Palette manage procs
extern LONG MainPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern LONG PaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern LONG FullScreenPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern LONG NullPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

// material processing

extern void ss_InitTeaMaterials();
extern void ss_InitTexMaterials();
extern void ss_InitMaterials();
extern void ss_SetMaterial( MATERIAL *pMat );
extern void ss_SetMaterialIndex( int index );
extern MATERIAL *ss_RandomTeaMaterial( BOOL bSet );
extern int  ss_RandomTeaMaterialIndex( BOOL bSet );
extern MATERIAL *ss_RandomTexMaterial( BOOL bSet );
extern int  ss_RandomTexMaterialIndex( BOOL bSet );
extern void ss_CreateMaterialGradient( MATERIAL *matInc, MATERIAL *startMat,
                        MATERIAL *endMat, int transCount );
extern void ss_TransitionMaterial( MATERIAL *transMat, MATERIAL *transMatInc );

// color

extern void ss_HsvToRgb(float h, float s, float v, RGBA *color );

// clear

extern int ss_RectWipeClear( int width, int height, int repCount );
extern int ss_DigitalDissolveClear( int width, int height, int size );

// utility

extern void ss_RandInit( void );
extern int ss_iRand( int max );
extern int ss_iRand2( int min, int max );
extern FLOAT ss_fRand( FLOAT min, FLOAT max );
extern BOOL ss_ChangeDisplaySettings( int width, int height, int bitDepth );
extern void ss_QueryDisplaySettings( void );
extern void ss_QueryOSVersion( void );
extern void ss_QueryGLVersion( void );
extern BOOL ss_fOnWin95( void );
extern BOOL ss_fOnNT35( void );
extern BOOL ss_fOnGL11( void );
extern BOOL ss_fPreviewMode( void );
extern BOOL ss_fFullScreenMode( void );
extern BOOL ss_fWindowMode( void );
extern BOOL ss_fConfigMode( void );
extern BOOL ss_RedrawDesktop( void );

// texture file processing

extern int  ss_LoadBMPTextureFile( LPCTSTR pszBmpfile, TEXTURE *pTex );
extern int  ss_LoadTextureFile( TEXFILE *texFile, TEXTURE *pTex );
extern int  ss_LoadTextureResource( TEX_RES *pTexRes, TEXTURE *pTex );
extern BOOL ss_CopyTexture( TEXTURE *pTexDst, TEXTURE *pTexSrc );
extern BOOL ss_SetTextureTransparency( TEXTURE *pTex, float alpha, BOOL bSet );
extern void ss_DisableTextureErrorMsgs();
extern void ss_SetTexture( TEXTURE *pTex );
extern void ss_SetTexturePalette( TEXTURE *pTex, int index );
extern void ss_DeleteTexture( TEXTURE *pTex );
extern BOOL ss_LoadTextureResourceStrings();
extern BOOL ss_DIBImageLoad(PVOID pvFile, TEXTURE *ptex);
extern BOOL ss_RGBImageLoad(PVOID pvFile, TEXTURE *ptex);
extern BOOL ss_A8ImageLoad(PVOID pvFile, TEXTURE *ptex);
extern BOOL ss_VerifyTextureFile( TEXFILE *ptf );
extern BOOL ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf );
extern void ss_GetDefaultBmpFile( LPTSTR pszBmpFile );
extern void ss_InitAutoTexture( TEX_POINT2D *pTexRep );

// texture objects

extern BOOL ss_TextureObjectsEnabled( void );

// Paletted texture support
extern BOOL ss_PalettedTextureEnabled(void);
extern BOOL ss_QueryPalettedTextureEXT(void);

// math functions

extern POINT3D ss_ptZero;
extern void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_matrixIdent(MATRIX *);
extern void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta);
extern void ss_matrixTranslate(MATRIX *, double xTrans, double yTrans, double zTrans);
extern void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 );
extern void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3);
extern void ss_normalizeNorm(POINT3D *);
extern void ss_normalizeNorms(POINT3D *, ULONG);

// registry functions

extern BOOL ss_RegistrySetup( HINSTANCE hinst, int section, int file );
extern int  ss_GetRegistryInt( int name, int iDefault );
extern void ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
extern void ss_WriteRegistryInt( int name, int iVal );
extern void ss_WriteRegistryString( int name, LPTSTR lpString );

// dialog helper functions

extern int ss_GetTrackbarPos( HWND hDlg, int item );
extern void ss_SetupTrackbar( HWND hDlg, int item, int lo, int hi, int lineSize, int pageSize, int pos );

extern BOOL gbTextureObjects; // from texture.c

#ifdef __cplusplus
}
#endif

#endif // __sscommon_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\sswindow.cxx ===
/******************************Module*Header*******************************\
* Module Name: sswindow.cxx
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include "scrnsave.h"

#include "glscrnsv.h"
#include "ssintrnl.hxx"
#include "sswindow.hxx"
#include "ssutil.hxx"

static void (__stdcall *glAddSwapHintRect)(GLint, GLint, GLint, GLint);

// externs from ssinit.cxx
extern void *gDataPtr;
extern void (*gReshapeFunc)(int, int, void *);
extern void (*gRepaintFunc)( LPRECT, void *);
extern void (*gUpdateFunc)( void *);
extern void (*gInitFunc)( void *);
extern void (*gFinishFunc)( void *);
extern void (*gFloaterBounceFunc)( void *);

// forwards
static void GetWindowSize( HWND hwnd, ISIZE *pSize );
static void ss_QueryAddSwapHintRect();
static void DrawGdiDeltaRect( HDC hdc, HBRUSH hbr, RECT *pRect1, RECT *pRect2 );
static void DrawGLDeltaRect( GLRECT *pRect1, GLRECT *pRect2 );

/**************************************************************************\
* SSW constructor
*
\**************************************************************************/

SSW::SSW( PSSW psswParentArg, ISIZE *pSize, IPOINT2D *pPos, BOOL bMotion,
          SSCHILDSIZEPROC ChildSizeFuncArg )
{
    // Basic initialization

    Reset();

    // Initialization based on constructor parameters

    psswParent = psswParentArg;

    ChildSizeFunc = ChildSizeFuncArg;

    if( pSize )
        size = *pSize;
    if( pPos )
        pos = *pPos;
    else
        pos.x = pos.y = 0;

    if( bMotion && psswParent ) {
        // Allocate motion structure
        pMotion = (MOTION *)
                LocalAlloc( LMEM_ZEROINIT | LMEM_FIXED, sizeof(MOTION) );
        // If pMotion is NULL, then motion is disabled
    }

    // Call back to the client screen saver to determine size and motion
    // characteristics of child based on its parent size.
    GetChildInfo(); // this can set pos and size

    if( pMotion ) {
        if( pPos == NULL ) {
            // Set a random window pos
            pos.x = ss_iRand2( 0, (psswParent->size.width - size.width) );
            pos.y = ss_iRand2( 0, (psswParent->size.height - size.height) );

            // Set the motion parameters
            ResetMotion();
        }
        // Have to make sure parent has an hdc so it can draw background when
        // this child moves
        if( !psswParent->hdc )
            psswParent->hdc = GetDC( psswParent->hwnd );
    }

    if( psswParent ) {
        // Need to add this pssw to its parent's list
        psswParent->AddChild( this );
        // Default is to be subWindow of parent
        psswParent->iSubWindow++;  // increment reference count
    }
}

/**************************************************************************\
* SSW constructor
*
* Used when wrapping an SSW around an already existing window
* (as when drawing GL on dialog buttons)
\**************************************************************************/

SSW::SSW( PSSW psswParentArg, HWND hwndArg )
{
    Reset();

    psswParent = psswParentArg;
    if( psswParent )
        // Need to add this pssw to its parent's list
        psswParent->AddChild( this );

    hwnd = hwndArg;
    if( !hwnd ) {
        SS_ERROR( "SSW::SSW : NULL hwnd\n" );
        return;
    }

    bOwnWindow = FALSE;
    // Get the window size
    GetWindowSize( hwnd, &size );

    gpss->sswTable.Register( hwnd, this );
}

/**************************************************************************\
* Reset
*
* Reset parameters to default init state
\**************************************************************************/

void
SSW::Reset()
{
    // Basic initialization

    bOwnWindow = TRUE;
    iSubWindow = 0;
    bValidateBg = FALSE;
    wFlags = 0;
    hwnd = 0;
    hdc = 0;
    hrc = 0;
    pos.x = pos.y = 0;
    size.width = size.height = 0;
    psswParent =    NULL;
    psswSibling =   NULL;
    psswChildren =  NULL;
    bDoubleBuf =    FALSE;
    pStretch =      NULL;
    pMotion =       NULL;
    pGLc =          NULL;

    InitFunc =      NULL;
    UpdateFunc =    NULL;
    ReshapeFunc =   NULL;
    RepaintFunc =   NULL;
    FloaterBounceFunc = NULL;
    FinishFunc =    NULL;
    ChildSizeFunc = NULL;
    DataPtr =       NULL;
}

/**************************************************************************\
* SSW destructor
*
* This can be called when a window is closed, or by the ss client
*
\**************************************************************************/

SSW::~SSW()
{
    // If this window has any children, they will have to be terminated too

    if( psswChildren ) {
        PSSW psswChild = psswChildren;
        while( psswChild ) {
            // Delete first child in list
            if( psswChild->hwnd && bOwnWindow ) {
                // We created this window, we must destroy it
                DestroyWindow( psswChild->hwnd );
            } else {
                delete psswChild;
            }
            // Next child is now first child in list
            psswChild = psswChildren;
        }
    }

    if( psswParent )
        // Need to remove this pssw from its parent's list
        psswParent->RemoveChild( this );

    if( hwnd ) {
        // Remove from SSWTable
        gpss->sswTable.Remove( hwnd );
    } else {
        // subWindow
        if( psswParent ) {
            SS_ASSERT1( (psswParent->iSubWindow > 0),
                 "Invalid subWindow reference count for pssw=0x%x\n", this );
            psswParent->iSubWindow--;  // decrement subWindow reference count
        }
    }

    // Clean up GL

    if( hrc ) {
        // FinishFunc still needs gl
        if( FinishFunc )
            (*FinishFunc)( DataPtr );

        wglMakeCurrent( NULL, NULL );
        if( ! (wFlags & SS_HRC_PROXY_BIT) )
            wglDeleteContext( hrc );
    }

    // Clean up any bitmaps

    if( pStretch ) {
        SS_BITMAP *pssbm = &pStretch->ssbm;

        DeleteObject(SelectObject(pssbm->hdc, pssbm->hbmOld));
        DeleteDC(pssbm->hdc);
    }

    //  Release the dc
    if( hdc ) {
        HWND hwndForHdc = hwnd ? hwnd : psswParent ? psswParent->hwnd : NULL;
        ReleaseDC(hwndForHdc, hdc);
    }
}

/**************************************************************************\
* AddChild
*
* Add the supplied child SSW to this SSW.
\**************************************************************************/

void
SSW::AddChild( PSSW psswChild )
{
    if( !psswChildren ) {
        psswChildren = psswChild;
        return;
    }

    // Else travel along the sibling chain of psswChildren and deposit
    // psswChild at the end

    PSSW pssw = psswChildren;
    while( pssw->psswSibling )
        pssw = pssw->psswSibling;
    pssw->psswSibling = psswChild;
}


/**************************************************************************\
* RemoveChild
*
* Remove this child from the parent's list
*
* Whoever calls this needs to update SSW_TABLE too...
\**************************************************************************/

BOOL
SSW::RemoveChild( PSSW psswChild )
{
    if( !psswChildren ) {
        // Something wrong - this window has no children
        SS_ERROR( "SSW::RemoveChild : no children\n" );
        return FALSE;
    }

    PSSW psswPrev;
    PSSW pssw = psswChildren;

    while( pssw != NULL ) {
        if( pssw == psswChild ) {
            // found it !
            if( psswChild == psswChildren )
                // The child being removed is the first in the list
                psswChildren = psswChild->psswSibling;
            else
                psswPrev->psswSibling = pssw->psswSibling;
            return TRUE;
        }
        // Move up the pointers
        psswPrev = pssw;
        pssw = psswPrev->psswSibling;
    }

    SS_ERROR( "SSW::RemoveChild : child not found\n" );
    return FALSE;
}

/**************************************************************************\
* GetWindowSize
*
\**************************************************************************/

static void
GetWindowSize( HWND hwnd, ISIZE *pSize )
{
    RECT clientRect;

    GetClientRect( hwnd, &clientRect );

    pSize->width = clientRect.right - clientRect.left + 1;
    pSize->height = clientRect.bottom - clientRect.top + 1;
}

/**************************************************************************\
* CreateSSWindow
*
* Create OpenGL floater window.  This window floats on top of the screen
* saver window, bouncing off each of the screen edges.
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Floater motion characteristics now defined by caller
*  Aug. 14, 95 : [marcfo]
*    - Position the window offscreen initially, to workaround a win95 bug
*      with a corrupted initial clip rect.
*
\**************************************************************************/

BOOL
SSW::CreateSSWindow(HINSTANCE hMainInstance,  UINT uStyle, UINT uExStyle ,
                  LPCTSTR pszWindowTitle, WNDPROC wndProcArg, LPCTSTR pszClassName, HWND hwndParentOverride )
{
    IPOINT2D startPos;
    HWND hwndParent;

    if( hwndParentOverride )
        hwndParent = hwndParentOverride;
    else
        hwndParent =  psswParent ? psswParent->hwnd : NULL;


    wndProc = wndProcArg;

    if( !pMotion )
        startPos = pos;
    else {
        // Initialize start position off screen to work around win95 screen
        // validation bug
        startPos.x = pos.x - psswParent->size.width;
        startPos.y = pos.y - psswParent->size.height;
    }

    hwnd = CreateWindowEx(
                                 uExStyle,
                                 pszClassName,
                                 pszWindowTitle,
                                 uStyle,
                                 startPos.x,
                                 startPos.y,
                                 size.width,     // width
                                 size.height,    // height
                                 hwndParent,
                                 NULL,               // menu
                                 hMainInstance,
                                 (LPVOID) this
                                );

    if (!hwnd) {
        //mf: could still continue here by using sub-windows
        SS_WARNING( "SSW::CreateSSWindow : CreateWindowEx failure\n" );
        return FALSE;
    }

    // This window is on its own now
    if( psswParent ) {
        SS_ASSERT1( (psswParent->iSubWindow > 0),
                 "Invalid subWindow reference count for pssw=0x%x\n", this );
        psswParent->iSubWindow--;  // decrement subWindow reference count
    }

    ShowWindow(hwnd, SW_SHOW);

    return TRUE;
}

/**************************************************************************\
* GetChildInfo
*
* Call the window's ChildSizeFunc
\**************************************************************************/

void
SSW::GetChildInfo( )
{
    if( !ChildSizeFunc )
        return;

    CHILD_INFO childInfo;

    // Call the client's SizeFunc to get required info

    (*ChildSizeFunc)( &psswParent->size, &childInfo );

    // Pull required values into pssw and validate them

    size = childInfo.size;
    ValidateChildSize();

    if( !pMotion ) {
        pos = childInfo.pos;
        bValidateChildPos();
    } else {
        pMotion->posInc = childInfo.motionInfo.posInc;
        pMotion->posIncVary = childInfo.motionInfo.posIncVary;
        pMotion->posIncCur = pMotion->posInc;
    }
}


/**************************************************************************\
* ConfigureForGdi
*
* Creates an hdc for the window
*
\**************************************************************************/

BOOL
SSW::ConfigureForGdi()
{
    if( hdc )
        // already configured
        return TRUE;

    // Figure window to get hdc from
    HWND hwndForHdc = hwnd ? hwnd : psswParent ? psswParent->hwnd : NULL;

    if( !hwndForHdc || !(hdc = GetDC(hwndForHdc)) ) {
        SS_WARNING( "SSW::ConfigureForGdi failed\n" );
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************\
* ConfigureForGL
*
* Creates a GL rendering context for the specified window
*
\**************************************************************************/

BOOL
SSW::ConfigureForGL( SS_GL_CONFIG *pGLcArg )
{
    pGLc = pGLcArg;
    return ConfigureForGL();
}

BOOL
SSW::ConfigureForGL()
{
    if( hrc )
        // Already configured...
        return TRUE;

    if( ConfigureForGdi() &&
        (hrc = hrcSetupGL()) )
        return TRUE;

    SS_WARNING( "SSW::ConfigureForGL failed\n" );
    return FALSE;
}

/**************************************************************************\
* hrcSetupGL
*
* Setup OpenGL.
*
\**************************************************************************/

#define NULL_RC ((HGLRC) 0)

HGLRC
SSW::hrcSetupGL()
{
    if( !pGLc )
        return NULL_RC;

//mf: This routine does not yet fully support logical sub-windows...

    HGLRC hrc;
    HDC hgldc;
    int pfFlags = pGLc->pfFlags;
    PIXELFORMATDESCRIPTOR pfd = {0};

    pStretch = pGLc->pStretch;
    if( pStretch ) {
        if( NeedStretchedWindow() ) {
            // Only need single buffered pixel format
            pfFlags &= ~SS_DOUBLEBUF_BIT;
            pfFlags |= SS_BITMAP_BIT; // yup, BOTH window and bitmap need this
        } else
            // Turn off stretching
            pStretch = NULL;
    }

    // If preview mode or config mode, don't allow pixel formats that need
    // the system palette, as this will create much ugliness.
    if( ss_fPreviewMode() || ss_fConfigMode() )
        pfFlags |= SS_NO_SYSTEM_PALETTE_BIT;

    // If config mode, force a non-accelerated pixel format, as WNDOBJ's
    // seem to have problems with MCD, ICD.  Do the same thing if a
    // monitor configuration is detected, since only the generic implementation
    // will work properly in this case on all displays.

    if( ss_fConfigMode() || (GetSystemMetrics(SM_CMONITORS) > 1) )
        pfFlags |= SS_GENERIC_UNACCELERATED_BIT;

    bDoubleBuf = SS_HAS_DOUBLEBUF( pfFlags );

    if( !SSU_SetupPixelFormat( hdc, pfFlags, &pfd ) )
        return NULL_RC;

    // Update pGLc->pfFlags based on pfd returned
    // !!! mf: klugey, fix after SUR
    // (for now, the only ones we care about are the generic/accelerated flags)
    if(  (pfd.dwFlags & (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED))
		 == PFD_GENERIC_FORMAT )
        pGLc->pfFlags |= SS_GENERIC_UNACCELERATED_BIT;

    if( SSU_bNeedPalette( &pfd ) ) {
        // Note: even if bStretch, need to set up palette here so they match
        if( !gpss->pssPal ) {
            SS_PAL *pssPal;
            BOOL bTakeOverPalette = ss_fFullScreenMode() ? TRUE : FALSE;

            // The global palette has not been created yet - do it
            // SS_PAL creation requires pixel format descriptor for color bit
            // information, etc. (the pfd is cached in SS_PAL, since for
            // palette purposes it is the same for all windows)
            pssPal = new SS_PAL( hdc, &pfd, bTakeOverPalette );
            if( !pssPal )
                return NULL_RC;
            // Set approppriate palette manage proc
            if( ss_fFullScreenMode() )
                pssPal->paletteManageProc = FullScreenPaletteManageProc;
            else
                // use regular palette manager proc
                pssPal->paletteManageProc = PaletteManageProc;
            gpss->pssPal = pssPal;
        }
        // Realize the global palette in this window
        //mf: assume we're realizing in foreground
        HWND hwndPal = hwnd ? hwnd : psswParent ? psswParent->hwnd : NULL;
        if( hwndPal )
            gpss->pssPal->Realize( hwndPal, hdc, FALSE );
    }

    if( pStretch ) {
        // Stretch blt mode: For every frame, we'll be doing a StretchBlt
        // from a DIB to the screen.  Need to set up a compatible memdc.
        SS_BITMAP *pssbm;

        pssbm = &pStretch->ssbm;

        pssbm->hdc = CreateCompatibleDC(hdc);
        if( !pssbm->hdc )
            return NULL_RC;
        ResizeStretch(); // this creates the DIB Section
        pfFlags = 0;
        pfFlags |= SS_BITMAP_BIT;
        if( !SSU_SetupPixelFormat( pssbm->hdc, pfFlags, &pfd ) ) {
            return NULL_RC;
        }
        //mf: this ppfd's palette bits must match the window's !!
        // If window needs palette, so does bitmap...
        if( gpss->pssPal ) {
            SS_PAL *pssPal = gpss->pssPal;
            extern void ssw_UpdateDIBColorTable( HDC, HDC );

            ssw_UpdateDIBColorTable( pssbm->hdc, hdc );
        }
        hgldc = pssbm->hdc;
    } else {
        hgldc = hdc;
    }

    if( pGLc->hrc ) {
        // Use the supplied hrc
        hrc = pGLc->hrc;
        // Set flag so we don't delete this borrowed hrc when the SSW terminates
        wFlags |= SS_HRC_PROXY_BIT;
    } else
        // Create a new hrc
        hrc = wglCreateContext(hgldc);

    if( !hrc || !wglMakeCurrent(hgldc, hrc) ) {
        SS_WARNING( "SSW::hrcSetupGL : hrc context failure\n" );
        return NULL_RC;
    }

    if( !hwnd && (bDoubleBuf || pStretch) ) {

        // enable scissoring
        glEnable( GL_SCISSOR_TEST );

        if( !(pGLc->pfFlags & SS_GENERIC_UNACCELERATED_BIT) ) {
            // MCD or ICD, possible hardware implementation - we maintain
            // a lastRect to handle SwapBuffer issues
            lastRect.x = lastRect.y = lastRect.width = lastRect.height = 0;
        }
    }

    SS_DBGLEVEL2( SS_LEVEL_INFO,
        "SSW::hrcSetupGL: wglMakeCurrent( hrc=0x%x, hwnd=0x%x )\n", hrc, hwnd );

//mf: Note that these queries are based on a single gl window screen saver.  In
// a more complicated scenario, these capabilities could be queried on a
// per-window basis (since support could vary with pixel formats).

    // Query the GL version - sets support for any new (e.g. 1.1) functionality
    ss_QueryGLVersion();

    // Query paletted texture extension
    ss_QueryPalettedTextureEXT();

    // Query the AddSwapHintRect WIN extension
    ss_QueryAddSwapHintRect();

    // Pull in any Func's that were already defined (for compatibility with
    // old mechanism)

    InitFunc = gInitFunc;
    UpdateFunc = gUpdateFunc;
    ReshapeFunc = gReshapeFunc;
    RepaintFunc = gRepaintFunc;
    FloaterBounceFunc = gFloaterBounceFunc;
    FinishFunc = gFinishFunc;
    DataPtr = gDataPtr;

    return hrc;
}

/**************************************************************************\
* MakeCurrent
*
* Call wglMakeCurrent for this window's hrc.  Note: an ss client may have
* more than one hrc (e.g. pipes), in which case it is the client's
* responsibility to make current.
\**************************************************************************/

void
SSW::MakeCurrent()
{
    if( ! wglMakeCurrent( hdc, hrc ) ) {
        SS_WARNING( "SSW::MakeCurrent : wglMakeCurrent failure\n" );
    }
}

/**************************************************************************\
* InitGL
*
* Call the window's GL Init Func
*
* Priority is raised to expedite any initialization (e.g. loading and
* processing textures can take a while.
*
* A Reshape msg is sent to the client ss, as this is required for setting
* glViewport, etc.
\**************************************************************************/

void
SSW::InitGL()
{
    PSSW psswChild = psswChildren;

    // Configure the window for GL if pGLc non-NULL
    if( pGLc && (! ConfigureForGL()) ) {
        // This is fatal for this window - if it is the main window,
        // the ss will terminate
        if( hwnd )
            PostMessage( hwnd, WM_CLOSE, 0, 0l );
        return;
    }

    // If window configured for GL, hrc will have been set...

    // Call the InitFunc
    if( hrc && InitFunc ) {
        DWORD oldPriority;

        // Bump up priority during initialization phase
        oldPriority = GetPriorityClass( GetCurrentProcess() );
        SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS );

        SS_DBGLEVEL1( SS_LEVEL_INFO,
                "SSW::InitGL: Calling client GLInit for 0x%x\n", hwnd );

        (*InitFunc)( DataPtr );

        // restore original priority
        SetPriorityClass( GetCurrentProcess(), oldPriority );
    }

    /* Send another Reshape, since initial one triggered by window
     * creation would have been received before GL init'd
     */
    Reshape();

    // Next, init any child windows.  This has to be done after the parent
    // window initialization.

    while( psswChild ) {
        if( psswChild->hwnd )
            SendMessage( psswChild->hwnd, SS_WM_INITGL, 0, 0 );
        else
            // Must be a logical sub-window
            psswChild->InitGL();
        psswChild = psswChild->psswSibling;
    }
}

/**************************************************************************\
* ResizeStretch
*
* Resize the compatible bitmap for stretch blt mode
*
* There are 2 sizing modes.  If bRatioMode, then we set the bitmap size
* by dividing the window dimensions by the supplied ratios.  In this case,
* the base* values set a lower limit for the bitmap dimensions.  Otherwise, the
* base* values determine the bitmap dimensions.
*
* Feb. 12, 96 : [marcfo]
*
\**************************************************************************/

void
SSW::ResizeStretch()
{
    RECT rc;
    HBITMAP hbmNew;
    PVOID pvBits;
    int width, height;
    int cwidth, cheight; // client area size
    SS_BITMAP *pssbm = &pStretch->ssbm;

    cwidth = size.width;
    cheight = size.height;

    if( pStretch->bRatioMode ) {
        width = (int) ( (float)cwidth / pStretch->widthRatio );
        height = (int) ( (float)cheight / pStretch->heightRatio );
        if( width < pStretch->baseWidth )
            width = pStretch->baseWidth;
        if( height < pStretch->baseHeight )
            height = pStretch->baseHeight ;
    } else {
        width = pStretch->baseWidth;
        height = pStretch->baseHeight;
    }

    // Limit width, height to window dimensions
    if( width > cwidth )
        width = cwidth;
    if( height > cheight )
        height = cheight;

    // If same size, get out
    if( (width == pssbm->size.width) && (height == pssbm->size.height) )
        return;

    pssbm->size.width = width;
    pssbm->size.height = height;

#if 1
    // Use system palette
    hbmNew = SSDIB_CreateCompatibleDIB(hdc, NULL, width, height, &pvBits);
#else
    // Use log palette
    hbmNew = SSDIB_CreateCompatibleDIB(hdc,
                                    gpss->pssPal ? gpss->pssPal->hPal : NULL,
                                    width, height, &pvBits);
#endif
    if (hbmNew)
    {
        if (pssbm->hbm != (HBITMAP) 0)
        {
            SelectObject( pssbm->hdc, pssbm->hbmOld );
            DeleteObject( pssbm->hbm );
        }

        pssbm->hbm = hbmNew;
        pssbm->hbmOld = (HBITMAP) SelectObject( pssbm->hdc, pssbm->hbm );
    }
}

/**************************************************************************\
* Resize
*
* Resize wrapper
*
* Called in response to WM_SIZE.
*
\**************************************************************************/

void
SSW::Resize( int width, int height )
{
    size.width  = width;
    size.height = height;

    if( pStretch ) {
        // May have to resize associated bitmap
        ResizeStretch();
    }

    if( psswChildren ) {
        // May need to resize any children
        PSSW pssw = psswChildren;
        while( pssw ) {
            // Get new size/motion for the floater
            pssw->GetChildInfo();
            pssw->SetSSWindowPos();
            if( !pssw->hwnd ) {
                // Handle sub-window case
                // Need to call Reshape, since win32 system won't send WM_SIZE.
                pssw->Reshape();
            }
            pssw = pssw->psswSibling;
        }
    }

    Reshape();
}

/**************************************************************************\
* Repaint
*
* Repaint wrapper
*
* Called in response to WM_PAINT.
*
\**************************************************************************/

#define NULL_UPDATE_RECT( pRect ) \
     (  ((pRect)->left == 0) && \
        ((pRect)->right == 0) && \
        ((pRect)->top == 0) && \
        ((pRect)->bottom == 0) )

void
SSW::Repaint( BOOL bCheckUpdateRect )
{
    if( !hwnd )
        return;

    RECT rect, *pRect = NULL;

    if( bCheckUpdateRect ) {
        GetUpdateRect( hwnd, &rect, FALSE );
        // mf: Above supposed to return NULL if rect is all 0's,
        // but this doesn't happen
        if( NULL_UPDATE_RECT( &rect ) )
            return;
        pRect = &rect;
    }

    if( RepaintFunc )
        (*RepaintFunc)( pRect, DataPtr );
}

/**************************************************************************\
* NeedStretchedWindow
*
* Check if stretch mode is necessary
*
\**************************************************************************/

BOOL
SSW::NeedStretchedWindow()
{
    if( (pStretch->baseWidth >= size.width) &&
        (pStretch->baseHeight >= size.height) ) {
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************\
* SetSSWindowPos
*
* Set new size and position for an SSW
*
\**************************************************************************/

void
SSW::SetSSWindowPos()
{
    SetSSWindowPos( 0 );
}

void
SSW::SetSSWindowPos( int flags )
{
    if( hwnd ) {
        SetWindowPos(hwnd, 0, pos.x, pos.y,
                 size.width, size.height,
                 SWP_NOCOPYBITS | SWP_NOZORDER | SWP_NOACTIVATE | flags );
    // Note: If flags does not specify SWP_NOREDRAW, this generates a WM_PAINT
    // msg for the entire window region
    } else if( psswParent && !pStretch ) {
        // Set viewport for new position
        // (mf: if pStretch, shouldn't need to do anything, as viewport should
        // have been already set to the bitmap)
        int posy = GLPosY();
        glViewport( pos.x, posy, size.width, size.height );
        glScissor( pos.x, posy, size.width, size.height );
        glAddSwapHintRect( pos.x, posy, size.width, size.height );
    }
}

/******************************Public*Routine******************************\
* SetAspectRatio
*
* Resize a child window to conform to the supplied aspect ratio.  We do this by
* maintaining the existing width, and adjusting the height.
*
* Window resize seems to be executed synchronously, so gl should be able to
* immediately validate its buffer dimensions (we count on it).
*
* Returns TRUE if new height is different from last, else FALSE.
\**************************************************************************/

BOOL
SSW::SetAspectRatio( FLOAT fAspect )
{
    if( !psswParent )
        return FALSE;

    int oldHeight;
    UINT uFlags = 0;

    // Check for zero fAspect
    if( fAspect == 0.0f ) fAspect = 1.0f;

    oldHeight = size.height;
    // Set the new height, based on desired aspect ratio
    size.height = (int) ((FLOAT) size.width / fAspect);
    // make sure new height not TOO big!
    ValidateChildSize();

    if( size.height == oldHeight )
        // no change
        return FALSE;

    // make sure current position still valid when height changes
    if( !bValidateChildPos() ) {
        // current position OK, don't need to move it
        uFlags |= SWP_NOMOVE;
    }
    SetSSWindowPos( uFlags );

    // ! remember not to call the client's ReshapeFunc here, as SetAspectRatio
    // may be called by the client in response to a window resize, resulting in
    // an infinite loop
    //mf: but if there is no size change (above) we return, avoiding the
    // infinite loop
    if( !hwnd )
        // Need to call Reshape, since win32 system won't send WM_SIZE.  Need
        // to fix to avoid possible infinite loops
        Reshape();

    return TRUE;
}

/**************************************************************************\
* CalcNextWindowPos
*
* Calculate the next position for a moving window, using the pMotion data.
* If the new position would cause the window to bounce off the
* edge of its parent, return TRUE.
*
\**************************************************************************/

BOOL
SSW::CalcNextWindowPos()
{
    POINT2D *fpos = &pMotion->pos;
    IPOINT2D *ipos = &pos;
    POINT2D *posInc = &pMotion->posInc;
    POINT2D *posIncV = &pMotion->posIncVary;
    POINT2D *posIncCur = &pMotion->posIncCur;
    BOOL bounce = FALSE;

    if( !psswParent )
        return FALSE;

    // Compute the next window position.

    fpos->x += posIncCur->x;
    fpos->y += posIncCur->y;
    ipos->x = (int) fpos->x;
    ipos->y = (int) fpos->y;

    if ( (ipos->x + size.width) > psswParent->size.width) {
        // Right hit
        ipos->x = psswParent->size.width - size.width;
        fpos->x = (float) ipos->x;
        posIncCur->x =
            - ss_fRand( posInc->x - posIncV->x, posInc->x + posIncV->x );
        if( posIncCur->x > -0.5f ) posIncCur->x = -0.5f;
        bounce = TRUE;
    } else if (ipos->x < 0) {
        // Left hit
        ipos->x = 0;
        fpos->x = 0.0f;
        posIncCur->x =
            ss_fRand( posInc->x - posIncV->x, posInc->x + posIncV->x );
        if( posIncCur->x < 0.5f ) posIncCur->x = 0.5f;
        bounce = TRUE;
    }

    if ( (ipos->y + size.height) > psswParent->size.height) {
        // Bottom hit
        ipos->y = psswParent->size.height - size.height;
        fpos->y = (float) (ipos->y);
        posIncCur->y =
            - ss_fRand( posInc->y - posIncV->y, posInc->y + posIncV->y );
        if( posIncCur->y > -0.5f ) posIncCur->y = -0.5f;
        bounce = TRUE;
    } else if (ipos->y < 0) {
        // Top hit
        ipos->y = 0;
        fpos->y = 0.0f;
        posIncCur->y =
            ss_fRand( posInc->y - posIncV->y, posInc->y + posIncV->y );
        if( posIncCur->y < 0.5f ) posIncCur->y = 0.5f;
        bounce = TRUE;
    }
    return bounce;
}


/**************************************************************************\
* MoveSSWindow
*
* This is the function that moves the OpenGL window around, causing it to
* bounce around.  Each time the window is moved, the contents of the
* window are updated from the hidden (or back) buffer by SwapBuffers().
*
* The bRedrawBg flag determines whether the area that was covered by the old
* position should be updated by the parent window.
*
\**************************************************************************/

void
SSW::MoveSSWindow( BOOL bRedrawBg )
{
    BOOL bounce;
    int flags = SWP_NOSIZE;

    // Synchronize with OpenGL.  Flush OpenGL commands and wait for completion.

    glFinish();

    // Move the window

    bounce = CalcNextWindowPos();

    if( bounce && FloaterBounceFunc )
        // The window bounced off one of the sides
        // ! This function should *not* be used for rendering - for
        // informational purposes only (.e.g. changing the spin of a
        // rotating object).
        (*FloaterBounceFunc)( DataPtr );

    if( !bRedrawBg )
        flags |= SWP_NOREDRAW;
    SetSSWindowPos( flags );
}


/**************************************************************************\
* UpdateWindow
*
* Update the window
*
* Ccurrently this assumes all windows are being animated (i.e. not showing
*   a static image)
*
* Things *must* happen in the order defined here, so they work on generic as
* well as hardware implementations.
* Note: Move must happen after SwapBuf, and will cause some encroaching on
* the current display, as the parent window repaints after the move.  Therefore
* apps must take care to leave an empty border around their rendered image,
* equal to the maximum window move delta.
*
\**************************************************************************/

void
SSW::UpdateWindow()
{
    // update any children first

    PSSW pssw = psswChildren;
    while( pssw ) {
        pssw->UpdateWindow();
        pssw = pssw->psswSibling;
    }

//mf: semi-kluge
    // If this window is a subWindow in a non-generic implementation, the
    // background of the parent may be invalid (this may eventually be
    // useful for regular windows, which is why we don't && !hwnd)
    if( psswParent &&
        psswParent->bValidateBg &&
        pGLc &&
        !(pGLc->pfFlags & SS_GENERIC_UNACCELERATED_BIT) )
    {
        // Clear the entire parent window
        // mf: I think this is only needed for double-buffered schemes, since
        // the windowing system should repaint the front buffer in this case.
        glDisable( GL_SCISSOR_TEST );
        glClear( GL_COLOR_BUFFER_BIT );
        glEnable( GL_SCISSOR_TEST );
        psswParent->bValidateBg = FALSE;
    }

    if( !UpdateFunc )
        return;

    // bDoubleBuf and pStretch should be mutually exclusive...

    if( bDoubleBuf || pStretch ) {
        UpdateDoubleBufWin();
    } else {
//mf: ? where's the clearing here ?  (true, no one uses this path...)
        if( pMotion )
            MoveSSWindow( TRUE );
        (*UpdateFunc)( DataPtr );
    }
}

/**************************************************************************\
* UpdateDoubleBufWin
*
* This is used when moving a double buffered window around.  It will
* work for all configurations.
*
\**************************************************************************/

void
SSW::UpdateDoubleBufWin()
{
    if( !hwnd ) {
        UpdateDoubleBufSubWin();
        return;
    }

    RECT updateRect;

    // Move the window

    if( pMotion ) {
        // Save child update rect before move
        GetSSWindowRect( &updateRect );
        // Move window, without repainting exposed area
        MoveSSWindow( FALSE );
    }

    // Update the back buffer

    (*UpdateFunc)( DataPtr );

    if( pMotion ) {
        // (pMotion will be NULL if this window has no parent)
        if( hwnd ) {
            // Paint the exposed area with bg brush (the current image will
            // be partially erased momentarily, until the SwapBuffers() call
            // comes through)
            // (This rect should be clipped to our new window position...)
            DrawGdiRect( psswParent->hdc, gpss->hbrBg, &updateRect );
        } else {
//mf: currently this path not possible, since if !hwnd, we use one of the
// UpdateDoubleBufSubWin* functions
            SS_WARNING( "SSW::UpdateDoubleBufWin: no hwnd\n" );
            // sub-window case : need to do our own clipping
            RECT newRect;
            GetSSWindowRect( &newRect );
            DrawGdiDeltaRect( psswParent->hdc, gpss->hbrBg, &updateRect, &newRect );
        }
    }

    // Swap to the new window position
    SwapSSBuffers();
}


/**************************************************************************\
* UpdateDoubleBufSubWin
*
* Used for generic double buffered gl sub-windows.
*
\**************************************************************************/

void
SSW::UpdateDoubleBufSubWin()
{
    GLRECT curRect, newRect;

    // AddSwapHintRect for current position
    glAddSwapHintRect( pos.x, GLPosY(), size.width, size.height );

    if( pMotion ) {

        // Save current rect
        curRect.x = pos.x;
        curRect.y = GLPosY();
        curRect.width = size.width;
        curRect.height = size.height;

        // Move window, without repainting exposed area
        MoveSSWindow( FALSE );

        // Get new rect
        newRect.x = pos.x;
        newRect.y = GLPosY();
        newRect.width = size.width;
        newRect.height = size.height;

        DrawGLDeltaRect( &curRect, &newRect );

        // Have to consider previous rect for ICD or MCD
        if( !(pGLc->pfFlags & SS_GENERIC_UNACCELERATED_BIT) ) {
            DrawGLDeltaRect( &lastRect, &newRect );
            lastRect = curRect;
        }

        // Reset scissor to new rect (this *was* set by MoveSSWindow, but
        // DrawGLDeltaRect sets scissor to do its clearing
        glScissor( newRect.x, newRect.y, newRect.width, newRect.height );
    }

    // Update the back buffer

    (*UpdateFunc)( DataPtr );

    // Swap to the new window position
    SwapSSBuffers();
}


/******************************Public*Routine******************************\
* RandomWindowPos
*
* Sets a new random window position and motion
*
\**************************************************************************/

void
SSW::RandomWindowPos()
{
    if( psswParent ) {
        if( !hwnd ) {
            // sub-window : manually clear old window rect
            if( bDoubleBuf ) {
                glClear( GL_COLOR_BUFFER_BIT );
            } else {
                RECT oldRect;
                GetSSWindowRect( &oldRect );
                DrawGdiRect( psswParent->hdc, gpss->hbrBg, &oldRect );
            }
        }

        // Calc and set new position
        pos.x = ss_iRand2( 0, (psswParent->size.width - size.width) );
        pos.y = ss_iRand2( 0, (psswParent->size.height - size.height) );
        SetSSWindowPos( SWP_NOSIZE );

        // Reset motion
        if( pMotion )
            ResetMotion();
    }
}

/**************************************************************************\
* ResetMotion
*
* Calculate a random position and motion vector for the floater window
* Note that a floating point position is maintained for DDA window movement
*
\**************************************************************************/

void
SSW::ResetMotion()
{
    if( !psswParent || !pMotion )
        // Only child windows can be reset
        return;

    // Set floating point pos also, for DDA
    pMotion->pos.x = (float) pos.x;
    pMotion->pos.y = (float) pos.y;

    // also reset the window motion directions

    if( ss_iRand(2) )  // 0 or 1
        pMotion->posIncCur.x = - pMotion->posIncCur.x;
    if( ss_iRand(2) )
        pMotion->posIncCur.y = - pMotion->posIncCur.y;
}

/**************************************************************************\
* ValidateChildSize
*
* Make sure it's not bigger than its parent
*
\**************************************************************************/

void
SSW::ValidateChildSize()
{
    if( !psswParent )
        return;

    SS_CLAMP_TO_RANGE2( size.width, 0, psswParent->size.width );
    SS_CLAMP_TO_RANGE2( size.height, 0, psswParent->size.height );
}

/**************************************************************************\
* bValidateChildPos
*
* Make sure that with the current window position, none of the floating
* window extends beyond the parent window.
*
\**************************************************************************/

BOOL
SSW::bValidateChildPos()
{
    BOOL bRet = FALSE;

    if( !psswParent )
        return FALSE;

    if ( (pos.x + size.width) > psswParent->size.width) {
        pos.x = psswParent->size.width - size.width;
        bRet = TRUE;
    }

    if ( (pos.y + size.height) > psswParent->size.height) {
        pos.y = psswParent->size.height - size.height;
        bRet = TRUE;
    }
    return bRet;
}

/**************************************************************************\
* GetSSWindowRect
*
* Return window position and size in supplied RECT structure
*
* mf: this rect is relative to the parent
\**************************************************************************/

void
SSW::GetSSWindowRect( LPRECT lpRect )
{
    lpRect->left = pos.x;
    lpRect->top = pos.y;
    lpRect->right = pos.x + size.width;
    lpRect->bottom = pos.y + size.height;
}

/**************************************************************************\
* GLPosY
*
* Return y-coord of window position in GL coordinates (a win32 window position
* (starts from top left, while GL starts from bottom left)
*
\**************************************************************************/

int
SSW::GLPosY()
{
    if( !psswParent )
        return 0;

    return psswParent->size.height - size.height - pos.y;
}

/**************************************************************************\
* SwapStretchBuffers
*
* Swaps from the stretch buffer to the GL window, using StretchBlt
*
\**************************************************************************/

void
SSW::SwapStretchBuffers()
{
    SS_BITMAP *pssbm = &pStretch->ssbm;

    if( (size.width == pssbm->size.width) &&
        (size.height == pssbm->size.height) ) // buffers same size
    {
        BitBlt(hdc, 0, 0, size.width, size.height,
               pssbm->hdc, 0, 0, SRCCOPY);
    }
    else
    {
        StretchBlt(hdc, 0, 0, size.width, size.height,
                   pssbm->hdc, 0, 0, pssbm->size.width, pssbm->size.height,
                   SRCCOPY);
    }
    GdiFlush();
}

/**************************************************************************\
* SwapBuffers
*
* Wrapper for SwapBuffers / SwapStretchBuffers
*
\**************************************************************************/

void
SSW::SwapSSBuffers()
{
    if( pStretch )
        SwapStretchBuffers();
    else if( bDoubleBuf ) {
        SwapBuffers( hdc );
    }
}

/**************************************************************************\
* Reshape
*
* Reshape wrapper

* Sends reshape msg to screen saver
* This is the size of the surface that gl renders onto, which can be a bitmap.
*
\**************************************************************************/

void
SSW::Reshape()
{
    // Point to size of window, or bitmap if it has one
    ISIZE *pSize = &size;
    if( pStretch )
        pSize = &pStretch->ssbm.size;

    // If the window has an hrc, set default viewport

    if( hrc ) {
        if( hwnd )
            glViewport( 0, 0, pSize->width, pSize->height );
        else if ( psswParent ) {
            // sub-window (only 1 level of sub-windowing supported)
//mf: klugey ? - should take into account non-GL and single buffer...
#if 1
            // clear entire window to black
            glDisable( GL_SCISSOR_TEST );
            glClear( GL_COLOR_BUFFER_BIT );
            glEnable( GL_SCISSOR_TEST );
#endif
            // Convert win32 y-coord to GL
            glViewport( pos.x, GLPosY(), pSize->width, pSize->height );
        }
    }

    if( ReshapeFunc ) {
        (*ReshapeFunc)( pSize->width, pSize->height, DataPtr );
    }
}

/******************************Public*Routine******************************\
* GdiClear
*
* Clears window using Gdi FillRect
\**************************************************************************/

void
SSW::GdiClear()
{
    if( !hdc )
        return;

    RECT rect;

//mf: this should use GetClientRect
    GetSSWindowRect( &rect );

    FillRect( hdc, &rect, gpss->hbrBg );
    GdiFlush();
}


/******************************Public*Routine******************************\
* MyAddSwapHintRect
*
\**************************************************************************/

static void _stdcall
MyAddSwapHintRect(GLint xs, GLint ys, GLint xe, GLint ye)
{
    return;
}

/******************************Public*Routine******************************\
* QueryAddSwapHintRectWIN
*
\**************************************************************************/

static void
ss_QueryAddSwapHintRect()
{
    glAddSwapHintRect = (PFNGLADDSWAPHINTRECTWINPROC)
        wglGetProcAddress("glAddSwapHintRectWIN");
    if (glAddSwapHintRect == NULL) {
        glAddSwapHintRect = MyAddSwapHintRect;
    }
}

/******************************Public*Routine******************************\
* DrawGdiDeltaRect
*
* Draw the exposed area by transition from rect1 to rect2
\**************************************************************************/

static void
DrawGdiDeltaRect( HDC hdc, HBRUSH hbr, RECT *pRect1, RECT *pRect2 )
{
    if( (pRect1 == NULL) || (pRect2 == NULL) ) {
        SS_WARNING( "DrawGdiDeltaRect : one or both rects are NULL\n" );
        return;
    }

    // Draw 2 rects

    RECT rect;

    // Rect exposed in x-direction:

    rect.top = pRect1->top;
    rect.bottom = pRect1->bottom;
    if( pRect2->left > pRect1->left ) {
        // moving right
        rect.left = pRect1->left;
        rect.right = pRect2->left;
    } else {
        // moving left
        rect.left = pRect2->right;
        rect.right = pRect1->right;
    }
    FillRect( hdc, &rect, hbr );

    // Rect exposed in y-direction:

    rect.left = pRect1->left;
    rect.right = pRect1->right;
    if( pRect2->bottom > pRect1->bottom ) {
        // moving down
        rect.top = pRect1->top;
        rect.bottom = pRect2->top;
    } else {
        // moving up
        rect.top = pRect2->bottom;
        rect.bottom = pRect1->bottom;
    }
    FillRect( hdc, &rect, hbr );

    GdiFlush();
}


/******************************Public*Routine******************************\
* DrawGLDeltaRect
*
* Draw the exposed area by transition from rect1 to rect2
\**************************************************************************/

static void
DrawGLDeltaRect( GLRECT *pRect1, GLRECT *pRect2 )
{
    if( (pRect1 == NULL) || (pRect2 == NULL) ) {
        SS_WARNING( "DrawGLDeltaRect : one or both rects are NULL\n" );
        return;
    }

    // Draw 2 rects :

//mf: !!! this assumes rect1 and rect2 have same dimensions !

    GLRECT rect;

    // Rect exposed in x-direction:

    rect.height = pRect1->height;
    rect.y = pRect1->y;

    if( pRect2->x > pRect1->x ) {
        // moving right
        rect.width = pRect2->x - pRect1->x;
        rect.x = pRect1->x;
    } else {
        // moving left
        rect.width = pRect1->x - pRect2->x;
        rect.x = pRect2->x + pRect2->width;
    }

    glScissor( rect.x, rect.y, rect.width, rect.height );
    glClear( GL_COLOR_BUFFER_BIT );

    // Rect exposed in y-direction:

    rect.width = pRect1->width;
    rect.x = pRect1->x;

    if( pRect2->y > pRect1->y ) {
        // moving up
        rect.height = pRect2->y - pRect1->y;
        rect.y = pRect1->y;
    } else {
        // moving down
        rect.height = pRect1->y - pRect2->y;
        rect.y = pRect2->y + pRect2->height;
    }

    glScissor( rect.x, rect.y, rect.width, rect.height );
    glClear( GL_COLOR_BUFFER_BIT );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\sswproc.cxx ===
/******************************Module*Header*******************************\
* Module Name: sswproc.cxx
*
* Window procedure functions.
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#include <windows.h>
#include <commdlg.h>
#include <scrnsave.h>
#include <GL\gl.h>
#include "tk.h"
#include <math.h>
#include <memory.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <time.h>

#include "ssintrnl.hxx"
#include "sswproc.hxx"
#include "palette.hxx"
#include "clear.hxx"

// forward declarations of internal functions

static void ss_TimerProc();
LRESULT SS_ScreenSaverProc(HWND, UINT, WPARAM, LPARAM);

LONG 
FullScreenPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

static void 
ssw_RelayMessageToChildren( PSSW pssw, UINT msg, WPARAM wParam, LPARAM lParam);

static void ssw_RealizePalette( PSSW pssw, BOOL bBackground );
static void ssw_DeletePalette( PSSW pssw );


/**************************************************************************\
* ScreenSaverProc
*
* Processes messages for the top level screen saver window.
*
* Unhandled msgs are sent to DefScreenSaverProc
\**************************************************************************/

LRESULT
ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    static BOOL bInited = FALSE;
    static UINT idTimer = 0;
    // Draw timer time-out interval
#ifdef SS_DEBUG  
    static UINT uiTimeOut = 2;  // Let it rip !
#else
    static UINT uiTimeOut = 16; // Cap at ~60 fps
#endif
    static BOOL bSuspend = FALSE;
#ifdef SS_WIN95_TIMER_HACK
    static BOOL bIdle = FALSE;
#endif
    PSSW pssw;

    switch (message)
    {
        case WM_CREATE:
        case WM_ERASEBKGND:
        case SS_WM_INITGL:
            return SS_ScreenSaverProc( hwnd, message, wParam, lParam);

        case WM_ACTIVATE:
            if ( LOWORD(wParam) == WA_INACTIVE ) {
                SS_DBGMSG( "Main_Proc: WM_ACTIVATE inactive\n" );
                gpss->bInForeground = FALSE;
            } else {
                SS_DBGMSG( "Main_Proc: WM_ACTIVATE active\n" );
                gpss->bInForeground = TRUE;
            }

            // fall thru

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
        case WM_SYSCOLORCHANGE:
        case SS_WM_PALETTE:
            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) );

        case SS_WM_START:
            SS_DBGMSG( "Main_Proc: SS_WM_START\n" );
            // This is the main GL startup point. The global animation timer
            // is started, and SS_WM_START is relayed to the window chain.

//mf: kluge for 'delayed background paint' problem in preview mode - in
// floater type ss's, the main window gets this delayed bg paint thing that
// makes the floater obvious.  By relenquishing our time slice here, the
// problem goes away...
#if 1
            if( gpss->type == SS_TYPE_PREVIEW ) {
                Sleep(0);
            }
#endif

            // Initialize the animation timer - it should start up once we
            // return from here

            idTimer = 1;
            SetTimer(hwnd, idTimer, uiTimeOut, 0);

#ifdef SS_DEBUG
            // Start timer for calculating update rate
            gpss->timer.Start();
#endif
            if( !bInited )
                bInited = TRUE;

            // Process SS_WM_START for the window chain
            return SS_ScreenSaverProc( hwnd, message, wParam, lParam);

#ifdef SS_WIN95_TIMER_HACK
        case SS_WM_IDLE :
            if( wParam == SS_IDLE_ON )
                bIdle = TRUE;
            else if( wParam == SS_IDLE_OFF )
                bIdle = FALSE;
            break;
#endif

        case WM_DESTROY:
            if (idTimer) {
                KillTimer(hwnd, idTimer);
                idTimer = 0;
            }

            // Destroy any children of the top level window

            pssw = gpss->sswTable.PsswFromHwnd( hwnd );

            PSSW psswChild;
            psswChild = pssw == NULL ? NULL : pssw->psswChildren;

            while( psswChild ) {
                if( psswChild->hwnd )
                    DestroyWindow( psswChild->hwnd );
                psswChild = pssw->psswSibling;
            }

            // Handle any palette stuff

//mf: Before deleting this top level window, we need to use its
// still-valid dc to things like restore SystemPaletteUse mode.  Ideally this
// should be done after ~SSW has dumped GL, but ~SSW also releases the DC.
// If this is a problem, we can create a new function SSW::DeleteGL that just
// gets rid of the GL part

            if( gpss->pssPal && pssw)
                ssw_DeletePalette( pssw );

            // Dump the main pssw
            delete pssw;

            // All pssw's have now been deleted - remove global ptr to top of
            // window chain.
            gpss->psswMain = NULL;

            PostQuitMessage(0);
            return 0;

        case SS_WM_CLOSING:
            // mf:This message is sent when the screen saver receives a WM_CLOSE
            // msg, *after* any password protection routines.
            // For now, only sent in /s mode
            SS_DBGMSG( "Main_Proc: SS_WM_CLOSING\n" );

            if( gpss->bResSwitch ) {
                // pssw->GdiClear();
                // mf: untested for child window case
                // Restore previous display settings
                // Note that this is also checked for in ~SCRNSAVE, in
                // case this message is not hit.
                ChangeDisplaySettings(NULL, CDS_FULLSCREEN);
                gpss->bResSwitch = FALSE;
            }
            return 0;

        case WM_SETFOCUS:
            SS_DBGMSG( "Main_Proc: WM_FOCUS\n" );
            //mf: this catches some of the win95 passwd dialog problems, where
            // we don't get repaint msgs when dialogs end
            if( ss_fOnWin95() && ss_fFullScreenMode() ) {
                pssw = gpss->sswTable.PsswFromHwnd( hwnd );
                if (pssw != NULL)
                    pssw->Repaint( FALSE );
            }
            break;

#if DBG
        case WM_SHOWWINDOW:
            SS_DBGMSG( "Main_Proc: WM_SHOWWINDOW\n" );
            break;
#endif

        case WM_PAINT:
            SS_DBGMSG( "Main_Proc: WM_PAINT\n" );

            pssw = gpss->sswTable.PsswFromHwnd( hwnd );
            if (pssw != NULL)
                pssw->Repaint( TRUE );

#ifdef SS_DO_PAINT
            // We do the painting rather than letting the system do it
            hdc = BeginPaint(hwnd, &ps);

            // This is case where bg brush is NULL and we have to do repaint
            // We only do it after bInited, as this will avoid the first
            // WM_PAINT for the entire window.
            if( bInited )
                DrawGdiRect( hdc, gpss->hbrBg, &ps.rcPaint );
            EndPaint(hwnd, &ps);
#endif // SS_DO_PAINT

#ifdef SS_DELAYED_START_KLUGE
            if( !bInited && SS_DELAY_START(gpss->type) ) {
                bInited = TRUE;

                // Do initial GL configuration
                PostMessage( hwnd, SS_WM_INITGL, 0, 0 );
                // Start drawing
                PostMessage( hwnd, SS_WM_START, 0, 0 );
            }
#endif // SS_DELAYED_START_KLUGE

            if( pssw->iSubWindow ) {
                // If this window has sub windows, mark the bg for validation,
                // since for hardware double buffered schemes, Swapbuffers
                // may swap in ugly garbage.
                pssw->bValidateBg = TRUE;
            }

#ifdef SS_DO_PAINT
            return 0; // painting has been handled by us
#endif // SS_DO_PAINT

            break;

        case WM_SIZE:
            // Suspend drawing if minimized
            if( wParam == SIZE_MINIMIZED )
                bSuspend = TRUE;
            else  // either SIZE_RESTORED or SIZE_MAXIMIZED
                bSuspend = FALSE;

            return SS_ScreenSaverProc( hwnd, message, wParam, lParam);

        case WM_MOVE:
            SS_DBGMSG( "Main_Proc: WM_MOVE\n" );
            // See note for WM_PAINT for subWindows
            pssw = gpss->sswTable.PsswFromHwnd( hwnd );
            if (pssw == NULL)
                break;

            //mf: kluge for non-floater workaround : see above
            if( pssw->iSubWindow ) 
                pssw->bValidateBg = TRUE;

            break;

        case WM_TIMER:
            if( bSuspend )
                return 0;

#ifdef SS_WIN95_TIMER_HACK
            if( bIdle ) {
                // We are in an idle state, and don't want to flood the queue
                // with WM_TIMER mesages.  So we kill the timer, do our
                // drawing, then start another timer.

                // Kill current timer
                if (idTimer)
                    KillTimer(hwnd, idTimer);
                else
                    // unlikely, but what the hay
                    return 0;
            }
#endif

            ss_TimerProc();

#ifdef SS_WIN95_TIMER_HACK
            if( bIdle ) {
                // Start another animation timer after we've done drawing
                SetTimer(hwnd, idTimer, uiTimeOut, 0);
            }
#endif
            return 0;
    }

    return DefScreenSaverProc(hwnd, message, wParam, lParam);
}

/**************************************************************************\
* SS_ScreenSaverProc
*
* Wndproc for child windows, and some messages from top-level window
*
* Unhandled msgs are sent to DefWindowProc
\**************************************************************************/

LRESULT 
SS_ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    PAINTSTRUCT ps;
    int i;
    int retVal;
    PSSW pssw;

    switch (message)
    {
        case WM_CREATE:
            SS_DBGMSG1( "SS_Proc: WM_CREATE for 0x%x\n", hwnd );

            pssw = (PSSW) ( ((LPCREATESTRUCT)lParam)->lpCreateParams ); 
            gpss->sswTable.Register( hwnd, pssw );
  
            pssw->size.width  = ((LPCREATESTRUCT)lParam)->cx;
            pssw->size.height = ((LPCREATESTRUCT)lParam)->cy;
            pssw->hwnd = hwnd;
            break;

        case SS_WM_INITGL:
            SS_DBGMSG1( "SS_Proc: SS_WM_INITGL for 0x%x\n", hwnd );

            pssw = gpss->sswTable.PsswFromHwnd( hwnd );
            pssw->InitGL();

            break;

#ifdef SS_MULTI_WINDOW_TIMERS
// Enable this section and fill it in if windows start their own animation
// timers.  For now, there is just one timer on the main window.
        case SS_WM_START:
            SS_DBGMSG1( "SS_Proc: SS_WM_START for 0x%x\n", hwnd );

            pssw = gpss->sswTable.PsswFromHwnd( hwnd );

            // Send SS_WM_START to any children of this window
            ssw_RelayMessageToChildren( pssw, SS_WM_START, 0, 0 ); 

            // Nothing really to do here yet...

            break;
#endif

        case SS_WM_PALETTE:
            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) );

        case WM_DESTROY:
            pssw = gpss->sswTable.PsswFromHwnd( hwnd );

            SS_DBGMSG1( "SS_Proc: WM_DESTROY for 0x%x\n", hwnd );
            // Kill off any children of this window first

            PSSW psswChild;
            psswChild = pssw == NULL ? NULL : pssw->psswChildren;

            while( psswChild ) {
                if( psswChild->hwnd )
                    DestroyWindow( psswChild->hwnd );
                else
                    delete psswChild;
                psswChild = pssw->psswSibling;
            }
            // Delete the pssw - this does all necessary cleanup

            delete pssw;
            break;

        case WM_ERASEBKGND:
            SS_DBGMSG1( "SS_Proc: WM_ERASEBKGRND for 0x%x\n", hwnd );
#if 0
            // If eventually we want to control bg erasing...
          {
            BOOL bEraseNow = TRUE; // ! 0 or 1 have same effect !
            if( bEraseNow ) {
                // If bg for the window is NULL, ? should erase here ?
                return TRUE;
            }
            else
                return 0; // window remains marked for erasing
          }
#else
            pssw = gpss->sswTable.PsswFromHwnd( hwnd );
            if (pssw != NULL)
                pssw->Repaint( FALSE );
            // Don't process this message
            return DefWindowProc(hwnd, message, wParam, lParam);
#endif

        case WM_PAINT:
            // We get this msg every time window moves, since SWP_NOCOPYBITS is
            // specified with the window move.
            hdc = BeginPaint(hwnd, &ps);
            EndPaint(hwnd, &ps);
            break;

        case WM_SIZE:
            pssw = gpss->sswTable.PsswFromHwnd( hwnd );
            if (pssw != NULL)
                pssw->Resize( LOWORD(lParam), HIWORD(lParam) );
            break;

        // these msg's are never received by the child window ?
        case WM_ACTIVATE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) );


        case WM_SYSCOMMAND:
        case WM_SETCURSOR:
        case WM_ACTIVATEAPP:
        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
        case WM_POWERBROADCAST:
        case WM_POWER:
            pssw = gpss->sswTable.PsswFromHwnd( hwnd );
            if (pssw == NULL)
                return DefScreenSaverProc(hwnd, message, wParam, lParam);
            else
                return DefScreenSaverProc(pssw->psswParent->hwnd, message, wParam, lParam);

        default: 
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}


#ifdef SS_DEBUG
/**************************************************************************\
* PrintUpdateRate
*
* Print number of updates per second in the title bar
*
\**************************************************************************/

static void
PrintUpdateRate( double elapsed, long updateCount )
{
    char buf[100];
    double updateRate;

    if( elapsed == 0.0 )
        updateRate = 0.0;
    else
        updateRate = updateCount / elapsed;

    sprintf( buf, "Updates per second = %4.1f", updateRate );
    SendMessage(gpss->psswMain->hwnd, WM_SETTEXT, 0, (LPARAM)buf);
}
#endif

/**************************************************************************\
* ss_TimerProc
*
* Every time a timer event fires off, update all active windows
*
\**************************************************************************/

static void 
ss_TimerProc()
{
    static int busy = FALSE;
    int i;
#ifdef SS_DEBUG
    static long updateCount = 0;
    static double updateInterval = 2.0;
    SS_TIMER *pTimer = &gpss->timer;
#endif

    if (busy)
        return;
    busy = TRUE;

    gpss->psswMain->UpdateWindow();

#ifdef SS_DEBUG
    updateCount++;
    if( gpss->bDoTiming && 
        (( (double) pTimer->ElapsedTime() ) >= updateInterval) ) 
    {
        double elapsed = pTimer->Stop();
        PrintUpdateRate( elapsed, updateCount );
        updateCount = 0;
        pTimer->Start();
    }
#endif

    busy = FALSE;
}

/**************************************************************************\
* RelayMessageToChildren
*
* Pass along the message to any child windows
\**************************************************************************/

static void
ssw_RelayMessageToChildren( PSSW pssw, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PSSW psswChild = pssw->psswChildren;

    while( psswChild ) {
        if( psswChild->hwnd )
            SendMessage( psswChild->hwnd, msg, wParam, lParam );
        psswChild = psswChild->psswSibling;
    }
}


/**************************************************************************\
* UpdateDIBColorTable
*
* Wrapper for SSDIB_UpdateColorTable.  
*
* This controls the hPal parameter for SSDIB_UpdateColorTable.
*
\**************************************************************************/

void
ssw_UpdateDIBColorTable( HDC hdcbm, HDC hdcwin )
{
    SS_PAL *pssPal = gpss->pssPal;

    if( !pssPal )
        return;
#if 0
    HPALETTE hpal = pssPal->bTakeOver ? pssPal->hPal : NULL;
#else
    HPALETTE hpal =  pssPal->hPal;
#endif

    SSDIB_UpdateColorTable( hdcbm, hdcwin, hpal );
}


/**************************************************************************\
* RealizePalette
*
\**************************************************************************/

static void
ssw_RealizePalette( PSSW pssw, BOOL bBackground )
{
    // assumed pssPal valid if get here
    SS_PAL *pssPal = gpss->pssPal;

    if( !pssw->hrc ) {
        // Can assume this window doesn't need to worry about palettes, but
        // if any of its children are subWindows, it will have to take care
        // of it *for* them.
        if( ! pssw->iSubWindow )
            return; // no hrc and no subWindow children
    }
    pssPal->Realize( pssw->hwnd, pssw->hdc, bBackground );

    if( pssw->pStretch && pssw->pStretch->ssbm.hdc ) {
        SS_BITMAP *pssbm = &pssw->pStretch->ssbm;
        ssw_UpdateDIBColorTable( pssbm->hdc, pssw->hdc );
    }
}

/**************************************************************************\
* ssw_DeletePalette
*
\**************************************************************************/

static void
ssw_DeletePalette( PSSW pssw )
{
    SS_PAL *pssPal = gpss->pssPal;

    if( pssPal->bTakeOver ) {
        // We took over the system palette - make a note of this
        // for any special ss termination conditions.
        gpss->flags |= SS_PALETTE_TAKEOVER;
    }
    pssPal->SetDC( pssw->hdc );
    delete pssPal;
    gpss->pssPal = NULL;
}

/**************************************************************************\
* PaletteManage Procs
\**************************************************************************/

/* palette related msgs's:
    - WM_ACTIVATE:
        The WM_ACTIVATE message is sent when a window is being activated or 
        deactivated. This message is sent first to the window procedure of 
        the top-level window being deactivated; it is then sent to the 
        window procedure of the top-level window being activated. 

    - WM_QUERYNEWPALETTE:
        The WM_QUERYNEWPALETTE message informs a window that it is about 
        to receive the keyboard focus, giving the window the opportunity 
        to realize its logical palette when it receives the focus. 

        If the window realizes its logical palette, it must return TRUE; 
        otherwise, it must return FALSE. 

    - WM_PALETTECHANGED:
        The WM_PALETTECHANGED message is sent to all top-level and overlapped 
        windows after the window with the keyboard focus has realized its 
        logical palette, thereby changing the system palette. This message 
        enables a window that uses a color palette but does not have the 
        keyboard focus to realize its logical palette and update its client 
        area. 

        This message must be sent to all top-level and overlapped windows, 
        including the one that changed the system palette. If any child 
        windows use a color palette, this message must be passed on to them 
        as well. 
        To avoid creating an infinite loop, a window that receives this 
        message must not realize its palette, unless it determines that 
        wParam does not contain its own window handle. 

    - WM_SYSCOLORCHANGE:
        The WM_SYSCOLORCHANGE message is sent to all top-level windows when 
        a change is made to a system color setting. 

    - SS_WM_PALETTE:
        Internal msg.  Uses:
        - In fullscreen mode, we send this from Main wndproc to main 
          window's children on WM_ACTIVATE.
        - When this is received in SS_ScreenSaverProc, if fullscreen,
          it does:
                    UnrealizeObject( pssPal->hPal );
                    RealizePalette( hdc );
          otherwise, it is passed to PaletteManageProc, where
          Realize is called (for 'floater' windows to realize 
          their palettes).
        - It is also sent by DelayPaletteRealization() when it can't get
          the system palette.

*/


/**************************************************************************\
* MainPaletteManageProc
*
* Top-level palette management proc.

* Returns immediately if no palette set - otherwise calls through
* paletteManageProc function pointer
*
\**************************************************************************/

LONG 
MainPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    if( !gpss->pssPal )
        // No palette management required
        return 0;

    // else call approppriate palette manage proc
    return (*gpss->pssPal->paletteManageProc)(hwnd, message, wParam, lParam);
}

LONG 
NullPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    return 0;
}

/**************************************************************************\
* FullScreenPaletteManageProc
*
* Processes messages relating to palette management in full screen mode.
*
\**************************************************************************/

LONG 
FullScreenPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    SS_PAL *pssPal;
    PSSW pssw;

    switch (message)
    {
        case WM_ACTIVATE:

#if SS_DEBUG
            if ( LOWORD(wParam) == WA_INACTIVE )
                SS_DBGMSG1( "FullScreen_PMProc: WM_ACTIVATE : inactive for 0x%x\n",
                           hwnd );
            else
                SS_DBGMSG1( "FullScreen_PMProc: WM_ACTIVATE : active for 0x%x\n",
                           hwnd );
#endif

            // !! This msg is only sent to main top level window
            pssw = gpss->sswTable.PsswFromHwnd( hwnd );

            pssPal = gpss->pssPal;
            if ( pssPal->bUseStatic ) {
                HDC hdc = pssw->hdc; // hdc *always* valid for top-level pssw
                // Note: wParam = 0 when window going *inactive*
                SetSystemPaletteUse( hdc, wParam ? SYSPAL_NOSTATIC
                                                : pssPal->uiOldStaticUse);
            }

            // Send SS_WM_PALETTE msg to main window
            SendMessage( hwnd, SS_WM_PALETTE, wParam, 0);
            break;

        case SS_WM_PALETTE:

            SS_DBGMSG1( "FullScreen_PMProc: SS_WM_PALETTE for 0x%x\n", hwnd );

            pssw = gpss->sswTable.PsswFromHwnd( hwnd );

            ssw_RelayMessageToChildren( pssw, SS_WM_PALETTE, wParam, 0 );

            HDC hdc;
            if( hdc = pssw->hdc )
            {
                pssPal = gpss->pssPal;

//mf: this should call thru ssw_RealizePalette for bitmap case ? (for now
// don't need to, since we take over palette...)
                // This resets the logical palette, causing remapping of
                // logical palette to system palette
           // mf: !!! ?? how come no dc with UnrealizeObject ?  does that
                // mean its done once per app, not per child window ?
            // yeah, we should move this up...
                UnrealizeObject( pssPal->hPal );
                RealizePalette( hdc );
            }
            break;
    }
    return 0;
}

/**************************************************************************\
* PaletteManageProc
*
* Processes messages relating to palette management for the general case.
*
* Note: this msg handling strategy is based loosely on the tk, so any changes 
* there should be reflected here
\**************************************************************************/

LONG 
PaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    // One global palette for all windows
    if( !gpss->pssPal )
        return 0;

    switch (message)
    {
      case WM_ACTIVATE:

        SendMessage( hwnd, SS_WM_PALETTE, gpss->bInBackground(), 0);

        // Allow DefWindowProc() to finish the default processing (which 
        // includes changing the keyboard focus).

        break;

      case WM_QUERYNEWPALETTE:

        SS_DBGMSG1( "Palette_Proc: WM_QUERYNEWPALETTE for 0x%x\n", hwnd );
        // We don't actually realize palette here (we do it at WM_ACTIVATE
        // time), but we need the system to think that we have so that a
        // WM_PALETTECHANGED message is generated.
//mf: why can't we just realize here ? and who wants even more messages to
// be generated !!! :)

        // This is the only msg preview mode gets wrt palettes !
        if( !ss_fPreviewMode() )
            return (1);

        // We are in preview mode - realize the palette
        SendMessage( hwnd, SS_WM_PALETTE, gpss->bInBackground(), 0);
        break;

      case WM_PALETTECHANGED:

        SS_DBGMSG1( "Palette_Proc: WM_PALETTECHANGED for 0x%x\n", hwnd );
        // Respond to this message only if the window that changed the palette
        // is not this app's window.

        // We are not the foreground window, so realize palette in the
        // background.  We cannot call Realize to do this because
        // we should not do any of the gbUseStaticColors processing while
        // in background.

        // Actually, we *can* be the fg window, so don't realize if
        // we're in foreground

        if( (hwnd != (HWND) wParam) && gpss->bInBackground() )
            SendMessage( hwnd, SS_WM_PALETTE, TRUE, 0);

        break;

      case WM_SYSCOLORCHANGE:

        // If the system colors have changed and we have a palette
        // for an RGB surface then we need to recompute the static
        // color mapping because they might have been changed in
        // the process of changing the system colors.

          SS_DBGMSG1( "Palette_Proc: WM_SYSCOLORCHANGE for 0x%x\n", hwnd );
          gpss->pssPal->ReCreateRGBPalette();
          SendMessage( hwnd, SS_WM_PALETTE, gpss->bInBackground(), 0);
          break;
            
      case SS_WM_PALETTE:

          SS_DBGMSG2( "Palette_Proc: SS_WM_PALETTE for 0x%x, bg = %d\n", 
                          hwnd, wParam );


          // Realize palette for this window and its children
          // wParam = TRUE if realize as bg

          PSSW pssw = gpss->sswTable.PsswFromHwnd( hwnd );
          ssw_RelayMessageToChildren( pssw, message, wParam, lParam ); 
          ssw_RealizePalette( pssw, (BOOL)wParam );
          break;
    }
    return 0;
}

/******************************Public*Routine******************************\
* GLScreenSaverConfigureDialog
*
* This is a wrapper for ScreenSaverConfigureDialog, which is the main dialog
* proc for all the GL screen savers in config mode.
* 
* We call the client's ss_ConfigInit() routine on the first WM_PAINT, since
* the dialog will have focus at this point (can realize palette) and all
* buttons should have been created.
\**************************************************************************/

BOOL
GLScreenSaverConfigureDialog( HWND hDlg, UINT msg, WPARAM wParam,
                              LPARAM lParam )
{
    static BOOL bInited = 0;

    switch( msg ) {
        case WM_INITDIALOG :
          {
            SS_DBGMSG( "GLScreenSaverConfigureDialog: WM_INITDIALOG\n" );
            // Create wrapper pssw for the dialog box

            PSSW pssw;
            pssw = new SSW( NULL,       // ssw parent
                            hDlg
                          );
            SS_ASSERT( pssw, "GLScreenSaverConfigureDialog : alloc failure for psswMain\n" );

            gpss->psswMain = pssw;

            // Load any resource strings common to all the dialogs
            BOOL bStringsLoaded = ss_LoadTextureResourceStrings();
            // If this doesn't work, things are seriously wrong and we
            // shouldn't continue
            SS_ASSERT( bStringsLoaded, "GLScreenSaverConfigureDialog : failure loading common resource strings\n" );
          }
          break;

        case WM_PAINT:

            if( !bInited ) {
                // Call client's ss_ConfigInit()
                if( !ss_ConfigInit( hDlg ) ) {
                    SS_WARNING( "ConfigInit failed\n" );
                    // Send WM_CLOSE to the dialog - this will enable any
                    // cleanup code to be called by the client
                    SendMessage( hDlg, WM_CLOSE, 0, 0l );
                }
                bInited = TRUE;
            }
            break;

        case WM_ACTIVATE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
        case SS_WM_PALETTE:
            return( MainPaletteManageProc( hDlg, msg, wParam, lParam ) );

    }
    return ScreenSaverConfigureDialog( hDlg, msg, wParam, lParam );
}

/******************************Public*Routine******************************\
* SSW_TABLE constructor
*
\**************************************************************************/

SSW_TABLE::SSW_TABLE()
{
    nEntries = 0;
}

/******************************Public*Routine******************************\
* Register
*
* Register a HWND/PSSW pair.
\**************************************************************************/

void
SSW_TABLE::Register( HWND hwnd, PSSW pssw )
{
    SSW_TABLE_ENTRY *pEntry;

    // Check if already in table
    if( PsswFromHwnd( hwnd ) )
        return;

    // put hwnd/pssw pair in the table
    pEntry = &sswTable[nEntries];
    pEntry->hwnd = hwnd;
    pEntry->pssw = pssw;
    nEntries++;
}

/******************************Public*Routine******************************\
* PsswFromHwnd
*
* Return PSSW for the HWND
\**************************************************************************/

PSSW
SSW_TABLE::PsswFromHwnd( HWND hwnd )
{
    int count = nEntries;
    SSW_TABLE_ENTRY *pEntry = sswTable;

    while( count-- ) {
        if( pEntry->hwnd == hwnd )
            return pEntry->pssw;
        pEntry++;
    }
    return NULL;
}

/******************************Public*Routine******************************\
* Remove
*
* Remove HWND/PSSW entry from table
\**************************************************************************/

BOOL
SSW_TABLE::Remove( HWND hwnd )
{
    SSW_TABLE_ENTRY *pEntry = sswTable;

    // Locate the hwnd/pssw pair

    for( int count = 0 ; count < nEntries ; count++, pEntry++ ) {
        if( pEntry->hwnd == hwnd )
            break;
    }

    if( count == nEntries )
        // couldn't find it in the table
        return FALSE;

    // Remove entry / shuffle up other entries
    for( int i = count; i < nEntries-1; i ++ ) {
        sswTable[i] = sswTable[i+1];
    }

    nEntries--;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\ssutil.cxx ===
/******************************Module*Header*******************************\
* Module Name: ssutil.cxx
*
* Screen-saver utility functions
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <scrnsave.h>
#include <GL\gl.h>
#include <memory.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include "tk.h"
#include "ssintrnl.hxx"

#include "ssutil.hxx"

static OSVERSIONINFO gosvi = {0};
static BOOL gbGLv1_1 = FALSE;  // GL version 1.1 boolean

/******************************Public*Routine******************************\
* SSU_ChoosePixelFormat
*
* Local implementation of ChoosePixelFormat
*
* Choose pixel format based on flags.
* This allows us a little a more control than just calling ChoosePixelFormat
\**************************************************************************/

static int
SSU_ChoosePixelFormat( HDC hdc, int flags )
{
    int MaxPFDs;
    int iBest = 0;
    PIXELFORMATDESCRIPTOR pfd;

    // Always choose native pixel depth
    int cColorBits =
                GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    BOOL bDoubleBuf = flags & SS_DOUBLEBUF_BIT;

    int cDepthBits = 0;
    if( SS_HAS_DEPTH16(flags) )
        cDepthBits = 16;
    else if( SS_HAS_DEPTH32(flags) )
        cDepthBits = 32;

    int i = 1;
    do
    {
        MaxPFDs = DescribePixelFormat(hdc, i, sizeof(pfd), &pfd);
        if ( MaxPFDs <= 0 )
            return 0;

        if( ! (pfd.dwFlags & PFD_SUPPORT_OPENGL) )
            continue;

        if( flags & SS_BITMAP_BIT ) {
            // need bitmap pixel format
            if( ! (pfd.dwFlags & PFD_DRAW_TO_BITMAP) )
                continue;
        } else {
            // need window pixel format
            if( ! (pfd.dwFlags & PFD_DRAW_TO_WINDOW) )
                continue;
            // a window can be double buffered...
            if( ( bDoubleBuf && !(pfd.dwFlags & PFD_DOUBLEBUFFER) ) ||
                ( !bDoubleBuf && (pfd.dwFlags & PFD_DOUBLEBUFFER) ) )
                continue;
        }

        if ( pfd.iPixelType != PFD_TYPE_RGBA )
            continue;
        if( pfd.cColorBits != cColorBits )
            continue;

        if( flags & SS_ALPHA_BIT ) {
            // We want alpha bit planes
            if( pfd.cAlphaBits == 0 )
                continue;
        } else {
            // We don't want alpha
            if( pfd.cAlphaBits )
                continue;
        }

        if( (flags & SS_GENERIC_UNACCELERATED_BIT) &&
            ((pfd.dwFlags & (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED))
		    != PFD_GENERIC_FORMAT) )
            continue;

        if( (flags & SS_NO_SYSTEM_PALETTE_BIT) &&
            (pfd.dwFlags & PFD_NEED_SYSTEM_PALETTE) )
            continue;

        if( cDepthBits ) {
            if( pfd.cDepthBits < cDepthBits )
                continue;
        } else {
            // No depth buffer required, but use it if nothing better
            if( pfd.cDepthBits ) {
                if( pfd.dwFlags & PFD_GENERIC_ACCELERATED )
                    // Accelerated pixel format - we may as well use this, even
                    // though we don't need depth.  Otherwise if we keep going
                    // to find a better match, we run the risk of overstepping
                    // all the accelerated formats and picking a slower format.
                    return i;
                iBest = i;
                continue;
            }
        }

        // We have found something useful
        return i;

    } while (++i <= MaxPFDs);

    if( iBest )
        // not an exact match, but good enough
        return iBest;

    // If we reach here, we have failed to find a suitable pixel format.
    // See if the system can find us one.

    memset( &pfd, 0, sizeof( PIXELFORMATDESCRIPTOR ) );
    pfd.nSize = sizeof( PIXELFORMATDESCRIPTOR );
    pfd.cColorBits = (BYTE)cColorBits;
    pfd.cDepthBits = (BYTE)cDepthBits;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.dwFlags = PFD_SUPPORT_OPENGL;
    if( bDoubleBuf )
        pfd.dwFlags |= PFD_DOUBLEBUFFER;
    if( flags & SS_BITMAP_BIT )
        pfd.dwFlags |= PFD_DRAW_TO_BITMAP;
    else
        pfd.dwFlags |= PFD_DRAW_TO_WINDOW;

    if( (flags & SS_GENERIC_UNACCELERATED_BIT) ||
        (flags & SS_NO_SYSTEM_PALETTE_BIT) )
        // If either of these flags are set, we should be safe specifying a
        // 'slow' pixel format that supports bitmap drawing
        //mf: DRAW_TO_WINDOW seems to override this...
        pfd.dwFlags |= PFD_DRAW_TO_BITMAP;

    SS_WARNING( "SSU_ChoosePixelFormat failed, calling ChoosePIxelFormat\n" );

    return ChoosePixelFormat( hdc, &pfd );
}

/******************************Public*Routine******************************\
* SSU_SetupPixelFormat
*
* Choose pixel format according to supplied flags.  If ppfd is non-NULL,
* call DescribePixelFormat with it.
*
\**************************************************************************/

BOOL
SSU_SetupPixelFormat(HDC hdc, int flags, PIXELFORMATDESCRIPTOR *ppfd )
{
    int pixelFormat;
    int nTryAgain = 4;

    do{
        if( (pixelFormat = SSU_ChoosePixelFormat(hdc, flags)) &&
            SetPixelFormat(hdc, pixelFormat, NULL) ) {
            SS_DBGLEVEL1( SS_LEVEL_INFO,
               "SSU_SetupPixelFormat: Setting pixel format %d\n", pixelFormat );
            if( ppfd )
                DescribePixelFormat(hdc, pixelFormat,
                                sizeof(PIXELFORMATDESCRIPTOR), ppfd);
            return TRUE; // Success
        }
        // Failed to set pixel format.  Try again after waiting a bit (win95
        // bug with full screen dos box)
        Sleep( 1000 ); // Wait a second between attempts
    } while( nTryAgain-- );

    return FALSE;
}

/******************************Public*Routine******************************\
* SSU_bNeedPalette
*
\**************************************************************************/

BOOL
SSU_bNeedPalette( PIXELFORMATDESCRIPTOR *ppfd )
{
    if (ppfd->dwFlags & PFD_NEED_PALETTE)
        return TRUE;
    else
        return FALSE;
}


/******************************Public*Routine******************************\
* SSU_PixelFormatDescriptorFromDc
*
\**************************************************************************/

int
SSU_PixelFormatDescriptorFromDc( HDC hdc, PIXELFORMATDESCRIPTOR *Pfd )
{
    int PfdIndex;

    if ( 0 < (PfdIndex = GetPixelFormat( hdc )) )
    {
        if ( 0 < DescribePixelFormat( hdc, PfdIndex, sizeof(*Pfd), Pfd ) )
        {
            return(PfdIndex);
        }
    }
    return 0;
}

/******************************Public*Routine******************************\
* ss_ChangeDisplaySettings
*
* Try changing display settings.
* If bitDepth is 0, use current bit depth
*
\**************************************************************************/

BOOL
ss_ChangeDisplaySettings( int width, int height, int bitDepth )
{
    int change;
    DEVMODE dm = {0};

	dm.dmSize       = sizeof(dm);
    dm.dmFields     = DM_PELSWIDTH | DM_PELSHEIGHT;
	dm.dmPelsWidth  = width;
	dm.dmPelsHeight = height;

    if( bitDepth != 0 ) {
	    dm.dmFields |= DM_BITSPERPEL;
    	dm.dmBitsPerPel = bitDepth;
    }

//    change = ChangeDisplaySettings(&dm, CDS_TEST);
    change = ChangeDisplaySettings(&dm, CDS_FULLSCREEN);

    if( change == DISP_CHANGE_SUCCESSFUL )
        return TRUE;
    else
        return FALSE;
}

/******************************Public*Routine******************************\
* ss_QueryDisplaySettings
*
* Find out what diplay resolutions are available.
*
\**************************************************************************/

void
ss_QueryDisplaySettings( void )
{
    int i = 0;
    DEVMODE devMode = {0};

    while( EnumDisplaySettings( NULL, i, &devMode ) ) {
        i++;
    }
}

/******************************Public*Routine******************************\
* ss_QueryGLVersion
*
* Find out what GL version is being loaded.  If it's 1.1, set various
* global capabilities.
*
\**************************************************************************/

void
ss_QueryGLVersion( void )
{
    // Get GL version

    if( strstr( (char *) glGetString(GL_VERSION), "1.1") ) {
        gbGLv1_1 = TRUE;
        gbTextureObjects = TRUE;
    } else {
        gbGLv1_1 = FALSE;
        gbTextureObjects = FALSE;
    }
    if( !gbTextureObjects ) {
        SS_DBGINFO( "ss_QueryGLVersion: Texture Objects disabled\n" );
    }
}

/******************************Public*Routine******************************\
* ss_fOnGL11
*
* True if running on OpenGL v.1.1x
*
\**************************************************************************/

BOOL
ss_fOnGL11( void )
{
    return gbGLv1_1;
}

/******************************Public*Routine******************************\
* ss_QueryOSVersion
*
* Query the OS version
*
\**************************************************************************/

void
ss_QueryOSVersion( void )
{
    gosvi.dwOSVersionInfoSize = sizeof(gosvi);
    GetVersionEx(&gosvi);
}

/******************************Public*Routine******************************\
* ss_fOnNT35
*
* True if running on NT version 3.51 or less
*
\**************************************************************************/

BOOL
ss_fOnNT35( void )
{
    static fOnNT35;
    static bInited = FALSE;

    if( !bInited ) {
        if( !gosvi.dwOSVersionInfoSize )
            ss_QueryOSVersion();
        fOnNT35 =
        (
            (gosvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
            (gosvi.dwMajorVersion == 3 && gosvi.dwMinorVersion <= 51)
        );
        bInited = TRUE;
    }
    return fOnNT35;
}

/******************************Public*Routine******************************\
* ss_fOnWin95
*
* True if running on Windows 95
*
\**************************************************************************/

BOOL
ss_fOnWin95( void )
{
    static fOnWin95;
    static bInited = FALSE;

    if( !bInited ) {
        if( !gosvi.dwOSVersionInfoSize )
            ss_QueryOSVersion();
        fOnWin95 = ( gosvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS );
        bInited = TRUE;
    }
    return fOnWin95;
}

/******************************Public*Routine******************************\
* ss_fPreviewMode
*
* True if running in Display setting's child preview window
*
\**************************************************************************/

BOOL
ss_fPreviewMode( void )
{
    return gpss->type == SS_TYPE_PREVIEW;
}

/******************************Public*Routine******************************\
* ss_fFullScreenMode
*
* True if running full screen (/s option)
*
\**************************************************************************/

BOOL
ss_fFullScreenMode( void )
{
    return gpss->type == SS_TYPE_FULLSCREEN;
}

BOOL
ss_fConfigMode( void )
{
    return gpss->type == SS_TYPE_CONFIG;
}

BOOL
ss_fWindowMode( void )
{
    return gpss->type == SS_TYPE_NORMAL;
}

/******************************Public*Routine******************************\
* ss_RedrawDesktop
*
* Causes the entire desktop to be redrawn
*
\**************************************************************************/

BOOL
ss_RedrawDesktop( void )
{
    return RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE |
                            RDW_ERASENOW | RDW_UPDATENOW | RDW_ALLCHILDREN );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\texture.h ===
/******************************Module*Header*******************************\
* Module Name: texture.h
*
* Local texture processing functions
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __texture_h__
#define __texture_h__

#include "sscommon.h"

#ifdef __cplusplus
extern "C" {
#endif

extern BOOL bVerifyDIB(LPTSTR pszFileName, ISIZE *pSize );
extern BOOL bVerifyRGB(LPTSTR pszFileName, ISIZE *pSize );

#ifdef __cplusplus
}
#endif

#endif // __texture_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\flwbox\geom.c ===
/**********************************Module**********************************\
*
* geom.c
*
* 3D FlowerBox screen saver
* Geometry routines
*
* History:
*  Wed Jul 19 14:50:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// Sphere radius
#define RADIUS 1

// Values to map a 2D point onto a 3D plane
// Base point and axes to map X and Y coordinates onto
typedef struct _PLANE_MAP
{
    PT3 base, x_axis, y_axis;
} PLANE_MAP;

// Data area used by the current geometry
// Base points and generated points
PT3 pts[MAXPTS], npts[MAXPTS];
// Scaling factor for spherical projection
FLT vlen[MAXPTS];
// Normals
PT3 normals[MAXPTS];
// Vertex data indices
int index[MAXPTS*2];
// Triangle strip sizes
int strip_size[MAXSIDES*MAXSUBDIV];

void InitCube(GEOMETRY *geom);
void InitTetra(GEOMETRY *geom);
void InitPyramids(GEOMETRY *geom);
void InitCylinder(GEOMETRY *geom);
void InitSpring(GEOMETRY *geom);

GEOMETRY cube_geom = {InitCube};
GEOMETRY tetra_geom = {InitTetra};
GEOMETRY pyramids_geom = {InitPyramids};
GEOMETRY cylinder_geom = {InitCylinder};
GEOMETRY spring_geom = {InitSpring};

GEOMETRY *geom_table[] =
{
    &cube_geom,
    &tetra_geom,
    &pyramids_geom,
    &cylinder_geom,
    &spring_geom
};

extern BOOL bOgl11;
extern BOOL bCheckerOn;

/******************************Public*Routine******************************\
*
* InitVlen
*
* Precomputes scaling factor for spherical projection
*
* History:
*  Mon Jul 24 14:59:03 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void InitVlen(GEOMETRY *geom, int npts, PT3 *pts)
{
    FLT d;
    FLT *vl;

    vl = vlen;
    while (npts-- > 0)
    {
        d = V3Len(pts);

        // Don't allow really close points because this leads to
        // numeric instability and really large objects
        assert(d > 0.01f);

        // Geometries are created with size one, filling the area
        // from -.5 to .5.  This leads to distances generally less
        // than one, which leaves off half of the interesting morphing
        // effects due to the projection
        // Scaling up the scaling factor allows the values to
        // be both above and below one
        d *= geom->init_sf;
        
        assert(d > 0.0001f);
        
        *vl++ = (RADIUS-d)/d;
        
#if 0
        dprintf(("Distance is %f, vl %f\n", d, *(vl-1)));
#endif

        pts++;
    }
}

/******************************Public*Routine******************************\
*
* MapToSide
*
* Takes x,y coordinates in the range 0-1 and maps them onto the given
* side plane for the current geometry
*
* History:
*  Mon Jul 24 15:10:34 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void MapToSide(PLANE_MAP *map, FLT x, FLT y, PT3 *pt)
{
    pt->x = x*map->x_axis.x+y*map->y_axis.x+map->base.x;
    pt->y = x*map->x_axis.y+y*map->y_axis.y+map->base.y;
    pt->z = x*map->x_axis.z+y*map->y_axis.z+map->base.z;

#if 0
    dprintf(("Point is %f,%f,%f\n", pt->x, pt->y, pt->z));
#endif
}

void DrawWithVArrays (GEOMETRY *geom)
{
    int side, ss, idc, k;
    unsigned int *idx;

    for (side = 0; side < geom->nsides; side++) {
        geom->sides[side].dBuf = (GLuint *) LocalAlloc (LMEM_FIXED, 
                                                        sizeof (GLuint) * 
                                                        3 * MAXPTS * 2);
        k = 0;
        idx = geom->sides[side].strip_index;
        for (ss = 0; ss < geom->sides[side].nstrips; ss++) {
            if (geom->sides[side].strip_size[ss] < 3) continue;
            for (idc = 2; idc < geom->sides[side].strip_size[ss]; idc++) {
                if (!(idc % 2)) { //even
                    geom->sides[side].dBuf[k++] = *(idx+idc-2); 
                    geom->sides[side].dBuf[k++] = *(idx+idc-1); 
                } else {
                    geom->sides[side].dBuf[k++] = *(idx+idc-1); 
                    geom->sides[side].dBuf[k++] = *(idx+idc-2); 
                }
                geom->sides[side].dBuf[k++] = *(idx+idc); 
            }
            idx += geom->sides[side].strip_size[ss];
        }
        geom->sides[side].num_eles = k;
    }
    glNormalPointer (GL_FLOAT, sizeof (PT3), 
                     (GLfloat *)&(geom->normals[0].x));
    glVertexPointer (3, GL_FLOAT, sizeof (PT3), 
                     (GLfloat *)&(geom->npts[0].x));
    glEnableClientState (GL_VERTEX_ARRAY);
    glEnableClientState (GL_NORMAL_ARRAY);
    
    glDisableClientState (GL_COLOR_ARRAY);
    glDisableClientState (GL_INDEX_ARRAY);
    glDisableClientState (GL_EDGE_FLAG_ARRAY);
    glDisableClientState (GL_TEXTURE_COORD_ARRAY);
}
/******************************Public*Routine******************************\
*
* InitCube
*
* Initialize the cube's geometry
*
* History:
*  Wed Jul 19 14:52:50 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define CUBE_SIDES 6

PLANE_MAP cube_planes[CUBE_SIDES] =
{
    -0.5f, -0.5f,  0.5f,  1.0f,  0.0f, 0.0f, 0.0f, 1.0f, 0.0f,
     0.5f, -0.5f, -0.5f, -1.0f,  0.0f, 0.0f, 0.0f, 1.0f, 0.0f,
     0.5f,  0.5f, -0.5f, -1.0f,  0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  1.0f,  0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f,  1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f
};

#define CUBE_IDX(side, x, y) ((side)*side_pts+(x)*(config.subdiv+1)+(y))

void InitCube(GEOMETRY *geom)
{
    int side, x, y, k, num_in_side;
    PT3 *pt;
    unsigned int *sz, *idx, idc, ss, i0, i1, i2, i3;
    int side_pts;

    side_pts = (config.subdiv+1)*(config.subdiv+1);
    
    geom->nsides = CUBE_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.1f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 2.0f;
    
    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    for (side = 0; side < geom->nsides; side++)
    {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;
        
        for (x = 0; x < config.subdiv; x++)
        {
            *sz++ = (config.subdiv+1)*2;

            for (y = 0; y < config.subdiv+1; y++)
            {
                *idx++ = CUBE_IDX(side, x, y);
                *idx++ = CUBE_IDX(side, x+1, y);
            }
        }
    }

    assert(sz-strip_size <= DIMA(strip_size));
    assert(idx-index <= DIMA(index));

   
    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
#if 0
        dprintf(("Side %d\n", side));
#endif
        
        for (x = 0; x < config.subdiv+1; x++)
        {
            for (y = 0; y < config.subdiv+1; y++)
            {
                MapToSide(&cube_planes[side],
                          (FLT)x/config.subdiv, (FLT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    assert(pt-pts <= DIMA(pts));

    geom->total_pts = geom->nsides*side_pts;
}


/******************************Public*Routine******************************\
*
* InitTetra
*
* Initialize the tetrahedron's geometry
*
* History:
*  Tue Jul 25 11:43:18 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define TETRA_SIDES 4

#define SQRT3 1.73205f
#define SQRT3_2 (SQRT3/2.0f)
#define SQRT3_3 (SQRT3/3.0f)
#define SQRT3_6 (SQRT3/6.0f)
#define SQRT3_12 (SQRT3/12.0f)

#define TETRA_BASE (-SQRT3/8.0f)

PLANE_MAP tetra_planes[TETRA_SIDES] =
{
    -0.5f, TETRA_BASE, SQRT3_6,
    1.0f, 0.0f, 0.0f, 0.0f, SQRT3_2, -SQRT3_6,
    
    0.0f, TETRA_BASE, -SQRT3_3,
    -0.5f, 0.0f, SQRT3_2, 0.25f, SQRT3_2, SQRT3_12,
    
    0.5f, TETRA_BASE, SQRT3_6,
    -0.5f, 0.0f, -SQRT3_2, -0.25f, SQRT3_2, SQRT3_12,
    
    0.5f, TETRA_BASE, SQRT3_6,
    -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -SQRT3_2
};

void InitTetra(GEOMETRY *geom)
{
    int side, x, y, k, ss, num_in_side;
    PT3 *pt;
    int *sz, *idx, idc, i0, i1, i2, i3;
    int side_pts;
    int base_pt;
    int row_pts;
    FLT fx, fy;

    side_pts = (config.subdiv+2)*(config.subdiv+1)/2;
    
    geom->nsides = TETRA_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 3.75f;

    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    base_pt = 0;
    for (side = 0; side < geom->nsides; side++)
    {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;

        for (x = 0; x < config.subdiv; x++)
        {
            row_pts = config.subdiv-x+1;
            *sz++ = row_pts*2-1;

            *idx++ = base_pt;
            for (y = 0; y < row_pts-1; y++)
            {
                *idx++ = base_pt+row_pts+y;
                *idx++ = base_pt+1+y;
            }

            base_pt += row_pts;
        }

        base_pt++;
    }

    assert(sz-strip_size <= DIMA(strip_size));
    assert(idx-index <= DIMA(index));

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
#if 0
        dprintf(("Side %d\n", side));
#endif
        
        for (x = 0; x < config.subdiv+1; x++)
        {
            fx = (FLT)x/config.subdiv;
            for (y = 0; y < config.subdiv-x+1; y++)
            {
                MapToSide(&tetra_planes[side],
                          fx+(FLT)y/(config.subdiv*2),
                          (FLT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    assert(pt-pts <= DIMA(pts));

    geom->total_pts = geom->nsides*side_pts;
}

/******************************Public*Routine******************************\
*
* InitPyramids
*
* Initializes double pyramid geometry
*
* History:
*  Wed Jul 26 18:37:11 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define PYRAMIDS_SIDES 8

PLANE_MAP pyramids_planes[PYRAMIDS_SIDES] =
{
    -0.5f, 0.0f,  0.5f,  1.0f, 0.0f,  0.0f,  0.0f,  0.5f, -0.5f,
     0.5f, 0.0f,  0.5f, -1.0f, 0.0f,  0.0f,  0.0f, -0.5f, -0.5f,
     0.5f, 0.0f,  0.5f,  0.0f, 0.0f, -1.0f, -0.5f,  0.5f,  0.0f,
     0.5f, 0.0f, -0.5f,  0.0f, 0.0f,  1.0f, -0.5f, -0.5f,  0.0f,
     0.5f, 0.0f, -0.5f, -1.0f, 0.0f,  0.0f,  0.0f,  0.5f,  0.5f,
    -0.5f, 0.0f, -0.5f,  1.0f, 0.0f,  0.0f,  0.0f, -0.5f,  0.5f,
    -0.5f, 0.0f, -0.5f,  0.0f, 0.0f,  1.0f,  0.5f,  0.5f,  0.0f,
    -0.5f, 0.0f,  0.5f,  0.0f, 0.0f, -1.0f,  0.5f, -0.5f,  0.0f
};

void InitPyramids(GEOMETRY *geom)
{
    int side, x, y, k, num_in_side;
    PT3 *pt;
    int *sz, *idx, idc, i0, i1, i2, i3, ss;
    int side_pts;
    int base_pt;
    int row_pts;
    FLT fx, fy;

    side_pts = (config.subdiv+2)*(config.subdiv+1)/2;
    
    geom->nsides = PYRAMIDS_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 3.0f;

    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    base_pt = 0;

    for (side = 0; side < geom->nsides; side++) {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;
            
        for (x = 0; x < config.subdiv; x++) {
            row_pts = config.subdiv-x+1;
            *sz++ = row_pts*2-1;

            *idx++ = base_pt;
            for (y = 0; y < row_pts-1; y++) {
                *idx++ = base_pt+row_pts+y;
                *idx++ = base_pt+1+y;
            }

            base_pt += row_pts;
        }
            
        base_pt++;
    }

    assert(sz-strip_size <= DIMA(strip_size));
    assert(idx-index <= DIMA(index));

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
#if 0
        dprintf(("Side %d\n", side));
#endif
        
        for (x = 0; x < config.subdiv+1; x++)
        {
            fx = (FLT)x/config.subdiv;
            for (y = 0; y < config.subdiv-x+1; y++)
            {
                MapToSide(&pyramids_planes[side],
                          fx+(FLT)y/(config.subdiv*2),
                          (FLT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    assert(pt-pts <= DIMA(pts));

    geom->total_pts = geom->nsides*side_pts;
}

/******************************Public*Routine******************************\
*
* InitCylinder
*
* Initializes the cylinder geometry
*
* History:
*  Fri Jul 28 16:12:39 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void InitCylinder(GEOMETRY *geom)
{
    int side, x, y, k, num_in_side;
    PT3 *pt;
    int *sz, *idx, ss, idc, i0, i1, i2, i3;
    int base_pt;
    int row_pts;
    FLT fx, fy, fz;
    double ang;

    geom->nsides = 1;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];

    geom->min_sf = -2.5f;
    geom->max_sf = 8.5f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 2.1f;

    // Generate triangle strip data
    // If version 1.1 then allocate the index buffer for glDrawElements
    sz = &strip_size[0];
    idx = &index[0];
    side = 0;
    geom->sides[side].nstrips = config.subdiv;
    geom->sides[side].strip_size = sz;
    geom->sides[side].strip_index = idx;
    
    row_pts = config.subdiv+1;
    base_pt = 0;
    for (x = 0; x < config.subdiv; x++) {
        *sz++ = row_pts*2;
        
        for (y = 0; y < row_pts; y++) {
            // Wrap around at the edge so the cylinder normals
            // are properly averaged
            if (x == config.subdiv-1) {
                *idx++ = y;
            }
            else {
                *idx++ = base_pt+row_pts+y;
            }
            *idx++ = base_pt+y;
        }

        base_pt += row_pts;
    }
    
    assert(sz-strip_size <= DIMA(strip_size));
    assert(idx-index <= DIMA(index));

    // Generate base vertices
    pt = geom->pts;
    ang = 0;
    for (x = 0; x < config.subdiv; x++)
    {
        fx = (FLT)cos(ang)*0.5f;
        fz = (FLT)sin(ang)*0.5f;
        for (y = 0; y < config.subdiv+1; y++)
        {
            pt->x = fx;
            pt->y = (FLT)y/config.subdiv-0.5f;
            pt->z = fz;
            pt++;
        }
        ang += (2*PI)/config.subdiv;
    }

    assert(pt-pts <= DIMA(pts));

    geom->total_pts = geom->nsides*(config.subdiv+1)*config.subdiv;
}

/******************************Public*Routine******************************\
*
* InitSpring
*
* Initializes the spring geometry
*
* History:
*  Fri Jul 28 16:12:39 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define SPRING_RADIUS 0.1f
#define SPRING_CENTER (0.5f-SPRING_RADIUS)

void InitSpring(GEOMETRY *geom)
{
    int side, x, y, k, num_in_side;
    PT3 *pt;
    int *sz, *idx, idc, ss, i0, i1, i2, i3;
    double ang_center, ang_surf;
    FLT cs, sn;
    FLT rad;
    PLANE_MAP plane;
    int spin_pts;
    int row_pts;

    geom->nsides = 1;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];

    geom->min_sf = -2.2f;
    geom->max_sf = 0.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 1.0f;

    // Generate triangle strip data
    // If version 1.1 then allocate the index buffer for glDrawElements
    sz = &strip_size[0];
    idx = &index[0];
    side = 0;
    geom->sides[side].nstrips = config.subdiv;
    geom->sides[side].strip_size = sz;
    geom->sides[side].strip_index = idx;
    
    row_pts = config.subdiv;
    spin_pts = 4*config.subdiv+1;
    for (x = 0; x < config.subdiv; x++) {
        *sz++ = spin_pts*2;

        for (y = 0; y < spin_pts; y++) {
            *idx++ = x+row_pts*y;
            // Wrap around at the edge so the cylindrical surface
            // of the tube is seamless.  Without this the normal
            // averaging would be incorrect and a seam would be visible
            if (x == config.subdiv-1) {
                *idx++ = row_pts*y;
            }
            else {
                *idx++ = x+row_pts*y+1;
            }
        }
    }
    
    assert(sz-strip_size <= DIMA(strip_size));
    assert(idx-index <= DIMA(index));

    // Generate base vertices
    pt = geom->pts;
    ang_center = 0;
    plane.y_axis.x = 0.0f;
    plane.y_axis.y = SPRING_RADIUS;
    plane.y_axis.z = 0.0f;
    plane.x_axis.y = 0.0f;
    for (x = 0; x < spin_pts; x++)
    {
        cs = (FLT)cos(ang_center);
        sn = (FLT)sin(ang_center);
        rad = 0.5f-(FLT)x/(spin_pts-1)*(SPRING_CENTER/2);
        plane.base.x = cs*rad;
        plane.base.y = -0.5f+(FLT)x/(spin_pts-1);
        plane.base.z = sn*rad;
        plane.x_axis.x = cs*SPRING_RADIUS;
        plane.x_axis.z = sn*SPRING_RADIUS;

        ang_surf = 0;
        for (y = 0; y < config.subdiv; y++)
        {
            MapToSide(&plane,
                      (FLT)cos(ang_surf), (FLT)sin(ang_surf),
                      pt);
            pt++;
            ang_surf += (2*PI)/config.subdiv;
        }
        
        ang_center += (4*PI)/(spin_pts-1);
    }

    assert(pt-pts <= DIMA(pts));

    geom->total_pts = geom->nsides*spin_pts*config.subdiv;
}

/******************************Public*Routine******************************\
*
* DrawGeom
*
* Draw the current geometry
*
* History:
*  Wed Jul 19 14:53:02 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void DrawGeom(GEOMETRY *geom)
{
    int side, strip, k;
    int *idx, idc, idxv;

    if (config.smooth_colors)
    {
        glShadeModel(GL_SMOOTH);
    }
    else
    {
        glShadeModel(GL_FLAT);
    }

    if (config.color_pick == ID_COL_SINGLE)
    {
        glMaterialfv(config.two_sided, GL_DIFFUSE, solid_cols);
    }

#if 1
    if (!(bOgl11 && !bCheckerOn)) {
        for (side = 0; side < geom->nsides; side++) {
            if (config.color_pick == ID_COL_PER_SIDE) {
                glMaterialfv(config.two_sided, GL_DIFFUSE, side_cols[side]);
            }

            idx = geom->sides[side].strip_index;
            for (strip = 0; strip < geom->sides[side].nstrips; strip++) {
                glBegin(GL_TRIANGLE_STRIP);

                for (idc = 0; idc < geom->sides[side].strip_size[strip]; 
                     idc++) {
                    idxv = *idx++;

                    assert(idxv >=0 && idxv < geom->total_pts);

                    if (config.color_pick == ID_COL_CHECKER) {
                        if (config.triangle_colors) {
                            glMaterialfv(config.two_sided, GL_DIFFUSE,
                                         checker_cols[side][(idc+1)/2+strip &
                                                           1]);
                        }
                        else {
                            glMaterialfv(config.two_sided, GL_DIFFUSE,
                                         checker_cols[side][idc/2+strip & 1]);
                        }
                    }
                
                    glNormal3fv((GLfloat *)&geom->normals[idxv]);
                    glVertex3fv((GLfloat *)&geom->npts[idxv]);
                }

                glEnd();
            }
        }
    } else {
        k = 0;
        for (side = 0; side < geom->nsides; side++) {
            if (config.color_pick == ID_COL_PER_SIDE)
                glMaterialfv(config.two_sided, GL_DIFFUSE, side_cols[side]);

            glDrawElements (GL_TRIANGLES, geom->sides[side].num_eles, 
                            GL_UNSIGNED_INT, &(geom->sides[side].dBuf[0]));
            k += geom->sides[side].num_eles;
        }
    }    
#else
    glBegin(GL_POINTS);
    for (side = 0; side < geom->total_pts; side++)
    {
        glVertex3fv((GLfloat *)&geom->npts[side]);
    }
    glEnd();
#endif
}

/******************************Public*Routine******************************\
*
* ComputeAveragedNormals
*
* Compute face-averaged normals for each vertex
*
* History:
*  Wed Jul 19 14:53:13 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ComputeAveragedNormals(GEOMETRY *geom)
{
    int side, strip;
    int *sz;
    int *idx, idx1, idx2, idx3;
    int tc, idc;
    PT3 v1, v2, n1;
    
    memset(geom->normals, 0, sizeof(PT3)*geom->total_pts);
    
    for (side = 0; side < geom->nsides; side++)
    {
        idx = geom->sides[side].strip_index;
        sz = geom->sides[side].strip_size;
        for (strip = 0; strip < geom->sides[side].nstrips; strip++)
        {
            idx1 = *idx++;
            idx2 = *idx++;

            assert(idx1 >= 0 && idx1 < geom->total_pts &&
                   idx2 >= 0 && idx2 < geom->total_pts);
            
            tc = (*sz++)-2;
            for (idc = 0; idc < tc; idc++)
            {
                idx3 = *idx++;

                assert(idx3 >= 0 && idx3 < geom->total_pts);
                
                V3Sub(&geom->npts[idx3], &geom->npts[idx1], &v1);
                V3Sub(&geom->npts[idx2], &geom->npts[idx1], &v2);
                V3Cross(&v1, &v2, &n1);
                // Triangle strip ordering causes half of the triangles
                // to be oriented oppositely from the others
                // Those triangles need to have their normals flipped
                // so the whole triangle strip has consistent normals
                if ((idc & 1) == 0)
                {
                    n1.x = -n1.x;
                    n1.y = -n1.y;
                    n1.z = -n1.z;
                }
                
#if 0
                dprintf(("Normal is %f,%f,%f\n", n1.x, n1.y, n1.z));
#endif

                V3Add(&geom->normals[idx1], &n1, &geom->normals[idx1]);
                V3Add(&geom->normals[idx2], &n1, &geom->normals[idx2]);
                V3Add(&geom->normals[idx3], &n1, &geom->normals[idx3]);

                idx1 = idx2;
                idx2 = idx3;
            }
        }
    }
}

/******************************Public*Routine******************************\
*
* UpdatePts
*
* Project the point array through a sphere according to the given scale factor
*
* History:
*  Wed Jul 19 14:53:53 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void UpdatePts(GEOMETRY *geom, FLT sf)
{
    int pt;
    FLT f, *vl;
    PT3 *v;
    PT3 *p;

    vl = vlen;
    p = &geom->pts[0];
    v = &geom->npts[0];
    for (pt = 0; pt < geom->total_pts; pt++)
    {
        f = (*vl++)*sf+1;
        v->x = p->x*f;
        v->y = p->y*f;
        v->z = p->z*f;
#if 0
        dprintf(("%f: %f,%f,%f to %f,%f,%f by %f\n", sf,
                 p->x, p->y, p->z, v->x, v->y, v->z, f));
#endif
        p++;
        v++;
    }

    ComputeAveragedNormals(geom);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\texture.c ===
/******************************Module*Header*******************************\
* Module Name: texture.c
*
* Texture handling functions
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>
#include <scrnsave.h>
#include <commdlg.h>
#include <GL/gl.h>
#include "tk.h"

#include "scrnsave.h"  // for hMainInstance
#include "sscommon.h"
#include "texture.h"

static int ProcessTexture( TEXTURE *pTex );
static int ProcessTkTexture( TK_RGBImageRec *image, TEXTURE *pTex );
static int VerifyTextureFile( TEXFILE *pTexFile );
static int GetTexFileType( TEXFILE *pTexFile );

static TEX_STRINGS gts = {0};
BOOL gbTextureObjects = FALSE;
static BOOL gbPalettedTexture = FALSE;
static PFNGLCOLORTABLEEXTPROC pfnColorTableEXT;
static PFNGLCOLORSUBTABLEEXTPROC pfnColorSubTableEXT;

static BOOL gbEnableErrorMsgs = FALSE;

/******************************Public*Routine******************************\
*
* ss_LoadTextureResourceStrings
*
* Load various messages and strings that are used in processing textures,
* into global TEX_STRINGS structure
*
\**************************************************************************/

BOOL
ss_LoadTextureResourceStrings()
{
    LPTSTR pszStr;

    // title for choose texture File dialog
    LoadString(hMainInstance, IDS_TEXTUREDIALOGTITLE, gts.szTextureDialogTitle, 
                GEN_STRING_SIZE);
    LoadString(hMainInstance, IDS_BMP, gts.szBmp, GEN_STRING_SIZE);
    LoadString(hMainInstance, IDS_DOTBMP, gts.szDotBmp, GEN_STRING_SIZE);

    // szTextureFilter requires a little more work.  Need to assemble the file
    // name filter string, which is composed of two strings separated by a NULL
    // and terminated with a double NULL.

    LoadString(hMainInstance, IDS_TEXTUREFILTER, gts.szTextureFilter, 
                GEN_STRING_SIZE);
    pszStr = &gts.szTextureFilter[lstrlen(gts.szTextureFilter)+1];
    LoadString(hMainInstance, IDS_STARDOTBMP, pszStr, GEN_STRING_SIZE);
    pszStr += lstrlen(pszStr);
    *pszStr++ = TEXT(';');
    LoadString(hMainInstance, IDS_STARDOTRGB, pszStr, GEN_STRING_SIZE);
    pszStr += lstrlen(pszStr);
    pszStr++;
    *pszStr = TEXT('\0');

    LoadString(hMainInstance, IDS_WARNING, gts.szWarningMsg, MAX_PATH);
    LoadString(hMainInstance, IDS_SELECT_ANOTHER_BITMAP, 
                gts.szSelectAnotherBitmapMsg, MAX_PATH );

    LoadString(hMainInstance, IDS_BITMAP_INVALID, 
                gts.szBitmapInvalidMsg, MAX_PATH );
    LoadString(hMainInstance, IDS_BITMAP_SIZE, 
                gts.szBitmapSizeMsg, MAX_PATH );

    // assumed here that all above calls loaded properly (mf: fix later)
    return TRUE;
}

/******************************Public*Routine******************************\
*
*
\**************************************************************************/

void
ss_DisableTextureErrorMsgs()
{
    gbEnableErrorMsgs = FALSE;
}

/******************************Public*Routine******************************\
*
* ss_LoadBMPTextureFile
*
* Loads a BMP file and prepares it for GL usage
*
\**************************************************************************/

int 
ss_LoadBMPTextureFile( LPCTSTR pszBmpfile, TEXTURE *pTex )
{
    TK_RGBImageRec *image = (TK_RGBImageRec *) NULL;

#ifdef UNICODE
    image = tkDIBImageLoadAW( (char *) pszBmpfile, TRUE );
#else
    image = tkDIBImageLoadAW( (char *) pszBmpfile, FALSE );
#endif

    if( !image )  {
        return 0;
    }
    return ProcessTkTexture( image, pTex );
}

/******************************Public*Routine******************************\
*
* ss_LoadTextureFile
*
* Loads a BMP file and prepares it for GL usage
*
\**************************************************************************/

int 
ss_LoadTextureFile( TEXFILE *pTexFile, TEXTURE *pTex )
{
    TK_RGBImageRec *image = (TK_RGBImageRec *) NULL;
    LPTSTR pszBmpfile = pTexFile->szPathName;
    int type;
    LPTSTR pszStr;

    // Verify file / set type
    
    if( !(type = VerifyTextureFile( pTexFile )) )
        return 0;

    if( type == TEX_BMP ) {

#ifdef UNICODE
        image = tkDIBImageLoadAW( (char *) pszBmpfile, TRUE );
#else
        image = tkDIBImageLoadAW( (char *) pszBmpfile, FALSE );
#endif
    } else {
#ifdef UNICODE
        image = tkRGBImageLoadAW( (char *) pszBmpfile, TRUE );
#else
        image = tkRGBImageLoadAW( (char *) pszBmpfile, FALSE );
#endif
    }

    if( !image )  {
        return 0;
    }
    return ProcessTkTexture( image, pTex );
}

/******************************Public*Routine******************************\
*
* ss_LoadTextureResource
*
* Loads a BMP or RGB texture resource and prepares it for GL usage
*
\**************************************************************************/

int 
ss_LoadTextureResource( TEX_RES *pTexRes, TEXTURE *pTex )
{
    HMODULE ghmodule;
    HRSRC hr;
    HGLOBAL hg;
    LPVOID pv;
    LPCTSTR lpType;
    BOOL fLoaded = FALSE;

    ghmodule = GetModuleHandle(NULL);
    switch(pTexRes->type)
    {
    case TEX_RGB:
        lpType = MAKEINTRESOURCE(RT_RGB);
        break;
    case TEX_BMP:
        lpType = MAKEINTRESOURCE(RT_MYBMP);
        break;
    case TEX_A8:
        lpType = MAKEINTRESOURCE(RT_A8);
        break;
    }

    hr = FindResource(ghmodule, MAKEINTRESOURCE(pTexRes->name), lpType);
    if (hr == NULL)
    {
        goto EH_NotFound;
    }
    hg = LoadResource(ghmodule, hr);
    if (hg == NULL)
    {
        goto EH_FreeResource;
    }
    pv = (PSZ)LockResource(hg);
    if (pv == NULL)
    {
        goto EH_FreeResource;
    }

    switch(pTexRes->type)
    {
    case TEX_RGB:
        fLoaded = ss_RGBImageLoad( pv, pTex );
        break;
    case TEX_BMP:
        fLoaded = ss_DIBImageLoad( pv, pTex );
        break;
    case TEX_A8:
        fLoaded = ss_A8ImageLoad( pv, pTex );
        break;
    }

 EH_FreeResource:
    FreeResource(hr);
 EH_NotFound:
    
    if( !fLoaded )  {
        return 0;
    }

    return ProcessTexture( pTex );
}


/******************************Public*Routine******************************\
*
* ValidateTextureSize
* 
* - Scales the texture to powers of 2
*
\**************************************************************************/

static BOOL
ValidateTextureSize( TEXTURE *pTex )
{
    double xPow2, yPow2;
    int ixPow2, iyPow2;
    int xSize2, ySize2;
    float fxFact, fyFact;
    GLint glMaxTexDim;

    if( (pTex->width <= 0) || (pTex->height <= 0) ) {
        SS_WARNING( "ValidateTextureSize : invalid texture dimensions\n" );
        return FALSE;
    }

    pTex->origAspectRatio = (float) pTex->height / (float) pTex->width;

    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &glMaxTexDim);
    if( glMaxTexDim <= 0 )
        return FALSE;

    if( pTex->format != GL_COLOR_INDEX ) {

        // We limit the max dimension here for performance reasons
        glMaxTexDim = min(256, glMaxTexDim);

        if (pTex->width <= glMaxTexDim)
            xPow2 = log((double)pTex->width) / log((double)2.0);
        else
            xPow2 = log((double)glMaxTexDim) / log((double)2.0);

        if (pTex->height <= glMaxTexDim)
            yPow2 = log((double)pTex->height) / log((double)2.0);
        else
            yPow2 = log((double)glMaxTexDim) / log((double)2.0);

        ixPow2 = (int)xPow2;
        iyPow2 = (int)yPow2;

        // Always scale to higher nearest power
        if (xPow2 != (double)ixPow2)
            ixPow2++;
        if (yPow2 != (double)iyPow2)
            iyPow2++;

        xSize2 = 1 << ixPow2;
        ySize2 = 1 << iyPow2;

        if (xSize2 != pTex->width ||
            ySize2 != pTex->height)
        {
            BYTE *pData;

            pData = (BYTE *) malloc(xSize2 * ySize2 * pTex->components * sizeof(BYTE));
            if (!pData) {
                SS_WARNING( "ValidateTextureSize : can't alloc pData\n" );
                return FALSE;
            }

            glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

            if( gluScaleImage(pTex->format, pTex->width, pTex->height,
                      GL_UNSIGNED_BYTE, pTex->data,
                      xSize2, ySize2, GL_UNSIGNED_BYTE,
                      pData) )
            {
                // glu failure
                SS_WARNING( "ValidateTextureSize : gluScaleImage failure\n" );
                free(pData);
                return FALSE;
            }
        
            // set the new width,height,data
            pTex->width = xSize2;
            pTex->height = ySize2;
            free(pTex->data);
            pTex->data = pData;
        }
    } else {  // paletted texture case
        //mf
        // paletted texture: must be power of 2 - but might need to enforce
        // here if not done in a8 load.  Also have to check against
        // GL_MAX_TEXTURE_SIZE.  Could then clip it to power of 2 size
    }
    return TRUE;
}

/******************************Public*Routine******************************\
*
* SetDefaultTextureParams
*
\**************************************************************************/

static void
SetDefaultTextureParams()
{
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
}

/******************************Public*Routine******************************\
*
* ProcessTexture
*
* - Verifies texture size
* - Fills out TEXTURE structure with required data
* - Creates a texture object if extension exists
*
\**************************************************************************/

static int 
ProcessTexture( TEXTURE *pTex )
{
    // Enforce proper texture size (power of 2, etc.)

    if( !ValidateTextureSize( pTex ) )
        return 0;

    // if texturing objects available, init the object
    if( gbTextureObjects ) {
        glGenTextures( 1, &pTex->texObj );
        glBindTexture( GL_TEXTURE_2D, pTex->texObj );

        // Default attributes for texObj
        SetDefaultTextureParams();

        glTexImage2D( GL_TEXTURE_2D, 0, pTex->components,
                      pTex->width, pTex->height, 0, pTex->format,
                      GL_UNSIGNED_BYTE, pTex->data );
        
        if (gbPalettedTexture && pTex->pal != NULL)
        {
            pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTex->pal_size,
                             GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTex->pal);
        }
    } else
        pTex->texObj = 0;

    return 1;
}

/******************************Public*Routine******************************\
*
* ProcessTkTexture
*
* Simple wrapper for ProcessTexture which fills out a TEXTURE
* from a TK_RGBImageRec
*
* Frees the ImageRec if ProcessTexture succeeds
*
\**************************************************************************/

static int
ProcessTkTexture( TK_RGBImageRec *image, TEXTURE *pTex )
{

    pTex->width = image->sizeX;
    pTex->height = image->sizeY;
    pTex->format = GL_RGB;
    pTex->components = 3;
    pTex->data = image->data;
    pTex->pal_size = 0;
    pTex->pal = NULL;

    if( ProcessTexture( pTex ) )
    {
        free(image);
        return 1;
    }
    else
    {
        return 0;
    }
}
    
/******************************Public*Routine******************************\
*
* ss_SetTexture
*
\**************************************************************************/

void
ss_SetTexture( TEXTURE *pTex )
{
    if( pTex == NULL )
        return;

    if( gbTextureObjects && pTex->texObj ) {
        glBindTexture( GL_TEXTURE_2D, pTex->texObj );
        return;
    }
    
    glTexImage2D( GL_TEXTURE_2D, 0, pTex->components,
                  pTex->width, pTex->height, 0, pTex->format,
                  GL_UNSIGNED_BYTE, pTex->data );
        
    if (gbPalettedTexture && pTex->pal != NULL)
    {
        pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTex->pal_size,
                         GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTex->pal);
    }
}

    
/******************************Public*Routine******************************\
*
* ss_CopyTexture
*
* Make a copy of a texture.
*
\**************************************************************************/

BOOL
ss_CopyTexture( TEXTURE *pTexDst, TEXTURE *pTexSrc )
{
    int size;

    if( (pTexDst == NULL) || (pTexSrc == NULL) )
        return FALSE;

    *pTexDst = *pTexSrc;

    if( gbTextureObjects && pTexSrc->texObj ) {
        glGenTextures( 1, &pTexDst->texObj );
    }
    
    // copy image data

    size = pTexSrc->width * pTexSrc->height;
    if( pTexSrc->components != GL_COLOR_INDEX8_EXT )
        size *= pTexSrc->components; // since data format always UNSIGNED_BYTE

    pTexDst->data = (unsigned char *) malloc( size );
    if( pTexDst->pal == NULL )
        return FALSE;
    memcpy( pTexDst->data, pTexSrc->data, size );

    // copy palette data

    if( gbPalettedTexture && pTexSrc->pal != NULL )
    {
        size = pTexSrc->pal_size*sizeof(RGBQUAD);
        pTexDst->pal = (RGBQUAD *) malloc(size);
        if( pTexDst->pal == NULL )
        {
            free(pTexDst->data);
            return FALSE;
        }
        memcpy( pTexDst->pal, pTexSrc->pal, size );
    }
    
    if( gbTextureObjects ) {
        glBindTexture( GL_TEXTURE_2D, pTexDst->texObj );

        // Default attributes for texObj
        SetDefaultTextureParams();

        glTexImage2D( GL_TEXTURE_2D, 0, pTexDst->components,
                      pTexDst->width, pTexDst->height, 0, pTexDst->format,
                      GL_UNSIGNED_BYTE, pTexDst->data );
        
        if( gbPalettedTexture && (pTexDst->pal != NULL) )
        {
            pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTexDst->pal_size,
                             GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTexDst->pal);
        }
    }
    return TRUE;
}

/******************************Public*Routine******************************\
*
* ss_SetTexturePalette
*
* Set a texture's palette according to the supplied index. This index
* indicates the start of the palette, which then wraps around if necessary.
* Of course this only works on paletted textures.
*
\**************************************************************************/

void
ss_SetTexturePalette( TEXTURE *pTex, int index )
{
    if( pTex == NULL )
        return;

    if( gbTextureObjects )
        ss_SetTexture( pTex );

    if( gbPalettedTexture && pTex->pal != NULL )
    {
        int start, count;

        start = index & (pTex->pal_size - 1);
        count = pTex->pal_size - start;
        pfnColorSubTableEXT(GL_TEXTURE_2D, 0, count, GL_BGRA_EXT,
                            GL_UNSIGNED_BYTE, pTex->pal + start);
        if (start != 0)
        {
            pfnColorSubTableEXT(GL_TEXTURE_2D, count, start, GL_BGRA_EXT,
                                GL_UNSIGNED_BYTE, pTex->pal);
        }
    }
}

/******************************Public*Routine******************************\
*
* SetTextureAlpha
*
* Set a constant alpha value for the texture
* Again, don't overwrite any existing 0 alpha values, as explained in
* ss_SetTextureTransparency
*
\**************************************************************************/

static void
SetTextureAlpha( TEXTURE *pTex, float fAlpha )
{
    int i;
    unsigned char *pData = pTex->data;
    RGBA8 *pColor = (RGBA8 *) pTex->data;
    BYTE bAlpha = (BYTE) (fAlpha * 255.0f);

    if( pTex->components != 4 )
        return;

    for( i = 0; i < pTex->width*pTex->height; i ++, pColor++ ) {
        if( pColor->a != 0 ) 
            pColor->a = bAlpha;
    }
}

/******************************Public*Routine******************************\
*
* ConvertTextureToRGBA
*
* Convert RGB texture to RGBA
*
\**************************************************************************/

static void
ConvertTextureToRGBA( TEXTURE *pTex, float fAlpha )
{
    unsigned char *pNewData;
    int count = pTex->width * pTex->height;
    unsigned char *src, *dst;
    BYTE bAlpha = (BYTE) (fAlpha * 255.0f);
    int i;

    pNewData = (unsigned char *) LocalAlloc(LMEM_FIXED, count * sizeof(RGBA8));
    if( !pNewData )
        return;

    src = pTex->data;
    dst = pNewData;
    // Note: the color ordering is ABGR, where R is lsb
    for( i = 0; i < count; i ++ ) {
        *((RGB8 *)dst) = *((RGB8 *)src);
        dst += sizeof(RGB8);
        src += sizeof(RGB8);
        *dst++ = bAlpha;
    }
    LocalFree( pTex->data );
    pTex->data = pNewData;
    pTex->components = 4;
    pTex->format = GL_RGBA;
}

/******************************Public*Routine******************************\
*
* ss_SetTextureTransparency
*
* Set transparency for a texture by adding or modifying the alpha data.  
* Transparency value must be between 0.0 (opaque) and 1.0 (fully transparent)
* If the texture data previously had no alpha, add it in.
* If bSet is TRUE, make this the current texture.
*
* Note: Currently fully transparent pixels (alpha=0) will not be altered, since
* it is assumed these should be permanently transparent (could make this an
* option? - bPreserveTransparentPixels )
*
\**************************************************************************/

BOOL
ss_SetTextureTransparency( TEXTURE *pTex, float fTransp, BOOL bSet )
{
    int i;
    float fAlpha;

    if( pTex == NULL )
        return FALSE;

    SS_CLAMP_TO_RANGE2( fTransp, 0.0f, 1.0f );
    fAlpha = 1 - fTransp;

    if( pTex->format == GL_COLOR_INDEX )
    {
        // just need to modify the palette
            RGBQUAD *pPal = pTex->pal;
            BYTE bAlpha = (BYTE) (fAlpha * 255.0f);

            if( !pPal )
                return FALSE;

            for( i = 0; i < pTex->pal_size; i ++, pPal++ ) {
                if( pPal->rgbReserved != 0 )
                    pPal->rgbReserved = bAlpha;
            }
        
            // need to send down the new palette for texture objects
            if( gbTextureObjects && gbPalettedTexture )
            {
                glBindTexture( GL_TEXTURE_2D, pTex->texObj );
                pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTex->pal_size,
                                 GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTex->pal);
            }
    }
    else {
        // Need to setup new texture data
        if( pTex->components != 4 ) {
            // Make room for alpha component
            //mf: ? change to bAlpha ?
            ConvertTextureToRGBA( pTex, fAlpha );
        } else {
            // Set alpha component
            SetTextureAlpha( pTex, fAlpha );
        }
        // Send down new data if texture objects
        if( gbTextureObjects )
        {
            glBindTexture( GL_TEXTURE_2D, pTex->texObj );
            glTexImage2D( GL_TEXTURE_2D, 0, pTex->components,
                          pTex->width, pTex->height, 0, pTex->format,
                          GL_UNSIGNED_BYTE, pTex->data );
        }
    }

    if( bSet )
        ss_SetTexture( pTex );

    return TRUE;
}

/******************************Public*Routine******************************\
*
* ss_DeleteTexture
*
\**************************************************************************/

void
ss_DeleteTexture( TEXTURE *pTex )
{
    if( pTex == NULL )
        return;

    if( gbTextureObjects && pTex->texObj ) {
        glDeleteTextures( 1, &pTex->texObj );
        pTex->texObj = 0;
    }
    if (pTex->pal != NULL)
    {
        free(pTex->pal);
    }
    if( pTex->data )
        free( pTex->data );
}



/******************************Public*Routine******************************\
*
* ss_TextureObjectsEnabled
*
* Returns BOOL set by ss_QueryGLVersion (Texture Objects only supported on
* GL v.1.1 or greater)
*
\**************************************************************************/

BOOL
ss_TextureObjectsEnabled( void )
{
    return gbTextureObjects;
}

/******************************Public*Routine******************************\
*
* ss_PalettedTextureEnabled
*
* Returns result from ss_QueryPalettedTextureEXT
*
\**************************************************************************/

BOOL
ss_PalettedTextureEnabled( void )
{
    return gbPalettedTexture;
}

/******************************Public*Routine******************************\
*
* ss_QueryPalettedTextureEXT
*
* Queries the OpenGL implementation to see if paletted texture is supported
* Typically called once at app startup.
*
\**************************************************************************/

BOOL
ss_QueryPalettedTextureEXT( void )
{
    PFNGLGETCOLORTABLEPARAMETERIVEXTPROC pfnGetColorTableParameterivEXT;
    int size;

    pfnColorTableEXT = (PFNGLCOLORTABLEEXTPROC)
        wglGetProcAddress("glColorTableEXT");
    if (pfnColorTableEXT == NULL)
        return FALSE;
    pfnColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC)
        wglGetProcAddress("glColorSubTableEXT");
    if (pfnColorSubTableEXT == NULL)
        return FALSE;
        
    // Check color table size
    pfnGetColorTableParameterivEXT = (PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
        wglGetProcAddress("glGetColorTableParameterivEXT");
    if (pfnGetColorTableParameterivEXT == NULL)
        return FALSE;
    // For now, the only paletted textures supported in this lib are TEX_A8,
    // with 256 color table entries.  Make sure the device supports this.
    pfnColorTableEXT(GL_PROXY_TEXTURE_2D, GL_RGBA, 256,
                     GL_BGRA_EXT, GL_UNSIGNED_BYTE, NULL );
    pfnGetColorTableParameterivEXT( GL_PROXY_TEXTURE_2D, 
                                    GL_COLOR_TABLE_WIDTH_EXT, &size );
    if( size != 256 )
        // The device does not support a color table size of 256, so we don't
        // enable paletted textures in general.
        return FALSE;

    return gbPalettedTexture=TRUE;
}


/******************************Public*Routine******************************\
*
* ss_VerifyTextureFile
*
* Validates texture bmp or rgb file, by checking for valid pathname and
* correct format.
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
*  Jul. 25, 95 : [marcfo]
*    - Suppress warning dialog box in child preview mode, as it will
*      be continuously brought up.
*
*  Dec. 12, 95 : [marcfo]
*     - Support .rgb files as well
*
*  Dec. 14, 95 : [marcfo]
*     - Change to have it only check the file path
*
\**************************************************************************/

BOOL
ss_VerifyTextureFile( TEXFILE *ptf )
{
    // Make sure the selected texture file is OK.

    ISIZE size;
    TCHAR szFileName[MAX_PATH];
    PTSTR pszString;
    TCHAR szString[MAX_PATH];

    lstrcpy(szFileName, ptf->szPathName);

    if ( SearchPath(NULL, szFileName, NULL, MAX_PATH,
                     ptf->szPathName, &pszString)
       )
    {
        ptf->nOffset = (int)((ULONG_PTR)(pszString - ptf->szPathName));
        return TRUE;
    }
    else
    {
        lstrcpy(ptf->szPathName, szFileName);    // restore

        if( !ss_fOnWin95() && gbEnableErrorMsgs )
        {
            wsprintf(szString, gts.szSelectAnotherBitmapMsg, ptf->szPathName);
            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK);
        }
        return FALSE;
    }
}


/******************************Public*Routine******************************\
*
* ss_SelectTextureFile
*
* Use the common dialog GetOpenFileName to get the name of a bitmap file
* for use as a texture.  This function will not return until the user
* either selects a valid bitmap or cancels.  If a valid bitmap is selected
* by the user, the global array szPathName will have the full path
* to the bitmap file and the global value nOffset will have the
* offset from the beginning of szPathName to the pathless file name.
*
* If the user cancels, szPathName and nOffset will remain
* unchanged.
*
* History:
*  10-May-1994 -by- Gilman Wong [gilmanw]
*    - Wrote it.
*  Apr. 28, 95 : [marcfo]
*    - Modified for common use
*  Dec. 12, 95 : [marcfo]
*    - Support .rgb files as well
*
\**************************************************************************/

BOOL
ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf )
{
    OPENFILENAME ofn;
    TCHAR dirName[MAX_PATH];
    TEXFILE newTexFile;
    LPTSTR pszFileName = newTexFile.szPathName;
    TCHAR origPathName[MAX_PATH];
    PTSTR pszString;
    BOOL bTryAgain, bFileSelected;

//mf: 
    gbEnableErrorMsgs = TRUE;

    // Make a copy of the original file path name, so we can tell if
    // it changed or not
    lstrcpy( origPathName, ptf->szPathName );

    // Make dialog look nice by parsing out the initial path and
    // file name from the full pathname.  If this isn't done, then
    // dialog has a long ugly name in the file combo box and
    // directory will end up with the default current directory.

    if (ptf->nOffset) {
    // Separate the directory and file names.

        lstrcpy(dirName, ptf->szPathName);
        dirName[ptf->nOffset-1] = L'\0';
        lstrcpy(pszFileName, &ptf->szPathName[ptf->nOffset]);
    }
    else {
    // If nOffset is zero, then szPathName is not a full path.
    // Attempt to make it a full path by calling SearchPath.

        if ( SearchPath(NULL, ptf->szPathName, NULL, MAX_PATH,
                         dirName, &pszString) )
        {
        // Successful.  Go ahead a change szPathName to the full path
        // and compute the filename offset.

            lstrcpy(ptf->szPathName, dirName);
            ptf->nOffset = (int)((ULONG_PTR)(pszString - dirName));

        // Break the filename and directory paths apart.

            dirName[ptf->nOffset-1] = TEXT('\0');
            lstrcpy(pszFileName, pszString);
        }

    // Give up and use the Windows system directory.

        else
        {
            GetWindowsDirectory(dirName, MAX_PATH);
            lstrcpy(pszFileName, ptf->szPathName);
        }
    }

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = gts.szTextureFilter;
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = pszFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = (LPTSTR) NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = dirName;
    ofn.lpstrTitle = gts.szTextureDialogTitle;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = gts.szBmp;
    ofn.lCustData = 0;
    ofn.lpfnHook = (LPOFNHOOKPROC) NULL;
    ofn.lpTemplateName = (LPTSTR) NULL;

    do {
    // Invoke the common file dialog.  If it succeeds, then validate
    // the bitmap file.  If not valid, make user try again until either
    // they pick a good one or cancel the dialog.

        bTryAgain = FALSE;

        if ( bFileSelected = GetOpenFileName(&ofn) ) {
            ISIZE size;

            newTexFile.nOffset = ofn.nFileOffset;
            if( VerifyTextureFile( &newTexFile ) ) {
                // copy in new file and offset
                *ptf = newTexFile;
            }
            else {
                bTryAgain = TRUE;
            }
        }

    // If need to try again, recompute dir and file name so dialog
    // still looks nice.

        if (bTryAgain && ofn.nFileOffset) {
            lstrcpy(dirName, pszFileName);
            dirName[ofn.nFileOffset-1] = L'\0';
            lstrcpy(pszFileName, &pszFileName[ofn.nFileOffset]);
        }

    } while (bTryAgain);

    gbEnableErrorMsgs = FALSE;

    if( bFileSelected ) {
        if( lstrcmpi( origPathName, ptf->szPathName ) )
            // a different file was selected
            return TRUE;
    }
    return FALSE;
}


/******************************Public*Routine******************************\
*
* ss_GetDefaultBmpFile
*
* Determine a default bitmap file to use for texturing, if none
* exists yet in the registry.  
*
* Put default in BmpFile parameter.   DotBmp parameter is the bitmap
* extension (usually .bmp).
*
* We have to synthesise the name from the ProductType registry entry.
* Currently, this can be WinNT, LanmanNT, or Server.  If it is
* WinNT, the bitmap is winnt.bmp.  If it is LanmanNT or Server,
* the bitmap is lanmannt.bmp.
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
*  Jul. 27, 95 : [marcfo]
*    - Added support for win95
*
*  Apr. 23, 96 : [marcfo]
*    - Return NULL string for win95
*
\**************************************************************************/

void
ss_GetDefaultBmpFile( LPTSTR pszBmpFile )
{
    HKEY   hkey;
    LONG   cjDefaultBitmap = MAX_PATH;

    if( ss_fOnWin95() )
        // There is no 'nice' bmp file on standard win95 installations
        lstrcpy( pszBmpFile, TEXT("") );
    else {
        if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 (LPCTSTR) TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                 0,
                 KEY_QUERY_VALUE,
                 &hkey) == ERROR_SUCCESS )
        {

            if ( RegQueryValueEx(hkey,
                                  TEXT("ProductType"),
                                  (LPDWORD) NULL,
                                  (LPDWORD) NULL,
                                  (LPBYTE) pszBmpFile,
                                  (LPDWORD) &cjDefaultBitmap) == ERROR_SUCCESS
                 && (cjDefaultBitmap / sizeof(TCHAR) + 4) <= MAX_PATH )
                lstrcat( pszBmpFile, gts.szDotBmp );
            else
                lstrcpy( pszBmpFile, TEXT("winnt.bmp") );

            RegCloseKey(hkey);
        }
        else
            lstrcpy( pszBmpFile, TEXT("winnt.bmp") );

    // If its not winnt.bmp, then its lanmannt.bmp.  (This would be a lot
    // cleaner both in the screen savers and for usersrv desktop bitmap
    // initialization if the desktop bitmap name were stored in the
    // registry).

        if ( lstrcmpi( pszBmpFile, TEXT("winnt.bmp") ) != 0 )
            lstrcpy( pszBmpFile, TEXT("lanmannt.bmp") );
    }
}

/******************************Public*Routine******************************\
*
* VerifyTextureFile
*
* Verify that a bitmap or rgb file is valid
*
* Returns:
*   File type (RGB or BMP) if valid file; otherwise, 0.
*
* History
*  Dec. 12, 95 : [marcfo]
*    - Creation
*
\**************************************************************************/

static int
VerifyTextureFile( TEXFILE *pTexFile )
{
    int type;
    ISIZE size;
    BOOL bValid;
    TCHAR szString[2 * MAX_PATH]; // May contain a pathname

    // check for 0 offset and null strings
    if( (pTexFile->nOffset == 0) || (*pTexFile->szPathName == 0) )
        return 0;

    type = GetTexFileType( pTexFile );

    switch( type ) {
        case TEX_BMP:
            bValid = bVerifyDIB( pTexFile->szPathName, &size );
            break;
        case TEX_RGB:
            bValid = bVerifyRGB( pTexFile->szPathName, &size );
            break;
        case TEX_UNKNOWN:
        default:
            bValid = FALSE;
    }

    if( !bValid ) {
        if( gbEnableErrorMsgs ) {
            wsprintf(szString, gts.szSelectAnotherBitmapMsg, pTexFile->szPathName);
            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK);
        }
        return 0;
    }

    // Check size ?

    if ( (size.width > TEX_WIDTH_MAX)     || 
         (size.height > TEX_HEIGHT_MAX) )
    {
        if( gbEnableErrorMsgs )
        {
            wsprintf(szString, gts.szBitmapSizeMsg, 
                      TEX_WIDTH_MAX, TEX_HEIGHT_MAX);
            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK);
        }
        return 0;
    }

    return type;
}

/******************************Public*Routine******************************\
*
* ss_InitAutoTexture
*
* Generate texture coordinates automatically.
* If pTexRep is not NULL, use it to set the repetition of the generated
* texture.
*
\**************************************************************************/

void
ss_InitAutoTexture( TEX_POINT2D *pTexRep )
{
    GLfloat sgenparams[] = {1.0f, 0.0f, 0.0f, 0.0f};
    GLfloat tgenparams[] = {0.0f, 1.0f, 0.0f, 0.0f};

    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
    if( pTexRep )
        sgenparams[0] = pTexRep->s;
    glTexGenfv(GL_S, GL_OBJECT_PLANE, sgenparams );

    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
    if( pTexRep )
        tgenparams[0] = pTexRep->t;
    glTexGenfv(GL_T, GL_OBJECT_PLANE, tgenparams );

    glEnable(GL_TEXTURE_GEN_S);
    glEnable(GL_TEXTURE_GEN_T);
    glEnable( GL_TEXTURE_2D );
}

/******************************Public*Routine******************************\
*
* GetTexFileType
*
* Determine if a texture file is rgb or bmp, based on extension.  This is
* good enough, as the open texture dialog only shows files with these
* extensions.
*
\**************************************************************************/

static int
GetTexFileType( TEXFILE *pTexFile )
{
    LPTSTR pszStr;

#ifdef UNICODE
    pszStr = wcsrchr( pTexFile->szPathName + pTexFile->nOffset, 
             (USHORT) L'.' );
#else
    pszStr = strrchr( pTexFile->szPathName + pTexFile->nOffset, 
             (USHORT) L'.' );
#endif
    if( !pszStr || (lstrlen(++pszStr) == 0) )
        return TEX_UNKNOWN;

    if( !lstrcmpi( pszStr, TEXT("bmp") ) )
        return TEX_BMP;
    else if( !lstrcmpi( pszStr, TEXT("rgb") ) )
        return TEX_RGB;
    else
        return TEX_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\flwbox\geom.h ===
/**********************************Module**********************************\
*
* geom.h
*
* 3D FlowerBox screen saver
* Geometry header file
*
* History:
*  Wed Jul 19 14:50:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GEOM_H__
#define __GEOM_H__

// Geometry of a shape

// A side of a shape
typedef struct _SIDE
{
    // Number of triangle strips in this side
    int nstrips;
    // Number of vertices per strip
    int *strip_size;
    // Indices for each point in the triangle strips
    unsigned int *strip_index;

    // The number of elements for glDrawElements call
    int num_eles;
    // Index buffer for glDrawElements
    GLuint *dBuf;
} SIDE;

typedef struct _GEOMETRY
{
    void (*init)(struct _GEOMETRY *geom);
    
    // Number of sides
    int nsides;
    // Sides
    SIDE sides[MAXSIDES];

    // Data for each vertex in the shape
    PT3 *pts, *npts;
    PT3 *normals;

    // Total number of vertices
    int total_pts;

    // Scaling control
    FLT min_sf, max_sf, sf_inc;

    // Initial scale factor setup control
    FLT init_sf;

} GEOMETRY;

#define GEOM_CUBE       0
#define GEOM_TETRA      1
#define GEOM_PYRAMIDS   2

extern GEOMETRY *geom_table[];

void InitVlen(GEOMETRY *geom, int npts, PT3 *pts);
void UpdatePts(GEOMETRY *geom, FLT sf);
void DrawGeom(GEOMETRY *geom);
extern void DrawWithVArrays (GEOMETRY *geom);

#endif // __GEOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\common\util.cxx ===
/******************************Module*Header*******************************\
* Module Name: util.cxx
*
* Misc. utility functions
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <sys/timeb.h>
#include <GL/gl.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <math.h>
#include "ssintrnl.hxx"
#include "util.hxx"


/******************************Public*Routine******************************\
* SS_TIME class
*
\**************************************************************************/

void
SS_TIME::Update()
{
    struct _timeb time;

    _ftime( &time );
    seconds = time.time + time.millitm/1000.0;
}

void
SS_TIME::Zero()
{
    seconds = 0.0;
}

double
SS_TIME::Seconds()
{
    return seconds;
}

SS_TIME
SS_TIME::operator+( SS_TIME addTime )
{
    return( *this += addTime );
}


SS_TIME
SS_TIME::operator-( SS_TIME subTime )
{
    return( *this -= subTime );
}

SS_TIME
SS_TIME::operator+=( SS_TIME addTime )
{
    seconds += addTime.seconds;
    return *this;
}

SS_TIME
SS_TIME::operator-=( SS_TIME subTime )
{
    seconds -= subTime.seconds;
    return *this;
}

/******************************Public*Routine******************************\
* SS_TIMER class
*
\**************************************************************************/

void
SS_TIMER::Start()
{
    startTime.Update();
}

SS_TIME
SS_TIMER::Stop()
{
    elapsed.Update();
    return elapsed - startTime;
}

void
SS_TIMER::Reset()
{
    elapsed.Zero();
}

SS_TIME
SS_TIMER::ElapsedTime()
{
    elapsed.Update();
    return elapsed - startTime;
}

/******************************Public*Routine******************************\
* ss_Rand
*
* Generates integer random number 0..(max-1)
*
\**************************************************************************/

int ss_iRand( int max )
{
    return (int) ( max * ( ((float)rand()) / ((float)(RAND_MAX+1)) ) );
}

/******************************Public*Routine******************************\
* ss_Rand2
*
* Generates integer random number min..max
*
\**************************************************************************/

int ss_iRand2( int min, int max )
{
    if( min == max )
        return min;
    else if( max < min ) {
        int temp = min;
        min = max;
        max = temp;
    }

    return min + (int) ( (max-min+1) * ( ((float)rand()) / ((float)(RAND_MAX+1)) ) );
}

/******************************Public*Routine******************************\
* ss_fRand
*
* Generates float random number min...max
*
\**************************************************************************/

FLOAT ss_fRand( FLOAT min, FLOAT max )
{
    FLOAT diff;

    diff = max - min;
    return min + ( diff * ( ((float)rand()) / ((float)(RAND_MAX)) ) );
}

/******************************Public*Routine******************************\
* ss_RandInit
*
* Initializes the randomizer
*
\**************************************************************************/

void ss_RandInit( void )
{
    struct _timeb time;

    _ftime( &time );
    srand( time.millitm );

    for( int i = 0; i < 10; i ++ )
        rand();
}

#if DBG
/******************************Public*Routine******************************\
* DbgPrint
*
* Formatted string output to the debugger.
*
* History:
*  26-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG
DbgPrint(PCH DebugMessage, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    OutputDebugStringA(buffer);

    va_end(ap);

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\flwbox\precomp.h ===
/**********************************Module**********************************\
*
* precomp.h
*
* Precompiled header file
*
* History:
*  Wed Jul 19 14:50:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>

#include <windows.h>
#include <math.h>
#include <commctrl.h>
#include <scrnsave.h>

#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>


#include <sscommon.h>

#include "rsrc.h"
#include "ssflwbox.h"
#include "geom.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\flwbox\rsrc.h ===
/**********************************Module**********************************\
*
* rsrc.h
*
* Resource definitions
*
* History:
*  Wed Jul 19 14:50:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __RSRC_H__
#define __RSRC_H__

#define ID_COMPLEXITY              401
#define ID_IMAGE_SIZE              402

#define ID_COL_PICK_FIRST          ID_COL_CHECKER
#define ID_COL_CHECKER             500
#define ID_COL_PER_SIDE            501
#define ID_COL_SINGLE              502
#define ID_COL_PICK_LAST           ID_COL_SINGLE
#define ID_COL_PICK_COUNT          (ID_COL_PICK_LAST-ID_COL_PICK_FIRST+1)

#define ID_COL_SMOOTH              550
#define ID_COL_TRIANGLE            551
#define ID_COL_CYCLE               552

#define ID_SPIN                    600
#define ID_BLOOM                   601
#define ID_TWO_SIDED               602

#define ID_GEOM                    650

#define IDS_CONFIG_SMOOTH_COLORS        1000
#define IDS_CONFIG_TRIANGLE_COLORS      1001
#define IDS_CONFIG_CYCLE_COLORS         1002
#define IDS_CONFIG_SPIN                 1003
#define IDS_CONFIG_BLOOM                1004
#define IDS_CONFIG_SUBDIV               1005
#define IDS_CONFIG_COLOR_PICK           1006
#define IDS_CONFIG_IMAGE_SIZE           1007
#define IDS_CONFIG_GEOM                 1008
#define IDS_CONFIG_TWO_SIDED            1009

#define IDS_GEOM_FIRST                  IDS_GEOM_CUBE
#define IDS_GEOM_CUBE                   1025
#define IDS_GEOM_TETRA                  1026
#define IDS_GEOM_PYRAMIDS               1027
#define IDS_GEOM_CYLINDER               1028
#define IDS_GEOM_SPRING                 1029
#define IDS_GEOM_LAST                   IDS_GEOM_SPRING
#define IDS_GEOM_COUNT                  (IDS_GEOM_LAST-IDS_GEOM_FIRST+1)

#define IDS_INI_SECTION                 1051

#endif // __RSRC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\flwbox\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ssflwbox.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\flwbox\ssflwbox.c ===
/**********************************Module**********************************\
*
* ssflwbox.c
*
* 3D FlowerBox screen saver
*
* History:
*  Wed Jul 19 14:50:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// Minimum and maximum image sizes
#define MINIMAGESIZE 10
#define MAXIMAGESIZE 100

// Color tables for checkboard, per-side and single color modes
GLfloat base_checker_cols[MAXSIDES][NCCOLS][4] =
{
    1.0f, 0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f,
    1.0f, 0.0f, 0.0f, 1.0f
};
GLfloat checker_cols[MAXSIDES][NCCOLS][4];

GLfloat base_side_cols[MAXSIDES][4] =
{
    1.0f, 0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f
};
GLfloat side_cols[MAXSIDES][4];

GLfloat base_solid_cols[4] =
{
    1.0f, 1.0f, 1.0f, 1.0f
};
GLfloat solid_cols[4];

// Current geometry
GEOMETRY *cur_geom;

// Set when a rendering context is available
BOOL gbGlInit = FALSE;

// Common library context
SSContext gssc;

// Spin rotations
double xr = 0, yr = 0, zr = 0;
// Scale factor and increment
FLT sf;
FLT sfi;
// Color cycling hue phase
FLT phase = 0.0f;

// Default configuration
CONFIG config =
{
    TRUE, FALSE, FALSE, TRUE, TRUE, MAXSUBDIV, ID_COL_PER_SIDE,
    (MAXIMAGESIZE+MINIMAGESIZE)/2, GEOM_CUBE, GL_FRONT
};

// A slider range
typedef struct _RANGE
{
    int min_val;
    int max_val;
    int step;
    int page_step;
} RANGE;

RANGE complexity_range = {MINSUBDIV, MAXSUBDIV, 1, 2};
RANGE image_size_range = {MINIMAGESIZE, MAXIMAGESIZE, 1, 10};

// True if the current OpenGL version is 1.1
BOOL bOgl11;

// True if checkered mode is on
BOOL bCheckerOn;

/******************************Public*Routine******************************\
*
* dprintf
*
* Debug output printf
*
* History:
*  Wed Jul 26 15:16:11 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
void dprintf_out(char *fmt, ...)
{
    va_list args;
    char dbg[256];

    va_start(args, fmt);
    vsprintf(dbg, fmt, args);
    va_end(args);
    OutputDebugStringA(dbg);
}
#endif

/******************************Public*Routine******************************\
*
* assert_failed
*
* Assertion failure handler
*
* History:
*  Fri Jul 28 17:40:28 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
void assert_failed(char *file, int line, char *msg)
{
    dprintf(("Assertion failed %s(%d): %s\n", file, line, msg));
    DebugBreak();
}
#endif

/******************************Public*Routine******************************\
*
* V3Len
*
* Vector length
*
* History:
*  Wed Jul 19 14:52:21 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

FLT V3Len(PT3 *v)
{
    return (FLT)sqrt(v->x*v->x+v->y*v->y+v->z*v->z);
}

/******************************Public*Routine******************************\
*
* ComputeHsvColors
*
* Compute a smooth range of colors depending on the current color mode
*
* History:
*  Wed Jul 19 14:53:32 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void ComputeHsvColors(void)
{
    GLfloat *cols;
    int ncols;
    FLT ang, da;
    int hex;
    FLT fhex, frac;
    FLT p, q, t;
    FLT sat, val;

    switch(config.color_pick)
    {
    case ID_COL_CHECKER:
        ncols = MAXSIDES*NCCOLS;
        cols = &checker_cols[0][0][0];
        break;
    case ID_COL_PER_SIDE:
        ncols = MAXSIDES;
        cols = &side_cols[0][0];
        break;
    case ID_COL_SINGLE:
        ncols = 1;
        cols = &solid_cols[0];
        break;
    }

    ang = phase;
    da = (FLT)((2*PI)/ncols);
    val = sat = 1.0f;

    while (ncols > 0)
    {
        fhex = (FLT)(6*ang/(2*PI));
        hex = (int)fhex;
        frac = fhex-hex;
        hex = hex % 6;
        
	p = val*(1-sat);
	q = val*(1-sat*frac);
	t = val*(1-sat*(1-frac));
        
	switch(hex)
	{
	case 0:
            cols[0] = val;
            cols[1] = t;
            cols[2] = p;
	    break;
	case 1:
            cols[0] = q;
            cols[1] = val;
            cols[2] = p;
	    break;
	case 2:
            cols[0] = p;
            cols[1] = val;
            cols[2] = t;
	    break;
	case 3:
            cols[0] = p;
            cols[1] = q;
            cols[2] = val;
	    break;
	case 4:
            cols[0] = t;
            cols[1] = p;
            cols[2] = val;
            break;
	case 5:
            cols[0] = val;
            cols[1] = p;
            cols[2] = q;
	    break;
	}

        ang += da;
        cols += 4;
        ncols--;
    }
}

/******************************Public*Routine******************************\
*
* Draw
*
* Draw everything
*
* History:
*  Wed Jul 19 14:54:16 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void Draw(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glLoadIdentity();

    glRotated(xr, 1, 0, 0);
    glRotated(yr, 0, 1, 0);
    glRotated(zr, 0, 0, 1);

    DrawGeom(cur_geom);

    glFlush();
}

/******************************Public*Routine******************************\
*
* Update
*
* Update all varying values, called by the common library
*
* History:
*  Wed Jul 19 14:54:24 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void Update(void *data)
{
    if (config.spin)
    {
        xr += 3;
        yr += 2;
    }

    if (config.bloom)
    {
        sf += sfi;
        if (sf > cur_geom->max_sf ||
            sf < cur_geom->min_sf)
        {
            sfi = -sfi;
        }
        UpdatePts(cur_geom, sf);
    }

    if (config.cycle_colors)
    {
        ComputeHsvColors();
        phase += (FLT)(2.5*PI/180.);
    }
    
    Draw();
}

// String storage
TCHAR geom_names[IDS_GEOM_COUNT][20];

/******************************Public*Routine******************************\
* getIniSettings
*
* Get the screen saver configuration options from .INI file/registry.
*
\**************************************************************************/

static void 
getIniSettings()
{
    // Get registry settings

    if( ! ss_RegistrySetup( GetModuleHandle(NULL), IDS_INI_SECTION, 
                            IDS_INIFILE ) )
        return;
    
    config.smooth_colors =
        ss_GetRegistryInt( IDS_CONFIG_SMOOTH_COLORS, config.smooth_colors );
    config.triangle_colors =
        ss_GetRegistryInt( IDS_CONFIG_TRIANGLE_COLORS, config.triangle_colors );
    config.cycle_colors =
        ss_GetRegistryInt( IDS_CONFIG_CYCLE_COLORS, config.cycle_colors );
    config.spin =
        ss_GetRegistryInt( IDS_CONFIG_SPIN, config.spin );
    config.bloom =
        ss_GetRegistryInt( IDS_CONFIG_BLOOM, config.bloom );
    config.subdiv =
        ss_GetRegistryInt( IDS_CONFIG_SUBDIV, config.subdiv );
    config.color_pick =
        ss_GetRegistryInt( IDS_CONFIG_COLOR_PICK, config.color_pick );
    config.image_size =
        ss_GetRegistryInt( IDS_CONFIG_IMAGE_SIZE, config.image_size );
    config.geom =
        ss_GetRegistryInt( IDS_CONFIG_GEOM, config.geom );
    config.two_sided =
        ss_GetRegistryInt( IDS_CONFIG_TWO_SIDED, config.two_sided );
}

/******************************Public*Routine******************************\
* saveIniSettings
*
* Save the screen saver configuration option to the .INI file/registry.
*
\**************************************************************************/

static void 
saveIniSettings()
{
    if( ! ss_RegistrySetup( GetModuleHandle(NULL), IDS_INI_SECTION, 
                            IDS_INIFILE ) )
        return;

    ss_WriteRegistryInt( IDS_CONFIG_SMOOTH_COLORS, config.smooth_colors );

    ss_WriteRegistryInt( IDS_CONFIG_TRIANGLE_COLORS, config.triangle_colors );
    ss_WriteRegistryInt( IDS_CONFIG_CYCLE_COLORS, config.cycle_colors );
    ss_WriteRegistryInt( IDS_CONFIG_SPIN, config.spin );
    ss_WriteRegistryInt( IDS_CONFIG_BLOOM, config.bloom );
    ss_WriteRegistryInt( IDS_CONFIG_SUBDIV, config.subdiv );
    ss_WriteRegistryInt( IDS_CONFIG_COLOR_PICK, config.color_pick );
    ss_WriteRegistryInt( IDS_CONFIG_IMAGE_SIZE, config.image_size );
    ss_WriteRegistryInt( IDS_CONFIG_GEOM, config.geom );
    ss_WriteRegistryInt( IDS_CONFIG_TWO_SIDED, config.two_sided );
}

/******************************Public*Routine******************************\
*
* NewConfig
*
* Set up a new configuration
*
* History:
*  Wed Jul 19 14:55:34 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void NewConfig(CONFIG *cnf)
{
    // Set new config
    config = *cnf;

    // Save to ini file
    saveIniSettings();
    
    // Reset colors
    memcpy(checker_cols, base_checker_cols, sizeof(checker_cols));
    memcpy(side_cols, base_side_cols, sizeof(side_cols));
    memcpy(solid_cols, base_solid_cols, sizeof(solid_cols));

    // Reset geometry
    cur_geom = geom_table[config.geom];
    cur_geom->init(cur_geom);
    if (bOgl11 && !bCheckerOn) DrawWithVArrays (cur_geom);
    
    assert(cur_geom->total_pts <= MAXPTS);
           
    InitVlen(cur_geom, cur_geom->total_pts, cur_geom->pts);
    sf = 0.0f;
    sfi = cur_geom->sf_inc;
    UpdatePts(cur_geom, sf);

    // Reset OpenGL parameters according to configuration
    // Only done if GL has been initialized
    if (gbGlInit)
    {
        GLfloat fv4[4];
        
        if (config.two_sided == GL_FRONT_AND_BACK)
        {
            glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
            glDisable(GL_CULL_FACE);
        }
        else
        {
            glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
            glEnable(GL_CULL_FACE);
        }
        
        fv4[0] = fv4[1] = fv4[2] = .8f;
        fv4[3] = 1.0f;
        glMaterialfv(config.two_sided, GL_SPECULAR, fv4);
        glMaterialf(config.two_sided, GL_SHININESS, 30.0f);
    }
}

/******************************Public*Routine******************************\
*
* RegisterDialogClasses
*
* Standard screensaver hook
*
* History:
*  Wed Jul 19 15:18:14 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL WINAPI RegisterDialogClasses(HANDLE hinst)
{
    return TRUE;
}

// Temporary configuration for when the configuration dialog is active
// If the dialog is ok'ed then this becomes the current configuration,
// otherwise it is discarded
CONFIG temp_config;

/******************************Public*Routine******************************\
*
* ScreenSaverConfigureDialog
*
* Standard screensaver hook
*
* History:
*  Wed Jul 19 14:56:41 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL CALLBACK ScreenSaverConfigureDialog(HWND hdlg, UINT msg,
                                         WPARAM wpm, LPARAM lpm)
{
    WORD pos;
    RANGE *rng;
    HWND hCtrl;
    int i;
    
    switch(msg)
    {
    case WM_INITDIALOG:

        InitCommonControls();

        getIniSettings();
    
        temp_config = config;
        
        CheckRadioButton(hdlg, ID_COL_PICK_FIRST, ID_COL_PICK_LAST,
                         config.color_pick);
        CheckDlgButton(hdlg, ID_COL_SMOOTH, config.smooth_colors);
        CheckDlgButton(hdlg, ID_COL_TRIANGLE, config.triangle_colors);
        CheckDlgButton(hdlg, ID_COL_CYCLE, config.cycle_colors);
        CheckDlgButton(hdlg, ID_SPIN, config.spin);
        CheckDlgButton(hdlg, ID_BLOOM, config.bloom);
        CheckDlgButton(hdlg, ID_TWO_SIDED,
                       config.two_sided == GL_FRONT_AND_BACK);
        
        ss_SetupTrackbar( hdlg, ID_COMPLEXITY, MINSUBDIV, MAXSUBDIV, 
                          complexity_range.step,
                          complexity_range.page_step,
                          config.subdiv);

        ss_SetupTrackbar( hdlg, ID_IMAGE_SIZE, MINIMAGESIZE, MAXIMAGESIZE, 
                          image_size_range.step,
                          image_size_range.page_step,
                          config.image_size);

        hCtrl = GetDlgItem(hdlg, ID_GEOM);
        SendMessage(hCtrl, CB_RESETCONTENT, 0, 0);
        for (i = 0; i < IDS_GEOM_COUNT; i++)
        {
            LoadString( hMainInstance, i+IDS_GEOM_FIRST, geom_names[i],
                        sizeof(geom_names)/IDS_GEOM_COUNT );
            SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)geom_names[i]);
        }
        SendMessage(hCtrl, CB_SETCURSEL, config.geom, 0);
        
        SetFocus(GetDlgItem(hdlg, ID_COMPLEXITY));
        return FALSE;

    case WM_COMMAND:
        switch(LOWORD(wpm))
        {
        case ID_COL_CHECKER:
        case ID_COL_PER_SIDE:
        case ID_COL_SINGLE:
            temp_config.color_pick = LOWORD(wpm);
            break;

        case ID_COL_SMOOTH:
            temp_config.smooth_colors = !temp_config.smooth_colors;
            break;
        case ID_COL_TRIANGLE:
            temp_config.triangle_colors = !temp_config.triangle_colors;
            break;
        case ID_COL_CYCLE:
            temp_config.cycle_colors = !temp_config.cycle_colors;
            break;
            
        case ID_SPIN:
            temp_config.spin = !temp_config.spin;
            break;
        case ID_BLOOM:
            temp_config.bloom = !temp_config.bloom;
            break;
        case ID_TWO_SIDED:
            temp_config.two_sided =
                temp_config.two_sided == GL_FRONT_AND_BACK ? GL_FRONT :
                GL_FRONT_AND_BACK;
            break;

        case IDOK:
            temp_config.subdiv =
                ss_GetTrackbarPos(hdlg, ID_COMPLEXITY);
            temp_config.image_size =
                ss_GetTrackbarPos(hdlg, ID_IMAGE_SIZE);
            temp_config.geom =
                (int)SendMessage(GetDlgItem(hdlg, ID_GEOM), CB_GETCURSEL, 0, 0);
            NewConfig(&temp_config);
            // Fall through
        case IDCANCEL:
            EndDialog(hdlg, LOWORD(wpm));
            break;
        }
        return TRUE;
        
    }

    return FALSE;
}

/******************************Public*Routine******************************\
*
* Init
*
* Drawing initialization, called by common library
*
* History:
*  Wed Jul 19 14:47:13 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void Init(void *data)
{
    GLfloat fv4[4];

    gbGlInit = TRUE;
    
    bOgl11 = ss_fOnGL11();

    if (config.color_pick == ID_COL_CHECKER) bCheckerOn = TRUE;
    else bCheckerOn = FALSE;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1, 2, 5); // for object range -1.5 to 1.5
    gluLookAt(0, 0, 3.5, 0, 0, 0, 0, 1, 0);
    glMatrixMode(GL_MODELVIEW);

    glEnable(GL_DEPTH_TEST);
    glClearDepth(1);

    glCullFace(GL_BACK);
    
    fv4[0] = 2.0f;
    fv4[1] = 2.0f;
    fv4[2] = 10.0f;
    fv4[3] = 1.0f;
    glLightfv(GL_LIGHT0, GL_POSITION, fv4);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glEnable(GL_NORMALIZE);
    
    // Make default configuration current
    NewConfig(&config);
}

/******************************Public*Routine******************************\
* SetFloaterInfo
*
* Set the size and motion of the floating window
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild )
{
    float sizeFact;
    float sizeScale;
    int size;
    ISIZE *pChildSize = &pChild->size;
    MOTION_INFO *pMotion = &pChild->motionInfo;

    sizeScale = (float)config.image_size / 100.0f;
    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75%
    size = (int) (sizeFact * ( ((float)(pParentSize->width + pParentSize->height)) / 2.0f ));
    SS_CLAMP_TO_RANGE2( size, 0, pParentSize->width );
    SS_CLAMP_TO_RANGE2( size, 0, pParentSize->height );

    pChildSize->width = pChildSize->height = size;

    // Floater motion
    pMotion->posInc.x = .005f * (float) size;
    if( pMotion->posInc.x < 1.0f )
        pMotion->posInc.x = 1.0f;
    pMotion->posInc.y = pMotion->posInc.x;
    pMotion->posIncVary.x = .4f * pMotion->posInc.x;
    pMotion->posIncVary.y = pMotion->posIncVary.x;
}

/******************************Public*Routine******************************\
*
* FloaterFail
*
* Called when the floating window cannot be created
*
* History:
*  Wed Jul 19 15:06:18 1995	-by-	Drew Bliss [drewb]
*   Taken from text3d
*
\**************************************************************************/

void FloaterFail(void *data)
{
    HINSTANCE hinst;
    TCHAR error_str[20];
    TCHAR start_failed[80];

    hinst = GetModuleHandle(NULL);
    if (LoadString(hinst, IDS_ERROR,
                   error_str, sizeof(error_str)) &&
        LoadString(hinst, IDS_START_FAILED,
                   start_failed, sizeof(start_failed)))
    {
        MessageBox(NULL, start_failed, error_str, MB_OK);
    }
}

/******************************Public*Routine******************************\
*
* ss_Init
*
* Screensaver initialization routine, called at startup by common library
*
* History:
*  Wed Jul 19 14:44:46 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

SSContext *ss_Init(void)
{
    getIniSettings();
    
    ss_InitFunc(Init);
    ss_UpdateFunc(Update);

    gssc.bFloater = TRUE;
    gssc.floaterInfo.bMotion = TRUE;
    gssc.floaterInfo.ChildSizeFunc = SetFloaterInfo;

    gssc.bDoubleBuf = TRUE;
    gssc.depthType = SS_DEPTH16;

    return &gssc;
}


/**************************************************************************\
* ConfigInit
*
* Dialog box version of ss_Init.  Used for setting up any gl drawing on the
* dialog.
*
\**************************************************************************/
BOOL
ss_ConfigInit( HWND hDlg )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\flwbox\ssflwbox.h ===
/**********************************Module**********************************\
*
* ssflwbox.h
*
* 3D FlowerBox screen saver
* Base header file
*
* History:
*  Wed Jul 19 14:50:27 1995	-by-	Drew Bliss [drewb]
*   Created
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __SSFLWBOX_H__
#define __SSFLWBOX_H__

#ifndef PI
#define PI 3.14159265358979323846
#endif

// Minimum and maximum number of side subdivisions
#define MINSUBDIV 2
#define MAXSUBDIV 10

// Maximum values allowed
#define MAXSIDES 8
#define MAXSPTS ((MAXSUBDIV+1)*(MAXSUBDIV+1))
#define MAXPTS (MAXSIDES*MAXSPTS)
#define MAXSFACES (MAXSUBDIV*MAXSUBDIV)
#define MAXFACES (MAXSIDES*MAXSFACES)
#define MAXFPTS 4

// Number of colors used in checkerboarding
#define NCCOLS 2

// Allow floating point type configurability
typedef GLfloat FLT;
typedef struct
{
    FLT x, y, z;
} PT3;

// Configurable options
typedef struct _CONFIG
{
    BOOL smooth_colors;
    BOOL triangle_colors;
    BOOL cycle_colors;
    BOOL spin;
    BOOL bloom;
    int subdiv;
    int color_pick;
    int image_size;
    int geom;
    int two_sided;
} CONFIG;

extern CONFIG config;

extern GLfloat checker_cols[MAXSIDES][NCCOLS][4];
extern GLfloat side_cols[MAXSIDES][4];
extern GLfloat solid_cols[4];

#if defined(assert)
#undef assert
#endif
#if DBG
#define dprintf(args) dprintf_out args
void dprintf_out(char *fmt, ...);
#define assert(e) if (!(e)) assert_failed(__FILE__, __LINE__, #e); else 0
void assert_failed(char *file, int line, char *msg);
#else
#define dprintf(args)
#define assert(e)
#endif

#define DIMA(a) (sizeof(a)/sizeof(a[0]))

/******************************Public*Routine******************************\
*
* Basic vector math macros
*
* History:
*  Wed Jul 19 14:49:49 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define V3Sub(a, b, r) \
    ((r)->x = (a)->x-(b)->x, (r)->y = (a)->y-(b)->y, (r)->z = (a)->z-(b)->z)
#define V3Add(a, b, r) \
    ((r)->x = (a)->x+(b)->x, (r)->y = (a)->y+(b)->y, (r)->z = (a)->z+(b)->z)
#define V3Cross(a, b, r) \
    ((r)->x = (a)->y*(b)->z-(b)->y*(a)->z,\
     (r)->y = (a)->z*(b)->x-(b)->z*(a)->x,\
     (r)->z = (a)->x*(b)->y-(b)->x*(a)->y)
extern FLT V3Len(PT3 *v);

#endif // __SSFLWBOX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\fixed.h ===
#ifndef __FIXED_H__
#define __FIXED_H__

#include <math.h>

#ifdef __cplusplus
extern "C" {
#endif
    
#ifndef PI
#define PI (3.1415926535897932384626433832795028841971693993751)
#endif

/* Default table size for precomputed sincos table */
#define FA_TABLE_SIZE 360

/*
   Flags for initialization
   FA_CARTESIAN_Y       - Y axis is positive up
 */
#define FA_DEFAULT      0
#define FA_CARTESIAN_Y  1
    
#if defined(FX_DOUBLE) || defined(FX_SINGLE)

#ifdef FX_DOUBLE
typedef double FxValue;

#define FX_MAX_VALUE (1e100)
#define FX_MIN_VALUE (1e-10)
#else
typedef float FxValue;

#define FX_MAX_VALUE (1e38f)
#define FX_MIN_VALUE (1e-7f)
#endif

#define FxVal(i) ((FxValue)(i))
#define FxInt(v) ((int)(v))
#define FxFltVal(f) ((FxValue)(f))
#define FxFlt(v) ((double)(v))
#define FxPromote(v) (v)
#define FxDemote(v) (v)

#define FxMul(a, b) ((a)*(b))
#define FxDemotedMul(a, b) FxMul(a, b)
#define FxDiv(a, b) ((a)/(b))
#define FxDemotedDiv(a, b) FxDiv(a, b)
#define FxMulToInt(a, b) FxInt((a)*(b))
#define FxDivToInt(a, b) ((int)((a)/(b)))
#define FxMulDiv(a, m, d) (((a)*(m))/(d))
#define FxSqrt(v) ((FxValue)sqrt((double)(v)))
#define FxDemotedSqrt(v) FxSqrt(v)

typedef FxValue FaAngle;

#define FaAng(a) (a)

#define FaSin(v) ((FxValue)-sin((double)(v)))
#define FaCos(v) ((FxValue)cos((double)(v)))

#define FaAdd(a, d) ((a)+(d))
FaAngle FaNorm(FaAngle a);
#define FaDeg(da) ((da)*(FxValue)(PI/180.0))
#define FaRad(ra) (ra)
#define FaAngVal(aa) (aa)
#define FaFltDegVal(a) ((a)*180.0/PI)
#define FaFltRadVal(a) (a)

#define FxInitialize(table_size, flags) ((flags) == FA_DEFAULT)
#define FxEnd()

#else

/* If integer sqrt isn't interesting, define FX_PRECISE_SQRT
   and the floating point sqrt will be used */

#ifndef FX_SHIFT
#define FX_SHIFT 10
#endif
#define FX_MULT (1L << FX_SHIFT)

typedef long FxValue;

#define FX_MAX_VALUE (0x7fffffff)
#define FX_MIN_VALUE (1)

#define FxVal(i) FxPromote((FxValue)(i))
#define FxInt(v) ((int)FxDemote(v))
#define FxFltVal(f) ((FxValue)((f)*(double)FX_MULT))
#define FxFlt(v) (((double)(v))/(double)FX_MULT)
#define FxPromote(v) ((v) << FX_SHIFT)
#define FxDemote(v) ((v) >> FX_SHIFT)

#if FX_SHIFT != 16
/* These can overflow if the shift and numbers are too large */
#define FxMul(a, b) FxDemote((a)*(b))
#define FxDiv(a, b) (FxPromote(a)/(b))
#define FxMulToInt(a, b) FxInt(FxDemote((a)*(b)))
#define FxMulDiv(a, m, d) (((a)*(m))/(d))
#else
/* For FX_SHIFT == 16 and certain platforms, assembly routines are
   provided which do 64-bit intermediate math, preserving accuracy
   There is still a danger of overflow if the results don't fit in
   32 bits, though */
FxValue FxMul(FxValue a, FxValue b);
FxValue FxDiv(FxValue a, FxValue b);
int FxMulToInt(FxValue a, FxValue b);
FxValue FxMulDiv(FxValue a, FxValue m, FxValue d);
#endif

#ifndef FX_PRECISE_SQRT
FxValue FxSqrt(FxValue v);
/* Computing the square root of a demoted value leaves it out of
   adjustment by sqrt(FX_MULT) so shift by FX_SHIFT/2 to
   restore fixed point
   FX_SHIFT should be even for this to work */
#define FxDemotedSqrt(v) (FxSqrt(FxDemote(v)) << (FX_SHIFT/2))
#else
#define FxSqrt(v) FxFltVal(sqrt(FxFlt(v)))
#define FxDemotedSqrt(v) FxSqrt(v)
#endif

#define FxDemotedMul(a, b) (FxDemote(a)*(b))
#define FxDemotedDiv(a, b) FxPromote((a)/(b))
#define FxDivToInt(a, b) ((int)((a)/(b)))

/* One unit of angle is the table quantum
   One unit of angle equals 360/_fa_table_size degrees */ 
typedef FxValue FaAngle;

extern int _fa_table_size;

extern FxValue *_fa_sines;
extern FxValue *_fa_cosines;

#define FaAng(a) FxDemote(a)
#define FaSin(a) _fa_sines[(int)FaAng(a)]
#define FaCos(a) _fa_cosines[(int)FaAng(a)]

FaAngle FaAdd(FaAngle a, FaAngle d);
FaAngle FaBisectingAngle(FaAngle f, FaAngle t);
#define FaNorm(a) FaAdd(FxVal(0), a)
#define FaDeg(da) \
    FaNorm(FxMulDiv(FxVal(da), _fa_table_size, 360))
#define FaRad(ra) FaNorm(FxFltVal((ra)*_fa_table_size/PI2))
#define FaAngVal(aa) FaNorm(FxVal(aa))
#define FaFltDegVal(ang) FxFltVal(FxMulDiv(ang, 360, _fa_table_size))
#define FaFltRadVal(ang) (FxFltVal(ang)*PI2/_fa_table_size)

BOOL FxInitialize(int table_size, ULONG flags);
void FxEnd(void);

#endif

typedef struct _FxPt2
{
    FxValue x, y;
} FxPt2;
typedef FxPt2 FxVec2;

typedef struct _FxBox2
{
    FxPt2 min, max;
} FxBox2;

typedef struct _FxPt3
{
    FxValue x, y, z;
} FxPt3;
typedef FxPt3 FxVec3;

typedef struct _FxBox3
{
    FxPt3 min, max;
} FxBox3;

typedef struct _FxPt4
{
    FxValue x, y, z, w;
} FxPt4;
typedef FxPt4 FxVec4;

void FxBBox2Empty(FxBox2 *bb);
void FxBBox2AddPt(FxBox2 *bb, FxPt2 *pt);

void FxBBox3Empty(FxBox3 *bb);
void FxBBox3AddPt(FxBox3 *bb, FxPt3 *pt);

#define FxV2Set(v, xv, yv) \
    ((v)->x = (xv), (v)->y = (yv))
#define FxV2Add(a, b, r) \
    ((r)->x = (a)->x+(b)->x, (r)->y = (a)->y+(b)->y)
#define FxV2Sub(a, b, r) \
    ((r)->x = (a)->x-(b)->x, (r)->y = (a)->y-(b)->y)
#define FxV2Dot(a, b) \
    (FxMul((a)->x, (b)->x)+FxMul((a)->y, (b)->y))
#define FxV2Neg(v, r) \
    ((r)->x = -(v)->x, (r)->y = -(v)->y)
#define FxV2NegV(v) FxV2Neg(v, v)
#define FxV2NormV(v) FxV2Norm(v, v)

FxValue FxV2Len(FxVec2 *v);
FxValue FxV2Norm(FxVec2 *v, FxVec2 *r);

#define FxvV2Set(v, xv, yv) FxV2Set(&(v), xv, yv)
#define FxvV2Add(a, b, r) FxV2Add(&(a), &(b), &(r))
#define FxvV2Sub(a, b, r) FxV2Sub(&(a), &(b), &(r))
#define FxvV2Dot(a, b) FxV2Dot(&(a), &(b))
#define FxvV2Neg(v, r) FxV2Neg(&(v), &(r))
#define FxvV2NegV(v) FxV2NegV(&(v))
#define FxvV2Len(v) FxV2Len(&(v))
#define FxvV2Norm(v, r) FxV2Norm(&(v), &(r))
#define FxvV2NormV(v) FxV2NormV(&(v))

#define FxV3Set(v, xv, yv, zv) \
    ((v)->x = (xv), (v)->y = (yv), (v)->z = (zv))
#define FxV3Add(a, b, r) \
    ((r)->x = (a)->x+(b)->x, (r)->y = (a)->y+(b)->y, (r)->z = (a)->z+(b)->z)
#define FxV3Sub(a, b, r) \
    ((r)->x = (a)->x-(b)->x, (r)->y = (a)->y-(b)->y, (r)->z = (a)->z-(b)->z)
#define FxV3Dot(a, b) \
    (FxMul((a)->x, (b)->x)+FxMul((a)->y, (b)->y)+FxMul((a)->z, (b)->z))
#define FxV3Neg(v, r) \
    ((r)->x = -(v)->x, (r)->y = -(v)->y, (r)->z = -(v)->z)
#define FxV3NegV(v) FxV3Neg(v, v)
#define FxV3Cross(a, b, r) \
    ((r)->x = (a)->y*(b)->z-(b)->y*(a)->z,\
     (r)->y = (a)->z*(b)->x-(b)->z*(a)->x,\
     (r)->z = (a)->x*(b)->y-(b)->x*(a)->y)
#define FxV3NormV(v) FxV3Norm(v, v)

FxValue FxV3Len(FxVec3 *v);
FxValue FxV3Norm(FxVec3 *v, FxVec3 *r);

#define FxvV3Set(v, xv, yv, zv) FxV3Set(&(v), xv, yv, zv)
#define FxvV3Add(a, b, r) FxV3Add(&(a), &(b), &(r))
#define FxvV3Sub(a, b, r) FxV3Sub(&(a), &(b), &(r))
#define FxvV3Dot(a, b) FxV3Dot(&(a), &(b))
#define FxvV3Neg(v, r) FxV3Neg(&(v), &(r))
#define FxvV3NegV(v) FxV3NegV(&(v))
#define FxvV3Cross(a, b, r) FxV3Cross(&(a), &(b), &(r))
#define FxvV3Len(v) FxV3Len(&(v))
#define FxvV3Norm(v, r) FxV3Norm(&(v), &(r))
#define FxvV3NormV(v) FxV3NormV(&(v))

typedef FxValue FxMatrix2[2][2];
typedef FxValue FxMatrix3[3][3];
typedef FxValue FxMatrix4[4][4];

typedef FxValue FxTMatrix2[2][3];
typedef FxValue FxTMatrix3[3][4];

void FxT2Ident(FxTMatrix2 m);
void FxT2Mul(FxTMatrix2 a, FxTMatrix2 b, FxTMatrix2 r);
void FxT2Vec2(FxTMatrix2 m, int n, FxVec2 *f, FxVec2 *t);

void FxT3Ident(FxTMatrix3 m);
void FxT3Mul(FxTMatrix3 a, FxTMatrix3 b, FxTMatrix3 r);
void FxT3Vec3(FxTMatrix3 m, int n, FxVec3 *f, FxVec3 *t);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\genmaze.h ===
#ifndef __GENMAZE_H__
#define __GENMAZE_H__

#define MAZE_WALL_VERT 1
#define MAZE_WALL_HORZ 2

BOOL GenerateMaze(int width, int height, BYTE *walls);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\glmaze.h ===
#ifndef __GLMAZE_H__
#define __GLMAZE_H__

#include "sscommon.h"
#include "maze_std.h"

#ifdef __cplusplus
extern "C" {
#endif

enum {
    TEX_WALL  = 0,
    TEX_FLOOR,
    TEX_CEILING,
    TEX_START,
    TEX_END,
    TEX_RAT,
    TEX_AD,
    TEX_COVER,
    NUM_TEXTURES
};

void UseTextureEnv( TEX_ENV *pTexEnv );

#define MAX_RATS 10

extern MazeOptions maze_options;
extern TEX_RES gTexResSurf[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\dialog.cxx ===
/******************************Module*Header*******************************\
* Module Name: dialog.cxx
*
* Dialog box functions
*
* Created: 11-16-95 -by- Marc Fortier [marcfo]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/

#include "pch.c"
#pragma hdrstop

#include <commdlg.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "mazedlg.h"

#include "sscommon.hxx"

// Global string buffers for message box.

// local funtions

static void updateDialogControls(HWND hDlg);

HWND    ghDlg; // main dialog window handle
int     giSize;
int     giImageQual;
BOOL    gbTurboMode;
int     gnBitsPerPixel;

static void DrawTexture( int surface );
static void CleanUp( HWND hwnd );

// Texture information for each surface: used in both configure and run mode

TEX_INFO gTexInfo[NUM_SURFACES] = {0};

// default surface texture cache
static TEXTURE gDefTex[NUM_DEF_SURFACE_TEXTURES] = {0};

// Per-surface texture information relevant only to configure mode

typedef struct {
    TEXTURE userTex;
    int  iDefTex;
    int  defTexIDS;
    int  fileIDS;
    int  offsetIDS;
    int  dlgSpinTexID;
    int  iPalRot;  // texture palette rotation index
    SS_TEX_BUTTON *pTexBtn;  // GL texture drawing button thing
} TEX_DLG;

static TEX_DLG gTex[NUM_SURFACES] = {
    { 
      {0},
      BRICK_TEXTURE,
      IDS_DEF_WALL_TEXTURE, 
      IDS_WALL_TEXTURE_FILE, 
      IDS_WALL_TEXTURE_OFFSET,
      DLG_SPIN_WALLS,
      NULL
    },
    { 
      {0},
      WOOD_TEXTURE,
      IDS_DEF_FLOOR_TEXTURE, 
      IDS_FLOOR_TEXTURE_FILE, 
      IDS_FLOOR_TEXTURE_OFFSET,
      DLG_SPIN_FLOOR,
      NULL
    },
    { 
      {0},
      CASTLE_TEXTURE,
      IDS_DEF_CEILING_TEXTURE, 
      IDS_CEILING_TEXTURE_FILE, 
      IDS_CEILING_TEXTURE_OFFSET,
      DLG_SPIN_CEILING,
      NULL
    }
};

static UINT idTimer = 0;

static BOOL CALLBACK TextureConfigureDialog(HWND hDlg, UINT message,
                            WPARAM wParam, LPARAM lParam);

/******************************Public*Routine******************************\
* getIniSettings
*
* - Get the screen saver configuration options from .INI file/registry.
* - Called by both dialog box and screen saver
*
* History:
*  Nov. 95 [marcfo]
*    - Creation
*
\**************************************************************************/

void 
getIniSettings()
{
    int    option;
    int    i;

    // Load resources

    LoadString(hMainInstance, IDS_GENNAME, szScreenSaver, 
               sizeof(szScreenSaver) / sizeof(TCHAR));

    // Get registry settings

    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        // get wall/floor/ceiling texture enables
        // For now, texturing always on
        for( i = 0; i < NUM_SURFACES; i++ )
            gTexInfo[i].bTex = TRUE;

        option = ss_GetRegistryInt( IDS_DEFAULT_TEXTURE_ENABLE, (1 << NUM_SURFACES)-1 );
        for( i = 0; i < NUM_SURFACES; i++, option >>= 1 )
            gTexInfo[i].bDefTex = option & 1;

        // get default texture indices

        for( i = 0; i < NUM_SURFACES; i++ ) {
            gTexInfo[i].iDefTex = 
                    ss_GetRegistryInt( gTex[i].defTexIDS, gTex[i].iDefTex );
            SS_CLAMP_TO_RANGE2( gTexInfo[i].iDefTex, 0, 
                                                NUM_DEF_SURFACE_TEXTURES-1 );
        }

        // get user texture files

        for( i = 0; i < NUM_SURFACES; i++ ) {
            ss_GetRegistryString( gTex[i].fileIDS, 0, 
                                  gTexInfo[i].texFile.szPathName, MAX_PATH);
            gTexInfo[i].texFile.nOffset = ss_GetRegistryInt( gTex[i].offsetIDS, 0 );
        }

        // get overlay
        maze_options.top_view = ss_GetRegistryInt( IDS_OVERLAY, 0 );

        // Get rat population
        maze_options.nrats = ss_GetRegistryInt(IDS_NRATS, 1);
        
        // get image quality

        giImageQual = ss_GetRegistryInt( IDS_IMAGEQUAL, IMAGEQUAL_DEFAULT );
        SS_CLAMP_TO_RANGE2( giImageQual, IMAGEQUAL_DEFAULT, IMAGEQUAL_HIGH );

        // get size

        giSize = ss_GetRegistryInt( IDS_SIZE, 0 );
        SS_CLAMP_TO_RANGE2( giSize, MIN_SLIDER, MAX_SLIDER );

        // get turbo mode
        gbTurboMode = ss_GetRegistryInt( IDS_TURBOMODE, 1 );
    }
}


/******************************Public*Routine******************************\
* saveIniSettings
*
* Save the screen saver configuration option to the .INI file/registry.
*
* History:
*  Nov. 95 [marcfo]
*    - Creation
\**************************************************************************/

static void 
saveIniSettings(HWND hDlg)
{
    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        int i, option = 0;

        // write enables

        for( i = NUM_SURFACES-1, option = 0; i >= 0; i--, option <<= 1 )
            option |= gTexInfo[i].bDefTex & 1;
        ss_WriteRegistryInt( IDS_DEFAULT_TEXTURE_ENABLE, option >>= 1 );

        // Write default texture indices

        for( i = 0; i < NUM_SURFACES; i++ ) {
            ss_WriteRegistryInt( gTex[i].defTexIDS, gTexInfo[i].iDefTex );
        }

        // write user texture files

        for( i = 0; i < NUM_SURFACES; i++ ) {
            ss_WriteRegistryString( gTex[i].fileIDS,
                                    gTexInfo[i].texFile.szPathName );
            ss_WriteRegistryInt( gTex[i].offsetIDS, gTexInfo[i].texFile.nOffset);
        }

        // write size
        ss_WriteRegistryInt( IDS_SIZE, 
                    ss_GetTrackbarPos(hDlg, DLG_SLIDER_SIZE) );

        // write overlay enable
        ss_WriteRegistryInt( IDS_OVERLAY, maze_options.top_view );

        // Write rat population
        ss_WriteRegistryInt( IDS_NRATS, maze_options.nrats );
        
        // write image quality
        ss_WriteRegistryInt( IDS_IMAGEQUAL, giImageQual );

        // turbot mod
        ss_WriteRegistryInt( IDS_TURBOMODE, gbTurboMode );
    }
}

/******************************Public*Routine******************************\
* setupDialogControls
*
* Do initial setup of dialog controls.
*
* History:
*  Nov. 95 [marcfo]
*    - Creation
\**************************************************************************/

static void 
setupDialogControls(HWND hDlg)
{
    int i;
    int idsImageQual;
    TCHAR szStr[GEN_STRING_SIZE];

    InitCommonControls();

    // setup size slider

    ss_SetupTrackbar( hDlg, DLG_SLIDER_SIZE, MIN_SLIDER, MAX_SLIDER, 1, 9, 
                      giSize );

    // setup default texture spins

    for( i = 0; i < NUM_SURFACES; i ++ ) {
        SendDlgItemMessage( hDlg, gTex[i].dlgSpinTexID, UDM_SETRANGE, 0, 
                            MAKELONG(NUM_DEF_SURFACE_TEXTURES-1, 0) );
        SendDlgItemMessage( hDlg, gTex[i].dlgSpinTexID, UDM_SETPOS, 0, 
                            MAKELONG(gTexInfo[i].iDefTex, 0) );
    }

    // setup image quality combo box

    idsImageQual = IDS_IMAGEQUAL_DEFAULT;
    for( i = 0; i < IMAGEQUAL_COUNT; i++, idsImageQual++ ) {
        LoadString(hMainInstance, idsImageQual, szStr, 
                    GEN_STRING_SIZE);
        SendDlgItemMessage(hDlg, DLG_COMBO_IMAGEQUAL, CB_ADDSTRING, 0,
                           (LPARAM) szStr);
    }
    SendDlgItemMessage(hDlg, DLG_COMBO_IMAGEQUAL, CB_SETCURSEL, 
                       giImageQual, 0);

    // Disable Quality box when running on > 16 bits per pixel (since it only
    // affects dithering)
    gnBitsPerPixel = GetDeviceCaps( GetDC(hDlg), BITSPIXEL );
    EnableWindow( GetDlgItem(hDlg, DLG_COMBO_IMAGEQUAL), gnBitsPerPixel <= 16 );
    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_IMAGEQUAL), gnBitsPerPixel <= 16 );
        
    // set palette rotation index for each surface for a8 textures
    for( i = 0; i < NUM_SURFACES; i ++ )
        gTex[i].iPalRot = ss_iRand(0xff);

    // set state of other controls

    CheckDlgButton(hDlg, DLG_CHECK_OVERLAY, maze_options.top_view );

    CheckDlgButton(hDlg, DLG_CHECK_TURBOMODE, gbTurboMode );

    updateDialogControls(hDlg);
}

/******************************Public*Routine******************************\
* updateDialogControls
*
* Updates dialog controls according to current state
* 
* History:
*  Nov. 95 [marcfo]
*    - Creation
\**************************************************************************/

static void 
updateDialogControls(HWND hDlg)
{
    int i;
    BOOL bDither;

    static int dlgSpinTexDef[NUM_SURFACES] = { 
        DLG_SPIN_WALLS,
        DLG_SPIN_FLOOR,
        DLG_SPIN_CEILING};

    for( i = 0; i < NUM_SURFACES; i ++ ) {
        EnableWindow( GetDlgItem(hDlg, gTex[i].dlgSpinTexID), gTexInfo[i].bDefTex );
    }

    EnableWindow( GetDlgItem(hDlg, DLG_SLIDER_SIZE), !gbTurboMode );
    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_SIZE), !gbTurboMode );
    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_MIN), !gbTurboMode );
    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_MAX), !gbTurboMode );

    // Dithering looks bad with turbo mode on and 8 bits/pixel
    bDither = (gnBitsPerPixel <= 16) && !gbTurboMode;
    EnableWindow( GetDlgItem(hDlg, DLG_COMBO_IMAGEQUAL), bDither );
    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_IMAGEQUAL), bDither );
}

/******************************Public*Routine******************************\
* updateGLState
*
\**************************************************************************/

static void 
updateGLState()
{
    if( (giImageQual == IMAGEQUAL_DEFAULT) || gbTurboMode )
        glDisable( GL_DITHER );
    else
        glEnable( GL_DITHER );
}

/******************************Public*Routine******************************\
* ValidateTexture
*
*
\**************************************************************************/

static TEXTURE *
ValidateTexture( int surface ) 
{
    TEXTURE *pTex = NULL;
    TEX_INFO *pTexInfo = &gTexInfo[surface];
    extern TEX_RES gTexResSurf[]; // from glmaze.c

    if( !pTexInfo->bDefTex ) {
        // Try to draw user texture
        pTex = &gTex[surface].userTex;
        if( !pTex->data ) {
            // Load user texture - this can fail!
            // If nOffset = 0, we assume user has never specified a texture,
            // so we silently switch to the default texture.
            // If the load of user texture fails, we use default texture
            if( (pTexInfo->texFile.nOffset == 0) || 
                (! ss_LoadTextureFile( &pTexInfo->texFile, pTex )) ) {

                pTexInfo->bDefTex = TRUE;  // draw default texture resource

                // Enable the spin control
                EnableWindow( GetDlgItem(ghDlg, gTex[surface].dlgSpinTexID), 
                              TRUE );
            }
        }
    }

    if( pTexInfo->bDefTex ) {
        // Draw default texture resource
        pTex = &gDefTex[pTexInfo->iDefTex];
        if( !pTex->data ) {
            if( !ss_LoadTextureResource( &gTexResSurf[pTexInfo->iDefTex], pTex ))
                pTex = NULL;
        }
    }

    return pTex;
}

/******************************Public*Routine******************************\
* DrawTextures
*
* Draw all the textures
*
\**************************************************************************/

static void 
DrawTextures() 
{
    for( int i = 0; i < NUM_SURFACES; i++ ) {
        DrawTexture( i );
    }
}

/******************************Public*Routine******************************\
* DrawTexture
*
* Draw appropriate texture in supplied window (e.g. a button)
* - Use TEX_INFO state to determine texture
* - Load texture if not in cache
*
\**************************************************************************/

static void 
DrawTexture( int surface ) 
{
    TEXTURE *pTex;

    // Make sure valid texture loaded for this surface
    if( ! (pTex = ValidateTexture( surface )) )
        return;

    SS_TEX_BUTTON *pTexBtn = gTex[surface].pTexBtn;
    // pTexBtn never NULL, else ss_ConfigInit fails

    // If palette rotation for this texture, slam in the current rotation,
    // to be used by pTexBtn->Draw
    if( pTex->pal )
        pTex->iPalRot = gTex[surface].iPalRot;

    pTexBtn->Draw( pTex );
}

/******************************Public*Routine******************************\
* RegisterDialogClasses
*
\**************************************************************************/

BOOL WINAPI RegisterDialogClasses(HANDLE hinst)
{
    return TRUE;
}

/******************************Public*Routine******************************\
* HandlePreviewDraw
*
* History:
*  Dec. 95 [marcfo]
*    - Creation
\**************************************************************************/

static BOOL
HandlePreviewDraw( UINT idCtl, LPDRAWITEMSTRUCT lpdis )
{
    int surface = DLG_PREVIEW_TO_SURFACE( idCtl );

    if( lpdis->itemAction == ODA_DRAWENTIRE ) {
        DrawTexture( surface );
        return TRUE;
    }
    return FALSE;
}

/******************************Public*Routine******************************\
* HandleTexButtonNewTexture
*
* - Handle when a user selects a new texture
*
* If the new texture fails to load (unlikely, since we validate a good chunk
* of it with the selection dialog), then the current default texture is
* used.
\**************************************************************************/

static void
HandleTexButtonNewTexture( int surface )
{
    TEXTURE *pTex = &gTex[surface].userTex;

    // Delete the old texture
    ss_DeleteTexture( pTex );

    // Load up the new texture
    if( ! ss_LoadTextureFile( &gTexInfo[surface].texFile, pTex ) )
        gTexInfo[surface].bDefTex = TRUE;
}

/******************************Public*Routine******************************\
* MazeDlgTimerProc
*
* Runs off of WM_TIMER message.  Used for any gl animation in the dialog
*
* History:
*  Jan. 96 [marcfo]
*    - Creation
\**************************************************************************/

static void
MazeDlgTimerProc()
{
    extern TEX_RES gTexResSurf[]; // from glmaze.c

    if( ss_PalettedTextureEnabled() ) {
        TEX_INFO *pti = gTexInfo;
        int i;

        // rotate texture palettes for surfaces with a8 palettes

        for( i = 0; i < NUM_SURFACES; i++, pti++ ) {
            if( pti->bTex &&
                pti->bDefTex &&
                ( gTexResSurf[pti->iDefTex].type == TEX_A8 ) )
            {
                // Increment palette rotation for this surface
                gTex[i].iPalRot++;
                // Draw texture associated with the surface
                DrawTexture( i );
            }
        }
    }
}

/******************************Public*Routine******************************\
* ConfigInit
*
* Do Initialization for Config mode
*
* This is the config equivalent of ss_Init
*
* Setup SS_TEX_BUTTON wrappers for each of the 3 texture preview buttons.
\**************************************************************************/

BOOL
ss_ConfigInit( HWND hDlg )
{
    SS_DBGLEVEL1( SS_LEVEL_INFO, "ConfigInit for %d\n", hDlg );

    // Create GL texture buttons to draw the surface previews

    SS_TEX_BUTTON *pTexBtn;

    for( int i = 0; i < NUM_SURFACES; i++ ) {
        pTexBtn = new SS_TEX_BUTTON( hDlg,
                            GetDlgItem(hDlg, DLG_SURFACE_TO_PREVIEW(i)) );
        if( !pTexBtn ) {
            return FALSE;
        }
        gTex[i].pTexBtn = pTexBtn;
    }

    updateGLState();

    // Start a timer for animating texture palettes
    idTimer = 1;
    SetTimer(hDlg, idTimer, 16, 0);

    // Note: no textures are loaded here, they are 'demand-loaded'
    return TRUE;
}

/******************************Public*Routine******************************\
* ScreenSaverConfigureDialog
*
* Processes messages for the configuration dialog box.
*
* History:
*  Nov. 95 [marcfo]
*    - Creation
\**************************************************************************/

BOOL ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                WPARAM wParam, LPARAM lParam)
{
    int wTmp, surface;
    static BOOL bInited = 0;

    switch (message) {
        case WM_INITDIALOG:
            getIniSettings();
            setupDialogControls(hDlg);
            // cache the window handle
            ghDlg = hDlg;
            return TRUE;

        case WM_TIMER:
            MazeDlgTimerProc();
            return 0;
            break;

        case WM_DRAWITEM:
            switch( (UINT) wParam ) {
                case DLG_PREVIEW_WALLS:
                case DLG_PREVIEW_FLOOR:
                case DLG_PREVIEW_CEILING:
                    if( HandlePreviewDraw( (UINT) wParam, 
                                             (LPDRAWITEMSTRUCT) lParam ) )
                        return TRUE;
                default:
                    break;
            }
            break;

        case WM_VSCROLL:
            switch(LOWORD(wParam))
            {
                case SB_THUMBPOSITION:
                    // get new value
                    wTmp = HIWORD(wParam);
                    {
                        int id;
                        HWND hwndScroll = (HWND) lParam;

                        id = GetDlgCtrlID( hwndScroll );
                        surface = DLG_SPIN_TEX_TO_SURFACE( id );
                        gTexInfo[surface].iDefTex = wTmp;
                        DrawTexture( surface );
                    }
                    break;
                default:
                    break;
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                    
                case DLG_BUTTON_WALLS_TEX:
                case DLG_BUTTON_FLOOR_TEX:
                case DLG_BUTTON_CEILING_TEX:
                    surface = DLG_BUTTON_TEX_TO_SURFACE( LOWORD(wParam) );
                    if( DialogBoxParam( 
                        hMainInstance, 
                        (LPTSTR) MAKEINTRESOURCE( DLG_TEXTURE_CONFIGURE ),
                        hDlg, (DLGPROC)TextureConfigureDialog, surface ) ) {
                    //mf: If anything changed here, we have to draw it, as it
                    // seems when choose texture dialog box terminates, we
                    // don't get any DRAW_ITEM messages.
                    // Draw preview area
                        DrawTexture( surface );
                    }
                    break;

                case DLG_CHECK_OVERLAY:
                    maze_options.top_view = !maze_options.top_view;
                    CheckDlgButton(hDlg, DLG_CHECK_OVERLAY, 
                                   maze_options.top_view );
                    break;

                case DLG_CHECK_TURBOMODE:
                    gbTurboMode = !gbTurboMode;
                    CheckDlgButton(hDlg, DLG_CHECK_TURBOMODE, gbTurboMode );
                    updateGLState();
                    DrawTextures();
                    break;

                case DLG_COMBO_IMAGEQUAL:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        case CBN_SELCHANGE:
                          {
                            int oldImageQual = giImageQual; 
                            giImageQual = 
                                (int)SendDlgItemMessage(hDlg, DLG_COMBO_IMAGEQUAL,
                                                        CB_GETCURSEL, 0, 0);
                            if( giImageQual != oldImageQual ) {
                                // change has occurred - redraw any gl objects
                                updateGLState();
                                DrawTextures();
                            }
                          }
                          break;
                        default:
                            return FALSE;
                    }
                    break;

                case IDOK:
                    saveIniSettings(hDlg);
                    // fall thru...

                case IDCANCEL:
                    CleanUp( hDlg );
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return 0;
                    break;
            }
            updateDialogControls(hDlg);
            return TRUE;
            break;

        default:
            return 0;
    }
    return 0;
}


/******************************Public*Routine******************************\
* updateTextureConfigControls
*
* Updates dialog controls according to current state
* 
* History:
*    - Creation
\**************************************************************************/

static void 
updateTextureConfigControls(HWND hDlg, BOOL bDefTex )
{
    CheckDlgButton(hDlg, IDC_RADIO_TEX_DEFAULT, bDefTex );
    CheckDlgButton(hDlg, IDC_RADIO_TEX_CHOOSE, !bDefTex );

    EnableWindow(GetDlgItem(hDlg, DLG_BUTTON_TEX_CHOOSE ), !bDefTex );
}

/******************************Public*Routine******************************\
* TextureConfigureDialog
*
* Processes messages for the texture configure dialog box.
*
* - Call EndDialog with TRUE if texture changed, otherwise FALSE
*
* History:
*  Dec. 95 [marcfo]
*    - Creation
\**************************************************************************/

static BOOL CALLBACK 
TextureConfigureDialog(HWND hDlg, UINT message,
                            WPARAM wParam, LPARAM lParam)
{
    // static state ok here, cuz only one of these dialogs can be active
    static int surface;
    static BOOL bDefTex; // temporary state

    switch (message) {
        case WM_INITDIALOG:
            // Cache some initial values
            surface = (int) lParam;
            bDefTex = gTexInfo[surface].bDefTex;
            updateTextureConfigControls(hDlg, bDefTex );
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                    
                case DLG_BUTTON_TEX_CHOOSE:
                    if( ss_SelectTextureFile( hDlg, 
                                         &gTexInfo[surface].texFile ) ) {
                        // New user texture was selected
                        HandleTexButtonNewTexture( surface );

                        // For now, let's end the dialog right here if a
                        // new one chosen - otherwise we'd have to make the
                        // new texture discardable if user entered Cancel
                        gTexInfo[surface].bDefTex = bDefTex;
                        EndDialog(hDlg, TRUE );
                    }
                    break;

                case IDC_RADIO_TEX_DEFAULT:
                    bDefTex = TRUE;
                    break;
                    
                case IDC_RADIO_TEX_CHOOSE:
                    bDefTex = FALSE;
                    break;
                    
                case IDOK:
                    // save state
                    gTexInfo[surface].bDefTex = bDefTex;
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return 0;
                    break;
            }
            updateTextureConfigControls(hDlg, bDefTex );
            return TRUE;
            break;

        default:
            return 0;
    }
    return 0;
}

/******************************Public*Routine******************************\
* CleanUp
*
\**************************************************************************/

static void
CleanUp( HWND hwnd )
{
    int i;

    if (idTimer) {
        KillTimer(hwnd, idTimer);
        idTimer = 0;
    }

    // delete any textures and tex buttons created

    for( i = 0; i < NUM_SURFACES; i ++ ) {
        if( gTex[i].userTex.data )
            ss_DeleteTexture( &gTex[i].userTex );
        if( gDefTex[i].data )
            ss_DeleteTexture( &gDefTex[i] );
        if( gTex[i].pTexBtn )
            delete gTex[i].pTexBtn;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\genmaze.c ===
#include "pch.c"
#pragma hdrstop

/*
  Maze generation based on Kruskal's algorithm
  
  Consider all possible paths as sets of connected cells.  Initially
  all cells are unconnected and all walls are present.  Pick a wall
  at random and determine if the cells on either side of the wall are
  connected by any possible path.  If they are, try again.  If not,
  knock out the wall and union the two path sets together.
  */
#include <stdlib.h>
#include <memory.h>

#include "genmaze.h"

typedef struct _MazeCell
{
    /* Pointer to the head of the set of cells reachable from this one.
       Easily identifies an entire set for comparison */
    struct _MazeCell *set;
    /* Pointer to the next cell in this connected set */
    struct _MazeCell *next;
} MazeCell;

typedef struct _MazeWall
{
    BYTE wall;
    int x, y;
} MazeWall;

/*
  Union two connection sets together by setting all elements in one
  to the set of the other and then appending it to the end of the
  set list
  */
static void ConnectSets(MazeCell *set, MazeCell *add)
{
    /* Locate end of set */
    while (set->next != NULL)
    {
        set = set->next;
    }

    /* Change to point to head of set */
    add = add->set;
    
    /* Append new cells */
    set->next = add;

    /* Change new cells' set identity */
    while (add != NULL)
    {
        add->set = set->set;
        add = add->next;
    }
}

/*
  Determine whether the two cells are already connected.  With the
  existing data structures this is a trivial comparison of set
  identities
  */
#define SetsAreConnected(a, b) \
    ((a)->set == (b)->set)

/* Locate a cell in a known array */
#define CellAt(x, y) (cells+(x)+(y)*width)

/* Locate a cell in the output array */
#define MazeAt(x, y) (maze+(x)+(y)*(width+1))

/*
  Generate a maze by deleting walls at random
  Width and height are the counts of cells

  Result is stored in the walls array, formatted as (width+1)*(height+1)
  cells with MAZE_WALL_HORZ | MAZE_WALL_VERT set appropriately.
  X coordinates are one byte apart, so maze is treated like
  maze[height+1][width+1]
  */
BOOL GenerateMaze(int width, int height, BYTE *maze)
{
    MazeCell *cells;
    MazeWall *walls;
    int ncells;
    int nwalls;
    int i, x, y;
    MazeCell *ca, *cb;
    MazeWall *w, wt;

    ncells = width*height;
    cells = (MazeCell *)malloc(sizeof(MazeCell)*ncells);
    if (cells == NULL)
    {
        return FALSE;
    }

    nwalls = (width-1)*height+(height-1)*width;
    walls = (MazeWall *)malloc(sizeof(MazeWall)*nwalls);
    if (walls == NULL)
    {
        free(cells);
        return FALSE;
    }

    /* Initialize all cells to be unique sets */
    ca = cells;
    for (i = 0; i < ncells; i++)
    {
        ca->set = ca;
        ca->next = NULL;
        ca++;
    }

    /* Add all internal horizontal and vertical walls.
       All edge walls will be present in the final maze so
       they aren't considered here */
    w = walls;
    for (x = 1; x < width; x++)
    {
        for (y = 0; y < height; y++)
        {
            w->wall = MAZE_WALL_VERT;
            w->x = x;
            w->y = y;
            w++;
        }
    }
    for (y = 1; y < height; y++)
    {
        for (x = 0; x < width; x++)
        {
            w->wall = MAZE_WALL_HORZ;
            w->x = x;
            w->y = y;
            w++;
        }
    }

    /* Randomize the wall array */
    for (i = nwalls-1; i > 0; i--)
    {
        w = walls+(rand() % i);
        wt = *w;
        *w = walls[i];
        walls[i] = wt;
    }

    /* Now walk the random list of walls, knocking walls out to
       join cells together */
    w = walls;
    for (i = 0; i < nwalls; i++)
    {
        /* Determine the two cells separated by the current wall */
        ca = CellAt(w->x, w->y);
        if (w->wall == MAZE_WALL_HORZ)
        {
            cb = CellAt(w->x, w->y-1);
        }
        else
        {
            cb = CellAt(w->x-1, w->y);
        }

        /* If the two cells aren't connected, connect them by knocking
           out the wall */
        if (!SetsAreConnected(ca, cb))
        {
            ConnectSets(ca, cb);
            w->wall = 0;
        }
        
        w++;
    }

    /* Initialize output to empty */
    memset(maze, 0, sizeof(BYTE)*(width+1)*(height+1));
    
    /* Set all edge walls in the output */
    for (x = 0; x < width; x++)
    {
        *MazeAt(x, 0) |= MAZE_WALL_HORZ;
        *MazeAt(x, height) |= MAZE_WALL_HORZ;
    }
    for (y = 0; y < height; y++)
    {
        *MazeAt(0, y) |= MAZE_WALL_VERT;
        *MazeAt(width, y) |= MAZE_WALL_VERT;
    }

    /* Copy remaining walls into the output array */
    w = walls;
    for (i = 0; i < nwalls; i++)
    {
        *MazeAt(w->x, w->y) |= w->wall;
        w++;
    }

    free(cells);
    free(walls);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\glmaze.c ===
#include "pch.c"
#pragma hdrstop

#include <time.h>
#include "mazedlg.h"
#include <assert.h>

MazeView vw;
MazeSolution sol;

MazeOptions maze_options =
{
    FALSE,          // depth_test
    RENDER_FLAT,    // render mode (WALLS)
    RENDER_FLAT,    // render mode (FLOOR)
    RENDER_FLAT,    // render mode (CEILING)
    FALSE,           // frame_count
    FALSE,          // top_view
    TRUE,           // eye_view
    FALSE,          // single_step
    FALSE,          // all_alpha
    FALSE,          // bDither
    1               // nrats
};

float gfAspect = 1.0f;  // aspect ratio

#define SST_NEW_MAZE    0
#define SST_MAZE_GROW   1
#define SST_SOLVING     2
#define SST_MAZE_SHRINK 3
#define SST_ROTATE      4

int solve_state = SST_NEW_MAZE;

// Table of textures used.  The first entries contain 1 texture for each main
// surface, followed by textures used for various objects
TEXTURE all_textures[NUM_TEXTURES];

// Environment associated with the texture (repetition, palette rotation,..) 
// For now, have one for each of the textures in all_textures.  But, this 
// could be a per-object thing.
TEX_ENV gTexEnv[NUM_TEXTURES];

// texture environment mode
int gTexEnvMode;

// Texture resources for the main surfaces
TEX_RES gTexResSurf[NUM_DEF_SURFACE_TEXTURES] = {
    {TEX_BMP, IDB_BRICK},       // default textures
    {TEX_BMP, IDB_WOOD},
    {TEX_BMP, IDB_CASTLE},
    {TEX_A8,  IDB_CURL4},       // mandelbrot textures
    {TEX_A8,  IDB_BHOLE4},
    {TEX_A8,  IDB_SNOWFLAK},
    {TEX_A8,  IDB_SWIRLX4}
};
    
// Texture resources for objects
TEX_RES gTexResObject[NUM_OBJECT_TEXTURES] = {
    {TEX_A8,  IDB_START},
    {TEX_A8,  IDB_END},
    {TEX_A8,  IDB_RAT},
    {TEX_A8,  IDB_AD},
    {TEX_BMP, IDB_COVER}
};
SSContext gssc;

void maze_Init( void *data );
void RotateTexturePalettes( TEX_ENV *pTexEnv, int count, int iRot );

enum {
    TIMER_START = 0,
    TIMER_STOP
};

void Draw(void)
{
    GLbitfield mask;

    mask = 0;
    if (maze_options.depth_test)
    {
        mask |= GL_DEPTH_BUFFER_BIT;
    }
    if (maze_options.render[FLOOR] == RENDER_NONE ||
        maze_options.render[CEILING] == RENDER_NONE ||
        maze_options.render[WALLS] == RENDER_NONE ||
        maze_height < 1.0f)
    {
        mask |= GL_COLOR_BUFFER_BIT;
    }
    if (mask != 0)
    {
        glClear(mask);
    }

    // Rotate the palettes of any paletted texures by 1
    RotateTexturePalettes( gTexEnv, NUM_TEXTURES, 1 );

    if (maze_options.eye_view)
    {
        DrawMaze(&vw);
    }

    if (maze_options.top_view)
    {
        DrawTopView(&vw);
    }
    
    glFlush();
}

MazeGoal maze_goals[MAX_GOALS];
int ngoals;

Object special_obj[MAX_SPECIALS];

#define MAX_LETTERS 3
Object letters_obj[MAX_LETTERS];

typedef struct _Rat
{
    Object obj;
    MazeView vw;
    MazeSolution sol;
} Rat;
Rat rats[MAX_RATS];

void NewMazeList(void)
{
    glNewList(maze_walls_list, GL_COMPILE);
    DrawMazeWalls();
    glEndList();
}

void UpdateRatPosition(Rat *rat)
{
    MoveObject(&rat->obj, rat->vw.pos.x, rat->vw.pos.y);
    // Invert the angle because view angles move opposite to
    // object angles
    rat->obj.ang = FaAdd(0, -rat->vw.ang);
}

// Simple routines to pick cells at random while guaranteeing
// that those cells are unoccupied

static int rnd_cells[MAZE_CELLS];
static int nrnd_cells;

void InitRandomCells(void)
{
    int i;

    nrnd_cells = MAZE_CELLS;
    for (i = 0; i < nrnd_cells; i++)
    {
        rnd_cells[i] = i;
    }
}

void PickRandomCell(IntPt2 *pos)
{
    int idx, t;

#if DBG
    if (nrnd_cells == 0)
    {
        MessageBox(GetDesktopWindow(), TEXT("Out of random cells"),
                   NULL, MB_OK);
        pos->x = 0;
        pos->y = 0;
        return;
    }
#endif
    
    idx = rand() % nrnd_cells;
    nrnd_cells--;
    t = rnd_cells[idx];
    rnd_cells[idx] = rnd_cells[nrnd_cells];
    pos->x = t % MAZE_GRID;
    pos->y = t / MAZE_GRID;
}

void RemoveRandomCell(IntPt2 *pos)
{
    int i, idx;

    for (i = 0; i < nrnd_cells; i++)
    {
        idx = rnd_cells[i];
        if ((idx % MAZE_GRID) == pos->x &&
            (idx / MAZE_GRID) == pos->y)
        {
            nrnd_cells--;
            rnd_cells[i] = rnd_cells[nrnd_cells];
            return;
        }
    }
}

void NewMaze(void)
{
    IntPt2 cell, start_cell;
    int i, nspecials, nads;
    static BOOL firstMaze = TRUE;

    // If not in full screen mode, move the maze window around after it's solved
    if( !gbTurboMode && !firstMaze )
        ss_RandomWindowPos();

    InitRandomCells();
    
    if (!InitMaze(&start_cell, maze_goals, &ngoals))
    {
        printf("InitMaze failed\n");
        exit(1);
    }

    RemoveRandomCell(&start_cell);
    cell.x = maze_goals[GOAL_END].clx;
    cell.y = maze_goals[GOAL_END].cly;
    RemoveRandomCell(&cell);

    nspecials = rand() % MAX_SPECIALS;
    for (i = 0; i < nspecials; i++)
    {
        PickRandomCell(&cell);
        maze_goals[ngoals].clx = cell.x;
        maze_goals[ngoals].cly = cell.y;
        maze_goals[ngoals].user = &special_obj[i];
        
        special_obj[i].w = FMAZE_CELL_SIZE/4;
        special_obj[i].h = FxFltVal(.25);
        special_obj[i].z = special_obj[i].h;
        special_obj[i].col = 15;
        special_obj[i].draw_style = DRAW_SPECIAL;
        special_obj[i].draw_arg = rand() % SPECIAL_ARG_COUNT;
        special_obj[i].ang = FaDeg(0);
        special_obj[i].user1 = (rand() % 6)+2;
        special_obj[i].user2 = rand() % 5;
        special_obj[i].user3 = 0;
        PlaceObject(&special_obj[i],
                    CellToMfx(maze_goals[ngoals].clx)+FMAZE_CELL_SIZE/2,
                    CellToMfx(maze_goals[ngoals].cly)+FMAZE_CELL_SIZE/2);
        ngoals++;
    }
    while (i < MAX_SPECIALS)
    {
        special_obj[i].cell = NULL;
        i++;
    }

    nads = (rand() % (MAX_LETTERS*2))-MAX_LETTERS+1;
    for (i = 0; i < nads; i++)
    {
        PickRandomCell(&cell);
        
        letters_obj[i].w = FMAZE_CELL_SIZE/3;
        letters_obj[i].h = FxFltVal(.33);
        letters_obj[i].z = FxFltVal(.5);
        letters_obj[i].col = 15;
        letters_obj[i].draw_style = DRAW_POLYGON;
        letters_obj[i].pTexEnv = &gTexEnv[ TEX_AD ];
        letters_obj[i].ang = FaDeg(0);
        PlaceObject(&letters_obj[i],
                    CellToMfx(cell.x)+FMAZE_CELL_SIZE/2,
                    CellToMfx(cell.y)+FMAZE_CELL_SIZE/2);
    }
    while (i < MAX_LETTERS)
    {
        letters_obj[i].cell = NULL;
        i++;
    }

    for (i = 0; i < maze_options.nrats; i++)
    {
        PickRandomCell(&cell);
        
        rats[i].obj.w = FMAZE_CELL_SIZE/4;
        rats[i].obj.h = FxFltVal(.125);
        rats[i].obj.z = rats[i].obj.h;
        rats[i].obj.col = 16;
        rats[i].obj.draw_style = DRAW_POLYGON;
        rats[i].obj.pTexEnv = &gTexEnv[ TEX_RAT ];
        SolveMazeStart(&rats[i].vw, &maze_cells[0][0], MAZE_GRID, MAZE_GRID,
                       &cell, SOL_DIR_LEFT,
                       NULL, 0,
                       (rand() % 1000) > 500 ? SOL_TURN_LEFT : SOL_TURN_RIGHT,
                       &rats[i].sol);
        // Need to force this to NULL when a new maze is generated so
        // that moving doesn't try to use old maze data
        rats[i].obj.cell = NULL;
        UpdateRatPosition(&rats[i]);
    }
    
    NewMazeList();
    
    SolveMazeStart(&vw, &maze_cells[0][0], MAZE_GRID, MAZE_GRID,
                   &start_cell, SOL_DIR_RIGHT,
                   maze_goals, ngoals,
                   (rand() % 1000) > 500 ? SOL_TURN_LEFT : SOL_TURN_RIGHT,
                   &sol);

    solve_state = SST_MAZE_GROW;
    firstMaze = FALSE;
}

/**************************************************************************\
* Step
*
* Main draw proc
*
\**************************************************************************/

static MazeGoal *found_goal = NULL;
static int rot_step;

void Step(void *data)
{
    int i;
    MazeGoal *goal;

    switch(solve_state)
    {
    case SST_NEW_MAZE:
        view_rot = 0;
        maze_height = 0.0f;
        NewMaze();
        break;

    case SST_SOLVING:
        for (i = 0; i < maze_options.nrats; i++)
        {
            SolveMazeStep(&rats[i].vw, &rats[i].sol);
            UpdateRatPosition(&rats[i]);
        }
        
        goal = SolveMazeStep(&vw, &sol);
        if (goal == &maze_goals[GOAL_END])
        {
            solve_state = SST_MAZE_SHRINK;
        }
        else if (goal != NULL)
        {
            solve_state = SST_ROTATE;
            found_goal = goal;
            rot_step = 0;
        }
        break;

    case SST_MAZE_GROW:
        maze_height += .025f;
        if (maze_height >= 1.0f)
        {
            solve_state = SST_SOLVING;
        }
        break;
        
    case SST_MAZE_SHRINK:
        maze_height -= .025f;
        if (maze_height <= 0.0f)
        {
            solve_state = SST_NEW_MAZE;
        }
        break;

    case SST_ROTATE:
        view_rot += 10.0;
        if (++rot_step == 18)
        {
            Object *sp_obj;

            sp_obj = (Object *)found_goal->user;
            RemoveObject(sp_obj);
            
            solve_state = SST_SOLVING;
            ngoals--;
            if (found_goal < maze_goals+ngoals)
            {
                memmove(found_goal, found_goal+1,
                        sizeof(MazeGoal)*(size_t)((ULONG_PTR)(ngoals-(found_goal-maze_goals))));
            }
            SolveMazeSetGoals(&sol, maze_goals, ngoals);
            found_goal = NULL;

            if (view_rot >= 360.0)
            {
                view_rot = 0.0;
            }
            else
            {
                view_rot = 180.0;
            }
        }
        break;
    }

    Draw();

    for (i = 0; i < MAX_SPECIALS; i++)
    {
        // Increment rotations of any specials still present in the maze
        if (special_obj[i].cell != NULL)
        {
            special_obj[i].ang = FaAdd(special_obj[i].ang,
                                       FaDeg(special_obj[i].user1));
            special_obj[i].user3 += special_obj[i].user2;
        }
    }
}

void UpdateModes(void)
{
    if (maze_options.depth_test)
    {
        glEnable(GL_DEPTH_TEST);
    }
    else
    {
        glDisable(GL_DEPTH_TEST);
    }
}

/**************************************************************************\
* Reshape
*
*       - called on resize, expose                                      
*       - always called on app startup                                  
*
\**************************************************************************/

void 
Reshape(int width, int height, void *data )
{
    gfAspect = height == 0 ? 1.0f: (float) width / (float) height;
}


/******************************Public*Routine******************************\
* VerifyTextureFiles
*
* Check that any user specified textures are valid
* - MUST be called at ss_Init, or any error msgs will not display properly
*
\**************************************************************************/

void VerifyTextureFiles(void)
{
    int i;

    ss_DisableTextureErrorMsgs();

    for (i = 0; i < NUM_SURFACES; i++) {
        if( gTexInfo[i].bTex && !gTexInfo[i].bDefTex ) {
            if( !ss_VerifyTextureFile( &gTexInfo[i].texFile ) )
                // use default texture
                gTexInfo[i].bDefTex = TRUE;
        }
    }
}

/******************************Public*Routine******************************\
* CalcRep
*
* Figure out repetion based on size.
*
* - Use 128 pixels as a unit repetition reference
* - Size is always a power of 2
*
\**************************************************************************/

static int
CalcRep( int size )
{
    double pow2;
    int pow2ref = 8;
    int rep;

    pow2 = log((double)size) / log((double)2.0);
    rep = 1 + pow2ref - (int)pow2;
    return rep; 
}

//mf: tradeoff
#define MAX_TEX_DIM 128
//#define MAX_TEX_DIM 256

/******************************Public*Routine******************************\
* CalcTexRep
*
* Figure out texture repetition based on texture size.
*
* - mf: ? double for walls/ceiling ?
*
\**************************************************************************/

static void
CalcTexRep( TEXTURE *pTex, IPOINT2D *pTexRep )
{
    if( pTex->width >= MAX_TEX_DIM )
        pTexRep->x = 1;
    else
        pTexRep->x = CalcRep( pTex->width );

    if( pTex->height >= MAX_TEX_DIM )
        pTexRep->y = 1;
    else
        pTexRep->y = CalcRep( pTex->height );
}

/******************************Public*Routine******************************\
* LoadTextures
*
* Load textures from .bmp files or from embedded resources, using
* global texture info structure.
*
* For now, this also sets render modes, since if texturing is off for a
* surface, we always use RENDER_FLAT
*
* History:
*  - Nov. 95 [marcfo] : Creation
*  - Jan. 96 [marcfo] : Load surface and object textures separately.  The 3
*       surface textures occupy the first locations of the all_textures[]
*       array, and the object textures follow.
*
\**************************************************************************/

static void 
LoadTextures(void)
{
    int i;
    TEXTURE *pTex = all_textures;
    TEX_ENV *pTexEnv = gTexEnv;
    TEX_RES *pTexRes;

    assert( (NUM_SURFACES + NUM_OBJECT_TEXTURES) == NUM_TEXTURES );

    // load surface textures (wall, floor, ceiling)

    for (i = 0; i < NUM_SURFACES; i++, pTex++, pTexEnv++) {
        maze_options.render[i] = RENDER_FLAT;
        if( gTexInfo[i].bTex ) {
            pTexEnv->pTex = pTex;
            pTexEnv->bTransp = FALSE;

            // Load user or default texture for the surface

            if( !gTexInfo[i].bDefTex && 
                ss_LoadTextureFile( &gTexInfo[i].texFile, pTex )) {
            } else
            {
                // Load default resource texture

                pTexRes = &gTexResSurf[ gTexInfo[i].iDefTex ];
                if( !ss_LoadTextureResource( pTexRes, pTex ) )
                    continue; 
    
                if( ss_PalettedTextureEnabled() &&
                    (pTexRes->type == TEX_A8) )
                {
                    pTexEnv->bPalRot = TRUE;
                    pTexEnv->iPalRot = ss_iRand( 0xff );
                } else
                    pTexEnv->bPalRot = FALSE;
            }

            maze_options.render[i] = RENDER_TEXTURED;

            // Figure out texture repetition
            CalcTexRep( pTex, &pTexEnv->texRep );
            // We would have to set texture parameters per object here,
            // but we just use default ones already set by ss_LoadTexture*
        }
    }

    // load object textures

    pTexRes = gTexResObject;
    for( i = 0; i < NUM_OBJECT_TEXTURES; i++, pTex++, pTexEnv++, pTexRes++ ) {
        if( ss_LoadTextureResource( pTexRes, pTex ) )
            pTexEnv->pTex = pTex;
        else
            pTexEnv->pTex = NULL;

        pTexEnv->bTransp = FALSE;

        // For now we don't do palrot's on any of the object textures
        pTexEnv->bPalRot = FALSE;
        // No repetition
        pTexEnv->texRep.x = pTexEnv->texRep.y = 1;
    }

    // Set transparency for some of the textures
    ss_SetTextureTransparency( gTexEnv[TEX_START].pTex, 0.42f, FALSE );
    ss_SetTextureTransparency( gTexEnv[TEX_END].pTex, 0.4f, FALSE );
    ss_SetTextureTransparency( gTexEnv[TEX_AD].pTex, 0.4f, FALSE );

#if 0
    // Enough already with the transparency!
    ss_SetTextureTransparency( &all_textures[TEX_COVER], 0.6f, FALSE );
    ss_SetTextureTransparency( &all_textures[TEX_WALL], 0.5f, FALSE );
#endif

    // Enable transparency for some of the texture environments
    gTexEnv[TEX_START].bTransp = TRUE;
    gTexEnv[TEX_END].bTransp = TRUE;
    gTexEnv[TEX_AD].bTransp = TRUE;
}

void UseTextureEnv( TEX_ENV *pTexEnv )
{
    static HTEXTURE hCurTex = (HTEXTURE) -1;
    HTEXTURE hTex = pTexEnv->pTex;

    // We cache the current texture for 'no texture object' case

    if( !ss_TextureObjectsEnabled() &&
        (hCurTex == hTex) )
        return; // same texture, no need to send it down

    // Make this texture current

    ss_SetTexture( hTex );

    // Set texture palette if necessary

    if( pTexEnv->bPalRot &&
        !ss_TextureObjectsEnabled() && 
        ss_PalettedTextureEnabled() ) {

        // We need to send down the (rotated) palette
        ss_SetTexturePalette( hTex, pTexEnv->iPalRot );
    }

    hCurTex = hTex;
}

/******************************Public*Routine******************************\
* RotateTexturePalettes
*
* If paletted texturing is enabled, go through the supplied list of texture
* environments, and if any have a palette, increment its rotation by the
* supplied iRot value.
*
\**************************************************************************/

void
RotateTexturePalettes( TEX_ENV *pTexEnv, int count, int iRot )
{
    int i;

    if( !ss_PalettedTextureEnabled() || !pTexEnv )
        return;


    for( ; count; count--, pTexEnv++ ) {

        if( !pTexEnv->pTex || !pTexEnv->pTex->pal )
            continue;

        if( pTexEnv->bPalRot ) {
            // increment palette rotation
            pTexEnv->iPalRot += iRot;
            if( pTexEnv->iPalRot >= pTexEnv->pTex->pal_size )
                pTexEnv->iPalRot = 0;
            // Only send down the new palette if texture objects are enabled,
            // since otherwise it will be sent down when texture is 
            // 'made current'
            if( ss_TextureObjectsEnabled() ) {
                ss_SetTexturePalette( pTexEnv->pTex, pTexEnv->iPalRot );
            }
        }
    }
}

/******************************Public*Routine******************************\
* InitStretchInfo
*
\**************************************************************************/

static void
InitStretchInfo( STRETCH_INFO *pStretch )
{
    ISIZE screen;

    pStretch->baseWidth = 320;
    pStretch->baseHeight = 200;
    pStretch->bRatioMode = FALSE;
}

/******************************Public*Routine******************************\
* SetFloaterInfo
*
* Set the size and position of the floating child window
*
\**************************************************************************/


static void 
SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild )
{
    float hdtvAspect = 9.0f / 16.0f;
    ISIZE *pChildSize = &pChild->size;

    // Set width according to user-specified size
    // (giSize range is 0..100)
    // set min size as 1/3 parent width
    pChildSize->width = 
            (int) ((0.333f + 2.0f*giSize/300.0f) * pParentSize->width);

    // Scale height for hdtv aspect ratio
    pChildSize->height = (int) (hdtvAspect * pChildSize->width + 0.5f);
    // Ensure height not too big
    SS_CLAMP_TO_RANGE2( pChildSize->height, 0, pParentSize->height );

    pChild->pos.x = (pParentSize->width - pChildSize->width) / 2;
    pChild->pos.y = (pParentSize->height - pChildSize->height) / 2;
}

/******************************Public*Routine******************************\
* ss_Init
*
* Initialize - called on first entry into ss.
* Called BEFORE gl is initialized!
* Just do basic stuff here, like set up callbacks, verify dialog stuff, etc.
*
* Fills global SSContext structure with required data, and returns ptr
* to it.
*
\**************************************************************************/

SSContext *
ss_Init( void )
{
    getIniSettings();

    VerifyTextureFiles();

    // Set callbacks

    ss_InitFunc( maze_Init );
    ss_UpdateFunc( Step );
    ss_ReshapeFunc( Reshape );

    gssc.depthType = (maze_options.depth_test) ? SS_DEPTH16 : SS_DEPTH_NONE;

    // Currently stretch and floater mutex
    gssc.bDoubleBuf = TRUE; // will get turned off if stretch used
    if( gbTurboMode ) {
        // We stretch out the drawing area to the full size of the main window
        gssc.bFloater = FALSE;
        gssc.bStretch = TRUE;
        InitStretchInfo( &gssc.stretchInfo );
    } else {
        // A static centered floating window is created in the main window
        FLOATER_INFO *pFloater = &gssc.floaterInfo;

        gssc.bFloater = TRUE;
        gssc.bStretch = FALSE;
        pFloater->bMotion = FALSE;
        pFloater->ChildSizeFunc = SetFloaterInfo;
    }

    return &gssc;
}

/******************************Public*Routine******************************\
* maze_Init
*
* Initializes OpenGL state
*
\**************************************************************************/
void
maze_Init( void *data )
{
    float fv4[4];

    if (!FxInitialize(FA_TABLE_SIZE, 0))
    {
        printf("FxInit failed\n");
        exit(1);
    }

    glShadeModel( GL_FLAT );
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    glClearDepth(1);
    
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

    if( (giImageQual == IMAGEQUAL_DEFAULT) || gbTurboMode ) {
        maze_options.bDither = FALSE;
        glDisable( GL_DITHER );
    } else {
        maze_options.bDither = TRUE;
        glEnable( GL_DITHER );
    }

    // Load textures and set render modes
    LoadTextures();
    
    fv4[0] = MAZE_SIZE/2.0f;
    fv4[1] = MAZE_SIZE/2.0f;
    fv4[2] = 10.0f;
    fv4[3] = 1.0f;
    glLightfv(GL_LIGHT0, GL_POSITION, fv4);
    glEnable(GL_LIGHT0);

    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // Check which texture environment function to use for objects
    if( ss_fOnGL11() )
        gTexEnvMode = GL_REPLACE;
    else
        gTexEnvMode = GL_MODULATE; 

    maze_walls_list = glGenLists(1);
    
    UpdateModes();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\mazedlg.h ===
/******************************Module*Header*******************************\
* Module Name: mazedlg.h
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __dialog_h__
#define __dialog_h__

#include "dlgs.h"
#include "sscommon.h"
#include "maze_std.h"

#ifdef __cplusplus
extern "C" {
#endif

#define IDS_SCREENSAVERTITLE    1020
#define IDS_SAVERNAME           1002

// structure to pull in texture info from registry
typedef struct {
    BOOL    bTex;       // texture enable/disable
    BOOL    bDefTex;    // default texture enable/disable
    int     iDefTex;    // default texture index
    TEXFILE texFile;    // user texture file
} TEX_INFO;

// registry strings

#define IDS_TEXTURE_ENABLE              1100
#define IDS_DEFAULT_TEXTURE_ENABLE      1101

#define IDS_WALL_TEXTURE_FILE           1110
#define IDS_FLOOR_TEXTURE_FILE          1111
#define IDS_CEILING_TEXTURE_FILE        1112

#define IDS_WALL_TEXTURE_OFFSET         1120
#define IDS_FLOOR_TEXTURE_OFFSET        1121
#define IDS_CEILING_TEXTURE_OFFSET      1122

#define IDS_DEF_WALL_TEXTURE            1130
#define IDS_DEF_FLOOR_TEXTURE           1131
#define IDS_DEF_CEILING_TEXTURE         1132

#define IDS_OVERLAY                     1200

#define IDS_TURBOMODE                   1250

#define IDS_IMAGEQUAL                   1300

#define IDS_NRATS                       1400

// Dialog box defines

// Imagequal combobox strings
#define IDS_IMAGEQUAL_DEFAULT     1301
#define IDS_IMAGEQUAL_HIGH        1302

#define MIN_SLIDER              0
#define MAX_SLIDER              100

// Size slider
#define DLG_SLIDER_SIZE         2000
#define IDC_STATIC_SIZE         2001
#define IDC_STATIC_MIN          2002
#define IDC_STATIC_MAX          2003

// Maze overly check box
#define DLG_CHECK_OVERLAY       2008

// Turbo mode check box
#define DLG_CHECK_TURBOMODE     2009

// Buttons to choose textures
#define DLG_BUTTON_WALLS_TEX    3100
#define DLG_BUTTON_FLOOR_TEX    3101
#define DLG_BUTTON_CEILING_TEX  3102
#define DLG_BUTTON_TEX_TO_SURFACE(n)    ( (n) - DLG_BUTTON_WALLS_TEX )

// Previews for surfaces (now just texture, but could show like colors)
#define DLG_PREVIEW_WALLS        3200
#define DLG_PREVIEW_FLOOR        3201
#define DLG_PREVIEW_CEILING      3202
#define DLG_PREVIEW_TO_SURFACE(n)    ( (n) - DLG_PREVIEW_WALLS )
#define DLG_SURFACE_TO_PREVIEW(n)    ( (n) + DLG_PREVIEW_WALLS )

// Spin controls for texture previews
//mf: add TEX suffix
#define DLG_SPIN_WALLS           3300
#define DLG_SPIN_FLOOR           3301
#define DLG_SPIN_CEILING         3302
#define DLG_SPIN_TEX_TO_SURFACE(n)    ( (n) - DLG_SPIN_WALLS )

// Resource bitmap id's
#define IDB_BRICK                100
#define IDB_WOOD                 101
#define IDB_CASTLE               102
#define IDB_START                103
#define IDB_END                  104
#define IDB_RAT                  105
#define IDB_AD                   106
#define IDB_COVER                107

#define IDB_CURL4                120
#define IDB_BHOLE4               121
#define IDB_SNOWFLAK             125
#define IDB_SWIRLX4               127

// Image quality box
#define DLG_COMBO_IMAGEQUAL      3500
#define IDC_STATIC_IMAGEQUAL     3501

// Choose texture dialog box

#define DLG_TEXTURE_CONFIGURE   4000

#define IDC_RADIO_TEX_DEFAULT   4010
#define IDC_RADIO_TEX_CHOOSE    4011
#define DLG_BUTTON_TEX_CHOOSE   4012

extern void getIniSettings();
extern TEX_INFO gTexInfo[];
extern int      giSize; // window size
extern BOOL     gbTurboMode;  // turbo mode enable/disable
extern int      giImageQual;  // Image quality (dithering)

#ifdef __cplusplus
}
#endif

#endif // __dialog_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\maze_std.h ===
#ifndef __MAZE_STD_H__
#define __MAZE_STD_H__

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "fixed.h"
#include "genmaze.h"
#include "sscommon.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _IntPt2
{
    int x, y;
} IntPt2;

#define DIR_RIGHT 0
#define DIR_UP 1
#define DIR_LEFT 2
#define DIR_DOWN 3
#define DIR_COUNT 4

typedef struct
{
    TEXTURE  *pTex;   // ptr to texture
    IPOINT2D texRep;  // texture repetition in s and t directions
    BOOL     bPalRot; // whether should rotate texture palette
    int      iPalRot; // current palette rotation start point
    BOOL     bTransp; // transparency on/off for RGBA textures
} TEX_ENV;

typedef struct _MazeView
{
    FxPt2 pos;
    FaAngle ang;
} MazeView;

#define RENDER_NONE     0
#define RENDER_FLAT     1
#define RENDER_SMOOTH   2
#define RENDER_TEXTURED 3
#define RENDER_COUNT    4

// surfaces
enum {
    WALLS = 0,
    FLOOR,
    CEILING,
    NUM_SURFACES
};

// default surface textures
enum {
    BRICK_TEXTURE = 0,
    WOOD_TEXTURE,
    CASTLE_TEXTURE,
    CURL4_TEXTURE,
    BHOLE4_TEXTURE,
    SNOWFLAK_TEXTURE,
    SWIRLX4_TEXTURE,
    NUM_DEF_SURFACE_TEXTURES
};

// textured objects
enum {
    START = 0,
    END,
    RAT,
    AD,
    COVER,
    NUM_OBJECT_TEXTURES
};


enum {
    IMAGEQUAL_DEFAULT = 0,
    IMAGEQUAL_HIGH,
    IMAGEQUAL_COUNT
};

typedef struct _MazeOptions
{
    BOOL depth_test;
    int render[NUM_SURFACES];
    BOOL frame_count;
    BOOL top_view;
    BOOL eye_view;
    BOOL single_step;
    BOOL all_alpha;
    BOOL bDither;
    int nrats;
} MazeOptions;

extern MazeOptions maze_options;

#ifdef __cplusplus
}
#endif

#endif // __MAZE_STD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\pch.c ===
#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>
#include <tk.h>

#include "sscommon.h"
#include "maze_std.h"
#include "glmaze.h"
#include "maze.h"
#include "slvmaze.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\maze.h ===
#ifndef __MAZE_H__
#define __MAZE_H__

#include "maze_std.h"

#define MAZE_GRID 12
#define MAZE_CELLS (MAZE_GRID*MAZE_GRID)
#define MAZE_ARRAY (MAZE_GRID+1)
#define MAZE_ARRAY_CELLS (MAZE_ARRAY*MAZE_ARRAY)
#define N_MAZE_PTS MAZE_ARRAY_CELLS
#define N_MAZE_WALLS (2*MAZE_ARRAY_CELLS)

#define MAZE_WALL_LEFT          0x0004
#define MAZE_WALL_RIGHT         0x0008
#define MAZE_WALL_UP            0x0010
#define MAZE_WALL_DOWN          0x0020
#define MAZE_CONTENTS           0x0040

// Partial flags must be shifted versions of the standard flags
#define MAZE_WALL_LEFT_PARTIAL  0x0080
#define MAZE_WALL_RIGHT_PARTIAL 0x0100
#define MAZE_WALL_UP_PARTIAL    0x0200
#define MAZE_WALL_DOWN_PARTIAL  0x0400
#define MAZE_PARTIAL_SHIFT      5

#define WIDX_LEFT       0
#define WIDX_RIGHT      1
#define WIDX_UP         2
#define WIDX_DOWN       3

#define MAZE_CELL_SIZE 1
#define MAZE_SIZE (MAZE_GRID*MAZE_CELL_SIZE)
#define FMAZE_CELL_SIZE FxVal(MAZE_CELL_SIZE)
#define FMAZE_SIZE FxVal(MAZE_SIZE)

#define MfxToCell(mfx) FxInt(mfx)
#define CellToMfx(cl) FxVal(cl)

struct _Cell;

#define DRAW_POLYGON    0
#define DRAW_SPECIAL    1

#define SPECIAL_ARG_ICOSAHEDRON         0
#define SPECIAL_ARG_OCTAHEDRON          1
#define SPECIAL_ARG_DODECAHEDRON        2
#define SPECIAL_ARG_TETRAHEDRON         3
#define SPECIAL_ARG_COUNT               4

typedef struct _Object
{
    FxPt2 p;
    FxValue z;
    FaAngle ang;
    FxValue w, h;
    int col;
    int draw_style;
    int draw_arg;
    TEX_ENV *pTexEnv;  // ptr to texture environment
    int user1, user2, user3;
    struct _Object *next;
    struct _Cell *cell;
} Object;

typedef unsigned short WallFlags;

typedef struct _Cell
{
    WallFlags can_see;
    WallFlags unseen;
    Object *contents;
    struct _Wall *walls[4];
} Cell;

extern Cell maze_cells[MAZE_GRID][MAZE_GRID];

extern float maze_height;
extern double view_rot;
extern int maze_walls_list;

extern int gTexEnvMode;

#define MAX_GOALS       10
#define MAX_SPECIALS    (MAX_GOALS-1)

#define GOAL_END        0
#define GOAL_SPECIALS   1

BOOL InitMaze(IntPt2 *start_cell, struct _MazeGoal *goals, int *ngoals);

void PlaceObject(Object *obj, FxValue x, FxValue y);
void RemoveObject(Object *obj);
void MoveObject(Object *obj, FxValue x, FxValue y);

void DrawMaze(MazeView *vw);
void DrawMazeWalls(void);
void DrawTopView(MazeView *vw);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\slvmaze.c ===
#include "pch.c"
#pragma hdrstop

static int left_turn[SOL_DIRS] =
{
    SOL_DIR_DOWN, SOL_DIR_LEFT, SOL_DIR_UP, SOL_DIR_RIGHT
};

static int right_turn[SOL_DIRS] =
{
    SOL_DIR_UP, SOL_DIR_RIGHT, SOL_DIR_DOWN, SOL_DIR_LEFT
};

static BYTE dir_wall[SOL_DIRS] =
{
    MAZE_WALL_LEFT, MAZE_WALL_UP, MAZE_WALL_RIGHT, MAZE_WALL_DOWN
};

static int dir_cloff[SOL_DIRS][2] =
{
    -1,0, 0,-1, 1,0, 0,1
};

static FaAngle dir_ang[SOL_DIRS];
static FxPt2 dir_off[SOL_DIRS];

/* We want to traverse one quarter of a circle in the given number of
   steps.  The distance is the arc length which is r*pi/2.  Divide that
   by the number of steps to get the distance each step should travel */
#define ARC_STEP 5
#define ARC_STEPS (90/ARC_STEP)

#define REVERSE_STEP (2*ARC_STEP)
#define REVERSE_STEPS (180/REVERSE_STEP)

static void SetView(MazeSolution *sol, MazeView *vw)
{
    vw->ang = dir_ang[sol->dir];
    vw->pos.x = CellToMfx(sol->clx)+dir_off[sol->dir].x;
    vw->pos.y = CellToMfx(sol->cly)+dir_off[sol->dir].y;
}

void SolveMazeSetGoals(MazeSolution *sol, MazeGoal *goals, int ngoals)
{
    sol->goals = goals;
    sol->ngoals = ngoals;
}

void SolveMazeStart(MazeView *vw,
                    Cell *maze, int w, int h,
                    IntPt2 *start, int start_dir,
                    MazeGoal *goals, int ngoals,
                    int turn_to,
                    MazeSolution *sol)
{
    dir_ang[SOL_DIR_LEFT] = FaDeg(180);
    dir_ang[SOL_DIR_UP] = FaDeg(90);
    dir_ang[SOL_DIR_RIGHT] = FaDeg(0);
    dir_ang[SOL_DIR_DOWN] = FaDeg(270);

    dir_off[SOL_DIR_LEFT].x = CellToMfx(1)-FX_MIN_VALUE;
    dir_off[SOL_DIR_LEFT].y = CellToMfx(1)/2;
    dir_off[SOL_DIR_UP].x = CellToMfx(1)/2;
    dir_off[SOL_DIR_UP].y = CellToMfx(1)-FX_MIN_VALUE;
    dir_off[SOL_DIR_RIGHT].x = FxVal(0);
    dir_off[SOL_DIR_RIGHT].y = CellToMfx(1)/2;
    dir_off[SOL_DIR_DOWN].x = CellToMfx(1)/2;
    dir_off[SOL_DIR_DOWN].y = FxVal(0);
    
    sol->clx = start->x;
    sol->cly = start->y;
    sol->dir = start_dir;
    sol->maze = maze;
    sol->w = w;
    sol->h = h;
    sol->ani_state = ANI_STATE_NONE;

    switch(turn_to)
    {
    case SOL_TURN_RIGHT:
        sol->turn_to = left_turn;
        sol->turn_away = right_turn;
        sol->dir_sign = 1;
        break;

    case SOL_TURN_LEFT:
        sol->turn_to = right_turn;
        sol->turn_away = left_turn;
        sol->dir_sign = -1;
        break;
    }

    SolveMazeSetGoals(sol, goals, ngoals);
    
    SetView(sol, vw);
}

#define MazeAt(x, y) (sol->maze+(x)+(y)*(sol->w))

MazeGoal *SolveMazeStep(MazeView *vw, MazeSolution *sol)
{
    Cell *cell;
    int i, dir, turn_to;

    if (sol->ani_state != ANI_STATE_NONE)
    {
        if (--sol->ani_count == 0)
        {
            sol->ani_state = ANI_STATE_NONE;
            SetView(sol, vw);
        }
    }
    
    switch(sol->ani_state)
    {
    case ANI_STATE_TURN_TO:
        vw->pos.x += FxMulDiv(FaCos(vw->ang),
                              FxFltVal(PI*MAZE_CELL_SIZE/2),
                              FxVal(ARC_STEPS*2));
        vw->pos.y += FxMulDiv(FaSin(vw->ang),
                              FxFltVal(PI*MAZE_CELL_SIZE/2),
                              FxVal(ARC_STEPS*2));
        vw->ang = FaAdd(vw->ang, sol->dir_sign*FaDeg(ARC_STEP));
        return NULL;

    case ANI_STATE_TURN_AWAY:
        vw->pos.x += FxMulDiv(FaCos(vw->ang),
                              FxFltVal(PI*MAZE_CELL_SIZE/2),
                              FxVal(ARC_STEPS*2));
        vw->pos.y += FxMulDiv(FaSin(vw->ang),
                              FxFltVal(PI*MAZE_CELL_SIZE/2),
                              FxVal(ARC_STEPS*2));
        vw->ang = FaAdd(vw->ang, sol->dir_sign * -FaDeg(ARC_STEP));
        return NULL;

    case ANI_STATE_FORWARD:
        vw->pos.x += FxMulDiv(FaCos(vw->ang), MAZE_CELL_SIZE, ARC_STEPS);
        vw->pos.y += FxMulDiv(FaSin(vw->ang), MAZE_CELL_SIZE, ARC_STEPS);
        return NULL;
        
    case ANI_STATE_REVERSE:
        vw->ang = FaAdd(vw->ang, sol->dir_sign*FaDeg(REVERSE_STEP));
        return NULL;
    }

    for (i = 0; i < sol->ngoals; i++)
    {
        if (sol->clx == sol->goals[i].clx &&
            sol->cly == sol->goals[i].cly)
        {
            return &sol->goals[i];
        }
    }

    cell = MazeAt(sol->clx, sol->cly);

    dir = sol->dir;
    for (i = 0; i < SOL_DIRS-1; i++)
    {
        turn_to = sol->turn_to[dir];
        if ((dir_wall[turn_to] & cell->can_see) == 0)
        {
            /* No wall present when turned, so turn that way */
            sol->clx += dir_cloff[turn_to][0];
            sol->cly += dir_cloff[turn_to][1];
            sol->dir = turn_to;

            sol->ani_count = ARC_STEPS;
            switch(i)
            {
            case 0:
                sol->ani_state = ANI_STATE_TURN_TO;
                break;

            case 1:
                sol->ani_state = ANI_STATE_FORWARD;
                break;

            case 2:
                sol->ani_state = ANI_STATE_TURN_AWAY;
                break;
            }
            break;
        }
        else
        {
            /* Wall present, turn away and check again */
            dir = sol->turn_away[dir];
        }
    }

    if (i == SOL_DIRS-1)
    {
        /* Dead end.  Turn around */
        dir = sol->turn_to[sol->turn_to[sol->dir]];
        sol->clx += dir_cloff[dir][0];
        sol->cly += dir_cloff[dir][1];
        sol->dir = dir;

        sol->ani_state = ANI_STATE_REVERSE;
        sol->ani_count = REVERSE_STEPS;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\slvmaze.h ===
#ifndef __SLVMAZE_H__
#define __SLVMAZE_H__

#define ANI_STATE_NONE          0
#define ANI_STATE_TURN_TO       1
#define ANI_STATE_TURN_AWAY     2
#define ANI_STATE_FORWARD       3
#define ANI_STATE_REVERSE       4

#define SOL_DIR_LEFT    0
#define SOL_DIR_UP      1
#define SOL_DIR_RIGHT   2
#define SOL_DIR_DOWN    3
#define SOL_DIRS        4

#define SOL_TURN_LEFT   0
#define SOL_TURN_RIGHT  1

typedef struct _MazeGoal
{
    int clx, cly;
    void *user;
} MazeGoal;

typedef struct _MazeSolution
{
    int clx, cly;
    int dir;
    Cell *maze;
    int w, h;
    MazeGoal *goals;
    int ngoals;
    int ani_state;
    int ani_count;
    int *turn_to;
    int *turn_away;
    int dir_sign;
} MazeSolution;

void SolveMazeStart(MazeView *vw,
                    Cell *maze, int w, int h,
                    IntPt2 *start, int start_dir,
                    MazeGoal *goals, int ngoals,
                    int turn_to,
                    MazeSolution *sol);
void SolveMazeSetGoals(MazeSolution *sol, MazeGoal *goals, int ngoals);
MazeGoal *SolveMazeStep(MazeView *vw, MazeSolution *sol);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by maze.rc
//
#include "windows.h"
#include "scrnsave.h"
// Note: vc4 embeds sscommon.rc into maze.rc
#include "sscommon.rc"
#include "mazedlg.h"
#include "commctrl.h"

#define IDD_DIALOG1                     101
#define IDB_BITMAP1                     102
#define IDC_CHECK1                      1000
#define IDC_CHECK2                      1001
#define IDC_CHECK3                      1002
#define IDC_SCROLLBAR1                  1003
#define IDC_CHECK4                      1005
#define IDC_RADIO1                      1011
#define IDC_RADIO2                      1012
#define IDC_BUTTON1                     1013
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\dialog.h ===
/******************************Module*Header*******************************\
* Module Name: dialog.h
*
* Externals from dialog.c
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __dialog_h__
#define __dialog_h__

#include "dlgs.h"
#include "sscommon.h"

#ifdef __cplusplus
extern "C" {
#endif

extern float fTesselFact;
extern ULONG ulJointType;
extern ULONG ulSurfStyle;
extern ULONG ulTexQuality;
extern TEXFILE gTexFile[];
extern int gnTextures;

extern BOOL  bFlexMode;
extern BOOL  bMultiPipes;

extern void getIniSettings(void);


// surface styles
enum {
    SURFSTYLE_SOLID = 0,
    SURFSTYLE_TEX,
    SURFSTYLE_WIREFRAME
};

// Resource constants

#define IDS_SAVERNAME           1002
#define IDS_JOINTTYPE           1008
#define IDS_SURFSTYLE           1009
#define IDS_TEXQUAL             1010

#define IDS_FLEX                1020
#define IDS_MULTIPIPES          1021

//mf: should get rid of OFFSET...
#define IDS_TEXTURE_COUNT       1029
#define IDS_TEXTURE0            1030
#define IDS_TEXTURE1            1031
#define IDS_TEXTURE2            1032
#define IDS_TEXTURE3            1033
#define IDS_TEXTURE4            1034
#define IDS_TEXTURE5            1035
#define IDS_TEXTURE6            1036
#define IDS_TEXTURE7            1037
#define IDS_TEXOFFSET0          1050
#define IDS_TEXOFFSET1          1051
#define IDS_TEXOFFSET2          1052
#define IDS_TEXOFFSET3          1053
#define IDS_TEXOFFSET4          1054
#define IDS_TEXOFFSET5          1055
#define IDS_TEXOFFSET6          1056
#define IDS_TEXOFFSET7          1057

#define IDS_JOINT_ELBOW         1100
#define IDS_JOINT_BALL          1101
#define IDS_JOINT_MIXED         1102
#define IDS_JOINT_CYCLE         1103

#define DLG_SETUP_TESSEL        2001
#define DLG_SETUP_TEXTURE       2002
#define IDC_STATIC_TESS         2003
#define IDC_STATIC_TESS_MIN     2004
#define IDC_STATIC_TESS_MAX     2005
#define IDC_STATIC_TESS_GRP     2006
#define IDC_STATIC_TEXQUAL_GRP  2007

#define IDC_RADIO_SINGLE_PIPE       3000
#define IDC_RADIO_MULTIPLE_PIPES    3001

#define IDC_RADIO_NORMAL        3100
#define IDC_RADIO_FLEX          3101

#define IDC_STATIC_JOINTTYPE       2106

#define DLG_COMBO_JOINTTYPE     2200

enum {
    JOINT_ELBOW=0,
    JOINT_BALL,
    JOINT_MIXED,
    JOINT_CYCLE,
    NUM_JOINTTYPES
};

// In order for the IDC_TO_SURFSTYLE conversion macro to work, the radio buttons
// for surface styles must be kept contiguous.

#define IDC_RADIO_SOLID         2111
#define IDC_RADIO_TEX           2112
#define IDC_RADIO_WIREFRAME     2113
#define IDC_TO_SURFSTYLE(n)          ( (n) - IDC_RADIO_SOLID )


// In order for the IDC_TO_TEXQUAL conversion macro to work, the radio buttons
// for texture quality must be kept contiguous.

#define IDC_RADIO_TEXQUAL_DEFAULT   2121
#define IDC_RADIO_TEXQUAL_HIGH  2122
#define IDC_TO_TEXQUAL(n)       ( (n) - IDC_RADIO_TEXQUAL_DEFAULT )

#define TEXQUAL_DEFAULT         0
#define TEXQUAL_HIGH            1


// texture resources
#define IDB_DEFTEX              99
#define IDB_DEFTEX2            100 

// multi texture dialog

#ifdef __cplusplus
}
#endif

#endif // __dialog_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\eval.cxx ===
/******************************Module*Header*******************************\
* Module Name: eval.cxx
*
* Evaluator stuff
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glaux.h>

#include "sscommon.h"
#include "sspipes.h"
#include "eval.h"

//#define EVAL_DBG 1

typedef enum {
    X_PLANE = 0,
    Y_PLANE,
    Z_PLANE
};

#define EVAL_VSIZE 3  // vertex size in floats

#define TMAJOR_ORDER 2
#define TMINOR_ORDER 2

#define VDIM 3
#define TDIM 2

//forwards
#if EVAL_DBG
static void DrawPoints( int num, POINT3D *pts );
#endif
static void RotatePointSet( POINT3D *inPts, int numPts, float angle, int dir, 
                      float radius, POINT3D *outPts );
static void ExtrudePointSetDir( POINT3D *inPts, int numPts, float *acPts, 
                      int dir, POINT3D *outPts );


/**************************************************************************\
* EVAL
*
* Evaluator constructor
* 
\**************************************************************************/

EVAL::EVAL( BOOL bTex )
{
    bTexture = bTex; 

    // Allocate points buffer

//mf: might want to use less than max in some cases
    int size = MAX_USECTIONS * MAX_UORDER * MAX_VORDER * sizeof(POINT3D);
    pts = (POINT3D *) LocalAlloc( LMEM_FIXED, size );
    SS_ASSERT( pts != NULL, "EVAL constructor\n" );
    
    // Alloc texture points buffer

    if( bTexture ) {
        size = MAX_USECTIONS * TEX_ORDER * TEX_ORDER * sizeof(TEX_POINT2D);
        texPts = (TEX_POINT2D *) LocalAlloc( LMEM_FIXED, size );
        SS_ASSERT( texPts != NULL, "EVAL constructor\n" );
    }
    
    ResetEvaluator( bTexture );
}

/**************************************************************************\
* ~EVAL
*
* Evaluator destructor
*
* Frees up memory
*
\**************************************************************************/

EVAL::~EVAL( )
{
    LocalFree( pts );
    if( bTexture )
        LocalFree( texPts );
}

/**************************************************************************\
* Reset
*
* Reset evaluator to generate 3d vertices and vertex normals
*
\**************************************************************************/

void
ResetEvaluator( BOOL bTexture )
{
    if( bTexture ) {
        glEnable( GL_MAP2_TEXTURE_COORD_2 );
    }
    glEnable( GL_MAP2_VERTEX_3 );
    glEnable( GL_AUTO_NORMAL );
    glFrontFace( GL_CW ); // cuz
//mf: !!! if mixing Normal and Flex, have to watch out for this, cuz normal
// needs CCW
}

/**************************************************************************\
* SetTextureControlPoints
*
* Set texture control point net
*
* This sets up 'numSections' sets of texture coordinate control points, based
* on starting and ending s and t values.
*
* s coords run along pipe direction, t coords run around circumference
*
* History
*  July 17, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
EVAL::SetTextureControlPoints( float s_start, float s_end, 
                              float t_start, float t_end )
{
    int i;
    TEX_POINT2D *ptexPts = texPts;
    GLfloat t_delta = (t_end - t_start) / numSections;
    GLfloat t = t_start;

    // calc ctrl pts for each quadrant
    for( i = 0; i < numSections; i++, ptexPts += (TDIM*TDIM) ) {
        // s, t coords
        ptexPts[0].t = ptexPts[2].t = t;
        t += t_delta;
        ptexPts[1].t = ptexPts[3].t = t;
        ptexPts[0].s = ptexPts[1].s = s_start;
        ptexPts[2].s = ptexPts[3].s = s_end;
    } 
}

/**************************************************************************\
* SetVertexCtrlPtsXCTranslate
*
* Builds 3D control eval control net from 2 xcObjs displaced along the
* z-axis by 'length'.
* 
* First xc used to generate points in z=0 plane.
* Second xc generates points in z=length plane.
* ! Replicates the last point around each u.
*
*  July 27, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
EVAL::SetVertexCtrlPtsXCTranslate( POINT3D *pts, float length, 
                             XC *xcStart, XC *xcEnd )
{
    int i;
    POINT2D *ptsStart, *ptsEnd;
    POINT3D *pts1, *pts2;
    int     numPts = xcStart->numPts;

    numPts++;  // due to last point replication

    ptsStart = xcStart->pts;
    ptsEnd   = xcEnd->pts;
    pts1     = pts;
    pts2     = pts + numPts;

    for( i = 0; i < (numPts-1); i++, pts1++, pts2++ ) {
        // copy over x,y from each xc
        *( (POINT2D *) pts1) = *ptsStart++;
        *( (POINT2D *) pts2) = *ptsEnd++;
        // set z for each
        pts1->z = 0.0f;
        pts2->z = length;
    }

    // Replicate last point in each u-band
    *pts1 = *pts;
    *pts2 = *(pts + numPts);
}

/**************************************************************************\
* ProcessXCPrimLinear
*
* Processes a prim according to evaluator data
*
* - Only valid for colinear xc's (along z)
* - XC's may be identical (extrusion).  If not identical, may have
*   discontinuities at each end.
* - Converts 2D XC pts to 3D pts
*
*  July 27, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
EVAL::ProcessXCPrimLinear( XC *xcStart, XC *xcEnd, float length )
{
    if( length <= 0.0f )
        // nuttin' to do
        return;

    // Build a vertex control net from 2 xcObj's a distance 'length' apart
    // this will displace the end xcObj a distance 'length' down the z-axis
    SetVertexCtrlPtsXCTranslate( pts, length, xcStart, xcEnd );

    Evaluate( );
}

/**************************************************************************\
* ProcessXCPrimBendSimple
*
* Processes a prim by bending along dir from xcCur
*
* - dir is relative from xc in x-y plane
* - adds C2 continuity at ends
*
*  July 27, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
EVAL::ProcessXCPrimBendSimple( XC *xcCur, int dir, float radius )
{
    POINT3D *ptsSrc, *ptsDst;
    static float acPts[MAX_XC_PTS+1];
    int ptSetStride = xcCur->numPts + 1; // pt stride for output pts buffer

    // We will be creating 4 cross-sectional control point sets here.

    // Convert 2D pts in xcCur to 3D pts at z=0 for 1st point set
    xcCur->ConvertPtsZ( pts, 0.0f );

    // Calc 4th point set by rotating 1st set as per dir
    ptsDst = pts + 3*ptSetStride;
    RotatePointSet( pts, ptSetStride, 90.0f, dir, radius, ptsDst );

    // angles != 90, hard, cuz not easy to extrude 3rd set from 4th

    // Next, have to figure out ac values.  Need to extend each xc's points
    // into bend to generate ac net.  For circular bend (and later for general
    // case elliptical bend), need to know ac distance from xc for each point.
    // This is based on the point's turn radius - a function of its distance
    // from the 'hinge' of the turn.

    // Can take advantage of symmetry here.  Figure for one xc, good for 2nd.
    // This assumes 90 deg turn.  (also,last point replicated)
    xcCur->CalcArcACValues90( dir, radius, acPts );
    
    // 2) extrude each point's ac from xcCur (extrusion in +z)
    // apply values to 1st to get 2nd
    // MINUS_Z, cuz subtracts *back* from dir
    ExtrudePointSetDir( pts, ptSetStride, acPts, MINUS_Z, 
                                                    pts + ptSetStride );

    // 3) extrude each point's ac from xcEnd (extrusion in -dir)
    ptsSrc = pts + 3*ptSetStride;
    ptsDst = pts + 2*ptSetStride;
    ExtrudePointSetDir( ptsSrc, ptSetStride, acPts, dir, ptsDst );

    Evaluate();
}

/**************************************************************************\
* eval_ProcessXCPrimSingularity
*
* Processes a prim by joining singularity to an xc
*
* - Used for closing or opening the pipe
* - If bOpening is true, starts with singularity, otherwise ends with one
* - the xc side is always in z=0 plane
* - singularity side is radius on either side of xc
* - adds C2 continuity at ends (perpendicular to +z at singularity end)
*
*  July 29, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
EVAL::ProcessXCPrimSingularity( XC *xcCur, float length, BOOL bOpening )
{
    POINT3D *ptsSing, *ptsXC;
    static float acPts[MAX_XC_PTS+1];
    float zSing; // z-value at singularity
    int ptSetStride = xcCur->numPts + 1; // pt stride for output pts buffer
    int i;
    XC xcSing(xcCur);

    // create singularity xc - which is an extremely scaled-down version
    //  of xcCur (this prevents any end-artifacts, unless of course we were
    //  to zoom it ultra-large).

    xcSing.Scale( .0005f );

    // We will be creating 4 cross-sectional control point sets here.
    // mf: 4 is like hard coded; what about for different xc component levels ?

    if( bOpening ) {
        ptsSing = pts;
        ptsXC = pts + 3*ptSetStride;
    } else {
        ptsSing = pts + 3*ptSetStride;
        ptsXC = pts;
    }

    // Convert 2D pts in xcCur to 3D pts at 'xc' point set
    xcCur->ConvertPtsZ( ptsXC, 0.0f );

    // Set z-value for singularity point set
    zSing = bOpening ? -length : length;
    xcSing.ConvertPtsZ( ptsSing, zSing );

    // The arc control for each point is based on a radius value that is
    //  each xc point's distance from the xc center
    xcCur->CalcArcACValuesByDistance( acPts );

    // Calculate point set near xc
    if( bOpening )
        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, PLUS_Z, 
                                                    ptsXC - ptSetStride );
    else
        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, MINUS_Z, 
                                                    ptsXC + ptSetStride );

    // Point set near singularity is harder, as the points must generate
    // a curve between the singularity and each xc point
    // No, easier, just scale each point by universal arc controller !
    POINT3D *ptsDst = pts;
    ptsDst = bOpening ? ptsSing + ptSetStride : ptsSing - ptSetStride;
    for( i = 0; i < ptSetStride; i ++, ptsDst++ ) {
        ptsDst->x = EVAL_CIRC_ARC_CONTROL * ptsXC[i].x;
        ptsDst->y = EVAL_CIRC_ARC_CONTROL * ptsXC[i].y;
        ptsDst->z = zSing;
    }

    Evaluate();
}

/**************************************************************************\
* Evaluate
*
* Evaluates the EVAL object
*
* - There may be 1 or more lengthwise sections around an xc
* - u is minor, v major
* - u,t run around circumference, v,s lengthwise
* - Texture maps are 2x2 for each section
* - ! uDiv is per section !
*
* History
*  July 21, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
EVAL::Evaluate( )
{
    int i;
    POINT3D *ppts = pts; 
    TEX_POINT2D *ptexPts = texPts;
    // total # pts in cross-section:
    int xcPointCount = (uOrder-1)*numSections + 1;

    for( i = 0; i < numSections; i ++, 
                                       ppts += (uOrder-1),
                                       ptexPts += (TEX_ORDER*TEX_ORDER) ) {

        // map texture coords

        if( bTexture ) {
            glMap2f(GL_MAP2_TEXTURE_COORD_2, 
                    0.0f, 1.0f, TDIM, TEX_ORDER, 
                    0.0f, 1.0f, TEX_ORDER*TDIM, TEX_ORDER, 
                    (GLfloat *) ptexPts );
        }

        // map vertices

        glMap2f(GL_MAP2_VERTEX_3, 
               0.0f, 1.0f, VDIM, uOrder, 
               0.0f, 1.0f, xcPointCount*VDIM, vOrder,
               (GLfloat *) ppts );

        // evaluate

        glMapGrid2f(uDiv, 0.0f, 1.0f, vDiv, 0.0f, 1.0f);
        glEvalMesh2( GL_FILL, 0, uDiv, 0, vDiv);
    }
}

#if EVAL_DBG
/**************************************************************************\
* DrawPoints
*
* draw control points
*
\**************************************************************************/
static 
void DrawPoints( int num, POINT3D *pts )
{
    GLint i;

    // draw green pts for now
    glColor3f(0.0f, 1.0f, 0.0f);
    glPointSize(2);

    glBegin(GL_POINTS);
        for (i = 0; i < num; i++, pts++) {
            glVertex3fv( (GLfloat *) pts );
        }
    glEnd();
}
#endif

/**************************************************************************\
* ExtrudePointSetDir
*
* Extrude a point set back from the current direction
*
* Generates C2 continuity at the supplied point set xc, by generating another
* point set back of the first, using supplied subtraction values.
*
*  July 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

static void
ExtrudePointSetDir( POINT3D *inPts, int numPts, float *acPts, int dir, 
                    POINT3D *outPts )
{
    int i;
    float sign;
    int offset;

    switch( dir ) {
        case PLUS_X:
            offset = 0;
            sign = -1.0f;
            break;
        case MINUS_X:
            offset = 0;
            sign =  1.0f;
            break;
        case PLUS_Y:
            offset = 1;
            sign = -1.0f;
            break;
        case MINUS_Y:
            offset = 1;
            sign =  1.0f;
            break;
        case PLUS_Z:
            offset = 2;
            sign = -1.0f;
            break;
        case MINUS_Z:
            offset = 2;
            sign =  1.0f;
            break;
    }

    for( i = 0; i < numPts; i++, inPts++, outPts++, acPts++ ) {
        *outPts = *inPts;
        ((float *)outPts)[offset] = ((float *)inPts)[offset] + (sign * (*acPts));
    }
}

/**************************************************************************\
* RotatePointSet
*
* Rotate point set by angle, according to dir and radius
*
* - Put points in supplied outPts buffer
*
*  July 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

static void 
RotatePointSet( POINT3D *inPts, int numPts, float angle, int dir, 
                      float radius, POINT3D *outPts )
{
    MATRIX matrix1, matrix2, matrix3;
    int i;
    POINT3D rot = {0.0f};
    POINT3D anchor = {0.0f};

    /* dir      rot
       +x       90 y
       -x       -90 y
       +y       -90 x
       -y       90 x
    */

    // convert angle to radians
    //mf: as noted in objects.c, we have to take negative angle to make
    // it work in familiar 'CCW rotation is positive' mode.  The ss_* rotate
    // routines must work in the 'CW is +'ve' mode, as axis pointing at you.
    angle = SS_DEG_TO_RAD(-angle);

    // set axis rotation and anchor point

    switch( dir ) {
        case PLUS_X:
            rot.y = angle;
            anchor.x = radius;
            break;
        case MINUS_X:
            rot.y = -angle;
            anchor.x = -radius;
            break;
        case PLUS_Y:
            rot.x = -angle;
            anchor.y = radius;
            break;
        case MINUS_Y:
            rot.x = angle;
            anchor.y = -radius;
            break;
    }

    // translate anchor point to origin
    ss_matrixIdent( &matrix1 );
    ss_matrixTranslate( &matrix1, -anchor.x, -anchor.y, -anchor.z );

    // rotate 
    ss_matrixIdent( &matrix2 );
    ss_matrixRotate( &matrix2, (double) rot.x, rot.y, rot.z );

    // concat these 2
    ss_matrixMult( &matrix3, &matrix2, &matrix1 );

    // translate back
    ss_matrixIdent( &matrix2 );
    ss_matrixTranslate( &matrix2,  anchor.x,  anchor.y,  anchor.z );

    // concat these 2
    ss_matrixMult( &matrix1, &matrix2, &matrix3 );

    for( i = 0; i < numPts; i ++, outPts++, inPts++ ) {
        ss_xformPoint( outPts, inPts, &matrix1 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\maze\ssmaze.c ===
#include "pch.c"
#pragma hdrstop
#include "maze_std.h"

#define VIEW_ANG 90

float maze_height;
double view_rot;
int maze_walls_list;

extern TEX_ENV gTexEnv[];

typedef struct _FxRay2
{
    FxPt2 p;
    FxVec2 d;
} FxRay2;

BYTE maze_desc[MAZE_ARRAY][MAZE_ARRAY];

Cell maze_cells[MAZE_GRID][MAZE_GRID];
#define CellAt(x, y) (&maze_cells[y][x])

typedef struct _Wall
{
    FxPt2 f, t;
    int col;
    TEX_ENV *pTexEnv;  // points to texture environment
} Wall;
    
FxPt2 fmaze_pts[N_MAZE_PTS];
Wall maze[N_MAZE_WALLS];
int nwalls;

typedef struct _WallHit
{
    Cell *cell;
    int cx, cy;
    WallFlags flag;
} WallHit;

void AddObject(Object *obj, Cell *cell)
{
    obj->next = cell->contents;
    cell->contents = obj;
    obj->cell = cell;
}

void PlaceObject(Object *obj, FxValue x, FxValue y)
{
    Cell *cell;
    int cx, cy;

    cx = MfxToCell(x);
    cy = MfxToCell(y);
    cell = CellAt(cx, cy);
    
    obj->p.x = x;
    obj->p.y = y;

    AddObject(obj, cell);
}

void RemoveObject(Object *obj)
{
    Object *o, *op;
        
    if (obj->cell != NULL)
    {
        op = NULL;
        for (o = obj->cell->contents; o != obj; o = o->next)
        {
            op = o;
        }

        if (op == NULL)
        {
            obj->cell->contents = obj->next;
        }
        else
        {
            op->next = obj->next;
        }

        obj->cell = NULL;
    }
}

void MoveObject(Object *obj, FxValue x, FxValue y)
{
    int cx, cy;
    Cell *cell;
    
    obj->p.x = x;
    obj->p.y = y;
    
    cx = MfxToCell(x);
    cy = MfxToCell(y);
    cell = CellAt(cx, cy);
    
    if (cell == obj->cell)
    {
        return;
    }
    
    RemoveObject(obj);
    AddObject(obj, cell);
}

Object start_obj, end_obj;

BOOL InitMaze(IntPt2 *start_cell, MazeGoal *goals, int *ngoals)
{
    int i, j, n;
    FxPt2 p;

    if (!GenerateMaze(MAZE_GRID, MAZE_GRID, &maze_desc[0][0]))
    {
        return FALSE;
    }
    
    p.y = FxVal(0);
    n = 0;
    for (i = 0; i < MAZE_ARRAY; i++)
    {
        p.x = FxVal(0);
        for (j = 0; j < MAZE_ARRAY; j++)
        {
            fmaze_pts[n].x = p.x;
            fmaze_pts[n++].y = p.y;
            p.x += FMAZE_CELL_SIZE;
        }
        p.y += FMAZE_CELL_SIZE;
    }

    nwalls = 0;
    for (i = 0; i < MAZE_ARRAY; i++)
    {
        for (j = 0; j < MAZE_ARRAY; j++)
        {
            if (i < MAZE_ARRAY-1 && j < MAZE_ARRAY-1)
            {
                maze_cells[i][j].can_see = 0;
                maze_cells[i][j].contents = NULL;
                memset(maze_cells[i][j].walls, 0, 4*sizeof(Wall *));
            }
                
            if (maze_desc[i][j] & MAZE_WALL_HORZ)
            {
                if (j == MAZE_ARRAY-1)
                {
                    printf("MAZE_WALL_HORZ at right edge\n");
                    return FALSE;
                }
                
                maze[nwalls].f = fmaze_pts[i*MAZE_ARRAY+j];
                maze[nwalls].t = fmaze_pts[i*MAZE_ARRAY+j+1];
                maze[nwalls].col = (i+j+1) & 1;
                maze[nwalls].pTexEnv = &gTexEnv[TEX_WALL];
                
                if (i > 0)
                {
                    maze_cells[i-1][j].can_see |= MAZE_WALL_DOWN;
                    maze_cells[i-1][j].walls[WIDX_DOWN] = &maze[nwalls];
                }
                if (i < MAZE_ARRAY-1)
                {
                    maze_cells[i][j].can_see |= MAZE_WALL_UP;
                    maze_cells[i][j].walls[WIDX_UP] = &maze[nwalls];
                }
                
                nwalls++;
            }
            
            if (maze_desc[i][j] & MAZE_WALL_VERT)
            {
                if (i == MAZE_ARRAY-1)
                {
                    printf("MAZE_WALL_VERT at bottom edge\n");
                    return FALSE;
                }

                maze[nwalls].f = fmaze_pts[i*MAZE_ARRAY+j];
                maze[nwalls].t = fmaze_pts[(i+1)*MAZE_ARRAY+j];
                maze[nwalls].col = (i+j) & 1;
                maze[nwalls].pTexEnv = &gTexEnv[TEX_WALL];
            
                if (j > 0)
                {
                    maze_cells[i][j-1].can_see |= MAZE_WALL_RIGHT;
                    maze_cells[i][j-1].walls[WIDX_RIGHT] = &maze[nwalls];
                }
                if (j < MAZE_ARRAY-1)
                {
                    maze_cells[i][j].can_see |= MAZE_WALL_LEFT;
                    maze_cells[i][j].walls[WIDX_LEFT] = &maze[nwalls];
                }
                
                nwalls++;
            }
        }
    }

    // Always place the start on the left and
    // the end on the right.  This guarantees that there'll be
    // some traversing of the maze for the solution
    // Since the maze generator guarantees that the entire maze is
    // fully connected, the solution can always be found
    
    start_cell->x = 0;
    start_cell->y = rand() % MAZE_GRID;

    *ngoals = 1;
    goals[0].clx = MAZE_GRID-1;
    goals[0].cly = rand() % MAZE_GRID;
    
    start_obj.w = FMAZE_CELL_SIZE/6;
    start_obj.h = FxFltVal(.166);
    start_obj.z = FxFltVal(.5);
    start_obj.col = 12;
    start_obj.draw_style = DRAW_POLYGON;
    start_obj.pTexEnv = &gTexEnv[ TEX_START ];
    start_obj.ang = FaDeg(0);
    PlaceObject(&start_obj,
                CellToMfx(start_cell->x)+FMAZE_CELL_SIZE/2,
                CellToMfx(start_cell->y)+FMAZE_CELL_SIZE/2);
    
    end_obj.w = FMAZE_CELL_SIZE/6;
    end_obj.h = FxFltVal(.166);
    end_obj.z = FxFltVal(.5);
    end_obj.col = 10;
    end_obj.draw_style = DRAW_POLYGON;
    end_obj.pTexEnv = &gTexEnv[ TEX_END ];
    end_obj.ang = FaDeg(0);
    PlaceObject(&end_obj,
                CellToMfx(goals[0].clx)+FMAZE_CELL_SIZE/2,
                CellToMfx(goals[0].cly)+FMAZE_CELL_SIZE/2);

    // Reset some of the walls' textures to the OpenGL cover
    // for some variety
    i = (rand() % 5)+1;
    while (i-- > 0)
    {
        j = rand() % nwalls;
        maze[j].pTexEnv = &gTexEnv[TEX_COVER];
    }

#if 0
    // Make some of the walls partially covered
    n = (rand() % 50)+1;
    while (n-- > 0)
    {
        Wall *wall;
        int dir;

        // The wall picked cannot be an edge wall because that
        // would allow walking out of the maze
        i = ((rand() >> 8) % (MAZE_GRID-2))+1;
        j = ((rand() >> 8) % (MAZE_GRID-2))+1;
        dir = (rand() >> 13) % 4;
        wall = maze_cells[i][j].walls[dir];
        if (wall != NULL)
        {
            wall->pTexEnv = &gTexEnv[TEX_END];
            maze_cells[i][j].can_see |= (MAZE_WALL_LEFT_PARTIAL << dir);
            switch(dir)
            {
            case WIDX_LEFT:
                if (j > 0)
                {
                    maze_cells[i][j-1].can_see |= MAZE_WALL_RIGHT_PARTIAL;
                }
                break;
            case WIDX_RIGHT:
                if (j < MAZE_GRID-1)
                {
                    maze_cells[i][j+1].can_see |= MAZE_WALL_LEFT_PARTIAL;
                }
                break;
            case WIDX_UP:
                if (i > 0)
                {
                    maze_cells[i-1][j].can_see |= MAZE_WALL_DOWN_PARTIAL;
                }
                break;
            case WIDX_DOWN:
                if (i < MAZE_GRID-1)
                {
                    maze_cells[i+1][j].can_see |= MAZE_WALL_UP_PARTIAL;
                }
                break;
            }
        }
    }
#endif
    
    return TRUE;
}

#define PO_WALL 0
#define PO_PARTIAL 1
#define PO_COUNT 2

typedef struct _PaintWall
{
    Wall *wall;
} PaintWall;

typedef struct _PaintPartial
{
    Object *obj;
} PaintPartial;

typedef struct _PaintObject
{
    int type;
    union
    {
        PaintWall wall;
        PaintPartial partial;
    } u;
    FxValue depth;
    struct _PaintObject *closer;
} PaintObject;

#define N_PAINT_OBJECTS (4*MAZE_CELLS)
PaintObject paint[N_PAINT_OBJECTS];
int npaint;

void WallCoords(int x, int y, WallFlags flag, FxPt2 *f, FxPt2 *t)
{
    t->x = f->x = CellToMfx(x);
    t->y = f->y = CellToMfx(y);
    if (flag & MAZE_WALL_LEFT)
    {
        t->y += FMAZE_CELL_SIZE;
    }
    else if (flag & MAZE_WALL_UP)
    {
        t->x += FMAZE_CELL_SIZE;
    }
    else if (flag & MAZE_WALL_RIGHT)
    {
        f->x += FMAZE_CELL_SIZE;
        t->x = f->x;
        t->y += FMAZE_CELL_SIZE;
    }
    else if (flag & MAZE_WALL_DOWN)
    {
        f->y += FMAZE_CELL_SIZE;
        t->y = f->y;
        t->x += FMAZE_CELL_SIZE;
    }
}

void AddPaintWall(Cell *cell, int widx)
{
    PaintWall *pw;
    
    if (npaint == N_PAINT_OBJECTS)
    {
        printf("Paint list full\n");
        return;
    }
    
    pw = &paint[npaint].u.wall;
    paint[npaint].type = PO_WALL;
    npaint++;

    pw->wall = cell->walls[widx];
}

void AddPaintWalls(Cell *cell, WallFlags wf)
{
    if (wf & MAZE_WALL_LEFT)
    {
        AddPaintWall(cell, WIDX_LEFT);
    }
    if (wf & MAZE_WALL_RIGHT)
    {
        AddPaintWall(cell, WIDX_RIGHT);
    }
    if (wf & MAZE_WALL_DOWN)
    {
        AddPaintWall(cell, WIDX_DOWN);
    }
    if (wf & MAZE_WALL_UP)
    {
        AddPaintWall(cell, WIDX_UP);
    }
}

void AddPaintPartial(Object *obj)
{
    PaintPartial *pp;
    
    if (npaint == N_PAINT_OBJECTS)
    {
        printf("Paint list full\n");
        return;
    }
    
    pp = &paint[npaint].u.partial;
    paint[npaint].type = PO_PARTIAL;
    npaint++;

    pp->obj = obj;
}

void AddCell(int x, int y, WallFlags wf)
{
    Cell *cell;
    Object *obj;

    wf |= MAZE_CONTENTS;
    cell = CellAt(x, y);
    if ((cell->unseen & wf) == 0)
    {
        return;
    }
    
    AddPaintWalls(cell, (WallFlags)(wf & cell->unseen));

    if (cell->unseen & MAZE_CONTENTS)
    {
        for (obj = cell->contents; obj; obj = obj->next)
        {
            AddPaintPartial(obj);
        }
    }
    
    cell->unseen &= ~wf;
}

void TraceCells(FxPt2 *ip, FxVec2 *dp, WallHit *hit)
{
    int cx, cy;
    int sgnx, sgny;
    FxVec2 dg, dst;
    FxPt2 fp, g;
    WallFlags xwf, ywf, iwf, xpf, ypf;
    FxValue sx, sy;

    cx = MfxToCell(ip->x);
    cy = MfxToCell(ip->y);

    fp = *ip;
    
#ifdef TRACEDEB
    printf("pt %ld,%ld dp %ld,%ld\n", fp.x, fp.y, dp.x, dp.y);
#endif
    
    if (dp->x < 0)
    {
        g.x = CellToMfx(cx)-FX_MIN_VALUE;
        dg.x = -FMAZE_CELL_SIZE;
        sgnx = -1;
        xwf = MAZE_WALL_LEFT;
        xpf = MAZE_WALL_LEFT_PARTIAL;
    }
    else
    {
        g.x = CellToMfx(cx+1);
        dg.x = FMAZE_CELL_SIZE;
        sgnx = 1;
        xwf = MAZE_WALL_RIGHT;
        xpf = MAZE_WALL_RIGHT_PARTIAL;
        if (dp->x == 0)
        {
            xwf |= MAZE_WALL_LEFT;
            xpf |= MAZE_WALL_LEFT_PARTIAL;
        }
    }
    if (dp->y < 0)
    {
        g.y = CellToMfx(cy)-FX_MIN_VALUE;
        dg.y = -FMAZE_CELL_SIZE;
        sgny = -1;
        ywf = MAZE_WALL_UP;
        ypf = MAZE_WALL_UP_PARTIAL;
    }
    else
    {
        g.y = CellToMfx(cy+1);
        dg.y = FMAZE_CELL_SIZE;
        sgny = 1;
        ywf = MAZE_WALL_DOWN;
        ypf = MAZE_WALL_DOWN_PARTIAL;
        if (dp->y == 0)
        {
            ywf |= MAZE_WALL_UP;
            ypf |= MAZE_WALL_UP_PARTIAL;
        }
    }

    for (;;)
    {
        AddCell(cx, cy, (WallFlags)(xwf | ywf));

        dst.x = (g.x-fp.x)*sgnx;
        dst.y = (g.y-fp.y)*sgny;
        sx = FxMul(dst.x, dp->y);
        if (sx < 0)
        {
            sx = -sx;
        }
        sy = FxMul(dst.y, dp->x);
        if (sy < 0)
        {
            sy = -sy;
        }
        
#ifdef TRACEDEB
        printf("dx %ld, sx %ld, dy %ld, sy %ld\n", dst.x, sx, dst.y, sy);
#endif
        
        if (sx <= sy)
        {
            if ((maze_cells[cy][cx].can_see & xwf) &&
                (maze_cells[cy][cx].can_see & xpf) == 0)
            {
                iwf = xwf;
                break;
            }
            
            fp.x = g.x;
            fp.y += FxDiv(sx, dp->x)*sgnx*sgny;
            if (fp.y == g.y)
            {
                if ((maze_cells[cy][cx].can_see & ywf) &&
                    (maze_cells[cy][cx].can_see & ypf) == 0)
                {
                    iwf = ywf;
                    break;
                }
                cy += sgny;
                g.y += dg.y;
            }
            cx += sgnx;
            g.x += dg.x;
        }
        else
        {
            if ((maze_cells[cy][cx].can_see & ywf) &&
                (maze_cells[cy][cx].can_see & ypf) == 0)
            {
                iwf = ywf;
                break;
            }

            fp.y = g.y;
            fp.x += FxDiv(sy, dp->y)*sgnx*sgny;
            if (fp.x == g.x)
            {
                if ((maze_cells[cy][cx].can_see & xwf) &&
                    (maze_cells[cy][cx].can_see & xpf) == 0)
                {
                    iwf = xwf;
                    break;
                }
                cx += sgnx;
                g.x += dg.x;
            }
            cy += sgny;
            g.y += dg.y;
        }
    }
    hit->cell = CellAt(cx, cy);
    hit->cx = cx;
    hit->cy = cy;
    hit->flag = iwf;
}

void TraceView(MazeView *vw)
{
    FaAngle acc;
    FxVec2 vcc;
    WallHit hit;
    int rc;

    acc = FaAdd(vw->ang, FaDeg(VIEW_ANG)/2);
    
    for (rc = 0; rc < VIEW_ANG; rc++)
    {
        vcc.x = FaCos(acc);
        vcc.y = FaSin(acc);
        
        TraceCells(&vw->pos, &vcc, &hit);

        acc = FaAdd(acc, -FaDeg(1));
    }
}

static void WallCompute(PaintObject *po, MazeView *vw,
                        FxValue cs, FxValue sn)
{
    FxPt2 mid;
    Wall *wall;
    
    wall = po->u.wall.wall;

    // Compute depth at midpoint of wall
    // Eye coordinate depth increases along the X so
    // we only need to transform it
    
    mid.x = (wall->f.x+wall->t.x)/2-vw->pos.x;
    mid.y = (wall->f.y+wall->t.y)/2-vw->pos.y;
    
    po->depth = FxMul(mid.x, cs)+FxMul(mid.y, sn);
}

static void PartialCompute(PaintObject *po, MazeView *vw,
                           FxValue cs, FxValue sn)
{
    PaintPartial *pp;
    FxPt2 c;

    pp = &po->u.partial;

    // Compute depth at center of partial
    
    c.x = pp->obj->p.x-vw->pos.x;
    c.y = pp->obj->p.y-vw->pos.y;
    
    po->depth = FxMul(c.x, cs)+FxMul(c.y, sn);
}

typedef void (*PoComputeFn)(PaintObject *po, MazeView *vw,
                            FxValue cs, FxValue sn);
static PoComputeFn PoCompute[PO_COUNT] =
{
    WallCompute,
    PartialCompute
};

static float colors[17][3] =
{
    0.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 0.5f,
    0.0f, 0.5f, 0.0f,
    0.0f, 0.5f, 0.5f,
    0.5f, 0.0f, 0.0f,
    0.5f, 0.0f, 0.5f,
    0.5f, 0.5f, 0.0f,
    0.5f, 0.5f, 0.5f,
    0.75f, 0.75f, 0.75f,
    0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 0.0f,
    1.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 0.0f,
    1.0f, 1.0f, 1.0f,
    0.75f, 0.39f, 0.0f
};

#define WALL_SET 0
#define FLOOR_SET 1
#define CEILING_SET 2

static float *smooth_sets[3][2][4] =
{
    &colors[1][0], &colors[2][0], &colors[4][0], &colors[7][0],
    &colors[2][0], &colors[1][0], &colors[7][0], &colors[4][0],
    &colors[10][0], &colors[2][0], &colors[4][0], &colors[6][0],
    &colors[10][0], &colors[2][0], &colors[4][0], &colors[6][0],
    &colors[9][0], &colors[1][0], &colors[2][0], &colors[3][0],
    &colors[9][0], &colors[1][0], &colors[2][0], &colors[3][0]
};

static float *flat_sets[3][2][4] =
{
    &colors[8][0], &colors[8][0], &colors[8][0], &colors[8][0],
    &colors[15][0], &colors[15][0], &colors[15][0], &colors[15][0],
    &colors[2][0], &colors[2][0], &colors[2][0], &colors[2][0],
    &colors[2][0], &colors[2][0], &colors[2][0], &colors[2][0],
    &colors[9][0], &colors[9][0], &colors[9][0], &colors[9][0],
    &colors[9][0], &colors[9][0], &colors[9][0], &colors[9][0]
};

void SetAlphaCol(GLfloat *fv3)
{
    if (maze_options.all_alpha)
    {
        GLfloat fv4[4];

        fv4[0] = fv3[0];
        fv4[1] = fv3[1];
        fv4[2] = fv3[2];
        fv4[3] = 0.5f;
        glColor4fv(fv4);
    }
    else
    {
        glColor3fv(fv3);
    }
}

static void WallDraw(PaintObject *po, MazeView *vw)
{
    Wall *wall;
    float fx, fy, tx, ty, cx, cy, nx, ny;
    float **col_set;
    int reps;
    int rept;
    GLenum old_env;

    wall = po->u.wall.wall;
    reps = wall->pTexEnv->texRep.x;
    rept = wall->pTexEnv->texRep.y;
    
    fx = (float)FxFlt(wall->f.x);
    fy = (float)FxFlt(wall->f.y);
    tx = (float)FxFlt(wall->t.x);
    ty = (float)FxFlt(wall->t.y);
    nx = -(ty-fy);
    ny = (tx-fx);
    cx = (float)FxFlt(vw->pos.x);
    cy = (float)FxFlt(vw->pos.y);

    col_set = &flat_sets[WALL_SET][wall->col][0];
    switch(maze_options.render[WALLS])
    {
    case RENDER_NONE:
        return;
    case RENDER_SMOOTH:
        col_set = &smooth_sets[WALL_SET][wall->col][0];
        break;
    case RENDER_FLAT:
    case RENDER_TEXTURED:
        break;
    }

    // Compute dot product with wall normal to determine
    // wall direction.  We need to know the wall direction
    // in order to ensure that the wall texture faces the
    // correct direction
    UseTextureEnv(wall->pTexEnv);

    if (wall->pTexEnv->bTransp)
    {
        if (!maze_options.all_alpha)
        {
            glGetTexEnviv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &old_env);
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, gTexEnvMode);
            glEnable(GL_BLEND);
        }
    }

    glBegin(GL_POLYGON);
    if ((fx-cx)*nx+(fy-cy)*ny > 0)
    {
        glTexCoord2d(0, 0);
        SetAlphaCol(col_set[0]);
        glVertex3f(fx, fy, 0.0f);
        glTexCoord2d(reps, 0);
        SetAlphaCol(col_set[1]);
        glVertex3f(tx, ty, 0.0f);
        glTexCoord2d(reps, rept);
        SetAlphaCol(col_set[2]);
        glVertex3f(tx, ty, maze_height);
        glTexCoord2d(0, rept);
        SetAlphaCol(col_set[3]);
        glVertex3f(fx, fy, maze_height);
    }
    else
    {
        glTexCoord2d(reps, 0);
        SetAlphaCol(col_set[0]);
        glVertex3f(fx, fy, 0.0f);
        glTexCoord2d(0, 0);
        SetAlphaCol(col_set[1]);
        glVertex3f(tx, ty, 0.0f);
        glTexCoord2d(0, rept);
        SetAlphaCol(col_set[2]);
        glVertex3f(tx, ty, maze_height);
        glTexCoord2d(reps, rept);
        SetAlphaCol(col_set[3]);
        glVertex3f(fx, fy, maze_height);
    }
    glEnd();

    if (wall->pTexEnv->bTransp)
    {
        if (!maze_options.all_alpha)
        {
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, old_env);
            glDisable(GL_BLEND);
        }
    }
}

void (APIENTRY *convex_solids[SPECIAL_ARG_COUNT])(GLdouble radius) =
{
    auxSolidIcosahedron,
    auxSolidOctahedron,
    auxSolidDodecahedron,
    auxSolidTetrahedron
};

static void PartialDraw(PaintObject *po, MazeView *vw)
{
    PaintPartial *pp;
    float w, h, cx, cy, cz, vx, vy, fx, fy, fz, tx, ty, tz;
    float cs, sn;
    GLenum old_env;

    pp = &po->u.partial;
    
    w = (float)FxFlt(pp->obj->w);
    h = (float)FxFlt(pp->obj->h);

    // Partials are billboarded so we want it to always be
    // perpendicular to the view direction

    cs = (float)FxFlt(FaCos(vw->ang));
    sn = (float)FxFlt(FaSin(vw->ang));
    vx = -sn*w;
    vy = cs*w;
    
    cx = (float)FxFlt(pp->obj->p.x);
    cy = (float)FxFlt(pp->obj->p.y);
    cz = (float)FxFlt(pp->obj->z);

    fx = cx-vx;
    fy = cy-vy;
    fz = (cz-h)*maze_height;
    tx = cx+vx;
    ty = cy+vy;
    tz = (cz+h)*maze_height;

    if (maze_options.render[WALLS] == RENDER_TEXTURED)
    {
        glDisable(GL_TEXTURE_2D);
    }

    switch(pp->obj->draw_style)
    {
    case DRAW_POLYGON:
        glEnable(GL_TEXTURE_2D);
        if (!maze_options.all_alpha)
        {
            glGetTexEnviv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &old_env);
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, gTexEnvMode);
            glEnable(GL_BLEND);
        }
        UseTextureEnv( pp->obj->pTexEnv );
        SetAlphaCol(colors[15]);
        glBegin(GL_POLYGON);
        glNormal3f(cs, sn, 0.0f);
        glTexCoord2f(1.0f, 0.0f);
        glVertex3f(fx, fy, fz);
        glTexCoord2f(0.0f, 0.0f);
        glVertex3f(tx, ty, fz);
        glTexCoord2f(0.0f, 1.0f);
        glVertex3f(tx, ty, tz);
        glTexCoord2f(1.0f, 1.0f);
        glVertex3f(fx, fy, tz);
        glEnd();
        glDisable(GL_TEXTURE_2D);
        if (!maze_options.all_alpha)
        {
            glDisable(GL_BLEND);
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, old_env);
        }
        break;

    case DRAW_SPECIAL:
        SetAlphaCol(colors[pp->obj->col]);
    
        glEnable(GL_AUTO_NORMAL);
        glEnable(GL_NORMALIZE);
        glEnable(GL_LIGHTING);
        glEnable(GL_CULL_FACE);
        glEnable(GL_DITHER);
        glPushMatrix();
        
        glTranslated(cx, cy, cz*maze_height);
        glScaled(1.0, 1.0, maze_height);
        glRotated(FaFltDegVal(pp->obj->ang), 0, 0, 1);
        glRotated(pp->obj->user3, 0, 1, 0);
        // Must use convex objects since depth testing can be off
        convex_solids[pp->obj->draw_arg](w);
        
        glPopMatrix();
        if( !maze_options.bDither )
            glDisable(GL_DITHER);
        glDisable(GL_CULL_FACE);
        glDisable(GL_LIGHTING);
        glDisable(GL_AUTO_NORMAL);
        glDisable(GL_NORMALIZE);
        break;
    }
    
    if (maze_options.render[WALLS] == RENDER_TEXTURED)
    {
        glEnable(GL_TEXTURE_2D);
    }
}

typedef void (*PoDrawFn)(PaintObject *po, MazeView *vw);
static PoDrawFn PoDraw[PO_COUNT] =
{
    WallDraw,
    PartialDraw
};


void RenderZPlane(int render, TEX_ENV *pTexEnv, int set, float zval)
{
    float **col_set;
    int reps = pTexEnv->texRep.x; 
    int rept = pTexEnv->texRep.y; 
    
    switch(render)
    {
    case RENDER_NONE:
        break;
    case RENDER_TEXTURED:
        UseTextureEnv(pTexEnv);
        glEnable(GL_TEXTURE_2D);
        // Fall through
    case RENDER_FLAT:
    case RENDER_SMOOTH:
        col_set = &flat_sets[set][0][0];
        if (render == RENDER_SMOOTH)
        {
            col_set = &smooth_sets[set][0][0];
        }
        
        glBegin(GL_POLYGON);

        // Switch texture orientation dependent on surface type
        if( set == CEILING_SET ) {
            glTexCoord2f((float)reps*MAZE_SIZE, 0.0f);
            glColor3fv(col_set[0]);
            glVertex3f(0.0f, 0.0f, zval);
            glTexCoord2f(0.0f, 0.0f);
            glColor3fv(col_set[1]);
            glVertex3f((float)MAZE_SIZE, 0.0f, zval);
            glTexCoord2f(0.0f, (float)rept*MAZE_SIZE);
            glColor3fv(col_set[2]);
            glVertex3f((float)MAZE_SIZE, (float)MAZE_SIZE, zval);
            glTexCoord2f((float)reps*MAZE_SIZE, (float)rept*MAZE_SIZE);
            glColor3fv(col_set[3]);
            glVertex3f(0.0f, (float)MAZE_SIZE, zval);
        } else {
            glTexCoord2f(0.0f, 0.0f);
            glColor3fv(col_set[0]);
            glVertex3f(0.0f, 0.0f, zval);
            glTexCoord2f((float)reps*MAZE_SIZE, 0.0f);
            glColor3fv(col_set[1]);
            glVertex3f((float)MAZE_SIZE, 0.0f, zval);
            glTexCoord2f((float)reps*MAZE_SIZE, (float)rept*MAZE_SIZE);
            glColor3fv(col_set[2]);
            glVertex3f((float)MAZE_SIZE, (float)MAZE_SIZE, zval);
            glTexCoord2f(0.0f, (float)rept*MAZE_SIZE);
            glColor3fv(col_set[3]);
            glVertex3f(0.0f, (float)MAZE_SIZE, zval);
        }

        glEnd();

        if (render == RENDER_TEXTURED)
        {
            glDisable(GL_TEXTURE_2D);
        }
        break;
    }
}

void Render(MazeView *vw)
{
    FxValue cs, sn;
    PaintObject *sorted, *so, *pso;
    PaintObject *po;
    int i;
    FxPt2 at;
    BOOL special;
    float viewHeight;

    cs = FaCos(vw->ang);
    sn = FaSin(vw->ang);
    
    at.x = vw->pos.x+cs;
    at.y = vw->pos.y+sn;
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glRotated(view_rot, 0, 0, 1);
    gluPerspective(VIEW_ANG, 1, .01, 100);
    viewHeight = 0.5f;
    gluLookAt(FxFlt(vw->pos.x), FxFlt(vw->pos.y), viewHeight,
              FxFlt(at.x), FxFlt(at.y), viewHeight,
              0, 0, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    RenderZPlane(maze_options.render[FLOOR], &gTexEnv[TEX_FLOOR], FLOOR_SET, 0.0f);
    RenderZPlane(maze_options.render[CEILING], &gTexEnv[TEX_CEILING], CEILING_SET, 1.0f);
        
    sorted = NULL;
    special = FALSE;
    for (i = 0, po = paint; i < npaint; i++, po++)
    {
        if (po->type == PO_PARTIAL &&
            po->u.partial.obj->draw_style == DRAW_SPECIAL)
        {
            special = TRUE;
        }
        
        PoCompute[po->type](po, vw, cs, sn);
        
        for (so = sorted, pso = NULL; so; pso = so, so = so->closer)
        {
            if (so->depth <= po->depth)
            {
                break;
            }
        }
        if (pso == NULL)
        {
            sorted = po;
        }
        else
        {
            pso->closer = po;
        }
        po->closer = so;
    }

#if 0
    // Unnecessary at the moment, but might be handy later
    if (special && !maze_options.depth_test)
    {
        glClear(GL_DEPTH_BUFFER_BIT);
    }
#endif
    
    if (maze_options.render[WALLS] == RENDER_TEXTURED)
    {
        glEnable(GL_TEXTURE_2D);
    }
    
    for (so = sorted; so; so = so->closer)
    {
        PoDraw[so->type](so, vw);
    }

    if (maze_options.render[WALLS] == RENDER_TEXTURED)
    {
        glDisable(GL_TEXTURE_2D);
    }
}

void InitPaint(void)
{
    int i, j;

    npaint = 0;
    for (i = 0; i < MAZE_GRID; i++)
    {
        for (j = 0; j < MAZE_GRID; j++)
        {
            maze_cells[i][j].unseen = maze_cells[i][j].can_see | MAZE_CONTENTS;
        }
    }
}

void DrawMaze(MazeView *vw)
{
    InitPaint();
    TraceView(vw);
    Render(vw);
}

void DrawMazeWalls(void)
{
    int w;
    Wall *wall;
    
    wall = maze;
    
    glColor3f(1.0f, 1.0f, 1.0f);

    glBegin(GL_LINES);
    for (w = 0; w < nwalls; w++)
    {
        glVertex2f((float)FxFltVal(wall->f.x), (float)FxFltVal(wall->f.y));
        glVertex2f((float)FxFltVal(wall->t.x), (float)FxFltVal(wall->t.y));
        wall++;
    }
    glEnd();
}

#define SQRT2_2 0.707107f

void DrawTopView(MazeView *vw)
{
    int c;
    Cell *cell;
    Object *obj;
    float vx, vy, cx, cy, width, ang;
    extern float gfAspect;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
//mf: if image being stretched, gfAspect isn't enought to make this straight -
// need to compensate by using aspect of base dimensions as well.
//mf? maybe use glScale ?
    gluOrtho2D( -MAZE_SIZE/2.0, MAZE_SIZE/2.0,
            -MAZE_SIZE/2.0/gfAspect, MAZE_SIZE/2.0/gfAspect );
    glMatrixMode(GL_MODELVIEW);

    glPushMatrix();

    ang = (float)FaFltDegVal(vw->ang)+90.0f;
    glRotatef(ang, 0.0f, 0.0f, 1.0f);
    vx = (float)FxFltVal(vw->pos.x);
    vy = (float)FxFltVal(vw->pos.y);
    glTranslatef(-vx, -vy, 0.0f);
    
#define AA_LINES 1
#ifdef AA_LINES
    // Turn on antialiased lines
    glEnable( GL_BLEND );
    glEnable( GL_LINE_SMOOTH );
    glHint( GL_LINE_SMOOTH_HINT, GL_NICEST );
#endif

    glCallList(maze_walls_list);

#ifdef AA_LINES
    glDisable( GL_BLEND );
    glDisable( GL_LINE_SMOOTH );
#endif

    // Objects aren't put in the walls display list so that they
    // can move around
    
    cell = &maze_cells[0][0];
    for (c = 0; c < MAZE_CELLS; c++)
    {
        for (obj = cell->contents; obj != NULL; obj = obj->next)
        {
            cx = (float)FxFltVal(obj->p.x);
            cy = (float)FxFltVal(obj->p.y);
            width = (float)FxFltVal(obj->w);

            glColor3fv(colors[obj->col]);

            glPushMatrix();
            glTranslatef(cx, cy, 0.0f);
            glRotated(FaFltDegVal(obj->ang), 0, 0, 1);
#if 1
            glBegin(GL_POLYGON);
            glVertex2f(width, 0.0f);
            glVertex2f(-width*SQRT2_2, width*0.5f);
            glVertex2f(-width*SQRT2_2, -width*0.5f);
            glEnd();
#else
            glRectf(-width, -width, width, width);
#endif
            glPopMatrix();
        }

        cell++;
    }
    
    glPopMatrix();
    
    // Draw self
    glColor3f(0.0f, 0.0f, 1.0f);
    width = MAZE_CELL_SIZE/4.0f;
    glBegin(GL_POLYGON);
    glVertex2f(0.0f, width);
    glVertex2f(width*0.5f, -width*SQRT2_2);
    glVertex2f(-width*0.5f, -width*SQRT2_2);
    glEnd();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\dialog.c ===
/******************************Module*Header*******************************\
* Module Name: sspipes.c
*
* Message loop and dialog box for the OpenGL-based 3D Pipes screen saver.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <scrnsave.h>
#include <GL\gl.h>
#include <math.h>
#include <memory.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys\timeb.h>
#include <time.h>
#include <commctrl.h>
#include "sscommon.h"
#include "sspipes.h"
#include "dlgs.h"
#include "dialog.h"

//#define NEW_TEXTURE 1

BOOL bFlexMode;
BOOL bMultiPipes;

// ulJointType controls the style of the elbows.

ULONG ulJointType = JOINT_ELBOW;

// ulSurfStyle determines whether the pipe surfaces are textured.

ULONG ulSurfStyle = SURFSTYLE_SOLID;

// ulTexQuality control the texture quality.

ULONG ulTexQuality = TEXQUAL_DEFAULT;

// fTesselFact controls the how finely the surface is tesselated.  It
// varies from very course (0.0) to very fine (2.0).

float fTesselFact = 1.0f;

// If ulSurfStyle indicates a textured surface, szTexPathname specifies
// the bitmap chosen as the texture.

// Texture file(s)
TEXFILE gTexFile[MAX_TEXTURES] = {0};
int gnTextures = 0;

static void updateDialogControls(HWND hDlg);

/******************************Public*Routine******************************\
* getIniSettings
*
* Get the screen saver configuration options from .INI file/registry.
*
*  Apr. 95 [marcfo]
*   - Use ss_GetDefaultBmpFile
*
\**************************************************************************/

void 
getIniSettings()
{
    TCHAR  szDefaultBitmap[MAX_PATH];
    int    tessel;
    int idsTexture;
    int idsTexOffset;
    int i;

    // Load resources

    LoadString(hMainInstance, IDS_GENNAME, szScreenSaver, 
               sizeof(szScreenSaver) / sizeof(TCHAR));

    // Load resource strings for texture processing

    ss_LoadTextureResourceStrings();

    // Get registry settings

    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        ulJointType = ss_GetRegistryInt( IDS_JOINTTYPE, JOINT_ELBOW );

        ulSurfStyle = ss_GetRegistryInt( IDS_SURFSTYLE, SURFSTYLE_SOLID );

        ulTexQuality = ss_GetRegistryInt( IDS_TEXQUAL, TEXQUAL_DEFAULT );

        tessel = ss_GetRegistryInt( IDS_TESSELATION, 0 );
        SS_CLAMP_TO_RANGE2( tessel, 0, 200 );
        fTesselFact  = (float)tessel / 100.0f;

        bFlexMode = ss_GetRegistryInt( IDS_FLEX, 0 );

        bMultiPipes = ss_GetRegistryInt( IDS_MULTIPIPES, 0 );

        // Get any textures

#ifndef NEW_TEXTURE
        // Just get one texture with old registry names
        ss_GetRegistryString( IDS_TEXTURE, 0, gTexFile[0].szPathName, MAX_PATH);
        gTexFile[0].nOffset = ss_GetRegistryInt( IDS_TEXTURE_FILE_OFFSET, 0 );
        gnTextures = 1;
#else
        gnTextures = ss_GetRegistryInt( IDS_TEXTURE_COUNT, 0 );
        SS_CLAMP_TO_RANGE2( gnTextures, 0, MAX_TEXTURES );

        idsTexture = IDS_TEXTURE0;
        idsTexOffset = IDS_TEXOFFSET0;
        for( i = 0; i < gnTextures; i++, idsTexture++, idsTexOffset++ ) {
            ss_GetRegistryString( idsTexture, 0, gTexFile[i].szPathName,
                                  MAX_PATH);
            gTexFile[i].nOffset = ss_GetRegistryInt( idsTexOffset, 0 );
        }
#endif
    }
}

/**************************************************************************\
* ConfigInit
*
\**************************************************************************/
BOOL
ss_ConfigInit( HWND hDlg )
{
    return TRUE;
}

/******************************Public*Routine******************************\
* saveIniSettings
*
* Save the screen saver configuration option to the .INI file/registry.
*
\**************************************************************************/

static void saveIniSettings(HWND hDlg)
{
    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        int idsTexture;
        int idsTexOffset;
        int i;

        ss_WriteRegistryInt( IDS_JOINTTYPE, ulJointType );
        ss_WriteRegistryInt( IDS_SURFSTYLE, ulSurfStyle );
        ss_WriteRegistryInt( IDS_TEXQUAL, ulTexQuality );
        ss_WriteRegistryInt( IDS_TESSELATION, 
                    ss_GetTrackbarPos(hDlg, DLG_SETUP_TESSEL) );
        ss_WriteRegistryInt( IDS_FLEX, bFlexMode );
        ss_WriteRegistryInt( IDS_MULTIPIPES, bMultiPipes );
#ifndef NEW_TEXTURE
        ss_WriteRegistryString( IDS_TEXTURE, gTexFile[0].szPathName );
        ss_WriteRegistryInt( IDS_TEXTURE_FILE_OFFSET, gTexFile[0].nOffset );
#else
        idsTexture = IDS_TEXTURE0;
        idsTexOffset = IDS_TEXOFFSET0;
        for( i = 0; i < gnTextures; i++, idsTexture++, idsTexOffset++ ) {
            ss_WriteRegistryString( idsTexture, gTexFile[i].szPathName );
            ss_WriteRegistryInt( idsTexOffset, gTexFile[i].nOffset );
        }
#endif
    }
}

/******************************Public*Routine******************************\
* setupDialogControls
*
* Do initial setup of dialog controls.
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
* Wrote it.
\**************************************************************************/

static void 
setupDialogControls(HWND hDlg)
{
    int pos;
    int wTmp;
    TCHAR szStr[GEN_STRING_SIZE];
    int idsJointType;

    InitCommonControls();

    pos = (int)(fTesselFact * 100.0f);
    ss_SetupTrackbar( hDlg, DLG_SETUP_TESSEL, 0, 200, 1, 10, pos );

    // setup jointType combo box
    idsJointType = IDS_JOINT_ELBOW;
    for (wTmp = 0; wTmp < NUM_JOINTTYPES; wTmp++, idsJointType++) {
        LoadString(hMainInstance, idsJointType, szStr, 
                    GEN_STRING_SIZE);
        SendDlgItemMessage(hDlg, DLG_COMBO_JOINTTYPE, CB_ADDSTRING, 0,
                           (LPARAM) szStr);
    }
    SendDlgItemMessage(hDlg, DLG_COMBO_JOINTTYPE, CB_SETCURSEL, 
                       ulJointType, 0);

    updateDialogControls( hDlg );
}

/******************************Public*Routine******************************\
* updateDialogControls
*
* Setup the dialog controls based on the current global state.
*
\**************************************************************************/

static void updateDialogControls(HWND hDlg)
{
    BOOL bTexture = (ulSurfStyle ==  SURFSTYLE_TEX);

    CheckDlgButton( hDlg, IDC_RADIO_SOLID, ulSurfStyle == SURFSTYLE_SOLID );
    CheckDlgButton( hDlg, IDC_RADIO_TEX  , bTexture );
#ifdef NEED_THESE_LATER
    CheckDlgButton( hDlg, IDC_RADIO_WIREFRAME, ulSurfStyle == SURFSTYLE_WIREFRAME   );

    CheckDlgButton( hDlg, IDC_RADIO_TEXQUAL_DEFAULT ,
                   bTexture && ulTexQuality == TEXQUAL_DEFAULT);
    CheckDlgButton( hDlg, IDC_RADIO_TEXQUAL_HIGH,
                   bTexture && ulTexQuality == TEXQUAL_HIGH);
#endif

    CheckDlgButton( hDlg, IDC_RADIO_NORMAL, !bFlexMode);
    CheckDlgButton( hDlg, IDC_RADIO_FLEX, bFlexMode);

    CheckDlgButton( hDlg, IDC_RADIO_SINGLE_PIPE, !bMultiPipes);
    CheckDlgButton( hDlg, IDC_RADIO_MULTIPLE_PIPES, bMultiPipes);

    EnableWindow( GetDlgItem(hDlg, DLG_COMBO_JOINTTYPE), !bFlexMode);
    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_JOINTTYPE), !bFlexMode);

    EnableWindow( GetDlgItem(hDlg, DLG_SETUP_TEXTURE), bTexture );
    EnableWindow( GetDlgItem(hDlg, IDC_RADIO_TEXQUAL_DEFAULT), bTexture );
    EnableWindow( GetDlgItem(hDlg, IDC_RADIO_TEXQUAL_HIGH), bTexture );
    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_TEXQUAL_GRP), bTexture );

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TESSEL), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MIN), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MAX), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_GRP), TRUE);
}

BOOL WINAPI RegisterDialogClasses(HANDLE hinst)
{
    return TRUE;
}


/******************************Public*Routine******************************\
* ScreenSaverConfigureDialog
*
* Screen saver setup dialog box procedure.
*  Apr. 95 [marcfo]
*   - Use ss_SelectTextureFile
*
\**************************************************************************/

BOOL ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                WPARAM wParam, LPARAM lParam)
{
    int wTmp;
    int optMask = 1;

    switch (message)
    {
        case WM_INITDIALOG:
            getIniSettings();
            setupDialogControls(hDlg);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_RADIO_SOLID:
                case IDC_RADIO_TEX:
                case IDC_RADIO_WIREFRAME:
                    ulSurfStyle = IDC_TO_SURFSTYLE(LOWORD(wParam));
                    break;

                case IDC_RADIO_TEXQUAL_DEFAULT:
                case IDC_RADIO_TEXQUAL_HIGH:
                    ulTexQuality = IDC_TO_TEXQUAL(LOWORD(wParam));
                    break;

                case IDC_RADIO_NORMAL:
                    bFlexMode = FALSE;
                    break;
                case IDC_RADIO_FLEX:
                    bFlexMode = TRUE;
                    break;

                case IDC_RADIO_SINGLE_PIPE:
                    bMultiPipes = FALSE;
                    break;
                case IDC_RADIO_MULTIPLE_PIPES:
                    bMultiPipes = TRUE;
                    break;

                case DLG_SETUP_TEXTURE:
                    // Run choose texture dialog
#if 1
                    ss_SelectTextureFile( hDlg, &gTexFile[0] );
#else
                    ss_SelectTextureFile( hDlg, &gTexFile[0] );
                    // NEW_TEXTURE dialog box
#endif
                    break;

                case DLG_COMBO_JOINTTYPE:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        case CBN_SELCHANGE:
                            ulJointType = 
                                (ULONG)SendDlgItemMessage(hDlg, DLG_COMBO_JOINTTYPE,
                                                          CB_GETCURSEL, 0, 0);
                            break;
                        default:
                            return FALSE;
                    }
                    break;

                case IDOK:
                    saveIniSettings(hDlg);
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    break;
            }
            updateDialogControls(hDlg);
            return TRUE;

        default:
            return 0;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\eval.h ===
#ifndef __eval_h__
#define __eval_h__

#include "sscommon.h"
#include "xc.h"

#define MAX_UORDER      5 // this is per section
#define MAX_VORDER      5
#define MAX_USECTIONS   4
#define MAX_XC_PTS      (MAX_UORDER * MAX_USECTIONS)

#define TEX_ORDER       2
#define EVAL_ARC_ORDER  4
#define EVAL_CYLINDER_ORDER 2
#define EVAL_ELBOW_ORDER    4

// # of components (eg. arcs) to form a complete cross-section
#define EVAL_XC_CIRC_SECTION_COUNT 4

#define EVAL_XC_POINT_COUNT ( (EVAL_ARC_ORDER-1)*4 + 1 )

#define EVAL_CIRC_ARC_CONTROL 0.56f // for r=1

/**************************************************************************\
*
* EVAL class
*
* - Evaluator composed of one or more sections that are evaluated
*   separately with OpenGL evaluators
*
\**************************************************************************/

class EVAL {
public:
    EVAL( BOOL bTexture );
    ~EVAL();
    int         numSections;    // number of cross-sectional sections
    int         uOrder, vOrder;
        // assumed: all sections same order - uOrder is per
        // section; sections share vertex and texture control points
    int         uDiv, vDiv;    // figured out one level up ?
    POINT3D     *pts;          // vertex control points
    // - texture always order 2 for s and t (linear mapping)
    BOOL        bTexture;
    TEX_POINT2D *texPts;       // texture control points

    void        Evaluate(); // evaluate/render the object
    void        SetVertexCtrlPtsXCTranslate( POINT3D *pts, float length, 
                                             XC *xcStart, XC *xcEnd );
    void        SetTextureControlPoints( float s_start, float s_end,
                                         float t_start, float t_end );
    void        ProcessXCPrimLinear( XC *xcStart, XC *xcEnd, float length );
    void        ProcessXCPrimBendSimple( XC *xcCur, int dir, float radius );
    void        ProcessXCPrimSingularity( XC *xcCur, float length, 
                                          BOOL bOpening );
};

extern void ResetEvaluator( BOOL bTexture );

#endif // __eval_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\fpipe.cxx ===
/******************************Module*Header*******************************\
* Module Name: fpipe.cxx
*
* Flex pipes
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

/* Notes:
    
    - All Draw routines start with current xc at the beginning, and create
      a new one at the end.  Since it is common to just have 2 xc's for
      each prim, xcCur holds the current xc, and xcEnd is available
      for the draw routine to use as the end xc.
        They also reset xcCur when done
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "fpipe.h"
#include "eval.h"

// defCylNotch shows the absolute notch for the default cylinder,
// given a direction (notch is always along +x axis)

static GLint defCylNotch[NUM_DIRS] = 
        { MINUS_Z, PLUS_Z, PLUS_X, PLUS_X, PLUS_X, MINUS_X };

static int GetRelativeDir( int lastDir, int notchVec, int newDir );

/**************************************************************************\
* FLEX_PIPE constructor
*
*
\**************************************************************************/

FLEX_PIPE::FLEX_PIPE( STATE *pState )
: PIPE( pState )
{
    float circ;

    // Create an EVAL object

    nSlices = pState->nSlices;

    // No XC's yet, they will be allocated at pipe Start()
    xcCur = xcEnd = NULL;

    // The EVAL will be used for all pEvals in the pipe, so should be
    // set to hold max. possible # of pts for the pipe.
    pEval = new EVAL( bTexture );

    // Determine pipe tesselation
    // For now, this is based on global tesselation factor

    //mf: maybe clean up this scheme a bit
    // Calculate evalDivSize, a reference value for the size of a UxV division.
    // This is used later for calculating texture coords.
    circ = CIRCUMFERENCE( pState->radius );
    evalDivSize = circ / (float) nSlices;
}

/**************************************************************************\
* ~FLEX_PIPE
*
\**************************************************************************/

FLEX_PIPE::~FLEX_PIPE( )
{
    delete pEval;

    // delete any XC's
    if( xcCur != NULL ) {
        if( xcEnd == xcCur )
            //mf: so far this can't happen...
            xcEnd = NULL; // xcCur and xcEnd can point to same xc !
        delete xcCur;
        xcCur = NULL;
    }

    if( xcEnd != NULL ) {
        delete xcEnd;
        xcEnd = NULL;
    }
}

/**************************************************************************\
* REGULAR_FLEX_PIPE constructor
*
\**************************************************************************/

REGULAR_FLEX_PIPE::REGULAR_FLEX_PIPE( STATE *state )
: FLEX_PIPE( state )
{
    static float turnFactorRange = 0.1f;
    type = TYPE_FLEX_REGULAR;

    // figure out turning factor range (0 for min bends, 1 for max bends)
#if 1
    float avgTurn = ss_fRand( 0.11f, 0.81f );
    // set min and max turn factors, and clamp to 0..1
    turnFactorMin = 
                SS_CLAMP_TO_RANGE( avgTurn - turnFactorRange, 0.0f, 1.0f );
    turnFactorMax = 
                SS_CLAMP_TO_RANGE( avgTurn + turnFactorRange, 0.0f, 1.0f );
#else
// debug: test max bend
    turnFactorMin = turnFactorMax = 1.0f;
#endif
    // choose straight weighting
    // mf:for now, same as npipe - if stays same, put in pipe
    if( ! ss_iRand( 20 ) )
        weightStraight = ss_iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT );
    else
        weightStraight = ss_iRand( 4 );
}

/**************************************************************************\
* TURNING_FLEX_PIPE constructor
*
\**************************************************************************/

TURNING_FLEX_PIPE::TURNING_FLEX_PIPE( STATE *state )
: FLEX_PIPE( state )
{
    type = TYPE_FLEX_TURNING;
}

/******************************Public*Routine******************************\
* SetTexIndex
*
* Set the texture index for this pipe, and calculate texture state dependent
* on texRep values
*
* Dec. 95 [marcfo]
*
\**************************************************************************/

void
FLEX_PIPE::SetTexParams( TEXTURE *pTex, IPOINT2D *pTexRep )
{
    if( bTexture ) {
        GLfloat t_size;
        float circ;

        t_start = (GLfloat) pTexRep->y * 1.0f;
        t_end = 0.0f;

        // calc height (t_size) of one rep of texture around circumference
        circ = CIRCUMFERENCE( radius );
        t_size = circ / pTexRep->y;

        // now calc corresponding width of the texture using its x/y ratio
        s_length = t_size / pTex->origAspectRatio;
        s_start = s_end = 0.0f;
//mf: this means we are 'standardizing' the texture size and proportions
// on pipe of radius 1.0 for entire program.  Might want to recalc this on
// a per-pipe basis ?
    }
}

/**************************************************************************\
* ChooseXCProfile
*
* Initialize extruded pipe scheme.  This uses a randomly constructed XC, but it
* remains constant throughout the pipe
*
* History
*  July 30, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
FLEX_PIPE::ChooseXCProfile()
{
    static float turnFactorRange = 0.1f;
    float avgTurn;
    float baseRadius = pState->radius;

    // initialize evaluator elements:

    pEval->numSections = EVAL_XC_CIRC_SECTION_COUNT;
    pEval->uOrder = EVAL_ARC_ORDER;
//mf: watch this - maybe should ROUND_UP uDiv
    // set uDiv per section (assumed uDiv multiple of numSections)
    pEval->uDiv = nSlices / pEval->numSections;

    // Setup XC's

    // The xc profile remains constant throughout in this case,
    // so we only need one xc.

    // Choose between elliptical or random cross-sections.  Since elliptical
    //  looks a little better, make it more likely
    if( ss_iRand(4) )  // 3/4 of the time
        xcCur = new ELLIPTICAL_XC( ss_fRand(1.2f, 2.0f) * baseRadius, 
                                           baseRadius );
    else
        xcCur = new RANDOM4ARC_XC( ss_fRand(1.5f, 2.0f) * baseRadius );
}


/**************************************************************************\
* REGULAR_FLEX_PIPE::Start
*
* Does startup of extruded-XC pipe drawing scheme 
*
\**************************************************************************/

void
REGULAR_FLEX_PIPE::Start()
{
    NODE_ARRAY *nodes = pState->nodes;
    int newDir;

    // Set start position

    if( !SetStartPos() ) {
        status = PIPE_OUT_OF_NODES;
        return;
    }

    // set material

    ChooseMaterial();

    // set XC profile

    ChooseXCProfile();

    // push matrix with zTrans and scene rotation

    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // set random lastDir
    lastDir = ss_iRand( NUM_DIRS );

    // get a new node to draw to
    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) {
        // draw like one of those tea-pouring thingies...
        status = PIPE_STUCK;
        DrawTeapot();
        glPopMatrix();
        return;
    } else
        status = PIPE_ACTIVE;

    align_plusz( newDir ); // get us pointed in right direction

    // draw start cap, which will end right at current node
    DrawCap( START_CAP );

    // set initial notch vector, which is just the default notch, since
    // we didn't have to spin the start cap around z
    notchVec = defCylNotch[newDir];

    zTrans = - pState->view.divSize;  // distance back from new node

    UpdateCurrentPosition( newDir );

    lastDir = newDir;
}

/**************************************************************************\
* TURNING_FLEX_PIPE::Start
*
* Does startup of turning extruded-XC pipe drawing scheme 
*
\**************************************************************************/

void
TURNING_FLEX_PIPE::Start( )
{
    NODE_ARRAY *nodes = pState->nodes;

    // Set start position

    if( !SetStartPos() ) {
        status = PIPE_OUT_OF_NODES;
        return;
    }

    // Set material

    ChooseMaterial();

    // Set XC profile

    ChooseXCProfile();

    // Push matrix with zTrans and scene rotation

    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // lastDir has to be set to something valid, in case we get stuck right
    // away, cuz Draw() will be called anyways on next iteration, whereupon
    // it finds out it really is stuck, AFTER calling ChooseNewTurnDirection,
    // which requires valid lastDir. (mf: fix this)
    lastDir = ss_iRand( NUM_DIRS );

    // Pick a starting direction by finding a neihgbouring empty node
    int newDir = nodes->FindClearestDirection( &curPos );
    // We don't 'choose' it, or mark it as taken, because ChooseNewDirection
    // will always check it anyways


    if( newDir == DIR_NONE ) {
        // we can't go anywhere
        // draw like one of those tea-pouring thingies...
        status = PIPE_STUCK;
        DrawTeapot();
        glPopMatrix();
        return;
    } else
        status = PIPE_ACTIVE;

    align_plusz( newDir ); // get us pointed in right direction

    // Draw start cap, which will end right at current node
    DrawCap( START_CAP );

    // Set initial notch vector, which is just the default notch, since
    // we didn't have to spin the start cap around z
    notchVec = defCylNotch[newDir];

    zTrans = 0.0f;  // right at current node

    lastDir = newDir;
}

/**************************************************************************\
* REGULAR_FLEX_PIPE::Draw
*
* Draws the pipe using a constant random xc that is extruded
*
* Minimum turn radius can vary, since xc is not symmetrical across any
* of its axes.  Therefore here we draw using a pipe/elbow sequence, so we
* know what direction we're going in before drawing the elbow.  The current
* node is the one we will draw thru next time.  Typically, the actual end
* of the pipe is way back of this node, almost at the previous node, due
* to the variable turn radius
*
* History
*  July 30, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
REGULAR_FLEX_PIPE::Draw( )
{
    float turnRadius, minTurnRadius;
    float pipeLen, maxPipeLen, minPipeLen;
    int newDir, relDir;
    float maxXCExtent;
    NODE_ARRAY *nodes = pState->nodes;
    float divSize = pState->view.divSize;

    // get new direction

    newDir = ChooseNewDirection();
    if( newDir == DIR_NONE ) {
        status = PIPE_STUCK;
        DrawCap( END_CAP );
        glPopMatrix();
        return;
    }

    // draw pipe, and if turning, joint

    if( newDir != lastDir ) { // turning! - we have to draw joint

        // get relative turn, to figure turn radius

        relDir = GetRelativeDir( lastDir, notchVec, newDir );
        minTurnRadius = xcCur->MinTurnRadius( relDir );

        // now calc maximum straight section we can draw before turning
        // zTrans is current pos'n of end of pipe, from current node ??
        // zTrans is current pos'n of end of pipe, from last node

        maxPipeLen = (-zTrans) - minTurnRadius;

        // there is also a minimum requirement for the length of the straight
        // section, cuz if we turn too soon with a large turn radius, we
        // will swing up too close to the next node, and won't be able to
        // make one or more of the 4 possible turns from that point

        maxXCExtent = xcCur->MaxExtent(); // in case need it again
        minPipeLen = maxXCExtent - (divSize + zTrans);
        if( minPipeLen < 0.0f )
            minPipeLen = 0.0f;

        // Choose length of straight section
        // (we are translating from turnFactor to 'straightFactor' here)
        pipeLen = minPipeLen +
            ss_fRand( 1.0f - turnFactorMax, 1.0f - turnFactorMin ) * 
                        (maxPipeLen - minPipeLen);

        // turn radius is whatever's left over:
        turnRadius = maxPipeLen - pipeLen + minTurnRadius;

        // draw straight section
        DrawExtrudedXCObject( pipeLen );
        zTrans += pipeLen; // not necessary for now, since elbow no use

        // draw elbow
        // this updates axes, notchVec to position at end of elbow
        DrawXCElbow( newDir, turnRadius );

        zTrans = -(divSize - turnRadius);  // distance back from node
    }
    else {  // no turn
        // draw a straight pipe through the current node
        // length can vary according to the turnFactors (e.g. for high turn
        // factors draw a short pipe, so next turn can be as big as possible)

        minPipeLen = -zTrans; // brings us just up to last node
        maxPipeLen = minPipeLen + divSize - xcCur->MaxExtent();
        // brings us as close as possible to new node

        pipeLen = minPipeLen +
            ss_fRand( 1.0f - turnFactorMax, 1.0f - turnFactorMin ) * 
                        (maxPipeLen - minPipeLen);

        // draw pipe
        DrawExtrudedXCObject( pipeLen );
        zTrans += (-divSize + pipeLen);
    }

    UpdateCurrentPosition( newDir );

    lastDir = newDir;
}

/**************************************************************************\
* DrawTurningXCPipe
*
* Draws the pipe using only turns
*
* - Go straight if no turns available
*
* History
*  Aug 10, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
TURNING_FLEX_PIPE::Draw()
{
    float turnRadius;
    int newDir;
    NODE_ARRAY *nodes = pState->nodes;
    float divSize = pState->view.divSize;

    // get new direction

    //mf: pipe may have gotten stuck on Start...(we don't check for this)

    newDir = nodes->ChooseNewTurnDirection( &curPos, lastDir );
    if( newDir == DIR_NONE ) {
        status = PIPE_STUCK;
        DrawCap( END_CAP );
        glPopMatrix();
        return;
    }

    if( newDir == DIR_STRAIGHT ) {
        // No turns available - draw straight section and hope for turns
        //  on next iteration
        DrawExtrudedXCObject( divSize );
        UpdateCurrentPosition( lastDir );
        // ! we have to mark node as taken for this case, since
        // ChooseNewTurnDirection doesn't know whether we're taking the
        // straight option or not
        nodes->NodeVisited( &curPos );
    } else {
        // draw turning pipe

        // since xc is always located right at current node, turn radius
        // stays constant at one node division

        turnRadius = divSize;

        DrawXCElbow( newDir, turnRadius );

        // (zTrans stays at 0)

        // need to update 2 nodes
        UpdateCurrentPosition( lastDir );
        UpdateCurrentPosition( newDir );

        lastDir = newDir;
    }
}

/**************************************************************************\
* DrawXCElbow
*
* Draw elbow from current position through new direction
*
* - Extends current xc around bend
* - Radius of bend is provided - this is distance from xc center to hinge
*   point, along newDir.  e.g. for 'normal pipes', radius=vc->radius
*
* History
*  Jul. 25, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
FLEX_PIPE::DrawXCElbow( int newDir, float radius )
{
    int relDir;  // 'relative' direction of turn
    float length;

    length = (2.0f * PI * radius) / 4.0f; // average length of elbow

    // calc vDiv, texture params based on length
    //mf: I think we should improve resolution of elbows - more vDiv's
    // could rewrite this fn to take a vDivSize
    CalcEvalLengthParams( length );

    pEval->vOrder = EVAL_ARC_ORDER;

    // convert absolute dir to relative dir
    relDir = GetRelativeDir( lastDir, notchVec, newDir );

    // draw it - call simple bend function

    pEval->ProcessXCPrimBendSimple( xcCur, relDir, radius );

    // set transf. matrix to new position by translating/rotating/translating
    // ! Based on simple elbow
    glTranslatef( 0.0f, 0.0f, radius );
    switch( relDir ) {
        case PLUS_X:
            glRotatef( 90.0f, 0.0f, 1.0f, 0.0f );
            break;
        case MINUS_X:
            glRotatef( -90.0f, 0.0f, 1.0f, 0.0f );
            break;
        case PLUS_Y:
            glRotatef( -90.0f, 1.0f, 0.0f, 0.0f );
            break;
        case MINUS_Y:
            glRotatef( 90.0f, 1.0f, 0.0f, 0.0f );
            break;
    }
    glTranslatef( 0.0f, 0.0f, radius );
    
    // update notch vector using old function
    notchVec = notchTurn[lastDir][newDir][notchVec];
}

/**************************************************************************\
* DrawExtrudedXCObject
*
* Draws object generated by extruding the current xc
*
* Object starts at xc at origin in z=0 plane, and grows along +z axis 
*
* History
*  July 5, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
FLEX_PIPE::DrawExtrudedXCObject( float length )
{
    // calc vDiv, and texture coord stuff based on length
    // this also calcs pEval texture ctrl pt arrray now
    CalcEvalLengthParams( length );

    // we can fill in some more stuff:
    pEval->vOrder = EVAL_CYLINDER_ORDER;

#if 0
    // continuity stuff
    prim.contStart = prim.contEnd = CONT_1; // geometric continuity
#endif

    // draw it

//mf: this fn doesn't really handle continutity for 2 different xc's, so
// may as well pass it one xc
    pEval->ProcessXCPrimLinear( xcCur, xcCur, length );

    // update state draw axes position
    glTranslatef( 0.0f, 0.0f, length );
}

/**************************************************************************\
* DrawXCCap
*
* Cap the start of the pipe
*
* Needs newDir, so it can orient itself.
* Cap ends at current position with approppriate profile, starts a distance
* 'z' back along newDir.
* Profile is a singularity at start point.
*       
* History
*  July 22, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
FLEX_PIPE::DrawCap( int type )
{
    float radius;
    XC *xc = xcCur;
    BOOL bOpening = (type == START_CAP) ? TRUE : FALSE;
    float length;

    // set radius as average of the bounding box min/max's
    radius = ((xc->xRight - xc->xLeft) + (xc->yTop - xc->yBottom)) / 4.0f;

    length = (2.0f * PI * radius) / 4.0f; // average length of arc

    // calc vDiv, and texture coord stuff based on length
    CalcEvalLengthParams( length );

    // we can fill in some more stuff:
    pEval->vOrder = EVAL_ARC_ORDER;

    // draw it

    pEval->ProcessXCPrimSingularity( xc, radius, bOpening );
}

/**************************************************************************\
* CalcEvalLengthParams 
*
* Calculate pEval values that depend on the length of the extruded object
*
* - calculate vDiv, s_start, s_end, and the texture control net array
*
* History
*  July 13, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
FLEX_PIPE::CalcEvalLengthParams( float length )
{
    pEval->vDiv = (int ) SS_ROUND_UP( length / evalDivSize ); 

    // calc texture start and end coords

    if( bTexture ) {
        GLfloat s_delta;

        // Don't let s_end overflow : it should stay in range (0..1.0)
        if( s_end > 1.0f )
            s_end -= (int) s_end;

        s_start = s_end;
        s_delta = (length / s_length );
        s_end = s_start + s_delta;
        
        // the texture ctrl point array can be calc'd here - it is always
        // a simple 2x2 array for each section
        pEval->SetTextureControlPoints( s_start, s_end, t_start, t_end );
    }
}

/**************************************************************************\
*
* GetRelativeDir 
*
* Calculates relative direction of turn from lastDir, notchVec, newDir
*
* - Use look up table for now.
* - Relative direction is from xy-plane, and can be +x,-x,+y,-y   
* - In current orientation, +z is along lastDir, +x along notchVec
*
* History
*  July 27, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

// this array tells you relative turn
// format: relDir[lastDir][notchVec][newDir]
static int relDir[NUM_DIRS][NUM_DIRS][NUM_DIRS] = {
//      +x      -x      +y      -y      +z      -z (newDir)
// lastDir = +x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Y, MINUS_Y,
        iXX,    iXX,    MINUS_X,PLUS_X, MINUS_Y,PLUS_Y,
        iXX,    iXX,    MINUS_Y,PLUS_Y, PLUS_X, MINUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,
// lastDir = -x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,MINUS_Y,PLUS_Y,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Y, MINUS_Y,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
        iXX,    iXX,    MINUS_Y,PLUS_Y, MINUS_X,PLUS_X,
// lastDir = +y
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,
        MINUS_X,PLUS_X, iXX,    iXX,    PLUS_Y, MINUS_Y,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_X, MINUS_X,
        MINUS_Y,PLUS_Y, iXX,    iXX,    MINUS_X,PLUS_X,
// lastDir = -y
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
        MINUS_X,PLUS_X, iXX,    iXX,    MINUS_Y,PLUS_Y,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_X, MINUS_X,
        PLUS_Y, MINUS_Y,iXX,    iXX,    MINUS_X,PLUS_X,

// lastDir = +z
        PLUS_X, MINUS_X,PLUS_Y, MINUS_Y,iXX,    iXX,
        MINUS_X,PLUS_X, MINUS_Y,PLUS_Y, iXX,    iXX,
        MINUS_Y,PLUS_Y, PLUS_X, MINUS_X,iXX,    iXX,
        PLUS_Y, MINUS_Y,MINUS_X,PLUS_X, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
// lastDir = -z
        PLUS_X, MINUS_X,MINUS_Y,PLUS_Y, iXX,    iXX,
        MINUS_X,PLUS_X, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,iXX,    iXX,
        MINUS_Y,PLUS_Y, MINUS_X,PLUS_X, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX
};

static int
GetRelativeDir( int lastDir, int notchVec, int newDir )
{
    return( relDir[lastDir][notchVec][newDir] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\fstate.cxx ===
/******************************Module*Header*******************************\
* Module Name: fstate.cxx
*
* FLEX_STATE
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "fstate.h"
#include "nstate.h"
#include "npipe.h"
#include "fpipe.h"

/******************************Public*Rout